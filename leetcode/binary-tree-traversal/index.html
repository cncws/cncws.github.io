<!DOCTYPE html><html lang="zh-CN,en,default"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/uploads/icon/drop/128x128.png"><link rel="icon" type="image/png" sizes="32x32" href="/uploads/icon/drop/32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/uploads/icon/drop/16x16.png"><link rel="mask-icon" href="/uploads/icon/drop/drop.svg" color="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="NKt2iJb3Hnl6-Sm7LB-fTT7LRyi9cg5yZrB-zd0ohtk"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"cwscn.github.io",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1,width:240},copycode:{enable:!0,show_result:!0,style:"flat"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"manual"},fancybox:!1,mediumzoom:!0,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"fadeIn"}},path:"search.xml"}</script><meta name="description" content="Pre/In/Post Order Given a binary tree, return the preorder/inorder/postorder traversal of its nodes&apos; values. # Definition for a binary tree node.class TreeNode:    def __init__(self, val=0, left=None,"><meta name="keywords" content="栈,递归,LeetCode,遍历"><meta property="og:type" content="article"><meta property="og:title" content="Binary Tree Traversal"><meta property="og:url" content="https://cwscn.github.io/leetcode/binary-tree-traversal/index.html"><meta property="og:site_name" content="春夏秋冬"><meta property="og:description" content="Pre/In/Post Order Given a binary tree, return the preorder/inorder/postorder traversal of its nodes&apos; values. # Definition for a binary tree node.class TreeNode:    def __init__(self, val=0, left=None,"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://cwscn.github.io/uploads/image/leetcode/traversal.png"><meta property="og:updated_time" content="2020-08-09T01:41:41.219Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Binary Tree Traversal"><meta name="twitter:description" content="Pre/In/Post Order Given a binary tree, return the preorder/inorder/postorder traversal of its nodes&apos; values. # Definition for a binary tree node.class TreeNode:    def __init__(self, val=0, left=None,"><meta name="twitter:image" content="https://cwscn.github.io/uploads/image/leetcode/traversal.png"><link rel="canonical" href="https://cwscn.github.io/leetcode/binary-tree-traversal/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css"><link rel="stylesheet" href="//unpkg.com/video.js/dist/video-js.min.css"><link rel="stylesheet" href="/css/videojs-bilibili.css"><style>.aplayer.aplayer-arrow .aplayer-icon-loop,.aplayer.aplayer-arrow .aplayer-icon-order{display:inline-block}</style><title>Binary Tree Traversal | 春夏秋冬</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">春夏秋冬</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">愿你走出半生 归来仍是少年</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档<span class="badge">255</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类<span class="badge">24</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签<span class="badge">108</span></a></li><li class="menu-item menu-item-收藏"><a href="/favlist/" rel="section"><i class="fa fa-star fa-fw"></i> 收藏</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div><meting-js server="netease" type="playlist" id="67155774" theme="#ff5555" loop="all" order="list" preload="none" volume="" mutex="" list-folded="NaN" fixed="true"></meting-js></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwscn.github.io/leetcode/binary-tree-traversal/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar/nekosensei.png"><meta itemprop="name" content="菜农陈文生"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="春夏秋冬"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Binary Tree Traversal</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-08-09 09:41:41" itemprop="dateModified" datetime="2020-08-09T09:41:41+08:00">2020-08-09</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span></span><span id="/leetcode/binary-tree-traversal/" class="post-meta-item leancloud_visitors" data-flag-title="Binary Tree Traversal" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/leetcode/binary-tree-traversal/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/leetcode/binary-tree-traversal/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="preinpost-order">Pre/In/Post Order</h1><p>Given a binary tree, return the <em>preorder/inorder/postorder</em> traversal of its nodes' values.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure><h2 id="recursion">Recursion</h2><p><img src="/uploads/image/leetcode/traversal.png"></p><p>Here the nodes are enumerated in the order you visit them, and you could follow <code>1-2-3-4-5</code> to compare different strategies.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root, res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                res.append(root.val)</span><br><span class="line">                helper(root.left, res)</span><br><span class="line">                helper(root.right, res)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        helper(root, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root, res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                helper(root.left, res)</span><br><span class="line">                res.append(root.val)</span><br><span class="line">                helper(root.right, res)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        helper(root, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root, res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                helper(root.left, res)</span><br><span class="line">                helper(root.right, res)</span><br><span class="line">                res.append(root.val)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        helper(root, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="iterating-method-using-stack">Iterating method using stack</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        res, stack = [], [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            curr = stack.pop()   <span class="comment"># first, visit</span></span><br><span class="line">            res.append(curr.val)</span><br><span class="line">            <span class="keyword">if</span> curr.right:       <span class="comment"># then, push right child</span></span><br><span class="line">                stack.append(curr.right)</span><br><span class="line">            <span class="keyword">if</span> curr.left:        <span class="comment"># last, push left child</span></span><br><span class="line">                stack.append(curr.left)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        res, stack = [], []</span><br><span class="line">        curr = root</span><br><span class="line">        <span class="keyword">while</span> curr <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> curr:</span><br><span class="line">                stack.append(curr)</span><br><span class="line">                curr = curr.left</span><br><span class="line">            curr = stack.pop()    <span class="comment"># Visit leftmost node, or you can image it as</span></span><br><span class="line">            res.append(curr.val)  <span class="comment"># the parent of a None node. Then, we need to</span></span><br><span class="line">            curr = curr.right     <span class="comment"># visit it's right subtree.</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        res, stack = [], []</span><br><span class="line">        curr, last_visit = root, <span class="literal">None</span>  <span class="comment"># need a variable to record if right subtree is visited</span></span><br><span class="line">        <span class="keyword">while</span> curr <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> curr:</span><br><span class="line">                stack.append(curr)</span><br><span class="line">                curr = curr.left</span><br><span class="line">            peek = stack[<span class="number">-1</span>]           <span class="comment"># leftmost node (parent node of a None node)</span></span><br><span class="line">            <span class="keyword">if</span> peek.right <span class="keyword">and</span> peek.right != last_visit:  <span class="comment"># if it's right subtree is not visited yet</span></span><br><span class="line">                curr = peek.right                          <span class="comment"># to visit it</span></span><br><span class="line">            <span class="keyword">else</span>:                                        <span class="comment"># else</span></span><br><span class="line">                last_visit = stack.pop()</span><br><span class="line">                res.append(last_visit.val)                 <span class="comment"># visit parent</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br><span class="line">   / \</span><br><span class="line">  6   7</span><br></pre></td></tr></table></figure><ul><li>Preorder: [1, 2, 4, 5, 6, 7, 3]</li></ul><table><thead><tr class="header"><th>res</th><th>stack</th></tr></thead><tbody><tr class="odd"><td>1</td><td>3, 2</td></tr><tr class="even"><td>1, 2</td><td>3, 5, 4</td></tr><tr class="odd"><td>1, 2, 4</td><td>3, 5</td></tr><tr class="even"><td>1, 2, 4, 5</td><td>3, 7, 6</td></tr><tr class="odd"><td>1, 2, 4, 5, 6</td><td>3, 7</td></tr><tr class="even"><td>1, 2, 4, 5, 6, 7</td><td>3</td></tr><tr class="odd"><td>1, 2, 4, 5, 6, 7, 3</td><td></td></tr></tbody></table><ul><li>Inorder: [4, 2, 6, 5, 7, 1, 3]</li></ul><table><thead><tr class="header"><th>res</th><th>curr</th><th>stack</th><th>explanation</th></tr></thead><tbody><tr class="odd"><td></td><td>1</td><td></td><td></td></tr><tr class="even"><td></td><td>None</td><td>1, 2, 4</td><td>state when exit the inner loop</td></tr><tr class="odd"><td>4</td><td>None</td><td>1, 2</td><td>curr = 4.right</td></tr><tr class="even"><td>4, 2</td><td>5</td><td>1</td><td>curr = 2.right</td></tr><tr class="odd"><td>4, 2</td><td>None</td><td>1, 5, 6</td><td>state when exit the inner loop</td></tr><tr class="even"><td>4, 2, 6</td><td>None</td><td>1, 5</td><td>curr = 6.right</td></tr><tr class="odd"><td>4, 2, 6, 5</td><td>7</td><td>1</td><td>curr = 5.right</td></tr><tr class="even"><td>4, 2, 6, 5</td><td>None</td><td>1, 7</td><td>state when exit the inner loop</td></tr><tr class="odd"><td>4, 2, 6, 5, 7</td><td>None</td><td>1</td><td>curr = 7.right</td></tr><tr class="even"><td>4, 2, 6, 5, 7, 1</td><td>3</td><td></td><td>stack is empty</td></tr><tr class="odd"><td>4, 2, 6, 5, 7, 1</td><td>None</td><td>3</td><td>state when exit the inner loop</td></tr><tr class="even"><td>4, 2, 6, 5, 7, 1, 3</td><td></td><td></td><td></td></tr></tbody></table><ul><li>Postorder: [4, 6, 7, 5, 2, 3, 1]</li></ul><table><thead><tr class="header"><th>res</th><th>curr</th><th>stack</th><th>last_visit</th><th>explanation</th></tr></thead><tbody><tr class="odd"><td></td><td>1</td><td></td><td>None</td><td></td></tr><tr class="even"><td></td><td>None</td><td>1, 2, 4</td><td>None</td><td>state when exit the inner loop</td></tr><tr class="odd"><td>4</td><td>None</td><td>1, 2</td><td>4</td><td>stack[-1].right is None</td></tr><tr class="even"><td>4</td><td>5</td><td>1, 2</td><td>4</td><td></td></tr><tr class="odd"><td>4</td><td>None</td><td>1, 2, 5, 6</td><td>4</td><td>state when exit the inner loop</td></tr><tr class="even"><td>4, 6</td><td>None</td><td>1, 2, 5</td><td>6</td><td></td></tr><tr class="odd"><td>4, 6</td><td>7</td><td>1, 2, 5</td><td>6</td><td>curr = stack[-1].right</td></tr><tr class="even"><td>4, 6</td><td>None</td><td>1, 2, 5, 7</td><td>6</td><td>state when exit the inner loop</td></tr><tr class="odd"><td>4, 6, 7</td><td>None</td><td>1, 2, 5</td><td>7</td><td>stack[-1].right == last_visit, goto else</td></tr><tr class="even"><td>4, 6, 7, 5</td><td>None</td><td>1, 2</td><td>5</td><td>stack[-1].right == last_visit, goto else</td></tr><tr class="odd"><td>4, 6, 7, 5, 2</td><td>None</td><td>1</td><td>2</td><td></td></tr><tr class="even"><td>4, 6, 7, 5, 2</td><td>3</td><td>1</td><td>2</td><td>curr = stack[-1].right</td></tr><tr class="odd"><td>4, 6, 7, 5, 2</td><td>None</td><td>1, 3</td><td>2</td><td>state when exit the inner loop</td></tr><tr class="even"><td>4, 6, 7, 5, 2, 3</td><td>None</td><td>1</td><td>3</td><td>stack[-1].right == last_visit, goto else</td></tr><tr class="odd"><td>4, 6, 7, 5, 2, 3, 1</td><td>None</td><td></td><td>1</td><td></td></tr></tbody></table><h1 id="morris-inorder-traversal">Morris Inorder Traversal</h1><p>In this method, we have to use a new data structure -- Threaded Binary Tree, and the strategy is as follows:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. Initialize current as root</span><br><span class="line">2. While current is not None</span><br><span class="line">    2.1 If current does not have left child</span><br><span class="line">        a. Add current&apos;s data</span><br><span class="line">        b. Go to the right, i.e. current = current.right</span><br><span class="line">    2.2 Else</span><br><span class="line">        a. In current&apos;s left subtree, make current the right child of the rightmost node</span><br><span class="line">        b. Go to this left child, i.e. current = current.left</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        res = []</span><br><span class="line">        curr, pre = root, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            <span class="keyword">if</span> curr.left:</span><br><span class="line">                pre = curr.left</span><br><span class="line">                <span class="keyword">while</span> pre.right:  <span class="comment"># find rightmost</span></span><br><span class="line">                    pre = pre.right</span><br><span class="line">                pre.right = curr   <span class="comment"># add an edge</span></span><br><span class="line">                temp = curr</span><br><span class="line">                curr = curr.left   <span class="comment"># move to left subtree</span></span><br><span class="line">                temp.left = <span class="literal">None</span>   <span class="comment"># delete an edge, avoid infinite loop</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(curr.val)</span><br><span class="line">                curr = curr.right  <span class="comment"># move to next right node</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>See a simple example to understand how it works:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  2</span><br><span class="line"> / \     Let N(2) represent the node which has value 2.</span><br><span class="line">1   3    curr = N(2) at the beginning.</span><br><span class="line"></span><br><span class="line">  2     N(1) is the rightmost node in left subtree,</span><br><span class="line"> ^ \    which means curr = N(2) is the successor node of N(1).</span><br><span class="line">1   3   So we add an edge N(1).right = N(2), we use &apos;^&apos; represent such edges.</span><br><span class="line">        Then, move curr = N(2).left = N(1).</span><br><span class="line">        And, we deleted the edge N(2).left.</span><br><span class="line"></span><br><span class="line">  2     Now, N(1).left is None, we can visit it.</span><br><span class="line"> ^ \    We added a &apos;.&apos; to represent a node has been visited.</span><br><span class="line">1.  3   Then, move curr = N(1).right = N(2).    &lt;-- The edge we added makes sense.</span><br><span class="line"></span><br><span class="line">  2.     Again, we check if curr has left child?</span><br><span class="line"> ^ \     No, since we has deleted the edge.</span><br><span class="line">1.  3.   So, we visit N(2).</span><br><span class="line">         Then, move curr = N(2).right = N(3). Visit it.</span><br></pre></td></tr></table></figure><p>As you can see, the tree is modified by algorithm. Can we avoid it?</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        res = []</span><br><span class="line">        curr, pre = root, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            <span class="keyword">if</span> curr.left:</span><br><span class="line">                pre = curr.left</span><br><span class="line">                <span class="comment"># add a condition: pre.right != curr</span></span><br><span class="line">                <span class="keyword">while</span> pre.right <span class="keyword">and</span> pre.right != curr:  <span class="comment"># find rightmost</span></span><br><span class="line">                    pre = pre.right</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> pre.right:  <span class="comment"># right child is None</span></span><br><span class="line">                    pre.right = curr  <span class="comment"># add an edge</span></span><br><span class="line">                    curr = curr.left  <span class="comment"># move to left subtree</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># pre.right == curr, means pre has benn visited</span></span><br><span class="line">                    pre.right = <span class="literal">None</span>  <span class="comment"># delete the edge we added before</span></span><br><span class="line">            res.append(curr.val)</span><br><span class="line">            curr = curr.right  <span class="comment"># move to next right node</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">1   3    curr = N(2) at the beginning.</span><br><span class="line"></span><br><span class="line">   2     N(1).right is None,</span><br><span class="line"> /^ \    So we add an edge N(1).right = N(2).</span><br><span class="line">1    3   Then, move curr = N(2).left = N(1).</span><br><span class="line"></span><br><span class="line">   2     Now, N(1).left is None, we can visit it.</span><br><span class="line"> /^ \    Then, move curr = N(1).right = N(2).</span><br><span class="line">1.   3</span><br><span class="line"></span><br><span class="line">  2.     Here comes the difference.</span><br><span class="line"> /  \    N(2).left = N(1), but N(1).right = curr.</span><br><span class="line">1.   3   Which means, N(1).right is the edge we added before.</span><br><span class="line">         So, we delete N(1).right, and visit curr N(2).</span><br><span class="line">         Then, move curr = curr.right = N(3).</span><br><span class="line"></span><br><span class="line">  2.     Visit N(3).</span><br><span class="line"> /  \    See, the tree is recovered after we traversed it.</span><br><span class="line">1.   3.</span><br></pre></td></tr></table></figure><h1 id="level-order">Level Order</h1><p>Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>Performance of stack and queue:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list, used as stack, append() and pop()</span><br><span class="line">    similar to</span><br><span class="line">collections.deque, used as stack, append() and pop()</span><br><span class="line">    similar to</span><br><span class="line">collections.deque, used as queue, append() and popleft() (or appendleft() and pop())</span><br><span class="line">    better than</span><br><span class="line">queue.Queue, queue, put() and get() (queue is synchronized)</span><br><span class="line">    similar to</span><br><span class="line">queue.LifoQueue, stack, put() and get()</span><br><span class="line">    much much better than</span><br><span class="line">list, used as queue, append() and pop(0) ()</span><br></pre></td></tr></table></figure><p>Docs:</p><p><a href="https://devdocs.io/python~3.6/library/queue" target="_blank" rel="noopener"><code>queue — A synchronized queue class</code></a></p><p><a href="https://devdocs.io/python~3.6/library/collections#collections.deque" target="_blank" rel="noopener"><code>collections.deque</code></a></p><h2 id="using-two-queues">Using two queues</h2><p>One queue stores nodes in current level, another stores nodes in next level.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res, cur = [], deque([root])</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            res.append([])</span><br><span class="line">            nxt = deque()  <span class="comment"># next level</span></span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                n = cur.popleft()  <span class="comment"># queue</span></span><br><span class="line">                res[<span class="number">-1</span>].append(n.val)</span><br><span class="line">                <span class="keyword">if</span> n.left:</span><br><span class="line">                    nxt.append(n.left)</span><br><span class="line">                <span class="keyword">if</span> n.right:</span><br><span class="line">                    nxt.append(n.right)</span><br><span class="line">            cur = nxt</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="using-a-queue-and-a-variable">Using a queue and a variable</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        cur, res = deque([root]), []</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            res.append([])</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(cur)):  <span class="comment"># number of nodes in current level</span></span><br><span class="line">                n = cur.popleft()  <span class="comment"># queue</span></span><br><span class="line">                res[<span class="number">-1</span>].append(n.val)</span><br><span class="line">                <span class="keyword">if</span> n.left:</span><br><span class="line">                    cur.append(n.left)</span><br><span class="line">                <span class="keyword">if</span> n.right:</span><br><span class="line">                    cur.append(n.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="zigzag-level-order">Zigzag Level Order</h1><p>Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="using-two-stacks">Using two stacks</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">           1</span><br><span class="line">      /         \</span><br><span class="line">     2           3</span><br><span class="line">   /   \       /   \</span><br><span class="line">  4     5     6     7</span><br><span class="line"> / \   / \   / \   / \</span><br><span class="line">8   9 10 11 12 13 14 15</span><br></pre></td></tr></table></figure><table><thead><tr class="header"><th>visit</th><th>stack1 (current level)</th><th>stack2 (next level)</th></tr></thead><tbody><tr class="odd"><td>1</td><td>2, 3</td><td></td></tr><tr class="even"><td>3</td><td>2</td><td>7, 6</td></tr><tr class="odd"><td>2</td><td></td><td>7, 6, 5, 4</td></tr><tr class="even"><td>4</td><td>8, 9</td><td>7, 6, 5</td></tr><tr class="odd"><td>5</td><td>8, 9, 10, 11</td><td>7, 6</td></tr><tr class="even"><td>6</td><td>8, 9, 10, 11, 12, 13</td><td>7</td></tr><tr class="odd"><td>7</td><td>8, 9, 10, 11, 12, 13, 14, 15</td><td></td></tr><tr class="even"><td>15</td><td>8, 9, 10, 11, 12, 13, 14</td><td></td></tr><tr class="odd"><td>...</td><td></td><td></td></tr></tbody></table><p>We need stack becacuse the visit order is changed each level, the node visit later in previous level, it's children will be visited earlier. That's exactly the property of stack.</p><p>And we need to note that the order to push children into stack is also different by level. From the example, we know if current level is visited from left, the order to push it's childern is (left, right); otherwise, (right, left).</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res, cur = [], deque([root])</span><br><span class="line">        reverse = <span class="literal">True</span>  <span class="comment"># add a flag</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            res.append([])</span><br><span class="line">            nxt = deque()</span><br><span class="line">            reverse = <span class="keyword">not</span> reverse  <span class="comment"># flip when a new level started</span></span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                n = cur.pop()</span><br><span class="line">                res[<span class="number">-1</span>].append(n.val)</span><br><span class="line">                <span class="keyword">if</span> reverse:</span><br><span class="line">                    <span class="keyword">if</span> n.right:</span><br><span class="line">                        nxt.append(n.right)</span><br><span class="line">                    <span class="keyword">if</span> n.left:</span><br><span class="line">                        nxt.append(n.left)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> n.left:</span><br><span class="line">                        nxt.append(n.left)</span><br><span class="line">                    <span class="keyword">if</span> n.right:</span><br><span class="line">                        nxt.append(n.right)</span><br><span class="line">            cur = nxt</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="popular-posts-header">相关文章</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/leetcode/contruct-binary-tree-from-traversal/" rel="bookmark">Contruct Binary Tree from Traversal</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/leetcode/flatten-binary-tree-to-linked-list/" rel="bookmark">114. Flatten Binary Tree to Linked List</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/leetcode/k-sum/" rel="bookmark">k Sum</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/leetcode/symmetric-and-same-tree/" rel="bookmark">Symmetric Tree and Same Tree</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/introduction-to-algorithms/breadth-first-search-and-depth-first-search/" rel="bookmark">广度优先搜索和深度优先搜索</a></div></li></ul><footer class="post-footer"><div class="post-tags"> <a href="/tags/stack/" rel="tag"># 栈</a> <a href="/tags/recursion/" rel="tag"># 递归</a> <a href="/tags/LeetCode/" rel="tag"># LeetCode</a> <a href="/tags/traversal/" rel="tag"># 遍历</a></div><div class="post-nav"><div class="post-nav-item"><a href="/leetcode/longest-valid-parentheses/" rel="prev" title="32. Longest Valid Parentheses"><i class="fa fa-chevron-left"></i> 32. Longest Valid Parentheses</a></div><div class="post-nav-item"> <a href="/leetcode/edit-distance/" rel="next" title="Edit Distance">Edit Distance<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#preinpost-order"><span class="nav-number">1.</span> <span class="nav-text">Pre/In/Post Order</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#recursion"><span class="nav-number">1.1.</span> <span class="nav-text">Recursion</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iterating-method-using-stack"><span class="nav-number">1.2.</span> <span class="nav-text">Iterating method using stack</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#morris-inorder-traversal"><span class="nav-number">2.</span> <span class="nav-text">Morris Inorder Traversal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#level-order"><span class="nav-number">3.</span> <span class="nav-text">Level Order</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#using-two-queues"><span class="nav-number">3.1.</span> <span class="nav-text">Using two queues</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#using-a-queue-and-a-variable"><span class="nav-number">3.2.</span> <span class="nav-text">Using a queue and a variable</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#zigzag-level-order"><span class="nav-number">4.</span> <span class="nav-text">Zigzag Level Order</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#using-two-stacks"><span class="nav-number">4.1.</span> <span class="nav-text">Using two stacks</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="菜农陈文生" src="/uploads/avatar/nekosensei.png"><p class="site-author-name" itemprop="name">菜农陈文生</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">255</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">24</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">108</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/cncws" title="GitHub → https://github.com/cncws" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a></span><span class="links-of-author-item"><a href="mailto:1031616423@qq.com" title="E-Mail → mailto:1031616423@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">菜农陈文生</span></div><script src="//cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="//cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script><script src="/js/aplayer-el.js"></script><script src="//unpkg.com/video.js/dist/video.min.js"></script><script src="/js/videojs-bilibili.js"></script><script src="/js/videojs-bilibili-el.js"></script></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script><script src="/js/local-search.js"></script><div id="pjax"><script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Axl15EIRi5o5AatKaxXxV4Oq-gzGzoHsz',
      appKey     : 'E0qm04UjsP0qQN1l8ME3GQ25',
      placeholder: "Just go go",
      avatar     : 'identicon',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script></div></body></html>