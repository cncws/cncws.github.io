<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>水滴</title>
  
  <subtitle>愿你走出半生 归来仍是少年</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cwscn.github.io/"/>
  <updated>2020-07-17T05:24:30.461Z</updated>
  <id>https://cwscn.github.io/</id>
  
  <author>
    <name>菜农陈文生</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Continuous Subarray Sum</title>
    <link href="https://cwscn.github.io/programming/leetcode/continuous-subarray-sum/"/>
    <id>https://cwscn.github.io/programming/leetcode/continuous-subarray-sum/</id>
    <published>2020-07-17T06:24:23.000Z</published>
    <updated>2020-07-17T05:24:30.461Z</updated>
    
    <content type="html"><![CDATA[<p>Given a list of <strong>non-negative</strong> numbers and a target integer <code>k</code>, write a function to check if the array has a continuous subarray of size at least 2 that sums up to a multiple of <code>k</code>, that is, sums up to <code>n*k</code> where <code>n</code> is also an integer.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [23, 2, 4, 6, 7],  k=6</span><br><span class="line">Output: True</span><br><span class="line">Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [23, 2, 6, 4, 7],  k=6</span><br><span class="line">Output: True</span><br><span class="line">Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.</span><br></pre></td></tr></table></figure><p><strong>Constraints</strong>:</p><ul><li>The length of the array won't exceed 10,000.</li><li>You may assume the sum of all the numbers is in the range of a signed 32-bit integer.</li></ul><h1 id="broute-forse-optimized">Broute Forse Optimized</h1><p>Enumerate all subarray <code>a[i .. j]</code>. Calculate sum... By calcualte accumulated sum of array, we can get sum of any subarray in O(1). See problem <a href="/programming/leetcode/range-sum-query/" title="Range Sum Query">Range Sum Query</a>.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkSubarraySum</span><span class="params">(self, nums: <span class="string">'List[int]'</span>, k: int)</span> -&gt; bool:</span></span><br><span class="line">        accumulated = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            accumulated.append(accumulated[<span class="number">-1</span>] + num)</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n):  <span class="comment"># ensure j &gt; i</span></span><br><span class="line">                <span class="comment"># sum of nums[i .. j], at least two elements</span></span><br><span class="line">                sum_ = accumulated[j + <span class="number">1</span>] - accumulated[i]</span><br><span class="line">                <span class="keyword">if</span> sum_ == k <span class="keyword">or</span> (k != <span class="number">0</span> <span class="keyword">and</span> sum_ % k == <span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="hash-table">Hash Table</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Define nums[i .. j] as the sum of nums[i:j+1].</span><br><span class="line"></span><br><span class="line">If nums[i .. j] % k = 0, then:</span><br><span class="line">nums[0 .. j] % k = (nums[0 .. i-1] + nums[i .. j]) % k</span><br><span class="line">                 = nums[0 .. i-1] % k + nums[i .. j] % k</span><br><span class="line">                 = nums[0 .. i-1] % k + 0</span><br></pre></td></tr></table></figure><a id="more"></a><p>So, there is the algorithm to solve this problem using above property.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(min(n, k))</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkSubarraySum</span><span class="params">(self, nums: <span class="string">'List[int]'</span>, k: int)</span> -&gt; bool:</span></span><br><span class="line">        sum_ = <span class="number">0</span></span><br><span class="line">        hMap = &#123;<span class="number">0</span>: <span class="number">-1</span>&#125;  <span class="comment"># special for the case that subarray start from 0</span></span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            sum_ += n</span><br><span class="line">            <span class="keyword">if</span> k != <span class="number">0</span>:</span><br><span class="line">                sum_ %= k</span><br><span class="line">            <span class="keyword">if</span> sum_ <span class="keyword">in</span> hMap:</span><br><span class="line">                <span class="keyword">if</span> i - hMap[sum_] &gt; <span class="number">1</span>:  <span class="comment"># at least 2 elements</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># if not in, record it in map</span></span><br><span class="line">                hMap[sum_] = i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a list of &lt;strong&gt;non-negative&lt;/strong&gt; numbers and a target integer &lt;code&gt;k&lt;/code&gt;, write a function to check if the array has a continuous subarray of size at least 2 that sums up to a multiple of &lt;code&gt;k&lt;/code&gt;, that is, sums up to &lt;code&gt;n*k&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is also an integer.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: [23, 2, 4, 6, 7],  k=6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: True&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Example 2:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: [23, 2, 6, 4, 7],  k=6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: True&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;Constraints&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The length of the array won&#39;t exceed 10,000.&lt;/li&gt;
&lt;li&gt;You may assume the sum of all the numbers is in the range of a signed 32-bit integer.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;broute-forse-optimized&quot;&gt;Broute Forse Optimized&lt;/h1&gt;
&lt;p&gt;Enumerate all subarray &lt;code&gt;a[i .. j]&lt;/code&gt;. Calculate sum... By calcualte accumulated sum of array, we can get sum of any subarray in O(1). See problem &lt;a href=&quot;/programming/leetcode/range-sum-query/&quot; title=&quot;Range Sum Query&quot;&gt;Range Sum Query&lt;/a&gt;.&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Time: O(n^2)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Space: O(n)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;checkSubarraySum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, nums: &lt;span class=&quot;string&quot;&gt;&#39;List[int]&#39;&lt;/span&gt;, k: int)&lt;/span&gt; -&amp;gt; bool:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        accumulated = [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; num &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; nums:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            accumulated.append(accumulated[&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;] + num)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        n = len(nums)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, n - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(i + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, n):  &lt;span class=&quot;comment&quot;&gt;# ensure j &amp;gt; i&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;# sum of nums[i .. j], at least two elements&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                sum_ = accumulated[j + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] - accumulated[i]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; sum_ == k &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; (k != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; sum_ % k == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;False&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;hash-table&quot;&gt;Hash Table&lt;/h1&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Define nums[i .. j] as the sum of nums[i:j+1].&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;If nums[i .. j] % k = 0, then:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums[0 .. j] % k = (nums[0 .. i-1] + nums[i .. j]) % k&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 = nums[0 .. i-1] % k + nums[i .. j] % k&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 = nums[0 .. i-1] % k + 0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://cwscn.github.io/categories/programming/"/>
    
    
      <category term="leetcode" scheme="https://cwscn.github.io/tags/leetcode/"/>
    
      <category term="array" scheme="https://cwscn.github.io/tags/array/"/>
    
      <category term="hash table" scheme="https://cwscn.github.io/tags/hash-table/"/>
    
  </entry>
  
  <entry>
    <title>Merge Intervals</title>
    <link href="https://cwscn.github.io/programming/leetcode/merge-intervals/"/>
    <id>https://cwscn.github.io/programming/leetcode/merge-intervals/</id>
    <published>2020-07-17T04:55:19.000Z</published>
    <updated>2020-07-17T03:59:55.797Z</updated>
    
    <content type="html"><![CDATA[<p>Given a collection of intervals, merge all overlapping intervals.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">Output: [[1,6],[8,10],[15,18]]</span><br><span class="line">Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [[1,4],[4,5]]</span><br><span class="line">Output: [[1,5]]</span><br><span class="line">Explanation: Intervals [1,4] and [4,5] are considered overlapping.</span><br></pre></td></tr></table></figure><h1 id="sorting">Sorting</h1><p>If we sort the intervals by their start value, then each set of intervals that can be merged will appear as a contiguous &quot;run&quot; in the sorted list.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:  [(1, 9), (2, 5), (19, 20), (10, 11), (12, 20), (0, 3), (0, 1), (0, 2)]</span><br><span class="line">Sorted: [(0, 3), (0, 1), (0, 2), (1, 9), (2, 5), (10, 11), (12, 20), (19, 20)]</span><br><span class="line">         --------------------------------------  --------  ------------------</span><br><span class="line">        [                (0, 9),                 (10, 11),       (12, 20)    ]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n log(n))</span></span><br><span class="line"><span class="comment"># Space: O(1) or O(n), depending on sort algorithm</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals: <span class="string">'List[List[int]]'</span>)</span> -&gt; 'List[List[int]]':</span></span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">or</span> res[<span class="number">-1</span>][<span class="number">1</span>] &lt; x[<span class="number">0</span>]:</span><br><span class="line">                res.append(x)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[<span class="number">-1</span>][<span class="number">1</span>] = max(res[<span class="number">-1</span>][<span class="number">1</span>], x[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="counting-sort">Counting Sort</h1><p>This approach works like counting sort. Create a long enough array <code>a</code>:</p><ol type="1"><li>Scan each interval, for start value, <code>a[start] += 1</code>; for end value, <code>a[end] -= 1</code>.</li><li>Calculate accumulated sum of <code>a</code>. The merged interval always end at <code>j</code> where <code>a[j] == 0</code>. However, it can start from <code>i</code> where <code>a[i] == 0</code> also. That's a special interval we need to consider.</li></ol><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">         Overlapping                Containing   Special</span><br><span class="line">Input:  [[3,5],[4,6], [0,1],[1,2], [7,10],[8,9], [11,11]]</span><br><span class="line"></span><br><span class="line">index:  0  1  2  3  4  5  6  7  8  9  10  11</span><br><span class="line">array:  x  x  x  x  x  x  x  x  x  x   x   x   # x means no value</span><br><span class="line"> scan:  1  0 -1  1  1 -1 -1  1  1 -1  -1   0</span><br><span class="line"> accu:  1  1  0  1  2  1  0  1  2  1   0   0</span><br><span class="line">        &lt;     &gt;  &lt;        &gt;  &lt;         &gt;   &lt;&gt;</span><br><span class="line">merge: [ [0,2],    [3,6],     [7,10],      [11,11]  ]</span><br></pre></td></tr></table></figure><p><strong>This variation only works with non-negative values</strong>, you know the reason.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(max(n, m)), m is the greatest end-value of all intervals</span></span><br><span class="line"><span class="comment"># Space: O(m)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals: <span class="string">'List[List[int]]'</span>)</span> -&gt; 'List[List[int]]':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> intervals <span class="keyword">or</span> len(intervals) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> intervals</span><br><span class="line">        <span class="comment"># find max end, or pre-define a large enough value</span></span><br><span class="line">        max_bd = max(end <span class="keyword">for</span> _, end <span class="keyword">in</span> intervals)  <span class="comment"># &lt;-- O(n)</span></span><br><span class="line"></span><br><span class="line">        arr = [<span class="literal">None</span>] * (max_bd + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># a helper function return 0 when value is None</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">read_arr</span><span class="params">(i)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> arr[i] <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> arr[i]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># scan</span></span><br><span class="line">        <span class="keyword">for</span> start, end <span class="keyword">in</span> intervals:  <span class="comment"># &lt;-- O(n)</span></span><br><span class="line">            arr[start] = read_arr(start) + <span class="number">1</span></span><br><span class="line">            arr[end] = read_arr(end) - <span class="number">1</span></span><br><span class="line">        <span class="comment"># accumulate</span></span><br><span class="line">        acc = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(arr):  <span class="comment"># &lt;-- O(m)</span></span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                acc += x</span><br><span class="line">                arr[i] = acc</span><br><span class="line">        <span class="comment"># merge</span></span><br><span class="line">        res = []</span><br><span class="line">        i = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(arr)):  <span class="comment"># &lt;-- O(m)</span></span><br><span class="line">            <span class="keyword">if</span> arr[j] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    i = j</span><br><span class="line">                <span class="keyword">if</span> arr[j] == <span class="number">0</span>:</span><br><span class="line">                    res.append([i, j])</span><br><span class="line">                    i = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="counting-sort-using-dict">Counting Sort using Dict</h1><p>Using dict instead of list, the above method can process negative values. However, can't process decimal values.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(max(n, m)), m is the greatest end-value of all intervals</span></span><br><span class="line"><span class="comment"># Space: O(min(2n, p)), p = len(set(v for v in itv for itv in intervals)),</span></span><br><span class="line"><span class="comment">#        i.e., p is the number of distinct values</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals: <span class="string">'List[List[int]]'</span>)</span> -&gt; 'List[List[int]]':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> intervals <span class="keyword">or</span> len(intervals) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> intervals</span><br><span class="line"></span><br><span class="line">        arr = &#123;&#125;</span><br><span class="line">        min_bd, max_bd = float(<span class="string">'inf'</span>), float(<span class="string">'-inf'</span>)</span><br><span class="line">        <span class="comment"># scan</span></span><br><span class="line">        <span class="keyword">for</span> start, end <span class="keyword">in</span> intervals:  <span class="comment"># &lt;-- O(n)</span></span><br><span class="line">            arr[start] = arr.get(start, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            arr[end] = arr.get(end, <span class="number">0</span>) - <span class="number">1</span></span><br><span class="line">            min_bd = min(min_bd, start)</span><br><span class="line">            max_bd = max(max_bd, end)</span><br><span class="line">        <span class="comment"># accumulate</span></span><br><span class="line">        acc = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(min_bd, max_bd + <span class="number">1</span>):  <span class="comment"># &lt;-- O(m)</span></span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> arr:</span><br><span class="line">                acc += arr[i]</span><br><span class="line">                arr[i] = acc</span><br><span class="line">        <span class="comment"># merge</span></span><br><span class="line">        res = []</span><br><span class="line">        i = min_bd</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(min_bd, max_bd + <span class="number">1</span>):  <span class="comment"># &lt;-- O(m)</span></span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">in</span> arr:</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    i = j  <span class="comment"># j not +1 in this case</span></span><br><span class="line">                <span class="keyword">if</span> arr[j] == <span class="number">0</span>:</span><br><span class="line">                    res.append([i, j])</span><br><span class="line">                    i = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="summary">Summary</h1><table style="width:100%;"><colgroup><col style="width: 16%"><col style="width: 16%"><col style="width: 16%"><col style="width: 16%"><col style="width: 16%"><col style="width: 16%"></colgroup><thead><tr class="header"><th>Method or Algorithm</th><th>Time</th><th>Space</th><th>Can process<br>non-negative values?</th><th>Can process<br>negative values?</th><th>Can process<br>decimal values?</th></tr></thead><tbody><tr class="odd"><td>Sorting</td><td><code>O(n log(n))</code></td><td><code>O(1) or O(n)</code></td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr class="even"><td>Counting Sort</td><td><code>O(max(n, m))</code></td><td><code>O(m)</code></td><td>Yes</td><td>No</td><td>No</td></tr><tr class="odd"><td>Counting Sort using Dict</td><td><code>O(max(n, m))</code></td><td><code>O(min(2n, p))</code></td><td>No</td><td>No</td><td>No</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a collection of intervals, merge all overlapping intervals.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: [[1,3],[2,6],[8,10],[15,18]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: [[1,6],[8,10],[15,18]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Example 2:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: [[1,4],[4,5]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: [[1,5]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: Intervals [1,4] and [4,5] are considered overlapping.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;sorting&quot;&gt;Sorting&lt;/h1&gt;
&lt;p&gt;If we sort the intervals by their start value, then each set of intervals that can be merged will appear as a contiguous &amp;quot;run&amp;quot; in the sorted list.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input:  [(1, 9), (2, 5), (19, 20), (10, 11), (12, 20), (0, 3), (0, 1), (0, 2)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Sorted: [(0, 3), (0, 1), (0, 2), (1, 9), (2, 5), (10, 11), (12, 20), (19, 20)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         --------------------------------------  --------  ------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [                (0, 9),                 (10, 11),       (12, 20)    ]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Time: O(n log(n))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Space: O(1) or O(n), depending on sort algorithm&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;merge&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, intervals: &lt;span class=&quot;string&quot;&gt;&#39;List[List[int]]&#39;&lt;/span&gt;)&lt;/span&gt; -&amp;gt; &#39;List[List[int]]&#39;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        intervals.sort(key=&lt;span class=&quot;keyword&quot;&gt;lambda&lt;/span&gt; x: x[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        res = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; intervals:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; res &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; res[&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] &amp;lt; x[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                res.append(x)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                res[&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = max(res[&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;], x[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;counting-sort&quot;&gt;Counting Sort&lt;/h1&gt;
&lt;p&gt;This approach works like counting sort. Create a long enough array &lt;code&gt;a&lt;/code&gt;:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Scan each interval, for start value, &lt;code&gt;a[start] += 1&lt;/code&gt;; for end value, &lt;code&gt;a[end] -= 1&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Calculate accumulated sum of &lt;code&gt;a&lt;/code&gt;. The merged interval always end at &lt;code&gt;j&lt;/code&gt; where &lt;code&gt;a[j] == 0&lt;/code&gt;. However, it can start from &lt;code&gt;i&lt;/code&gt; where &lt;code&gt;a[i] == 0&lt;/code&gt; also. That&#39;s a special interval we need to consider.&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://cwscn.github.io/categories/programming/"/>
    
    
      <category term="leetcode" scheme="https://cwscn.github.io/tags/leetcode/"/>
    
      <category term="sort" scheme="https://cwscn.github.io/tags/sort/"/>
    
      <category term="counting sort" scheme="https://cwscn.github.io/tags/counting-sort/"/>
    
  </entry>
  
  <entry>
    <title>Kth Largest Element in an Array</title>
    <link href="https://cwscn.github.io/programming/leetcode/kth-largest-element-in-an-array/"/>
    <id>https://cwscn.github.io/programming/leetcode/kth-largest-element-in-an-array/</id>
    <published>2020-07-17T02:15:23.000Z</published>
    <updated>2020-07-17T01:16:13.235Z</updated>
    
    <content type="html"><![CDATA[<p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,2,1,5,6,4] and k = 2</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,2,3,1,2,4,5,5,6] and k = 4</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p>Note: You may assume k is always valid, <code>1 &lt;= k &lt;= array.length</code>.</p><h1 id="quick-sort">Quick Sort</h1><p>kth largest is the (n-k)th element in ordered array.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(log(n))</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, nums, left, right)</span>:</span></span><br><span class="line">        pivot = nums[right]</span><br><span class="line">        i, j = left, right - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># i &lt; hi, j &gt;= lo, can avoid the case i == j after loops</span></span><br><span class="line">            <span class="comment"># i == j will cause infinite loop</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; right <span class="keyword">and</span> nums[i] &lt;= pivot:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= left <span class="keyword">and</span> nums[j] &gt;= pivot:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; j:</span><br><span class="line">                nums[i], nums[right] = nums[right], nums[i]</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="comment"># There is another variation of partition,</span></span><br><span class="line">        <span class="comment"># which is eaiser but not as efficiently as above.</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        pivot, i = a[right], left</span></span><br><span class="line"><span class="string">        for j in range(left, right):</span></span><br><span class="line"><span class="string">            if a[j] &lt; pivot:</span></span><br><span class="line"><span class="string">                a[i], a[j] = a[j], a[i]</span></span><br><span class="line"><span class="string">                i += 1</span></span><br><span class="line"><span class="string">        a[i], a[right] = a[right], a[i]</span></span><br><span class="line"><span class="string">        return i</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">randomizedPartition</span><span class="params">(self, nums, lo, hi)</span>:</span></span><br><span class="line">        i = randint(lo, hi)</span><br><span class="line">        nums[i], nums[hi] = nums[hi], nums[i]</span><br><span class="line">        <span class="keyword">return</span> self.partition(nums, lo, hi)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quickSelect</span><span class="params">(self, nums, lo, hi, t)</span>:</span></span><br><span class="line">        q = self.randomizedPartition(nums, lo, hi)</span><br><span class="line">        <span class="keyword">if</span> q == t:</span><br><span class="line">            <span class="keyword">return</span> nums[t]</span><br><span class="line">        <span class="keyword">elif</span> q &lt; t:</span><br><span class="line">            <span class="keyword">return</span> self.quickSelect(nums, q + <span class="number">1</span>, hi, t)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># q &gt; k</span></span><br><span class="line">            <span class="keyword">return</span> self.quickSelect(nums, lo, q - <span class="number">1</span>, t)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: list, k: int)</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">return</span> self.quickSelect(nums, <span class="number">0</span>, n - <span class="number">1</span>, n - k)</span><br></pre></td></tr></table></figure><h1 id="heap">Heap</h1><p>Using a max heap, pop k-1 times from heap, the current top element is the kth largest element.</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(nlog(n))</span></span><br><span class="line"><span class="comment"># Space: O(log(n)), recursion stack during sift_down</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sift_down</span><span class="params">(self, nums, heap_size, i)</span>:</span></span><br><span class="line">        l, r = (i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>, (i &lt;&lt; <span class="number">1</span>) + <span class="number">2</span></span><br><span class="line">        largest = i</span><br><span class="line">        <span class="keyword">if</span> l &lt; heap_size <span class="keyword">and</span> nums[l] &gt; nums[largest]:</span><br><span class="line">            largest = l</span><br><span class="line">        <span class="keyword">if</span> r &lt; heap_size <span class="keyword">and</span> nums[r] &gt; nums[largest]:</span><br><span class="line">            largest = r</span><br><span class="line">        <span class="keyword">if</span> largest != i:</span><br><span class="line">            nums[largest], nums[i] = nums[i], nums[largest]</span><br><span class="line">            self.sift_down(nums, heap_size, largest)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heapify</span><span class="params">(self, nums, heap_size)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(heap_size &lt;&lt; <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            self.sift_down(nums, heap_size, i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: list, k: int)</span> -&gt; int:</span></span><br><span class="line">        size = len(nums)</span><br><span class="line">        self.heapify(nums, size)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k - <span class="number">1</span>):</span><br><span class="line">            nums[<span class="number">0</span>], nums[size - <span class="number">1</span>] = nums[size - <span class="number">1</span>], nums[<span class="number">0</span>]</span><br><span class="line">            size -= <span class="number">1</span></span><br><span class="line">            self.sift_down(nums, size, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: [3,2,1,5,6,4] and k = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Example 2:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: [3,2,3,1,2,4,5,5,6] and k = 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Note: You may assume k is always valid, &lt;code&gt;1 &amp;lt;= k &amp;lt;= array.length&lt;/code&gt;.&lt;/p&gt;
&lt;h1 id=&quot;quick-sort&quot;&gt;Quick Sort&lt;/h1&gt;
&lt;p&gt;kth largest is the (n-k)th element in ordered array.&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Time: O(n)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Space: O(log(n))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;partition&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, nums, left, right)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        pivot = nums[right]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        i, j = left, right - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;True&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;# i &amp;lt; hi, j &amp;gt;= lo, can avoid the case i == j after loops&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;# i == j will cause infinite loop&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; i &amp;lt; right &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; nums[i] &amp;lt;= pivot:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                i += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; j &amp;gt;= left &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; nums[j] &amp;gt;= pivot:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                j -= &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; i &amp;gt; j:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                nums[i], nums[right] = nums[right], nums[i]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; i&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            nums[i], nums[j] = nums[j], nums[i]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;# There is another variation of partition,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;# which is eaiser but not as efficiently as above.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;        pivot, i = a[right], left&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;        for j in range(left, right):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;            if a[j] &amp;lt; pivot:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;                a[i], a[j] = a[j], a[i]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;                i += 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;        a[i], a[right] = a[right], a[i]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;        return i&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;        &#39;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;randomizedPartition&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, nums, lo, hi)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        i = randint(lo, hi)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        nums[i], nums[hi] = nums[hi], nums[i]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; self.partition(nums, lo, hi)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;quickSelect&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, nums, lo, hi, t)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        q = self.randomizedPartition(nums, lo, hi)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; q == t:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; nums[t]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; q &amp;lt; t:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; self.quickSelect(nums, q + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, hi, t)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:  &lt;span class=&quot;comment&quot;&gt;# q &amp;gt; k&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; self.quickSelect(nums, lo, q - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, t)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;findKthLargest&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, nums: list, k: int)&lt;/span&gt; -&amp;gt; int:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        n = len(nums)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; self.quickSelect(nums, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, n - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, n - k)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;heap&quot;&gt;Heap&lt;/h1&gt;
&lt;p&gt;Using a max heap, pop k-1 times from heap, the current top element is the kth largest element.&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://cwscn.github.io/categories/programming/"/>
    
    
      <category term="recursion" scheme="https://cwscn.github.io/tags/recursion/"/>
    
      <category term="leetcode" scheme="https://cwscn.github.io/tags/leetcode/"/>
    
      <category term="array" scheme="https://cwscn.github.io/tags/array/"/>
    
      <category term="heap" scheme="https://cwscn.github.io/tags/heap/"/>
    
      <category term="quick sort" scheme="https://cwscn.github.io/tags/quick-sort/"/>
    
  </entry>
  
  <entry>
    <title>Lowest Common Ancestor</title>
    <link href="https://cwscn.github.io/programming/leetcode/lowest-common-ancestor/"/>
    <id>https://cwscn.github.io/programming/leetcode/lowest-common-ancestor/</id>
    <published>2020-07-16T01:27:46.000Z</published>
    <updated>2020-07-16T00:53:00.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lca-of-a-binary-tree">LCA of a Binary Tree</h1><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p><p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="noopener">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we <strong>allow a node to be a descendant of itself</strong>).”</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4]</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">   /    \</span><br><span class="line">  5      1</span><br><span class="line"> / \    / \</span><br><span class="line">6   2  0   8</span><br><span class="line">   / \</span><br><span class="line">  7   4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: p = 5, q = 1</span><br><span class="line">Output: 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: p = 5, q = 4</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><p>Note:</p><ul><li>All of the nodes' values will be unique.</li><li><code>p</code> and <code>q</code> are different and both values will exist in the binary tree.</li></ul><h2 id="resursion">Resursion</h2><ul><li><code>left = True</code> if <code>p</code> or <code>q</code> in it's left subtree.</li><li><code>right = True</code> if <code>p</code> or <code>q</code> in it's right subtree.</li><li><code>mid = True</code> if itself is <code>p</code> or <code>q</code></li></ul><p>A node is a LCA of <code>p</code> and <code>q</code> if <code>left + right + mid == 2</code> (two of three become True).</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     3</span><br><span class="line">   /    \</span><br><span class="line">  5      1</span><br><span class="line"> / \    / \</span><br><span class="line">6   2  0   8</span><br><span class="line">   / \</span><br><span class="line">  7   4</span><br><span class="line"></span><br><span class="line">3 is LCA of 5 and 1.      (left == right == True)</span><br><span class="line">5 is LCA of 5 and 4.      (mid == right == True)</span><br><span class="line">5 is LCA of 5 and 6.      (mid == left == True)</span><br><span class="line">5 is not LCA of 2 and 4.  (right == True)</span><br><span class="line"></span><br><span class="line">left == right == mid == Ture never happens.</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n), maximum recursion stack</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: TreeNode, p: TreeNode, q: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        ans = root</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># Left recursion.</span></span><br><span class="line">            left = helper(node.left)</span><br><span class="line">            <span class="comment"># Right recursion.</span></span><br><span class="line">            right = helper(node.right)</span><br><span class="line">            mid = node <span class="keyword">in</span> (p, q)</span><br><span class="line">            <span class="comment"># If any two of the three flags left, right or mid become True.</span></span><br><span class="line">            <span class="keyword">if</span> left + mid + right &gt;= <span class="number">2</span>:</span><br><span class="line">                ans = node</span><br><span class="line">            <span class="keyword">return</span> left <span class="keyword">or</span> mid <span class="keyword">or</span> right</span><br><span class="line"></span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="iterative-using-parent-pointers">Iterative using parent pointers</h2><p>In recursion, the recursion stack let us go back to parent when children are visited. In iteration, we using parent pointers.</p><p>The procedure of iteration:</p><ol type="1"><li>Find path's from root to <code>p</code> and from root to <code>q</code>.</li><li>Backtracking from <code>p</code> to root using parent pointers.</li><li>Backtracking from <code>q</code> to root, the first common node is LCA of <code>p</code> and <code>q</code>.</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: TreeNode, p: TreeNode, q: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        stack, parent = [root], &#123;root: <span class="literal">None</span>&#125;</span><br><span class="line">        <span class="comment"># find paths</span></span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">not</span> <span class="keyword">in</span> parent <span class="keyword">or</span> q <span class="keyword">not</span> <span class="keyword">in</span> parent:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">                parent[node.right] = node</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">                parent[node.left] = node</span><br><span class="line">        <span class="comment"># backtracking p ~&gt; root</span></span><br><span class="line">        ancestors = set()</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            ancestors.add(p)</span><br><span class="line">            p = parent[p]</span><br><span class="line">        <span class="comment"># backtracking q ~&gt; root</span></span><br><span class="line">        <span class="keyword">while</span> q <span class="keyword">not</span> <span class="keyword">in</span> ancestors:</span><br><span class="line">            q = parent[q]</span><br><span class="line">        <span class="keyword">return</span> q</span><br></pre></td></tr></table></figure><h2 id="without-parent-pointers">Without parent pointers</h2><p>When we find one node of <code>p</code> or <code>q</code>, tracking a variable <code>lca</code> to indicate the node where we &quot;split&quot; our path.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     3</span><br><span class="line">   /    \</span><br><span class="line">  5      1</span><br><span class="line"> / \    / \</span><br><span class="line">6   2  0   8</span><br><span class="line">   / \</span><br><span class="line">  7   4</span><br><span class="line"></span><br><span class="line">Input: p = 6, q = 4</span><br><span class="line"></span><br><span class="line">3 -&gt; 5 -&gt; 6.       One node found. lca = 6</span><br><span class="line">3 -&gt; 5             Backtracking.  lca = 5  (lca only move left along the path)</span><br><span class="line">3 -&gt; 5 -&gt; 2 -&gt; 7.</span><br><span class="line">3 -&gt; 5 -&gt; 2</span><br><span class="line">3 -&gt; 5 -&gt; 2 -&gt; 4.  Another node found. return lca = 5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Input: p = 5, q = 4</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">3 -&gt; 5 -&gt; 2 -&gt; 4.  One node found. lca = 4</span><br><span class="line">3 -&gt; 5 -&gt; 2.       Backtracking. lca = 2</span><br><span class="line">3 -&gt; 5.            Another node found. lca = 5</span><br></pre></td></tr></table></figure><h3 id="iteration">Iteration</h3><p>To do this, we need a &quot;path&quot; save the nodes from root to current. We made a little change with stack: add a flag to represent current node's visit state.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: TreeNode, p: TreeNode, q: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        PENDING, HALF_DONE, DONE = <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        stack = [(root, PENDING)]</span><br><span class="line">        one_found, lca_ind = <span class="literal">False</span>, <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node, state = stack[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> state != DONE:</span><br><span class="line">                <span class="keyword">if</span> state == PENDING:  <span class="comment"># PENDING</span></span><br><span class="line">                    <span class="keyword">if</span> node <span class="keyword">in</span> (p, q):</span><br><span class="line">                        <span class="keyword">if</span> one_found:</span><br><span class="line">                            <span class="keyword">return</span> stack[lca_ind][<span class="number">0</span>]</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            one_found = <span class="literal">True</span></span><br><span class="line">                            lca_ind = len(stack) - <span class="number">1</span></span><br><span class="line">                    child = node.left</span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># HALF_DONE</span></span><br><span class="line">                    child = node.right</span><br><span class="line"></span><br><span class="line">                <span class="comment"># update state</span></span><br><span class="line">                stack.pop()</span><br><span class="line">                stack.append((node, state - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> child:</span><br><span class="line">                    stack.append((child, PENDING))</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># DONE</span></span><br><span class="line">                stack.pop()  <span class="comment"># backtracking on path</span></span><br><span class="line">                <span class="keyword">if</span> one_found <span class="keyword">and</span> lca_ind == len(stack):  <span class="comment"># need move left</span></span><br><span class="line">                    lca_ind -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="recursion">Recursion</h3><p>It's easier to keep a path during recursive DFS:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: TreeNode, p: TreeNode, q: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        find_another, lca = <span class="literal">False</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(node, path)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> find_another, lca</span><br><span class="line"></span><br><span class="line">            path.append(node)  <span class="comment"># add current node</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">in</span> (p, q):</span><br><span class="line">                find_another = <span class="keyword">not</span> find_another</span><br><span class="line">                <span class="keyword">if</span> find_another:</span><br><span class="line">                    lca = path[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                helper(node.left, path)  <span class="comment"># go deeper</span></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                helper(node.right, path)</span><br><span class="line">            backed = path.pop()  <span class="comment"># remove current node</span></span><br><span class="line">            <span class="keyword">if</span> find_another <span class="keyword">and</span> lca == backed:</span><br><span class="line">                lca = path[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        helper(root, [])</span><br><span class="line">        <span class="keyword">return</span> lca</span><br></pre></td></tr></table></figure><h1 id="lca-of-binary-search-tree">LCA of Binary Search Tree</h1><p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given binary search tree: root = [6,2,8,0,4,7,9,null,null,3,5]</span><br><span class="line"></span><br><span class="line">     6</span><br><span class="line">   /    \</span><br><span class="line">  2      8</span><br><span class="line"> / \    / \</span><br><span class="line">0   4  7   9</span><br><span class="line">   / \</span><br><span class="line">  3   5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: p = 2, q = 8</span><br><span class="line">Output: 6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: p = 2, q = 4</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Constraints</strong>:</p><ul><li>All of the nodes' values will be unique.</li><li><code>p</code> and <code>q</code> are different and both values will exist in the BST.</li></ul><h2 id="before-coding">Before coding</h2><p>We can solve this using the approaches to find LCA in a binary tree.</p><p>But, binary search tree's property could be utilized, to come up with a better algorithm.</p><p>Lets review properties of a BST:</p><blockquote><ol type="1"><li>Left subtree of a node N contains nodes whose values are lesser than or equal to node N's value.</li><li>Right subtree of a node N contains nodes whose values are greater than node N's value.</li><li>Both left and right subtrees are also BSTs.</li></ol></blockquote><p>The LCA's position:</p><ol type="1"><li>If current node's value lesser than value of <code>p</code> and <code>q</code>, the LCA must exist in current node's right subtree.</li><li>If current node's value greater than value of <code>p</code> and <code>q</code>, the LCA must exist in current node's left subtree.</li><li>If both 1 and 2 are not True, the current node is the LCA.</li></ol><p>The algorithm is based on an important constraint: <code>p</code> and <code>q</code> are different and both values will exist in the BST.</p><h2 id="recursion-1">Recursion</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: TreeNode, p: TreeNode, q: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        min_, max_ = min(p.val, q.val), max(p.val, q.val)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">lca</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> node.val &gt; max_:</span><br><span class="line">                <span class="keyword">return</span> lca(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.val &lt; min_:</span><br><span class="line">                <span class="keyword">return</span> lca(node.right)</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lca(root)</span><br></pre></td></tr></table></figure><h2 id="iteration-1">Iteration</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: TreeNode, p: TreeNode, q: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        min_, max_ = min(p.val, q.val), max(p.val, q.val)</span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            <span class="keyword">if</span> node.val &gt; max_:</span><br><span class="line">                node = node.left</span><br><span class="line">            <span class="keyword">elif</span> node.val &lt; min_:</span><br><span class="line">                node = node.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> node</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lca-of-a-binary-tree&quot;&gt;LCA of a Binary Tree&lt;/h1&gt;
&lt;p&gt;Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.&lt;/p&gt;
&lt;p&gt;According to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Lowest_common_ancestor&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;definition of LCA on Wikipedia&lt;/a&gt;: “The lowest common ancestor is defined between two nodes &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt; as the lowest node in &lt;code&gt;T&lt;/code&gt; that has both &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt; as descendants (where we &lt;strong&gt;allow a node to be a descendant of itself&lt;/strong&gt;).”&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   /    \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  5      1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; / \    / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6   2  0   8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  7   4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Example 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: p = 5, q = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Example 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: p = 5, q = 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Note:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All of the nodes&#39; values will be unique.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt; are different and both values will exist in the binary tree.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;resursion&quot;&gt;Resursion&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;left = True&lt;/code&gt; if &lt;code&gt;p&lt;/code&gt; or &lt;code&gt;q&lt;/code&gt; in it&#39;s left subtree.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;right = True&lt;/code&gt; if &lt;code&gt;p&lt;/code&gt; or &lt;code&gt;q&lt;/code&gt; in it&#39;s right subtree.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mid = True&lt;/code&gt; if itself is &lt;code&gt;p&lt;/code&gt; or &lt;code&gt;q&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A node is a LCA of &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt; if &lt;code&gt;left + right + mid == 2&lt;/code&gt; (two of three become True).&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;     3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   /    \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  5      1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; / \    / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6   2  0   8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  7   4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3 is LCA of 5 and 1.      (left == right == True)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5 is LCA of 5 and 4.      (mid == right == True)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5 is LCA of 5 and 6.      (mid == left == True)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5 is not LCA of 2 and 4.  (right == True)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;left == right == mid == Ture never happens.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Time: O(n)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Space: O(n), maximum recursion stack&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;lowestCommonAncestor&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, root: TreeNode, p: TreeNode, q: TreeNode)&lt;/span&gt; -&amp;gt; TreeNode:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ans = root&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;helper&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(node)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;nonlocal&lt;/span&gt; ans&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; node:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;False&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;# Left recursion.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            left = helper(node.left)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;# Right recursion.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            right = helper(node.right)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mid = node &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; (p, q)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;# If any two of the three flags left, right or mid become True.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; left + mid + right &amp;gt;= &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                ans = node&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; left &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; mid &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; right&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        helper(root)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ans&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://cwscn.github.io/categories/programming/"/>
    
    
      <category term="leetcode" scheme="https://cwscn.github.io/tags/leetcode/"/>
    
      <category term="binary tree" scheme="https://cwscn.github.io/tags/binary-tree/"/>
    
      <category term="BST" scheme="https://cwscn.github.io/tags/BST/"/>
    
  </entry>
  
  <entry>
    <title>Coin Change</title>
    <link href="https://cwscn.github.io/programming/leetcode/coin-change/"/>
    <id>https://cwscn.github.io/programming/leetcode/coin-change/</id>
    <published>2020-07-15T11:17:37.000Z</published>
    <updated>2020-07-16T00:20:59.797Z</updated>
    
    <content type="html"><![CDATA[<p>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: coins = [1, 2, 5], amount = 11</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: coins = [2], amount = 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p>Note: You may assume that you have an infinite number of each kind of coin.</p><h1 id="bottom-up-dp">Bottom-Up DP</h1><p>Let's define <code>dp[s]</code> as the minimum number of coins needed to make change for amount <code>s</code> using coins <code>c</code>.</p><p>Base case: <code>dp[0] = 0</code>.</p><p>Induction rule: <code>dp[s] = ?</code>. If we take a coin <code>c[i]</code> first, then we need <code>dp[s - c[i]] + 1</code> coins. So, <code>dp[s] = min(dp[s - c[i]] | i = 0, 1, ..., n - 1) + 1</code>, i.e., we try every coin.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n * s), n = len(coins), s = amount</span></span><br><span class="line"><span class="comment"># Space: O(s)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: list, amount: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> amount &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dp = [float(<span class="string">'inf'</span>)] * (amount + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(coin, amount + <span class="number">1</span>):  <span class="comment"># x start from coin</span></span><br><span class="line">                dp[x] = min(dp[x], dp[x - coin] + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != float(<span class="string">'inf'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="top-down-dp">Top-Down DP</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n * s), n = len(coins), s = amount</span></span><br><span class="line"><span class="comment"># Space: O(s)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: list, amount: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> amount &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x: int, dp: list)</span> -&gt; int:</span></span><br><span class="line">            <span class="keyword">if</span> x == <span class="number">0</span> <span class="keyword">or</span> dp[x] != <span class="number">0</span>:  <span class="comment"># base case</span></span><br><span class="line">                <span class="keyword">return</span> dp[x]</span><br><span class="line">            <span class="comment"># induction rule</span></span><br><span class="line">            dp[x] = float(<span class="string">'inf'</span>)</span><br><span class="line">            <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">                <span class="keyword">if</span> x &gt;= coin:</span><br><span class="line">                    dp[x] = min(dp[x], helper(x - coin, dp) + <span class="number">1</span>)</span><br><span class="line">            <span class="string">'''</span></span><br><span class="line"><span class="string">            dp[x] = min((helper(x - coin, dp) + 1 for coin in coins</span></span><br><span class="line"><span class="string">                        if x &gt;= coin), default=float('inf'))</span></span><br><span class="line"><span class="string">            '''</span></span><br><span class="line">            <span class="keyword">return</span> dp[x]</span><br><span class="line"></span><br><span class="line">        dp = [<span class="number">0</span>] * (amount + <span class="number">1</span>)</span><br><span class="line">        helper(amount, dp)</span><br><span class="line">        <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != float(<span class="string">'inf'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: coins = [1, 2, 5], amount = 11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: 11 = 5 + 5 + 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Example 2:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: coins = [2], amount = 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: -1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Note: You may assume that you have an infinite number of each kind of coin.&lt;/p&gt;
&lt;h1 id=&quot;bottom-up-dp&quot;&gt;Bottom-Up DP&lt;/h1&gt;
&lt;p&gt;Let&#39;s define &lt;code&gt;dp[s]&lt;/code&gt; as the minimum number of coins needed to make change for amount &lt;code&gt;s&lt;/code&gt; using coins &lt;code&gt;c&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Base case: &lt;code&gt;dp[0] = 0&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Induction rule: &lt;code&gt;dp[s] = ?&lt;/code&gt;. If we take a coin &lt;code&gt;c[i]&lt;/code&gt; first, then we need &lt;code&gt;dp[s - c[i]] + 1&lt;/code&gt; coins. So, &lt;code&gt;dp[s] = min(dp[s - c[i]] | i = 0, 1, ..., n - 1) + 1&lt;/code&gt;, i.e., we try every coin.&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Time: O(n * s), n = len(coins), s = amount&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Space: O(s)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;coinChange&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, coins: list, amount: int)&lt;/span&gt; -&amp;gt; int:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; amount &amp;lt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dp = [float(&lt;span class=&quot;string&quot;&gt;&#39;inf&#39;&lt;/span&gt;)] * (amount + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dp[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; coin &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; coins:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(coin, amount + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;):  &lt;span class=&quot;comment&quot;&gt;# x start from coin&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                dp[x] = min(dp[x], dp[x - coin] + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; dp[amount] &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; dp[amount] != float(&lt;span class=&quot;string&quot;&gt;&#39;inf&#39;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://cwscn.github.io/categories/programming/"/>
    
    
      <category term="leetcode" scheme="https://cwscn.github.io/tags/leetcode/"/>
    
      <category term="dynamic programming" scheme="https://cwscn.github.io/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>Add Strings</title>
    <link href="https://cwscn.github.io/programming/leetcode/add-strings/"/>
    <id>https://cwscn.github.io/programming/leetcode/add-strings/</id>
    <published>2020-07-14T01:10:51.000Z</published>
    <updated>2020-07-14T00:10:54.964Z</updated>
    
    <content type="html"><![CDATA[<p>Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.</p><p><strong>Note</strong>:</p><ul><li>The length of both num1 and num2 is &lt; 5100.</li><li>Both num1 and num2 contains only digits 0-9.</li><li>Both num1 and num2 does not contain any leading zero.</li><li>You must not use any built-in BigInteger library or convert the inputs to integer directly.</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(max(n1, n2)), n1, n2 are the length of num1, num2</span></span><br><span class="line"><span class="comment"># Space: O(max(n1, n2))</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addStrings</span><span class="params">(self, num1: str, num2: str)</span> -&gt; str:</span></span><br><span class="line">        res = []</span><br><span class="line">        i, j, carry = len(num1) - <span class="number">1</span>, len(num2) - <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">or</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            n1 = int(num1[i]) <span class="keyword">if</span> i &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            n2 = int(num2[j]) <span class="keyword">if</span> j &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            tmp = n1 + n2 + carry</span><br><span class="line">            carry = tmp // <span class="number">10</span></span><br><span class="line">            res.append(tmp % <span class="number">10</span>)</span><br><span class="line">            i, j = i - <span class="number">1</span>, j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> carry &gt; <span class="number">0</span>:</span><br><span class="line">            res.append(carry)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(str(x) <span class="keyword">for</span> x <span class="keyword">in</span> reversed(res))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;:&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="编程" scheme="https://cwscn.github.io/categories/programming/"/>
    
    
      <category term="leetcode" scheme="https://cwscn.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Longest Chunked Palindrome Decomposition</title>
    <link href="https://cwscn.github.io/programming/leetcode/longest-chunked-palindrome-decomposition/"/>
    <id>https://cwscn.github.io/programming/leetcode/longest-chunked-palindrome-decomposition/</id>
    <published>2020-07-14T01:09:00.000Z</published>
    <updated>2020-07-14T00:09:43.064Z</updated>
    
    <content type="html"><![CDATA[<p>Return the largest possible <code>k</code> such that there exists <code>a_1, a_2, ..., a_k</code> such that:</p><ul><li>Each <code>a_i</code> is a non-empty string;</li><li>Their concatenation <code>a_1 + a_2 + ... + a_k</code> is equal to text;</li><li>For all <code>1 &lt;= i &lt;= k</code>, <code>a_i = a_{k+1 - i}</code>.</li></ul><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: text = &quot;ghiabcdefhelloadamhelloabcdefghi&quot;</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: We can split the string on &quot;(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)&quot;.</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: text = &quot;merchant&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: We can split the string on &quot;(merchant)&quot;.</span><br></pre></td></tr></table></figure><p>Example 3:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: text = &quot;antaprezatepzapreanta&quot;</span><br><span class="line">Output: 11</span><br><span class="line">Explanation: We can split the string on &quot;(a)(nt)(a)(pre)(za)(tpe)(za)(pre)(a)(nt)(a)&quot;.</span><br></pre></td></tr></table></figure><p>Example 4:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: text = &quot;aaa&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: We can split the string on &quot;(a)(a)(a)&quot;.</span><br></pre></td></tr></table></figure><p>Constraints:</p><ul><li>text consists only of lowercase English characters.</li><li><code>1 &lt;= text.length &lt;= 1000</code></li></ul><h1 id="greedy">Greedy</h1><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: abcdefabc</span><br><span class="line"></span><br><span class="line">1. is a == c ? No</span><br><span class="line">2. is ab == bc ? No</span><br><span class="line">3. is abc == abc ? Yes, res += 2</span><br><span class="line">4. is d == f ? No</span><br><span class="line">5. is de == ef ? No</span><br><span class="line">6. is def == def ? Yes, res += 1</span><br><span class="line"></span><br><span class="line">We must be careful about the case that</span><br><span class="line">a substring crossing the middle point.</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2)</span></span><br><span class="line"><span class="comment"># Space: O(n), the max length of substring we compared can be n/2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestDecomposition</span><span class="params">(self, text: str)</span> -&gt; int:</span></span><br><span class="line">        n = len(text)</span><br><span class="line">        i = res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n // <span class="number">2</span>):  <span class="comment"># move forward end point</span></span><br><span class="line">            <span class="keyword">if</span> text[i:j + <span class="number">1</span>] == text[n - j - <span class="number">1</span>:n - i]:</span><br><span class="line">                res += <span class="number">2</span></span><br><span class="line">                i = j + <span class="number">1</span>  <span class="comment"># new start point</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">2</span> * i &lt; n:  <span class="comment"># middle chunk</span></span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="recursion">Recursion</h1><p>Same procedure implemented by recursion.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2)</span></span><br><span class="line"><span class="comment"># Space: O(n), as much as n/2 recursion depth</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestDecomposition</span><span class="params">(self, text: str)</span> -&gt; int:</span></span><br><span class="line">        n = len(text)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n // <span class="number">2</span> + <span class="number">1</span>):  <span class="comment"># j is the length of substrings we compared</span></span><br><span class="line">            <span class="keyword">if</span> text[<span class="number">0</span>:j] == text[n - j:n]:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">2</span> * j &lt; n:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">2</span> + self.longestDecomposition(text[j:n-j])</span><br><span class="line">                <span class="keyword">elif</span> <span class="number">2</span> * j == n:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># 2 * j &gt; n, substring crossed middle point</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>  <span class="comment"># not matched</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Return the largest possible &lt;code&gt;k&lt;/code&gt; such that there exists &lt;code&gt;a_1, a_2, ..., a_k&lt;/code&gt; such that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Each &lt;code&gt;a_i&lt;/code&gt; is a non-empty string;&lt;/li&gt;
&lt;li&gt;Their concatenation &lt;code&gt;a_1 + a_2 + ... + a_k&lt;/code&gt; is equal to text;&lt;/li&gt;
&lt;li&gt;For all &lt;code&gt;1 &amp;lt;= i &amp;lt;= k&lt;/code&gt;, &lt;code&gt;a_i = a_{k+1 - i}&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example 1:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: text = &amp;quot;ghiabcdefhelloadamhelloabcdefghi&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: We can split the string on &amp;quot;(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)&amp;quot;.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Example 2:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: text = &amp;quot;merchant&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: We can split the string on &amp;quot;(merchant)&amp;quot;.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Example 3:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: text = &amp;quot;antaprezatepzapreanta&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: We can split the string on &amp;quot;(a)(nt)(a)(pre)(za)(tpe)(za)(pre)(a)(nt)(a)&amp;quot;.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Example 4:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: text = &amp;quot;aaa&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: We can split the string on &amp;quot;(a)(a)(a)&amp;quot;.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Constraints:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;text consists only of lowercase English characters.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= text.length &amp;lt;= 1000&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;greedy&quot;&gt;Greedy&lt;/h1&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: abcdefabc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1. is a == c ? No&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2. is ab == bc ? No&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3. is abc == abc ? Yes, res += 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4. is d == f ? No&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5. is de == ef ? No&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6. is def == def ? Yes, res += 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;We must be careful about the case that&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a substring crossing the middle point.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Time: O(n^2)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Space: O(n), the max length of substring we compared can be n/2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;longestDecomposition&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, text: str)&lt;/span&gt; -&amp;gt; int:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        n = len(text)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        i = res = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(n // &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;):  &lt;span class=&quot;comment&quot;&gt;# move forward end point&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; text[i:j + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] == text[n - j - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:n - i]:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                res += &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                i = j + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;# new start point&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; * i &amp;lt; n:  &lt;span class=&quot;comment&quot;&gt;# middle chunk&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            res += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://cwscn.github.io/categories/programming/"/>
    
    
      <category term="recursion" scheme="https://cwscn.github.io/tags/recursion/"/>
    
      <category term="leetcode" scheme="https://cwscn.github.io/tags/leetcode/"/>
    
      <category term="palindrome" scheme="https://cwscn.github.io/tags/palindrome/"/>
    
      <category term="greedy" scheme="https://cwscn.github.io/tags/greedy/"/>
    
  </entry>
  
  <entry>
    <title>网络层</title>
    <link href="https://cwscn.github.io/notes/computer-networking/network-layer/"/>
    <id>https://cwscn.github.io/notes/computer-networking/network-layer/</id>
    <published>2020-07-13T14:16:08.000Z</published>
    <updated>2020-07-13T13:18:42.369Z</updated>
    
    <content type="html"><![CDATA[<p>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网络层不提供服务质量的承诺。如果主机中的进程之间的通信需要是可靠的，那么就由网络的主机中的运输层负责（包括差错处理、流量控制）。采用这种设计思路的好处是：网络造价大大降低，运行方式灵活，能够适应多种应用。</p><h1 id="网际协议-ip">网际协议 IP</h1><p>与 IP 协议配套使用的还有三个协议：</p><ul><li>地址解析协议 ARP（Address Resolution Protocol）</li><li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li><li>网际组管理协议（Internet Group Management Protocol）</li></ul><p>IP 协议使用 ARP 协议。ICMP 和 IGMP 使用 IP 协议。</p><p>将网络互相连接起来要使用一些<strong>中间设备</strong>。根据中间设备所在的层次，可以有以下四种不同的中间设备：</p><ol type="1"><li>物理层使用的中间设备叫做<strong>转发器</strong>（repeater）。</li><li>数据链路层使用的中间设备叫做<strong>网桥</strong>或<strong>桥接器</strong>（bridge）。</li><li>网络层使用的中间设备叫做<strong>路由器</strong>（router）。</li><li>在网络层以上使用的中间设备叫做<strong>网关</strong>（gateway）。用网关连接两个不兼容的系统需要在高层进行协议的转换。</li></ol><p>当中间设备是转发器或网桥时，这仅仅是把一个网络扩大了，而从网络层的角度看，这仍然是一个网络，一般并不称为网络互连。网关由于比较复杂，目前使用得较少。因此讨论网络互连时，都是指用路由器进行网络互连和路由选择。路由器其实就是一台专用计算机，用来在互联网中进行路由选择。由于历史的原因，许多有关 TCP/IP 的文献曾经把网络层使用的路由器称为网关，本书有时也这样用。</p><h1 id="ip-地址">IP 地址</h1><p>整个的互联网就是一个单一的、抽象的网络。IP 地址就是给互联网上的每一台主机（或路由器）的每一个接口分配一个在全世界范围内唯一的 32 位的标识符。IP 地址的编址方式经过了三个历史阶段。</p><ol type="1"><li>分类的 IP 地址。最基本的编址方法。</li><li>子网的划分。对最基本的编址方法的改进。</li><li>构成超网。无分配编址方法。已被广泛使用。</li></ol><h1 id="分类的-ip-地址">分类的 IP 地址</h1><table><tr><th>网络类别</th><th>类别位</th><th>网络号</th><th>主机号</th></tr><tr><td>A</td><td>0</td><td>8 位</td><td>24 位</td></tr><tr><td>B</td><td>10</td><td>16 位</td><td>16 位</td></tr><tr><td>C</td><td>110</td><td>24 位</td><td>8 位</td></tr><tr><td>D</td><td>1110</td><td colspan="2" style="text-align: center;">多播地址</td></tr><tr><td>E</td><td>1111</td><td colspan="2" style="text-align: center;">保留为今后使用</td></tr></table><a id="more"></a><p>申请 IP 地址时，实际上是获得了具有同样网络号的一块地址。其中具体的各台主机号则由单位自行分配，只要做到在该单位管辖的范围内无重复的主机号即可。</p><p>A 类地址的网络号的第一位固定为 0，因此 A 类地址空间共有 2^31 个地址，占整个 IP 地址空间的 50%。同理，B 类占 25%，C 类占 12.5%。</p><p>全 0 的主机号字段表示该 IP 地址是“本主机”所连接到的<strong>一个网络的地址</strong>（例如，一主机的 IP 地址为 5.6.7.8，则该主机所在的网络地址就是 5.0.0.0），而全 1 表示“<strong>所有的</strong>”，全 1 的主机号字段表示该网络上的所有主机。</p><table><thead><tr class="header"><th>网络类别</th><th>最大可指派网络数</th><th>不指派网络号</th><th>第一个可指派的网络号</th><th>最后一个可指派的网络号</th><th>最大主机数</th></tr></thead><tbody><tr class="odd"><td>A</td><td>2^7 - 2</td><td>0 和 127</td><td>1</td><td>126</td><td>2^24 - 2</td></tr><tr class="even"><td>B</td><td>2^14 - 1</td><td>128.0</td><td>128.1</td><td>191.255</td><td>2^16 - 2</td></tr><tr class="odd"><td>C</td><td>2^21 - 1</td><td>192.0.0</td><td>192.0.1</td><td>223.255.255</td><td>2^8 - 2</td></tr></tbody></table><p>A 类地址的网络号有 7 位可用，但可指派的网络号是 2^7 - 2 = 126 个。减 2 的原因是：第一，网络号字段全 0 的 IP 地址是个保留地址，意思是”<strong>本网络</strong>“；第二，网络号为 127（即 01111111）保留作为本地软件<strong>环回测试</strong>（loopback test）本主机的进程之间的通信之用。若主机发送一个目的地址为环回地址（例如 127.0.0.1）的 IP 数据报，则本主机中的协议软件就会处理数据报中的数据，而不会把数据报发送到任何网络。目的地址为环回地址的 IP 数据报永远不会出现在任何网络上，因为网络号为 127 的地址根本不是一个网络地址。</p><p>IP 地址具有以下一些重要特点。</p><ol type="1"><li>每一个 IP 地址都由网络号和主机号两部分组成。这样做有两个好处：第一，<strong>方便 IP 地址的管理</strong>，IP 地址管理机构在分配 IP 地址时只分配网络号，而主机号由单位自行分配。第二，路由器仅<strong>根据目的主机所连接的网络号来转发分组</strong>，这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间以及查找路由表的时间。</li><li>实际上 IP 地址是标志一台主机（或路由器）和一条链路的<strong>接口</strong>。当一台主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号必须是不同的。这种主机称为<strong>多归属主机</strong>（multihomed host）。<strong>由于一个路由器至少应当连接到两个网络，因此一个路由器至少应当有两个不同的 IP 地址</strong>。</li><li>按照互联网的观点，一个网络是指具有相同网络号的主机的集合。因此，用转发器或网桥连接起来的若干个局域网仍为一个网络。具有不同网络号的局域网必须使用路由器进行连接。</li><li>在 IP 地址中，所有分配到网络号的网络都是<strong>平等</strong>的。所谓平等，只是互联网同等对待每一个 IP 地址。</li></ol><h2 id="ip-地址和硬件地址">IP 地址和硬件地址</h2><p>硬件地址（物理地址，MAC 地址）是数据链路层和物理层使用的地址，而 IP 地址是网络层和以上各层使用的地址，是一种逻辑地址，是用软件实现的。</p><p><img src="/uploads/image/computer-networking/ip-address-and-hardware-address.jpeg"></p><p>路由器同时连接到两个网络上时，必须具有两个不同的 IP 地址，也要有两个硬件地址。</p><p>在网络层只能看到 IP 数据报，数据报被转发时，首部中的源地址和目的地址始终不变。在链路层只能看到 MAC 帧，IP 数据报被封装在 MAC 帧中。MAC 帧在不同的网络上传送时，其首部中的源地址和目的地址要发生变化。</p><h2 id="地址解析协议-arp">地址解析协议 ARP</h2><p>由于是 IP 地址使用了 ARP 协议，因此通常就把 ARP 协议划归网络层。</p><p>每一台主机都设有一个 ARP 高速缓存，里面有<strong>本局域网</strong>上的各主机和路由器的 IP 地址到硬件地址的映射表。注意，ARP 是解决同一个局域网上的主机和路由器的 IP 地址和硬件地址的映射问题。主机不需要知道远程主机的硬件地址，只需要知道它的 IP 地址。IP 数据报通过连在同一个局域网的路由器来转发，最终到达目标网络的路由器上，再用类似方法解析出目的主机的硬件地址并交付。</p><p>当主机 A 要向<strong>本局域网</strong>上的主机 B 发送 IP 数据报时，先在 ARP 高速缓存中查看有无主机 B 的 IP 地址。如有，就查出其对应的硬件地址，再把这个硬件地址写入 MAC 帧，然后通过局域网发送该 MAC 帧。若无，主机 A 按以下步骤找出主机 B 的硬件地址。</p><ol type="1"><li>在本局域网上<strong>广播</strong>发送一个 ARP 请求分组，主要内容是：“我的 IP 地址是 ... 硬件地址是 ... 我想知道 IP 地址为 .. 的主机的硬件地址。“</li><li>在本局域网上的所有主机都收到此 ARP 请求分组。若主机的 IP 地址与 ARP 请求分组中要查询的 IP 地址不一致，就不理睬这个请求分组。（也有可能理睬一下，更新自己的 ARP 缓存，写入主机 A 的 IP 地址和硬件地址）</li><li>主机 B 的 IP 地址与请求分组中要查询的 IP 地址一致，就收下这个请求分组（同时更新 ARP 缓存写入主机 A 的 IP 地址和硬件地址），并向主机 A 发送 ARP 响应分组（<strong>单播</strong>），在这个响应分组中写入自己的硬件地址。</li><li>主机 A 收到响应分组后，就在其 ARP 高速缓存中写入主机 B 的 IP 地址到硬件地址的映射。</li></ol><p>ARP 对保存在高速缓存中的每一个映射地址都设置<strong>生存时间</strong>。当硬件地址发生改变时，能通过 ARP 再次查询新的地址。</p><h2 id="ip-数据报的格式">IP 数据报的格式</h2><p><img src="/uploads/image/computer-networking/ip-header.jpeg"></p><ul><li>版本：4（IPv4）或 6（IPv6）</li><li>首部长度：单位是 4 字节，因此最小值是 5（只有固定首部，没有数据），最大值 15，即 60 字节。当首部长度不是 4 字节的整数倍时，必须利用填充字段加以填充（全 0）。</li><li><p>总长度：单位是字节，因此数据报的最大长度为 2^16 - 1 = 65535 字节。然而传送这样长的数据报在现实中极少遇到。IP 层下面的每一种数据链路层协议都规定了一个数据帧中的<strong>数据字段的最大长度</strong>，称为<strong>最大传送单元</strong> MTU（Maximum Transfer Unit）。当一个 IP 数据报封装成链路层的帧时，总长度不能超过 MTU，否则必须把过长的数据报进行分片处理。</p><p>使用尽可能长的 IP 数据报会使传输效率得到提高，但数据报短些也有好处。每一个 IP 数据报越短，路由器转发的速度就越快。为此， IP 协议规定，在互联网中所有的主机和路由器，必须能够接受长度不超过 576 字节的数据报。这是假定上层交下来的数据长度有 512 字节（合理的长度），加上最长的 IP 首部 60 字节，再加上 4 字节的富余量，就得到 576 字节。当主机需要发送长度超过 576 字节的数据报时，应当先了解一下，目的主机能否接受所要发送的数据报长度。否则，就要进行分片。</p></li><li><p>标识、标志、片偏移：这三个字段与分片有关。</p><p>标识：IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加 1，并将此值赋给标识字段。</p><p>标志：MF（More Fragment），MF = 1 表示后面还有分片的数据报。MF = 0 表示这已经是最后一个分片。DF（Don't Fragment），DF = 1 表示不要分片。只有当 DF = 0 时才允许分片。</p><p>片偏移：以 8 个字节为偏移单位。也就是说，每个分片的长度一定是 8 字节的整数倍。</p><table><thead><tr class="header"><th></th><th>总长度（20 字节首部）</th><th>标识</th><th>MF</th><th>DF</th><th>片偏移</th></tr></thead><tbody><tr class="odd"><td>原始数据报</td><td>3820</td><td>12345</td><td>0</td><td>0</td><td>0</td></tr><tr class="even"><td>数据报片 1</td><td>1420</td><td>12345</td><td>1</td><td>0</td><td>0</td></tr><tr class="odd"><td>数据报片 2</td><td>1420</td><td>12345</td><td>1</td><td>0</td><td>175</td></tr><tr class="even"><td>数据报片 3</td><td>1020</td><td>12345</td><td>0</td><td>0</td><td>350</td></tr></tbody></table></li><li>生存时间：TTL（Time To Live），现在指<strong>跳数</strong>，表明数据报在网络中的寿命，防止无法交付的数据报无限制地在互联网中兜圈子。若 TTL = 1，就表示这个数据报只能在本局域网中传送。</li><li><p>协议：指出此数据报携带的数据是使用何种协议，以便使目的主机的 IP 层知道应将数据部分上交给哪个协议进行处理。</p><table><thead><tr class="header"><th>协议名</th><th>ICMP</th><th>IGMP</th><th>IP</th><th>TCP</th><th>EGP</th><th>IGP</th><th>UDP</th><th>IPv6</th><th>ESP</th><th>OSPF</th></tr></thead><tbody><tr class="odd"><td>协议字段值</td><td>1</td><td>2</td><td>4</td><td>6</td><td>8</td><td>9</td><td>17</td><td>41</td><td>50</td><td>89</td></tr></tbody></table></li><li><p>首部检验和：只检验数据报首部，数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化）。</p><p><img src="/uploads/image/computer-networking/ip-header-validation.jpeg"></p></li></ul><h2 id="转发分组的流程">转发分组的流程</h2><p>在互联网上转发分组时，是从一个路由器转发到下一个路由器。</p><p>在路由表中，对每一条路由最重要的是以下两个信息：(目的网络地址，下一跳地址)</p><p>虽然互联网所有的分组转发都是<strong>基于目的主机所在的网络</strong>*，但在大多数情况下都允许有这样的特例，即对特定的目的主机指明一个路由。这种路由叫做<strong>特定主机路由</strong>。采用特定主机路由可使网络管理人员更<strong>方便地控制网络和测试网络</strong>（对网络的连接或路由表进行排错），同时也可在需要<strong>考虑某种安全问题</strong>时采用这种特定主机路由。</p><p>路由器还可采用<strong>默认路由</strong>（default route）以减小路由表所占用的空间和搜索路由表所用的时间。这种转发方式在一个网络只有很少的对外连接时是很有用的。主机在发送每一个 IP 数据报时都要查找自己的路由表，如果一台主机连接在一个小网络上，而这个网络只用一个路由器和互联网连接，那么在这种情况下使用默认路由是非常合适的。</p><p><img src="/uploads/image/computer-networking/ip-default-route.jpeg"></p><p>IP 数据报中没有下一跳路由器的 IP 地址，那么待转发的数据报怎样能够找到下一跳路由器呢？</p><p>当路由器收到一个待转发的数据报，从路由表中得出下一跳路由器的 IP 地址后，不是把这个地址填入 IP 数据报，而是<strong>送交数据链路层的网络接口软件</strong>。网络接口软件负责把下一跳路由器的 IP 地址转换成硬件地址（使用 ARP），并将此硬件地址放在链路层的 MAC 帧的首部，然后根据这个硬件地址找到下一跳路由器。</p><p>分组转发算法如下：</p><ol type="1"><li>从数据报首部提取目的主机的 IP 地址 D，得出目的网络地址 N。</li><li>若网络 N 与此路由器直接相连，则进行<strong>直接交付</strong>，把数据报交付目的主机（查找 D 的硬件地址，封装 MAC 帧，发送）。否则就是<strong>间接交付</strong>。</li><li>若路由表中有 D 的特定主机路由，则交付特定路由指明的下一跳路由器。</li><li>若路由表中有 N 的路由，交付给指定的下一跳路由器。</li><li>若路由表中有 默认路由，交付给默认路由器。</li><li>否则，报告转发分组出错。</li></ol><h1 id="划分子网">划分子网</h1><h2 id="从两级-ip-到三级-ip">从两级 IP 到三级 IP</h2><ol type="1"><li>IP 地址空间的利用率有时很低。有的单位申请到了一个 B 类地址，但所连接的主机数并不多，可是又不愿意申请一个足够使用的 C 类地址，理由是考虑到今后可能的扩展。IP 地址的浪费，使 IP 地址空间的资源过早地被用完。</li><li>给每一个物理网络分配一个网络号会<strong>使路由表变得太大</strong>（需要更多的存储空间）因而使网络性能变坏（查找路由耗费更多的时间）。</li><li>两级 IP 地址不够灵活。一个单位需要在新的地点开通一个新的网络。但是在申请到一个新的 IP 地址之前，新增加的网络是不可能连接到互联网上工作的。我们希望有一种方法，使一个单位能随时灵活地增加本单位的网络，而不必去申请新的网络号。</li></ol><p>为解决上述问题，从 1985 年起在 IP 地址中又增加了一个“子网号字段”，使两级 IP 地址变为三级 IP 地址（网络号，子网号，主机号）。子网号是从原来的主机号借用若干位，而原来的主机号相应减少了同样的位数。</p><p>从其他网络发送给本网络某台主机的 IP 数据报，仍然是根据<strong>网络号</strong>找到连接在本网络上的路由器。但此路由器在收到 IP 数据报后，再按<strong>子网号</strong>找到目的子网，交付目的主机（子网与该路由器直接相连）或与子网连接的路由器。</p><h2 id="子网掩码">子网掩码</h2><p>现在剩下的问题是，路由器无法看出子网号有几位。IP 地址本身以及数据报首部都没有关于子网划分的信息。因此必须另外想办法，这就是使用子网掩码（subnet mask）。</p><p><img src="/uploads/image/computer-networking/ip-subnet-mask.jpeg"></p><p>虽然没有规定子网掩码中的一串 1 必须是连续的，但却极力推荐在子网掩码中选用连续的 1，以免出现差错。</p><p>使用子网掩码的好处是：不管网络有没有划分子网，只要把子网掩码和 IP 地址进行“与”运算，就立即得出网络地址来。这样在路由器处理到来的分组时就可采用同样的算法。</p><p>现在互联网的标准规定：所有的网络都必须使用子网掩码（便于查找路由表），同时<strong>在路由器的路由表中也必须有子网掩码这一栏</strong>。如果一个网络不划分子网，那么该网络的子网掩码就使用默认子网掩码。默认子网掩码中 1 的位置和 IP 地址中的网络号字段正好相对应。A 类：255.0.0.0。 B 类：255.255.0.0。 C 类：255.255.255.0。</p><p>路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。在路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。若一个路由器连接在两个子网上就拥有两个网络地址和两个子网掩码。</p><p>划分子网增加了灵活性，但却减少了网络上能连接的最大主机总数。</p><h2 id="使用子网时分组的转发">使用子网时分组的转发</h2><p>使用子网后，路由表必须包含以下三项内容：（目的网络地址，子网掩码，下一跳地址）。</p><ol type="1"><li>从收到的数据报首部提取目的 IP 地址 D。</li><li>判断是否可以直接交付：对路由器直接连接的网络逐个进行检查，用各网络的子网掩码和 D 相与，看结果是否和相应的网络地址匹配。若匹配，则直接交付（查找物理地址，封装成帧，发送）。否则是间接交付。</li><li>若有目的地址为 D 的特定主机路由，交付下一跳路由。</li><li>对路由表中每一行，用 D 与子网掩码相与，其结果为 N。若 N 与目的网络地址匹配，交付下一跳路由器。</li><li>若有默认路由，交付默认路由器。</li><li>报告转发分组出错。</li></ol><h1 id="无分类编址构造超网">无分类编址（构造超网）</h1><h2 id="网络前缀">网络前缀</h2><p>无分类域间路由选择 CIDR（Classless Inter-Domain Routing，读音是 “sider”）最主要的特点有两个：</p><ol type="1"><li><p>CIDR 消除了传统的 A、B、C 类地址以及划分子网的概念，能更加有效地分配 IPv4 的地址空间。</p><p>CIDR 使 IP 地址又回到了两级编址：（网络前缀，主机号）。</p><p>CIDR 使用斜线记法，在 IP 地址后面加上斜线 “/”，然后写上网络前缀所占的位数。</p></li><li><p>CIDR 把网络前缀都相同的连续的 IP 地址组成一个“CIDR 地址块”。只要知道地址块中的任何一个地址，就可以知道这个地址块的起始地址（即最小地址）和最大地址，以及地址块中的地址数。</p><p>例如，128.14.35.7/20，前 20 位是网络前缀，即子网掩码的前 20 位是 1，后 16 位是 0。</p><p>128.14.35.7/20 = <u>10000000 00001110 0010</u>0011 00000111</p><p>最小地址：128.14.32.0 = <u>10000000 00001110 0010</u>0000 00000000</p><p>最大地址：128.14.47.255 = <u>10000000 00001110 0010</u>1111 11111111</p><p>当然，一般并不使用以上这两个特殊的主机号。上面的地址块可记为 128.14.32.0/20。</p></li></ol><p>“CIDR 不使用子网”是指 CIDR 并没有在 32 位地址中指明若干位作为子网字段。但分配到一个 CIDR 地址块的单位，仍然可以根据需要划分出一些子网。这些子网也都只有一个网络前缀和一个主机号，但子网的网络前缀比地址块的网络前缀要长些。</p><p>由于一个 CIDR 地址块中有很多地址，所以在路由表中就利用 CIDR 地址块来查找目的网络。这种地址的聚合常称为<strong>路由聚合</strong>（route aggregation），它使得路由表中的一个项目可以表示传统分类地址的很多个路由。</p><p>常用的 CIDR 地址块</p><table><colgroup><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"></colgroup><thead><tr class="header"><th>CIDR 前缀长度</th><th>点分十进制</th><th>包含的地址数</th><th>相当于</th></tr></thead><tbody><tr class="odd"><td>/13</td><td>255.248.0.0</td><td>512 K ~ 2^(32 - 13) 个</td><td>8 个 B 类（2^16 个地址）或 2048 个 C 类（2^8 个地址）</td></tr><tr class="even"><td>/14</td><td>255.252.0.0</td><td>256 K</td><td>4 个 B 类或 1024 个 C 类</td></tr><tr class="odd"><td>...</td><td>...</td><td>...</td><td>...</td></tr><tr class="even"><td>/23</td><td>255.255.254.0</td><td>512</td><td>2 个 C 类</td></tr><tr class="odd"><td>/24</td><td>255.255.255.0</td><td>256</td><td>1 个 C 类</td></tr><tr class="even"><td>/25</td><td>255.255.255.128</td><td>128</td><td>1/2 个 C 类</td></tr><tr class="odd"><td>/26</td><td>255.255.255.192</td><td>64</td><td>1/4 个 C 类</td></tr><tr class="even"><td>/27</td><td>255.255.255.224</td><td>32</td><td>1/8 个 C 类</td></tr></tbody></table><p>路由聚合也称为<strong>构成超网</strong>（supernetting）。除最后几行外，CIDR 地址块都包含了多个 C 类地址，这就是“构成超网”这一名次的来源。</p><p>使用 CIDR 的一个好处就是可以更加有效地分配 IPv4 的地址空间，可根据客户的需要分配适当大小的地址块。而在分类地址中，只能以 /8（A 类），/16（B 类），/24（C 类）来分配，很不灵活。</p><h2 id="最长前缀匹配">最长前缀匹配</h2><p>在使用 CIDR 时，查找路由表时可能会得到不止一个匹配结果，<strong>应当从匹配结果中选择具有最长网络前缀的路由</strong>。这叫做<strong>最长前缀匹配</strong>（longest-perfix matching）。因为网络前缀越长，路由就越具体。</p><p>例如，路由表中有以下两个项目：206.0.68.0/22 和 206.0.71.128/25。现在假定收到一个数据报，其目的 IP 地址为 D=206.0.71.130。D 与这两个目的网络都匹配，根据最长前缀匹配，应当选择后者。因为 206.0.71.128/25 是 206.0.68.0/22 的子网，它更具体。</p><p>采用 CIDR，我们可以按照网络所在的地理位置来分配地址块，这样就可大大减少路由表中的路由项目。例如，可以将世界划分为四大地区，每一地区分配一个 CIDR 地址块：</p><ul><li>地址块 194/7（194.0.0.0 至 195.255.255.255）分配给欧洲。</li><li>地址块 198/7（198.0.0.0 至 199.255.255.255）分配给北美洲。</li><li>地址块 200/7（200.0.0.0 至 201.255.255.255）分配给中美洲和南美洲。</li><li>地址块 202/7（202.0.0.0 至 203.255.255.255）分配给亚洲和太平洋地区。</li></ul><p>上面的每一个地址块包含约 3200 万个地址。凡是发往北美的 IP 数据报（目的 IP 地址的前 7 位是十进制 194）都先送交位于美国的一个路由器，因此在路由表中使用一个项目就行了。</p><h2 id="使用二叉线索查找路由">使用二叉线索查找路由</h2><p>使用 CIDR 后，由于要寻找最长前缀匹配，使路由表的查找过程变得更加复杂了。为了进行更加有效的查找，通常是把无分类编址的路由表放在一种层次的数据结构中，然后自上而下地按层次进行查找。这里最常用的就是<strong>二叉线索</strong>（binary trie），它是一种特殊结构的树。IP 地址中从左到后的比特值决定了从根节点逐层向下层延伸的路径。</p><p>为了简化二叉线索的结构，可以先找出对应与每一个 IP 地址的<strong>唯一前缀</strong>（unique prefix）。所谓唯一前缀就是在表中所有的 IP 地址中，该前缀是唯一的。进行查找时，只要能够和唯一前缀相匹配就行了。</p><p><img src="/uploads/image/computer-networking/ip-binary-trie.jpeg"></p><p>由于唯一前缀一般都小于 32 位，因此用唯一前缀构造的二叉线索的深度往往不到 32 层。二叉线索的每个叶节点代表一个唯一前缀。例如有一个地址是 10011011 ...，需要查找该地址是否在此二叉线索中。从左边开始查起，查到第三个字符时，找不到匹配的，说明这个地址不在这个二叉线索中。</p><p>目的地址<strong>与某一前缀匹配不意味着一定与网络前缀匹配</strong>。要将二叉线索用于路由表中，还必须使每一个叶节点包含所对应的网络前缀和子网掩码。当搜索到一个叶节点时，就必须将目的地址和子网掩码进行“与”运算，看结果是否与对应的网络前缀相匹配。若匹配，就按下一跳的接口转发分组。否则，就丢弃该分组。</p><p>为了提高二叉线索的查找速度，广泛使用了各种<strong>压缩技术</strong>。例如，图中的最后两个地址，其最前面 4 位都是 1011.因此，只要有一个地址的前 4 位是 1011，就可以跳过前面 4 位（即压缩了 4 个层次）而直接从第 5 位开始比较。当然，制作经过压缩的二叉线索需要更多的计算，但由于每一次查找路由时都可以提高查找速度，这样做还是值得的。</p><h1 id="网际控制报文协议-icmp">网际控制报文协议 ICMP</h1><p>为了更有效地转发 IP 数据报和提高交付成功的机会，在网际层使用了 网际控制报文协议 ICMP（Internet Control Message Protocol）。ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。</p><p>ICMP 报文是<strong>封在 IP 数据报</strong>中，作为其中的数据部分。看起来像高层协议，其实不是，而是 IP 层的协议。</p><p>ICMP 报文有两种：<strong>ICMP 差错报告报文</strong> 和 <strong>ICMP 询问报文</strong>。</p><p>ICMP 报文的前 4 个字节是统一的格式，类型（1）、代码（1）和检验和（2）。接着的 4 个字节的内容与 ICMP 的类型有关。最后面是数据字段。</p><table><tr><th>ICMP 报文种类</th><th>类型的值</th><th>类型</th></tr><tr><td rowspan="4">差错报告控制报文</td><td>3</td><td>终点不可达</td></tr><tr><td>11</td><td>时间超过</td></tr><tr><td>12</td><td>参数问题</td></tr><tr><td>5</td><td>改变路由（Redirect）</td></tr><tr><td rowspan="2">询问报文</td><td>8 或 0</td><td>回送（Echo）请求或回答</td></tr><tr><td>13 或 14</td><td>时间戳（Timestamp）请求或回答</td></tr></table><h2 id="差错报告报文">差错报告报文</h2><ul><li>终点不可达：当路由器或主机不能交付数据报时，向源点发送此报文。</li><li>时间超过：当路由器收到生存时间为零的数据报时，除丢弃该数据报以外，还要向源点发送此报文。当终点在规定时间内不能收到一个数据报的全部数据报片时，就把已收到的都丢弃，并向源点发送此报文。</li><li>参数问题：当路由器或主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送此报文。</li><li><p>改变路由：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）。</p><p>在互联网的主机中也要有一个路由表。当主机要发送数据报时，首先要查找主机自己的路由表，看应当从哪一个接口把数据报发送出去。在互联网中，主机的数量远大于路由器的数量，出于效率的考虑，这些主机不和路由器定期交换路由信息。在主机刚开始工作时，一般都在路由表中设置一个默认路由器的 IP 地址。这个默认路由器（通过和其他路由器交换路由信息）知道到每一个目的地址的最佳路由。如果默认路由器发现主机发往某个目的地址的数据报的最佳路由应当经过网络上的另一个路由器时，就用改变路由报文把这情况告诉主机。于是，该主机就在其路由表中增加一个项目：到某目的地址应经过某路由器（而不是默认路由器）。</p></li></ul><p>所有的 ICMP 差错报告报文中的数据字段都具有同样的格式。</p><p><img src="/uploads/image/computer-networking/icmp-data.jpeg"></p><p>提取收到的数据报的数据字节的前 8 个字节（TCP 或 UDP 的首部的前 8 个字节）是为了得到运输层的端口号（对于 TCP 和 UDP）以及运输层报文的发送序号（对于 TCP）。整个 ICMP 报文作为 IP 数据报的数据字段发送给源点。</p><p>下面是不应该发送 ICMP 差错报告报文的几种情况。</p><ul><li>对 ICMP 差错报告报文，不再发送 ICMP 差错报告报文。</li><li>对第一个分片的数据报片的所有后续数据报片，都不发送。</li><li>对具有多播地址的数据报，都不发送。</li><li>对具有特殊地址（如 127.0.0.0 或 0.0.0.0）的数据报，不发送。</li></ul><h2 id="询问报文">询问报文</h2><ul><li>回送请求和回答：由主机或路由器向一个特定的目的主机发出询问，收到此报文的主机必须给源主机或路由器发送 ICMP 回送回答报文。这种询问报文用来<strong>测试目的站是否可达</strong>以及<strong>了解有关状态</strong>。</li><li>时间戳请求和回答：请某台主机或路由器回答当前的日期和时间。可用于时钟同步和时间测量。</li></ul><h2 id="icmp-应用举例">ICMP 应用举例</h2><ul><li><p>分组网间探测 PING（Packet InterNet Groper），用来测试两台主机之间的连通性。</p><p>PING 使用 ICMP 回送请求和回送回答报文（<strong>ICMP 询问报文</strong>）。<strong>PING 是应用层直接使用网络层 ICMP 的一个例子。它没有通过运输层的 TCP 或 UDP</strong>。</p></li><li><p>traceroute（这是 UNIX 操作系统中的名字）或 tracert（Windows 操作系统中的名字），用来跟踪一个分组从源点到终点的路径。</p><p>traceroute 从源主机向目的主机发送一连串的 IP 数据报，数据报中<strong>封装的是无法交付（使用了非法的端口）的 UDP 用户数据报</strong>。第一个数据报的生存时间 TTL 设置为 1。路由器收下后把 TTL 的值减 1，由于 TTL 等于 0 了，就丢弃报文并向源主机发送一个 <strong>ICMP 时间超过</strong>差错报告报文。</p><p>源主机接着发送第二个数据报，并把 TTL 设置为 2 ... 这样一直继续下去，当最后一个数据报刚刚到达目的主机时，数据报的 TTL 是 1。主机不转发数据报，但因 IP 数据报中封装的是无法交付的 UDP 用户数据报，因此目的主机要向源点发送 <strong>ICMP 终点不可达</strong>差错报告报文。</p></li></ul><h1 id="路由选择协议">路由选择协议</h1><p>路由表中的路由（行）是怎样得出的。</p><h2 id="理想的路由算法">理想的路由算法</h2><ol type="1"><li>正确性和完整性。正确的含义是：沿着各路由表所指引的路由，分组一定能够最终到达目的网络和目的主机。</li><li>计算上应简单，不应使网络增加太多的额外开销。</li><li>自适应性，能适应通信量和网络拓扑的变化。也称稳健性（robustness）。</li><li>稳定性，算法应收敛于一个可以接受的解，而不应使得路由不停地变化。</li><li>公平性，对所有用户（除对少数优先级高的用户）都是平等的。</li><li>最佳的，使得分组平均时延最小而网络的吞吐量最大。虽然我们希望得到”最佳“的算法，但这并不总是最重要的。对于某些网络，网络的可靠性有时要比最小的分组平均时延或最大吞吐量更加重要。因此，所谓最佳只能是相对于某一种特定要求下得出的较为合理的选择而已。</li></ol><p>若从路由算法能否虽网络的通信量或拓扑自适应地进行调整来区分，则只有两大类：</p><ul><li>静态路由选择策略，也叫做非自适应路由选择。其特点是简单和开销小，但不能及时适应网络状态的变化。对于很简单的小网络，完全可以采用静态路由选择，用人工配置每一条路由。</li><li>动态路由选择策略，也叫做自适应路由选择。其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。因此，动态路由选择适用于较复杂的大网络。</li></ul><h2 id="分层次的路由选择协议">分层次的路由选择协议</h2><p>互联网采用的主要是<strong>自适应的、分布式</strong>路由选择协议。而采用分层次的路由选择协议有以下两个原因：</p><ol type="1"><li>互联网的规模非常大。如果让所有的路由器知道所有的网络应怎样到达，则这种路由表将非常大，处理起来也太花时间。而所有这些路由器之间交换路由信息所需的带宽就会使互联网的通信链路饱和。</li><li>许多单位不愿意外界了解自己单位网络的布局细节和本部门所采用的路由选择协议，但同时还希望连接到互联网上。</li></ol><p>为此，可以把整个互联网划分为许多较小的<strong>自治系统</strong> AS（autonomous system）。AS 是在单一技术管理下的一组路由器，这些路由器使用一种自治系统内部的路由选择协议和共同的度量。一个 AS 对其他 AS 表现出的是<strong>一个单一的和一致的路由选择策略</strong>。</p><p>互联网把路由选择协议划分为两大类：</p><ol type="1"><li><strong>内部网关协议</strong> IGP（Interior Gateway Protocol） 即在一个自治系统内部使用的路由选择协议。目前这类路由选择协议使用得最多，如 RIP 和 OSPF 协议。</li><li><strong>外部网关协议</strong> EGP（External Gateway Protocol） 若源主机和目的主机处在不同的自治系统中（这两个自治系统可能使用不同的内部网关协议），当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。目前使用最多的外部网关协议是 BGP-4（BGP的版本 4）。</li></ol><p>每个自治系统自己决定在本自治系统内部运行哪一个内部路由选择协议（RIP 或 OSPF）。但每个自治系统都有一个或多个路由器除运行本系统的内部路由选择协议之外，还要运行自治系统间的路由选择协议（BGP-4）。</p><p>网关是旧称，就是网络层的路由器。因此有的书把 IGP 和 EGP 分别改为 IRP 和 ERP。</p><h2 id="内部网关协议-rip">内部网关协议 RIP</h2><p>RIP（Routing Information Protocol）是内部网关协议 IGP 中最先得到广泛使用的协议。RIP 是一种<strong>分布式的基于距离向量</strong>的路由选择协议，其最大的优点是<strong>简单</strong>。</p><p>RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录（因此，这是一组距离，即“距离向量”）。RIP 协议的“距离”也称“跳数”（hop count），因为每经过一个路由器，跳数就加 1。RIP 认为好的路由就是它通过的路由器的数目少，即“距离短”。RIP 允许一条路径最多只能包含 15 个路由器，因此“距离”等于 16 时即相当于不可达。可见 RIP 只适用于小型互联网。</p><p>RIP 不能在两个网络之间使用多条路由。RIP 选择一条具有最少路由器的路由，哪怕还存在另一条高速（低时延）但路由器较多的路由。</p><p>我们一定要弄清以下三个要点，即<strong>和哪些路由器交换信息？交换什么信息？在什么时候交换</strong>？</p><p>RIP 协议的特点是：</p><ol type="1"><li>仅和相邻路由器交换信息。如果两个路由器之间的通信不需要经过另一个路由器，那么这两个路由器就是相邻的。不相邻的路由器不交换信息。</li><li>交换的信息是当前本路由器所知道的全部信息，即自己现在的路由表。</li><li>按固定的时间间隔交换路由信息。例如，每隔 30 秒。</li></ol><h3 id="距离向量算法">距离向量算法</h3><p>距离向量算法的基础是 Bellman-Ford 算法，原理是最短路径具有最优子结构性质。</p><p>对每一个相邻路由器发送过来的 RIP 报文，进行以下步骤。</p><ol type="1"><li><p>对地址为 X 的相邻路由器发来的 RIP 报文，先修改此报文中的所有项目：把“下一跳”字段中的地址都改为 X，并把所有的“距离”字段的值都加 1。修改后每一个项目都由三个关键数据，即：目的网络 N，距离 d，下一跳路由器 X。（即 X 把它的路由表传给我了，我要比较我的路由表和它的路由表，看看应该按我的路由表传，还是它的。这一步的修改动作就是为接下来的比较做准备，N 是目的网络，d 就是我把分组传给 X 再由 X 续传到 N 的总距离）</p></li><li><p>对修改后的每一个项目，进行以下步骤：</p>若路由表中没有目的网络 N，添加该项目到路由表中。否则，路由表中有网络 N，就要比较距离了：<ul><li>若下一跳路由器地址也是 X，则更新距离 d。（注意，是更新。因为网络的距离是可能发生变化的，要以最新的消息为准）</li><li>若下一跳路由器的地址不是 X，则保留距离较小的那一项。</li></ul></li><li><p>若 3 分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达路由器，即把距离置为 16。</p></li></ol><h3 id="rip-协议的报文格式">RIP 协议的报文格式</h3><p>下图是 RIP2（版本 2）的报文格式。</p><p><img src="/uploads/image/computer-networking/rip-header.jpeg"></p><p>RIP 协议使用运输层的 UDP 进行传送，使用的端口是 520。命令字段指出报文的意义。例如， 1 表示请求路由信息，2 表示对 1 的响应或主动发出的路由更新报文。首部的“必为 0”是填充字段，为了 4 字节的对齐。</p><p>RIP2 具有简单的鉴别功能。若使用鉴别功能，则将原来写入第一个路由信息的位置用作鉴别。这时应将地址族标识符置为全 1，而路由标记写入鉴别类型，剩下的 16 字节为鉴别数据。在鉴别数据之后才写入路由信息，但这时最多只能再放入 24 个路由信息。</p><p>RIP 存在的一个问题是<strong>当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器</strong>。举个简单的例子，</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">N1 ----- R1 ------------ R2 ----- N2</span><br><span class="line">    N1, 1, 直接       N1, 2, R1</span><br><span class="line"></span><br><span class="line">N1 -xxx- R1 ------------ R2 ----- N2</span><br><span class="line">    N1, 16, 直接      N1, 2, R1</span><br></pre></td></tr></table></figure><p>现在假定 R1 到 N1 的链路除了故障。于是 R1 更新自己的路由表为 N1, 16, 直接。但是，很可能要经过 30 秒后才把更新后的信息发给 R2。（这么憨的吗？不能立即发送吗？）然而，R1 在发送之前收到了来自 R2 的更新信息。根据算法，R1 需要更新自己的路由为 N1, 2, R2。即 R1 误以为可以通过 R2 将到达 N1。R1 经过一段时间，将 N1, 2, R2 发送给 R2，R2 根据算法将自己的路由表更新为 N1, 3, R1。（你也这么憨的吗？更新前不看看发来的路由的下一跳就是自己）……这样的更新一直持续下去，直到距离增大到 16 为止，R1 和 R2 才知道 N1 是不可达的。RIP 协议的这一特点叫做：<strong>好消息传播得快，而坏消息传播得慢。</strong>但如果一个路由器发现了更短的路由，那么这种更新信息就传播得很快。</p><p>总之，RIP 协议最大的优点就是<strong>实现简单，开销较小</strong>。但缺点也很多。</p><ul><li>首先，RIP 限制了网络的规模，它能使用的最大距离为 15。</li><li>其次，路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</li><li>最后，坏消息传播得慢，使更新过程的收敛时间过长。</li></ul><p>因此，对于规模较大的网络就应当使用 OSPF 协议。然而目前在规模较小的网络中，使用 RIP 协议的仍占多数。</p><h2 id="内部网关协议-ospf">内部网关协议 OSPF</h2><p>这个协议的名字是<strong>开放最短路径优先</strong> OSPF（Open Shortest Path First），是为了克服 RIP 的缺点被开发出来的。”开放“指的是 OSPF 协议不是受某一家厂商控制，而是公开发表的。”最短路径优先“是因为使用了 Dijkstra 提出的<strong>最短路径算法</strong>。请注意：OSPF 只是一个协议的名字，并不表示其他的路由选择协议不是”最短路径优先“。实际上，所有的在自治系统内部使用的路由选择协议都是要寻找一条最短的路径。</p><p>OSPF 最主要的特征就是使用分布式的<strong>链路状态协议</strong>（link state protocol），而不是像 RIP 那样的距离向量协议。OSPF 协议的三个要点和 RIP 的都不一样：</p><ol type="1"><li>向本自治系统中<strong>所有路由器</strong>发送信息。使用的是<strong>洪泛法</strong>（flooding）：路由器通过所有输出端口向所有相邻的路由器发送信息。而每一个相邻的路由器又再将此信息发往其所有的相邻路由器（但不发给发来信息的那个路由器）。这样，最终整个区域中所有的路由器都得到了这个信息的一个副本。</li><li>发送的信息是<strong>与本路由器相邻的所有路由器的链路状态</strong>，但这只是路由器所知道的<strong>部分信息</strong>。所谓链路状态就是说明本路由器和哪些路由器相邻，以及该链路的<strong>度量</strong>（metric）。度量（费用、距离、时延、带宽等等）由网络管理人员来决定，因此较为灵活。</li><li>只有当链路状态<strong>发生变化</strong>时，路由器才向所有路由器用洪泛法发送此信息。</li></ol><h3 id="关于-rip-和-ospf-三个要点的总结">关于 RIP 和 OSPF 三个要点的总结</h3><table><colgroup><col style="width: 33%"><col style="width: 33%"><col style="width: 33%"></colgroup><thead><tr class="header"><th></th><th>RIP</th><th>OSPF</th></tr></thead><tbody><tr class="odd"><td>向谁发送？</td><td>相邻路由器</td><td>全部路由器（洪泛法，可以看做递归式地向相邻路由器发送）</td></tr><tr class="even"><td>发送什么？</td><td>本路由器的路由表（本路由器知道的全部信息）</td><td>与本路由器相邻的路由器的链路状态（本路由器知道的部分信息），链路状态可以等效看作是自定义的路由表的表项</td></tr><tr class="odd"><td>何时发送？</td><td>定期发送（如 30 秒）</td><td>链路状态发生变化时发送</td></tr></tbody></table><p>所有的路由器最终都能建立一个<strong>链路状态数据库</strong>（link-state database），这个数据库实际上就是<strong>全网的拓扑结构图</strong>。这个拓扑结构图在全网范围内是一致的（这称为链路状态数据库的同步）。每一个路由器使用链路状态数据库，构造出自己的路由表（例如，使用 Dijkstra 的最短路径路由算法）。</p><p>OSPF 的链路状态数据库能较快地进行更新，<strong>更新过程收敛得快</strong>是其重要优点。</p><h3 id="ospf-的区域划分">OSPF 的区域划分</h3><p>为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的范围，叫做<strong>区域</strong>（area），每一个区域都由一个 32 位的区域标识符（用点分十进制表示，和 IPv4 类似，但不是 IPv4）。一个区域不能太大，在一个区域内的路由器最好不超过 200 个。划分区域的好处是<strong>把利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统</strong>，这就减少了整个网络上的通信量。在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况。</p><p>为了使每一个区域能够和本区域以外的区域进行通信，OSPF 使用<strong>层次结构的区域划分</strong>。在上层的区域叫做<strong>主干区域</strong>（backbone area），标识符规定为 0.0.0.0。主干区域的作用是连通其他在下层的区域。在主干区域内的路由器叫做<strong>主干路由器</strong>（backbone router）。同时连接主干区域和其他区域的路由器叫做<strong>区域边界路由器</strong>（area border router）。主干区域内还要有一个路由器专门和本自治系统以外的的其他自治系统交换路由信息。这样的路由器叫做<strong>自治系统边界路由器</strong>。</p><p>采用分层次划分区域的方法，</p><ul><li>缺点是，使交换信息的种类增多了，同时也使 OSPF 协议更加复杂了。</li><li>优点是，使每一个区域内部交换路由信息的通信量大大减小，因而能用于规模很大的自治系统中。</li></ul><h3 id="ospf-协议的报文格式">OSPF 协议的报文格式</h3><p>OSPF 不用 UDP 而是<strong>直接用 IP 数据报传送</strong>，这样做可减少路由信息的通信量。数据报短的另一个好处是，可以不必将长的数据报分片传送。分片传送的数据报只要丢失一个，就无法组装成原来的数据报，而整个数据报就必须重传。</p><p><img src="/uploads/image/computer-networking/ospf-header.jpeg"></p><p>OSPF 使用 24 字节的固定长度首部：</p><ul><li>版本：当前的版本号是 2。</li><li>类型：可以是 5 种类型分组中的一种。<ul><li>问候（Hello）分组，用来发现和维持邻站的可达性。</li><li>数据库描述（Database Description）分组，向邻站给出自己的链路状态数据库的摘要信息。</li><li>链路状态请求（Link State Request）分组，向对方请求发送某些链路状态项目的详细信息。</li><li>链路状态更新（Link State Update）分组，用洪泛法对全网更新链路状态。这种分组是最复杂的，也是 OSPF 协议最核心的部分。</li><li>链路状态确认（Link State Acknowledgement）分组，对链路更新分组的确认。</li></ul></li><li>分组长度：包括首部在内的分组长度，以字节为单位。</li><li>路由器标识符：发送该分组的路由器的接口的 IP 地址。</li><li>鉴别类型：0（不用）和 1（口令）</li><li>鉴别：鉴别类型为 0 时就填入 0，鉴别类型为 1 时则填入 8 个字符的口令。</li></ul><p>OSPF 的特点：</p><ul><li>允许管理员给每条路由指派不同的代价（1 至 65535）。商用的网络在使用 OSPF 时，通常根据链路带宽来计算链路的代价。这种灵活性是 RIP 所没有的。</li><li>如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这叫做多路径间的<strong>负载平衡</strong>（load balancing）。在代价相同的多条路径上分配通信量是通信量工程中的简单形式。RIP 只能找出到某个网络的一条路径。</li><li>在 OSPF 路由器之间交换的分组都具有鉴别的功能，保证了仅在可信赖的路由器之间交换路由信息。（RIP 也具有简单的鉴别功能）</li><li>OSPF 支持可变长度的子网划分和无分类的编址 CIDR。（RIP2 也支持）</li><li>由于网络中的链路状态可能经常发生变化，因此 OSPF 让每一个链路状态都带上一个 32 位的序号，序号越大状态就越新。OSPF 规定，链路状态序号增长的速率不得超过 5 秒钟 1 次。这样，全部序号空间在 600 年内不会产生重复序号。</li></ul><h3 id="ospf-的工作过程">OSPF 的工作过程</h3><p>OSPF 规定，每两个相邻的路由器每隔 10 秒钟要交换一次「问候分组」，这样就能确知哪些邻站是可达的。在正常情况下，网络中传送的绝大多数 OSPF 分组都是问候分组。若有 40 秒钟没有收到某个相邻路由器发来的问候分组，则可认为该相邻路由器是不可达的，应立即修改链路状态数据库，并重新计算路由表。</p><p>其他的四种分组都是用来进行链路状态数据库的同步。所谓<strong>同步</strong>就是指不同路由器的链路状态数据库的内容是一样的。</p><p>当一个路由器开始工作时，它只能通过问候分组得知它有哪些相邻的路由器在工作，以及将数据发往相邻路由器所需的”代价“。如果所有的路由器都把自己的本地链路状态信息对全网进行广播，那么各路由器只要将这些信息综合起来就可得出链路状态数据库。但这样做开销太大，因此 OSPF 采用下面的办法。</p><p>OSPF 让每一个路由器用「数据库描述分组」和相邻路由器交换本数据库中已有的链路状态摘要信息。摘要信息主要就是指出有哪些路由器的链路状态信息（以及其序号）已经写入了数据库。之后，路由就使用「链路状态请求分组」向对方请求自己所缺少的某些链路状态项目的详细信息。通过一系列的这种分组交换，全网同步的链路数据库就建立了。</p><p>在网络运行的过程中，只要一个路由器的链路状态发生变化，该路由器就要使用「链路状态更新分组」，用洪泛法向全网更新链路状态。OSPF 使用的是<strong>可靠的洪泛法</strong>，可靠的洪泛法是在收到更新分组后要发送确认（收到重复的更新分组只需要发送一次确认）。</p><p><img src="/uploads/image/computer-networking/ospf-reliable-flooding.jpeg"></p><p>为了确保链路状态数据库与全网的状态保持一致，OSPF 还规定每隔一段时间，如 30 分钟，要刷新一次数据库中的链路状态。</p><p>由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此，当互联网规模很大时，OSPF 协议要比距离向量协议 RIP 好得多。</p><p>若 N 个路由器连接在一个以太网上，则每个路由器要向其他 N-1 个路由器发送链路状态信息，因而共有 N(N-1) 个链路状态要在这个以太网上传送。OSPF 协议对这种多点接入的局域网采用了<strong>指定的路由器</strong>（designated router）的方法，使广播的信息量大大减少。指定的路由器代表该局域网上所有的链路，向连接到该网络上的各路由器发送状态信息（?）。</p><h2 id="外部网关协议-bgp">外部网关协议 BGP</h2><p>在不同的 AS 之间不能使用内部网关协议（RIP 或 OSPF），主要有两个原因：</p><ol type="1"><li><strong>互联网的规模太大</strong>，使得 AS 之间的路由选择非常困难。连接在互联网主干网上的路由器，必须对任何有效的 IP 地址都能在路由表中找到匹配的目的网络。如果使用链路状态协议（如 OSPF），则每一个路由器必须维持一个很大的链路状态数据库。对于这样大的主干网用 Dijkstra 算法计算最短路径时花费的时间也太长。另外，由于 AS 使用的路径度量（代价）可能不同，因此，当一条路径通过几个不同的 AS 时，要计算出有意义的代价是不太可能的。比较合理的做法是在 AS 之间交换“可达性”信息。例如，“到达目的网络 N 可经过自治系统 ASx”。</li><li><strong>AS 之间的路由选择必须考虑有关策略</strong>。这些策略包括政治、安全或经济方面的考虑。例如，我国国内站点在互相传送数据报时不应经过国外兜圈子，特别是，不要经过某些对我国的安全有威胁的国家。这些策略都是由网络管理人员对每一个路由器进行设置的。</li></ol><p>由于上述情况，边界网关协议 BGP 只能是力求寻找一条能够到达目的网络且比较好的路由，而并非要寻找一条最佳路由。</p><h3 id="bgp-协议的三要点">BGP 协议的三要点</h3><p>在配置 BGP 时，每一个自治系统的管理员要选择至少一个路由器作为该自治系统的“BGP 发言人”。BGP 发言人往往就是 BGP 边界路由器（但也可以不是），每一个 BGP 发言人除了必须运行 BGP 协议外，还必须运行该自治系统所使用的内部网关协议（如 RIP 或 OSPF）。</p><p>一个 BGP 发言人与其他 AS 的 BGP 发言人要交换路由信息（因此，BGP 协议交换路由信息的结点数量级是自治系统个数的量级，这要比这些自治系统中的网络数少很多），要先建立 TCP 连接（端口 179），然后在此连接上交换 BGP 报文以建立 BGP 会话（session），利用 BGP 会话交换路由信息，如增加了新的路由，或撤销过时的路由，以及报告出差错的情况等等。使用 TCP 连接能提供可靠的服务，也简化了路由选择协议。使用 TCP 连接交换路由信息的两个 BGP 发言人，彼此成为对方的<strong>邻站</strong>（neighbor）或<strong>对等站</strong>（peer）。</p><p>在 BGP 刚开始运行时，BGP 的邻站是交换整个的 BGP 路由表。但以后只需要在发生变化时更新有变化的部分。这样做对节省网络带宽和减少路由器的处理开销方面都有好处。</p><p>BGP 采用了<strong>路径向量路由选择协议</strong>，它与距离向量协议（如 RIP）和链路状态协议（如 OSPF）都有很大的区别。下图给出一个 BGP 发言人交换路径向量的例子。AS2 的 BGP 发言人通过主干网的 BGP 发言人：“要到达网络 N1，N2，N3 和 N4 可经过 AS2。“主干网在收到这个通知后，就发出通知：”要到达网络 N1，N2，N3 和 N4 可沿路径（AS1, AS2）。“</p><p><img src="/uploads/image/computer-networking/bgp-path-vector-example.jpeg"></p><p>BGP 支持无分类域间路由选择 CIDR，因此 BGP 的路由表应当包括<strong>目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的自治系统序列</strong>。由于使用了路径向量，可以很容易地避免会兜圈子的路由：如果一个 BGP 发言人收到了一个路径通知，它要检查一下本自治系统是否在此通知的路径中。如果在这条路径中，就不能采用这条路径（因为会兜圈子）。</p><p>BGP 可以很容易地解决距离向量路由选择算法中的“坏消息传播得慢”这一问题。但某个路由器或链路出故障时，由于 BGP 发言人可以从不止一个邻站获得路由信息，因此很容易选择出新的路由。</p><h3 id="bgp-协议的报文格式">BGP 协议的报文格式</h3><p>通用首部：</p><p><img src="/uploads/image/computer-networking/bgp-path-vector-example.jpeg"></p><ul><li>标记：用来鉴别收到的 BGP 报文，当不使用鉴别时要置为全 1。</li><li>长度：以字节为单位，最小值是 19（只有首部），最大值是 4096。</li><li>类型：1 到 4，分别对应 4 种报文。<ul><li>OPEN 报文，用来与相邻的另一个 BGP 发言人建立关系，使通信初始化。如果对方接受，就用 KEEPALIVE 报文响应，这样，两个 BGP 发言人的邻站关系就建立了。</li><li>UPDATE 报文，BGP 协议的核心内容，BGP 发言人可以用 UPDATE 报文撤销它以前通知过的路由，也可以宣布增加新的路由。撤销路由可以一次撤销许多条，但增加新路由时，每个更新报文只能增加一条。</li><li>KEEPALIVE 报文，用来周期性地（一般是 30 秒）证实邻站的连通性。KEEPALIVE 报文只有 19 字节（首部），因此不会造成网络上太大的开销。</li><li>NOTIFICATION 报文，用来发送检测到的错误。</li></ul></li></ul><p>报文主体：</p><ul><li>OPEN：6 个字段，版本、本自治系统号、保持时间（秒）、BGP 标识符（通常就是该路由器的 IP 地址）、可选参数长度 和 可选参数。</li><li>UPDATE：5 个字段，不可行路由长度（指明下一字段的长度）、撤销的路由、路径属性总长度（指明下一字段的长度）、路径属性 和 网络层可达性信息（定义发出此报文的网络，包括网络前缀的位数、IP 地址前缀）。</li><li>KEEPALIVE：无字段，只有首部。</li><li>NOTIFICATION： 3 个字段，差错代码、差错子代码 和 差错数据。</li></ul><h1 id="路由器的构成">路由器的构成</h1><p>路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组。路由器的转发分组正是网络层的主要工作。</p><p><img src="/uploads/image/computer-networking/router-structure.jpeg"></p><p>整个路由器结构可划分为两大部分：<strong>路由选择</strong>部分和<strong>分组转发</strong>部分。路由选择部分也叫做控制部分，其核心构件是路由选择处理机。路由选择处理机的任务是根据所选定的协议构造路由表，并更新和维护路由表。（如前面介绍的那样）本节讨论分组转发部分，它由三部分组成：<strong>交换结构</strong>、一组<strong>输入端口</strong>和一组<strong>输出端口</strong>（这里指的是硬件端口）。</p><p>“转发”和“路由选择”是有区别的。“转发”就是路由器根据转发表把收到的 IP 数据报从合适的端口转发出去，仅仅涉及到一个路由器。但“路由选择”则涉及到很多路由器，路由表则是许多路由器协同工作的结果。</p><p>“转发表“和”路由表“也是有区别的。”路由表“一般包含从目的网络到下一跳（用 IP 地址表示）的映射，而”转发表“是从路由表得出的，包含完成转发功能所必需的信息：从目的网络到输出端口和某些 MAC 地址信息的映射（如下一跳的以太网地址）。将转发表和路由表用不同的数据结构实现会带来一些好处，因为在转发分组时，转发表的结构应当使查找过程最优化，但路由表则需要对网络拓扑变化的计算最优化。路由表总是用软件实现的，但转发表甚至可以用特殊的硬件来实现。请注意，<strong>在讨论路由选择的原理时，往往不去区分转发表和路由表的区别，笼统地使用路由表这一名词</strong>。</p><p>输入端口和输出端口里的方框 1、2 和 3 分别代表物理层、数据链路层和网络层的处理模块。</p><ul><li>物理层进行比特的接收。</li><li>数据链路层则按照链路层协议接收帧。在把帧的首部和尾部剥去后，分组就被送入网络层的处理模块。</li><li>若接收到的是交换路由信息的分组（如 RIP 或 OSPF 分组等），则交给路由选择处理机。若接收到的是数据分组，则按照分组首部中的目的地址查找转发表，根据得到的结果，分组就经过交换结构到达合适的输出端口。</li></ul><p>路由器必须以很高的速率转发分组。分组在输入端口和输出端口都可能会在队列中排队等候处理。若分组处理的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少到零，这就使后面再进入队列的分组被丢弃。以前讨论的分组丢失就是发生在路由器中的输入和输出队列产生溢出的时候。当然，设备或线路出故障也可能使分组丢失。</p><p><img src="/uploads/image/computer-networking/router-forwarding.jpeg"></p><p>交换结构是路由器的关键构件。正是这个交换结构把分组从一个输入端口转移到某个合适的输出端口。下图给出了三种常用的交换方法。</p><p><img src="/uploads/image/computer-networking/router-switching-fabric.jpeg"></p><ul><li>存储器：最早使用的路由器就是利用普通的计算机，用 CPU 作为路由器的路由选择处理机。分组从输入端口复制到存储器中，路由器处理机从分组首部提取目的地址，查找路由表，再将分组复制到合适的输出端口的缓存中。若存储器的带宽（读或写）为每秒 M 个分组，那么路由器的交换速率一定小于 M/2。因为存储器对分组的读和写需要花费的时间是同一个量级。许多现代的路由器也通过存储器进行交换，不同的是，目的地址的查找和分组在存储器中的缓存都是在输入端口进行的。</li><li>总线：数据报从输入端口通过共享的总线直接传送到合适的输出端口，而不需要路由选择处理机的干预（复制）。但是，由于总线是共享的，因此在同一时间只能有一个分组在总线上传送。路由器的转发带宽受总线速率的限制。</li><li><p>互连网络：通过纵横交换结构（crossbar switch fabric）进行交换，它有 2N 条总线，可以使 N 个输入端口和 N 个输出端口相连接，这取决于相应的交叉节点是使水平总线和垂直总线连通还是断开。</p><p>当输入端口收到一个分组时，就将它发送到与该输入端口相连的水平总线上。若通向所要转发的输出端口的垂直总线是空闲的，则在这个结点将垂直总线与水平总线接通，然后将该分组转发到这个输出端口。若垂直总线被占用，则被阻塞，必须在输入端口排队。</p></li></ul><h1 id="ipv6">IPv6</h1><p>IPv6 仍支持无连接的传送，但将协议数据单元 PDU 称为分组，而不是 IPv4 的数据报。方便起见，这里仍采用数据报这一名词。</p><p>IPv6 引进到主要变化：</p><ul><li>更大的地址空间。从 IPv4 的 32 位 增大到 128 位。</li><li>扩展的地址层次结构。由于地址空间很大，因此可以划分更多的层次。</li><li>灵活的首部格式。IPv6 的首部与 IPv4 的并不兼容。IPv6 定义了许多可选的扩充首部。</li><li>改进的选项。IPv6 的首部长度是固定的，选项放在有效载荷中。</li><li>允许协议继续扩充。</li><li>支持即插即用。因此 IPv6 不需要使用 DHCP。</li><li>支持资源的预分配。</li><li>首部改为 8 字节对齐。IPv4 是 4 字节对齐。</li></ul><h2 id="基本首部">基本首部</h2><p>IPv6 数据报由两大部分组成，即<strong>基本首部</strong>（base header）和<strong>有效载荷</strong>（payload）。有效载荷允许有零个或多个<strong>扩展首部</strong>（extension header），再后面是数据部分。注意，扩展首部并不属于 IPv6 数据报的首部。</p><p><img src="/uploads/image/computer-networking/ipv6-header.jpg"></p><p>与 IPv4 相比，IPv6 对首部中的某些字段进行了如下的更改：</p><ul><li>取消了首部长度字段，因为它的首部长度是固定的（40 字节）。</li><li>取消了服务类型字段，优先级和流标号字段实现了服务类型的功能。</li><li>取消了总长度字段，改用有效载荷长度字段。</li><li>取消了标识、标志和片偏移字段，这些功能包含在分片扩展首部中。</li><li>把 TTL 字段改称为跳数限制字段，意义不变。</li><li>取消了协议字段，改用下一个首部字段。</li><li>取消了检验和字段，不进行差错检测。</li><li>取消了选项字段，用扩展首部实现选项功能。</li></ul><p>基本首部：</p><ul><li>版本：6。</li><li>通信量类：区分不同的 IPv6 数据报的类别或优先级。</li><li>流标号：IPv6 的一个新的机制是<strong>支持资源预分配</strong>，并且允许路由器把每一个数据报与一个给定的资源分配相联系。IPv6 提出流（flow）的抽象概念。所谓<strong>流就是互联网上从特定源点到特定终点（单播或多播）的一系列数据报（如实时音频或视频传输），而在这个流所经过的路径上的路由器都保证指明的服务质量</strong>。所有属于同一个流的数据报都具有同样的流标号。因此，流标号对实时音频/视频数据的传送特别有用。对于传统的非实时数据（如电子邮件），流标号则没有用处，把它置 0 即可。</li><li>有效载荷长度：除基本首部以外的字节数。最大值是 64 KB（65535 字节）。</li><li>下一个首部：当没有扩展首部时，它的值指出了首部后面的数据应交付 IP 层上面的哪一个高层协议（例如：6 或 17 分别表示交付 TCP 或 UDP）。当有扩展首部时，它的值标识第一个扩展首部的类型。</li><li>跳数限制：最大 255 跳。</li></ul><p>扩展首部：6 种。（1）逐跳选项；（2）路由选择；（3）分片；（4）鉴别；（5）封装安全有效载荷；（6）目的站选项。每一个扩展首部都由若干个字段组成，它们的长度也各不同。但所有扩展首部的第一个字段都是 8 位的“下一个首部”字段。当使用多个扩展首部时，应按以上的顺序出现。高层首部总是放在最后面。</p><p>IPv4 的数据报如果在首部中使用了选项，那么沿着数据报传送的路径上的每一个路由器都必须对这些选项一一进行检查，这就降低了路由器处理数据报的速度。然而实际上很多的选项在途中的路由器上是不需要检查的（因为不需要使用这些选项的信息）。<strong>IPv6 把选项的功能都放在扩展首部中，并把扩展首部留给路径两端的源点和终点的主机来处理</strong>，而数据报途中经过的路由器不处理这些扩展首部（只有一个首部例外，即逐跳选项扩展首部），这样就<strong>大大提高了路由器的处理效率</strong>。</p><h2 id="ipv6-地址">IPv6 地址</h2><p>一般来讲，一个 IPv6 数据报的目的地址可以是以下三种基本类型地址之一：</p><ol type="1"><li>单播（unicast） 传统的点对点通信。</li><li>多播（multicast） 一点对多点通信，IPv6 没有采用广播的术语，而是将广播看作多播的一个特例。</li><li>任播（anycast） 任播的终点是一组计算机，但数据报只交付其中的一个，通常是距离最近的一个。</li></ol><p>IPv6 把实现 IPv6 的主机和路由器均称为<strong>结点</strong>。一个结点可能有多个与链路相连的接口，IPv6 给每个接口指派一个 IP 地址。一个结点可以有多个单播地址，而其中任何一个地址都可以当作到达该结点的目的地址。（IPv4 也是这么做的啊）</p><p>IPv6 使用<strong>冒号十六进制记法</strong>，它把每个 16 位的值用十六进制值表示，各值之间用冒号分隔。</p><ul><li>在十六进制记法中，允许把数字前面的 0 省略。例如，<code>FF05:0:0:0:0:0:0:B3</code>。</li><li>允许零压缩（zero compression），一连串连续的零可以为一对冒号取代。为了保证零压缩有一个不含混的解释，规定在一个地址中只能使用一次零压缩。例如，<code>FF05::B3</code>。</li><li>可结合使用点分十进制记法的后缀（冒号分隔的每个值是两个字节的量，点分隔的每个值是一个字节的量）。这种结合在 IPv4 向 IPv6 的转换阶段特别有用。例如，<code>：：128.10.2.1</code>。</li><li>CIDR 的斜线记法仍然可用。</li></ul><p>IPv6 的地址分类</p><table><thead><tr class="header"><th>地址类型</th><th>二进制前缀</th></tr></thead><tbody><tr class="odd"><td>未指明地址（1 个）</td><td>00...0（128 位），<code>::/128</code></td></tr><tr class="even"><td>环回地址（1 个）</td><td>00...1（128 位），<code>::1/128</code></td></tr><tr class="odd"><td>多播地址（地址总数的 1/256）</td><td>11111111（8 位），<code>FF00::/8</code></td></tr><tr class="even"><td>本地链路单播地址（地址总数的 1/1024）</td><td>1111111010（10 位），<code>FE80::/10</code></td></tr><tr class="odd"><td>全球单播地址</td><td>除上述四种以外，所有其他的二进制前缀</td></tr></tbody></table><p>本地链路单播地址（Link-Local Unicast Address） 有些单位的网络使用 TCP/IP 协议，但并没有连接到互联网上。连接在这样的网络上的主机都可以使用这种本地地址进行通信，但不能和互联网上的其他主机通信。</p><h2 id="从-ipv4-向-ipv6-过渡">从 IPv4 向 IPv6 过渡</h2><p>向 IPv6 过渡只能采用逐步演进的方法。</p><h3 id="双协议栈">双协议栈</h3><p>双协议栈（dual stack）是指在完全过渡到 IPv6 之前，使一部分主机（或路由器）装有双协议栈：一个 IPv4 和一个 IPv6。在和 IPv6 主机通信时采用 IPv6 地址，而和 IPv4 主机通信时则采用 IPv4 地址。双协议栈如何知道目的主机采用哪一种地址呢？使用域名系统 DNS 来查询。若 DNS 返回的是 IPv4 地址，双协议栈的源主机就使用 IPv4 地址。当返回的是 IPv6 地址，源主机就使用 IPv6 地址。</p><p>图示的情况是 A 和 F 都使用 IPv6，所以 A 向 F 发送 IPv6 数据报，路径是 <code>A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; F</code>。但 B 到 E 这段路径是 IPv4 网络，B 不能向 C 转发 IPv6 数据报。它要把 IPv6 数据报首部转换为 IPv4 数据报再发送给 C。C 再转发给 D。D 将 IPv4 数据报恢复成 IPv6 数据报再转发给 E。主要注意的是，IPv6 <strong>首部中的某些字段却无法恢复</strong>。这种信息的损失是使用首部转换方法所不可避免的。</p><p><img src="/uploads/image/computer-networking/ipv6-dual-stack.jpeg"></p><h3 id="隧道技术">隧道技术</h3><p>隧道技术（tunneling）的要点是，在 IPv6 数据报要进入 IPv4 网络时，把 IPv6 数据报封装成为 IPv4 数据报。整个 IPv6 数据报变成了 IPv4 数据报的数据部分。当 IPv4 数据报离开 IPv4 网络中的隧道时，再把数据部分交给主机的 IPv6 协议栈。请注意图中，在隧道中传送的数据报的源地址是 B 而目的地址是 E。</p><p>要使双协议栈的主机知道 IPv4 数据报里封装的是 IPv6 数据报，必须把 IPv4 首部的协议字段置为 41。</p><p><img src="/uploads/image/computer-networking/ipv6-tunneling.jpeg"></p><h2 id="icmpv6">ICMPv6</h2><p>和 IPv4 一样，IPv6 也不保证数据报的可靠交付，因此 IPv6 也需要使用 ICMP 来反馈一些差错信息。新的版本称为 ICMPv6，它比 ICMPv4 要复杂得多。<strong>地址解析协议 ARP 和网际组管理协议 IGMP 的功能都已被合并到 ICMPv6 中</strong>。ICMPv6 是面向报文的协议，它利用报文来报告差错，获取信息，探测邻站或管理多播通信。</p><h1 id="ip-多播">IP 多播</h1><p>与单播相比，在一对多的通信中，多播可大大节约网络资源。</p><p><img src="/uploads/image/computer-networking/ip-unicast-and-multicast.jpeg"></p><p>在互联网范围的多播要靠路由器来实现，这些路由器必须增加一些能够识别多播数据报的软件。能够运行多播协议的路由器称为<strong>多播路由器</strong>（multicast router）。</p><p>在互联网上进行多播就叫做 IP 多播。IP 多播所传送的分组需要使用多播 IP 地址。显然，这个多播数据报的目的地址一定不能写入主机的 IP 地址。这是因为在同一时间可能有成千上万台主机加入到同一个多播组。多播数据报不可能在其首部写入这样多的主机的 IP 地址。<strong>在多播数据报的目的地址写入的是多播组的标识符</strong>，然后设法让加入到这个多播组的主机的 IP 地址与多播组的标识符关联起来。</p><p>其实多播组的标识符就是 IP 地址中的 D 类地址，前四位是 1110，因此范围是 224.0.0.0 到 239.255.255.255。这样，D 类地址共可标识 2^28 个多播组。多播数据报也是“尽最大努力交付“，不保证可靠性。因此，多播数据报和一般的 IP 数据报的区别就是它<strong>使用 D 类 IP 地址作为目的地址</strong>，并且首部中的<strong>协议值是 2，表明使用网际组管理协议 IGMP</strong>。</p><p>显然，<strong>多播地址只能用于目的地址，而不能用于源地址</strong>。此外，<strong>对多播数据报不产生 ICMP 差错报文</strong>。因此，若在 PING 命令后面键入多播地址，将永远不会收到响应。</p><p>IP 多播可以分为两种。一种是只在本地局域网上进行硬件多播，另一种则是在互联网的范围进行多播。前一种虽然比较简单，但很重要，因为现在大部分主机都是通过局域网接入到互联网的。在互联网上进行多播的最后阶段，还是要把多播数据报在局域网上用硬件多播交付多播组的所有成员。</p><h2 id="硬件多播">硬件多播</h2><p>以太网地址块的高 24 位为 <code>00-00-5E</code>，因此 TCP/IP 协议使用的以太网多播地址块的范围是从 <code>00-00-5E-00-00-00</code> 到 <code>00-00-5E-FF-FF-FF</code>。<strong>以太网硬件地址字段中的第 1 字节的最低位为 1 时即为多播地址</strong>。因此，以太网多播地址的范围是从 <code>01-00-5E-00-00-00</code> 到 <code>01-00-5E-7F-FF-FF</code>（第 25 位的 0 哪来的？）。</p><p><img src="/uploads/image/computer-networking/ip-hardware-multicast.jpeg"></p><p>在每一个地址中，只有 23 位可用作多播，这只能和 D 类 IP 地址中的 23 位有一一对应的关系。D 类 IP 地址可供分配的有 28 位，可见前 5 位不能用来构成以太网硬件地址。例如，IP 多播地址 224.128.64.32（即 <code>E0-80-40-20</code>）和 224.0.64.32（即 <code>E0-00-40-20</code>）转换成以太网的硬件多播地址都是 <code>01-00-5E-00-40-20</code>。由于多播 IP 地址与以太网硬件地址的映射关系不是唯一的，因此收到多播数据报的主机，还要在 IP 层利用软件进行过滤，把不是本主机要接收的数据报丢弃。</p><h2 id="网际组管理协议-igmp">网际组管理协议 IGMP</h2><p>网际组管理协议 IGMP 并非是在互联网范围内对所有多播组成员进行管理的协议。IGMP 不知道 IP 多播组包含的成员数，也不知道这些成员都分布在哪些网络上，等等。IGMP 协议是让<strong>连接在本地局域网</strong>上的多播路由器知道<strong>本局域网上</strong>是否有主机（严格来讲，是主机上的某个进程）参加或退出了某个多播组。所以，IGMP 的使用范围是本地局域网。</p><p>仅有 IGMP 协议是不能完成多播任务的。连接在局域网上的多播路由器还必须和互联网上的其他多播路由器协同工作，以便把多播数据报用最小代价传送给所有的组成员。这就需要使用<strong>多播路由选择协议</strong>。然而多播路由选择协议要比单播路由选择协议复杂的多。</p><ul><li>多播转发必须动态地适应多播组成员的变化（这时网络拓扑并未发生变化）。单播路由选择通常是在网络拓扑发生变化时才需要更新路由。</li><li>多播路由器在转发多播数据报时，不能仅仅根据多播数据报中的目的地址，还要考虑这个多播数据报从什么地方来和要到什么地方去。原因是，没有加入多播组的主机、加入多播组 A 的主机、加入多播组 B 的主机<strong>都可以</strong>向多播组 B 发送多播数据报。</li><li>多播数据报可以由没有加入多播组的主机发出（同上），也可以通过没有组成员接入的网络（例如，两个网路距离很远，必须通过中间网络转发）。</li></ul><p>和 ICMP 相似，IGMP 使用 IP 数据报传递其报文，但它也向 IP 提供服务。</p><p>IGMP 的工作可分为两个阶段。</p><ol type="1"><li>当某台主机加入新的多播组时，该主机应向多播组的多播地址发送一个 IGMP 报文，声明自己要成为改组的成员。本地的多播路由器收到 IGMP 报文后，还要利用多播路由选择协议把这种组成员关系转发给互联网上的其他多播路由器。</li><li>组成员关系是动态的。本地多播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否还继续是组的成员。只要有一台主机对某个组响应，那么多播路由器就认为这个组是活跃的。但一个组在经过几次的探询后仍然没有一台主机响应，多播路由器就认为本网络上的主机已经离开了这个组，因此也就不再把这个组的成员关系转发给其他的多播路由器。</li></ol><p>IGMP 设计得很仔细，避免了多播控制信息给网络增加大量的开销。IGMP 采用的一些具体措施如下：</p><ul><li>在主机和多播路由器之间的所有通信都是使用 IP 多播。只要有可能，携带 IGMP 报文的数据报都用硬件多播来传送。</li><li>多播路由器在探询组成员关系时，只需要对所有的组发送一个请求信息的询问报文，而不需要对每一个组发送一个询问报文。默认的询问速率是每 125 秒一次。</li><li>当同一个网络上连接有几个多播路由器时，它们能够迅速和有效地选择其中的一个来探询主机的成员关系。</li><li>在 IGMP 的询问报文中有一个数值 N，它指明一个最长响应时间（默认 10 秒）。当收到询问时，主机在 0 到 N 之间随机选择发送响应所需经过的时延。若一台主机同时参加了几个多播组，则主机对每一个多播组选择不同的随机数。对应于最小时延的响应最先发送。</li><li>同一个组内的每一台主机都要监听响应（响应是 IP 多播发送的，因此同一个组内的所有成员都能收到），只要有本组的其他主机先发送了响应，自己就可以不再发送响应了。这样就抑制了不必要的通信量。</li></ul><p>多播路由器并不需要保留组成员关系的准确记录，因为向局域网上的组成员转发数据报是使用硬件多播。多播路由器只需要知道网络上是否有主机是本组成员即可。</p><p>如果一台主机上有多个进程都加入了某个多播，那么这台主机对发给这个多播组的每个多播数据报只接收一个副本，然后给主机中的每一个进程发送一个本地复制的副本。</p><p>最后强调，多播数据报的发送者和接收者都不知道（也无法找出）一个多播组的成员有多少，以及这些成员是哪些主机。任何应用进程都可以在任何时候向任何一个多播组发送多播数据报，而并不需要加入这个多播组。</p><h2 id="多播路由选择协议">多播路由选择协议</h2><p>多播协议已成为建议标准，但多播路由选择协议尚未标准化。</p><p>多播路由选择实际上就是要找出以源主机为根节点的<strong>多播转发树</strong>。对不同的多播组对应于不同的多播转发树。同一个多播组，对不同的源点也会有不同的多播转发树。</p><p>已有了多种实用的多播路由选择协议，它们在转发多播数据报时使用了以下的三种方法：</p><ol type="1"><li><p><strong>洪泛与剪除</strong>。这种方法适用于较小的多播组，而所有的组成员接入的局域网也是相邻的。</p><p>一开始，路由转发多播数据报使用洪泛的方法（广播）。为了避免兜圈子，采用了<strong>反向路径广播</strong> RPB（Reverse Path Broadcasting）的策略。RPB 的要点是：每一个路由器在收到一个多播数据报时，先检查数据报是否是从源点经最短路径传送来的。进行这种检查很容易，只要寻找从本路由器到源点的最短路径（反向路径）上的第一个路由器。若是刚才把多播数据报送来的路由器，就向所有其他方向转发收到的多播数据报。若不是，就丢弃。如果有好几个相邻路由器都处在最短路径上，那么只能选择一条最短路径，选择的准则是看谁的 IP 最小。</p><p>如果在多播转发树上的某个路由器发现它的下游树枝已没有该多播组的成员，就应把它和下游的树枝一起剪除。当某个树枝有新增加的组成员时，可以再接入到多播转发树上。</p><p><img src="/uploads/image/computer-networking/ip-multicast-rpb.jpeg"></p></li><li><p><strong>隧道技术</strong>（tunneling）。隧道技术适用于多播组的位置在地理上很分散的情况。</p><p>路由器对多播数据报进行再次封装，即加上普通数据报的首部，使之成为向单一目的站发送的单播（unicast）数据报，然后通过隧道发送。</p><p>单播数据报到达目的站的路由器后，再剥去首部，恢复成原来的数据报，继续向多个目的站转发。</p><p><img src="/uploads/image/computer-networking/ip-multicast-tunneling.jpeg"></p></li><li><p><strong>基于核心的发现技术</strong>。这种方法对于多播组的大小在较大范围内变化时都合适。这种方法对每一个多播组 G 指定一个核心路由器，给出它的 IP 单播地址。核心路由器创建出对应于多播组 G 的转发树。如果有一个路由器 R1 向核心路由器 R2 发送数据报，若发送的是多播数据报且目的地址是 G，则 R2 就转发这个数据报。若发送的是请求加入 G 的数据报，R2 就把这个信息加到它的路由中，并用隧道技术向 R1 转发每一个多播数据报的副本。这样，参加到多播组 G 的路由器就从核心向外增多了，扩大了多播转发树的覆盖范围。</p></li></ol><h1 id="vpn-和-nat">VPN 和 NAT</h1><h2 id="虚拟专用网-vpn">虚拟专用网 VPN</h2><p>假定在一个机构内部的计算机通信也是采用 TCP/IP 协议，那么从原则上讲，对于这些计算机可以由该机构自行分配 IP 地址。让这些计算机仅在本地使用的有效的 IP 地址称为<strong>本地地址</strong>，而向互联网的管理机构申请的全球唯一的 IP 地址称为<strong>全球地址</strong>。</p><p>使用本地地址可以大大节约宝贵的 IP 地址资源。但是，如果任意选择一些 IP 地址作为本地地址，那么在某种情况下可能会引起一些麻烦。例如，有时机构内部的某台主机需要和互联网连接，那么这种仅在内部使用的本地地址就有可能和互联网中某个 IP 地址重合。</p><p>为了解决这一问题，RFC 1918 指明了一些<strong>专用地址</strong>（private address）。这些地址只能用于一个机构的内部通信，而不能用于和互联网上的主机通信。在互联网中的所有路由器，对目的地址是专用地址的数据报一律不进行转发。</p><p>三个专用地址块分别是：</p><ol type="1"><li>10.0.0.0 到 10.255.255.255 （或记为 10.0.0.0/8，又称为 24 位块，相当于 1 个 A 类网络）</li><li>172.16.0.0 到 172.31.255.255（或记为 172.16.0.0/12，又称为 20 位块，相当于 16 个 B 类网络）</li><li>192.168.0.0 到 192.168.255.255 （或记为 192.168.0.0/16，又称为 16 位块，相当于 256 个 C 类网络）</li></ol><p>采用这样的专用 IP 地址的互联网络称为专用互联网或本地互联网，简称<strong>专用网</strong>。专用地址也叫做<strong>可重用地址</strong>（reusable address）。</p><p>有时一个很大的机构的许多部门分布的范围很广，这些部分经常要互相交换信息。这可以有两种方法。（1）租用电信公司的通信线路。简单方便但价格昂贵。（2）利用互联网作为本机构各专用网之间的通信载体（利用 IP 隧道技术），这样的专用网又称为<strong>虚拟专用网</strong> VPN（Virtual Private Network）。虚拟表示“好像是”，VPN 只是在效果上和真正的专用网一样。一个机构要构建自己的 VPN 就必须为它的每一个场所购买专门的硬件和软件，并进行配置，使每一个场所的 VPN 系统都知道其他场所的地址。</p><p><img src="/uploads/image/computer-networking/ip-vpn.jpeg"></p><h2 id="网络地址转换-nat">网络地址转换 NAT</h2><p>下面讨论另一种情况，专用网内部的一些主机想和互联网上的主机通信。</p><p>最简单的办法就是设法再申请一些全球 IP 地址。但这在很多情况下是很不容易做到的。目前采用得最多的方法是<strong>网络地址转换</strong> NAT（Network Address Translation）。</p><p>这种方法需要在专用网络连接到互联网的路由器上安装 NAT 软件。装有 NAT 软件的路由器叫做 NAT 路由器，它至少有一个（也可以有多个）有效的全球 IP 地址。所有使用本地地址的主机在和外界通信时，都要在 NAT 路由器上将其本地地址转换成全球 IP 地址。当 NAT 路由器具有 n 个全球 IP 地址时，专用网内部最多可以同时有 n 台主机接入到互联网。专用网内较多数量的主机，可以轮流使用 n 个全球 IP 地址。</p><p><img src="/uploads/image/computer-networking/ip-nat.jpeg"></p><p>显然，通过 NAT 路由器的通信必须由专用网内的主机发起（因为内部主机没有全球 IP 地址，而路由器不转发目的地址为本地地址的数据报）。因此，这种专用网内部的主机不能充当服务器用。</p><p>为了更加有效地利用 NAT 路由器上的全球 IP 地址，现在常用的 NAT 转换表把运输层的端口号也利用上。这样，就可以使多个拥有本地地址的主机，共用一个 NAT 路由器上的全球 IP 地址。使用端口号的 NAT 也叫做<strong>网络地址与端口转换</strong> NAPT（Network Address and Port Translation），但在许多文献中不做区分，都使用 NAT。</p><p>从层次的角度看，NAPT 的机制有些特殊。普通路由器在转发 IP 数据报时，对于源 IP 地址或目的 IP 地址都是不改变的。但 NAT 路由器在转发 IP 数据报时，一定要更换其 IP 地址。其次，普通路由器在转发分组时，是工作在网络层。但 NAPT 路由器还要查看和转换运输层的端口号，而这本来应当属于运输层的范畴。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网络层不提供服务质量的承诺。如果主机中的进程之间的通信需要是可靠的，那么就由网络的主机中的运输层负责（包括差错处理、流量控制）。采用这种设计思路的好处是：网络造价大大降低，运行方式灵活，能够适应多种应用。&lt;/p&gt;
&lt;h1 id=&quot;网际协议-ip&quot;&gt;网际协议 IP&lt;/h1&gt;
&lt;p&gt;与 IP 协议配套使用的还有三个协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;地址解析协议 ARP（Address Resolution Protocol）&lt;/li&gt;
&lt;li&gt;网际控制报文协议 ICMP（Internet Control Message Protocol）&lt;/li&gt;
&lt;li&gt;网际组管理协议（Internet Group Management Protocol）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;IP 协议使用 ARP 协议。ICMP 和 IGMP 使用 IP 协议。&lt;/p&gt;
&lt;p&gt;将网络互相连接起来要使用一些&lt;strong&gt;中间设备&lt;/strong&gt;。根据中间设备所在的层次，可以有以下四种不同的中间设备：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;物理层使用的中间设备叫做&lt;strong&gt;转发器&lt;/strong&gt;（repeater）。&lt;/li&gt;
&lt;li&gt;数据链路层使用的中间设备叫做&lt;strong&gt;网桥&lt;/strong&gt;或&lt;strong&gt;桥接器&lt;/strong&gt;（bridge）。&lt;/li&gt;
&lt;li&gt;网络层使用的中间设备叫做&lt;strong&gt;路由器&lt;/strong&gt;（router）。&lt;/li&gt;
&lt;li&gt;在网络层以上使用的中间设备叫做&lt;strong&gt;网关&lt;/strong&gt;（gateway）。用网关连接两个不兼容的系统需要在高层进行协议的转换。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当中间设备是转发器或网桥时，这仅仅是把一个网络扩大了，而从网络层的角度看，这仍然是一个网络，一般并不称为网络互连。网关由于比较复杂，目前使用得较少。因此讨论网络互连时，都是指用路由器进行网络互连和路由选择。路由器其实就是一台专用计算机，用来在互联网中进行路由选择。由于历史的原因，许多有关 TCP/IP 的文献曾经把网络层使用的路由器称为网关，本书有时也这样用。&lt;/p&gt;
&lt;h1 id=&quot;ip-地址&quot;&gt;IP 地址&lt;/h1&gt;
&lt;p&gt;整个的互联网就是一个单一的、抽象的网络。IP 地址就是给互联网上的每一台主机（或路由器）的每一个接口分配一个在全世界范围内唯一的 32 位的标识符。IP 地址的编址方式经过了三个历史阶段。&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;分类的 IP 地址。最基本的编址方法。&lt;/li&gt;
&lt;li&gt;子网的划分。对最基本的编址方法的改进。&lt;/li&gt;
&lt;li&gt;构成超网。无分配编址方法。已被广泛使用。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;分类的-ip-地址&quot;&gt;分类的 IP 地址&lt;/h1&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;th&gt;
网络类别
&lt;/th&gt;
&lt;th&gt;
类别位
&lt;/th&gt;
&lt;th&gt;
网络号
&lt;/th&gt;
&lt;th&gt;
主机号
&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
A
&lt;/td&gt;
&lt;td&gt;
0
&lt;/td&gt;
&lt;td&gt;
8 位
&lt;/td&gt;
&lt;td&gt;
24 位
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
B
&lt;/td&gt;
&lt;td&gt;
10
&lt;/td&gt;
&lt;td&gt;
16 位
&lt;/td&gt;
&lt;td&gt;
16 位
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
C
&lt;/td&gt;
&lt;td&gt;
110
&lt;/td&gt;
&lt;td&gt;
24 位
&lt;/td&gt;
&lt;td&gt;
8 位
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
D
&lt;/td&gt;
&lt;td&gt;
1110
&lt;/td&gt;
&lt;td colspan=&quot;2&quot; style=&quot;text-align: center;&quot;&gt;
多播地址
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
E
&lt;/td&gt;
&lt;td&gt;
1111
&lt;/td&gt;
&lt;td colspan=&quot;2&quot; style=&quot;text-align: center;&quot;&gt;
保留为今后使用
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://cwscn.github.io/categories/notes/"/>
    
    
      <category term="Computer Networking" scheme="https://cwscn.github.io/tags/Computer-Networking/"/>
    
      <category term="IP" scheme="https://cwscn.github.io/tags/IP/"/>
    
      <category term="ICMP" scheme="https://cwscn.github.io/tags/ICMP/"/>
    
      <category term="IGMP" scheme="https://cwscn.github.io/tags/IGMP/"/>
    
      <category term="ARP" scheme="https://cwscn.github.io/tags/ARP/"/>
    
  </entry>
  
  <entry>
    <title>Convert Sorted List to Binary Serch Tree</title>
    <link href="https://cwscn.github.io/programming/leetcode/convert-sorted-list-to-binary-search-tree/"/>
    <id>https://cwscn.github.io/programming/leetcode/convert-sorted-list-to-binary-search-tree/</id>
    <published>2020-07-13T02:42:28.000Z</published>
    <updated>2020-07-13T13:23:12.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sorted-array-to-balanced-bst">Sorted Array to Balanced BST</h1><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p><p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given the sorted array: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   -3   9</span><br><span class="line">   /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure><h2 id="recursion">Recursion</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n), visit each element once</span></span><br><span class="line"><span class="comment"># Space: O(log(n)), recursion stack depth</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(self, nums: list)</span> -&gt; TreeNode:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(left, right)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> left &gt; right:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            root = TreeNode(nums[mid])</span><br><span class="line">            root.left = helper(left, mid - <span class="number">1</span>)</span><br><span class="line">            root.right = helper(mid + <span class="number">1</span>, right)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h1 id="sorted-list-to-balanced-bst">Sorted List to Balanced BST</h1><p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p><p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given the sorted linked list: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   -3   9</span><br><span class="line">   /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="recursion-1">Recursion</h2><p>Since we are given a linked list and not an array, we don't really have access to the elements of the list using indexes. We want to know the middle element of the linked list.</p><p>We can use the two pointer approach for finding out the middle element of a linked list. Essentially, we have two pointers called <code>slow_ptr</code> and <code>fast_ptr</code>. The <code>slow_ptr</code> moves one node at a time whereas the <code>fast_ptr</code> moves two nodes at a time. By the time the <code>fast_ptr</code> reaches the end of the linked list, the <code>slow_ptr</code> would have reached the middle element of the linked list. For an even sized list, any of the two middle elements can act as the root of the BST.</p><p>Once we have the middle element of the linked list, we disconnect the portion of the list to the left of the middle element. The way we do this is by keeping a <code>prev_ptr</code> as well which points to one node before the <code>slow_ptr</code>.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n log(n)), O(n) to find mid</span></span><br><span class="line"><span class="comment"># Space: O(log(n)), recursion stack</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMiddle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="comment"># The pointer used to disconnect the left half from the mid node.</span></span><br><span class="line">        prevPtr = <span class="literal">None</span></span><br><span class="line">        slowPtr = head</span><br><span class="line">        fastPtr = head</span><br><span class="line">        <span class="comment"># Iterate until fastPr doesn't reach the end of the linked list.</span></span><br><span class="line">        <span class="keyword">while</span> fastPtr <span class="keyword">and</span> fastPtr.next:</span><br><span class="line">            prevPtr = slowPtr</span><br><span class="line">            slowPtr = slowPtr.next</span><br><span class="line">            fastPtr = fastPtr.next.next</span><br><span class="line">        <span class="comment"># Handling the case when slowPtr was equal to head.</span></span><br><span class="line">        <span class="keyword">if</span> prevPtr:</span><br><span class="line">            prevPtr.next = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> slowPtr</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span><span class="params">(self, head: ListNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># If the head doesn't exist, then the linked list is empty</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># Find the middle element for the list.</span></span><br><span class="line">        mid = self.findMiddle(head)</span><br><span class="line">        <span class="comment"># The mid becomes the root of the BST.</span></span><br><span class="line">        node = TreeNode(mid.val)</span><br><span class="line">        <span class="comment"># Base case when there is just one element in the linked list</span></span><br><span class="line">        <span class="keyword">if</span> head == mid:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        <span class="comment"># Recursively form balanced BSTs using the left and right halves of the original list.</span></span><br><span class="line">        node.left = self.sortedListToBST(head)</span><br><span class="line">        node.right = self.sortedListToBST(mid.next)</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure><h2 id="recursion-conversion-to-array">Recursion + Conversion to Array</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n), array O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(self, nums: list)</span> -&gt; TreeNode:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(left, right)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> left &gt; right:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            root = TreeNode(nums[mid])</span><br><span class="line">            root.left = helper(left, mid - <span class="number">1</span>)</span><br><span class="line">            root.right = helper(mid + <span class="number">1</span>, right)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mapListToValues</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            res.append(head.val)</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span><span class="params">(self, head: ListNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">return</span> self.sortedArrayToBST(self.mapListToValues(head))</span><br></pre></td></tr></table></figure><h2 id="inorder-simulation">Inorder Simulation</h2><p>Elements processed in the inorder fashion on a binary search tree turn out to be sorted in ascending order.</p><p>The critical idea based on the inorder traversal that we will exploit to solve this problem, is:</p><p>We know that the leftmost element in the inorder traversal has to be the head of our given linked list. Similarly, the next element in the inorder traversal will be the second element in the linked list and so on. This is made possible because the initial list given to us is sorted in ascending order.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(log(n)), recursion stack</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSize</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        ptr = head</span><br><span class="line">        c = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> ptr:</span><br><span class="line">            ptr = ptr.next</span><br><span class="line">            c += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span><span class="params">(self, head: ListNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        size = self.findSize(head)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(l, r)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> head  <span class="comment"># point the node to process (visit)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Invalid case</span></span><br><span class="line">            <span class="keyword">if</span> l &gt; r:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="comment"># We don't really find out the middle node of the linked list.</span></span><br><span class="line">            <span class="comment"># We just have a variable telling us the index of the middle element.</span></span><br><span class="line">            <span class="comment"># We simply need this to make recursive calls on the two halves.</span></span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">            left = convert(l, mid - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            node = TreeNode(head.val)  <span class="comment"># process current</span></span><br><span class="line">            node.left = left</span><br><span class="line">            head = head.next  <span class="comment"># process next</span></span><br><span class="line"></span><br><span class="line">            node.right = convert(mid + <span class="number">1</span>, r)</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> convert(<span class="number">0</span>, size - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;sorted-array-to-balanced-bst&quot;&gt;Sorted Array to Balanced BST&lt;/h1&gt;
&lt;p&gt;Given an array where elements are sorted in ascending order, convert it to a height balanced BST.&lt;/p&gt;
&lt;p&gt;For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Given the sorted array: [-10,-3,0,5,9],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   -3   9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   /   /&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; -10  5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;recursion&quot;&gt;Recursion&lt;/h2&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Time: O(n), visit each element once&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Space: O(log(n)), recursion stack depth&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sortedArrayToBST&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, nums: list)&lt;/span&gt; -&amp;gt; TreeNode:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;helper&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(left, right)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; left &amp;gt; right:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;None&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mid = (left + right) // &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            root = TreeNode(nums[mid])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            root.left = helper(left, mid - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            root.right = helper(mid + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, right)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; root&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; helper(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, len(nums) - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;sorted-list-to-balanced-bst&quot;&gt;Sorted List to Balanced BST&lt;/h1&gt;
&lt;p&gt;Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.&lt;/p&gt;
&lt;p&gt;For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Given the sorted linked list: [-10,-3,0,5,9],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   -3   9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   /   /&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; -10  5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://cwscn.github.io/categories/programming/"/>
    
    
      <category term="leetcode" scheme="https://cwscn.github.io/tags/leetcode/"/>
    
      <category term="linked list" scheme="https://cwscn.github.io/tags/linked-list/"/>
    
      <category term="balanced binary tree" scheme="https://cwscn.github.io/tags/balanced-binary-tree/"/>
    
      <category term="BST" scheme="https://cwscn.github.io/tags/BST/"/>
    
  </entry>
  
  <entry>
    <title>Rotate List</title>
    <link href="https://cwscn.github.io/programming/leetcode/rotate-list/"/>
    <id>https://cwscn.github.io/programming/leetcode/rotate-list/</id>
    <published>2020-07-12T15:11:45.000Z</published>
    <updated>2020-07-12T14:11:53.534Z</updated>
    
    <content type="html"><![CDATA[<p>Given a linked list, rotate the list to the right by k places, where k is non-negative.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2</span><br><span class="line">Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL</span><br><span class="line">rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4</span><br><span class="line">Output: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">rotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULL</span><br><span class="line">rotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULL</span><br><span class="line">rotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><ol type="1"><li>Connect the tail with head, <code>tail.next = head</code>.</li><li>From <code>head</code>, go forward <code>len - (k % len) - 1</code> steps. The next element is the new head.</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateRight</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        tail, n = head, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> tail.next:</span><br><span class="line">            tail = tail.next</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">        tail.next = head  <span class="comment"># connect</span></span><br><span class="line">        <span class="comment"># find (n - k % n - 1)th node</span></span><br><span class="line">        tail = head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n - k % n - <span class="number">1</span>):</span><br><span class="line">            tail = tail.next</span><br><span class="line">        new_head = tail.next</span><br><span class="line">        tail.next = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> new_head</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given a linked list, rotate the list to the right by k places, where k is non-negative.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;/p&gt;
&lt;figure class=&quot;highlight pl
      
    
    </summary>
    
    
      <category term="编程" scheme="https://cwscn.github.io/categories/programming/"/>
    
    
      <category term="leetcode" scheme="https://cwscn.github.io/tags/leetcode/"/>
    
      <category term="linked list" scheme="https://cwscn.github.io/tags/linked-list/"/>
    
  </entry>
  
  <entry>
    <title>运输层</title>
    <link href="https://cwscn.github.io/notes/computer-networking/transport-layer/"/>
    <id>https://cwscn.github.io/notes/computer-networking/transport-layer/</id>
    <published>2020-07-10T03:26:02.000Z</published>
    <updated>2020-07-12T08:01:48.240Z</updated>
    
    <content type="html"><![CDATA[<p>只有主机的协议栈才有运输层，而路由器在转发分组时都只用到下三层（物理层、数据链路层和网络层）的功能。</p><p>从运输层的角度来看，通信的真正端点并不是主机而是主机中的进程。IP 协议虽然能把分组送到目的主机，但是这个分组没有交付主机中的应用进程。这表明，运输层有一个很重要的功能——<strong>复用</strong>（multiplexing）和<strong>分用</strong>（demultiplexing）。复用是指在发送方不同的应用进程都可以使用同一个运输层协议传送数据（当然需要加上适当的首部），而分用是指接收方的运输层在剥去报文的首部后能够把这些数据正确交付目的应用进程。</p><p>网络层为主机之间提供逻辑通信，而运输层<strong>为应用进程之间提供端到端的逻辑通信</strong>。</p><p>运输层还要对收到的报文进行<strong>差错检测</strong>。在网络层，IP 数据报首部中的检验和字段，只检验首部而不检查数据部分。</p><p>当运输层采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条全双工的可靠信道。但当采用无连接的 UDP 协议时，这种逻辑通信信道仍然是一条不可靠信道。</p><p>两个计算机中的进程要相互通信，不仅必须知道对方的 IP 地址（为了找到对方的计算机），而且还要知道对方的端口号（为了找到对方计算机中的应用进程）。TCP/IP 的运输层使用一个 16 位（可允许有 65535 个不同的端口，这个数目对一个计算机来说是足够用的）端口号来标志一个端口。</p><p>端口号分为下面两大类：</p><ul><li>服务器段使用的端口号<ul><li>孰知端口号，0～1023。这些端口号被指派给了 TCP/IP 最重要的一些应用程序。</li><li>登记端口号，1024～49151。使用这类端口号必须按照规定的手续登记，以防止重复。</li></ul></li><li>客户端使用的端口号，49152～65535。这类端口号尽在客户进程运行时才动态选择，因此又叫做短暂端口号。</li></ul><table><thead><tr class="header"><th>应用程序</th><th>FTP</th><th>TELNET</th><th>SMTP</th><th>DNS</th><th>TFTP</th><th>HTTP</th><th>HTTPS</th></tr></thead><tbody><tr class="odd"><td>孰知端口号</td><td>21</td><td>23</td><td>25</td><td>53</td><td>69</td><td>80</td><td>443</td></tr></tbody></table><p>运输层的两个主要协议：</p><ul><li>用户数据报协议 UDP（User Datagram Protocol）<ul><li>面向连接，可靠</li><li>一对一、全双工的，不提供广播或多播服务</li><li>面向字节流，根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少字节</li><li>流量控制，拥塞控制</li></ul></li><li>传输控制协议 TCP（Transmission Control Protocol）<ul><li>无连接的，不可靠，尽最大努力交付</li><li>支持一对一、一对多、多对一、多对多的交互通信</li><li>面向报文，对应用层交下来的报文，既不合并，也不拆分</li><li>没有拥塞控制</li><li>首部开销小，只有 8 个字节，有 4 个字段，每个字段的长度都是两个字节<ol type="1"><li>源端口，在需要对方回信时选用。不需要时可全为 0。</li><li>目的端口，若端口号不正确，就丢弃该报文，并由网际控制报文协议 ICMP 发送“端口不可达”差错报文给发送方。</li><li>长度，最小值是 8（仅有首部字段，没有数据字段）</li><li>检验和，检测数据报在传输中是否有错。有错就丢弃。</li></ol></li></ul></li></ul><a id="more"></a><h1 id="tcp-报文段">TCP 报文段</h1><p><img src="/uploads/image/computer-networking/tcp-header.jpeg"></p><ul><li>源端口和目的端口，各占 2 个字节，与 UDP 的分用类似，TCP 的分用功能也是通过端口实现的。</li><li>序号和确认号，各占 4 个字节。TCP 是面向字节流的，传送的字节流中的每一个字节都按顺序编号。序号是本报文段所发送的数据的第一个字节的序号；确认号是期望收到对方下一个报文段的第一个数据字节的序号。</li><li>数据偏移，占 4 位，数据起始距离报文段起始的偏移，因此也是报文段的首部长度。但应注意，数据偏移的单位是 32 位（即 4 字节）。由于 4 位二进制数能够表示的最大十进制数字是 15，因此数据偏移的最大值是 60 字节，这也是 TCP 首部的最大长度（即选项长度不能超过 40 字节）。</li><li>6 个控制位：紧急 URG，<strong>确认 ACK</strong>，推送 PSH，复位 RST，<strong>同步 SYN</strong>，<strong>终止 FIN</strong>。<strong>只有在 ACK = 1 时确认号字段才有意义</strong>。</li><li>窗口，占 2 个字节，指出现在允许对方发送的数据量（因为接收方的数据缓存空间是有限的）。窗口值经常在动态地变化着。</li><li>检验和，占 2 个字节。检验的范围包括<strong>首部和数据</strong>两部分。</li><li>选项，长度可变，最长 40 个字节。TCP 最初只规定了一种选项，即<strong>最大报文段长度</strong> MSS（Maximum Segment Size）。MSS 是<strong>数据字段的最大长度</strong>，不包括首部。随着互联网的发展，又陆续增加了几个选项，如<strong>窗口扩大</strong>选项、<strong>时间戳</strong>选项、<strong>选择确认（SACK）</strong>。</li></ul><p>为什么要规定一个最大报文段长度 MSS？</p><p>TCP 报文段的数据部分，至少要加上 40 字节（TCP 首部 20 字节和 IP首部 20 字节），才能组装成一个 IP 数据报。<strong>若选择较小的 MSS 值，网络的利用率就降低</strong>。反过来，若 MSS 非常大，那么在 IP 层传输时就有可能要分解成多个短数据报片。在终点要把收到的各个短数据报片装配成原来的 TCP 报文段。当传输出错时还要进行重传。这些也都会使开销增大。最佳的 MSS 是很难确定的。在连接建立的过程中，双方都把自己能够支持的 MSS 写入，两个传送方向可以有不同的 MSS 值。若主机未填写这一项，则 MSS 的默认值是 536 字节。</p><h1 id="可靠传输">可靠传输</h1><h2 id="滑动窗口">滑动窗口</h2><p>全双工通信的双方既是发送方也是接收方。因此，每一方都有自己的发送窗口和接收窗口。</p><p>TCP 的滑动窗口是以字节为单位的。</p><p>发送方的发送窗口大小不能超过接收方的接收窗口；发送窗口大小还要受到当时网络拥塞程度的制约。</p><p>发送窗口包含：</p><ol type="1"><li>已发送但未收到确认的数据</li><li>允许发送但尚未发送的数据</li></ol><p>接收窗口包含：</p><ol type="1"><li>未按序收到的数据（按序收到数据时窗口会向前滑动，因此按序收到的数据不会在接收窗口内）</li><li>允许接收的数据</li></ol><p>发送缓存包含：</p><ol type="1"><li>已发送但尚未收到确认的数据</li><li>准备发送的数据（可能位于发送窗口内，也可能不在窗口内）</li></ol><p>接收缓存包含：</p><ol type="1"><li>未按序收到的数据</li><li>按序到达，但尚未被接收应用程序读取的数据（位于接收窗口左侧）</li></ol><p>窗口通常只是缓存的一部分。</p><ul><li>虽然发送窗口是根据接收窗口设置的，但在同一时刻，它们并不总是一样大。这是因为通过网络传送窗口值需要经历一定的时间滞后，另外，发送方还可能根据拥塞情况适当减小自己的发送窗口大小。</li><li>对于不按序到达的数据应如何处理，TCP 标准并无明确规定。如果一律丢弃，那么接收窗口的管理将会比较简单，但对网络资源的利用不利。因此通常是先临时存放在接收窗口内，等缺少的字节收到后，再按序交付上层的应用进程。</li><li>TCP 要求接收方必须有<strong>累积确认</strong>的功能，这样可以减小传输开销。接收方可以在<strong>合适的时候</strong>发送确认，也可以在发送数据时<strong>捎带</strong>确认信息。但请注意两点。一是接收方不应过分推迟发送确认，否则会导致发送方不必要的重传，反而浪费了网络的资源。<strong>TCP 标准规定，确认推迟的时间不应超过 0.5 秒。若收到一连串具有最大长度的报文段，则必须每隔一个报文段就发送一个确认</strong>。二是捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。</li></ul><h2 id="超时重传时间">超时重传时间</h2><p>超时重传时间太短，就会引起很多不必要的重传，使网络负荷增大。太长，则又使网络的空闲时间增大，降低了传输效率。TCP 采用了一种<strong>自适应算法</strong>。</p><p>TCP 保留了 RTT 的一个加权平均往返时间 <span class="math inline">\(RTT_S\)</span>（S 表示 Smoothed）。</p><p><span class="math display">\[RTT_S^n=(1-\alpha)*RTT_S^{n-1}+\alpha*RTT^n\quad(0\le\alpha&lt;1)\]</span></p><p><span class="math inline">\(\alpha\)</span> 接近于 0，则新的 RTT 样本影响不大，<span class="math inline">\(RTT_S\)</span> 值更新较慢。推荐的 <span class="math inline">\(\alpha\)</span> 值为 1/8，即 0.125。</p><p><strong>超时重传时间</strong> RTO（Retransmission Time-Out）应略大于 <span class="math inline">\(RTT_S\)</span>，建议的公式为：</p><p><span class="math display">\[RTO=RTT_S+4*RTT_D\]</span></p><p><span class="math inline">\(RTT_D\)</span> 是 RTT 的偏差的加权平均值。<span class="math inline">\(\beta\)</span> 的推荐值是 1/4，即 0.25。</p><p><span class="math display">\[RTT_D^n=\begin{cases}0.5*RTT^1,\quad n=1\\ (1-\beta)*RTT_D^{n-1}+\beta*|RTT_S^n-RTT^n|,\quad n&gt;1\end{cases}\]</span></p><p>往返时间的测量实现起来相当复杂。试想，发送一个报文段，重传时间到了还没有收到确认，于是重传报文段。经过一段时间后，收到了确认报文段。现在的问题是：此报文段是对先发送的报文段的确认，还是对重传的报文段的确认？正确的判断对确定 <span class="math inline">\(RTT_S\)</span> 的值关系很大。</p><p>Karn 提出一个算法，只要报文段重传了，就不采用其往返时间成本。但这样，网络时延突然增大时，超时重传时间就无法更新。较为合理的策略是：<strong>报文段每重传一次，就把超时重传时间增大一些（典型做法是翻倍）。当不再发生重传时，才根据上面的公式计算超时重传时间</strong>。</p><h2 id="选择确认-sack">选择确认 SACK</h2><p>若收到的报文段无差错，只是未按序号，选择确认（Selective ACK）设法让发送方只传送缺少的数据而不重传已经正确到达接收方的数据。</p><p>接收到的数据字节流的序号不连续，就会形成一些不连续的字节块。接收方要把这些信息（字节块的边界）准确地告诉发送方，使发送方不要再重复发送这些数据。</p><p>如果要使用选择确认，那么在建立 TCP 连接时，就要在 TCP 首部的选项中加上“允许 SACK”选项，而双方必须都事先商定好。选项中只能报告最多 4 个字节块的边界信息。一个边界信息占 4 字节，共 8 个边界。此外，还需要 1 个字节指明是 SACK 选项和 1 字节指明这个选项要占用多少字节。总共 34 字节。TCP 首部选项的长度最多只有 40 字节。</p><h1 id="流量控制">流量控制</h1><h2 id="利用滑动窗口">利用滑动窗口</h2><p>TCP 通过让发送方维护一个称为接收窗口的变量 rwnd（receive window）来提供流量控制（flow control）。rwnd 用于给发送方（S）一个指示——接收方（R）还有多少可用的缓存空间。</p><p>S 通过将未确认的数据量控制在 rwnd 以内，就可以保证 R 的接收缓存不会溢出。现在有一个小小的问题，假设 R 的接收缓存已满，使得 rwnd = 0。R 在将 rwmd = 0 通告给 S 之后，还要假设 R 没有任何数据要发给 S。一段时间后，R 上的应用进程将缓存清空，但 TCP 仅在 R 有数据或者有确认要发时才会发送报文段给 S，这样，S 不可能知道 R 的接收缓存已经有新的空间了。</p><p>为了解决这个问题，TCP 规范要求：当 S 收到 R 的零窗口通知，就启动计时器。若计时器设置的时间到期，就发送一个零窗口<strong>探测报文段</strong>（只有一个字节数据的报文段），R 在确认这个报文段时给出新的 rwnd。</p><p>TCP 规定，即使设置为零窗口，也必须接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段。</p><h2 id="传输效率">传输效率</h2><p>应用进程把数据传送到 TCP 的发送缓存后，剩下的发送任务就由 TCP 来控制了。可以用不同的机制来控制 TCP 报文段的发送时机。 第一种机制，缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送。第二种机制，由应用进程指明要求发送报文段，即 TCP 支持的<strong>推送</strong>（push）操作。第三种机制，维持一个定时器，期限到了，就把当前已有的缓存数据装入报文段（但长度不能超过 MSS）发送出去。</p><p>在 TCP 的实现中广泛使用 Nagle 算法。算法如下：若发送应用进程要把数据<strong>逐个字节地发送到 TCP 的发送缓存</strong>（比如，一个交互式用户使用一条 TELNET 连接），则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。当发送方收到对第一个数据字节的确认后，再把发送缓存中的所有数据组装成一个报文段发送出去，同时继续对后续到达的数据进行缓存。只有在收到对前一个报文段的确认后才继续发送下一个报文段。Nagle 算法还规定，当到达的数据已达到发送窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段。当数据到达较快而网络速率较慢时，用这样的方法可以明显地减少所用的网络带宽。</p><p>试想另一种情况：接收方的缓存已满，而交互式的<strong>应用进程一次只从接收缓存读取一个字节</strong>，然后向发送方发送确认，并把窗口设置为 1 个字节。接着，发送方又发来 1 个字节的数据（注意，IP 数据报是 41 字节）。这样进行下去，使网络的效率很低。要解决这个问题，可以让接收方等待一段时间，使得接收缓存已有足够空间容纳一个最长的报文段，或者等到接收缓存已有一半空闲的空间，再发出确认报文并通知当前的窗口大小。接收方应 <strong>1. 适当推迟发回确认报文。 2. 尽量使用捎带确认。</strong></p><p>上述两种方法可配合使用。</p><h1 id="拥塞控制">拥塞控制</h1><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫做<strong>拥塞</strong>（congestion）。</p><p>拥塞常常趋于恶化。如果一个路由器没有足够的缓存空间，它就会丢弃一些新到的分组。但当分组被丢弃时，发送这一分组的源点就会重传这一分组，甚至可能还要重传多次。这样会引起更多的分组流入网络和被网络中的路由器丢弃。可见<strong>拥塞引起的重传并不会缓解拥塞，反而会加剧拥塞</strong>。</p><p>拥塞控制与流量控制的关系密切，但存在一些差别。拥塞控制就是<strong>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载</strong>。拥塞控制是一个<strong>全局性的过程</strong>，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制是指<strong>点对点通信量的控制</strong>，是个<strong>端到端</strong>的问题。流量控制要做的是抑制发送端发送数据的速率，以便使接收端来得及接收。</p><p>拥塞控制是很难设计的，因为它是一个动态的问题。分组的丢失是网络发生拥塞的征兆而不是原因。在许多情况下，甚至正是拥塞控制机制本身成为引起网络性能恶化甚至发生死锁（网络吞吐量下降到零，无法工作）的原因。</p><p>从大的方面看，拥塞控制可以分为<strong>开环控制和闭环控制</strong>两种方法。开环控制就是在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。但一旦整个系统运行起来，就不再中途进行改正了。闭环控制是基于<strong>反馈环路</strong>的概念，主要有以下几种措施：</p><ol type="1"><li>检测网络系统以便检测到拥塞在何处、何时发生。</li><li>把拥塞发生的信息传送到可采取行动的地方。</li><li>调整网络系统的运行以解决出现的问题。</li></ol><h2 id="tcp-的拥塞控制方法">TCP 的拥塞控制方法</h2><p>下面讨论的拥塞控制也叫做<strong>基于窗口</strong>的拥塞控制。发送方维持一个叫做<strong>拥塞窗口</strong> cwnd（congestion window）的状态变量，大小取决于网络的拥塞程度，并且动态地在变化。<strong>实际上 TCP 是用字节数作为窗口大小的单位</strong>。但为叙述方便起见，下面用报文段的个数作为窗口大小的单位。</p><p>TCP 进行拥塞控制的算法有四种，即<strong>慢开始</strong>（slow-start）、<strong>拥塞避免</strong>（congestion avoidance）、<strong>快重传</strong>（fast retransmit）和<strong>快恢复</strong>（fast recovery）。</p><h2 id="慢开始">慢开始</h2><p>当主机开始发送数据时，由于并不清楚网络的负荷情况，所以如果立即把大量数据字节注入网络，那么就有可能引起网络发生拥塞。经验证明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口。</p><p>在一开始发送方先设置 cwnd = 1，发送第一个报文段 M1，接收方收到后确认 M1。发送方收到确认后，把 cwnd 从 1 增大到 2，于是发送方接着发送 M2 和 M3。<strong>发送方每收到一个对新报文段的确认（重传的不算在内）就使拥塞窗口加 1</strong>，因此发送方在收到两个确认后，cwnd 就从 2 增大到 4。因此使用慢开始算法后，每经过一个传输轮次，拥塞窗口就加倍。（在 TCP 的实际运行中，发送方只要收到一个对新报文段的确认，其拥塞窗口就立即加 1，并可以立即发送新的报文段，而不需要等待这个轮次中所有的确认都收到后再发送新的报文段。）</p><h2 id="拥塞避免">拥塞避免</h2><p>为了防止拥塞窗口增长过大引起网络拥塞，还需要设置一个<strong>慢开始门限</strong> ssthresh：当 cwnd &lt; ssthres h时，使用慢开始算法；当 cwnd &gt; ssthresh时，该用拥塞避免算法；当 cwnd = ssthresh 时，既可以使用慢开始，也可以使用拥塞避免算法。</p><p>拥塞避免算法的思路是让拥塞窗口缓慢地增大，即每经过一个 RTT 就把拥塞窗口加 1，而不是加倍增长。当网络出现了超时，发送方判断为网络拥塞，调整门限值 ssthresh = cwnd / 2，同时设置拥塞窗口 cwnd = 1，进入慢开始阶段。</p><p>拥塞避免并非能够避免了拥塞，而是把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</p><h2 id="快重传">快重传</h2><p>有时，个别报文段会在网络中丢失，但实际上网络并未发生拥塞。如果发送方迟迟收不到确认，就会误认为网络发生了拥塞。这就导致发送方错误地启动慢开始，降低了传输效率。</p><p>采用快重传算法可以让发送方<strong>尽早知道发生了个别报文段的丢失</strong>。快重传算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要<strong>立即发送确认</strong>，即使收到了失序的报文段也要立即发出对已收到的报文段的<strong>重复确认</strong>。比如，接收方收到 M2，但没收到 M3。后续又收到了失序报文 M4～M6，本来，接收方可以直接丢弃失序报文。但按照快重传算法，接收方必须立即发送对 M2 的重复确认，以便让发送方及早知道接收方没有收到报文段 M3。快重传算法规定，发送方只要<strong>一连收到 3 个重复确认</strong>，应立即进行重传，这样就不会出现超时，发送方也就不会误认为出现了网络拥塞。</p><h2 id="快恢复">快恢复</h2><p>快重传发生时，发送方知道现在只是丢失了个别的报文段。于是不启动慢开始，而是执行快恢复算法：调整门限值 ssthresh = cwnd / 2，同时设置拥塞窗口 cwnd = ssthresh，并开始执行拥塞避免算法。</p><p>也有的快恢复实现是令 cwnd = ssthresh + 3 x MSS。这样做的理由是：既然发送方收到 3 个重复的确认，就表明有 3 个分组已经到达接收方的缓存中，可见现在网络中减少了 3 个分组。因此可以适当把拥塞窗口扩大些。</p><p>在拥塞避免阶段，拥塞窗口是按照线性规律增大的，这常称为<strong>加法增大</strong> AI（Additive Increase）。而一旦出现超时或 3 个重复的确认，就要把门限值设置为当前拥塞窗口值的一半，并大大减小拥塞窗口的数值，这常称为<strong>乘法减小</strong> MD（Multiplicative Decrease）。二者合在一起就是所谓的 <strong>AIMD</strong> 算法。</p><h2 id="结合流量控制">结合流量控制</h2><p>上面的讨论基于接收方总是有足够大的缓存空间的假定，但实际上接收方的缓存空间总是有限的。如果把拥塞控制和流量控制一起考虑，那么很显然，发送方的窗口的上限值应当取接收方窗口 rwnd 和拥塞窗口 cwnd 中较小的一个。</p><h2 id="全局同步">全局同步</h2><p>上节讨论的拥塞控制并没有和网络层采取的策略联系起来。网络层的策略对拥塞控制影响最大的就是<strong>路由器的分组丢弃策略</strong>。</p><p>在最简单的情况下，路由器的队列通常都是按照“先进先出” FIFO（First In First Out）的规则处理到来的分组。当队列已满时，以后再到达的分组都将被丢弃，这叫做“尾部丢弃策略”（tail-drop policy）。尾部丢弃往往会导致一连串分组的丢失，这就使发送方出现超时重传，使 TCP 进入慢开始状态。更为严重的是，在网络中通常有很多 TCP 连接，这些连接中的报文段通常是复用在网络层中的 IP 数据报中传送。在这种情况下，若发生了尾部丢弃，就可能会同时影响到很多条 TCP 连接，结果使这些连接在<strong>同一时间</strong>突然都进入慢开始状态。这在 TCP 术语中称为<strong>全局同步</strong>（global synchronization）。全局同步使得全网的通信量突然下降了很多，而在网络恢复正常后，其通信量又突然增大很多。</p><h2 id="主动队列管理-aqm">主动队列管理 AQM</h2><p>主动队列管理（Active Queue Management），所谓“主动”就是不要等到路由器的队列长度已经达到最大值时才不得不丢弃后面到达的分组。应当在队列长度到达某个值得警惕的数值时（即当网络拥塞有了某些征兆时），就主动丢弃到达的分组。这样就提醒了发送方放慢发送的速率，因而有可能使网络拥塞的程度减轻，甚至不出现。</p><p>AQM 可以有不同的实现方法，曾流行多年的就是<strong>随机早期检测</strong> RED（Random Early Detection）。实现 RED 时需要路由器维持两个参数，即队列长度的最小门限和最大门限。当每一个分组到达时，就按照规定的算法计算当前的平均队列长度，若平均队列长度</p><ol type="1"><li>小于最小门限，接收新到达的分组</li><li>大于最大门限，丢弃新到达的分组</li><li>介于两者之间，按照某一丢弃概率 p 丢弃新到达的分组</li></ol><p>在 RED 的操作中，最难处理的就是丢弃概率 p 的选择，因为 p 并不是一个常数。对每一个到达的分组，都必须计算 p 的数值。多年的实践证明，<strong>RED 的使用效果并不太理想</strong>。目前还没有一种算法能够成为 IEFT 标准。</p><h1 id="连接管理">连接管理</h1><p>运输连接有三个阶段：<strong>连接建立</strong>、<strong>数据传送</strong>和<strong>连接释放</strong>。在 TCP 连接建立过程中要解决以下三个问题：</p><ol type="1"><li>要使每一方都能确知对方的存在</li><li>要允许双方协商一些参数（如最大窗口值，是否使用窗口扩大选项和时间戳选项以及服务质量等）</li><li>能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配</li></ol><h2 id="连接建立">连接建立</h2><p>三次握手。握手开始前，服务器需处于 LISTEN 状态，等待客户的连接请求。</p><p><img src="/uploads/image/computer-networking/three-way-handshake.jpg"></p><ol type="1"><li>客户发出连接请求报文段，并进入 SYN-SENT 状态。请求报文不能携带数据，但要消耗一个序号 x。</li><li>服务器收到请求报文，如同意建立连接，则发送确认报文并进入 SYN-RCVD 状态。确认报文也不能携带数据，也要消耗一个序号 y。</li><li>客户收到确认后，还要发送对确认的确认，之后进入 ESTABLISHED 状态。这个报文可以携带数据。</li><li>服务器收到确认的确认后，也进入 ESTABLISHED 状态。</li></ol><p><strong>注意</strong>：第三次握手，客户可以携带数据，也可以不携带数据。但如果不携带数据则不消耗序号，下一个数据报文段的序号仍是 seq = x + 1。携带数据，则按照数据长度计算下一个报文段的序号。</p><p>为什么有第三次握手？这主要是为了<strong>防止已失效的连接请求报文突然又传送到了服务器</strong>，因而产生错误。考虑一种情况：C 发出连接请求，但迟迟没有收到 S 的确认。于是 C 重传一次请求，随后收到了确认，建立了连接。数据传输完毕后，就释放了连接。现在假定 C 的第一个请求报文段并没有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达 S。本来这应是一个失效的请求，但 S 收到后就误以为 C 又发起一次新的连接请求，于是向 C 发出确认报文，同意建立连接。如果没有第三次握手，新的连接就已经建立了。由于 C 没有发出新的请求，因此会丢弃确认报文。但 S 却以为新的连接已经建立了，并一直在等待 C 发来数据。S 的许多资源就这样白白浪费了。</p><h2 id="连接释放">连接释放</h2><p>四次挥手</p><p><img src="/uploads/image/computer-networking/four-way-handshake.jpg"></p><p>数据传输结束后，双方都可释放连接，下面假设客户先发起连接释放。</p><ol type="1"><li>客户发送释放报文（FIN = 1），进入 FIN-WAIT-1 状态。FIN 报文可以携带数据。即使不携带数据，也要消耗一个序号。</li><li>服务器收到后发出确认，进入 CLOSE-WAIT 状态。这时 TCP 处于半关闭状态。从服务器到客户端的连接并未关闭，这个状态可能会持续一段时间。</li><li>若服务器没有数据要发送，就释放连接。发送释放报文（FIN = 1），并进入 LAST-ACK 状态。</li><li>客户收到释放报文后，必须对此确认。注意 seq = u + 1，因为前一个客户发出的释放报文（这里假设未携带数据）要消耗一个序号。然后进入 TIMW-WAIT 状态。必须经过<strong>时间等待计时器</strong>（TIME-WAIT timer）设置的时间 2MSL 后，才进入到 CLOSED 状态。时间 MSL 叫做<strong>最长报文段寿命</strong>（Maximum Segment Lifetime）。</li></ol><p>为什么必须等待 2MSL 时间呢？这有两个理由：</p><ol type="1"><li>为了保证客户的最后一个 ACK 报文段能够到达服务器。这个 ACK 可能会丢失，服务器迟迟收不到就会重传 FIN + ACK 报文段，客户就能在 2MSL 时间内收到重传的 FIN + ACK 报文段。接着，发送确认并重置计时器。</li><li>防止“已失效的连接请求报文段”出现在本连接中。客户发出最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续时间内所产生的所有报文段都从网络上消失。这样，下一个新的连接中就不会出现旧的连接请求报文段。</li></ol><p>除了时间等待计时器，TCP 还设有一个<strong>保活计时器</strong>（keepalive timer）。服务器每收到一次客户的数据，就重置保活计时器，时间的设置通常是两小时。若两小时没有收到客户的数据，服务器就发送一个探测报文段，以后每隔 75 秒发送一次。若一连发送 10 个探测报文段后仍无客户的响应，服务器就认为客户端出了故障，接着就关闭这个连接。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;只有主机的协议栈才有运输层，而路由器在转发分组时都只用到下三层（物理层、数据链路层和网络层）的功能。&lt;/p&gt;
&lt;p&gt;从运输层的角度来看，通信的真正端点并不是主机而是主机中的进程。IP 协议虽然能把分组送到目的主机，但是这个分组没有交付主机中的应用进程。这表明，运输层有一个很重要的功能——&lt;strong&gt;复用&lt;/strong&gt;（multiplexing）和&lt;strong&gt;分用&lt;/strong&gt;（demultiplexing）。复用是指在发送方不同的应用进程都可以使用同一个运输层协议传送数据（当然需要加上适当的首部），而分用是指接收方的运输层在剥去报文的首部后能够把这些数据正确交付目的应用进程。&lt;/p&gt;
&lt;p&gt;网络层为主机之间提供逻辑通信，而运输层&lt;strong&gt;为应用进程之间提供端到端的逻辑通信&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;运输层还要对收到的报文进行&lt;strong&gt;差错检测&lt;/strong&gt;。在网络层，IP 数据报首部中的检验和字段，只检验首部而不检查数据部分。&lt;/p&gt;
&lt;p&gt;当运输层采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条全双工的可靠信道。但当采用无连接的 UDP 协议时，这种逻辑通信信道仍然是一条不可靠信道。&lt;/p&gt;
&lt;p&gt;两个计算机中的进程要相互通信，不仅必须知道对方的 IP 地址（为了找到对方的计算机），而且还要知道对方的端口号（为了找到对方计算机中的应用进程）。TCP/IP 的运输层使用一个 16 位（可允许有 65535 个不同的端口，这个数目对一个计算机来说是足够用的）端口号来标志一个端口。&lt;/p&gt;
&lt;p&gt;端口号分为下面两大类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器段使用的端口号
&lt;ul&gt;
&lt;li&gt;孰知端口号，0～1023。这些端口号被指派给了 TCP/IP 最重要的一些应用程序。&lt;/li&gt;
&lt;li&gt;登记端口号，1024～49151。使用这类端口号必须按照规定的手续登记，以防止重复。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;客户端使用的端口号，49152～65535。这类端口号尽在客户进程运行时才动态选择，因此又叫做短暂端口号。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th&gt;应用程序&lt;/th&gt;
&lt;th&gt;FTP&lt;/th&gt;
&lt;th&gt;TELNET&lt;/th&gt;
&lt;th&gt;SMTP&lt;/th&gt;
&lt;th&gt;DNS&lt;/th&gt;
&lt;th&gt;TFTP&lt;/th&gt;
&lt;th&gt;HTTP&lt;/th&gt;
&lt;th&gt;HTTPS&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td&gt;孰知端口号&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;23&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;53&lt;/td&gt;
&lt;td&gt;69&lt;/td&gt;
&lt;td&gt;80&lt;/td&gt;
&lt;td&gt;443&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;运输层的两个主要协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户数据报协议 UDP（User Datagram Protocol）
&lt;ul&gt;
&lt;li&gt;面向连接，可靠&lt;/li&gt;
&lt;li&gt;一对一、全双工的，不提供广播或多播服务&lt;/li&gt;
&lt;li&gt;面向字节流，根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少字节&lt;/li&gt;
&lt;li&gt;流量控制，拥塞控制&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;传输控制协议 TCP（Transmission Control Protocol）
&lt;ul&gt;
&lt;li&gt;无连接的，不可靠，尽最大努力交付&lt;/li&gt;
&lt;li&gt;支持一对一、一对多、多对一、多对多的交互通信&lt;/li&gt;
&lt;li&gt;面向报文，对应用层交下来的报文，既不合并，也不拆分&lt;/li&gt;
&lt;li&gt;没有拥塞控制&lt;/li&gt;
&lt;li&gt;首部开销小，只有 8 个字节，有 4 个字段，每个字段的长度都是两个字节
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;源端口，在需要对方回信时选用。不需要时可全为 0。&lt;/li&gt;
&lt;li&gt;目的端口，若端口号不正确，就丢弃该报文，并由网际控制报文协议 ICMP 发送“端口不可达”差错报文给发送方。&lt;/li&gt;
&lt;li&gt;长度，最小值是 8（仅有首部字段，没有数据字段）&lt;/li&gt;
&lt;li&gt;检验和，检测数据报在传输中是否有错。有错就丢弃。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://cwscn.github.io/categories/notes/"/>
    
    
      <category term="Computer Networking" scheme="https://cwscn.github.io/tags/Computer-Networking/"/>
    
      <category term="TCP" scheme="https://cwscn.github.io/tags/TCP/"/>
    
      <category term="UDP" scheme="https://cwscn.github.io/tags/UDP/"/>
    
      <category term="flow control" scheme="https://cwscn.github.io/tags/flow-control/"/>
    
      <category term="congestion control" scheme="https://cwscn.github.io/tags/congestion-control/"/>
    
  </entry>
  
  <entry>
    <title>Reverse Linked List</title>
    <link href="https://cwscn.github.io/programming/leetcode/reverse-linked-list/"/>
    <id>https://cwscn.github.io/programming/leetcode/reverse-linked-list/</id>
    <published>2020-07-09T02:08:14.000Z</published>
    <updated>2020-07-09T05:45:14.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="revserse-linked-list-i">Revserse Linked List I</h1><p>Reverse a singly linked list.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><p>Follow up:</p><p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p><h2 id="iteration">Iteration</h2><p>Given a linked list <code>1 -&gt; 2 -&gt; 3</code>, we think it as <code>None .&gt; 1 -&gt; 2 -&gt; 3 -&gt; None</code>, then change the pointers from left. Thus, we need change three pointers for a linked list with size 3. Don't forget the <code>next</code> in new tail node need to be <code>None</code>.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Initial:  None .&gt; 1 -&gt; 2 -&gt; 3 -&gt; None</span><br><span class="line">           ^      ^</span><br><span class="line">          pre    cur</span><br><span class="line"></span><br><span class="line">Details when fix the pointers:</span><br><span class="line">    1. temp = cur.next</span><br><span class="line">    2. cur.next = pre</span><br><span class="line">    3. pre = cur</span><br><span class="line">    4. cur = temp</span><br><span class="line"></span><br><span class="line">(1)       None &lt;- 1    2 -&gt; 3 -&gt; None</span><br><span class="line">                  ^    ^</span><br><span class="line">                 pre  cur</span><br><span class="line"></span><br><span class="line">(2)       None &lt;- 1 &lt;- 2    3 -&gt; None</span><br><span class="line">                       ^    ^</span><br><span class="line">                      pre  cur</span><br><span class="line"></span><br><span class="line">(3)       None &lt;- 1 &lt;- 2 &lt;- 3    None</span><br><span class="line">                            ^     ^</span><br><span class="line">                           pre   cur</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        curr, prev = head, <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            prev, prev.next, curr = curr, prev, curr.next</span><br><span class="line">            <span class="string">'''</span></span><br><span class="line"><span class="string">            temp = curr.next</span></span><br><span class="line"><span class="string">            curr.next = prev</span></span><br><span class="line"><span class="string">            prev = curr</span></span><br><span class="line"><span class="string">            curr = temp</span></span><br><span class="line"><span class="string">            '''</span></span><br><span class="line">        <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="recursion">Recursion</h2><p>The recursive version is slightly trickier and the key is to work backwards. Assume that the rest of the list had already been reversed, now how do I reverse the front part? Let's assume the list is: <span class="math inline">\(n_1 \rightarrow \dots \rightarrow n_{k-1} \rightarrow n_k \rightarrow n_{k+1} \rightarrow \dots \rightarrow n_m \rightarrow \emptyset\)</span>.</p><p>Assume from node <span class="math inline">\(n_{k+1}\)</span> to <span class="math inline">\(n_m\)</span> had been reversed and you are at node <span class="math inline">\(n_k\)</span>: <span class="math inline">\(n_1 \rightarrow \dots \rightarrow n_{k-1} \rightarrow n_k \rightarrow n_{k+1} \leftarrow \dots \leftarrow n_m\)</span>.</p><p>We want <span class="math inline">\(n_{k+1}\)</span>’s next node to point to <span class="math inline">\(n_k\)</span>. So, <span class="math inline">\(n_k\)</span>.next.next = <span class="math inline">\(n_k\)</span>;</p><p>Be very careful that <span class="math inline">\(n_1\)</span>'s next must point to <span class="math inline">\(\emptyset\)</span>. If you forget about this, your linked list has a cycle in it. This bug could be caught if you test your code with a linked list of size 2.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n1 -&gt; n2 -&gt; n3 -&gt; None</span><br><span class="line"></span><br><span class="line">reverseList(n1):</span><br><span class="line">    reverseList(n2):</span><br><span class="line">        reverseList(n3):</span><br><span class="line">            return n3</span><br><span class="line">        p = n3</span><br><span class="line">        n2.next.next = n2</span><br><span class="line">        n2.next = None</span><br><span class="line">        return n3        (n1 -&gt; n2 &lt;- n3)</span><br><span class="line">                                |-&gt; None</span><br><span class="line">    p = n3</span><br><span class="line">    n1.next.next = n1</span><br><span class="line">    n1.next = None       (None &lt;- n1 &lt;- n2 &lt;- n3)</span><br><span class="line">    return n3</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        p = self.reverseList(head.next)  <span class="comment"># return new head</span></span><br><span class="line">        head.next.next = head  <span class="comment"># old head is the new tail</span></span><br><span class="line">        head.next = <span class="literal">None</span>  <span class="comment"># set tail.next to None</span></span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure><h1 id="reverse-linked-list-ii">Reverse Linked List II</h1><p>Reverse a linked list from position m to n. <strong>Do it in one-pass</strong>.</p><p>Note: <span class="math inline">\(1 \le m \le n \le\)</span> length of list.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4</span><br><span class="line">Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure><h2 id="iteration-1">Iteration</h2><p>Given a linked list initially with elements <code>7 -&gt; 9 -&gt; 2 -&gt; 10 -&gt; 1 -&gt; 8 -&gt; 6</code> and we need to reverse the list from node 3 throught 6.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  None .&gt; 7 -&gt; 9 -&gt; 2 -&gt; 10 -&gt; 1 -&gt; 8 -&gt; 6 -&gt; None</span><br><span class="line">   ^      ^</span><br><span class="line">  pre    cur</span><br><span class="line"></span><br><span class="line">Step forward until cur reach the node 3:</span><br><span class="line"></span><br><span class="line">  None .&gt; 7 -&gt; 9 -&gt; 2 -&gt; 10 -&gt; 1 -&gt; 8 -&gt; 6 -&gt; None</span><br><span class="line">               ^    ^</span><br><span class="line">              pre  cur</span><br><span class="line">              con  tail</span><br><span class="line"></span><br><span class="line">Fix connections until pre reach node 6:</span><br><span class="line"></span><br><span class="line">  None .&gt; 7 -&gt; 9 &lt;-&gt; 2 &lt;- 10 &lt;- 1 &lt;- 8    6 -&gt; None</span><br><span class="line">               ^     ^               ^    ^</span><br><span class="line">              con   tai             pre  cur</span><br><span class="line"></span><br><span class="line">Adjust connections:  con -&gt; pre  tail -&gt; cur</span><br><span class="line"></span><br><span class="line">  None .&gt; 7 -&gt; 9 -&gt; 8 -&gt; 1 -&gt; 10 -&gt; 2 -&gt; 6 -&gt; None</span><br><span class="line">               ^    ^               ^    ^</span><br><span class="line">              con  pre             tail cur</span><br><span class="line"></span><br><span class="line">Be careful that con is None when m = 1.</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head: ListNode, m: int, n: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Move the pointers until they reach the proper starting point</span></span><br><span class="line">        pre, cur = <span class="literal">None</span>, head</span><br><span class="line">        <span class="keyword">while</span> m &gt; <span class="number">1</span>:</span><br><span class="line">            pre, cur = cur, cur.next</span><br><span class="line">            m, n = m - <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># The two pointers that will fix the final connections</span></span><br><span class="line">        con, tail = pre, cur</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Iteratively reverse the nodes</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            pre, pre.next, cur = cur, pre, cur.next</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Adjust the final connections</span></span><br><span class="line">        <span class="keyword">if</span> con:</span><br><span class="line">            con.next = pre</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            head = pre</span><br><span class="line">        tail.next = cur</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h2 id="recursion-1">Recursion</h2><p>The recursive function to reverse a linked list:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        p = self.reverseList(head.next)  <span class="comment"># return new head</span></span><br><span class="line">        head.next.next = head  <span class="comment"># old head is the new tail</span></span><br><span class="line">        head.next = <span class="literal">None</span>  <span class="comment"># set tail.next to None</span></span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure><p>To reverse first n elements:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseN</span><span class="params">(self, head: ListNode, n: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        successor = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(head, n)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> successor</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">                successor = head.next</span><br><span class="line">                <span class="keyword">return</span> head  <span class="comment"># new tail</span></span><br><span class="line">            p = helper(head.next, n - <span class="number">1</span>)</span><br><span class="line">            head.next.next = head</span><br><span class="line">            head.next = successor</span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(head, n)</span><br></pre></td></tr></table></figure><p>Finally, solve the problem:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head: ListNode, m: int, n: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.reverseN(head, n)</span><br><span class="line">        head.next = self.reverseBetween(head.next, m - <span class="number">1</span>, n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;revserse-linked-list-i&quot;&gt;Revserse Linked List I&lt;/h1&gt;
&lt;p&gt;Reverse a singly linked list.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Follow up:&lt;/p&gt;
&lt;p&gt;A linked list can be reversed either iteratively or recursively. Could you implement both?&lt;/p&gt;
&lt;h2 id=&quot;iteration&quot;&gt;Iteration&lt;/h2&gt;
&lt;p&gt;Given a linked list &lt;code&gt;1 -&amp;gt; 2 -&amp;gt; 3&lt;/code&gt;, we think it as &lt;code&gt;None .&amp;gt; 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; None&lt;/code&gt;, then change the pointers from left. Thus, we need change three pointers for a linked list with size 3. Don&#39;t forget the &lt;code&gt;next&lt;/code&gt; in new tail node need to be &lt;code&gt;None&lt;/code&gt;.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Initial:  None .&amp;gt; 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; None&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           ^      ^&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          pre    cur&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Details when fix the pointers:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    1. temp = cur.next&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    2. cur.next = pre&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    3. pre = cur&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    4. cur = temp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(1)       None &amp;lt;- 1    2 -&amp;gt; 3 -&amp;gt; None&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  ^    ^&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 pre  cur&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(2)       None &amp;lt;- 1 &amp;lt;- 2    3 -&amp;gt; None&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                       ^    ^&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      pre  cur&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(3)       None &amp;lt;- 1 &amp;lt;- 2 &amp;lt;- 3    None&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            ^     ^&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                           pre   cur&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Time: O(n)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Space: O(1)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;reverseList&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, head: ListNode)&lt;/span&gt; -&amp;gt; ListNode:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; head &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; head.next:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; head&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        curr, prev = head, &lt;span class=&quot;literal&quot;&gt;None&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; curr:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            prev, prev.next, curr = curr, prev, curr.next&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;            temp = curr.next&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;            curr.next = prev&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;            prev = curr&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;            curr = temp&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;            &#39;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; prev&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://cwscn.github.io/categories/programming/"/>
    
    
      <category term="recursion" scheme="https://cwscn.github.io/tags/recursion/"/>
    
      <category term="linked list" scheme="https://cwscn.github.io/tags/linked-list/"/>
    
      <category term="reverse" scheme="https://cwscn.github.io/tags/reverse/"/>
    
  </entry>
  
  <entry>
    <title>Populating Next Right Pointers in Each Node</title>
    <link href="https://cwscn.github.io/programming/leetcode/populating-next-right-pointers-in-each-node/"/>
    <id>https://cwscn.github.io/programming/leetcode/populating-next-right-pointers-in-each-node/</id>
    <published>2020-07-08T03:16:12.000Z</published>
    <updated>2020-07-13T13:38:20.327Z</updated>
    
    <content type="html"><![CDATA[<p>You are given a <strong>perfect binary tree</strong> where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p><p>Initially, all next pointers are set to <code>NULL</code>.</p><p><strong>Follow up</strong>:</p><ul><li>You may only use constant extra space.</li><li>Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.</li></ul><p>Example 1:</p><p><img src="/uploads/image/leetcode/connect_next.png"></p><p>Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B.</p><p>Constraints:</p><ul><li>The number of nodes in the given tree is less than 4096.</li><li><code>-1000 &lt;= node.val &lt;= 1000</code></li></ul><h1 id="level-order-traversal">Level Order Traversal</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        level = deque([root])</span><br><span class="line">        <span class="keyword">while</span> level:</span><br><span class="line">            n = len(level)</span><br><span class="line">            <span class="keyword">while</span> n:</span><br><span class="line">                cur = level.popleft()</span><br><span class="line">                n -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> n:  <span class="comment"># n &gt; 0 means level[0] and cur are in one level</span></span><br><span class="line">                    cur.next = level[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    level.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    level.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="without-extra-space">Without extra space</h1><p>Utilize the next pointers constructed before to visit a level from left to right. For each node visited:</p><ol type="1"><li>connect left child and right child.</li><li>connect right child and left child of next node.</li></ol><p>Then, go to next level. Repeat two steps for each node.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Initial:</span><br><span class="line"></span><br><span class="line">         1</span><br><span class="line">     /       \</span><br><span class="line">   2           3</span><br><span class="line"> /   \       /   \</span><br><span class="line">4     5     6     7</span><br><span class="line"></span><br><span class="line">cur = root, fix the pointers of root&apos;s children:</span><br><span class="line"></span><br><span class="line">         1</span><br><span class="line">     /       \</span><br><span class="line">   2    --&gt;    3</span><br><span class="line"> /   \       /   \</span><br><span class="line">4     5     6     7</span><br><span class="line"></span><br><span class="line">Fix the pointers of node 2:</span><br><span class="line"></span><br><span class="line">         1</span><br><span class="line">     /       \</span><br><span class="line">   2    --&gt;    3</span><br><span class="line"> /   \       /   \</span><br><span class="line">4 --&gt; 5 --&gt; 6    7</span><br><span class="line"></span><br><span class="line">Fix the pointers of node 3:</span><br><span class="line"></span><br><span class="line">         1</span><br><span class="line">     /       \</span><br><span class="line">   2    --&gt;    3</span><br><span class="line"> /   \       /   \</span><br><span class="line">4 --&gt; 5 --&gt; 6 --&gt; 7</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root: Node)</span> -&gt; Node:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        level = root</span><br><span class="line">        <span class="keyword">while</span> level.left:  <span class="comment"># 进行到倒数第二层，修改下一层的指针</span></span><br><span class="line">            cur = level</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                <span class="comment"># 连接节点的左右孩子节点</span></span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    cur.left.next = cur.right</span><br><span class="line">                <span class="comment"># 连接右节点与下一个兄弟节点的左节点</span></span><br><span class="line">                <span class="keyword">if</span> cur.next:</span><br><span class="line">                    cur.right.next = cur.next.left</span><br><span class="line">                cur = cur.next  <span class="comment"># 对下一个兄弟节点做同样操作</span></span><br><span class="line">            level = level.left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="recursion">Recursion</h1><p>For each node, we did two steps. This hint us recursion.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root: Node)</span> -&gt; Node:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> node.left:  <span class="comment"># 有子节点</span></span><br><span class="line">                node.left.next = node.right</span><br><span class="line">                <span class="keyword">if</span> node.next:  <span class="comment"># 有兄弟节点</span></span><br><span class="line">                    node.right.next = node.next.left</span><br><span class="line">                helper(node.left)  <span class="comment"># 递归其子节点</span></span><br><span class="line">                helper(node.right)</span><br><span class="line"></span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;You are given a &lt;strong&gt;perfect binary tree&lt;/strong&gt; where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;struct Node &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  int val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Node *left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Node *right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Node *next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to &lt;code&gt;NULL&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Initially, all next pointers are set to &lt;code&gt;NULL&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow up&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You may only use constant extra space.&lt;/li&gt;
&lt;li&gt;Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example 1:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/uploads/image/leetcode/connect_next.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B.&lt;/p&gt;
&lt;p&gt;Constraints:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The number of nodes in the given tree is less than 4096.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-1000 &amp;lt;= node.val &amp;lt;= 1000&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;level-order-traversal&quot;&gt;Level Order Traversal&lt;/h1&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; collections &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; deque&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Time: O(n)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Space: O(n)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, root: TreeNode)&lt;/span&gt; -&amp;gt; TreeNode:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; root:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; root&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        level = deque([root])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; level:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            n = len(level)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; n:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                cur = level.popleft()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                n -= &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; n:  &lt;span class=&quot;comment&quot;&gt;# n &amp;gt; 0 means level[0] and cur are in one level&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    cur.next = level[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; cur.left:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    level.append(cur.left)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; cur.right:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    level.append(cur.right)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; root&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://cwscn.github.io/categories/programming/"/>
    
    
      <category term="leetcode" scheme="https://cwscn.github.io/tags/leetcode/"/>
    
      <category term="tree" scheme="https://cwscn.github.io/tags/tree/"/>
    
      <category term="traversal" scheme="https://cwscn.github.io/tags/traversal/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree Right Side View</title>
    <link href="https://cwscn.github.io/programming/leetcode/binary-tree-right-side-view/"/>
    <id>https://cwscn.github.io/programming/leetcode/binary-tree-right-side-view/</id>
    <published>2020-07-08T02:42:06.000Z</published>
    <updated>2020-07-13T13:37:29.717Z</updated>
    
    <content type="html"><![CDATA[<p>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3,null,5,null,4]</span><br><span class="line">Output: [1, 3, 4]</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">   1            &lt;---</span><br><span class="line"> /   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></table></figure><h1 id="level-order-traversal">Level Order Traversal</h1><p>Return the list that contains the last node in each order.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        level, res = deque([root]), []</span><br><span class="line">        node = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> level:</span><br><span class="line">            n = len(level)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">                node = level.popleft()</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    level.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    level.append(node.right)</span><br><span class="line">            res.append(node.val)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="preorder">Preorder</h1><p>Modify the pre order traversal, we visit the node first, then right child, finally left child.</p><p>The first node we visit at each level is the rightmost. So we need to save the depth for each node.</p><h2 id="iteration">Iteration</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack, res = [(root, <span class="number">1</span>)], []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node, depth = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> depth &gt; len(res):</span><br><span class="line">                res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append((node.left, depth + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append((node.right, depth + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="recursion">Recursion</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(node, depth, ans)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> depth &gt; len(ans):  <span class="comment"># meet the rightmost</span></span><br><span class="line">                ans.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                helper(node.right, depth + <span class="number">1</span>, ans)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                helper(node.left, depth + <span class="number">1</span>, ans)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        helper(root, <span class="number">1</span>, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: [1,2,3,null,5,null,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: [1, 3, 4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   1            &amp;lt;---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; /   \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2     3         &amp;lt;---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; \     \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  5     4       &amp;lt;---&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;level-order-traversal&quot;&gt;Level Order Traversal&lt;/h1&gt;
&lt;p&gt;Return the list that contains the last node in each order.&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; collections &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; deque&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Time: O(n)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Space: O(n)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;rightSideView&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, root: TreeNode)&lt;/span&gt; -&amp;gt; list:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; root:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        level, res = deque([root]), []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        node = &lt;span class=&quot;literal&quot;&gt;None&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; level:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            n = len(level)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; _ &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(n):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                node = level.popleft()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; node.left:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    level.append(node.left)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; node.right:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    level.append(node.right)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            res.append(node.val)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://cwscn.github.io/categories/programming/"/>
    
    
      <category term="leetcode" scheme="https://cwscn.github.io/tags/leetcode/"/>
    
      <category term="binary tree" scheme="https://cwscn.github.io/tags/binary-tree/"/>
    
      <category term="traversal" scheme="https://cwscn.github.io/tags/traversal/"/>
    
      <category term="level order" scheme="https://cwscn.github.io/tags/level-order/"/>
    
  </entry>
  
</feed>
