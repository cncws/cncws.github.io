<!DOCTYPE html><html lang="zh-CN,en,default"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/uploads/icon/drop/128x128.png"><link rel="icon" type="image/png" sizes="32x32" href="/uploads/icon/drop/32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/uploads/icon/drop/16x16.png"><link rel="mask-icon" href="/uploads/icon/drop/drop.svg" color="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="NKt2iJb3Hnl6-Sm7LB-fTT7LRyi9cg5yZrB-zd0ohtk"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"cwscn.github.io",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1,width:240},copycode:{enable:!0,show_result:!0,style:"flat"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"manual"},fancybox:!1,mediumzoom:!0,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"fadeIn"}},path:"search.xml"}</script><meta name="keywords" content="blog"><meta property="og:type" content="website"><meta property="og:title" content="春夏秋冬"><meta property="og:url" content="https://cwscn.github.io/page/15/index.html"><meta property="og:site_name" content="春夏秋冬"><meta property="og:locale" content="zh-CN"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="春夏秋冬"><link rel="canonical" href="https://cwscn.github.io/page/15/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!0,isPost:!1,lang:"zh-CN"}</script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css"><link rel="stylesheet" href="//unpkg.com/video.js/dist/video-js.min.css"><link rel="stylesheet" href="/css/videojs-bilibili.css"><style>.aplayer.aplayer-arrow .aplayer-icon-loop,.aplayer.aplayer-arrow .aplayer-icon-order{display:inline-block}</style><title>春夏秋冬</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">春夏秋冬</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">人有悲欢离合 月有阴晴圆缺</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档<span class="badge">290</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类<span class="badge">28</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签<span class="badge">115</span></a></li><li class="menu-item menu-item-收藏"><a href="/favlist/" rel="section"><i class="fa fa-star fa-fw"></i> 收藏</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div><meting-js server="netease" type="playlist" id="67155774" theme="#ff5555" loop="all" order="list" preload="none" volume="" mutex="" list-folded="NaN" fixed="true"></meting-js></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content index posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwscn.github.io/leetcode/binary-tree-maximum-path-sum/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar/nekosensei.png"><meta itemprop="name" content="菜农陈文生"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="春夏秋冬"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/leetcode/binary-tree-maximum-path-sum/" class="post-title-link" itemprop="url">Binary Tree Maximum Path Sum</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-08-10 15:20:37" itemprop="dateModified" datetime="2020-08-10T15:20:37+08:00">2020-08-10</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span></span><span id="/leetcode/binary-tree-maximum-path-sum/" class="post-meta-item leancloud_visitors" data-flag-title="Binary Tree Maximum Path Sum" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><p>Given a <strong>non-empty</strong> binary tree, find the maximum path sum.</p><p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree <strong>along the parent-child connections</strong>. The path must contain <strong>at least one node</strong> and does not need to go through the root.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      / \</span><br><span class="line">     2   3</span><br><span class="line"></span><br><span class="line">Output: 6</span><br><span class="line">Explanation: sum of path 2 - 1 - 3</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [-10,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">   -10</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">Output: 42</span><br><span class="line">Explanation: sum of path 15 - 20 - 7</span><br></pre></td></tr></table></figure><h1 id="before-coding">Before coding</h1><p>From examples, we know that the maximum path sum have two cases:</p><ol type="1"><li>connected a node with it's left or right child. (<code>a -&gt; a.left</code> or <code>a -&gt; a.right</code>)</li><li>connected a node with it's both left and right child. (<code>a.left -&gt; a -&gt; a.right</code>)</li></ol><p>The key difference between 1 and 2 is case 1 can connect <code>a</code> with it's parent (if exists), but 2 can't.</p><p>Take away the case 2. It would be much easier to design an algorithm solving it. Here gives the recursion algrithm.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = float(<span class="string">'-inf'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>  <span class="comment"># return 0 when node is None</span></span><br><span class="line">    left_sum = max(helper(node.left), <span class="number">0</span>)  <span class="comment"># recursively</span></span><br><span class="line">    right_sum = max(helper(node.right), <span class="number">0</span>)</span><br><span class="line">    <span class="comment"># the max path sum start from node downward to it's child</span></span><br><span class="line">    case1 = node.val + max(left_sum, right_sum)</span><br><span class="line">    <span class="comment"># record result (max path sum)</span></span><br><span class="line">    res = max(res, case1)</span><br><span class="line">    <span class="keyword">return</span> case1</span><br></pre></td></tr></table></figure><p>By recursion, each node is visited once and calculated the max path sum from it. Then greater one is saved to <code>res</code>.</p><h1 id="recursion">Recursion</h1><p>Now, what if put case 2 back. Obviously, we need consider one more case: <code>a.left -&gt; a -&gt; a.right</code>. Luckily, it's max path sum can be calculated by <code>left_sum + node.val + right_sum</code>. There is the revised algorithm.</p><div class="post-button"> <a class="btn" href="/leetcode/binary-tree-maximum-path-sum/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwscn.github.io/leetcode/continuous-subarray-sum/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar/nekosensei.png"><meta itemprop="name" content="菜农陈文生"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="春夏秋冬"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/leetcode/continuous-subarray-sum/" class="post-title-link" itemprop="url">Continuous Subarray Sum</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-08-08 12:39:36" itemprop="dateModified" datetime="2020-08-08T12:39:36+08:00">2020-08-08</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span></span><span id="/leetcode/continuous-subarray-sum/" class="post-meta-item leancloud_visitors" data-flag-title="Continuous Subarray Sum" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><p>Given a list of <strong>non-negative</strong> numbers and a target integer <code>k</code>, write a function to check if the array has a continuous subarray of size at least 2 that sums up to a multiple of <code>k</code>, that is, sums up to <code>n*k</code> where <code>n</code> is also an integer.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [23, 2, 4, 6, 7],  k=6</span><br><span class="line">Output: True</span><br><span class="line">Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [23, 2, 6, 4, 7],  k=6</span><br><span class="line">Output: True</span><br><span class="line">Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.</span><br></pre></td></tr></table></figure><p><strong>Constraints</strong>:</p><ul><li>The length of the array won't exceed 10,000.</li><li>You may assume the sum of all the numbers is in the range of a signed 32-bit integer.</li></ul><h1 id="broute-forse-optimized">Broute Forse Optimized</h1><p>Enumerate all subarray <code>a[i .. j]</code>. Calculate sum... By calcualte cumulative sum of array, we can get sum of any subarray in O(1). See problem <a href="/leetcode/range-sum-query/" title="Range Sum Query">Range Sum Query</a>.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkSubarraySum</span><span class="params">(self, nums: <span class="string">'List[int]'</span>, k: int)</span> -&gt; bool:</span></span><br><span class="line">        accumulated = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            accumulated.append(accumulated[<span class="number">-1</span>] + num)</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n):  <span class="comment"># ensure j &gt; i</span></span><br><span class="line">                <span class="comment"># sum of nums[i .. j], at least two elements</span></span><br><span class="line">                sum_ = accumulated[j + <span class="number">1</span>] - accumulated[i]</span><br><span class="line">                <span class="keyword">if</span> sum_ == k <span class="keyword">or</span> (k != <span class="number">0</span> <span class="keyword">and</span> sum_ % k == <span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="hash-table">Hash Table</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Define nums[i .. j] as the sum of nums[i:j+1].</span><br><span class="line"></span><br><span class="line">If nums[i .. j] % k = 0, then:</span><br><span class="line">nums[0 .. j] % k = (nums[0 .. i-1] + nums[i .. j]) % k</span><br><span class="line">                 = nums[0 .. i-1] % k + nums[i .. j] % k</span><br><span class="line">                 = nums[0 .. i-1] % k + 0</span><br></pre></td></tr></table></figure><div class="post-button"> <a class="btn" href="/leetcode/continuous-subarray-sum/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwscn.github.io/leetcode/merge-intervals/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar/nekosensei.png"><meta itemprop="name" content="菜农陈文生"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="春夏秋冬"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/leetcode/merge-intervals/" class="post-title-link" itemprop="url">Merge Intervals</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-08-07 21:42:35" itemprop="dateModified" datetime="2020-08-07T21:42:35+08:00">2020-08-07</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span></span><span id="/leetcode/merge-intervals/" class="post-meta-item leancloud_visitors" data-flag-title="Merge Intervals" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><p>Given a collection of intervals, merge all overlapping intervals.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">Output: [[1,6],[8,10],[15,18]]</span><br><span class="line">Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [[1,4],[4,5]]</span><br><span class="line">Output: [[1,5]]</span><br><span class="line">Explanation: Intervals [1,4] and [4,5] are considered overlapping.</span><br></pre></td></tr></table></figure><h1 id="sorting">Sorting</h1><p>If we sort the intervals by their start value, then each set of intervals that can be merged will appear as a contiguous &quot;run&quot; in the sorted list.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:  [(1, 9), (2, 5), (19, 20), (10, 11), (12, 20), (0, 3), (0, 1), (0, 2)]</span><br><span class="line">Sorted: [(0, 3), (0, 1), (0, 2), (1, 9), (2, 5), (10, 11), (12, 20), (19, 20)]</span><br><span class="line">         --------------------------------------  --------  ------------------</span><br><span class="line">        [                (0, 9),                 (10, 11),       (12, 20)    ]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n log(n))</span></span><br><span class="line"><span class="comment"># Space: O(1) or O(n), depending on sort algorithm</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals: <span class="string">'List[List[int]]'</span>)</span> -&gt; 'List[List[int]]':</span></span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">or</span> res[<span class="number">-1</span>][<span class="number">1</span>] &lt; x[<span class="number">0</span>]:</span><br><span class="line">                res.append(x)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[<span class="number">-1</span>][<span class="number">1</span>] = max(res[<span class="number">-1</span>][<span class="number">1</span>], x[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="counting-sort">Counting Sort</h1><p>This approach works like counting sort. Create a long enough array <code>a</code>:</p><ol type="1"><li>Scan each interval, for start value, <code>a[start] += 1</code>; for end value, <code>a[end] -= 1</code>.</li><li>Calculate cumulative sum of <code>a</code>. The merged interval always end at <code>j</code> where <code>a[j] == 0</code>. However, it can start from <code>i</code> where <code>a[i] == 0</code> also. That's a special interval we need to consider.</li></ol><div class="post-button"> <a class="btn" href="/leetcode/merge-intervals/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwscn.github.io/leetcode/kth-largest-element-in-an-array/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar/nekosensei.png"><meta itemprop="name" content="菜农陈文生"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="春夏秋冬"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/leetcode/kth-largest-element-in-an-array/" class="post-title-link" itemprop="url">Kth Largest Element in an Array</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-08-09 09:59:39" itemprop="dateModified" datetime="2020-08-09T09:59:39+08:00">2020-08-09</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span></span><span id="/leetcode/kth-largest-element-in-an-array/" class="post-meta-item leancloud_visitors" data-flag-title="Kth Largest Element in an Array" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,2,1,5,6,4] and k = 2</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,2,3,1,2,4,5,5,6] and k = 4</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p>Note: You may assume k is always valid, <code>1 &lt;= k &lt;= array.length</code>.</p><h1 id="quick-sort">Quick Sort</h1><p>kth largest is the (n-k)th element in ordered array.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(log(n))</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, nums, left, right)</span>:</span></span><br><span class="line">        pivot = nums[right]</span><br><span class="line">        i, j = left, right - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># i &lt; hi, j &gt;= lo, can avoid the case i == j after loops</span></span><br><span class="line">            <span class="comment"># i == j will cause infinite loop</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; right <span class="keyword">and</span> nums[i] &lt;= pivot:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= left <span class="keyword">and</span> nums[j] &gt;= pivot:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; j:</span><br><span class="line">                nums[i], nums[right] = nums[right], nums[i]</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="comment"># There is another variation of partition,</span></span><br><span class="line">        <span class="comment"># which is eaiser but not as efficiently as above.</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        pivot, i = a[right], left</span></span><br><span class="line"><span class="string">        for j in range(left, right):</span></span><br><span class="line"><span class="string">            if a[j] &lt; pivot:</span></span><br><span class="line"><span class="string">                a[i], a[j] = a[j], a[i]</span></span><br><span class="line"><span class="string">                i += 1</span></span><br><span class="line"><span class="string">        a[i], a[right] = a[right], a[i]</span></span><br><span class="line"><span class="string">        return i</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">randomizedPartition</span><span class="params">(self, nums, lo, hi)</span>:</span></span><br><span class="line">        i = randint(lo, hi)</span><br><span class="line">        nums[i], nums[hi] = nums[hi], nums[i]</span><br><span class="line">        <span class="keyword">return</span> self.partition(nums, lo, hi)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quickSelect</span><span class="params">(self, nums, lo, hi, t)</span>:</span></span><br><span class="line">        q = self.randomizedPartition(nums, lo, hi)</span><br><span class="line">        <span class="keyword">if</span> q == t:</span><br><span class="line">            <span class="keyword">return</span> nums[t]</span><br><span class="line">        <span class="keyword">elif</span> q &lt; t:</span><br><span class="line">            <span class="keyword">return</span> self.quickSelect(nums, q + <span class="number">1</span>, hi, t)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># q &gt; k</span></span><br><span class="line">            <span class="keyword">return</span> self.quickSelect(nums, lo, q - <span class="number">1</span>, t)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: list, k: int)</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">return</span> self.quickSelect(nums, <span class="number">0</span>, n - <span class="number">1</span>, n - k)</span><br></pre></td></tr></table></figure><h1 id="heap">Heap</h1><p>Using a max heap, pop k-1 times from heap, the current top element is the kth largest element.</p><div class="post-button"> <a class="btn" href="/leetcode/kth-largest-element-in-an-array/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwscn.github.io/leetcode/lowest-common-ancestor/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar/nekosensei.png"><meta itemprop="name" content="菜农陈文生"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="春夏秋冬"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/leetcode/lowest-common-ancestor/" class="post-title-link" itemprop="url">Lowest Common Ancestor</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-08-10 15:20:37" itemprop="dateModified" datetime="2020-08-10T15:20:37+08:00">2020-08-10</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span></span><span id="/leetcode/lowest-common-ancestor/" class="post-meta-item leancloud_visitors" data-flag-title="Lowest Common Ancestor" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="lca-of-a-binary-tree">LCA of a Binary Tree</h1><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p><p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="noopener">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we <strong>allow a node to be a descendant of itself</strong>).”</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4]</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">   /    \</span><br><span class="line">  5      1</span><br><span class="line"> / \    / \</span><br><span class="line">6   2  0   8</span><br><span class="line">   / \</span><br><span class="line">  7   4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: p = 5, q = 1</span><br><span class="line">Output: 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: p = 5, q = 4</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><p>Note:</p><ul><li>All of the nodes' values will be unique.</li><li><code>p</code> and <code>q</code> are different and both values will exist in the binary tree.</li></ul><h2 id="resursion">Resursion</h2><ul><li><code>left = True</code> if <code>p</code> or <code>q</code> in it's left subtree.</li><li><code>right = True</code> if <code>p</code> or <code>q</code> in it's right subtree.</li><li><code>mid = True</code> if itself is <code>p</code> or <code>q</code></li></ul><p>A node is a LCA of <code>p</code> and <code>q</code> if <code>left + right + mid == 2</code> (two of three become True).</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     3</span><br><span class="line">   /    \</span><br><span class="line">  5      1</span><br><span class="line"> / \    / \</span><br><span class="line">6   2  0   8</span><br><span class="line">   / \</span><br><span class="line">  7   4</span><br><span class="line"></span><br><span class="line">3 is LCA of 5 and 1.      (left == right == True)</span><br><span class="line">5 is LCA of 5 and 4.      (mid == right == True)</span><br><span class="line">5 is LCA of 5 and 6.      (mid == left == True)</span><br><span class="line">5 is not LCA of 2 and 4.  (right == True)</span><br><span class="line"></span><br><span class="line">left == right == mid == Ture never happens.</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n), maximum recursion stack</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: TreeNode, p: TreeNode, q: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        ans = root</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># Left recursion.</span></span><br><span class="line">            left = helper(node.left)</span><br><span class="line">            <span class="comment"># Right recursion.</span></span><br><span class="line">            right = helper(node.right)</span><br><span class="line">            mid = node <span class="keyword">in</span> (p, q)</span><br><span class="line">            <span class="comment"># If any two of the three flags left, right or mid become True.</span></span><br><span class="line">            <span class="keyword">if</span> left + mid + right &gt;= <span class="number">2</span>:</span><br><span class="line">                ans = node</span><br><span class="line">            <span class="keyword">return</span> left <span class="keyword">or</span> mid <span class="keyword">or</span> right</span><br><span class="line"></span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><div class="post-button"> <a class="btn" href="/leetcode/lowest-common-ancestor/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwscn.github.io/leetcode/coin-change/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar/nekosensei.png"><meta itemprop="name" content="菜农陈文生"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="春夏秋冬"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/leetcode/coin-change/" class="post-title-link" itemprop="url">Coin Change</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-08-07 21:42:35" itemprop="dateModified" datetime="2020-08-07T21:42:35+08:00">2020-08-07</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span></span><span id="/leetcode/coin-change/" class="post-meta-item leancloud_visitors" data-flag-title="Coin Change" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><p>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: coins = [1, 2, 5], amount = 11</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: coins = [2], amount = 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p>Note: You may assume that you have an infinite number of each kind of coin.</p><h1 id="bottom-up-dp">Bottom-Up DP</h1><p>Let's define <code>dp[s]</code> as the minimum number of coins needed to make change for amount <code>s</code> using coins <code>c</code>.</p><p>Base case: <code>dp[0] = 0</code>.</p><p>Induction rule: <code>dp[s] = ?</code>. If we take a coin <code>c[i]</code> first, then we need <code>dp[s - c[i]] + 1</code> coins. So, <code>dp[s] = min(dp[s - c[i]] | i = 0, 1, ..., n - 1) + 1</code>, i.e., we try every coin.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n * s), n = len(coins), s = amount</span></span><br><span class="line"><span class="comment"># Space: O(s)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: list, amount: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> amount &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dp = [float(<span class="string">'inf'</span>)] * (amount + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(coin, amount + <span class="number">1</span>):  <span class="comment"># x start from coin</span></span><br><span class="line">                dp[x] = min(dp[x], dp[x - coin] + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != float(<span class="string">'inf'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><div class="post-button"> <a class="btn" href="/leetcode/coin-change/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwscn.github.io/leetcode/add-strings/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar/nekosensei.png"><meta itemprop="name" content="菜农陈文生"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="春夏秋冬"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/leetcode/add-strings/" class="post-title-link" itemprop="url">415. Add Strings</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-08-07 21:42:35" itemprop="dateModified" datetime="2020-08-07T21:42:35+08:00">2020-08-07</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span></span><span id="/leetcode/add-strings/" class="post-meta-item leancloud_visitors" data-flag-title="415. Add Strings" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><p>Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.</p><p><strong>Note</strong>:</p><ul><li>The length of both num1 and num2 is &lt; 5100.</li><li>Both num1 and num2 contains only digits 0-9.</li><li>Both num1 and num2 does not contain any leading zero.</li><li>You must not use any built-in BigInteger library or convert the inputs to integer directly.</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(max(n1, n2)), n1, n2 are the length of num1, num2</span></span><br><span class="line"><span class="comment"># Space: O(max(n1, n2))</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addStrings</span><span class="params">(self, num1: str, num2: str)</span> -&gt; str:</span></span><br><span class="line">        res = []</span><br><span class="line">        i, j, carry = len(num1) - <span class="number">1</span>, len(num2) - <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">or</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            n1 = int(num1[i]) <span class="keyword">if</span> i &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            n2 = int(num2[j]) <span class="keyword">if</span> j &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            tmp = n1 + n2 + carry</span><br><span class="line">            carry = tmp // <span class="number">10</span></span><br><span class="line">            res.append(tmp % <span class="number">10</span>)</span><br><span class="line">            i, j = i - <span class="number">1</span>, j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> carry &gt; <span class="number">0</span>:</span><br><span class="line">            res.append(carry)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(str(x) <span class="keyword">for</span> x <span class="keyword">in</span> reversed(res))</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwscn.github.io/leetcode/longest-chunked-palindrome-decomposition/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar/nekosensei.png"><meta itemprop="name" content="菜农陈文生"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="春夏秋冬"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/leetcode/longest-chunked-palindrome-decomposition/" class="post-title-link" itemprop="url">Longest Chunked Palindrome Decomposition</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-08-09 09:44:57" itemprop="dateModified" datetime="2020-08-09T09:44:57+08:00">2020-08-09</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span></span><span id="/leetcode/longest-chunked-palindrome-decomposition/" class="post-meta-item leancloud_visitors" data-flag-title="Longest Chunked Palindrome Decomposition" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><p>Return the largest possible <code>k</code> such that there exists <code>a_1, a_2, ..., a_k</code> such that:</p><ul><li>Each <code>a_i</code> is a non-empty string;</li><li>Their concatenation <code>a_1 + a_2 + ... + a_k</code> is equal to text;</li><li>For all <code>1 &lt;= i &lt;= k</code>, <code>a_i = a_{k+1 - i}</code>.</li></ul><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: text = &quot;ghiabcdefhelloadamhelloabcdefghi&quot;</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: We can split the string on &quot;(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)&quot;.</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: text = &quot;merchant&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: We can split the string on &quot;(merchant)&quot;.</span><br></pre></td></tr></table></figure><p>Example 3:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: text = &quot;antaprezatepzapreanta&quot;</span><br><span class="line">Output: 11</span><br><span class="line">Explanation: We can split the string on &quot;(a)(nt)(a)(pre)(za)(tpe)(za)(pre)(a)(nt)(a)&quot;.</span><br></pre></td></tr></table></figure><p>Example 4:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: text = &quot;aaa&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: We can split the string on &quot;(a)(a)(a)&quot;.</span><br></pre></td></tr></table></figure><p>Constraints:</p><ul><li>text consists only of lowercase English characters.</li><li><code>1 &lt;= text.length &lt;= 1000</code></li></ul><h1 id="greedy">Greedy</h1><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: abcdefabc</span><br><span class="line"></span><br><span class="line">1. is a == c ? No</span><br><span class="line">2. is ab == bc ? No</span><br><span class="line">3. is abc == abc ? Yes, res += 2</span><br><span class="line">4. is d == f ? No</span><br><span class="line">5. is de == ef ? No</span><br><span class="line">6. is def == def ? Yes, res += 1</span><br><span class="line"></span><br><span class="line">We must be careful about the case that</span><br><span class="line">a substring crossing the middle point.</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2)</span></span><br><span class="line"><span class="comment"># Space: O(n), the max length of substring we compared can be n/2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestDecomposition</span><span class="params">(self, text: str)</span> -&gt; int:</span></span><br><span class="line">        n = len(text)</span><br><span class="line">        i = res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n // <span class="number">2</span>):  <span class="comment"># move forward end point</span></span><br><span class="line">            <span class="keyword">if</span> text[i:j + <span class="number">1</span>] == text[n - j - <span class="number">1</span>:n - i]:</span><br><span class="line">                res += <span class="number">2</span></span><br><span class="line">                i = j + <span class="number">1</span>  <span class="comment"># new start point</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">2</span> * i &lt; n:  <span class="comment"># middle chunk</span></span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><div class="post-button"> <a class="btn" href="/leetcode/longest-chunked-palindrome-decomposition/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwscn.github.io/computer-networking/network-layer/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar/nekosensei.png"><meta itemprop="name" content="菜农陈文生"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="春夏秋冬"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/computer-networking/network-layer/" class="post-title-link" itemprop="url">网络层</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-08-22 13:49:26" itemprop="dateModified" datetime="2020-08-22T13:49:26+08:00">2020-08-22</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/books/" itemprop="url" rel="index"><span itemprop="name">书籍</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/books/computer-networking/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a></span></span><span id="/computer-networking/network-layer/" class="post-meta-item leancloud_visitors" data-flag-title="网络层" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><p>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网络层不提供服务质量的承诺。如果主机中的进程之间的通信需要是可靠的，那么就由网络的主机中的运输层负责（包括差错处理、流量控制）。采用这种设计思路的好处是：网络造价大大降低，运行方式灵活，能够适应多种应用。</p><h1 id="网际协议-ip">网际协议 IP</h1><p>与 IP 协议配套使用的还有三个协议：</p><ul><li>地址解析协议 ARP（Address Resolution Protocol）</li><li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li><li>网际组管理协议（Internet Group Management Protocol）</li></ul><p>IP 协议使用 ARP 协议。ICMP 和 IGMP 使用 IP 协议。</p><p>将网络互相连接起来要使用一些<strong>中间设备</strong>。根据中间设备所在的层次，可以有以下四种不同的中间设备：</p><ol type="1"><li>物理层使用的中间设备叫做<strong>转发器</strong>（repeater）。</li><li>数据链路层使用的中间设备叫做<strong>网桥</strong>或<strong>桥接器</strong>（bridge）。</li><li>网络层使用的中间设备叫做<strong>路由器</strong>（router）。</li><li>在网络层以上使用的中间设备叫做<strong>网关</strong>（gateway）。用网关连接两个不兼容的系统需要在高层进行协议的转换。</li></ol><p>当中间设备是转发器或网桥时，这仅仅是把一个网络扩大了，而从网络层的角度看，这仍然是一个网络，一般并不称为网络互连。网关由于比较复杂，目前使用得较少。因此讨论网络互连时，都是指用路由器进行网络互连和路由选择。路由器其实就是一台专用计算机，用来在互联网中进行路由选择。由于历史的原因，许多有关 TCP/IP 的文献曾经把网络层使用的路由器称为网关，本书有时也这样用。</p><h1 id="ip-地址">IP 地址</h1><p>整个的互联网就是一个单一的、抽象的网络。IP 地址就是给互联网上的每一台主机（或路由器）的每一个接口分配一个在全世界范围内唯一的 32 位的标识符。IP 地址的编址方式经过了三个历史阶段。</p><ol type="1"><li>分类的 IP 地址。最基本的编址方法。</li><li>子网的划分。对最基本的编址方法的改进。</li><li>构成超网。无分配编址方法。已被广泛使用。</li></ol><h1 id="分类的-ip-地址">分类的 IP 地址</h1><table><tr><th> 网络类别</th><th> 类别位</th><th> 网络号</th><th> 主机号</th></tr><tr><td> A</td><td> 0</td><td> 8 位</td><td> 24 位</td></tr><tr><td> B</td><td> 10</td><td> 16 位</td><td> 16 位</td></tr><tr><td> C</td><td> 110</td><td> 24 位</td><td> 8 位</td></tr><tr><td> D</td><td> 1110</td><td colspan="2" style="text-align:center"> 多播地址</td></tr><tr><td> E</td><td> 1111</td><td colspan="2" style="text-align:center"> 保留为今后使用</td></tr></table><div class="post-button"> <a class="btn" href="/computer-networking/network-layer/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwscn.github.io/leetcode/convert-sorted-list-to-binary-search-tree/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar/nekosensei.png"><meta itemprop="name" content="菜农陈文生"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="春夏秋冬"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/leetcode/convert-sorted-list-to-binary-search-tree/" class="post-title-link" itemprop="url">Convert Sorted List to Binary Serch Tree</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-08-07 21:42:35" itemprop="dateModified" datetime="2020-08-07T21:42:35+08:00">2020-08-07</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span></span><span id="/leetcode/convert-sorted-list-to-binary-search-tree/" class="post-meta-item leancloud_visitors" data-flag-title="Convert Sorted List to Binary Serch Tree" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="sorted-array-to-balanced-bst">Sorted Array to Balanced BST</h1><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p><p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given the sorted array: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   -3   9</span><br><span class="line">   /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure><h2 id="recursion">Recursion</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n), visit each element once</span></span><br><span class="line"><span class="comment"># Space: O(log(n)), recursion stack depth</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(self, nums: list)</span> -&gt; TreeNode:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(left, right)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> left &gt; right:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            root = TreeNode(nums[mid])</span><br><span class="line">            root.left = helper(left, mid - <span class="number">1</span>)</span><br><span class="line">            root.right = helper(mid + <span class="number">1</span>, right)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h1 id="sorted-list-to-balanced-bst">Sorted List to Balanced BST</h1><p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p><p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given the sorted linked list: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   -3   9</span><br><span class="line">   /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure><div class="post-button"> <a class="btn" href="/leetcode/convert-sorted-list-to-binary-search-tree/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><nav class="pagination"> <a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><a class="page-number" href="/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="page-number" href="/page/29/">29</a></nav></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="菜农陈文生" src="/uploads/avatar/nekosensei.png"><p class="site-author-name" itemprop="name">菜农陈文生</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">290</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">28</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">115</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/cncws" title="GitHub → https://github.com/cncws" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:1031616423@qq.com" title="E-Mail → mailto:1031616423@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span></div><div class="cc-license motion-element" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">菜农陈文生</span></div><script src="//cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="//cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script><script src="/js/aplayer-el.js"></script><script src="//unpkg.com/video.js/dist/video.min.js"></script><script src="/js/videojs-bilibili.js"></script><script src="/js/videojs-bilibili-el.js"></script></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script><script src="/js/local-search.js"></script><div id="pjax"><script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Axl15EIRi5o5AatKaxXxV4Oq-gzGzoHsz',
      appKey     : 'E0qm04UjsP0qQN1l8ME3GQ25',
      placeholder: "Just go go",
      avatar     : 'identicon',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script></div></body></html>