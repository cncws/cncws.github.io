<!DOCTYPE html><html lang="zh-CN,en,default"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/uploads/icon/drop/128x128.png"><link rel="icon" type="image/png" sizes="32x32" href="/uploads/icon/drop/32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/uploads/icon/drop/16x16.png"><link rel="mask-icon" href="/uploads/icon/drop/drop.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"cwscn.github.io",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1,width:240},copycode:{enable:!0,show_result:!0,style:"flat"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"manual"},fancybox:!1,mediumzoom:!0,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"fadeIn"}},path:"search.xml"}</script><meta name="keywords" content="blog"><meta property="og:type" content="website"><meta property="og:title" content="春夏秋冬"><meta property="og:url" content="https://cwscn.github.io/page/5/index.html"><meta property="og:site_name" content="春夏秋冬"><meta property="og:locale" content="zh-CN"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="春夏秋冬"><link rel="canonical" href="https://cwscn.github.io/page/5/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!0,isPost:!1,lang:"zh-CN"}</script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css"><link rel="stylesheet" href="//unpkg.com/video.js/dist/video-js.min.css"><link rel="stylesheet" href="/css/videojs-bilibili.css"><style>.aplayer.aplayer-arrow .aplayer-icon-loop,.aplayer.aplayer-arrow .aplayer-icon-order{display:inline-block}</style><title>春夏秋冬</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">春夏秋冬</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">愿你走出半生 归来仍是少年</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档<span class="badge">203</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类<span class="badge">11</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签<span class="badge">162</span></a></li><li class="menu-item menu-item-收藏"><a href="/favlist/" rel="section"><i class="fa fa-star fa-fw"></i> 收藏</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div><meting-js server="netease" type="playlist" id="67155774" theme="#ff5555" loop="all" order="list" preload="none" volume="" mutex="" list-folded="NaN" fixed="true"></meting-js></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content index posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwscn.github.io/notes/inside-mysql/mysql-locking/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar/nekosensei.png"><meta itemprop="name" content="菜农陈文生"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="春夏秋冬"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/notes/inside-mysql/mysql-locking/" class="post-title-link" itemprop="url">MySQL 锁</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-08-03 21:04:36" itemprop="dateModified" datetime="2020-08-03T21:04:36+08:00">2020-08-03</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/notes/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="并发控制">并发控制</h1><p>锁（locking）机制用于管理对<strong>共享资源</strong>（这里说的是共享资源而不仅仅是行记录）的并发访问。</p><h2 id="锁粒度">锁粒度</h2><p>一种提高共享资源并发性的方式就是让锁定对象更具选择性。尽量只锁定需要修改的部分数据，而不是所有的资源。更理想的方式是，只对会修改的数据片进行精确的锁定。</p><p>问题是加锁也要消耗资源。锁的各种操作，包括获得锁、检查锁是否已经解除、释放锁等，都会增加系统的开销。</p><p>所谓的<strong>锁策略</strong>，就是在锁的开销和数据的安全性之间寻求平衡。</p><ul><li>表级锁（table lock），锁定整张表，开销最小。一个用户在对表进行写操作（插入、删除、更新等）前，需要先获得 X 锁，这会阻塞其他用户对该表的所有读写操作。只有 S 锁和 S 锁之间不相互阻塞（称为锁兼容）。</li><li>行级锁（row lock），可以最大程度地支持并发处理，同时也带来了最大的锁开销。</li></ul><h2 id="读写锁">读写锁</h2><p>InnoDB 存储引擎（之后简称为 InnoDB）实现了两种标准的行级锁：</p><ul><li>共享锁（S，Shared lock），也叫读锁（read lock）</li><li>排他锁（X，eXclusive lock），也叫写锁（write lock）</li></ul><p>若 T1 获得了某行的 S 锁，这时 T2 也可以获得该行的 S 锁，因为读取不会改变行记录，称这种情况为<strong>锁兼容</strong>（lock compatible）。</p><table><thead><tr class="header"><th></th><th><strong>X</strong></th><th><strong>S</strong></th></tr></thead><tbody><tr class="odd"><td><strong>X</strong></td><td>不兼容</td><td>不兼容</td></tr><tr class="even"><td><strong>S</strong></td><td>不兼容</td><td>兼容</td></tr></tbody></table><h2 id="意向锁">意向锁</h2><p>InnoDB 支持多粒度锁定，允许事务在行级上和表级上的锁同时存在。为了支持在不同的粒度上进行加锁操作，InnoDB 支持一种额外的锁方式，称为<strong>意向锁</strong>（intention lock）。意向锁意味着事务希望在更细粒度上进行加锁。</p><p>意向锁为表级别的锁，设计目的是在一个事务中揭示下一行将被请求的锁类型。有两种意向锁：</p><ul><li>意向共享锁（IS），事务打算对表中的某几行加共享锁</li><li>意向排他锁（IX），事务打算对表中的某几行加排他锁</li></ul><p>意向锁之间是相互兼容的，意向锁与读写锁之间只有 IS 和 S 相互兼容。</p><table><thead><tr class="header"><th></th><th><strong>IS</strong></th><th><strong>IX</strong></th><th><strong>S</strong></th><th><strong>X</strong></th></tr></thead><tbody><tr class="odd"><td><strong>IS</strong></td><td>兼容</td><td>兼容</td><td>兼容</td><td>不兼容</td></tr><tr class="even"><td><strong>IX</strong></td><td>兼容</td><td>兼容</td><td>不兼容</td><td>不兼容</td></tr></tbody></table><p>意向锁是 InnoDB 自动加的，供 MySQL 内部使用，不需用户干预。</p><div class="post-button"> <a class="btn" href="/notes/inside-mysql/mysql-locking/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwscn.github.io/programming/leetcode/reverse-nodes-in-k-group/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar/nekosensei.png"><meta itemprop="name" content="菜农陈文生"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="春夏秋冬"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/programming/leetcode/reverse-nodes-in-k-group/" class="post-title-link" itemprop="url">Reverse Nodes in k-Group</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-08-03 08:09:17" itemprop="dateModified" datetime="2020-08-03T08:09:17+08:00">2020-08-03</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p><p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br><span class="line">For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</span><br><span class="line">For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</span><br></pre></td></tr></table></figure><p><strong>Note</strong>:</p><ul><li>Only constant extra memory is allowed.</li><li>You may not alter the values in the list's nodes, only nodes itself may be changed.</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1-&gt;2-&gt;3-&gt;4-&gt;5, k = 2</span><br><span class="line"></span><br><span class="line">    Use a sentinel to simplify implement:</span><br><span class="line">    0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5</span><br><span class="line"></span><br><span class="line">1.  Find a piece with k nodes</span><br><span class="line">    0-&gt; 1-&gt;2 -&gt;3-&gt;4-&gt;5</span><br><span class="line"></span><br><span class="line">    Reverse the piece, then fix the pointers</span><br><span class="line">    0-&gt; 2-&gt;1 -&gt;3-&gt;4-&gt;5</span><br><span class="line"></span><br><span class="line">2.  Find next piece with k nodes</span><br><span class="line">    0-&gt;2-&gt;1-&gt; 3-&gt;4 -&gt;5</span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 翻转一个子链表，并且返回新的头与尾</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, head: ListNode, tail: ListNode)</span>:</span></span><br><span class="line">        prev = tail.next</span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> prev != tail:</span><br><span class="line">            nex = p.next</span><br><span class="line">            p.next = prev</span><br><span class="line">            prev = p</span><br><span class="line">            p = nex</span><br><span class="line">        <span class="keyword">return</span> tail, head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        hair = ListNode(<span class="number">0</span>)  <span class="comment"># 添加一个辅助结点</span></span><br><span class="line">        hair.next = head  <span class="comment"># 使得算法能等同对待第一个k组</span></span><br><span class="line">        pre = hair</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            tail = pre</span><br><span class="line">            <span class="comment"># 查看剩余部分长度是否大于等于 k</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">                tail = tail.next</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> tail:</span><br><span class="line">                    <span class="keyword">return</span> hair.next</span><br><span class="line">            nex = tail.next</span><br><span class="line">            head, tail = self.reverse(head, tail)</span><br><span class="line">            <span class="comment"># 把子链表重新接回原链表</span></span><br><span class="line">            pre.next = head</span><br><span class="line">            tail.next = nex</span><br><span class="line">            pre = tail</span><br><span class="line">            head = tail.next</span><br><span class="line">        <span class="keyword">return</span> hair.next</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwscn.github.io/programming/leetcode/search-in-rotated-sorted-array/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar/nekosensei.png"><meta itemprop="name" content="菜农陈文生"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="春夏秋冬"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/programming/leetcode/search-in-rotated-sorted-array/" class="post-title-link" itemprop="url">Search in Rotated Sorted Array</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-08-04 17:51:23" itemprop="dateModified" datetime="2020-08-04T17:51:23+08:00">2020-08-04</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e., <code>[0,1,2,4,5,6,7]</code> might become <code>[4,5,6,7,0,1,2]</code>).</p><p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p><p>You may assume no duplicate exists in the array.</p><p>Your algorithm's runtime complexity must be in the order of O(log n).</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><h1 id="binary-search">Binary Search</h1><p>Time complexity in O(log n)? There must be binary search.</p><p>The key is, we split an array into two parts, there must exist a part is sorted (because is rotated only once). The another part could be sorted or unsored.</p><p>We can easily check target is in the sorted part or not. If in, find in sorted part. If not, find in another part.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(log(n))</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: <span class="string">'List[int]'</span>, target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        l, r = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="comment"># left is sorted</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= nums[<span class="number">0</span>]:  <span class="comment"># must be &gt;= (considering mid = 0)</span></span><br><span class="line">                <span class="keyword">if</span> nums[<span class="number">0</span>] &lt;= target &lt; nums[mid]:  <span class="comment"># in left</span></span><br><span class="line">                    r = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[<span class="number">-1</span>]:  <span class="comment"># in right</span></span><br><span class="line">                    l = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line"></span><br><span class="line">pointers: l = 0, r = 6, mid = 3</span><br><span class="line">nums:         4      2        7</span><br><span class="line">nums[mid] &gt; nums[l]:</span><br><span class="line">    4 &lt; 0 &lt; 7 is not True, l = mid + 1 = 4</span><br><span class="line"></span><br><span class="line">pointers: l = 4, r = 6, mid = 5</span><br><span class="line">nums:         0      2        1</span><br><span class="line">nums[mid] &gt; nums[l]:</span><br><span class="line">    0 &lt; 1 &lt; 2 is True, r = mid - 1 = 4</span><br><span class="line"></span><br><span class="line">pointers: l = 4, r = 4, mid = 4</span><br><span class="line">nums[mid] == target == 0, return 4.</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwscn.github.io/programming/leetcode/path-sum/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar/nekosensei.png"><meta itemprop="name" content="菜农陈文生"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="春夏秋冬"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/programming/leetcode/path-sum/" class="post-title-link" itemprop="url">Path Sum</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-08-04 17:42:58" itemprop="dateModified" datetime="2020-08-04T17:42:58+08:00">2020-08-04</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="path-sum-i">112. Path Sum I</h1><p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p><p>Note: A leaf is a node with no children.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given the below binary tree and sum = 22,</span><br><span class="line"></span><br><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \      \</span><br><span class="line">7    2      1</span><br><span class="line">return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.</span><br></pre></td></tr></table></figure><h2 id="bfs">BFS</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        queue = deque([(root, <span class="number">0</span>), ])</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node, sm = queue.popleft()  <span class="comment"># it's BFS when popleft, DFS when popright</span></span><br><span class="line">            sm += node.val</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:  <span class="comment"># is leaf node</span></span><br><span class="line">                <span class="keyword">if</span> sm == sum:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append((node.left, sm))</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append((node.right, sm))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><div class="post-button"> <a class="btn" href="/programming/leetcode/path-sum/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwscn.github.io/programming/leetcode/check-completeness-of-a-binary-tree/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar/nekosensei.png"><meta itemprop="name" content="菜农陈文生"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="春夏秋冬"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/programming/leetcode/check-completeness-of-a-binary-tree/" class="post-title-link" itemprop="url">958. Check Completeness of a Binary Tree</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-08-04 17:42:47" itemprop="dateModified" datetime="2020-08-04T17:42:47+08:00">2020-08-04</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>Given a binary tree, determine if it is a complete binary tree.</p><p>Definition of a complete binary tree from <a href="http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees" target="_blank" rel="noopener">Wikipedia</a>:</p><blockquote><p>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2^h nodes inclusive at the last level h.</p></blockquote><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6]</span><br><span class="line">     1</span><br><span class="line">   /   \</span><br><span class="line">  2     3</span><br><span class="line"> / \   /</span><br><span class="line">4   5 6</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3,4,5,null,7]</span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \   \</span><br><span class="line">4   5   7</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The node with value 7 isn&apos;t as far left as possible.</span><br></pre></td></tr></table></figure><p>Note: The tree will have between 1 and 100 nodes.</p><h1 id="bfs">BFS</h1><p>Accroding complete tree's definition.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isCompleteTree</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        queue = deque([root])</span><br><span class="line">        prev = root</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> prev <span class="keyword">and</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">            prev = node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h1 id="attach-indices">Attach indices</h1><p>At the root node, we will associate it with the code <code>1</code>. Then, for each node with code <code>v</code>, we will associate its left child with code <code>2 * v</code>, and its right child with code <code>2 * v + 1</code>. (Like heap, heap is a complete tree)</p><div class="post-button"> <a class="btn" href="/programming/leetcode/check-completeness-of-a-binary-tree/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwscn.github.io/programming/leetcode/merge-sorted-array/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar/nekosensei.png"><meta itemprop="name" content="菜农陈文生"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="春夏秋冬"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/programming/leetcode/merge-sorted-array/" class="post-title-link" itemprop="url">Merge Sorted Array</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-08-04 17:51:23" itemprop="dateModified" datetime="2020-08-04T17:51:23+08:00">2020-08-04</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.</p><p>Note:</p><p>The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is equal to m + n) to hold additional elements from nums2.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line">Output: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure><p>Constraints:</p><ul><li><code>-10^9 &lt;= nums1[i], nums2[i] &lt;= 10^9</code></li><li><code>nums1.length == m + n</code></li><li><code>nums2.length == n</code></li></ul><h1 id="two-pointers-backward">Two Pointers: backward</h1><p>Merge array in-place.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(m + n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1: <span class="string">'List[int]'</span>, m: int, nums2: <span class="string">'List[int]'</span>, n: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        i, j = m - <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line">        t = m + n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> nums1[i] &gt; nums2[j]:</span><br><span class="line">                nums1[t] = nums1[i]</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[t] = nums2[j]</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            t -= <span class="number">1</span></span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwscn.github.io/programming/leetcode/longest-substrings-without-repeating-characters/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar/nekosensei.png"><meta itemprop="name" content="菜农陈文生"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="春夏秋冬"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/programming/leetcode/longest-substrings-without-repeating-characters/" class="post-title-link" itemprop="url">Longest Substrings Without Repeating Characters</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-08-04 17:51:02" itemprop="dateModified" datetime="2020-08-04T17:51:02+08:00">2020-08-04</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>Given a string, find the length of the longest substring without repeating characters.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;abcabcbb&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;abc&quot;, with the length of 3.</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;bbbbb&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The answer is &quot;b&quot;, with the length of 1.</span><br></pre></td></tr></table></figure><p>Example 3:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;pwwkew&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;wke&quot;, with the length of 3.</span><br><span class="line">             Note that the answer must be a substring,</span><br><span class="line">             &quot;pwke&quot; is a subsequence and not a substring.</span><br></pre></td></tr></table></figure><h1 id="slinding-window">Slinding Window</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(min(n, m)), m is the size of the charset/alphabet.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        left = right = res = <span class="number">0</span></span><br><span class="line">        hSet = set()</span><br><span class="line">        <span class="keyword">while</span> right &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> s[right] <span class="keyword">not</span> <span class="keyword">in</span> hSet:</span><br><span class="line">                hSet.add(s[right])</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">                res = max(res, len(hSet))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hSet.remove(s[left])</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><div class="post-button"> <a class="btn" href="/programming/leetcode/longest-substrings-without-repeating-characters/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwscn.github.io/programming/leetcode/binary-tree-maximum-path-sum/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar/nekosensei.png"><meta itemprop="name" content="菜农陈文生"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="春夏秋冬"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/programming/leetcode/binary-tree-maximum-path-sum/" class="post-title-link" itemprop="url">Binary Tree Maximum Path Sum</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-08-03 08:07:28" itemprop="dateModified" datetime="2020-08-03T08:07:28+08:00">2020-08-03</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>Given a <strong>non-empty</strong> binary tree, find the maximum path sum.</p><p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree <strong>along the parent-child connections</strong>. The path must contain <strong>at least one node</strong> and does not need to go through the root.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      / \</span><br><span class="line">     2   3</span><br><span class="line"></span><br><span class="line">Output: 6</span><br><span class="line">Explanation: sum of path 2 - 1 - 3</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [-10,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">   -10</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">Output: 42</span><br><span class="line">Explanation: sum of path 15 - 20 - 7</span><br></pre></td></tr></table></figure><h1 id="before-coding">Before coding</h1><p>From examples, we know that the maximum path sum have two cases:</p><ol type="1"><li>connected a node with it's left or right child. (<code>a -&gt; a.left</code> or <code>a -&gt; a.right</code>)</li><li>connected a node with it's both left and right child. (<code>a.left -&gt; a -&gt; a.right</code>)</li></ol><p>The key difference between 1 and 2 is case 1 can connect <code>a</code> with it's parent (if exists), but 2 can't.</p><p>Take away the case 2. It would be much easier to design an algorithm solving it. Here gives the recursion algrithm.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = float(<span class="string">'-inf'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>  <span class="comment"># return 0 when node is None</span></span><br><span class="line">    left_sum = max(helper(node.left), <span class="number">0</span>)  <span class="comment"># recursively</span></span><br><span class="line">    right_sum = max(helper(node.right), <span class="number">0</span>)</span><br><span class="line">    <span class="comment"># the max path sum start from node downward to it's child</span></span><br><span class="line">    case1 = node.val + max(left_sum, right_sum)</span><br><span class="line">    <span class="comment"># record result (max path sum)</span></span><br><span class="line">    res = max(res, case1)</span><br><span class="line">    <span class="keyword">return</span> case1</span><br></pre></td></tr></table></figure><p>By recursion, each node is visited once and calculated the max path sum from it. Then greater one is saved to <code>res</code>.</p><h1 id="recursion">Recursion</h1><p>Now, what if put case 2 back. Obviously, we need consider one more case: <code>a.left -&gt; a -&gt; a.right</code>. Luckily, it's max path sum can be calculated by <code>left_sum + node.val + right_sum</code>. There is the revised algorithm.</p><div class="post-button"> <a class="btn" href="/programming/leetcode/binary-tree-maximum-path-sum/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwscn.github.io/programming/leetcode/3-sum-closest/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar/nekosensei.png"><meta itemprop="name" content="菜农陈文生"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="春夏秋冬"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/programming/leetcode/3-sum-closest/" class="post-title-link" itemprop="url">3 Sum Closest</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-08-04 17:51:23" itemprop="dateModified" datetime="2020-08-04T17:51:23+08:00">2020-08-04</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums = [-1,2,1,-4], target = 1</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</span><br></pre></td></tr></table></figure><p>Constraints:</p><ul><li><code>3 &lt;= nums.length &lt;= 10^3</code></li><li><code>-10^3 &lt;= nums[i] &lt;= 10^3</code></li><li><code>-10^4 &lt;= target &lt;= 10^4</code></li></ul><h1 id="sorting-two-pointers">Sorting + Two Pointers</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2)</span></span><br><span class="line"><span class="comment"># Space: O(log(n)) to O(n),</span></span><br><span class="line"><span class="comment">#   depending on the implementation of the sorting algorithm.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums: <span class="string">'List[int]'</span>, target: int)</span> -&gt; int:</span></span><br><span class="line">        nums.sort()  <span class="comment"># O(n log(n))</span></span><br><span class="line">        best = float(<span class="string">'inf'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">2</span>):  <span class="comment"># O(n^2)</span></span><br><span class="line">            l, r = i + <span class="number">1</span>, len(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                sum_ = nums[i] + nums[l] + nums[r]</span><br><span class="line">                <span class="keyword">if</span> sum_ == target:  <span class="comment"># target found</span></span><br><span class="line">                    <span class="keyword">return</span> target</span><br><span class="line">                <span class="keyword">if</span> abs(best - target) &gt; abs(sum_ - target):</span><br><span class="line">                    best = sum_</span><br><span class="line">                <span class="keyword">if</span> sum_ &gt; target:</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] == nums[r + <span class="number">1</span>]:  <span class="comment"># skip equal num (optional)</span></span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] == nums[l - <span class="number">1</span>]:</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> best</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwscn.github.io/programming/leetcode/min-stack/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar/nekosensei.png"><meta itemprop="name" content="菜农陈文生"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="春夏秋冬"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a href="/programming/leetcode/min-stack/" class="post-title-link" itemprop="url">Min Stack</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-07-18 11:35:57" itemprop="dateModified" datetime="2020-07-18T11:35:57+08:00">2020-07-18</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p><ul><li><code>push(x)</code> -- Push element x onto stack.</li><li><code>pop()</code> -- Removes the element on top of the stack.</li><li><code>top()</code> -- Get the top element.</li><li><code>getMin()</code> -- Retrieve the minimum element in the stack.</li></ul><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span><br><span class="line">[[],[-2],[0],[-3],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[null,null,null,null,-3,null,0,-2]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin(); // return -3</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();    // return 0</span><br><span class="line">minStack.getMin(); // return -2</span><br></pre></td></tr></table></figure><p><strong>Constraints</strong>: Methods pop, top and getMin operations will always be called on non-empty stacks.</p><h1 id="two-stacks">Two stacks</h1><p>One stack to store values. To get min in constant time, we need another stack to store min values of current stack. (Or we can save (val, min) in one stack).</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push  3, 2, 4, 1, 5, 0</span><br><span class="line"></span><br><span class="line">stack         min_stack</span><br><span class="line">3             3</span><br><span class="line">3,2           3,2</span><br><span class="line">3,2,4         3,2,2    &lt;- push 2</span><br><span class="line">3,2,4,1       3,2,2,1</span><br><span class="line">3,2,4,1,5     3,2,2,1,1</span><br><span class="line">3,2,4,1,5,0   3,2,2,1,1,0</span><br></pre></td></tr></table></figure><div class="post-button"> <a class="btn" href="/programming/leetcode/min-stack/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><nav class="pagination"><a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a> <a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a></nav></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="菜农陈文生" src="/uploads/avatar/nekosensei.png"><p class="site-author-name" itemprop="name">菜农陈文生</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">203</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">11</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">162</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/cncws" title="GitHub → https://github.com/cncws" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a></span><span class="links-of-author-item"><a href="mailto:1031616423@qq.com" title="E-Mail → mailto:1031616423@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">菜农陈文生</span></div><script src="//cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="//cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script><script src="/js/aplayer-el.js"></script><script src="//unpkg.com/video.js/dist/video.min.js"></script><script src="/js/videojs-bilibili.js"></script><script src="/js/videojs-bilibili-el.js"></script></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script><script src="/js/local-search.js"></script><div id="pjax"><script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Axl15EIRi5o5AatKaxXxV4Oq-gzGzoHsz',
      appKey     : 'E0qm04UjsP0qQN1l8ME3GQ25',
      placeholder: "Just go go",
      avatar     : 'identicon',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script></div></body></html>