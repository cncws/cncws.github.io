<!DOCTYPE html><html lang="zh-CN,en,default"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/uploads/icon/drop/128x128.png"><link rel="icon" type="image/png" sizes="32x32" href="/uploads/icon/drop/32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/uploads/icon/drop/16x16.png"><link rel="mask-icon" href="/uploads/icon/drop/drop.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"cwscn.github.io",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1,width:240},copycode:{enable:!0,show_result:!0,style:"flat"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"manual"},fancybox:!1,mediumzoom:!0,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"fadeIn"}},path:"search.xml"}</script><meta name="description" content="B+ 树 B+ 树的创造者 Rudolf Bayer 没有解释 B 代表什么。最常见的观点是 B 代表平衡（balanced），因为所有的叶子节点在树中都在相同的级别上。 B+ 树是通过二叉查找树（BST），再由平衡二叉树，B 树（B-tree）演化而来。  二叉查找树：平均查找速度较快，但最坏查找次数和顺序查找差不多。若想最大性能地构造一棵二叉查找树，需要这棵树是平衡的。 平衡二叉树：平衡二叉树"><meta name="keywords" content="MySQL,MySQL 技术内幕,index"><meta property="og:type" content="article"><meta property="og:title" content="MySQL 索引"><meta property="og:url" content="https://cwscn.github.io/notes/inside-mysql/mysql-indexes/index.html"><meta property="og:site_name" content="春夏秋冬"><meta property="og:description" content="B+ 树 B+ 树的创造者 Rudolf Bayer 没有解释 B 代表什么。最常见的观点是 B 代表平衡（balanced），因为所有的叶子节点在树中都在相同的级别上。 B+ 树是通过二叉查找树（BST），再由平衡二叉树，B 树（B-tree）演化而来。  二叉查找树：平均查找速度较快，但最坏查找次数和顺序查找差不多。若想最大性能地构造一棵二叉查找树，需要这棵树是平衡的。 平衡二叉树：平衡二叉树"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://cwscn.github.io/uploads/image/inside-mysql/b-tree.svg"><meta property="og:image" content="https://cwscn.github.io/uploads/image/inside-mysql/b+tree.svg"><meta property="og:image" content="https://cwscn.github.io/uploads/image/inside-mysql/b+tree-insert-28.svg"><meta property="og:image" content="https://cwscn.github.io/uploads/image/inside-mysql/b+tree-insert-70.svg"><meta property="og:image" content="https://cwscn.github.io/uploads/image/inside-mysql/b+tree-insert-95.svg"><meta property="og:image" content="https://cwscn.github.io/uploads/image/inside-mysql/b+tree-insert-70-rotation.svg"><meta property="og:image" content="https://cwscn.github.io/uploads/image/inside-mysql/b+tree-delete-70.svg"><meta property="og:image" content="https://cwscn.github.io/uploads/image/inside-mysql/b+tree-delete-25.svg"><meta property="og:image" content="https://cwscn.github.io/uploads/image/inside-mysql/b+tree-delete-60.svg"><meta property="og:updated_time" content="2020-08-02T23:46:50.265Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="MySQL 索引"><meta name="twitter:description" content="B+ 树 B+ 树的创造者 Rudolf Bayer 没有解释 B 代表什么。最常见的观点是 B 代表平衡（balanced），因为所有的叶子节点在树中都在相同的级别上。 B+ 树是通过二叉查找树（BST），再由平衡二叉树，B 树（B-tree）演化而来。  二叉查找树：平均查找速度较快，但最坏查找次数和顺序查找差不多。若想最大性能地构造一棵二叉查找树，需要这棵树是平衡的。 平衡二叉树：平衡二叉树"><meta name="twitter:image" content="https://cwscn.github.io/uploads/image/inside-mysql/b-tree.svg"><link rel="canonical" href="https://cwscn.github.io/notes/inside-mysql/mysql-indexes/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css"><link rel="stylesheet" href="//unpkg.com/video.js/dist/video-js.min.css"><link rel="stylesheet" href="/css/videojs-bilibili.css"><style>.aplayer.aplayer-arrow .aplayer-icon-loop,.aplayer.aplayer-arrow .aplayer-icon-order{display:inline-block}</style><title>MySQL 索引 | 春夏秋冬</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">春夏秋冬</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">愿你走出半生 归来仍是少年</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档<span class="badge">206</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类<span class="badge">11</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签<span class="badge">161</span></a></li><li class="menu-item menu-item-收藏"><a href="/favlist/" rel="section"><i class="fa fa-star fa-fw"></i> 收藏</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div><meting-js server="netease" type="playlist" id="67155774" theme="#ff5555" loop="all" order="list" preload="none" volume="" mutex="" list-folded="NaN" fixed="true"></meting-js></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwscn.github.io/notes/inside-mysql/mysql-indexes/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar/nekosensei.png"><meta itemprop="name" content="菜农陈文生"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="春夏秋冬"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> MySQL 索引</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-08-03 07:46:50" itemprop="dateModified" datetime="2020-08-03T07:46:50+08:00">2020-08-03</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/notes/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/notes/inside-mysql/mysql-indexes/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/notes/inside-mysql/mysql-indexes/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="b-树">B+ 树</h1><p>B+ 树的创造者 Rudolf Bayer 没有解释 B 代表什么。最常见的观点是 B 代表平衡（balanced），因为所有的叶子节点在树中都在相同的级别上。</p><p>B+ 树是通过二叉查找树（BST），再由平衡二叉树，B 树（B-tree）演化而来。</p><ul><li><p>二叉查找树：平均查找速度较快，但最坏查找次数和顺序查找差不多。若想最大性能地构造一棵二叉查找树，需要这棵树是平衡的。</p></li><li><p>平衡二叉树：平衡二叉树的查找性能比较高，但不是最高的。因为维护一棵平衡二叉树的代价是非常大的。</p></li><li><p>B 树：B 树是一种自平衡的二叉查找树，其允许存储超过 2 个的子节点。</p><p><img src="/uploads/image/inside-mysql/b-tree.svg"></p><p>一棵 m 阶的 B 树需要满足以下性质：</p><ul><li>节点最多拥有 m - 1 个关键字。（对比二叉查找树不难理解）</li><li>根节点最少拥有 1 个关键字，非根节点最少拥有 <code>ceil(m/2) - 1</code> 个关键字。（例如，上图是一个 5 阶 B 树，非根节点最少拥有 2 个关键字）</li><li>节点中的关键字按照大小从左到右排序，每个关键字的左子树中的所有关键字都小于它，右子树中的所有关键字都大于它。</li><li>所有叶子节点都位于同一层，即根节点到每个叶子节点的长度都相同。</li></ul></li><li><p>B+ 树：通常用于数据库和操作系统的文件系统中。通过最大化在每个内部节点内的子节点的数目，减小树的高度，平衡操作不经常发生，而且效率增加了。通常需要每个节点在次级存储（如硬盘）中占据完整的磁盘块或近似的大小。</p><p>B+ 树有两种实现，关键字数 = 子节点数；关键字数 = 子节点数 - 1。原理是相同的，MySQL 技术内幕讨论的是第二种。</p><p><img src="/uploads/image/inside-mysql/b+tree.svg"></p><p>B+ 树中的节点通常被表示为一组有序的元素和指针。与 B 树不同的是：</p><ul><li>B+ 树的内部节点（也叫索引节点）不保存数据，只保存索引。所有记录都保存在叶子节点中。</li><li>所有叶子节点都在同一层（与 B 树相同），且按关键字大小自小而大顺序连接（与 B 树不同）。</li></ul></li></ul><h2 id="b-树的插入操作">B+ 树的插入操作</h2><p>B+ 树插入的三种情况</p><table><colgroup><col style="width:25%"><col style="width:25%"><col style="width:50%"></colgroup><thead><tr class="header"><th>Leaf Page 满</th><th>Index Page 满</th><th>操作</th></tr></thead><tbody><tr class="odd"><td>No</td><td></td><td>直接将记录插入到叶子节点</td></tr><tr class="even"><td>Yes</td><td>No</td><td>1) 拆分 Leaf Page<br>2) 将中间的节点放到 Index Page 中<br>3) 小于中间节点的记录放左边<br>4) 大于等于中间节点的记录放右边</td></tr><tr class="odd"><td>Yes</td><td>Yes</td><td>1) 拆分 Leaf Page<br>2) 小于中间节点的记录放左边<br>3) 大于等于中间记录的放右边<br> 4) 拆分 Index Page<br>5) 小于中间节点的记录放左边<br>6) 大于等于中间记录的放右边<br>7) 中间节点放入上一层 Index Page（若上一层已满，继续拆分）</td></tr></tbody></table><a id="more"></a><ul><li><p>Leaf Page 未满</p><p><img src="/uploads/image/inside-mysql/b+tree-insert-28.svg"></p><p>插入节点 28。（为简化作图，省略了叶子节点的前后指针）</p></li><li><p>Leaf Page 已满，Index Page 未满</p><p>在上图中插入节点 70。根据中间节点 60 进行拆分叶子节点。</p><p><img src="/uploads/image/inside-mysql/b+tree-insert-70.svg"></p></li><li><p>Leaf Page 已满，Index Page 已满</p><p>在上图中插入节点 95。先根据中间节点 85 拆分叶子节点。此时内部节点也需要拆分，按其中间节点 60 进行拆分。</p><p><img src="/uploads/image/inside-mysql/b+tree-insert-95.svg"></p></li></ul><p>为了保持平衡，对于新加入的键值可能需要做大量的拆分页操作。因为 B+ 树主要用于磁盘，页的拆分意味着磁盘的操作，所以应该在尽可能的情况下减少页的拆分操作。因此，B+ 树同样提供了类似于平衡二叉树的旋转（rotation）操作。</p><p><strong>旋转发生在 Leaf Page 已满，但是其左右兄弟节点未满的情况下</strong>。这是 B+ 树不会去做拆分页的操作，而是将记录移到所在页的兄弟节点上。</p><p>例如，插入 70 时若应用旋转操作，插入后的 B+ 树为：</p><p><img src="/uploads/image/inside-mysql/b+tree-insert-70-rotation.svg"></p><h2 id="b-树的删除操作">B+ 树的删除操作</h2><p>B+ 树使用填充因子（fill factor）来控制树的删除变化，50% 是填充因子可设的最小值。（书中的例子就是以 50% 为填充因子的，当填充因子更大时，如 60%，两个兄弟节点该如何合并，书中并未说明）</p><table><colgroup><col style="width:25%"><col style="width:25%"><col style="width:50%"></colgroup><thead><tr class="header"><th>Leaf Page 小于填充因子</th><th>Index Page 小于填充因子</th><th>操作</th></tr></thead><tbody><tr class="odd"><td>No</td><td></td><td>直接将记录从叶子节点删除，若该节点在 Index Page 中有索引，还需要更新索引</td></tr><tr class="even"><td>Yes</td><td>No</td><td>合并叶子节点和它的兄弟节点，同时更新索引</td></tr><tr class="odd"><td>Yes</td><td>Yes（合并叶子节点导致的）</td><td>1) 合并叶子节点和它的兄弟节点<br>2) 更新 Index Page<br>3) 合并 Index Page 和 它的兄弟节点<br>4) 更新 Index Page 的 Index Page</td></tr></tbody></table><ul><li><p>Leaf Page 不小于填充因子</p><p>删除 70 时不需要更新内部节点；删除 25 时，因为它是叶子的第一个值，删除后需要将它之后的值 28 更新到内部节点。</p><p><img src="/uploads/image/inside-mysql/b+tree-delete-70.svg"> <img src="/uploads/image/inside-mysql/b+tree-delete-25.svg"></p></li><li><p>Leaf Page 和 Index Page 都小于填充因子</p><p>继续删除节点 60，叶子节点小于填充因子，将剩余节点移动到左兄弟，更新内部节点的索引。</p><p>索引更新后也小于填充因子，同样将剩余节点移动到左兄弟，更新上一层内部节点的索引。（怎么实现的？内部节点有没有前后指针？有没有父节点指针？）</p><p><img src="/uploads/image/inside-mysql/b+tree-delete-60.svg"></p></li></ul><h1 id="b-树索引">B+ 树索引</h1><p>B+ 树索引就是传统意义上的索引，是目前关系型数据库中查找最为常用、最有有效的索引。B+ 树索引的本质就是 B+ 树在数据库中的实现。B+ 树索引在数据库中的一个特点是高扇出性，因此在数据库中，B+ 树的高度一般都在 2～4 层，这也就是说，查找某一键值的行记录最多只需要 2 到 4 次 IO。</p><p><strong>B+ 树索引并不能找到一个给定键值的具体行。B+ 树索引能找到的只是被查找数据行所在的页，然后数据库通过把页读入到内存，再在内存中进行二分查找，最后得到要查找的数据。</strong></p><h2 id="索引的分类">索引的分类</h2><p>数据库中的 B+ 树索引可以分为<strong>聚集索引</strong>（clustered index）和<strong>辅助索引</strong>（secondary index）。与辅助索引不同的是，聚集索引在叶子节点存放的是一整行的信息。</p><ul><li><p>聚集索引</p><p>聚集索引就是按照每张表的主键构造一棵 B+ 树，同时叶子节点（聚集索引的叶子节点也称为数据页）存放的是行记录数据。表中数据也是聚集索引的一部分。</p><p>实际的数据页只能按照一棵 B+ 树进行排序，因此每张表只能拥有一个聚集索引。在多数情况下，查询优化器倾向于采用聚集索引，因为聚集索引能在叶子节点上直接找到数据。</p><p>此外，由于定义了数据的逻辑顺序，聚集索引对于主键的排序查找和范围查找非常快。</p></li><li><p>辅助索引，也称非聚集索引</p><p>辅助索引的叶子节点不包含行记录的全部数据。叶子节点除了包含键值以外，还包括一个书签（bookmark），用来告诉 InnoDB 如何找到对应的行数据。该书签就是聚集索引的键。</p><p>辅助索引的存在并不影响数据在聚集索引中的组织，因此每张表上可以有多个辅助索引。当通过辅助索引来寻找数据时，InnoDB 会遍历辅助索引并通过叶节点获得对应行数据的主键，然后再通过主键索引（即聚集索引）来找到一个完整的行记录。</p></li></ul><h2 id="索引的分裂">索引的分裂</h2><p>B+ 树索引页的分裂并不总是从页的中间记录开始，例如下面的记录：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、2、3、4、5、6、7、8、9</span><br></pre></td></tr></table></figure><p>插入是根据自增顺序进行的，若插入 10 这条记录后需要进行页的分裂操作，那么根据之前的分裂方法，会将记录 5 作为分裂点，分裂后得到下面两个页：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P1: 1、2、3、4</span><br><span class="line">P2: 5、6、7、8、9、10</span><br></pre></td></tr></table></figure><p>然而由于插入是顺序的，P1 这个页中将不会再有记录被插入，从而导致空间的浪费。（旋转能填充兄弟节点，但旋转也有开销，应该尽量避免）</p><p>InnoDB 的 Page Header 中有几个部分用来保存插入的顺序信息，通过这些信息，InnoDB 决定是向左还是向右分裂，同时决定哪一个记录为分裂点。若插入是随机的，则取页的中间记录作为分裂点。</p><h2 id="索引的管理">索引的管理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table user(name char(6), gender boolean, address varchar(100), birthday date)engine=innodb;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line"># ===== 查看表中的索引 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; show index from user;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># ===== 创建/删除 主键索引 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table user drop primary key;</span><br><span class="line">ERROR 1091 (42000): Can&apos;t DROP &apos;PRIMARY&apos;; check that column/key exists</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table user add primary key (name);</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line"># ===== 创建/删除 辅助索引 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table user add key idx_addr (address);</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table user drop key idx_addr;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line"># ===== 也可以只索引一个列的开头部分数据 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table user add key idx_addr (address(2));  # 只索引开头</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table user add key idx_birth_name (birthday, name);  # 联合索引</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line"># ===== SHOW INDEX 各列含义 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; show index from user\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">        Table: user     # 索引所在的表</span><br><span class="line">   Non_unique: 0        # 非唯一索引，主键索引是唯一的，值为 0</span><br><span class="line">     Key_name: PRIMARY  # 索引的名字</span><br><span class="line"> Seq_in_index: 1        # 列在索引中的位置，看联合索引比较直观</span><br><span class="line">  Column_name: name     # 列的名字</span><br><span class="line">    Collation: A        # 列以什么方式存储在索引中。A（排序的） 或 NULL</span><br><span class="line">  Cardinality: 0        # 索引中唯一值的数目（估计值）</span><br><span class="line">     Sub_part: NULL     # 是否是部分被索引</span><br><span class="line">       Packed: NULL     # 关键字如何被压缩</span><br><span class="line">         Null:          # 列中是否含有 NULL 值</span><br><span class="line">   Index_type: BTREE    # 索引类型，InnoDB 只支持 B+ 树索引</span><br><span class="line">      Comment:          # 注释</span><br><span class="line">Index_comment:</span><br><span class="line">      Visible: YES</span><br><span class="line">   Expression: NULL</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">        Table: user</span><br><span class="line">   Non_unique: 1         # 辅助索引不是唯一的，值为 1</span><br><span class="line">     Key_name: idx_addr</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: address</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: 2         # 只对前 2 个字符进行索引</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: YES</span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment:</span><br><span class="line">Index_comment:</span><br><span class="line">      Visible: YES</span><br><span class="line">   Expression: NULL</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">        Table: user</span><br><span class="line">   Non_unique: 1         # birthday 是索引 (birthday, name) 的第 1 个列</span><br><span class="line">     Key_name: idx_birth_name</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: birthday</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: YES</span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment:</span><br><span class="line">Index_comment:</span><br><span class="line">      Visible: YES</span><br><span class="line">   Expression: NULL</span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">        Table: user</span><br><span class="line">   Non_unique: 1</span><br><span class="line">     Key_name: idx_birth_name</span><br><span class="line"> Seq_in_index: 2</span><br><span class="line">  Column_name: name</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null:</span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment:</span><br><span class="line">Index_comment:</span><br><span class="line">      Visible: YES</span><br><span class="line">   Expression: NULL</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="cardinality">Cardinality</h2><p>Cardinality: the number of elements in a set or other grouping, as a property of that grouping.</p><p>并不是所有的列都需要添加索引。</p><ul><li><p>低选择性</p><p>对于性别、地区、类型字段，它们可取的范围很小，称为低选择性。比如，按性别进行查询时，可取的值的范围一般只有 'M', 'F'，因此 <code>select * from student where sex='F';</code> 得到结果可能是表中 50% 的数据（假设男女比例 1:1），这时添加性别索引是完全没有必要的。</p></li><li><p>高选择性</p><p>如果某个字段的取值范围很广，几乎没有重复，即属于高选择性。此时使用 B+ 树索引是最合适的。例如，对于姓名字段，基本上在一个应用中不允许重名的出现。</p></li></ul><p>Cardinality 值表示索引中不重复记录数量的预估值，注意，是预估值而不是准确值。在实际应用中，<code>Cardinality / n_rows_in_table</code> 应尽可能地接近 1。</p><p>数据库是如何统计 Cardinality 信息的呢？因为每种存储引擎对于 B+ 树索引的实现各不相同，所以对 Cardinality 的统计是放在存储引擎层进行的。</p><p>在生产环境中，索引的更新操作可能是非常频繁的。如果每次更新时就进行 Cardinality 的统计，那么将会给数据库带来很大的负担。此外，如果一张表的数据非常大，那么一次统计 Cardinality 信息所需的时间可能非常长。因此，<strong>数据库对 Cardinality 的统计都是采用采样（sample）的方式来完成的</strong>。</p><p>在 InnoDB 中，Cardinality 的更新发生在两个操作中：INSERT 和 UPDATE。不可能每次都发生 INSERT 和 UPDATE 都更新，InnoDB 更新 Cardinality 信息的策略为：</p><ul><li>表中 1/16 的数据已发生过改变</li><li><code>stat_modified_counter &gt; 2 000 000 000</code></li></ul><p>第二种情况考虑的是，如果对表中某一行数据频繁地进行更新操作，发生变化的是这一行数据，此时第一种更新策略无法适用。</p><p>采样方法：InnoDB 随机选择 8 个叶子节点，统计每个页不同记录的数目，记为 <code>P1, ..., P8</code>。设 A 是叶子节点的数目，则<code>Cardinality = (P1 + ... + P8) * A / 8</code>。</p><p>语句 <code>SHOW INDEX FROM</code> 会触发 MySQL 数据库对 Cardinality 的统计，统计是通过随机采样完成的。因此，即使没有改变表中的内容，Cardinality 的值还是可能发生变化。</p><h1 id="联合索引">联合索引</h1><p>从本质上来说，联合索引也是一棵 B+ 树，不同的是联合索引的键值的数量不止一个。</p><p>例如，一个联合索引为 <code>(a, b)</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">               +-+-------+-+</span><br><span class="line">               | | (2,4) | |</span><br><span class="line">               +-+-------+-+</span><br><span class="line">               /           \</span><br><span class="line">(1,1)、(1,2)、(2,1)       (2,4)、(3,1)、(3,2)</span><br></pre></td></tr></table></figure><p>可以使用该联合索引的语句：</p><ul><li><code>select * from t where a=1;</code></li><li><code>select * from t where a=1 and b=2;</code></li><li><code>select * from t where a=1 order by b;</code></li></ul><p>不可以使用该联合索引的语句：</p><ul><li><code>select * from t where b=2;</code></li><li><code>select * from t order by b;</code></li></ul><p>因为在叶子节点上，<code>(a)</code> 和 <code>(a, b)</code> 都是排序的，而 <code>(b)</code> 的值不是排序的。</p><p>看一个例子。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ===== 准备测试表 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; create table buy_log(</span><br><span class="line">    -&gt;   userid int unsigned not null,</span><br><span class="line">    -&gt;   buy_date date</span><br><span class="line">    -&gt; )engine=innodb;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into buy_log values</span><br><span class="line">    -&gt; (1,&apos;2009-01-01&apos;),</span><br><span class="line">    -&gt; (2,&apos;2009-01-01&apos;),</span><br><span class="line">    -&gt; (3,&apos;2009-01-01&apos;),</span><br><span class="line">    -&gt; (1,&apos;2009-02-01&apos;),</span><br><span class="line">    -&gt; (3,&apos;2009-02-01&apos;),</span><br><span class="line">    -&gt; (1,&apos;2009-03-01&apos;),</span><br><span class="line">    -&gt; (1,&apos;2009-04-01&apos;);</span><br><span class="line">Query OK, 7 rows affected (0.00 sec)</span><br><span class="line">Records: 7  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line"># ===== 创建了两个索引 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table buy_log add key(userid);</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table buy_log add key(userid, buy_date);</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p>如果只对 userid 进行查询，既可以使用 userid 这个索引，也可以使用 (userid, buy_date) 这个联合索引。优化器最终的选择是索引 userid，因为该索引包含单个键值，所以理论上一个页能存放的记录更多。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from buy_log where userid=2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: buy_log</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: userid,userid_2  # 可使用的索引</span><br><span class="line">          key: userid           # 优化器选择了 userid 索引</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>如果要取出 userid=1 的最近 3 次记录，这次优化器使用了联合索引，因为在联合索引中 buy_date 已经排好序了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from buy_log where userid=1 order by buy_date desc limit 3\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: buy_log</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: userid,userid_2</span><br><span class="line">          key: userid_2                # 优化器选择了联合索引</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 4</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Backward index scan; Using index  # 索引扫描</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line"># ===== 若强制使用 userid 索引 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from buy_log force index(userid) where userid=1 order by buy_date desc limit 3\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: buy_log</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: userid</span><br><span class="line">          key: userid          # 强制使用 userid</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 4</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using filesort  # 需要一次排序</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><h1 id="覆盖索引">覆盖索引</h1><p>覆盖索引（covering index，或称索引覆盖）即从辅助索引中就可以得到查询的记录，而不需要再次查询聚集索引。（覆盖索引不是一种索引，而是一种使用索引的方法）</p><p>使用覆盖索引的一个好处是，辅助索引不包含行记录的所有信息，故其大小要远小于聚集索引，因此可以减少 I/O 操作。</p><p>辅助索引的另一个好处是对某些统计问题而言的。<strong>列 Extra 的 Using index 代表优化器进行了覆盖索引操作</strong>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ===== 统计所有记录数 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select count(*) from buy_log\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: buy_log</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index</span><br><span class="line">possible_keys: NULL      # 可使用索引为 NULL</span><br><span class="line">          key: userid    # 实际选择了 userid 这个辅助索引</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 7</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>表 buy_log 中有 (userid, buy_date) 联合索引，一般情况下，只根据列 buy_date 进行条件查询是不能使用联合索引的（这里就不是一般情况），因为联合索引中记录不是按 buy_date 排序的。</p><p>这里不一般是因为表只有两个列，且全部包含在联合索引中，所以使用该联合索引能覆盖要查询的整行信息。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ===== 只针对列 buy_date 进行条件查询 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from buy_log where buy_date&gt;=&apos;2011-01-01&apos; and buy_date&lt;=&apos;2011-02-01&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: buy_log</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index</span><br><span class="line">possible_keys: userid_2</span><br><span class="line">          key: userid_2  # 使用联合索引</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 7</span><br><span class="line">     filtered: 14.29</span><br><span class="line">        Extra: Using where; Using index</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line"># ===== 随便加一个列 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table buy_log add price decimal;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line"># ===== 再次针对 buy_date 进行条件查询 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from buy_log where buy_date&gt;=&apos;2011-01-01&apos; and buy_date&lt;=&apos;2011-02-01&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: buy_log</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL    # 联合索引中没有 price 的值</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 7</span><br><span class="line">     filtered: 14.29</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>但是，若查询是针对 buy_date 的统计操作：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ===== 统计某段时间内的记录数 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select count(*) from buy_log where buy_date&gt;=&apos;2011-01-01&apos; and buy_date&lt;=&apos;2011-02-01&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: buy_log</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index</span><br><span class="line">possible_keys: userid_2</span><br><span class="line">          key: userid_2    # 使用联合索引</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 7</span><br><span class="line">     filtered: 14.29</span><br><span class="line">        Extra: Using where; Using index  # 使用了覆盖索引</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><h1 id="不使用索引的情况">不使用索引的情况</h1><p>在某些情况下，当执行 EXPLAIN 命令进行 SQL 语句的分析时，会发现优化器没有选择（辅助）索引去查找数据，而是通过扫描聚集索引，也就是直接进行全表扫描来得到数据。这种情况多发生于范围查找、JOIN 链接操作等情况下。</p><p>原因在于用户要选取的数据，不能被（辅助）索引完全覆盖。<strong>在使用（辅助）索引查到指定数据后，还需要一次书签访问来查找缺少的信息，而书签查找的数据则是无序的，因此变为了磁盘上的离散读操作</strong>。如果访问的数据量很小，优化器会选择辅助索引，但是当访问的数据占整个表的蛮大一部分时（一般是 20% 左右），优化器会选择通过聚集索引来查找数据。因为顺序读要远远快于离散读。（如何知道占比？）</p><p>若用户使用的磁盘是固态硬盘，随机读操作非常快，同时有足够的自信确认使用辅助索引可以带来更好的性能，那么可以使用 FORCE INDEX 强制使用某个索引。</p><h1 id="索引提示">索引提示</h1><p>MySQL 支持使用索引提示，显示地告诉优化器使用哪个索引。以下两种情况可能需要用到索引提示：</p><ul><li>优化器错误地选择了某个索引，导致 SQL 语句运行的很慢。这种情况非常非常的少见，优化器在绝大部分情况下工作得非常正确和有效。</li><li>某 SQL 语句可以选择的索引非常多，这是优化器执行的开销可能会大于 SQL 语句本身。例如，优化器分析 Range 查询本身就是比较耗时的操作。</li></ul><p>如果用户确定指定某个索引来完成查询，最可靠的是使用 FORCE INDEX：</p><ul><li><code>USE INDEX(idx)</code>：告诉优化器可以使用 idx 索引（设置的是 possible_keys 列的值），优化器还会再根据自己的判断进行选择，即不一定最终选择 idx。</li><li><code>FORCE INDEX(idx)</code>：强制使用 idx 索引（设置的是 key 列的值）。</li></ul><h1 id="multi-range-read-优化">Multi-Range Read 优化</h1><p>MySQL 5.6 开始支持 Multi-Range Read（MRR）优化。MRR 优化的目的是为了减少磁盘的随机访问，并且将随机访问转化为较为顺序的数据访问，这对 IO-bound 类型的 SQL 查询语句可带来性能极大的提升。MRR 优化可适用于 range, ref, eq_ref 类型的查询。</p><p>对于 InnoDB 和 MyISAM 的范围查询和 JOIN 查询，MRR 的工作方式如下：</p><ul><li>将查询得到的索引键值存放于一个缓存中。</li><li>将缓存中的键值根据 RowID 进行排序。</li><li>根据 RowID 的排序顺序来访问实际的数据文件。</li></ul><p>MRR 优化有以下几个好处：</p><ul><li>使数据访问变得较为顺序。顺序读快于离散读。</li><li>减少缓冲池中页被替换的次数。若存储引擎的缓冲池不够大，频繁的离散读操作会导致缓存中的页被替换出缓冲池，然后又有可能被再次读入。若按照主键顺序进行访问，则可以将此重复行为降至最低。</li><li><p>批量处理对键值的查询操作。MRR 可以将某些范围查询，拆分成键值对，以此来进行批量的数据查询。这样做的好处是可以在拆分过程中，<strong>直接过滤一些不符合查询条件的数据</strong>。</p><p>例如，<code>select * from t where key1 &gt;= 1000 and key1 &lt; 2000 and key2 = 10000;</code>。表中有 <code>(key1, key2)</code> 的联合索引，若没有 MRR，此时查询类型为 Range，优化器会先将 <code>key1 &gt;= 1000 and key1 &lt; 2000</code> 的数据都取出，再根据 <code>key2 = 10000</code> 进行过滤。这会导致无用数据被取出。</p><p>若启用了 MRR 优化，优化器会先将查询条件进行拆分，就上述查询语句而言，优化器会将查询条件拆分为 <code>(1000, 10000), (1001, 10000), ..., (1999, 10000)</code>，然后再根据拆分出的条件进行数据的查询。</p></li></ul><p>是否启用了 MRR 优化可以通过参数 optimizer_switch 中的标记来控制。</p><ul><li>mrr：是否启用 MRR优化。</li><li>mrr_cost_based：是否通过 cost based 的方式启用 MRR 优化。若 <code>mrr=on,mrr_cost_based=off</code> 则总是启用 MRR 优化。</li></ul><p>参数 read_rnd_buffer_size 用来控制键值的缓冲区大小，默认值是 256K。当缓存大于该值时，则执行器对已经缓存的数据根据 RowID 进行排序，并通过 RowID 来取得行数据。</p><h1 id="index-condition-pushdown-优化">Index Condition Pushdown 优化</h1><p>Index Condition Pushdown（ICP）同样是 MySQL 5.6 开始支持的一种根据索引进行查询的优化方式。在这之前，当进行索引查询时，首先根据索引来查找记录，再根据 WHERE 条件来过滤记录。<strong>支持 ICP 后，MySQL 会在取出索引的同时，判断是否可以进行 WHERE 条件的过滤</strong>，将 WHERE 的部分过滤操作放在了存储引擎层。在某些查询下，可以大大减少上层 SQL 层对记录的索取（fetch），从而提高数据库的整体性能。</p><p>ICP 优化支持 range, ref, eq_ref, ref_or_null 类型的查询，当优化器选择 ICP 优化时，可在执行计划的列 Extra 看到 Using index condition 提示。</p><p>假设某张表有联合索引 <code>(zip_code, last_name, first_name)</code>，并且查询语句为</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> people</span><br><span class="line"><span class="keyword">where</span> zip_code=<span class="string">'95054'</span></span><br><span class="line"><span class="keyword">and</span> lastname <span class="keyword">like</span> <span class="string">'%etrunia%'</span></span><br><span class="line"><span class="keyword">and</span> address <span class="keyword">like</span> <span class="string">'%Main Street%'</span>;</span><br></pre></td></tr></table></figure><p>若不支持 ICP 优化，则数据库先通过索引取出所有 <code>zip_code='95054'</code> 的记录，再按后两个条件过滤。若支持 ICP 优化，则在索引取出时，就会进行 WHERE 条件的过滤，然后再去获取记录。这将大大地提高查询的效率。当然，过滤的条件要在该索引可以覆盖的范围（address 必须在取到完整记录后才能过滤）。</p><h1 id="哈希算法">哈希算法</h1><p>InnoDB 使用哈希算法进行查找，其冲突机制采用链接法（chaining），对于缓冲池页的哈希表来说，每个页都有一个 chain 指针，指向相同哈希函数值的页。</p><p>哈希函数采用除法散列（<code>h(k) = k % m</code>）方式，m 的取值为略大于 2 倍页数量的质数。例如：当 innodb_buffer_pool_size 的大小为 10M，则共有 640 个 16K 的页，哈希表中需要分配 640x2=1280 个槽，但是由于 1280 不是质数，需要取比 1280 略大的一个质数，应该是 1399。</p><p>如何计算页的 k 呢？InnoDB 的表空间都有一个 space_id，用户所要查询的应该是某个表空间的某个连续 16KB 的页，即偏移量 offset。InnoDB 将 space_id 左移 20 位，然后加上这个 space_id 和 offset，即 <code>k = (space_id &lt;&lt; 20) + space_id + offset</code>，再通过除法散列到各个槽中。</p><h2 id="自适应哈希索引">自适应哈希索引</h2><p>自适应哈希索引采用上述哈希表的方式实现。不同的是，<strong>这仅是数据库自身创建并使用的，DBA 并不能对其进行干预</strong>。自适应哈希索引经哈希函数映射到一个哈希表中，对于等值查询非常快速，如 <code>select * from t where key='xxx';</code>。但是对于范围查询就无能为力了。</p><p>通过命令 <code>show engine innodb status</code> 可以看到当前自适应索引的使用情况。</p><h1 id="全文检索">全文检索</h1><p>B+ 树索引支持通过字段的前缀进行查找，例如 <code>select * from blog where content like 'xxx%';</code> 可以查询内容以 xxx 开头的文章，并且只要 content 添加了 B+ 树索引，就能利用索引进行快速查询。</p><p>然而实际这种查询不符合用户的需求，因为在更多的情况下，用户需要查询的是博客内容包含某个单词 xxx 的文章，即 <code>select * from blog where content like '%xxx%';</code>。</p><p>全文检索（Full-Text Search）是将存储于数据库中的整本书或整篇文章中的任意内容信息检索出来的技术。它可以根据需要获得全文中的章、节、段、句、词等信息，也可以进行各种统计和分析。</p><p>从 InnoDB 1.2.x 版本开始，InnoDB 开始支持全文检索，其支持 MyISAM 存储引擎的全部功能，并且还支持其他的一些特性。</p><h2 id="倒排索引">倒排索引</h2><p>全文检索通常使用倒排索引（inverted index）来实现。倒排索引在辅助表中存储了单词与单词自身在一个或多个文档中所在位置之间的映射。这通常利用关联数组实现，其拥有两种表现形式：</p><ul><li>inverted file index，表现形式为 <code>(单词, 单词所在文档的 ID)</code>。</li><li>full inverted index，表现形式为 <code>(单词, 单词所在文档的 ID, 在文档中的具体位置)</code>。full inverted index 占用更多的空间，但是能更好地定位数据，并扩充一些其他的搜索特性。</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ===== 表 =====</span><br><span class="line"></span><br><span class="line">Id  Text</span><br><span class="line">1   Pease porridge hot, pease porridge cold</span><br><span class="line">2   Pease porridge in the pot</span><br><span class="line">3   Nine days old</span><br><span class="line"></span><br><span class="line"># ===== inverted file index =====</span><br><span class="line"></span><br><span class="line">Id  Text      Document</span><br><span class="line">1   code      1        # code 存在于文档 1 中</span><br><span class="line">2   days      3</span><br><span class="line">3   hot       1</span><br><span class="line">4   in        2</span><br><span class="line">5   nine      3</span><br><span class="line">6   old       3</span><br><span class="line">7   pease     1,2      # pease 存在于文档 1 和 2 中</span><br><span class="line">8   porridge  1,2</span><br><span class="line">9   pot       2</span><br><span class="line">10  the       2</span><br><span class="line"></span><br><span class="line"># ===== full inverted index =====</span><br><span class="line"></span><br><span class="line">Id  Text      Document</span><br><span class="line">1   code      (1,6)        # code 是文档 1 中的第 6 个单词</span><br><span class="line">2   days      (3,2)</span><br><span class="line">3   hot       (1,3)</span><br><span class="line">4   in        (2,3)</span><br><span class="line">5   nine      (3,1)</span><br><span class="line">6   old       (3,3)</span><br><span class="line">7   pease     (1,1), (1,4), (2,1)</span><br><span class="line">8   porridge  (1,2), (1,5), (2,2)</span><br><span class="line">9   pot       (2,5)</span><br><span class="line">10  the       (2,4)</span><br></pre></td></tr></table></figure><h2 id="innodb-全文检索">InnoDB 全文检索</h2><p>InnoDB 采用 full inverted index 的方式。由于存放了 word 的 position 信息，故可以进行 Proximity Search（临近查询，临近指的是两个单词之间的距离）。</p><p>倒排索引需要将 word 存放到一张表中，称为辅助表（Auxiliary Table）。在 InnoDB 中，为了提高全文检索的并行性能，共有 6 张辅助表，每张表根据 word 的 Latin 编码进行分区。</p><p>辅助表是持久的表，存放于磁盘上。在全文索引中，还有一个重要的概念 FTS Index Cache（全文检索索引缓存，以下简称 FTSIC），其用来提高全文检索的性能。</p><p>全文检索索引缓存是一个红黑树结构，其根据 <code>(word, (documentId, position))</code> 进行排序。InnoDB 会批量对辅助表进行更新，向源数据表中插入记录后，将通过分词得到的 full inverted index 存入 FTSIC，而不是更新辅助表。当进行全文检索时，首先将 FTSIC 中对应的 word 字段合并到辅助表，再进行查询。</p><p>InnoDB 允许用户查看指定倒排索引的辅助表中分词的信息，通过设置全局参数 innodb_ft_aux_table 指定想查看的表，之后查询 information_schema 架构下的 INNODB_FT_INDEX_TABLE 即可看到分词信息。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; set global innodb_ft_aux_table=&apos;test/fts&apos;;    # test 架构下的 fts 表</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.innodb_ft_index_table;  # 查看分词信息</span><br></pre></td></tr></table></figure><p>当数据库关闭时，FTSIC 中的数据会同步到辅助表。然而，当数据库发生宕机时，一些数据可能未被同步到磁盘上，那么下次重启数据库时，当用户进行全文检索（查询或者插入）时，InnoDB 会自动读取未完成的文档，然后进行分词操作，再将分词的结果放入 FTSIC 中。参数 innodb_ft_cache_size 用来控制 FTSIC 的大小，默认值为 32M。增大该参数可以提高全文检索的性能，但是在宕机后，可能需要更长的时间恢复。</p><h3 id="fts-document-id">FTS Document ID</h3><p>FTS Document ID 是另一个重要的概念。为了支持全文检索，必须有一个列与 word 进行映射，在 InnoDB 中这个列被命名为 FTS_DOC_ID，其类型必须是 BIGINT UNSIGNED NOT NULL，并且 InnoDB 会在该列上加上一个名为 FTS_DOC_ID_INDEX 的 Unique Index（我没看到，还是自己加上该索引吧）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table fts(FTS_DOC_ID bigint unsigned not null, body text);</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show index from fts;</span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure><p>对于删除操作，不删除辅助表中的记录，而只是删除 FTSIC 中的记录。对于被删除的记录，InnoDB 会记录其 FTS Document ID，并将其保存在 ”删除辅助表“ 中。由于 DML 操作不会删除索引中的数据，因此索引会变得非常大。为此，InnoDB 允许用户通过命令 OPTIMIZE TABLE 手工地将已经删除的记录从索引中彻底删除。OPTIMIZE TABLE 还会进行一些其他的操作，如 Cardinality 的重新统计，若用户希望仅对倒排索引进行操作，可以通过全局参数 innodb_optimize_fulltext_only 进行设置。</p><p>若被删除的文档非常多，那么 OPTIMIZE TBALE 操作可能需要占用非常多的时间，这会影响应用程序的并发行，并极大地降低用户的响应时间。可以通过设置参数 innodb_ft_num_word_optimize 来限制每次实际删除的分词数量。默认值为 2000。</p><h3 id="例子">例子</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ===== 准备测试表 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; create table fts(</span><br><span class="line">    -&gt;   FTS_DOC_ID bigint unsigned not null auto_increment,  # 添加自增属性</span><br><span class="line">    -&gt;   body text,</span><br><span class="line">    -&gt;   primary key(FTS_DOC_ID)                              # 加上主键索引</span><br><span class="line">    -&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts(body) values</span><br><span class="line">    -&gt; (&apos;Pease porridge in the pot&apos;),</span><br><span class="line">    -&gt; (&apos;Pease porridge hot, pease porridge cold&apos;),</span><br><span class="line">    -&gt; (&apos;Nine days old&apos;);</span><br><span class="line">Query OK, 3 rows affected (0.00 sec)</span><br><span class="line">Records: 3  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; create fulltext index idx_fts on fts(body);  # 添加全文索引</span><br><span class="line">Query OK, 0 rows affected (0.04 sec)                # 先插入数据，再创建索引，是一种比较推荐的方式</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from fts;</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">| FTS_DOC_ID | body                                    |</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">|          1 | Pease porridge in the pot               |</span><br><span class="line">|          2 | Pease porridge hot, pease porridge cold |</span><br><span class="line">|          3 | Nine days old                           |</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># ===== 查看辅助表 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; set global innodb_ft_aux_table=&apos;test/fts&apos;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.innodb_ft_index_table;</span><br><span class="line">+----------+--------------+-------------+-----------+--------+----------+</span><br><span class="line">| WORD     | FIRST_DOC_ID | LAST_DOC_ID | DOC_COUNT | DOC_ID | POSITION |</span><br><span class="line">+----------+--------------+-------------+-----------+--------+----------+</span><br><span class="line">| cold     |            2 |           2 |         1 |      2 |       35 |</span><br><span class="line">| days     |            3 |           3 |         1 |      3 |        5 |</span><br><span class="line">| hot      |            2 |           2 |         1 |      2 |       15 |</span><br><span class="line">| nine     |            3 |           3 |         1 |      3 |        0 |</span><br><span class="line">| old      |            3 |           3 |         1 |      3 |       10 |</span><br><span class="line">| pease    |            1 |           2 |         2 |      1 |        0 |</span><br><span class="line">| pease    |            1 |           2 |         2 |      2 |        0 |</span><br><span class="line">| pease    |            1 |           2 |         2 |      2 |       20 |</span><br><span class="line">| porridge |            1 |           2 |         2 |      1 |        6 |</span><br><span class="line">| porridge |            1 |           2 |         2 |      2 |        6 |</span><br><span class="line">| porridge |            1 |           2 |         2 |      2 |       20 |</span><br><span class="line">| pot      |            1 |           1 |         1 |      1 |       22 |</span><br><span class="line">+----------+--------------+-------------+-----------+--------+----------+</span><br><span class="line">12 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>可以看到每个 word 都对应了一个 DOC_ID 和 POSITION（单位是字符）。此外，还记录了 FIRST_DOC_ID（第一次出现的文档 ID）、LAST_DOC_ID（最后一次出现的文档 ID）及 DOC_COUNT（在多少个文档内出现）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ===== 删除一条记录 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; delete from fts where FTS_DOC_ID=3;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.innodb_ft_deleted;</span><br><span class="line">+--------+</span><br><span class="line">| DOC_ID |</span><br><span class="line">+--------+</span><br><span class="line">|      3 |</span><br><span class="line">+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.innodb_ft_index_table;  # 辅助表中文档 3 依然存在</span><br><span class="line">+----------+--------------+-------------+-----------+--------+----------+</span><br><span class="line">| WORD     | FIRST_DOC_ID | LAST_DOC_ID | DOC_COUNT | DOC_ID | POSITION |</span><br><span class="line">+----------+--------------+-------------+-----------+--------+----------+</span><br><span class="line">| cold     |            2 |           2 |         1 |      2 |       35 |</span><br><span class="line">| days     |            3 |           3 |         1 |      3 |        5 |</span><br><span class="line">| hot      |            2 |           2 |         1 |      2 |       15 |</span><br><span class="line">| nine     |            3 |           3 |         1 |      3 |        0 |</span><br><span class="line">| old      |            3 |           3 |         1 |      3 |       10 |</span><br><span class="line">| pease    |            1 |           2 |         2 |      1 |        0 |</span><br><span class="line">| pease    |            1 |           2 |         2 |      2 |        0 |</span><br><span class="line">| pease    |            1 |           2 |         2 |      2 |       20 |</span><br><span class="line">| porridge |            1 |           2 |         2 |      1 |        6 |</span><br><span class="line">| porridge |            1 |           2 |         2 |      2 |        6 |</span><br><span class="line">| porridge |            1 |           2 |         2 |      2 |       20 |</span><br><span class="line">| pot      |            1 |           1 |         1 |      1 |       22 |</span><br><span class="line">+----------+--------------+-------------+-----------+--------+----------+</span><br><span class="line">12 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global innodb_optimize_fulltext_only=1;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; optimize table fts;</span><br><span class="line">+----------+----------+----------+----------+</span><br><span class="line">| Table    | Op       | Msg_type | Msg_text |</span><br><span class="line">+----------+----------+----------+----------+</span><br><span class="line">| test.fts | optimize | status   | OK       |</span><br><span class="line">+----------+----------+----------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.innodb_ft_index_table;</span><br><span class="line">+----------+--------------+-------------+-----------+--------+----------+</span><br><span class="line">| WORD     | FIRST_DOC_ID | LAST_DOC_ID | DOC_COUNT | DOC_ID | POSITION |</span><br><span class="line">+----------+--------------+-------------+-----------+--------+----------+</span><br><span class="line">| cold     |            2 |           2 |         1 |      2 |       35 |</span><br><span class="line">| hot      |            2 |           2 |         1 |      2 |       15 |</span><br><span class="line">| pease    |            1 |           2 |         2 |      1 |        0 |</span><br><span class="line">| pease    |            1 |           2 |         2 |      2 |        0 |</span><br><span class="line">| pease    |            1 |           2 |         2 |      2 |       20 |</span><br><span class="line">| porridge |            1 |           2 |         2 |      1 |        6 |</span><br><span class="line">| porridge |            1 |           2 |         2 |      2 |        6 |</span><br><span class="line">| porridge |            1 |           2 |         2 |      2 |       20 |</span><br><span class="line">| pot      |            1 |           1 |         1 |      1 |       22 |</span><br><span class="line">+----------+--------------+-------------+-----------+--------+----------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from  information_schema.innodb_ft_deleted;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from  information_schema.innodb_ft_being_deleted;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts values(3, &apos;Nine days old&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>以下是 MySQL 8 与原文中的不同之处：</p><ul><li>优化后 information_schema.innodb_ft_deleted 表中的记录也被删除了。</li><li>删除的文档 ID 3 没有被记录到 information_schema.innodb_ft_being_deleted 表中。</li><li>可以再次插入 ID 为 3 的记录。</li></ul><h3 id="stopword">stopword</h3><p>stopword 列表中的单词不需要对其进行索引分词操作。例如，对于 the 这个单词，由于其不具有具体的意义，将其视为 stopword。InnoDB 有一张默认的 stopword 列表，位于 <code>information_schema.innodb_ft_default_stopword</code>，默认有 36 个 stopword。用户可以通过参数 innodb_ft_server_stopword_table 来指定 stopword 列表。</p><p>当前 InnoDB 的全文检索还存在以下的限制：</p><ul><li>每张表只能有一个全文检索的索引。（MySQL 8 可以）</li><li>由多列组合而成的全文检索索引，列必须使用相同的字符集与排序规则。（没测试）</li><li>不支持没有单词定界符的语言，如中文、日语、韩语等。（MySQL 8 也不支持）</li></ul><h2 id="全文检索查询">全文检索查询</h2><p>MySQL 通过 <code>MATCH(...) AGAINST(...)</code> 语法支持全文检索查询。MATCH 指定了需要被查询的列，AGAINST 指定了使用何种方法进行查询。</p><h3 id="natural-language-mode">Natural Language Mode</h3><p>全文检索默认采用 Natural Language 模式，表示查询带有指定 word 的文档。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from fts;</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">| FTS_DOC_ID | body                                    |</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">|          1 | Pease porridge in the pot               |</span><br><span class="line">|          2 | Pease porridge hot, pease porridge cold |</span><br><span class="line">|          3 | Nine days old                           |</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from fts where body like &apos;%pease%&apos;;</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">| FTS_DOC_ID | body                                    |</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">|          1 | Pease porridge in the pot               |</span><br><span class="line">|          2 | Pease porridge hot, pease porridge cold |</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># ===== 查询单词 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from fts</span><br><span class="line">    -&gt; where match(body)    # in natural language mode 可省略</span><br><span class="line">    -&gt; against(&apos;pease&apos; in natural language mode);</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">| FTS_DOC_ID | body                                    |</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">|          2 | Pease porridge hot, pease porridge cold |</span><br><span class="line">|          1 | Pease porridge in the pot               |</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from fts where match(body) against(&apos;pease&apos;)\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: fts</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: fulltext</span><br><span class="line">possible_keys: idx_fts</span><br><span class="line">          key: idx_fts     # 使用全文索引</span><br><span class="line">      key_len: 0</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where; Ft_hints: sorted</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>在 WHERE 条件中使用 MATCH 函数，查询返回的结果是根据相关性进行降序排序的，0 表示没有相关性。上述查询中，由于 pease 在文档 2 中出现了两次，因而具有更高的相关性，故第一个显示。</p><p>为了统计 MATCH 函数得到的结果数量，可以用下列 SQL 语句：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">as</span> <span class="keyword">count</span> <span class="keyword">from</span> fts <span class="keyword">where</span> <span class="keyword">match</span>(<span class="keyword">body</span>) against(<span class="string">'pease'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">if</span>(<span class="keyword">match</span>(<span class="keyword">body</span>) against(<span class="string">'pease'</span>), <span class="number">1</span>, <span class="literal">null</span>)) <span class="keyword">as</span> <span class="keyword">count</span> <span class="keyword">from</span> fts;</span><br></pre></td></tr></table></figure><p>两句 SQL 得到的逻辑结果是相同的，但是从内部运行来看，第二句的执行速度可能更快些。因为第一句还需要进行相关性的排序统计，而第二句不需要。用户可以查看相关性（即 SELECT MATCH 函数的返回结果，而不是将其作为 WHERE 的条件）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select fts_doc_id as id, body,</span><br><span class="line">    -&gt;   match(body) against (&apos;pease&apos;) as relevance</span><br><span class="line">    -&gt; from fts;</span><br><span class="line">+----+-----------------------------------------+----------------------------+</span><br><span class="line">| id | body                                    | relevance                  |</span><br><span class="line">+----+-----------------------------------------+----------------------------+</span><br><span class="line">|  1 | Pease porridge in the pot               | 0.000000001885928302414186 |</span><br><span class="line">|  2 | Pease porridge hot, pease porridge cold | 0.000000003771856604828372 |</span><br><span class="line">|  3 | Nine days old                           |                          0 |</span><br><span class="line">+----+-----------------------------------------+----------------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>InnoDB 的全文检索，还需要考虑以下的因素：</p><ul><li>忽略 stopword 列表中的单词。</li><li>只查询长度在 <code>[innodb_ft_min_token_size, innodb_ft_max_token_size]</code> 内的单词，默认值是 <code>[3, 84]</code>。</li></ul><h3 id="boolean-mode">Boolean Mode</h3><p>Boolean 全文检索支持以下操作符：</p><table><thead><tr class="header"><th>布尔操作符</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>+</code></td><td>必须存在，例如 <code>+pease</code> 表示 pease 必须存在</td></tr><tr class="even"><td><code>-</code></td><td>必须被排除</td></tr><tr class="odd"><td>无操作符</td><td>可选的，但是如果出现，其相关性会更高</td></tr><tr class="even"><td><code>@</code></td><td>临近查询，例如 <code>&quot;pease pot&quot;@30</code> 将查询 pease 和 pot 距离在 30 个字符内的文章</td></tr><tr class="odd"><td><code>&gt;</code></td><td>出现时增加相关性</td></tr><tr class="even"><td><code>&lt;</code></td><td>出现时降低相关性</td></tr><tr class="odd"><td><code>~</code></td><td>出现时相关性为负</td></tr><tr class="even"><td><code>*</code></td><td>词尾通配符，例如 <code>lik*</code> 可以匹配 <code>lik</code>、<code>like</code></td></tr><tr class="odd"><td><code>&quot; &quot;</code></td><td>定义短语，例如 <code>'&quot;like hot&quot;'</code> 将 like hot 视为一个短语，而不是两个单词</td></tr></tbody></table><p>例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ===== 查询同时包含 pease 和 hot 的文章 ====</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from fts</span><br><span class="line">    -&gt; where match(body) against (&apos;+pease +hot&apos; in boolean mode);</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">| FTS_DOC_ID | body                                    |</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">|          2 | Pease porridge hot, pease porridge cold |</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># ===== 临近搜索 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from fts</span><br><span class="line">    -&gt; where match(body) against (&apos;&quot;pease pot&quot;@30&apos; in boolean mode);</span><br><span class="line">+------------+---------------------------+</span><br><span class="line">| FTS_DOC_ID | body                      |</span><br><span class="line">+------------+---------------------------+</span><br><span class="line">|          1 | Pease porridge in the pot |</span><br><span class="line">+------------+---------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># ===== 查询短语 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from fts where match(body) against (&apos;&quot;porridge hot&quot;&apos; in boolean mode);</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">| FTS_DOC_ID | body                                    |</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">|          2 | Pease porridge hot, pease porridge cold |</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="query-expansion">Query Expansion</h3><p>MySQL 全文检索支持扩展查询。这种查询通常在查询的关键词太短，用户需要隐含知识时进行。例如，对于单词 database 查询，用户可能希望查询的不仅仅是包含 database 的文章，可能还指那些包含 MySQL、Oracle 的文章。这时可以使用 Query Expansion 模式。</p><p>通过在查询短语中添加 WITH QUERY EXPANSION 或 IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION 可以开启 blind query expansion（又称为 automatic relevance feedback）。该查询分为两个阶段：</p><ol type="1"><li>根据搜索的单词进行全文检索查询。</li><li>根据第一阶段产生的分词再进行一次全文检索的查询。</li></ol><p>例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table articles(</span><br><span class="line">    -&gt;   id int unsigned auto_increment primary key,</span><br><span class="line">    -&gt;   title varchar(200),</span><br><span class="line">    -&gt;   body text,</span><br><span class="line">    -&gt;   fulltext (title, body)    # InnoDB 会自动添加 FTS_DOC_ID 列</span><br><span class="line">    -&gt; )engine=innodb;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into articles (title,body) values</span><br><span class="line">    -&gt; (&apos;MySQL Tutorial&apos;, &apos;DBMS stands for DataBase ...&apos;),</span><br><span class="line">    -&gt; (&apos;How To Use MySQL Well&apos;, &apos;After you went through a ...&apos;),</span><br><span class="line">    -&gt; (&apos;Optimizing MySQL&apos;, &apos;In this tutorial we will show ...&apos;),</span><br><span class="line">    -&gt; (&apos;1001 MySQL Tricks&apos;, &apos;1. Never run mysqld as root. 2. ...&apos;),</span><br><span class="line">    -&gt; (&apos;MySQL vs. YourSQL&apos;, &apos;In the following database comparison ...&apos;),</span><br><span class="line">    -&gt; (&apos;MySQL Security&apos;, &apos;When configured properly, MySQL ...&apos;),</span><br><span class="line">    -&gt; (&apos;IBM History&apos;, &apos;DB2 history for IBM ...&apos;);</span><br><span class="line">Query OK, 7 rows affected (0.01 sec)</span><br><span class="line">Records: 7  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from articles</span><br><span class="line">    -&gt; where match(title, body) against(&apos;database&apos;);</span><br><span class="line">+----+-------------------+------------------------------------------+</span><br><span class="line">| id | title             | body                                     |</span><br><span class="line">+----+-------------------+------------------------------------------+</span><br><span class="line">|  1 | MySQL Tutorial    | DBMS stands for DataBase ...             |</span><br><span class="line">|  5 | MySQL vs. YourSQL | In the following database comparison ... |</span><br><span class="line">+----+-------------------+------------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from articles</span><br><span class="line">    -&gt; where match(title, body) against(&apos;database&apos; with query expansion);</span><br><span class="line">+----+-----------------------+------------------------------------------+</span><br><span class="line">| id | title                 | body                                     |</span><br><span class="line">+----+-----------------------+------------------------------------------+</span><br><span class="line">|  5 | MySQL vs. YourSQL     | In the following database comparison ... |</span><br><span class="line">|  1 | MySQL Tutorial        | DBMS stands for DataBase ...             |</span><br><span class="line">|  3 | Optimizing MySQL      | In this tutorial we will show ...        |</span><br><span class="line">|  6 | MySQL Security        | When configured properly, MySQL ...      |</span><br><span class="line">|  2 | How To Use MySQL Well | After you went through a ...             |</span><br><span class="line">|  4 | 1001 MySQL Tricks     | 1. Never run mysqld as root. 2. ...      |</span><br><span class="line">+----+-----------------------+------------------------------------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>Query Expansion 的全文检索可能带来许多非相关性的查询，因此在使用时需要非常谨慎。</p></div><div class="popular-posts-header">相关文章</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/inside-mysql/mysql-transactions/" rel="bookmark">MySQL 事务</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/inside-mysql/mysql-locking/" rel="bookmark">MySQL 锁</a></div></li></ul><footer class="post-footer"><div class="post-tags"> <a href="/tags/MySQL/" rel="tag"># MySQL</a> <a href="/tags/inside-mysql/" rel="tag"># MySQL 技术内幕</a> <a href="/tags/index/" rel="tag"># index</a></div><div class="post-nav"><div class="post-nav-item"><a href="/notes/inside-mysql/mysql-locking/" rel="prev" title="MySQL 锁"><i class="fa fa-chevron-left"></i> MySQL 锁</a></div><div class="post-nav-item"> <a href="/programming/leetcode/subarray-sum-equals-k/" rel="next" title="560. Subarray Sum Equals k">560. Subarray Sum Equals k<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#b-树"><span class="nav-number">1.</span> <span class="nav-text">B+ 树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#b-树的插入操作"><span class="nav-number">1.1.</span> <span class="nav-text">B+ 树的插入操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#b-树的删除操作"><span class="nav-number">1.2.</span> <span class="nav-text">B+ 树的删除操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#b-树索引"><span class="nav-number">2.</span> <span class="nav-text">B+ 树索引</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#索引的分类"><span class="nav-number">2.1.</span> <span class="nav-text">索引的分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引的分裂"><span class="nav-number">2.2.</span> <span class="nav-text">索引的分裂</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引的管理"><span class="nav-number">2.3.</span> <span class="nav-text">索引的管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cardinality"><span class="nav-number">2.4.</span> <span class="nav-text">Cardinality</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#联合索引"><span class="nav-number">3.</span> <span class="nav-text">联合索引</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#覆盖索引"><span class="nav-number">4.</span> <span class="nav-text">覆盖索引</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#不使用索引的情况"><span class="nav-number">5.</span> <span class="nav-text">不使用索引的情况</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#索引提示"><span class="nav-number">6.</span> <span class="nav-text">索引提示</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#multi-range-read-优化"><span class="nav-number">7.</span> <span class="nav-text">Multi-Range Read 优化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#index-condition-pushdown-优化"><span class="nav-number">8.</span> <span class="nav-text">Index Condition Pushdown 优化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#哈希算法"><span class="nav-number">9.</span> <span class="nav-text">哈希算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#自适应哈希索引"><span class="nav-number">9.1.</span> <span class="nav-text">自适应哈希索引</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#全文检索"><span class="nav-number">10.</span> <span class="nav-text">全文检索</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#倒排索引"><span class="nav-number">10.1.</span> <span class="nav-text">倒排索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#innodb-全文检索"><span class="nav-number">10.2.</span> <span class="nav-text">InnoDB 全文检索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fts-document-id"><span class="nav-number">10.2.1.</span> <span class="nav-text">FTS Document ID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#例子"><span class="nav-number">10.2.2.</span> <span class="nav-text">例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stopword"><span class="nav-number">10.2.3.</span> <span class="nav-text">stopword</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#全文检索查询"><span class="nav-number">10.3.</span> <span class="nav-text">全文检索查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#natural-language-mode"><span class="nav-number">10.3.1.</span> <span class="nav-text">Natural Language Mode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#boolean-mode"><span class="nav-number">10.3.2.</span> <span class="nav-text">Boolean Mode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#query-expansion"><span class="nav-number">10.3.3.</span> <span class="nav-text">Query Expansion</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="菜农陈文生" src="/uploads/avatar/nekosensei.png"><p class="site-author-name" itemprop="name">菜农陈文生</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">206</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">11</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">161</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/cncws" title="GitHub → https://github.com/cncws" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a></span><span class="links-of-author-item"><a href="mailto:1031616423@qq.com" title="E-Mail → mailto:1031616423@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">菜农陈文生</span></div><script src="//cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="//cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script><script src="/js/aplayer-el.js"></script><script src="//unpkg.com/video.js/dist/video.min.js"></script><script src="/js/videojs-bilibili.js"></script><script src="/js/videojs-bilibili-el.js"></script></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script><script src="/js/local-search.js"></script><div id="pjax"><script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Axl15EIRi5o5AatKaxXxV4Oq-gzGzoHsz',
      appKey     : 'E0qm04UjsP0qQN1l8ME3GQ25',
      placeholder: "Just go go",
      avatar     : 'identicon',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script></div></body></html>