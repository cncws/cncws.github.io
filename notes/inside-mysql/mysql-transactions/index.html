<!DOCTYPE html><html lang="zh-CN,en,default"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/uploads/icon/drop/128x128.png"><link rel="icon" type="image/png" sizes="32x32" href="/uploads/icon/drop/32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/uploads/icon/drop/16x16.png"><link rel="mask-icon" href="/uploads/icon/drop/drop.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"cwscn.github.io",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1,width:240},copycode:{enable:!0,show_result:!0,style:"flat"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"manual"},fancybox:!1,mediumzoom:!0,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"fadeIn"}},path:"search.xml"}</script><meta name="description" content="理论上说，事务必须同时满足 ACID（原子性、一致性、隔离性、持久性） 四个特性，但是数据库厂商出于各种目的，并没有严格去满足。例如，对于 Oracle 数据库来说，其默认的隔离级别为 READ COMMITTED，不满足隔离性的要求。 对于 InnoDB 而言，其默认的隔离级别为 REPEATABLE READ，完全满足事务的 ACID 特性。 分类 从事务理论的角度来说，可以把事务分为以下几种"><meta name="keywords" content="MySQL,Inside MySQL,transaction"><meta property="og:type" content="article"><meta property="og:title" content="MySQL 事务"><meta property="og:url" content="https://cwscn.github.io/notes/inside-mysql/mysql-transactions/index.html"><meta property="og:site_name" content="水滴"><meta property="og:description" content="理论上说，事务必须同时满足 ACID（原子性、一致性、隔离性、持久性） 四个特性，但是数据库厂商出于各种目的，并没有严格去满足。例如，对于 Oracle 数据库来说，其默认的隔离级别为 READ COMMITTED，不满足隔离性的要求。 对于 InnoDB 而言，其默认的隔离级别为 REPEATABLE READ，完全满足事务的 ACID 特性。 分类 从事务理论的角度来说，可以把事务分为以下几种"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2020-07-26T09:10:09.164Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="MySQL 事务"><meta name="twitter:description" content="理论上说，事务必须同时满足 ACID（原子性、一致性、隔离性、持久性） 四个特性，但是数据库厂商出于各种目的，并没有严格去满足。例如，对于 Oracle 数据库来说，其默认的隔离级别为 READ COMMITTED，不满足隔离性的要求。 对于 InnoDB 而言，其默认的隔离级别为 REPEATABLE READ，完全满足事务的 ACID 特性。 分类 从事务理论的角度来说，可以把事务分为以下几种"><link rel="canonical" href="https://cwscn.github.io/notes/inside-mysql/mysql-transactions/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css"><link rel="stylesheet" href="//unpkg.com/video.js/dist/video-js.min.css"><link rel="stylesheet" href="/css/videojs-bilibili.css"><style>.aplayer.aplayer-arrow .aplayer-icon-loop,.aplayer.aplayer-arrow .aplayer-icon-order{display:inline-block}</style><title>MySQL 事务 | 水滴</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">水滴</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">愿你走出半生 归来仍是少年</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档<span class="badge">177</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类<span class="badge">11</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签<span class="badge">170</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i> 关于</a></li><li class="menu-item menu-item-收藏"><a href="/favlist/" rel="section"><i class="fa fa-star fa-fw"></i> 收藏</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div><meting-js server="netease" type="playlist" id="67155774" theme="#ff5555" loop="all" order="list" preload="none" volume="" mutex="" list-folded="NaN" fixed="true"></meting-js></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwscn.github.io/notes/inside-mysql/mysql-transactions/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar/nekosensei.png"><meta itemprop="name" content="菜农陈文生"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="水滴"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> MySQL 事务</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-07-26 17:10:09" itemprop="dateModified" datetime="2020-07-26T17:10:09+08:00">2020-07-26</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/notes/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/notes/inside-mysql/mysql-transactions/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/notes/inside-mysql/mysql-transactions/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><p>理论上说，事务必须同时满足 ACID（原子性、一致性、隔离性、持久性） 四个特性，但是数据库厂商出于各种目的，并没有严格去满足。例如，对于 Oracle 数据库来说，其默认的隔离级别为 READ COMMITTED，不满足隔离性的要求。</p><p>对于 InnoDB 而言，其默认的隔离级别为 REPEATABLE READ，完全满足事务的 ACID 特性。</p><h1 id="分类">分类</h1><p>从事务理论的角度来说，可以把事务分为以下几种类型：</p><ul><li><p>扁平事务（Flat Transactions）</p><p>扁平事务最为简单，但使用得最为频繁。要么全部提交，要么全部回滚，不能提交或回滚某一部分。</p></li><li><p>带有保存点的扁平事务（Flat Transactions with Savepoints）</p><p>某些事务中出现的错误不会导致所有操作都无效，放弃整个事务不合理，开销也太大。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">action 1</span><br><span class="line">savepoint a;</span><br><span class="line">action 2</span><br><span class="line">savepoint b;</span><br><span class="line">action 3</span><br><span class="line">rollback to a;  # 回滚至保存点 a，事务并未结束</span><br><span class="line">action 4</span><br><span class="line">commit;         # 提交 action 1、4。若是 rollback; 则回滚全部操作</span><br></pre></td></tr></table></figure></li><li><p>链事务（Chained Transactions）</p><p>链事务可视为保存点模式的一种变种。保存点是易失的（volatile），而非持久的（persistent）。当发生系统崩溃时，所有的保存点都将消失。这意味着当进行恢复时，事务需要从开始处重新执行，而不能从最近的一个保存点继续进行。</p><p>链事务的思想是：在提交一个事务时，释放不需要的数据对象，将必要的上下文隐式地传给下一个要开始的事务。注意，<strong>提交事务操作和开始下一个事务操作将合并为一个原子操作</strong>。</p></li><li><p>嵌套事务（Nested Transactions）</p><p>嵌套事务是一个层次结构框架。在 Moss 理论中，实际的工作交由叶子节点来完成，而高层的事务仅负责逻辑控制，决定何时调用相关的子事务。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">顶层事务     子事务           子事务</span><br><span class="line"></span><br><span class="line">begin;</span><br><span class="line">subtrx 1</span><br><span class="line">            begin;</span><br><span class="line">            subtrx 1.1</span><br><span class="line">                            begin;</span><br><span class="line">                            action</span><br><span class="line">                            commit;</span><br><span class="line">            commit;</span><br><span class="line">subtrx 2</span><br><span class="line">            begin</span><br><span class="line">            action</span><br><span class="line">            commit;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p>子事务既可以提交也可以回滚，<strong>但是它的提交操作并不马上生效，除非其父事务已经提交</strong>。任意一个事务的回滚会引起它的所有子事务一同回滚，故子事务保留 ACI 特性，不具有 D 的特性。</p><p>即使一个系统不支持嵌套事务，用户也可以通过保存点技术来模拟嵌套事务。</p><ul><li>在回滚时，采用保存点比嵌套具有更大的灵活性。</li><li>在锁的持有方面，嵌套查询中不同的子事务在数据库对象上持有的锁是不同的。用户可以选择哪些锁需要被子事务继承，哪些需要被父事务保留。</li></ul><p>然而，如果系统支持在嵌套事务中并行地执行各个子事务，采用保存点来模拟嵌套事务就不切实际了。</p></li><li><p>分布式事务（Distributed Transactions）</p><p>分布式事务通常是一个在分布式环境下运行的扁平事务，需要根据数据所在位置访问网络中不同的节点。例如在不同的银行之间转账。</p></li></ul><p>InnoDB 支持扁平事务、带有保存点的扁平事务、链事务、分布式事务。对于嵌套事务，其并不原生支持。</p><a id="more"></a><h1 id="事务的实现">事务的实现</h1><h2 id="redo">redo</h2><p>重做日志用来实现事务的持久性，其由两部分组成：一是内存中的重做日志缓冲（redo log buffer），是易失的；二是重做日志文件（redo log file），是持久的。</p><p>InnoDB 通过 Force Log at Commit 机制实现事务的持久性，当事务提交时，必须先将事务的所有日志写入到重做日志文件进行持久化，待事务的 COMMIT 操作完成才算完成。</p><p>为了确保每次日志都写入重做日志文件，在每次将重做日志缓冲写入重做日志文件（实际上写入的是文件系统缓存）后，InnoDB 都需要调用一次 fsync 操作，确保重做日志文件写入磁盘。fsync 的效率取决于磁盘的性能。</p><p>参数 innodb_flush_log_at_trx_commit 用来控制重做日志刷新到磁盘的策略。</p><table><colgroup><col style="width:14%"><col style="width:85%"></colgroup><thead><tr class="header"><th>取值</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>0</td><td>事务提交时不写入重做日志文件，该操作仅在 master thread 中完成，在 master thread 中每 1 秒会进行一次重做日志文件的 fsync 操作</td></tr><tr class="even"><td>1（默认值）</td><td>事务提交时必须调用一次 fsync</td></tr><tr class="odd"><td>2</td><td>事务提交时写入重做日志文件，但仅写入文件系统的缓存，不进行 fsync 操作。在这个设置下，当数据库发生宕机而操作系统不发生宕机时，并不会导致事务的丢失。</td></tr></tbody></table><h3 id="binlog">binlog</h3><p>在 MySQL 数据库中还有一种二进制日志（binlog），其用来进行 POINT-IN-TIME 的恢复及主从复制。binlog 与 redo log 有非常大的不同。</p><p>首先，<strong>重做日志是在 InnoDB 存储引擎层产生，而二进制日志是在 MySQL 数据库的上层产生的</strong>，并且二进制日志不仅仅针对于 InnoDB，任何存储引擎对于数据库的更改都会产生二进制日志。</p><p>其次，两种日志记录的内容形式不同。<strong>二进制日志是一种逻辑日志，记录的是对应的 SQL 语句。而重做日志是物理格式日志，记录的是对于每个页的修改</strong>。</p><p>此外，两种日志记录写入磁盘的时间点不同。<strong>二进制日志只在事务提交完成后进行一次写入，而重做日志在事务进行中不断地被写入</strong>，这表现为重做日志并不是随事务提交的顺序写入的。</p><h3 id="log-block">log block</h3><p>在 InnoDB 中，重做日志缓存、重做日志文件都是以块（大小为 512 字节）的方式进行存储的，称之为重做日志块（redo log block）。重做日志块的大小和磁盘扇区大小一样，写入可以保证原子性。</p><p>重做日志块由三部分组成，依次为日志块头（12 字节）、日志内容（492 字节）、日志块尾（8 字节）。</p><p>log block header 由 4 部分组成，</p><table><colgroup><col style="width:25%"><col style="width:12%"><col style="width:62%"></colgroup><thead><tr class="header"><th>字段</th><th>字节</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>LOG_BLOCK_HDR_NO</td><td>4</td><td>log buffer 是由 log block 组成，log buffer 好似一个数组，LOG_BLOCK_HDR_NO 用来标记这个数组中的位置。其是递增并且循环使用的，第 1 位是 flush bit，实际最大的值为 2G（2^31 bit）。</td></tr><tr class="even"><td>LOG_BLOCK_HDR_DATA_LEN</td><td>2</td><td>表示 log block 所占用的大小。当 log block 被写满时，该值为 512。</td></tr><tr class="odd"><td>LOG_BLOCK_FIRST_REC_GROUP</td><td>2</td><td>表示 log block 中第一个日志所在的偏移量。如果该值与 LOG_BLOCK_HDR_DATA_LEN 相同，则表示当前块中不包含新的日志。</td></tr><tr class="even"><td>LOG_BLOCK_CHECKPOINT_NO</td><td>4</td><td>表示该 log block 最后被写入时的检查点</td></tr></tbody></table><p>log block tailer 只由 1 个部分组成，LOG_BLOCK_TRL_NO，占用 4 个字节，且其值和 LOG_BLOCK_HDR_NO 相同。（尾部剩下 4 个字节是空的？）</p><p>在 InnoDB 运行过程中，log buffer 根据一定的规则将内存中的 log block 刷新到磁盘，这个规则具体是：</p><ul><li>事务提交时（可通过参数 innodb_flush_log_at_trx_commit 更改）</li><li>当 log buffer 中有一半的内存空间已经被使用时</li><li>log checkpoint 时</li></ul><p>log block 以追加的方式写入 redo log file，当一个 redo log file 被写满时，会接着写入下一个 redo log file。</p><p>redo log file 除了保存 log block，还保存一些其他的信息。第一个 redo log file 前 2KB 的部分保存以下 4 个 512 字节大小的块：log file header、checkpoint1、空、checkpoint2。其余的 redo log file 仅保留这些空间，不保存信息。追加新的 log block 时，还需要更新这部分信息。这些信息对于 InnoDB 的恢复操作来说至关重要。</p><p>checkpoint 保存检查点值，其设计是交替写入，目的是避免因介质失败导致无法找到可用的 checkpoint。</p><h3 id="重做日志格式">重做日志格式</h3><p>不同的操作有不同的重做日志格式，但是它们有着通用的头部格式，由以下 3 部分组成：</p><ul><li>redo_log_type ：重做日志类型</li><li>space ：表空间 ID</li><li>page_no ：页的偏移量</li></ul><h3 id="日志序列号">日志序列号</h3><p>日志序列号（Log Sequence Number，LSN）占用 8 字节，并且单调递增。其表示的含义有：</p><ul><li>重做日志写入的总量，单位是字节。例如当前重做日志的 LSN 为 1000，有一个事务写入了 100 字节的重做日志，那么 LSN 就变为了 1100。</li><li>checkpoint 的位置。</li><li>页的版本。LSN 不仅记录在重做日志中，还存在于每个页中。在每个页的头部，有一个值 FIL_PAGE_LSN，表示该页刷新时 LSN 的大小，该值用来判断页是否需要进行恢复操作。例如，页 P1 的 LSN 为 10000，而数据库启动时，InnoDB 检测到重做日志中的 LSN 为 13000，那么数据库需要进行恢复操作。</li></ul><p>通过命令 SHOW ENGINE INNODB STATUS 可以查看 LSN 的情况。Log sequence number 表示当前的 LSN，Log flushed up to 表示刷新到重做日志文件的 LSN，Last checkpoint at 表示刷新到磁盘的 LSN。</p><h3 id="恢复">恢复</h3><p>InnoDB 在启动时不管上次是否正常关闭，都会尝试进行恢复操作。重做日志记录的是物理日志，恢复的速度比逻辑日志，如二进制日志，要快很多。与此同时，InnoDB 也对恢复进行了一定程度的优化，如顺序读取及并行应用重做日志，进一步提高数据库恢复的速度。</p><p>checkpoint 表示已经刷新到磁盘的 LSN，因此在恢复过程中仅需恢复 checkpoint 开始的日志部分。</p><p>重做日志是物理日志，记录的是每个页上的变化。对于下面的表和 SQL 语句：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t (a <span class="built_in">int</span>, b <span class="built_in">int</span>, primary <span class="keyword">key</span>(a), <span class="keyword">key</span>(b));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">select</span> <span class="number">1</span>, <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>由于需要对聚集索引页和辅助索引页进行操作，其记录的重做日志大致为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">page(2,3), offset 32, value 1,2  # 聚集索引</span><br><span class="line">page(2,4), offset 64, avlue 2    # 辅助索引</span><br></pre></td></tr></table></figure><p>若插入涉及 B+ 树的 split，可能会有更多的页需要记录日志。此外，由于是物理日志，重做日志是幂等的。幂等的概念是 <code>f( f(x) ) = f(x)</code>。重复执行的结果不变。逻辑日志，如二进制日志，就不是幂等的。重复执行可能会插入（对于 INSERT）多条重复的记录。</p><h2 id="undo">undo</h2><p>事务有时还需要回滚，这时就需要 undo。因此在对数据库进行修改时，InnoDB 不但会产生 redo，还会产生一定量的 undo。当事务执行失败，或者用户用 ROLLBACK 请求回滚，就可以利用 undo 将数据回滚到修改前的样子。</p><p>与 redo 不同，undo 存放在数据库内部的一个特殊字段中，这个段成为 undo 段，undo 段位于共享表空间中。</p><p>undo 是逻辑日志，因此只是将数据库逻辑地恢复到原来的样子。InnoDB 回滚时，实际上做的是与先前相反的工作，对于每个 INSERT/DELETE，InnoDB 会完成一个 DELETE/INSERT；对于每个 UPDATE，InnoDB 会执行一个相反的 UPDATE，将修改前的行放回去。</p><p>除了回滚操作，undo 的另一个作用是 MVCC，MVCC 的实现是通过 undo 来完成。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过 undo 读取之前的行版本信息，以此实现非锁定读取。</p><p>最后也是最为重要的一点是，<strong>undo log 会产生 redo log</strong>。因为 undo log 也需要持久性的保护。</p><h3 id="undo-log-格式">undo log 格式</h3><p>InnoDB 中，undo log 分为 insert undo log 和 update undo log。</p><p>insert undo log 是指在 insert 操作中产生的 undo log。因为 insert 的记录，只对事务本身可见，故该 undo log 可以在事务提交后直接删除，不需要进行 purge 操作。</p><p>update undo log 记录的是对 delete 和 update 产生的 undo log。该 undo log 可能需要提供 MVCC 机制，因此不能在事务提交时就进行删除。提交时放入 undo log 链表，等待 purge 线程进行最后的删除。</p><h2 id="purge">purge</h2><p>purge 用于最终完成 delete 和 update 操作，这样设计的目的是支持 MVCC。</p><p>InnoDB 中有一个 histroy 列表，它根据事务提交的顺序，将 undo log 进行链接，先提交的事务在尾端。</p><p>为节省空间，一个页上允许多个事务的 undo log 存在。若按照列表中的顺序依次清理 undo log，需要做随机读（不同事务的 undo log 可能在不同页上），降低了 purge 的效率。</p><p>因此 purge 清理 undo log 的操作是：InnoDB 先从列表中找到第一个可以被清理的记录（尾部记录），清理之后在其所在的页中继续寻找是否存在可以被清理的记录。若页中其他记录被全部清理，则该 undo page 可以被重用。若有记录被其他事务所引用而不能被清理，则去 history list 中重新寻找可被清理的记录。</p><table><colgroup><col style="width:25%"><col style="width:75%"></colgroup><thead><tr class="header"><th>全局动态参数（默认值）</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>innodb_purge_batch_size (300)</td><td>每次 purge 操作需要清理的 undo page 数量。</td></tr><tr class="even"><td>innodb_max_purge_lag (0)</td><td>控制 history list 的长度。当 InnoDB 存储引擎的压力非常大时，并不能高效地进行 purge 操作，那么 history list 会越来越长。若长度大于该参数，InnoDB 会延缓 DML 的操作。默认值为 0 表示不对 history list 做任何限制。</td></tr><tr class="odd"><td>innodb_max_purge_lag_delay (0)</td><td>控制延缓的最大毫秒数。避免由于 purge 操作缓慢导致其他 SQL 线程出现无限制的等待。</td></tr></tbody></table><h3 id="group-commit">group commit</h3><p>对于 InnoDB 来说，事务提交时会进行两个阶段的操作：</p><ol type="1"><li>修改内存中事务对应的信息，并且将日志写入重做日志缓冲。</li><li>调用 fsync 确保日志写入磁盘。</li></ol><p>当有事务进行步骤 2 时，其他事务可以进行步骤 1 的操作。完成提交操作后，再次进行步骤 2 时，可以将多个事务的重做日志通过一次 fsync 刷新到磁盘，这样就大大地减少了磁盘的压力，从而提高了数据库的整体性能。对于更新较为频繁的操作，group commit 的效果尤为明显。（看不懂，没有例子）</p><p>然而在 InnoDB 1.2 版本之前，在开启二进制日志后，group commit 功能会失效，导致性能的下降。在线环境多使用 replication，因此二进制日志的选项基本都为开启状态，因此这个问题尤为显著。</p><p>导致这个问题的原因是在开启二进制日志后，为了保证存储引擎层中的事务和二进制日志的一致性，二者之间使用了两阶段事务，步骤如下：</p><ol type="1"><li>当事务提交时 InnoDB 进行 prepare 操作。</li><li>MySQL 数据库上层写入二进制文件。</li><li>InnoDB 存储引擎层将日志写入重做日志文件。<ol type="1"><li>修改内存中事务对应的信息，并且将日志写入重做日志缓冲。</li><li>调用 fsync 确保日志写入磁盘。</li></ol></li></ol><p>一旦步骤 2 中的操作完成，就确保了事务的提交（即使在步骤 3 时数据库发生了宕机）。此外，步骤 2、3 都需要一次 fsync 操作，保证上下两层数据的一致性。步骤 2 的 fsync 由参数 sync_binlog 控制，步骤 3 的 fsync 由 innodb_flush_log_at_trx_commit 控制。</p><p>为了保证 MySQL 数据库上层二进制日志的写入顺序和 InnoDB 层的事务提交顺序一致，MySQL 数据库内部使用了 prepare_commit_mutex 这个锁。在启用这个锁之后，步骤 3.1 不可以在其他事务执行步骤 3.2 时进行，从而导致了 group commit 失效。</p><p>MySQL 5.6 采用 Binary Log Group Commit（BLGC）解决这一问题。不但 MySQL 数据库上层的二进制日志写入是 group commit 的，InnoDB 存储引擎层也是 group commit 的。此外，还移除了原先的 prepare_commit_mutex 锁。</p><p>在 MySQL 数据库上层进行提交时，首先按顺序将其放入一个队列中，队列中的第一个事务称为 leader，其他事务称为 follower，leader 控制着 follower 的行为。BLGC 的步骤为：</p><ol type="1"><li>Flush 阶段，将每个事务的二进制日志写入文件。</li><li>Sync 阶段，将内存中的二进制日志刷新到磁盘，若队列中有多个事务，那么仅一次 fsync 操作就完成了二进制日志的写入，这就是 BLGC。</li><li>Commit 阶段，leader 根据顺序调用存储引擎层事务的提交，InnoDB 本身就支持 group commit，因此修复了原先由于 prepare_commit_mutex 锁导致 group commit 失效的问题。</li></ol><p>当有一组事务在进行 Commit 阶段时，其他事务可以进行 Flush 阶段，从而使 group commit 不断生效。当然 group commit 的效果由队列中事务的数量决定，当提交的事务越多时，group commit 的效果越明显，数据库性能的提升也就越大。</p><p>参数 binlog_max_flush_queue_time 用来控制 Flush 阶段中等待的时间，即使之前的一组事务完成提交，当前的一组事务也不马上进入 Sync 阶段，而是至少等待一段时间。这样做的好处是 group commit 的事务数量更多，然而这也可能会导致事务的响应时间变慢。该参数的默认值为 0，且推荐设置依然为 0。</p><h1 id="事务控制语句">事务控制语句</h1><table><thead><tr class="header"><th>语句</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>start transaction | begin</code></td><td>显式地开启一个事务</td></tr><tr class="even"><td><code>commit [work]</code></td><td>提交事务</td></tr><tr class="odd"><td><code>rollback [work]</code></td><td>回滚事务</td></tr><tr class="even"><td><code>savepoint p</code></td><td>创建一个保存点</td></tr><tr class="odd"><td><code>release savepoint p</code></td><td>删除一个保存点，当没有 <code>p</code> 这个保存点时，会抛出一个异常</td></tr><tr class="even"><td><code>rollback to p</code></td><td>回滚到保存点，当没有 <code>p</code> 这个保存点时，会抛出一个异常</td></tr><tr class="odd"><td><code>set transaction</code></td><td>设置事务的隔离级别</td></tr></tbody></table><p>start transaction 和 begin 都可以在命令行下显式地开启一个事务。但是在存储过程中，分析器会将 begin 识别为 begin...end，因此在存储过程中只能使用 start transaction 来开启一个事务。</p><p>commit 和 commit work 基本是一致的。不同之处在于 commit work 用来控制事务结束后的行为。用户可以通过参数 completion_type 控制。</p><table><thead><tr class="header"><th>取值</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>0（默认值）</td><td>没有任何操作，此时 commit 和 commit work 是完全等价的</td></tr><tr class="even"><td>1</td><td>马上自动开启一个相同隔离级别的事务，等同于 commit and chain（链事务）</td></tr><tr class="odd"><td>2</td><td>提交后自动断开与服务器的连接</td></tr></tbody></table><p>rollback 和 rollback work 与 commit 和 commit work 的工作方式一样。</p><h1 id="隐式提交的-sql-语句">隐式提交的 SQL 语句</h1><p>以下这些 SQL 语句会产生一个隐式的提交操作，即执行完成后，会有一个隐式的 COMMIT，因此这些操作无法被回滚。</p><ul><li>DDL 语句：ALTER ..., CREATE ..., DROP ..., RENAME TABLE, TRUNCATE TABLE 等等</li><li>用来隐式地修改 MySQL 架构的操作：CREATE USER, DROP USER, RENAME USER, GRANT, REVOKE, SET PASSWORD。</li><li>管理语句：ANALYZE TABLE, CACHE INDEX, CHECK TABLE, LOAD INDEX INTO CACHE, OPTIMIZE TABLE, REPAIR TABL。</li></ul><p>TRUNCATE TABLE 语句是 DLL，虽然和对整张表执行 DELETE 的结果一样，但它是不能回滚的。</p><h1 id="对于事务操作的统计">对于事务操作的统计</h1><p>计算每秒事务处理的能力（Transaction Per Second，TPS）的方法是：<code>(com_commit + com_rollback) / time</code>。但是利用这种方法进行计算的前提是：所有的事务必须是显示提交的，如果存在隐式提交地事务和回滚，不会计算到 com_commit 和 com_rollback 全局变量中。</p><h1 id="事务的隔离级别">事务的隔离级别</h1><p>InnoDB 的默认隔离级别是 REPEATABLE READ，但与标准 SQL 不同的是，使用 Next-Key Lock 算法，避免幻读的产生。</p><p>InnoDB 在 REPEATABLE READ 隔离级别下就可以达到 SERIALIABLE 的隔离，因此一般不在本地事务中使用 SERIALIABLE 的隔离级别。SERIALIABLE 隔离级别主要用于分布式事务。</p><h1 id="分布式事务">分布式事务</h1><p>InnoDB 通过 XA 事务来支持分布式事务的实现。分布式事务指的是允许多个独立的事务资源参与到一个全局的事务中。使用分布式事务时，InnoDB 的事务隔离级别必须设置为 SERIALIABLE。</p><p>分布式事务可能在银行系统的转账中比较常见。通常来说，都是通过编程语言来完成分布式事务的操作的。</p><p>MySQL 数据库中存在一种分布式事务，在存储引擎与插件之间，又或者在存储引擎与存储引擎之间，称之为内部 XA 事务。最为常见的内部 XA 事务存在于 binlog 与 InnoDB 之间。在事务提交事务，先写二进制日志，再写 InnoDB 的重做日志。二进制日志和重做日志必须同时写入，若二进制日志先写了，而在写入重做日志时发生了宕机，那么 slave 可能会接收到 master 传过去的二进制日志并执行，最终导致主从不一致的情况。</p><h1 id="不好的事务习惯">不好的事务习惯</h1><ul><li>在循环中提交，不论是显式的还是隐式的提交。</li><li>使用自动提交。</li><li>使用自动回滚，例如在一个存储过程中 <code>declare exit handler for sqlexception rollback;</code>。</li></ul><h1 id="长事务">长事务</h1><p>长事务（Long-Lived Transaction）就是执行时间长的事务。对于长事务的问题，有时可以通过转化为小批量的事务来解决。</p></div><div class="popular-posts-header">相关文章</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/inside-mysql/mysql-indexes/" rel="bookmark">MySQL 索引</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/inside-mysql/mysql-locking/" rel="bookmark">MySQL 锁</a></div></li></ul><footer class="post-footer"><div class="post-tags"> <a href="/tags/MySQL/" rel="tag"># MySQL</a> <a href="/tags/Inside-MySQL/" rel="tag"># Inside MySQL</a> <a href="/tags/transaction/" rel="tag"># transaction</a></div><div class="post-nav"><div class="post-nav-item"><a href="/programming/leetcode/longest-consecutive-sequence/" rel="prev" title="128. Longest Consecutive Sequence"><i class="fa fa-chevron-left"></i> 128. Longest Consecutive Sequence</a></div><div class="post-nav-item"> <a href="/programming/leetcode/find-peak-element/" rel="next" title="162. Find Peak Element">162. Find Peak Element<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#分类"><span class="nav-number">1.</span> <span class="nav-text">分类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#事务的实现"><span class="nav-number">2.</span> <span class="nav-text">事务的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#redo"><span class="nav-number">2.1.</span> <span class="nav-text">redo</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#binlog"><span class="nav-number">2.1.1.</span> <span class="nav-text">binlog</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#log-block"><span class="nav-number">2.1.2.</span> <span class="nav-text">log block</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重做日志格式"><span class="nav-number">2.1.3.</span> <span class="nav-text">重做日志格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#日志序列号"><span class="nav-number">2.1.4.</span> <span class="nav-text">日志序列号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#恢复"><span class="nav-number">2.1.5.</span> <span class="nav-text">恢复</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undo"><span class="nav-number">2.2.</span> <span class="nav-text">undo</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undo-log-格式"><span class="nav-number">2.2.1.</span> <span class="nav-text">undo log 格式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#purge"><span class="nav-number">2.3.</span> <span class="nav-text">purge</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#group-commit"><span class="nav-number">2.3.1.</span> <span class="nav-text">group commit</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#事务控制语句"><span class="nav-number">3.</span> <span class="nav-text">事务控制语句</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#隐式提交的-sql-语句"><span class="nav-number">4.</span> <span class="nav-text">隐式提交的 SQL 语句</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#对于事务操作的统计"><span class="nav-number">5.</span> <span class="nav-text">对于事务操作的统计</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#事务的隔离级别"><span class="nav-number">6.</span> <span class="nav-text">事务的隔离级别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#分布式事务"><span class="nav-number">7.</span> <span class="nav-text">分布式事务</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#不好的事务习惯"><span class="nav-number">8.</span> <span class="nav-text">不好的事务习惯</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#长事务"><span class="nav-number">9.</span> <span class="nav-text">长事务</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="菜农陈文生" src="/uploads/avatar/nekosensei.png"><p class="site-author-name" itemprop="name">菜农陈文生</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">177</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">11</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">170</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/cncws" title="GitHub → https://github.com/cncws" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a></span><span class="links-of-author-item"><a href="mailto:1031616423@qq.com" title="E-Mail → mailto:1031616423@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">菜农陈文生</span></div><script src="//cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="//cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script><script src="/js/aplayer-el.js"></script><script src="//unpkg.com/video.js/dist/video.min.js"></script><script src="/js/videojs-bilibili.js"></script><script src="/js/videojs-bilibili-el.js"></script></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script><script src="/js/local-search.js"></script><div id="pjax"><script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Axl15EIRi5o5AatKaxXxV4Oq-gzGzoHsz',
      appKey     : 'E0qm04UjsP0qQN1l8ME3GQ25',
      placeholder: "Just go go",
      avatar     : 'identicon',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script></div></body></html>