<!DOCTYPE html><html lang="zh-CN,en,default"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/uploads/icon/drop/128x128.png"><link rel="icon" type="image/png" sizes="32x32" href="/uploads/icon/drop/32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/uploads/icon/drop/16x16.png"><link rel="mask-icon" href="/uploads/icon/drop/drop.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"cwscn.github.io",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1,width:240},copycode:{enable:!0,show_result:!0,style:"flat"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"manual"},fancybox:!1,mediumzoom:!0,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"fadeIn"}},path:"search.xml"}</script><meta name="description" content="只有主机的协议栈才有运输层，而路由器在转发分组时都只用到下三层（物理层、数据链路层和网络层）的功能。 从运输层的角度来看，通信的真正端点并不是主机而是主机中的进程。IP 协议虽然能把分组送到目的主机，但是这个分组没有交付主机中的应用进程。这表明，运输层有一个很重要的功能——复用（multiplexing）和分用（demultiplexing）。复用是指在发送方不同的应用进程都可以使用同一个运输层协"><meta name="keywords" content="Computer Networking,TCP,UDP,flow control,congestion control"><meta property="og:type" content="article"><meta property="og:title" content="运输层"><meta property="og:url" content="https://cwscn.github.io/notes/computer-networking/transport-layer/index.html"><meta property="og:site_name" content="水滴"><meta property="og:description" content="只有主机的协议栈才有运输层，而路由器在转发分组时都只用到下三层（物理层、数据链路层和网络层）的功能。 从运输层的角度来看，通信的真正端点并不是主机而是主机中的进程。IP 协议虽然能把分组送到目的主机，但是这个分组没有交付主机中的应用进程。这表明，运输层有一个很重要的功能——复用（multiplexing）和分用（demultiplexing）。复用是指在发送方不同的应用进程都可以使用同一个运输层协"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://cwscn.github.io/uploads/image/computer-networking/tcp-header.jpeg"><meta property="og:image" content="https://cwscn.github.io/uploads/image/computer-networking/three-way-handshake.jpg"><meta property="og:image" content="https://cwscn.github.io/uploads/image/computer-networking/four-way-handshake.jpg"><meta property="og:updated_time" content="2020-07-12T08:01:48.240Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="运输层"><meta name="twitter:description" content="只有主机的协议栈才有运输层，而路由器在转发分组时都只用到下三层（物理层、数据链路层和网络层）的功能。 从运输层的角度来看，通信的真正端点并不是主机而是主机中的进程。IP 协议虽然能把分组送到目的主机，但是这个分组没有交付主机中的应用进程。这表明，运输层有一个很重要的功能——复用（multiplexing）和分用（demultiplexing）。复用是指在发送方不同的应用进程都可以使用同一个运输层协"><meta name="twitter:image" content="https://cwscn.github.io/uploads/image/computer-networking/tcp-header.jpeg"><link rel="canonical" href="https://cwscn.github.io/notes/computer-networking/transport-layer/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css"><link rel="stylesheet" href="//unpkg.com/video.js/dist/video-js.min.css"><link rel="stylesheet" href="/css/videojs-bilibili.css"><style>.aplayer.aplayer-arrow .aplayer-icon-loop,.aplayer.aplayer-arrow .aplayer-icon-order{display:inline-block}</style><title>运输层 | 水滴</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="水滴" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">水滴</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">愿你走出半生 归来仍是少年</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档<span class="badge">155</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类<span class="badge">11</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签<span class="badge">161</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i> 关于</a></li><li class="menu-item menu-item-收藏"><a href="/favlist/" rel="section"><i class="fa fa-star fa-fw"></i> 收藏</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div><meting-js server="netease" type="playlist" id="67155774" theme="#ff5555" loop="all" order="list" preload="none" volume="" mutex="" list-folded="NaN" fixed="true"></meting-js></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwscn.github.io/notes/computer-networking/transport-layer/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar/nekosensei.png"><meta itemprop="name" content="菜农陈文生"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="水滴"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 运输层</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-07-12 16:01:48" itemprop="dateModified" datetime="2020-07-12T16:01:48+08:00">2020-07-12</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/notes/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/notes/computer-networking/transport-layer/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/notes/computer-networking/transport-layer/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><p>只有主机的协议栈才有运输层，而路由器在转发分组时都只用到下三层（物理层、数据链路层和网络层）的功能。</p><p>从运输层的角度来看，通信的真正端点并不是主机而是主机中的进程。IP 协议虽然能把分组送到目的主机，但是这个分组没有交付主机中的应用进程。这表明，运输层有一个很重要的功能——<strong>复用</strong>（multiplexing）和<strong>分用</strong>（demultiplexing）。复用是指在发送方不同的应用进程都可以使用同一个运输层协议传送数据（当然需要加上适当的首部），而分用是指接收方的运输层在剥去报文的首部后能够把这些数据正确交付目的应用进程。</p><p>网络层为主机之间提供逻辑通信，而运输层<strong>为应用进程之间提供端到端的逻辑通信</strong>。</p><p>运输层还要对收到的报文进行<strong>差错检测</strong>。在网络层，IP 数据报首部中的检验和字段，只检验首部而不检查数据部分。</p><p>当运输层采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条全双工的可靠信道。但当采用无连接的 UDP 协议时，这种逻辑通信信道仍然是一条不可靠信道。</p><p>两个计算机中的进程要相互通信，不仅必须知道对方的 IP 地址（为了找到对方的计算机），而且还要知道对方的端口号（为了找到对方计算机中的应用进程）。TCP/IP 的运输层使用一个 16 位（可允许有 65535 个不同的端口，这个数目对一个计算机来说是足够用的）端口号来标志一个端口。</p><p>端口号分为下面两大类：</p><ul><li>服务器段使用的端口号<ul><li>孰知端口号，0～1023。这些端口号被指派给了 TCP/IP 最重要的一些应用程序。</li><li>登记端口号，1024～49151。使用这类端口号必须按照规定的手续登记，以防止重复。</li></ul></li><li>客户端使用的端口号，49152～65535。这类端口号尽在客户进程运行时才动态选择，因此又叫做短暂端口号。</li></ul><table><thead><tr class="header"><th>应用程序</th><th>FTP</th><th>TELNET</th><th>SMTP</th><th>DNS</th><th>TFTP</th><th>HTTP</th><th>HTTPS</th></tr></thead><tbody><tr class="odd"><td>孰知端口号</td><td>21</td><td>23</td><td>25</td><td>53</td><td>69</td><td>80</td><td>443</td></tr></tbody></table><p>运输层的两个主要协议：</p><ul><li>用户数据报协议 UDP（User Datagram Protocol）<ul><li>面向连接，可靠</li><li>一对一、全双工的，不提供广播或多播服务</li><li>面向字节流，根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少字节</li><li>流量控制，拥塞控制</li></ul></li><li>传输控制协议 TCP（Transmission Control Protocol）<ul><li>无连接的，不可靠，尽最大努力交付</li><li>支持一对一、一对多、多对一、多对多的交互通信</li><li>面向报文，对应用层交下来的报文，既不合并，也不拆分</li><li>没有拥塞控制</li><li>首部开销小，只有 8 个字节，有 4 个字段，每个字段的长度都是两个字节<ol type="1"><li>源端口，在需要对方回信时选用。不需要时可全为 0。</li><li>目的端口，若端口号不正确，就丢弃该报文，并由网际控制报文协议 ICMP 发送“端口不可达”差错报文给发送方。</li><li>长度，最小值是 8（仅有首部字段，没有数据字段）</li><li>检验和，检测数据报在传输中是否有错。有错就丢弃。</li></ol></li></ul></li></ul><a id="more"></a><h1 id="tcp-报文段">TCP 报文段</h1><p><img src="/uploads/image/computer-networking/tcp-header.jpeg"></p><ul><li>源端口和目的端口，各占 2 个字节，与 UDP 的分用类似，TCP 的分用功能也是通过端口实现的。</li><li>序号和确认号，各占 4 个字节。TCP 是面向字节流的，传送的字节流中的每一个字节都按顺序编号。序号是本报文段所发送的数据的第一个字节的序号；确认号是期望收到对方下一个报文段的第一个数据字节的序号。</li><li>数据偏移，占 4 位，数据起始距离报文段起始的偏移，因此也是报文段的首部长度。但应注意，数据偏移的单位是 32 位（即 4 字节）。由于 4 位二进制数能够表示的最大十进制数字是 15，因此数据偏移的最大值是 60 字节，这也是 TCP 首部的最大长度（即选项长度不能超过 40 字节）。</li><li>6 个控制位：紧急 URG，<strong>确认 ACK</strong>，推送 PSH，复位 RST，<strong>同步 SYN</strong>，<strong>终止 FIN</strong>。<strong>只有在 ACK = 1 时确认号字段才有意义</strong>。</li><li>窗口，占 2 个字节，指出现在允许对方发送的数据量（因为接收方的数据缓存空间是有限的）。窗口值经常在动态地变化着。</li><li>检验和，占 2 个字节。检验的范围包括<strong>首部和数据</strong>两部分。</li><li>选项，长度可变，最长 40 个字节。TCP 最初只规定了一种选项，即<strong>最大报文段长度</strong> MSS（Maximum Segment Size）。MSS 是<strong>数据字段的最大长度</strong>，不包括首部。随着互联网的发展，又陆续增加了几个选项，如<strong>窗口扩大</strong>选项、<strong>时间戳</strong>选项、<strong>选择确认（SACK）</strong>。</li></ul><p>为什么要规定一个最大报文段长度 MSS？</p><p>TCP 报文段的数据部分，至少要加上 40 字节（TCP 首部 20 字节和 IP首部 20 字节），才能组装成一个 IP 数据报。<strong>若选择较小的 MSS 值，网络的利用率就降低</strong>。反过来，若 MSS 非常大，那么在 IP 层传输时就有可能要分解成多个短数据报片。在终点要把收到的各个短数据报片装配成原来的 TCP 报文段。当传输出错时还要进行重传。这些也都会使开销增大。最佳的 MSS 是很难确定的。在连接建立的过程中，双方都把自己能够支持的 MSS 写入，两个传送方向可以有不同的 MSS 值。若主机未填写这一项，则 MSS 的默认值是 536 字节。</p><h1 id="可靠传输">可靠传输</h1><h2 id="滑动窗口">滑动窗口</h2><p>全双工通信的双方既是发送方也是接收方。因此，每一方都有自己的发送窗口和接收窗口。</p><p>TCP 的滑动窗口是以字节为单位的。</p><p>发送方的发送窗口大小不能超过接收方的接收窗口；发送窗口大小还要受到当时网络拥塞程度的制约。</p><p>发送窗口包含：</p><ol type="1"><li>已发送但未收到确认的数据</li><li>允许发送但尚未发送的数据</li></ol><p>接收窗口包含：</p><ol type="1"><li>未按序收到的数据（按序收到数据时窗口会向前滑动，因此按序收到的数据不会在接收窗口内）</li><li>允许接收的数据</li></ol><p>发送缓存包含：</p><ol type="1"><li>已发送但尚未收到确认的数据</li><li>准备发送的数据（可能位于发送窗口内，也可能不在窗口内）</li></ol><p>接收缓存包含：</p><ol type="1"><li>未按序收到的数据</li><li>按序到达，但尚未被接收应用程序读取的数据（位于接收窗口左侧）</li></ol><p>窗口通常只是缓存的一部分。</p><ul><li>虽然发送窗口是根据接收窗口设置的，但在同一时刻，它们并不总是一样大。这是因为通过网络传送窗口值需要经历一定的时间滞后，另外，发送方还可能根据拥塞情况适当减小自己的发送窗口大小。</li><li>对于不按序到达的数据应如何处理，TCP 标准并无明确规定。如果一律丢弃，那么接收窗口的管理将会比较简单，但对网络资源的利用不利。因此通常是先临时存放在接收窗口内，等缺少的字节收到后，再按序交付上层的应用进程。</li><li>TCP 要求接收方必须有<strong>累积确认</strong>的功能，这样可以减小传输开销。接收方可以在<strong>合适的时候</strong>发送确认，也可以在发送数据时<strong>捎带</strong>确认信息。但请注意两点。一是接收方不应过分推迟发送确认，否则会导致发送方不必要的重传，反而浪费了网络的资源。<strong>TCP 标准规定，确认推迟的时间不应超过 0.5 秒。若收到一连串具有最大长度的报文段，则必须每隔一个报文段就发送一个确认</strong>。二是捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。</li></ul><h2 id="超时重传时间">超时重传时间</h2><p>超时重传时间太短，就会引起很多不必要的重传，使网络负荷增大。太长，则又使网络的空闲时间增大，降低了传输效率。TCP 采用了一种<strong>自适应算法</strong>。</p><p>TCP 保留了 RTT 的一个加权平均往返时间 <span class="math inline">\(RTT_S\)</span>（S 表示 Smoothed）。</p><p><span class="math display">\[RTT_S^n=(1-\alpha)*RTT_S^{n-1}+\alpha*RTT^n\quad(0\le\alpha&lt;1)\]</span></p><p><span class="math inline">\(\alpha\)</span> 接近于 0，则新的 RTT 样本影响不大，<span class="math inline">\(RTT_S\)</span> 值更新较慢。推荐的 <span class="math inline">\(\alpha\)</span> 值为 1/8，即 0.125。</p><p><strong>超时重传时间</strong> RTO（Retransmission Time-Out）应略大于 <span class="math inline">\(RTT_S\)</span>，建议的公式为：</p><p><span class="math display">\[RTO=RTT_S+4*RTT_D\]</span></p><p><span class="math inline">\(RTT_D\)</span> 是 RTT 的偏差的加权平均值。<span class="math inline">\(\beta\)</span> 的推荐值是 1/4，即 0.25。</p><p><span class="math display">\[RTT_D^n=\begin{cases}0.5*RTT^1,\quad n=1\\ (1-\beta)*RTT_D^{n-1}+\beta*|RTT_S^n-RTT^n|,\quad n&gt;1\end{cases}\]</span></p><p>往返时间的测量实现起来相当复杂。试想，发送一个报文段，重传时间到了还没有收到确认，于是重传报文段。经过一段时间后，收到了确认报文段。现在的问题是：此报文段是对先发送的报文段的确认，还是对重传的报文段的确认？正确的判断对确定 <span class="math inline">\(RTT_S\)</span> 的值关系很大。</p><p>Karn 提出一个算法，只要报文段重传了，就不采用其往返时间成本。但这样，网络时延突然增大时，超时重传时间就无法更新。较为合理的策略是：<strong>报文段每重传一次，就把超时重传时间增大一些（典型做法是翻倍）。当不再发生重传时，才根据上面的公式计算超时重传时间</strong>。</p><h2 id="选择确认-sack">选择确认 SACK</h2><p>若收到的报文段无差错，只是未按序号，选择确认（Selective ACK）设法让发送方只传送缺少的数据而不重传已经正确到达接收方的数据。</p><p>接收到的数据字节流的序号不连续，就会形成一些不连续的字节块。接收方要把这些信息（字节块的边界）准确地告诉发送方，使发送方不要再重复发送这些数据。</p><p>如果要使用选择确认，那么在建立 TCP 连接时，就要在 TCP 首部的选项中加上“允许 SACK”选项，而双方必须都事先商定好。选项中只能报告最多 4 个字节块的边界信息。一个边界信息占 4 字节，共 8 个边界。此外，还需要 1 个字节指明是 SACK 选项和 1 字节指明这个选项要占用多少字节。总共 34 字节。TCP 首部选项的长度最多只有 40 字节。</p><h1 id="流量控制">流量控制</h1><h2 id="利用滑动窗口">利用滑动窗口</h2><p>TCP 通过让发送方维护一个称为接收窗口的变量 rwnd（receive window）来提供流量控制（flow control）。rwnd 用于给发送方（S）一个指示——接收方（R）还有多少可用的缓存空间。</p><p>S 通过将未确认的数据量控制在 rwnd 以内，就可以保证 R 的接收缓存不会溢出。现在有一个小小的问题，假设 R 的接收缓存已满，使得 rwnd = 0。R 在将 rwmd = 0 通告给 S 之后，还要假设 R 没有任何数据要发给 S。一段时间后，R 上的应用进程将缓存清空，但 TCP 仅在 R 有数据或者有确认要发时才会发送报文段给 S，这样，S 不可能知道 R 的接收缓存已经有新的空间了。</p><p>为了解决这个问题，TCP 规范要求：当 S 收到 R 的零窗口通知，就启动计时器。若计时器设置的时间到期，就发送一个零窗口<strong>探测报文段</strong>（只有一个字节数据的报文段），R 在确认这个报文段时给出新的 rwnd。</p><p>TCP 规定，即使设置为零窗口，也必须接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段。</p><h2 id="传输效率">传输效率</h2><p>应用进程把数据传送到 TCP 的发送缓存后，剩下的发送任务就由 TCP 来控制了。可以用不同的机制来控制 TCP 报文段的发送时机。 第一种机制，缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送。第二种机制，由应用进程指明要求发送报文段，即 TCP 支持的<strong>推送</strong>（push）操作。第三种机制，维持一个定时器，期限到了，就把当前已有的缓存数据装入报文段（但长度不能超过 MSS）发送出去。</p><p>在 TCP 的实现中广泛使用 Nagle 算法。算法如下：若发送应用进程要把数据<strong>逐个字节地发送到 TCP 的发送缓存</strong>（比如，一个交互式用户使用一条 TELNET 连接），则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。当发送方收到对第一个数据字节的确认后，再把发送缓存中的所有数据组装成一个报文段发送出去，同时继续对后续到达的数据进行缓存。只有在收到对前一个报文段的确认后才继续发送下一个报文段。Nagle 算法还规定，当到达的数据已达到发送窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段。当数据到达较快而网络速率较慢时，用这样的方法可以明显地减少所用的网络带宽。</p><p>试想另一种情况：接收方的缓存已满，而交互式的<strong>应用进程一次只从接收缓存读取一个字节</strong>，然后向发送方发送确认，并把窗口设置为 1 个字节。接着，发送方又发来 1 个字节的数据（注意，IP 数据报是 41 字节）。这样进行下去，使网络的效率很低。要解决这个问题，可以让接收方等待一段时间，使得接收缓存已有足够空间容纳一个最长的报文段，或者等到接收缓存已有一半空闲的空间，再发出确认报文并通知当前的窗口大小。接收方应 <strong>1. 适当推迟发回确认报文。 2. 尽量使用捎带确认。</strong></p><p>上述两种方法可配合使用。</p><h1 id="拥塞控制">拥塞控制</h1><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫做<strong>拥塞</strong>（congestion）。</p><p>拥塞常常趋于恶化。如果一个路由器没有足够的缓存空间，它就会丢弃一些新到的分组。但当分组被丢弃时，发送这一分组的源点就会重传这一分组，甚至可能还要重传多次。这样会引起更多的分组流入网络和被网络中的路由器丢弃。可见<strong>拥塞引起的重传并不会缓解拥塞，反而会加剧拥塞</strong>。</p><p>拥塞控制与流量控制的关系密切，但存在一些差别。拥塞控制就是<strong>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载</strong>。拥塞控制是一个<strong>全局性的过程</strong>，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制是指<strong>点对点通信量的控制</strong>，是个<strong>端到端</strong>的问题。流量控制要做的是抑制发送端发送数据的速率，以便使接收端来得及接收。</p><p>拥塞控制是很难设计的，因为它是一个动态的问题。分组的丢失是网络发生拥塞的征兆而不是原因。在许多情况下，甚至正是拥塞控制机制本身成为引起网络性能恶化甚至发生死锁（网络吞吐量下降到零，无法工作）的原因。</p><p>从大的方面看，拥塞控制可以分为<strong>开环控制和闭环控制</strong>两种方法。开环控制就是在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。但一旦整个系统运行起来，就不再中途进行改正了。闭环控制是基于<strong>反馈环路</strong>的概念，主要有以下几种措施：</p><ol type="1"><li>检测网络系统以便检测到拥塞在何处、何时发生。</li><li>把拥塞发生的信息传送到可采取行动的地方。</li><li>调整网络系统的运行以解决出现的问题。</li></ol><h2 id="tcp-的拥塞控制方法">TCP 的拥塞控制方法</h2><p>下面讨论的拥塞控制也叫做<strong>基于窗口</strong>的拥塞控制。发送方维持一个叫做<strong>拥塞窗口</strong> cwnd（congestion window）的状态变量，大小取决于网络的拥塞程度，并且动态地在变化。<strong>实际上 TCP 是用字节数作为窗口大小的单位</strong>。但为叙述方便起见，下面用报文段的个数作为窗口大小的单位。</p><p>TCP 进行拥塞控制的算法有四种，即<strong>慢开始</strong>（slow-start）、<strong>拥塞避免</strong>（congestion avoidance）、<strong>快重传</strong>（fast retransmit）和<strong>快恢复</strong>（fast recovery）。</p><h2 id="慢开始">慢开始</h2><p>当主机开始发送数据时，由于并不清楚网络的负荷情况，所以如果立即把大量数据字节注入网络，那么就有可能引起网络发生拥塞。经验证明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口。</p><p>在一开始发送方先设置 cwnd = 1，发送第一个报文段 M1，接收方收到后确认 M1。发送方收到确认后，把 cwnd 从 1 增大到 2，于是发送方接着发送 M2 和 M3。<strong>发送方每收到一个对新报文段的确认（重传的不算在内）就使拥塞窗口加 1</strong>，因此发送方在收到两个确认后，cwnd 就从 2 增大到 4。因此使用慢开始算法后，每经过一个传输轮次，拥塞窗口就加倍。（在 TCP 的实际运行中，发送方只要收到一个对新报文段的确认，其拥塞窗口就立即加 1，并可以立即发送新的报文段，而不需要等待这个轮次中所有的确认都收到后再发送新的报文段。）</p><h2 id="拥塞避免">拥塞避免</h2><p>为了防止拥塞窗口增长过大引起网络拥塞，还需要设置一个<strong>慢开始门限</strong> ssthresh：当 cwnd &lt; ssthres h时，使用慢开始算法；当 cwnd &gt; ssthresh时，该用拥塞避免算法；当 cwnd = ssthresh 时，既可以使用慢开始，也可以使用拥塞避免算法。</p><p>拥塞避免算法的思路是让拥塞窗口缓慢地增大，即每经过一个 RTT 就把拥塞窗口加 1，而不是加倍增长。当网络出现了超时，发送方判断为网络拥塞，调整门限值 ssthresh = cwnd / 2，同时设置拥塞窗口 cwnd = 1，进入慢开始阶段。</p><p>拥塞避免并非能够避免了拥塞，而是把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</p><h2 id="快重传">快重传</h2><p>有时，个别报文段会在网络中丢失，但实际上网络并未发生拥塞。如果发送方迟迟收不到确认，就会误认为网络发生了拥塞。这就导致发送方错误地启动慢开始，降低了传输效率。</p><p>采用快重传算法可以让发送方<strong>尽早知道发生了个别报文段的丢失</strong>。快重传算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要<strong>立即发送确认</strong>，即使收到了失序的报文段也要立即发出对已收到的报文段的<strong>重复确认</strong>。比如，接收方收到 M2，但没收到 M3。后续又收到了失序报文 M4～M6，本来，接收方可以直接丢弃失序报文。但按照快重传算法，接收方必须立即发送对 M2 的重复确认，以便让发送方及早知道接收方没有收到报文段 M3。快重传算法规定，发送方只要<strong>一连收到 3 个重复确认</strong>，应立即进行重传，这样就不会出现超时，发送方也就不会误认为出现了网络拥塞。</p><h2 id="快恢复">快恢复</h2><p>快重传发生时，发送方知道现在只是丢失了个别的报文段。于是不启动慢开始，而是执行快恢复算法：调整门限值 ssthresh = cwnd / 2，同时设置拥塞窗口 cwnd = ssthresh，并开始执行拥塞避免算法。</p><p>也有的快恢复实现是令 cwnd = ssthresh + 3 x MSS。这样做的理由是：既然发送方收到 3 个重复的确认，就表明有 3 个分组已经到达接收方的缓存中，可见现在网络中减少了 3 个分组。因此可以适当把拥塞窗口扩大些。</p><p>在拥塞避免阶段，拥塞窗口是按照线性规律增大的，这常称为<strong>加法增大</strong> AI（Additive Increase）。而一旦出现超时或 3 个重复的确认，就要把门限值设置为当前拥塞窗口值的一半，并大大减小拥塞窗口的数值，这常称为<strong>乘法减小</strong> MD（Multiplicative Decrease）。二者合在一起就是所谓的 <strong>AIMD</strong> 算法。</p><h2 id="结合流量控制">结合流量控制</h2><p>上面的讨论基于接收方总是有足够大的缓存空间的假定，但实际上接收方的缓存空间总是有限的。如果把拥塞控制和流量控制一起考虑，那么很显然，发送方的窗口的上限值应当取接收方窗口 rwnd 和拥塞窗口 cwnd 中较小的一个。</p><h2 id="全局同步">全局同步</h2><p>上节讨论的拥塞控制并没有和网络层采取的策略联系起来。网络层的策略对拥塞控制影响最大的就是<strong>路由器的分组丢弃策略</strong>。</p><p>在最简单的情况下，路由器的队列通常都是按照“先进先出” FIFO（First In First Out）的规则处理到来的分组。当队列已满时，以后再到达的分组都将被丢弃，这叫做“尾部丢弃策略”（tail-drop policy）。尾部丢弃往往会导致一连串分组的丢失，这就使发送方出现超时重传，使 TCP 进入慢开始状态。更为严重的是，在网络中通常有很多 TCP 连接，这些连接中的报文段通常是复用在网络层中的 IP 数据报中传送。在这种情况下，若发生了尾部丢弃，就可能会同时影响到很多条 TCP 连接，结果使这些连接在<strong>同一时间</strong>突然都进入慢开始状态。这在 TCP 术语中称为<strong>全局同步</strong>（global synchronization）。全局同步使得全网的通信量突然下降了很多，而在网络恢复正常后，其通信量又突然增大很多。</p><h2 id="主动队列管理-aqm">主动队列管理 AQM</h2><p>主动队列管理（Active Queue Management），所谓“主动”就是不要等到路由器的队列长度已经达到最大值时才不得不丢弃后面到达的分组。应当在队列长度到达某个值得警惕的数值时（即当网络拥塞有了某些征兆时），就主动丢弃到达的分组。这样就提醒了发送方放慢发送的速率，因而有可能使网络拥塞的程度减轻，甚至不出现。</p><p>AQM 可以有不同的实现方法，曾流行多年的就是<strong>随机早期检测</strong> RED（Random Early Detection）。实现 RED 时需要路由器维持两个参数，即队列长度的最小门限和最大门限。当每一个分组到达时，就按照规定的算法计算当前的平均队列长度，若平均队列长度</p><ol type="1"><li>小于最小门限，接收新到达的分组</li><li>大于最大门限，丢弃新到达的分组</li><li>介于两者之间，按照某一丢弃概率 p 丢弃新到达的分组</li></ol><p>在 RED 的操作中，最难处理的就是丢弃概率 p 的选择，因为 p 并不是一个常数。对每一个到达的分组，都必须计算 p 的数值。多年的实践证明，<strong>RED 的使用效果并不太理想</strong>。目前还没有一种算法能够成为 IEFT 标准。</p><h1 id="连接管理">连接管理</h1><p>运输连接有三个阶段：<strong>连接建立</strong>、<strong>数据传送</strong>和<strong>连接释放</strong>。在 TCP 连接建立过程中要解决以下三个问题：</p><ol type="1"><li>要使每一方都能确知对方的存在</li><li>要允许双方协商一些参数（如最大窗口值，是否使用窗口扩大选项和时间戳选项以及服务质量等）</li><li>能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配</li></ol><h2 id="连接建立">连接建立</h2><p>三次握手。握手开始前，服务器需处于 LISTEN 状态，等待客户的连接请求。</p><p><img src="/uploads/image/computer-networking/three-way-handshake.jpg"></p><ol type="1"><li>客户发出连接请求报文段，并进入 SYN-SENT 状态。请求报文不能携带数据，但要消耗一个序号 x。</li><li>服务器收到请求报文，如同意建立连接，则发送确认报文并进入 SYN-RCVD 状态。确认报文也不能携带数据，也要消耗一个序号 y。</li><li>客户收到确认后，还要发送对确认的确认，之后进入 ESTABLISHED 状态。这个报文可以携带数据。</li><li>服务器收到确认的确认后，也进入 ESTABLISHED 状态。</li></ol><p><strong>注意</strong>：第三次握手，客户可以携带数据，也可以不携带数据。但如果不携带数据则不消耗序号，下一个数据报文段的序号仍是 seq = x + 1。携带数据，则按照数据长度计算下一个报文段的序号。</p><p>为什么有第三次握手？这主要是为了<strong>防止已失效的连接请求报文突然又传送到了服务器</strong>，因而产生错误。考虑一种情况：C 发出连接请求，但迟迟没有收到 S 的确认。于是 C 重传一次请求，随后收到了确认，建立了连接。数据传输完毕后，就释放了连接。现在假定 C 的第一个请求报文段并没有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达 S。本来这应是一个失效的请求，但 S 收到后就误以为 C 又发起一次新的连接请求，于是向 C 发出确认报文，同意建立连接。如果没有第三次握手，新的连接就已经建立了。由于 C 没有发出新的请求，因此会丢弃确认报文。但 S 却以为新的连接已经建立了，并一直在等待 C 发来数据。S 的许多资源就这样白白浪费了。</p><h2 id="连接释放">连接释放</h2><p>四次挥手</p><p><img src="/uploads/image/computer-networking/four-way-handshake.jpg"></p><p>数据传输结束后，双方都可释放连接，下面假设客户先发起连接释放。</p><ol type="1"><li>客户发送释放报文（FIN = 1），进入 FIN-WAIT-1 状态。FIN 报文可以携带数据。即使不携带数据，也要消耗一个序号。</li><li>服务器收到后发出确认，进入 CLOSE-WAIT 状态。这时 TCP 处于半关闭状态。从服务器到客户端的连接并未关闭，这个状态可能会持续一段时间。</li><li>若服务器没有数据要发送，就释放连接。发送释放报文（FIN = 1），并进入 LAST-ACK 状态。</li><li>客户收到释放报文后，必须对此确认。注意 seq = u + 1，因为前一个客户发出的释放报文（这里假设未携带数据）要消耗一个序号。然后进入 TIMW-WAIT 状态。必须经过<strong>时间等待计时器</strong>（TIME-WAIT timer）设置的时间 2MSL 后，才进入到 CLOSED 状态。时间 MSL 叫做<strong>最长报文段寿命</strong>（Maximum Segment Lifetime）。</li></ol><p>为什么必须等待 2MSL 时间呢？这有两个理由：</p><ol type="1"><li>为了保证客户的最后一个 ACK 报文段能够到达服务器。这个 ACK 可能会丢失，服务器迟迟收不到就会重传 FIN + ACK 报文段，客户就能在 2MSL 时间内收到重传的 FIN + ACK 报文段。接着，发送确认并重置计时器。</li><li>防止“已失效的连接请求报文段”出现在本连接中。客户发出最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续时间内所产生的所有报文段都从网络上消失。这样，下一个新的连接中就不会出现旧的连接请求报文段。</li></ol><p>除了时间等待计时器，TCP 还设有一个<strong>保活计时器</strong>（keepalive timer）。服务器每收到一次客户的数据，就重置保活计时器，时间的设置通常是两小时。若两小时没有收到客户的数据，服务器就发送一个探测报文段，以后每隔 75 秒发送一次。若一连发送 10 个探测报文段后仍无客户的响应，服务器就认为客户端出了故障，接着就关闭这个连接。</p></div><div class="popular-posts-header">相关文章</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/computer-networking/application-layer/" rel="bookmark">应用层</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/computer-networking/network-layer/" rel="bookmark">网络层</a></div></li></ul><footer class="post-footer"><div class="post-tags"> <a href="/tags/Computer-Networking/" rel="tag"># Computer Networking</a> <a href="/tags/TCP/" rel="tag"># TCP</a> <a href="/tags/UDP/" rel="tag"># UDP</a> <a href="/tags/flow-control/" rel="tag"># flow control</a> <a href="/tags/congestion-control/" rel="tag"># congestion control</a></div><div class="post-nav"><div class="post-nav-item"><a href="/programming/leetcode/reverse-linked-list/" rel="prev" title="Reverse Linked List"><i class="fa fa-chevron-left"></i> Reverse Linked List</a></div><div class="post-nav-item"> <a href="/programming/leetcode/rotate-list/" rel="next" title="Rotate List">Rotate List<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#tcp-报文段"><span class="nav-number">1.</span> <span class="nav-text">TCP 报文段</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#可靠传输"><span class="nav-number">2.</span> <span class="nav-text">可靠传输</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#滑动窗口"><span class="nav-number">2.1.</span> <span class="nav-text">滑动窗口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#超时重传时间"><span class="nav-number">2.2.</span> <span class="nav-text">超时重传时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#选择确认-sack"><span class="nav-number">2.3.</span> <span class="nav-text">选择确认 SACK</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#流量控制"><span class="nav-number">3.</span> <span class="nav-text">流量控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#利用滑动窗口"><span class="nav-number">3.1.</span> <span class="nav-text">利用滑动窗口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#传输效率"><span class="nav-number">3.2.</span> <span class="nav-text">传输效率</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#拥塞控制"><span class="nav-number">4.</span> <span class="nav-text">拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp-的拥塞控制方法"><span class="nav-number">4.1.</span> <span class="nav-text">TCP 的拥塞控制方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#慢开始"><span class="nav-number">4.2.</span> <span class="nav-text">慢开始</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拥塞避免"><span class="nav-number">4.3.</span> <span class="nav-text">拥塞避免</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快重传"><span class="nav-number">4.4.</span> <span class="nav-text">快重传</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快恢复"><span class="nav-number">4.5.</span> <span class="nav-text">快恢复</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结合流量控制"><span class="nav-number">4.6.</span> <span class="nav-text">结合流量控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#全局同步"><span class="nav-number">4.7.</span> <span class="nav-text">全局同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主动队列管理-aqm"><span class="nav-number">4.8.</span> <span class="nav-text">主动队列管理 AQM</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#连接管理"><span class="nav-number">5.</span> <span class="nav-text">连接管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#连接建立"><span class="nav-number">5.1.</span> <span class="nav-text">连接建立</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#连接释放"><span class="nav-number">5.2.</span> <span class="nav-text">连接释放</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="菜农陈文生" src="/uploads/avatar/nekosensei.png"><p class="site-author-name" itemprop="name">菜农陈文生</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">155</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">11</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">161</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="/atom.xml" title="RSS → /atom.xml"><i class="fa fa-rss fa-fw"></i></a></span><span class="links-of-author-item"><a href="https://github.com/cncws" title="GitHub → https://github.com/cncws" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a></span><span class="links-of-author-item"><a href="mailto:1031616423@qq.com" title="E-Mail → mailto:1031616423@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">菜农陈文生</span></div><script src="//cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="//cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script><script src="/js/aplayer-el.js"></script><script src="//unpkg.com/video.js/dist/video.min.js"></script><script src="/js/videojs-bilibili.js"></script><script src="/js/videojs-bilibili-el.js"></script></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script><script src="/js/local-search.js"></script><div id="pjax"><script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Axl15EIRi5o5AatKaxXxV4Oq-gzGzoHsz',
      appKey     : 'E0qm04UjsP0qQN1l8ME3GQ25',
      placeholder: "Just go go",
      avatar     : 'identicon',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script></div></body></html>