<!DOCTYPE html><html lang="zh-CN,en,default"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/uploads/icon/drop/128x128.png"><link rel="icon" type="image/png" sizes="32x32" href="/uploads/icon/drop/32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/uploads/icon/drop/16x16.png"><link rel="mask-icon" href="/uploads/icon/drop/drop.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"cwscn.github.io",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1,width:240},copycode:{enable:!0,show_result:!0,style:"flat"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"manual"},fancybox:!1,mediumzoom:!0,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"fadeIn"}},path:"search.xml"}</script><meta name="description" content="网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网络层不提供服务质量的承诺。如果主机中的进程之间的通信需要是可靠的，那么就由网络的主机中的运输层负责（包括差错处理、流量控制）。采用这种设计思路的好处是：网络造价大大降低，运行方式灵活，能够适应多种应用。 网际协议 IP 与 IP 协议配套使用的还有三个协议：  地址解析协议 ARP（Address Resolution Proto"><meta name="keywords" content="Computer Networking,IP,ICMP,IGMP,ARP"><meta property="og:type" content="article"><meta property="og:title" content="网络层"><meta property="og:url" content="https://cwscn.github.io/notes/computer-networking/network-layer/index.html"><meta property="og:site_name" content="水滴"><meta property="og:description" content="网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网络层不提供服务质量的承诺。如果主机中的进程之间的通信需要是可靠的，那么就由网络的主机中的运输层负责（包括差错处理、流量控制）。采用这种设计思路的好处是：网络造价大大降低，运行方式灵活，能够适应多种应用。 网际协议 IP 与 IP 协议配套使用的还有三个协议：  地址解析协议 ARP（Address Resolution Proto"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://cwscn.github.io/uploads/image/computer-networking/ip-address-and-hardware-address.jpeg"><meta property="og:image" content="https://cwscn.github.io/uploads/image/computer-networking/ip-header.jpeg"><meta property="og:image" content="https://cwscn.github.io/uploads/image/computer-networking/ip-header-validation.jpeg"><meta property="og:image" content="https://cwscn.github.io/uploads/image/computer-networking/ip-default-route.jpeg"><meta property="og:image" content="https://cwscn.github.io/uploads/image/computer-networking/ip-subnet-mask.jpeg"><meta property="og:image" content="https://cwscn.github.io/uploads/image/computer-networking/ip-binary-trie.jpeg"><meta property="og:image" content="https://cwscn.github.io/uploads/image/computer-networking/icmp-data.jpeg"><meta property="og:image" content="https://cwscn.github.io/uploads/image/computer-networking/rip-header.jpeg"><meta property="og:image" content="https://cwscn.github.io/uploads/image/computer-networking/ospf-header.jpeg"><meta property="og:image" content="https://cwscn.github.io/uploads/image/computer-networking/ospf-reliable-flooding.jpeg"><meta property="og:image" content="https://cwscn.github.io/uploads/image/computer-networking/bgp-path-vector-example.jpeg"><meta property="og:image" content="https://cwscn.github.io/uploads/image/computer-networking/bgp-path-vector-example.jpeg"><meta property="og:image" content="https://cwscn.github.io/uploads/image/computer-networking/router-structure.jpeg"><meta property="og:image" content="https://cwscn.github.io/uploads/image/computer-networking/router-forwarding.jpeg"><meta property="og:image" content="https://cwscn.github.io/uploads/image/computer-networking/router-switching-fabric.jpeg"><meta property="og:image" content="https://cwscn.github.io/uploads/image/computer-networking/ipv6-header.jpg"><meta property="og:image" content="https://cwscn.github.io/uploads/image/computer-networking/ipv6-dual-stack.jpeg"><meta property="og:image" content="https://cwscn.github.io/uploads/image/computer-networking/ipv6-tunneling.jpeg"><meta property="og:image" content="https://cwscn.github.io/uploads/image/computer-networking/ip-unicast-and-multicast.jpeg"><meta property="og:image" content="https://cwscn.github.io/uploads/image/computer-networking/ip-hardware-multicast.jpeg"><meta property="og:image" content="https://cwscn.github.io/uploads/image/computer-networking/ip-multicast-rpb.jpeg"><meta property="og:image" content="https://cwscn.github.io/uploads/image/computer-networking/ip-multicast-tunneling.jpeg"><meta property="og:image" content="https://cwscn.github.io/uploads/image/computer-networking/ip-vpn.jpeg"><meta property="og:image" content="https://cwscn.github.io/uploads/image/computer-networking/ip-nat.jpeg"><meta property="og:updated_time" content="2020-07-13T13:18:42.369Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="网络层"><meta name="twitter:description" content="网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网络层不提供服务质量的承诺。如果主机中的进程之间的通信需要是可靠的，那么就由网络的主机中的运输层负责（包括差错处理、流量控制）。采用这种设计思路的好处是：网络造价大大降低，运行方式灵活，能够适应多种应用。 网际协议 IP 与 IP 协议配套使用的还有三个协议：  地址解析协议 ARP（Address Resolution Proto"><meta name="twitter:image" content="https://cwscn.github.io/uploads/image/computer-networking/ip-address-and-hardware-address.jpeg"><link rel="canonical" href="https://cwscn.github.io/notes/computer-networking/network-layer/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css"><link rel="stylesheet" href="//unpkg.com/video.js/dist/video-js.min.css"><link rel="stylesheet" href="/css/videojs-bilibili.css"><style>.aplayer.aplayer-arrow .aplayer-icon-loop,.aplayer.aplayer-arrow .aplayer-icon-order{display:inline-block}</style><title>网络层 | 水滴</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">水滴</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">愿你走出半生 归来仍是少年</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档<span class="badge">175</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类<span class="badge">11</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签<span class="badge">169</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i> 关于</a></li><li class="menu-item menu-item-收藏"><a href="/favlist/" rel="section"><i class="fa fa-star fa-fw"></i> 收藏</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div><meting-js server="netease" type="playlist" id="67155774" theme="#ff5555" loop="all" order="list" preload="none" volume="" mutex="" list-folded="NaN" fixed="true"></meting-js></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwscn.github.io/notes/computer-networking/network-layer/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar/nekosensei.png"><meta itemprop="name" content="菜农陈文生"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="水滴"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 网络层</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-07-13 21:18:42" itemprop="dateModified" datetime="2020-07-13T21:18:42+08:00">2020-07-13</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/notes/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/notes/computer-networking/network-layer/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/notes/computer-networking/network-layer/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><p>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网络层不提供服务质量的承诺。如果主机中的进程之间的通信需要是可靠的，那么就由网络的主机中的运输层负责（包括差错处理、流量控制）。采用这种设计思路的好处是：网络造价大大降低，运行方式灵活，能够适应多种应用。</p><h1 id="网际协议-ip">网际协议 IP</h1><p>与 IP 协议配套使用的还有三个协议：</p><ul><li>地址解析协议 ARP（Address Resolution Protocol）</li><li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li><li>网际组管理协议（Internet Group Management Protocol）</li></ul><p>IP 协议使用 ARP 协议。ICMP 和 IGMP 使用 IP 协议。</p><p>将网络互相连接起来要使用一些<strong>中间设备</strong>。根据中间设备所在的层次，可以有以下四种不同的中间设备：</p><ol type="1"><li>物理层使用的中间设备叫做<strong>转发器</strong>（repeater）。</li><li>数据链路层使用的中间设备叫做<strong>网桥</strong>或<strong>桥接器</strong>（bridge）。</li><li>网络层使用的中间设备叫做<strong>路由器</strong>（router）。</li><li>在网络层以上使用的中间设备叫做<strong>网关</strong>（gateway）。用网关连接两个不兼容的系统需要在高层进行协议的转换。</li></ol><p>当中间设备是转发器或网桥时，这仅仅是把一个网络扩大了，而从网络层的角度看，这仍然是一个网络，一般并不称为网络互连。网关由于比较复杂，目前使用得较少。因此讨论网络互连时，都是指用路由器进行网络互连和路由选择。路由器其实就是一台专用计算机，用来在互联网中进行路由选择。由于历史的原因，许多有关 TCP/IP 的文献曾经把网络层使用的路由器称为网关，本书有时也这样用。</p><h1 id="ip-地址">IP 地址</h1><p>整个的互联网就是一个单一的、抽象的网络。IP 地址就是给互联网上的每一台主机（或路由器）的每一个接口分配一个在全世界范围内唯一的 32 位的标识符。IP 地址的编址方式经过了三个历史阶段。</p><ol type="1"><li>分类的 IP 地址。最基本的编址方法。</li><li>子网的划分。对最基本的编址方法的改进。</li><li>构成超网。无分配编址方法。已被广泛使用。</li></ol><h1 id="分类的-ip-地址">分类的 IP 地址</h1><table><tr><th> 网络类别</th><th> 类别位</th><th> 网络号</th><th> 主机号</th></tr><tr><td> A</td><td> 0</td><td> 8 位</td><td> 24 位</td></tr><tr><td> B</td><td> 10</td><td> 16 位</td><td> 16 位</td></tr><tr><td> C</td><td> 110</td><td> 24 位</td><td> 8 位</td></tr><tr><td> D</td><td> 1110</td><td colspan="2" style="text-align:center"> 多播地址</td></tr><tr><td> E</td><td> 1111</td><td colspan="2" style="text-align:center"> 保留为今后使用</td></tr></table><a id="more"></a><p>申请 IP 地址时，实际上是获得了具有同样网络号的一块地址。其中具体的各台主机号则由单位自行分配，只要做到在该单位管辖的范围内无重复的主机号即可。</p><p>A 类地址的网络号的第一位固定为 0，因此 A 类地址空间共有 2^31 个地址，占整个 IP 地址空间的 50%。同理，B 类占 25%，C 类占 12.5%。</p><p>全 0 的主机号字段表示该 IP 地址是“本主机”所连接到的<strong>一个网络的地址</strong>（例如，一主机的 IP 地址为 5.6.7.8，则该主机所在的网络地址就是 5.0.0.0），而全 1 表示“<strong>所有的</strong>”，全 1 的主机号字段表示该网络上的所有主机。</p><table><thead><tr class="header"><th>网络类别</th><th>最大可指派网络数</th><th>不指派网络号</th><th>第一个可指派的网络号</th><th>最后一个可指派的网络号</th><th>最大主机数</th></tr></thead><tbody><tr class="odd"><td>A</td><td>2^7 - 2</td><td>0 和 127</td><td>1</td><td>126</td><td>2^24 - 2</td></tr><tr class="even"><td>B</td><td>2^14 - 1</td><td>128.0</td><td>128.1</td><td>191.255</td><td>2^16 - 2</td></tr><tr class="odd"><td>C</td><td>2^21 - 1</td><td>192.0.0</td><td>192.0.1</td><td>223.255.255</td><td>2^8 - 2</td></tr></tbody></table><p>A 类地址的网络号有 7 位可用，但可指派的网络号是 2^7 - 2 = 126 个。减 2 的原因是：第一，网络号字段全 0 的 IP 地址是个保留地址，意思是”<strong>本网络</strong>“；第二，网络号为 127（即 01111111）保留作为本地软件<strong>环回测试</strong>（loopback test）本主机的进程之间的通信之用。若主机发送一个目的地址为环回地址（例如 127.0.0.1）的 IP 数据报，则本主机中的协议软件就会处理数据报中的数据，而不会把数据报发送到任何网络。目的地址为环回地址的 IP 数据报永远不会出现在任何网络上，因为网络号为 127 的地址根本不是一个网络地址。</p><p>IP 地址具有以下一些重要特点。</p><ol type="1"><li>每一个 IP 地址都由网络号和主机号两部分组成。这样做有两个好处：第一，<strong>方便 IP 地址的管理</strong>，IP 地址管理机构在分配 IP 地址时只分配网络号，而主机号由单位自行分配。第二，路由器仅<strong>根据目的主机所连接的网络号来转发分组</strong>，这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间以及查找路由表的时间。</li><li>实际上 IP 地址是标志一台主机（或路由器）和一条链路的<strong>接口</strong>。当一台主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号必须是不同的。这种主机称为<strong>多归属主机</strong>（multihomed host）。<strong>由于一个路由器至少应当连接到两个网络，因此一个路由器至少应当有两个不同的 IP 地址</strong>。</li><li>按照互联网的观点，一个网络是指具有相同网络号的主机的集合。因此，用转发器或网桥连接起来的若干个局域网仍为一个网络。具有不同网络号的局域网必须使用路由器进行连接。</li><li>在 IP 地址中，所有分配到网络号的网络都是<strong>平等</strong>的。所谓平等，只是互联网同等对待每一个 IP 地址。</li></ol><h2 id="ip-地址和硬件地址">IP 地址和硬件地址</h2><p>硬件地址（物理地址，MAC 地址）是数据链路层和物理层使用的地址，而 IP 地址是网络层和以上各层使用的地址，是一种逻辑地址，是用软件实现的。</p><p><img src="/uploads/image/computer-networking/ip-address-and-hardware-address.jpeg"></p><p>路由器同时连接到两个网络上时，必须具有两个不同的 IP 地址，也要有两个硬件地址。</p><p>在网络层只能看到 IP 数据报，数据报被转发时，首部中的源地址和目的地址始终不变。在链路层只能看到 MAC 帧，IP 数据报被封装在 MAC 帧中。MAC 帧在不同的网络上传送时，其首部中的源地址和目的地址要发生变化。</p><h2 id="地址解析协议-arp">地址解析协议 ARP</h2><p>由于是 IP 地址使用了 ARP 协议，因此通常就把 ARP 协议划归网络层。</p><p>每一台主机都设有一个 ARP 高速缓存，里面有<strong>本局域网</strong>上的各主机和路由器的 IP 地址到硬件地址的映射表。注意，ARP 是解决同一个局域网上的主机和路由器的 IP 地址和硬件地址的映射问题。主机不需要知道远程主机的硬件地址，只需要知道它的 IP 地址。IP 数据报通过连在同一个局域网的路由器来转发，最终到达目标网络的路由器上，再用类似方法解析出目的主机的硬件地址并交付。</p><p>当主机 A 要向<strong>本局域网</strong>上的主机 B 发送 IP 数据报时，先在 ARP 高速缓存中查看有无主机 B 的 IP 地址。如有，就查出其对应的硬件地址，再把这个硬件地址写入 MAC 帧，然后通过局域网发送该 MAC 帧。若无，主机 A 按以下步骤找出主机 B 的硬件地址。</p><ol type="1"><li>在本局域网上<strong>广播</strong>发送一个 ARP 请求分组，主要内容是：“我的 IP 地址是 ... 硬件地址是 ... 我想知道 IP 地址为 .. 的主机的硬件地址。“</li><li>在本局域网上的所有主机都收到此 ARP 请求分组。若主机的 IP 地址与 ARP 请求分组中要查询的 IP 地址不一致，就不理睬这个请求分组。（也有可能理睬一下，更新自己的 ARP 缓存，写入主机 A 的 IP 地址和硬件地址）</li><li>主机 B 的 IP 地址与请求分组中要查询的 IP 地址一致，就收下这个请求分组（同时更新 ARP 缓存写入主机 A 的 IP 地址和硬件地址），并向主机 A 发送 ARP 响应分组（<strong>单播</strong>），在这个响应分组中写入自己的硬件地址。</li><li>主机 A 收到响应分组后，就在其 ARP 高速缓存中写入主机 B 的 IP 地址到硬件地址的映射。</li></ol><p>ARP 对保存在高速缓存中的每一个映射地址都设置<strong>生存时间</strong>。当硬件地址发生改变时，能通过 ARP 再次查询新的地址。</p><h2 id="ip-数据报的格式">IP 数据报的格式</h2><p><img src="/uploads/image/computer-networking/ip-header.jpeg"></p><ul><li>版本：4（IPv4）或 6（IPv6）</li><li>首部长度：单位是 4 字节，因此最小值是 5（只有固定首部，没有数据），最大值 15，即 60 字节。当首部长度不是 4 字节的整数倍时，必须利用填充字段加以填充（全 0）。</li><li><p>总长度：单位是字节，因此数据报的最大长度为 2^16 - 1 = 65535 字节。然而传送这样长的数据报在现实中极少遇到。IP 层下面的每一种数据链路层协议都规定了一个数据帧中的<strong>数据字段的最大长度</strong>，称为<strong>最大传送单元</strong> MTU（Maximum Transfer Unit）。当一个 IP 数据报封装成链路层的帧时，总长度不能超过 MTU，否则必须把过长的数据报进行分片处理。</p><p>使用尽可能长的 IP 数据报会使传输效率得到提高，但数据报短些也有好处。每一个 IP 数据报越短，路由器转发的速度就越快。为此， IP 协议规定，在互联网中所有的主机和路由器，必须能够接受长度不超过 576 字节的数据报。这是假定上层交下来的数据长度有 512 字节（合理的长度），加上最长的 IP 首部 60 字节，再加上 4 字节的富余量，就得到 576 字节。当主机需要发送长度超过 576 字节的数据报时，应当先了解一下，目的主机能否接受所要发送的数据报长度。否则，就要进行分片。</p></li><li><p>标识、标志、片偏移：这三个字段与分片有关。</p><p>标识：IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加 1，并将此值赋给标识字段。</p><p>标志：MF（More Fragment），MF = 1 表示后面还有分片的数据报。MF = 0 表示这已经是最后一个分片。DF（Don't Fragment），DF = 1 表示不要分片。只有当 DF = 0 时才允许分片。</p><p>片偏移：以 8 个字节为偏移单位。也就是说，每个分片的长度一定是 8 字节的整数倍。</p><table><thead><tr class="header"><th></th><th>总长度（20 字节首部）</th><th>标识</th><th>MF</th><th>DF</th><th>片偏移</th></tr></thead><tbody><tr class="odd"><td>原始数据报</td><td>3820</td><td>12345</td><td>0</td><td>0</td><td>0</td></tr><tr class="even"><td>数据报片 1</td><td>1420</td><td>12345</td><td>1</td><td>0</td><td>0</td></tr><tr class="odd"><td>数据报片 2</td><td>1420</td><td>12345</td><td>1</td><td>0</td><td>175</td></tr><tr class="even"><td>数据报片 3</td><td>1020</td><td>12345</td><td>0</td><td>0</td><td>350</td></tr></tbody></table></li><li>生存时间：TTL（Time To Live），现在指<strong>跳数</strong>，表明数据报在网络中的寿命，防止无法交付的数据报无限制地在互联网中兜圈子。若 TTL = 1，就表示这个数据报只能在本局域网中传送。</li><li><p>协议：指出此数据报携带的数据是使用何种协议，以便使目的主机的 IP 层知道应将数据部分上交给哪个协议进行处理。</p><table><thead><tr class="header"><th>协议名</th><th>ICMP</th><th>IGMP</th><th>IP</th><th>TCP</th><th>EGP</th><th>IGP</th><th>UDP</th><th>IPv6</th><th>ESP</th><th>OSPF</th></tr></thead><tbody><tr class="odd"><td>协议字段值</td><td>1</td><td>2</td><td>4</td><td>6</td><td>8</td><td>9</td><td>17</td><td>41</td><td>50</td><td>89</td></tr></tbody></table></li><li><p>首部检验和：只检验数据报首部，数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化）。</p><p><img src="/uploads/image/computer-networking/ip-header-validation.jpeg"></p></li></ul><h2 id="转发分组的流程">转发分组的流程</h2><p>在互联网上转发分组时，是从一个路由器转发到下一个路由器。</p><p>在路由表中，对每一条路由最重要的是以下两个信息：(目的网络地址，下一跳地址)</p><p>虽然互联网所有的分组转发都是<strong>基于目的主机所在的网络</strong>*，但在大多数情况下都允许有这样的特例，即对特定的目的主机指明一个路由。这种路由叫做<strong>特定主机路由</strong>。采用特定主机路由可使网络管理人员更<strong>方便地控制网络和测试网络</strong>（对网络的连接或路由表进行排错），同时也可在需要<strong>考虑某种安全问题</strong>时采用这种特定主机路由。</p><p>路由器还可采用<strong>默认路由</strong>（default route）以减小路由表所占用的空间和搜索路由表所用的时间。这种转发方式在一个网络只有很少的对外连接时是很有用的。主机在发送每一个 IP 数据报时都要查找自己的路由表，如果一台主机连接在一个小网络上，而这个网络只用一个路由器和互联网连接，那么在这种情况下使用默认路由是非常合适的。</p><p><img src="/uploads/image/computer-networking/ip-default-route.jpeg"></p><p>IP 数据报中没有下一跳路由器的 IP 地址，那么待转发的数据报怎样能够找到下一跳路由器呢？</p><p>当路由器收到一个待转发的数据报，从路由表中得出下一跳路由器的 IP 地址后，不是把这个地址填入 IP 数据报，而是<strong>送交数据链路层的网络接口软件</strong>。网络接口软件负责把下一跳路由器的 IP 地址转换成硬件地址（使用 ARP），并将此硬件地址放在链路层的 MAC 帧的首部，然后根据这个硬件地址找到下一跳路由器。</p><p>分组转发算法如下：</p><ol type="1"><li>从数据报首部提取目的主机的 IP 地址 D，得出目的网络地址 N。</li><li>若网络 N 与此路由器直接相连，则进行<strong>直接交付</strong>，把数据报交付目的主机（查找 D 的硬件地址，封装 MAC 帧，发送）。否则就是<strong>间接交付</strong>。</li><li>若路由表中有 D 的特定主机路由，则交付特定路由指明的下一跳路由器。</li><li>若路由表中有 N 的路由，交付给指定的下一跳路由器。</li><li>若路由表中有 默认路由，交付给默认路由器。</li><li>否则，报告转发分组出错。</li></ol><h1 id="划分子网">划分子网</h1><h2 id="从两级-ip-到三级-ip">从两级 IP 到三级 IP</h2><ol type="1"><li>IP 地址空间的利用率有时很低。有的单位申请到了一个 B 类地址，但所连接的主机数并不多，可是又不愿意申请一个足够使用的 C 类地址，理由是考虑到今后可能的扩展。IP 地址的浪费，使 IP 地址空间的资源过早地被用完。</li><li>给每一个物理网络分配一个网络号会<strong>使路由表变得太大</strong>（需要更多的存储空间）因而使网络性能变坏（查找路由耗费更多的时间）。</li><li>两级 IP 地址不够灵活。一个单位需要在新的地点开通一个新的网络。但是在申请到一个新的 IP 地址之前，新增加的网络是不可能连接到互联网上工作的。我们希望有一种方法，使一个单位能随时灵活地增加本单位的网络，而不必去申请新的网络号。</li></ol><p>为解决上述问题，从 1985 年起在 IP 地址中又增加了一个“子网号字段”，使两级 IP 地址变为三级 IP 地址（网络号，子网号，主机号）。子网号是从原来的主机号借用若干位，而原来的主机号相应减少了同样的位数。</p><p>从其他网络发送给本网络某台主机的 IP 数据报，仍然是根据<strong>网络号</strong>找到连接在本网络上的路由器。但此路由器在收到 IP 数据报后，再按<strong>子网号</strong>找到目的子网，交付目的主机（子网与该路由器直接相连）或与子网连接的路由器。</p><h2 id="子网掩码">子网掩码</h2><p>现在剩下的问题是，路由器无法看出子网号有几位。IP 地址本身以及数据报首部都没有关于子网划分的信息。因此必须另外想办法，这就是使用子网掩码（subnet mask）。</p><p><img src="/uploads/image/computer-networking/ip-subnet-mask.jpeg"></p><p>虽然没有规定子网掩码中的一串 1 必须是连续的，但却极力推荐在子网掩码中选用连续的 1，以免出现差错。</p><p>使用子网掩码的好处是：不管网络有没有划分子网，只要把子网掩码和 IP 地址进行“与”运算，就立即得出网络地址来。这样在路由器处理到来的分组时就可采用同样的算法。</p><p>现在互联网的标准规定：所有的网络都必须使用子网掩码（便于查找路由表），同时<strong>在路由器的路由表中也必须有子网掩码这一栏</strong>。如果一个网络不划分子网，那么该网络的子网掩码就使用默认子网掩码。默认子网掩码中 1 的位置和 IP 地址中的网络号字段正好相对应。A 类：255.0.0.0。 B 类：255.255.0.0。 C 类：255.255.255.0。</p><p>路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。在路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。若一个路由器连接在两个子网上就拥有两个网络地址和两个子网掩码。</p><p>划分子网增加了灵活性，但却减少了网络上能连接的最大主机总数。</p><h2 id="使用子网时分组的转发">使用子网时分组的转发</h2><p>使用子网后，路由表必须包含以下三项内容：（目的网络地址，子网掩码，下一跳地址）。</p><ol type="1"><li>从收到的数据报首部提取目的 IP 地址 D。</li><li>判断是否可以直接交付：对路由器直接连接的网络逐个进行检查，用各网络的子网掩码和 D 相与，看结果是否和相应的网络地址匹配。若匹配，则直接交付（查找物理地址，封装成帧，发送）。否则是间接交付。</li><li>若有目的地址为 D 的特定主机路由，交付下一跳路由。</li><li>对路由表中每一行，用 D 与子网掩码相与，其结果为 N。若 N 与目的网络地址匹配，交付下一跳路由器。</li><li>若有默认路由，交付默认路由器。</li><li>报告转发分组出错。</li></ol><h1 id="无分类编址构造超网">无分类编址（构造超网）</h1><h2 id="网络前缀">网络前缀</h2><p>无分类域间路由选择 CIDR（Classless Inter-Domain Routing，读音是 “sider”）最主要的特点有两个：</p><ol type="1"><li><p>CIDR 消除了传统的 A、B、C 类地址以及划分子网的概念，能更加有效地分配 IPv4 的地址空间。</p><p>CIDR 使 IP 地址又回到了两级编址：（网络前缀，主机号）。</p><p>CIDR 使用斜线记法，在 IP 地址后面加上斜线 “/”，然后写上网络前缀所占的位数。</p></li><li><p>CIDR 把网络前缀都相同的连续的 IP 地址组成一个“CIDR 地址块”。只要知道地址块中的任何一个地址，就可以知道这个地址块的起始地址（即最小地址）和最大地址，以及地址块中的地址数。</p><p>例如，128.14.35.7/20，前 20 位是网络前缀，即子网掩码的前 20 位是 1，后 16 位是 0。</p><p>128.14.35.7/20 = <u>10000000 00001110 0010</u>0011 00000111</p><p>最小地址：128.14.32.0 = <u>10000000 00001110 0010</u>0000 00000000</p><p>最大地址：128.14.47.255 = <u>10000000 00001110 0010</u>1111 11111111</p><p>当然，一般并不使用以上这两个特殊的主机号。上面的地址块可记为 128.14.32.0/20。</p></li></ol><p>“CIDR 不使用子网”是指 CIDR 并没有在 32 位地址中指明若干位作为子网字段。但分配到一个 CIDR 地址块的单位，仍然可以根据需要划分出一些子网。这些子网也都只有一个网络前缀和一个主机号，但子网的网络前缀比地址块的网络前缀要长些。</p><p>由于一个 CIDR 地址块中有很多地址，所以在路由表中就利用 CIDR 地址块来查找目的网络。这种地址的聚合常称为<strong>路由聚合</strong>（route aggregation），它使得路由表中的一个项目可以表示传统分类地址的很多个路由。</p><p>常用的 CIDR 地址块</p><table><colgroup><col style="width:25%"><col style="width:25%"><col style="width:25%"><col style="width:25%"></colgroup><thead><tr class="header"><th>CIDR 前缀长度</th><th>点分十进制</th><th>包含的地址数</th><th>相当于</th></tr></thead><tbody><tr class="odd"><td>/13</td><td>255.248.0.0</td><td>512 K ~ 2^(32 - 13) 个</td><td>8 个 B 类（2^16 个地址）或 2048 个 C 类（2^8 个地址）</td></tr><tr class="even"><td>/14</td><td>255.252.0.0</td><td>256 K</td><td>4 个 B 类或 1024 个 C 类</td></tr><tr class="odd"><td>...</td><td>...</td><td>...</td><td>...</td></tr><tr class="even"><td>/23</td><td>255.255.254.0</td><td>512</td><td>2 个 C 类</td></tr><tr class="odd"><td>/24</td><td>255.255.255.0</td><td>256</td><td>1 个 C 类</td></tr><tr class="even"><td>/25</td><td>255.255.255.128</td><td>128</td><td>1/2 个 C 类</td></tr><tr class="odd"><td>/26</td><td>255.255.255.192</td><td>64</td><td>1/4 个 C 类</td></tr><tr class="even"><td>/27</td><td>255.255.255.224</td><td>32</td><td>1/8 个 C 类</td></tr></tbody></table><p>路由聚合也称为<strong>构成超网</strong>（supernetting）。除最后几行外，CIDR 地址块都包含了多个 C 类地址，这就是“构成超网”这一名次的来源。</p><p>使用 CIDR 的一个好处就是可以更加有效地分配 IPv4 的地址空间，可根据客户的需要分配适当大小的地址块。而在分类地址中，只能以 /8（A 类），/16（B 类），/24（C 类）来分配，很不灵活。</p><h2 id="最长前缀匹配">最长前缀匹配</h2><p>在使用 CIDR 时，查找路由表时可能会得到不止一个匹配结果，<strong>应当从匹配结果中选择具有最长网络前缀的路由</strong>。这叫做<strong>最长前缀匹配</strong>（longest-perfix matching）。因为网络前缀越长，路由就越具体。</p><p>例如，路由表中有以下两个项目：206.0.68.0/22 和 206.0.71.128/25。现在假定收到一个数据报，其目的 IP 地址为 D=206.0.71.130。D 与这两个目的网络都匹配，根据最长前缀匹配，应当选择后者。因为 206.0.71.128/25 是 206.0.68.0/22 的子网，它更具体。</p><p>采用 CIDR，我们可以按照网络所在的地理位置来分配地址块，这样就可大大减少路由表中的路由项目。例如，可以将世界划分为四大地区，每一地区分配一个 CIDR 地址块：</p><ul><li>地址块 194/7（194.0.0.0 至 195.255.255.255）分配给欧洲。</li><li>地址块 198/7（198.0.0.0 至 199.255.255.255）分配给北美洲。</li><li>地址块 200/7（200.0.0.0 至 201.255.255.255）分配给中美洲和南美洲。</li><li>地址块 202/7（202.0.0.0 至 203.255.255.255）分配给亚洲和太平洋地区。</li></ul><p>上面的每一个地址块包含约 3200 万个地址。凡是发往北美的 IP 数据报（目的 IP 地址的前 7 位是十进制 194）都先送交位于美国的一个路由器，因此在路由表中使用一个项目就行了。</p><h2 id="使用二叉线索查找路由">使用二叉线索查找路由</h2><p>使用 CIDR 后，由于要寻找最长前缀匹配，使路由表的查找过程变得更加复杂了。为了进行更加有效的查找，通常是把无分类编址的路由表放在一种层次的数据结构中，然后自上而下地按层次进行查找。这里最常用的就是<strong>二叉线索</strong>（binary trie），它是一种特殊结构的树。IP 地址中从左到后的比特值决定了从根节点逐层向下层延伸的路径。</p><p>为了简化二叉线索的结构，可以先找出对应与每一个 IP 地址的<strong>唯一前缀</strong>（unique prefix）。所谓唯一前缀就是在表中所有的 IP 地址中，该前缀是唯一的。进行查找时，只要能够和唯一前缀相匹配就行了。</p><p><img src="/uploads/image/computer-networking/ip-binary-trie.jpeg"></p><p>由于唯一前缀一般都小于 32 位，因此用唯一前缀构造的二叉线索的深度往往不到 32 层。二叉线索的每个叶节点代表一个唯一前缀。例如有一个地址是 10011011 ...，需要查找该地址是否在此二叉线索中。从左边开始查起，查到第三个字符时，找不到匹配的，说明这个地址不在这个二叉线索中。</p><p>目的地址<strong>与某一前缀匹配不意味着一定与网络前缀匹配</strong>。要将二叉线索用于路由表中，还必须使每一个叶节点包含所对应的网络前缀和子网掩码。当搜索到一个叶节点时，就必须将目的地址和子网掩码进行“与”运算，看结果是否与对应的网络前缀相匹配。若匹配，就按下一跳的接口转发分组。否则，就丢弃该分组。</p><p>为了提高二叉线索的查找速度，广泛使用了各种<strong>压缩技术</strong>。例如，图中的最后两个地址，其最前面 4 位都是 1011.因此，只要有一个地址的前 4 位是 1011，就可以跳过前面 4 位（即压缩了 4 个层次）而直接从第 5 位开始比较。当然，制作经过压缩的二叉线索需要更多的计算，但由于每一次查找路由时都可以提高查找速度，这样做还是值得的。</p><h1 id="网际控制报文协议-icmp">网际控制报文协议 ICMP</h1><p>为了更有效地转发 IP 数据报和提高交付成功的机会，在网际层使用了 网际控制报文协议 ICMP（Internet Control Message Protocol）。ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。</p><p>ICMP 报文是<strong>封在 IP 数据报</strong>中，作为其中的数据部分。看起来像高层协议，其实不是，而是 IP 层的协议。</p><p>ICMP 报文有两种：<strong>ICMP 差错报告报文</strong> 和 <strong>ICMP 询问报文</strong>。</p><p>ICMP 报文的前 4 个字节是统一的格式，类型（1）、代码（1）和检验和（2）。接着的 4 个字节的内容与 ICMP 的类型有关。最后面是数据字段。</p><table><tr><th> ICMP 报文种类</th><th> 类型的值</th><th> 类型</th></tr><tr><td rowspan="4"> 差错报告控制报文</td><td> 3</td><td> 终点不可达</td></tr><tr><td> 11</td><td> 时间超过</td></tr><tr><td> 12</td><td> 参数问题</td></tr><tr><td> 5</td><td> 改变路由（Redirect）</td></tr><tr><td rowspan="2"> 询问报文</td><td> 8 或 0</td><td> 回送（Echo）请求或回答</td></tr><tr><td> 13 或 14</td><td> 时间戳（Timestamp）请求或回答</td></tr></table><h2 id="差错报告报文">差错报告报文</h2><ul><li>终点不可达：当路由器或主机不能交付数据报时，向源点发送此报文。</li><li>时间超过：当路由器收到生存时间为零的数据报时，除丢弃该数据报以外，还要向源点发送此报文。当终点在规定时间内不能收到一个数据报的全部数据报片时，就把已收到的都丢弃，并向源点发送此报文。</li><li>参数问题：当路由器或主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送此报文。</li><li><p>改变路由：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）。</p><p>在互联网的主机中也要有一个路由表。当主机要发送数据报时，首先要查找主机自己的路由表，看应当从哪一个接口把数据报发送出去。在互联网中，主机的数量远大于路由器的数量，出于效率的考虑，这些主机不和路由器定期交换路由信息。在主机刚开始工作时，一般都在路由表中设置一个默认路由器的 IP 地址。这个默认路由器（通过和其他路由器交换路由信息）知道到每一个目的地址的最佳路由。如果默认路由器发现主机发往某个目的地址的数据报的最佳路由应当经过网络上的另一个路由器时，就用改变路由报文把这情况告诉主机。于是，该主机就在其路由表中增加一个项目：到某目的地址应经过某路由器（而不是默认路由器）。</p></li></ul><p>所有的 ICMP 差错报告报文中的数据字段都具有同样的格式。</p><p><img src="/uploads/image/computer-networking/icmp-data.jpeg"></p><p>提取收到的数据报的数据字节的前 8 个字节（TCP 或 UDP 的首部的前 8 个字节）是为了得到运输层的端口号（对于 TCP 和 UDP）以及运输层报文的发送序号（对于 TCP）。整个 ICMP 报文作为 IP 数据报的数据字段发送给源点。</p><p>下面是不应该发送 ICMP 差错报告报文的几种情况。</p><ul><li>对 ICMP 差错报告报文，不再发送 ICMP 差错报告报文。</li><li>对第一个分片的数据报片的所有后续数据报片，都不发送。</li><li>对具有多播地址的数据报，都不发送。</li><li>对具有特殊地址（如 127.0.0.0 或 0.0.0.0）的数据报，不发送。</li></ul><h2 id="询问报文">询问报文</h2><ul><li>回送请求和回答：由主机或路由器向一个特定的目的主机发出询问，收到此报文的主机必须给源主机或路由器发送 ICMP 回送回答报文。这种询问报文用来<strong>测试目的站是否可达</strong>以及<strong>了解有关状态</strong>。</li><li>时间戳请求和回答：请某台主机或路由器回答当前的日期和时间。可用于时钟同步和时间测量。</li></ul><h2 id="icmp-应用举例">ICMP 应用举例</h2><ul><li><p>分组网间探测 PING（Packet InterNet Groper），用来测试两台主机之间的连通性。</p><p>PING 使用 ICMP 回送请求和回送回答报文（<strong>ICMP 询问报文</strong>）。<strong>PING 是应用层直接使用网络层 ICMP 的一个例子。它没有通过运输层的 TCP 或 UDP</strong>。</p></li><li><p>traceroute（这是 UNIX 操作系统中的名字）或 tracert（Windows 操作系统中的名字），用来跟踪一个分组从源点到终点的路径。</p><p>traceroute 从源主机向目的主机发送一连串的 IP 数据报，数据报中<strong>封装的是无法交付（使用了非法的端口）的 UDP 用户数据报</strong>。第一个数据报的生存时间 TTL 设置为 1。路由器收下后把 TTL 的值减 1，由于 TTL 等于 0 了，就丢弃报文并向源主机发送一个 <strong>ICMP 时间超过</strong>差错报告报文。</p><p>源主机接着发送第二个数据报，并把 TTL 设置为 2 ... 这样一直继续下去，当最后一个数据报刚刚到达目的主机时，数据报的 TTL 是 1。主机不转发数据报，但因 IP 数据报中封装的是无法交付的 UDP 用户数据报，因此目的主机要向源点发送 <strong>ICMP 终点不可达</strong>差错报告报文。</p></li></ul><h1 id="路由选择协议">路由选择协议</h1><p>路由表中的路由（行）是怎样得出的。</p><h2 id="理想的路由算法">理想的路由算法</h2><ol type="1"><li>正确性和完整性。正确的含义是：沿着各路由表所指引的路由，分组一定能够最终到达目的网络和目的主机。</li><li>计算上应简单，不应使网络增加太多的额外开销。</li><li>自适应性，能适应通信量和网络拓扑的变化。也称稳健性（robustness）。</li><li>稳定性，算法应收敛于一个可以接受的解，而不应使得路由不停地变化。</li><li>公平性，对所有用户（除对少数优先级高的用户）都是平等的。</li><li>最佳的，使得分组平均时延最小而网络的吞吐量最大。虽然我们希望得到”最佳“的算法，但这并不总是最重要的。对于某些网络，网络的可靠性有时要比最小的分组平均时延或最大吞吐量更加重要。因此，所谓最佳只能是相对于某一种特定要求下得出的较为合理的选择而已。</li></ol><p>若从路由算法能否虽网络的通信量或拓扑自适应地进行调整来区分，则只有两大类：</p><ul><li>静态路由选择策略，也叫做非自适应路由选择。其特点是简单和开销小，但不能及时适应网络状态的变化。对于很简单的小网络，完全可以采用静态路由选择，用人工配置每一条路由。</li><li>动态路由选择策略，也叫做自适应路由选择。其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。因此，动态路由选择适用于较复杂的大网络。</li></ul><h2 id="分层次的路由选择协议">分层次的路由选择协议</h2><p>互联网采用的主要是<strong>自适应的、分布式</strong>路由选择协议。而采用分层次的路由选择协议有以下两个原因：</p><ol type="1"><li>互联网的规模非常大。如果让所有的路由器知道所有的网络应怎样到达，则这种路由表将非常大，处理起来也太花时间。而所有这些路由器之间交换路由信息所需的带宽就会使互联网的通信链路饱和。</li><li>许多单位不愿意外界了解自己单位网络的布局细节和本部门所采用的路由选择协议，但同时还希望连接到互联网上。</li></ol><p>为此，可以把整个互联网划分为许多较小的<strong>自治系统</strong> AS（autonomous system）。AS 是在单一技术管理下的一组路由器，这些路由器使用一种自治系统内部的路由选择协议和共同的度量。一个 AS 对其他 AS 表现出的是<strong>一个单一的和一致的路由选择策略</strong>。</p><p>互联网把路由选择协议划分为两大类：</p><ol type="1"><li><strong>内部网关协议</strong> IGP（Interior Gateway Protocol） 即在一个自治系统内部使用的路由选择协议。目前这类路由选择协议使用得最多，如 RIP 和 OSPF 协议。</li><li><strong>外部网关协议</strong> EGP（External Gateway Protocol） 若源主机和目的主机处在不同的自治系统中（这两个自治系统可能使用不同的内部网关协议），当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。目前使用最多的外部网关协议是 BGP-4（BGP的版本 4）。</li></ol><p>每个自治系统自己决定在本自治系统内部运行哪一个内部路由选择协议（RIP 或 OSPF）。但每个自治系统都有一个或多个路由器除运行本系统的内部路由选择协议之外，还要运行自治系统间的路由选择协议（BGP-4）。</p><p>网关是旧称，就是网络层的路由器。因此有的书把 IGP 和 EGP 分别改为 IRP 和 ERP。</p><h2 id="内部网关协议-rip">内部网关协议 RIP</h2><p>RIP（Routing Information Protocol）是内部网关协议 IGP 中最先得到广泛使用的协议。RIP 是一种<strong>分布式的基于距离向量</strong>的路由选择协议，其最大的优点是<strong>简单</strong>。</p><p>RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录（因此，这是一组距离，即“距离向量”）。RIP 协议的“距离”也称“跳数”（hop count），因为每经过一个路由器，跳数就加 1。RIP 认为好的路由就是它通过的路由器的数目少，即“距离短”。RIP 允许一条路径最多只能包含 15 个路由器，因此“距离”等于 16 时即相当于不可达。可见 RIP 只适用于小型互联网。</p><p>RIP 不能在两个网络之间使用多条路由。RIP 选择一条具有最少路由器的路由，哪怕还存在另一条高速（低时延）但路由器较多的路由。</p><p>我们一定要弄清以下三个要点，即<strong>和哪些路由器交换信息？交换什么信息？在什么时候交换</strong>？</p><p>RIP 协议的特点是：</p><ol type="1"><li>仅和相邻路由器交换信息。如果两个路由器之间的通信不需要经过另一个路由器，那么这两个路由器就是相邻的。不相邻的路由器不交换信息。</li><li>交换的信息是当前本路由器所知道的全部信息，即自己现在的路由表。</li><li>按固定的时间间隔交换路由信息。例如，每隔 30 秒。</li></ol><h3 id="距离向量算法">距离向量算法</h3><p>距离向量算法的基础是 Bellman-Ford 算法，原理是最短路径具有最优子结构性质。</p><p>对每一个相邻路由器发送过来的 RIP 报文，进行以下步骤。</p><ol type="1"><li><p>对地址为 X 的相邻路由器发来的 RIP 报文，先修改此报文中的所有项目：把“下一跳”字段中的地址都改为 X，并把所有的“距离”字段的值都加 1。修改后每一个项目都由三个关键数据，即：目的网络 N，距离 d，下一跳路由器 X。（即 X 把它的路由表传给我了，我要比较我的路由表和它的路由表，看看应该按我的路由表传，还是它的。这一步的修改动作就是为接下来的比较做准备，N 是目的网络，d 就是我把分组传给 X 再由 X 续传到 N 的总距离）</p></li><li><p>对修改后的每一个项目，进行以下步骤：</p> 若路由表中没有目的网络 N，添加该项目到路由表中。否则，路由表中有网络 N，就要比较距离了：<ul><li>若下一跳路由器地址也是 X，则更新距离 d。（注意，是更新。因为网络的距离是可能发生变化的，要以最新的消息为准）</li><li>若下一跳路由器的地址不是 X，则保留距离较小的那一项。</li></ul></li><li><p>若 3 分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达路由器，即把距离置为 16。</p></li></ol><h3 id="rip-协议的报文格式">RIP 协议的报文格式</h3><p>下图是 RIP2（版本 2）的报文格式。</p><p><img src="/uploads/image/computer-networking/rip-header.jpeg"></p><p>RIP 协议使用运输层的 UDP 进行传送，使用的端口是 520。命令字段指出报文的意义。例如， 1 表示请求路由信息，2 表示对 1 的响应或主动发出的路由更新报文。首部的“必为 0”是填充字段，为了 4 字节的对齐。</p><p>RIP2 具有简单的鉴别功能。若使用鉴别功能，则将原来写入第一个路由信息的位置用作鉴别。这时应将地址族标识符置为全 1，而路由标记写入鉴别类型，剩下的 16 字节为鉴别数据。在鉴别数据之后才写入路由信息，但这时最多只能再放入 24 个路由信息。</p><p>RIP 存在的一个问题是<strong>当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器</strong>。举个简单的例子，</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">N1 ----- R1 ------------ R2 ----- N2</span><br><span class="line">    N1, 1, 直接       N1, 2, R1</span><br><span class="line"></span><br><span class="line">N1 -xxx- R1 ------------ R2 ----- N2</span><br><span class="line">    N1, 16, 直接      N1, 2, R1</span><br></pre></td></tr></table></figure><p>现在假定 R1 到 N1 的链路除了故障。于是 R1 更新自己的路由表为 N1, 16, 直接。但是，很可能要经过 30 秒后才把更新后的信息发给 R2。（这么憨的吗？不能立即发送吗？）然而，R1 在发送之前收到了来自 R2 的更新信息。根据算法，R1 需要更新自己的路由为 N1, 2, R2。即 R1 误以为可以通过 R2 将到达 N1。R1 经过一段时间，将 N1, 2, R2 发送给 R2，R2 根据算法将自己的路由表更新为 N1, 3, R1。（你也这么憨的吗？更新前不看看发来的路由的下一跳就是自己）……这样的更新一直持续下去，直到距离增大到 16 为止，R1 和 R2 才知道 N1 是不可达的。RIP 协议的这一特点叫做：<strong>好消息传播得快，而坏消息传播得慢。</strong>但如果一个路由器发现了更短的路由，那么这种更新信息就传播得很快。</p><p>总之，RIP 协议最大的优点就是<strong>实现简单，开销较小</strong>。但缺点也很多。</p><ul><li>首先，RIP 限制了网络的规模，它能使用的最大距离为 15。</li><li>其次，路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</li><li>最后，坏消息传播得慢，使更新过程的收敛时间过长。</li></ul><p>因此，对于规模较大的网络就应当使用 OSPF 协议。然而目前在规模较小的网络中，使用 RIP 协议的仍占多数。</p><h2 id="内部网关协议-ospf">内部网关协议 OSPF</h2><p>这个协议的名字是<strong>开放最短路径优先</strong> OSPF（Open Shortest Path First），是为了克服 RIP 的缺点被开发出来的。”开放“指的是 OSPF 协议不是受某一家厂商控制，而是公开发表的。”最短路径优先“是因为使用了 Dijkstra 提出的<strong>最短路径算法</strong>。请注意：OSPF 只是一个协议的名字，并不表示其他的路由选择协议不是”最短路径优先“。实际上，所有的在自治系统内部使用的路由选择协议都是要寻找一条最短的路径。</p><p>OSPF 最主要的特征就是使用分布式的<strong>链路状态协议</strong>（link state protocol），而不是像 RIP 那样的距离向量协议。OSPF 协议的三个要点和 RIP 的都不一样：</p><ol type="1"><li>向本自治系统中<strong>所有路由器</strong>发送信息。使用的是<strong>洪泛法</strong>（flooding）：路由器通过所有输出端口向所有相邻的路由器发送信息。而每一个相邻的路由器又再将此信息发往其所有的相邻路由器（但不发给发来信息的那个路由器）。这样，最终整个区域中所有的路由器都得到了这个信息的一个副本。</li><li>发送的信息是<strong>与本路由器相邻的所有路由器的链路状态</strong>，但这只是路由器所知道的<strong>部分信息</strong>。所谓链路状态就是说明本路由器和哪些路由器相邻，以及该链路的<strong>度量</strong>（metric）。度量（费用、距离、时延、带宽等等）由网络管理人员来决定，因此较为灵活。</li><li>只有当链路状态<strong>发生变化</strong>时，路由器才向所有路由器用洪泛法发送此信息。</li></ol><h3 id="关于-rip-和-ospf-三个要点的总结">关于 RIP 和 OSPF 三个要点的总结</h3><table><colgroup><col style="width:33%"><col style="width:33%"><col style="width:33%"></colgroup><thead><tr class="header"><th></th><th>RIP</th><th>OSPF</th></tr></thead><tbody><tr class="odd"><td>向谁发送？</td><td>相邻路由器</td><td>全部路由器（洪泛法，可以看做递归式地向相邻路由器发送）</td></tr><tr class="even"><td>发送什么？</td><td>本路由器的路由表（本路由器知道的全部信息）</td><td>与本路由器相邻的路由器的链路状态（本路由器知道的部分信息），链路状态可以等效看作是自定义的路由表的表项</td></tr><tr class="odd"><td>何时发送？</td><td>定期发送（如 30 秒）</td><td>链路状态发生变化时发送</td></tr></tbody></table><p>所有的路由器最终都能建立一个<strong>链路状态数据库</strong>（link-state database），这个数据库实际上就是<strong>全网的拓扑结构图</strong>。这个拓扑结构图在全网范围内是一致的（这称为链路状态数据库的同步）。每一个路由器使用链路状态数据库，构造出自己的路由表（例如，使用 Dijkstra 的最短路径路由算法）。</p><p>OSPF 的链路状态数据库能较快地进行更新，<strong>更新过程收敛得快</strong>是其重要优点。</p><h3 id="ospf-的区域划分">OSPF 的区域划分</h3><p>为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的范围，叫做<strong>区域</strong>（area），每一个区域都由一个 32 位的区域标识符（用点分十进制表示，和 IPv4 类似，但不是 IPv4）。一个区域不能太大，在一个区域内的路由器最好不超过 200 个。划分区域的好处是<strong>把利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统</strong>，这就减少了整个网络上的通信量。在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况。</p><p>为了使每一个区域能够和本区域以外的区域进行通信，OSPF 使用<strong>层次结构的区域划分</strong>。在上层的区域叫做<strong>主干区域</strong>（backbone area），标识符规定为 0.0.0.0。主干区域的作用是连通其他在下层的区域。在主干区域内的路由器叫做<strong>主干路由器</strong>（backbone router）。同时连接主干区域和其他区域的路由器叫做<strong>区域边界路由器</strong>（area border router）。主干区域内还要有一个路由器专门和本自治系统以外的的其他自治系统交换路由信息。这样的路由器叫做<strong>自治系统边界路由器</strong>。</p><p>采用分层次划分区域的方法，</p><ul><li>缺点是，使交换信息的种类增多了，同时也使 OSPF 协议更加复杂了。</li><li>优点是，使每一个区域内部交换路由信息的通信量大大减小，因而能用于规模很大的自治系统中。</li></ul><h3 id="ospf-协议的报文格式">OSPF 协议的报文格式</h3><p>OSPF 不用 UDP 而是<strong>直接用 IP 数据报传送</strong>，这样做可减少路由信息的通信量。数据报短的另一个好处是，可以不必将长的数据报分片传送。分片传送的数据报只要丢失一个，就无法组装成原来的数据报，而整个数据报就必须重传。</p><p><img src="/uploads/image/computer-networking/ospf-header.jpeg"></p><p>OSPF 使用 24 字节的固定长度首部：</p><ul><li>版本：当前的版本号是 2。</li><li>类型：可以是 5 种类型分组中的一种。<ul><li>问候（Hello）分组，用来发现和维持邻站的可达性。</li><li>数据库描述（Database Description）分组，向邻站给出自己的链路状态数据库的摘要信息。</li><li>链路状态请求（Link State Request）分组，向对方请求发送某些链路状态项目的详细信息。</li><li>链路状态更新（Link State Update）分组，用洪泛法对全网更新链路状态。这种分组是最复杂的，也是 OSPF 协议最核心的部分。</li><li>链路状态确认（Link State Acknowledgement）分组，对链路更新分组的确认。</li></ul></li><li>分组长度：包括首部在内的分组长度，以字节为单位。</li><li>路由器标识符：发送该分组的路由器的接口的 IP 地址。</li><li>鉴别类型：0（不用）和 1（口令）</li><li>鉴别：鉴别类型为 0 时就填入 0，鉴别类型为 1 时则填入 8 个字符的口令。</li></ul><p>OSPF 的特点：</p><ul><li>允许管理员给每条路由指派不同的代价（1 至 65535）。商用的网络在使用 OSPF 时，通常根据链路带宽来计算链路的代价。这种灵活性是 RIP 所没有的。</li><li>如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这叫做多路径间的<strong>负载平衡</strong>（load balancing）。在代价相同的多条路径上分配通信量是通信量工程中的简单形式。RIP 只能找出到某个网络的一条路径。</li><li>在 OSPF 路由器之间交换的分组都具有鉴别的功能，保证了仅在可信赖的路由器之间交换路由信息。（RIP 也具有简单的鉴别功能）</li><li>OSPF 支持可变长度的子网划分和无分类的编址 CIDR。（RIP2 也支持）</li><li>由于网络中的链路状态可能经常发生变化，因此 OSPF 让每一个链路状态都带上一个 32 位的序号，序号越大状态就越新。OSPF 规定，链路状态序号增长的速率不得超过 5 秒钟 1 次。这样，全部序号空间在 600 年内不会产生重复序号。</li></ul><h3 id="ospf-的工作过程">OSPF 的工作过程</h3><p>OSPF 规定，每两个相邻的路由器每隔 10 秒钟要交换一次「问候分组」，这样就能确知哪些邻站是可达的。在正常情况下，网络中传送的绝大多数 OSPF 分组都是问候分组。若有 40 秒钟没有收到某个相邻路由器发来的问候分组，则可认为该相邻路由器是不可达的，应立即修改链路状态数据库，并重新计算路由表。</p><p>其他的四种分组都是用来进行链路状态数据库的同步。所谓<strong>同步</strong>就是指不同路由器的链路状态数据库的内容是一样的。</p><p>当一个路由器开始工作时，它只能通过问候分组得知它有哪些相邻的路由器在工作，以及将数据发往相邻路由器所需的”代价“。如果所有的路由器都把自己的本地链路状态信息对全网进行广播，那么各路由器只要将这些信息综合起来就可得出链路状态数据库。但这样做开销太大，因此 OSPF 采用下面的办法。</p><p>OSPF 让每一个路由器用「数据库描述分组」和相邻路由器交换本数据库中已有的链路状态摘要信息。摘要信息主要就是指出有哪些路由器的链路状态信息（以及其序号）已经写入了数据库。之后，路由就使用「链路状态请求分组」向对方请求自己所缺少的某些链路状态项目的详细信息。通过一系列的这种分组交换，全网同步的链路数据库就建立了。</p><p>在网络运行的过程中，只要一个路由器的链路状态发生变化，该路由器就要使用「链路状态更新分组」，用洪泛法向全网更新链路状态。OSPF 使用的是<strong>可靠的洪泛法</strong>，可靠的洪泛法是在收到更新分组后要发送确认（收到重复的更新分组只需要发送一次确认）。</p><p><img src="/uploads/image/computer-networking/ospf-reliable-flooding.jpeg"></p><p>为了确保链路状态数据库与全网的状态保持一致，OSPF 还规定每隔一段时间，如 30 分钟，要刷新一次数据库中的链路状态。</p><p>由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此，当互联网规模很大时，OSPF 协议要比距离向量协议 RIP 好得多。</p><p>若 N 个路由器连接在一个以太网上，则每个路由器要向其他 N-1 个路由器发送链路状态信息，因而共有 N(N-1) 个链路状态要在这个以太网上传送。OSPF 协议对这种多点接入的局域网采用了<strong>指定的路由器</strong>（designated router）的方法，使广播的信息量大大减少。指定的路由器代表该局域网上所有的链路，向连接到该网络上的各路由器发送状态信息（?）。</p><h2 id="外部网关协议-bgp">外部网关协议 BGP</h2><p>在不同的 AS 之间不能使用内部网关协议（RIP 或 OSPF），主要有两个原因：</p><ol type="1"><li><strong>互联网的规模太大</strong>，使得 AS 之间的路由选择非常困难。连接在互联网主干网上的路由器，必须对任何有效的 IP 地址都能在路由表中找到匹配的目的网络。如果使用链路状态协议（如 OSPF），则每一个路由器必须维持一个很大的链路状态数据库。对于这样大的主干网用 Dijkstra 算法计算最短路径时花费的时间也太长。另外，由于 AS 使用的路径度量（代价）可能不同，因此，当一条路径通过几个不同的 AS 时，要计算出有意义的代价是不太可能的。比较合理的做法是在 AS 之间交换“可达性”信息。例如，“到达目的网络 N 可经过自治系统 ASx”。</li><li><strong>AS 之间的路由选择必须考虑有关策略</strong>。这些策略包括政治、安全或经济方面的考虑。例如，我国国内站点在互相传送数据报时不应经过国外兜圈子，特别是，不要经过某些对我国的安全有威胁的国家。这些策略都是由网络管理人员对每一个路由器进行设置的。</li></ol><p>由于上述情况，边界网关协议 BGP 只能是力求寻找一条能够到达目的网络且比较好的路由，而并非要寻找一条最佳路由。</p><h3 id="bgp-协议的三要点">BGP 协议的三要点</h3><p>在配置 BGP 时，每一个自治系统的管理员要选择至少一个路由器作为该自治系统的“BGP 发言人”。BGP 发言人往往就是 BGP 边界路由器（但也可以不是），每一个 BGP 发言人除了必须运行 BGP 协议外，还必须运行该自治系统所使用的内部网关协议（如 RIP 或 OSPF）。</p><p>一个 BGP 发言人与其他 AS 的 BGP 发言人要交换路由信息（因此，BGP 协议交换路由信息的结点数量级是自治系统个数的量级，这要比这些自治系统中的网络数少很多），要先建立 TCP 连接（端口 179），然后在此连接上交换 BGP 报文以建立 BGP 会话（session），利用 BGP 会话交换路由信息，如增加了新的路由，或撤销过时的路由，以及报告出差错的情况等等。使用 TCP 连接能提供可靠的服务，也简化了路由选择协议。使用 TCP 连接交换路由信息的两个 BGP 发言人，彼此成为对方的<strong>邻站</strong>（neighbor）或<strong>对等站</strong>（peer）。</p><p>在 BGP 刚开始运行时，BGP 的邻站是交换整个的 BGP 路由表。但以后只需要在发生变化时更新有变化的部分。这样做对节省网络带宽和减少路由器的处理开销方面都有好处。</p><p>BGP 采用了<strong>路径向量路由选择协议</strong>，它与距离向量协议（如 RIP）和链路状态协议（如 OSPF）都有很大的区别。下图给出一个 BGP 发言人交换路径向量的例子。AS2 的 BGP 发言人通过主干网的 BGP 发言人：“要到达网络 N1，N2，N3 和 N4 可经过 AS2。“主干网在收到这个通知后，就发出通知：”要到达网络 N1，N2，N3 和 N4 可沿路径（AS1, AS2）。“</p><p><img src="/uploads/image/computer-networking/bgp-path-vector-example.jpeg"></p><p>BGP 支持无分类域间路由选择 CIDR，因此 BGP 的路由表应当包括<strong>目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的自治系统序列</strong>。由于使用了路径向量，可以很容易地避免会兜圈子的路由：如果一个 BGP 发言人收到了一个路径通知，它要检查一下本自治系统是否在此通知的路径中。如果在这条路径中，就不能采用这条路径（因为会兜圈子）。</p><p>BGP 可以很容易地解决距离向量路由选择算法中的“坏消息传播得慢”这一问题。但某个路由器或链路出故障时，由于 BGP 发言人可以从不止一个邻站获得路由信息，因此很容易选择出新的路由。</p><h3 id="bgp-协议的报文格式">BGP 协议的报文格式</h3><p>通用首部：</p><p><img src="/uploads/image/computer-networking/bgp-path-vector-example.jpeg"></p><ul><li>标记：用来鉴别收到的 BGP 报文，当不使用鉴别时要置为全 1。</li><li>长度：以字节为单位，最小值是 19（只有首部），最大值是 4096。</li><li>类型：1 到 4，分别对应 4 种报文。<ul><li>OPEN 报文，用来与相邻的另一个 BGP 发言人建立关系，使通信初始化。如果对方接受，就用 KEEPALIVE 报文响应，这样，两个 BGP 发言人的邻站关系就建立了。</li><li>UPDATE 报文，BGP 协议的核心内容，BGP 发言人可以用 UPDATE 报文撤销它以前通知过的路由，也可以宣布增加新的路由。撤销路由可以一次撤销许多条，但增加新路由时，每个更新报文只能增加一条。</li><li>KEEPALIVE 报文，用来周期性地（一般是 30 秒）证实邻站的连通性。KEEPALIVE 报文只有 19 字节（首部），因此不会造成网络上太大的开销。</li><li>NOTIFICATION 报文，用来发送检测到的错误。</li></ul></li></ul><p>报文主体：</p><ul><li>OPEN：6 个字段，版本、本自治系统号、保持时间（秒）、BGP 标识符（通常就是该路由器的 IP 地址）、可选参数长度 和 可选参数。</li><li>UPDATE：5 个字段，不可行路由长度（指明下一字段的长度）、撤销的路由、路径属性总长度（指明下一字段的长度）、路径属性 和 网络层可达性信息（定义发出此报文的网络，包括网络前缀的位数、IP 地址前缀）。</li><li>KEEPALIVE：无字段，只有首部。</li><li>NOTIFICATION： 3 个字段，差错代码、差错子代码 和 差错数据。</li></ul><h1 id="路由器的构成">路由器的构成</h1><p>路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组。路由器的转发分组正是网络层的主要工作。</p><p><img src="/uploads/image/computer-networking/router-structure.jpeg"></p><p>整个路由器结构可划分为两大部分：<strong>路由选择</strong>部分和<strong>分组转发</strong>部分。路由选择部分也叫做控制部分，其核心构件是路由选择处理机。路由选择处理机的任务是根据所选定的协议构造路由表，并更新和维护路由表。（如前面介绍的那样）本节讨论分组转发部分，它由三部分组成：<strong>交换结构</strong>、一组<strong>输入端口</strong>和一组<strong>输出端口</strong>（这里指的是硬件端口）。</p><p>“转发”和“路由选择”是有区别的。“转发”就是路由器根据转发表把收到的 IP 数据报从合适的端口转发出去，仅仅涉及到一个路由器。但“路由选择”则涉及到很多路由器，路由表则是许多路由器协同工作的结果。</p><p>“转发表“和”路由表“也是有区别的。”路由表“一般包含从目的网络到下一跳（用 IP 地址表示）的映射，而”转发表“是从路由表得出的，包含完成转发功能所必需的信息：从目的网络到输出端口和某些 MAC 地址信息的映射（如下一跳的以太网地址）。将转发表和路由表用不同的数据结构实现会带来一些好处，因为在转发分组时，转发表的结构应当使查找过程最优化，但路由表则需要对网络拓扑变化的计算最优化。路由表总是用软件实现的，但转发表甚至可以用特殊的硬件来实现。请注意，<strong>在讨论路由选择的原理时，往往不去区分转发表和路由表的区别，笼统地使用路由表这一名词</strong>。</p><p>输入端口和输出端口里的方框 1、2 和 3 分别代表物理层、数据链路层和网络层的处理模块。</p><ul><li>物理层进行比特的接收。</li><li>数据链路层则按照链路层协议接收帧。在把帧的首部和尾部剥去后，分组就被送入网络层的处理模块。</li><li>若接收到的是交换路由信息的分组（如 RIP 或 OSPF 分组等），则交给路由选择处理机。若接收到的是数据分组，则按照分组首部中的目的地址查找转发表，根据得到的结果，分组就经过交换结构到达合适的输出端口。</li></ul><p>路由器必须以很高的速率转发分组。分组在输入端口和输出端口都可能会在队列中排队等候处理。若分组处理的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少到零，这就使后面再进入队列的分组被丢弃。以前讨论的分组丢失就是发生在路由器中的输入和输出队列产生溢出的时候。当然，设备或线路出故障也可能使分组丢失。</p><p><img src="/uploads/image/computer-networking/router-forwarding.jpeg"></p><p>交换结构是路由器的关键构件。正是这个交换结构把分组从一个输入端口转移到某个合适的输出端口。下图给出了三种常用的交换方法。</p><p><img src="/uploads/image/computer-networking/router-switching-fabric.jpeg"></p><ul><li>存储器：最早使用的路由器就是利用普通的计算机，用 CPU 作为路由器的路由选择处理机。分组从输入端口复制到存储器中，路由器处理机从分组首部提取目的地址，查找路由表，再将分组复制到合适的输出端口的缓存中。若存储器的带宽（读或写）为每秒 M 个分组，那么路由器的交换速率一定小于 M/2。因为存储器对分组的读和写需要花费的时间是同一个量级。许多现代的路由器也通过存储器进行交换，不同的是，目的地址的查找和分组在存储器中的缓存都是在输入端口进行的。</li><li>总线：数据报从输入端口通过共享的总线直接传送到合适的输出端口，而不需要路由选择处理机的干预（复制）。但是，由于总线是共享的，因此在同一时间只能有一个分组在总线上传送。路由器的转发带宽受总线速率的限制。</li><li><p>互连网络：通过纵横交换结构（crossbar switch fabric）进行交换，它有 2N 条总线，可以使 N 个输入端口和 N 个输出端口相连接，这取决于相应的交叉节点是使水平总线和垂直总线连通还是断开。</p><p>当输入端口收到一个分组时，就将它发送到与该输入端口相连的水平总线上。若通向所要转发的输出端口的垂直总线是空闲的，则在这个结点将垂直总线与水平总线接通，然后将该分组转发到这个输出端口。若垂直总线被占用，则被阻塞，必须在输入端口排队。</p></li></ul><h1 id="ipv6">IPv6</h1><p>IPv6 仍支持无连接的传送，但将协议数据单元 PDU 称为分组，而不是 IPv4 的数据报。方便起见，这里仍采用数据报这一名词。</p><p>IPv6 引进到主要变化：</p><ul><li>更大的地址空间。从 IPv4 的 32 位 增大到 128 位。</li><li>扩展的地址层次结构。由于地址空间很大，因此可以划分更多的层次。</li><li>灵活的首部格式。IPv6 的首部与 IPv4 的并不兼容。IPv6 定义了许多可选的扩充首部。</li><li>改进的选项。IPv6 的首部长度是固定的，选项放在有效载荷中。</li><li>允许协议继续扩充。</li><li>支持即插即用。因此 IPv6 不需要使用 DHCP。</li><li>支持资源的预分配。</li><li>首部改为 8 字节对齐。IPv4 是 4 字节对齐。</li></ul><h2 id="基本首部">基本首部</h2><p>IPv6 数据报由两大部分组成，即<strong>基本首部</strong>（base header）和<strong>有效载荷</strong>（payload）。有效载荷允许有零个或多个<strong>扩展首部</strong>（extension header），再后面是数据部分。注意，扩展首部并不属于 IPv6 数据报的首部。</p><p><img src="/uploads/image/computer-networking/ipv6-header.jpg"></p><p>与 IPv4 相比，IPv6 对首部中的某些字段进行了如下的更改：</p><ul><li>取消了首部长度字段，因为它的首部长度是固定的（40 字节）。</li><li>取消了服务类型字段，优先级和流标号字段实现了服务类型的功能。</li><li>取消了总长度字段，改用有效载荷长度字段。</li><li>取消了标识、标志和片偏移字段，这些功能包含在分片扩展首部中。</li><li>把 TTL 字段改称为跳数限制字段，意义不变。</li><li>取消了协议字段，改用下一个首部字段。</li><li>取消了检验和字段，不进行差错检测。</li><li>取消了选项字段，用扩展首部实现选项功能。</li></ul><p>基本首部：</p><ul><li>版本：6。</li><li>通信量类：区分不同的 IPv6 数据报的类别或优先级。</li><li>流标号：IPv6 的一个新的机制是<strong>支持资源预分配</strong>，并且允许路由器把每一个数据报与一个给定的资源分配相联系。IPv6 提出流（flow）的抽象概念。所谓<strong>流就是互联网上从特定源点到特定终点（单播或多播）的一系列数据报（如实时音频或视频传输），而在这个流所经过的路径上的路由器都保证指明的服务质量</strong>。所有属于同一个流的数据报都具有同样的流标号。因此，流标号对实时音频/视频数据的传送特别有用。对于传统的非实时数据（如电子邮件），流标号则没有用处，把它置 0 即可。</li><li>有效载荷长度：除基本首部以外的字节数。最大值是 64 KB（65535 字节）。</li><li>下一个首部：当没有扩展首部时，它的值指出了首部后面的数据应交付 IP 层上面的哪一个高层协议（例如：6 或 17 分别表示交付 TCP 或 UDP）。当有扩展首部时，它的值标识第一个扩展首部的类型。</li><li>跳数限制：最大 255 跳。</li></ul><p>扩展首部：6 种。（1）逐跳选项；（2）路由选择；（3）分片；（4）鉴别；（5）封装安全有效载荷；（6）目的站选项。每一个扩展首部都由若干个字段组成，它们的长度也各不同。但所有扩展首部的第一个字段都是 8 位的“下一个首部”字段。当使用多个扩展首部时，应按以上的顺序出现。高层首部总是放在最后面。</p><p>IPv4 的数据报如果在首部中使用了选项，那么沿着数据报传送的路径上的每一个路由器都必须对这些选项一一进行检查，这就降低了路由器处理数据报的速度。然而实际上很多的选项在途中的路由器上是不需要检查的（因为不需要使用这些选项的信息）。<strong>IPv6 把选项的功能都放在扩展首部中，并把扩展首部留给路径两端的源点和终点的主机来处理</strong>，而数据报途中经过的路由器不处理这些扩展首部（只有一个首部例外，即逐跳选项扩展首部），这样就<strong>大大提高了路由器的处理效率</strong>。</p><h2 id="ipv6-地址">IPv6 地址</h2><p>一般来讲，一个 IPv6 数据报的目的地址可以是以下三种基本类型地址之一：</p><ol type="1"><li>单播（unicast） 传统的点对点通信。</li><li>多播（multicast） 一点对多点通信，IPv6 没有采用广播的术语，而是将广播看作多播的一个特例。</li><li>任播（anycast） 任播的终点是一组计算机，但数据报只交付其中的一个，通常是距离最近的一个。</li></ol><p>IPv6 把实现 IPv6 的主机和路由器均称为<strong>结点</strong>。一个结点可能有多个与链路相连的接口，IPv6 给每个接口指派一个 IP 地址。一个结点可以有多个单播地址，而其中任何一个地址都可以当作到达该结点的目的地址。（IPv4 也是这么做的啊）</p><p>IPv6 使用<strong>冒号十六进制记法</strong>，它把每个 16 位的值用十六进制值表示，各值之间用冒号分隔。</p><ul><li>在十六进制记法中，允许把数字前面的 0 省略。例如，<code>FF05:0:0:0:0:0:0:B3</code>。</li><li>允许零压缩（zero compression），一连串连续的零可以为一对冒号取代。为了保证零压缩有一个不含混的解释，规定在一个地址中只能使用一次零压缩。例如，<code>FF05::B3</code>。</li><li>可结合使用点分十进制记法的后缀（冒号分隔的每个值是两个字节的量，点分隔的每个值是一个字节的量）。这种结合在 IPv4 向 IPv6 的转换阶段特别有用。例如，<code>：：128.10.2.1</code>。</li><li>CIDR 的斜线记法仍然可用。</li></ul><p>IPv6 的地址分类</p><table><thead><tr class="header"><th>地址类型</th><th>二进制前缀</th></tr></thead><tbody><tr class="odd"><td>未指明地址（1 个）</td><td>00...0（128 位），<code>::/128</code></td></tr><tr class="even"><td>环回地址（1 个）</td><td>00...1（128 位），<code>::1/128</code></td></tr><tr class="odd"><td>多播地址（地址总数的 1/256）</td><td>11111111（8 位），<code>FF00::/8</code></td></tr><tr class="even"><td>本地链路单播地址（地址总数的 1/1024）</td><td>1111111010（10 位），<code>FE80::/10</code></td></tr><tr class="odd"><td>全球单播地址</td><td>除上述四种以外，所有其他的二进制前缀</td></tr></tbody></table><p>本地链路单播地址（Link-Local Unicast Address） 有些单位的网络使用 TCP/IP 协议，但并没有连接到互联网上。连接在这样的网络上的主机都可以使用这种本地地址进行通信，但不能和互联网上的其他主机通信。</p><h2 id="从-ipv4-向-ipv6-过渡">从 IPv4 向 IPv6 过渡</h2><p>向 IPv6 过渡只能采用逐步演进的方法。</p><h3 id="双协议栈">双协议栈</h3><p>双协议栈（dual stack）是指在完全过渡到 IPv6 之前，使一部分主机（或路由器）装有双协议栈：一个 IPv4 和一个 IPv6。在和 IPv6 主机通信时采用 IPv6 地址，而和 IPv4 主机通信时则采用 IPv4 地址。双协议栈如何知道目的主机采用哪一种地址呢？使用域名系统 DNS 来查询。若 DNS 返回的是 IPv4 地址，双协议栈的源主机就使用 IPv4 地址。当返回的是 IPv6 地址，源主机就使用 IPv6 地址。</p><p>图示的情况是 A 和 F 都使用 IPv6，所以 A 向 F 发送 IPv6 数据报，路径是 <code>A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; F</code>。但 B 到 E 这段路径是 IPv4 网络，B 不能向 C 转发 IPv6 数据报。它要把 IPv6 数据报首部转换为 IPv4 数据报再发送给 C。C 再转发给 D。D 将 IPv4 数据报恢复成 IPv6 数据报再转发给 E。主要注意的是，IPv6 <strong>首部中的某些字段却无法恢复</strong>。这种信息的损失是使用首部转换方法所不可避免的。</p><p><img src="/uploads/image/computer-networking/ipv6-dual-stack.jpeg"></p><h3 id="隧道技术">隧道技术</h3><p>隧道技术（tunneling）的要点是，在 IPv6 数据报要进入 IPv4 网络时，把 IPv6 数据报封装成为 IPv4 数据报。整个 IPv6 数据报变成了 IPv4 数据报的数据部分。当 IPv4 数据报离开 IPv4 网络中的隧道时，再把数据部分交给主机的 IPv6 协议栈。请注意图中，在隧道中传送的数据报的源地址是 B 而目的地址是 E。</p><p>要使双协议栈的主机知道 IPv4 数据报里封装的是 IPv6 数据报，必须把 IPv4 首部的协议字段置为 41。</p><p><img src="/uploads/image/computer-networking/ipv6-tunneling.jpeg"></p><h2 id="icmpv6">ICMPv6</h2><p>和 IPv4 一样，IPv6 也不保证数据报的可靠交付，因此 IPv6 也需要使用 ICMP 来反馈一些差错信息。新的版本称为 ICMPv6，它比 ICMPv4 要复杂得多。<strong>地址解析协议 ARP 和网际组管理协议 IGMP 的功能都已被合并到 ICMPv6 中</strong>。ICMPv6 是面向报文的协议，它利用报文来报告差错，获取信息，探测邻站或管理多播通信。</p><h1 id="ip-多播">IP 多播</h1><p>与单播相比，在一对多的通信中，多播可大大节约网络资源。</p><p><img src="/uploads/image/computer-networking/ip-unicast-and-multicast.jpeg"></p><p>在互联网范围的多播要靠路由器来实现，这些路由器必须增加一些能够识别多播数据报的软件。能够运行多播协议的路由器称为<strong>多播路由器</strong>（multicast router）。</p><p>在互联网上进行多播就叫做 IP 多播。IP 多播所传送的分组需要使用多播 IP 地址。显然，这个多播数据报的目的地址一定不能写入主机的 IP 地址。这是因为在同一时间可能有成千上万台主机加入到同一个多播组。多播数据报不可能在其首部写入这样多的主机的 IP 地址。<strong>在多播数据报的目的地址写入的是多播组的标识符</strong>，然后设法让加入到这个多播组的主机的 IP 地址与多播组的标识符关联起来。</p><p>其实多播组的标识符就是 IP 地址中的 D 类地址，前四位是 1110，因此范围是 224.0.0.0 到 239.255.255.255。这样，D 类地址共可标识 2^28 个多播组。多播数据报也是“尽最大努力交付“，不保证可靠性。因此，多播数据报和一般的 IP 数据报的区别就是它<strong>使用 D 类 IP 地址作为目的地址</strong>，并且首部中的<strong>协议值是 2，表明使用网际组管理协议 IGMP</strong>。</p><p>显然，<strong>多播地址只能用于目的地址，而不能用于源地址</strong>。此外，<strong>对多播数据报不产生 ICMP 差错报文</strong>。因此，若在 PING 命令后面键入多播地址，将永远不会收到响应。</p><p>IP 多播可以分为两种。一种是只在本地局域网上进行硬件多播，另一种则是在互联网的范围进行多播。前一种虽然比较简单，但很重要，因为现在大部分主机都是通过局域网接入到互联网的。在互联网上进行多播的最后阶段，还是要把多播数据报在局域网上用硬件多播交付多播组的所有成员。</p><h2 id="硬件多播">硬件多播</h2><p>以太网地址块的高 24 位为 <code>00-00-5E</code>，因此 TCP/IP 协议使用的以太网多播地址块的范围是从 <code>00-00-5E-00-00-00</code> 到 <code>00-00-5E-FF-FF-FF</code>。<strong>以太网硬件地址字段中的第 1 字节的最低位为 1 时即为多播地址</strong>。因此，以太网多播地址的范围是从 <code>01-00-5E-00-00-00</code> 到 <code>01-00-5E-7F-FF-FF</code>（第 25 位的 0 哪来的？）。</p><p><img src="/uploads/image/computer-networking/ip-hardware-multicast.jpeg"></p><p>在每一个地址中，只有 23 位可用作多播，这只能和 D 类 IP 地址中的 23 位有一一对应的关系。D 类 IP 地址可供分配的有 28 位，可见前 5 位不能用来构成以太网硬件地址。例如，IP 多播地址 224.128.64.32（即 <code>E0-80-40-20</code>）和 224.0.64.32（即 <code>E0-00-40-20</code>）转换成以太网的硬件多播地址都是 <code>01-00-5E-00-40-20</code>。由于多播 IP 地址与以太网硬件地址的映射关系不是唯一的，因此收到多播数据报的主机，还要在 IP 层利用软件进行过滤，把不是本主机要接收的数据报丢弃。</p><h2 id="网际组管理协议-igmp">网际组管理协议 IGMP</h2><p>网际组管理协议 IGMP 并非是在互联网范围内对所有多播组成员进行管理的协议。IGMP 不知道 IP 多播组包含的成员数，也不知道这些成员都分布在哪些网络上，等等。IGMP 协议是让<strong>连接在本地局域网</strong>上的多播路由器知道<strong>本局域网上</strong>是否有主机（严格来讲，是主机上的某个进程）参加或退出了某个多播组。所以，IGMP 的使用范围是本地局域网。</p><p>仅有 IGMP 协议是不能完成多播任务的。连接在局域网上的多播路由器还必须和互联网上的其他多播路由器协同工作，以便把多播数据报用最小代价传送给所有的组成员。这就需要使用<strong>多播路由选择协议</strong>。然而多播路由选择协议要比单播路由选择协议复杂的多。</p><ul><li>多播转发必须动态地适应多播组成员的变化（这时网络拓扑并未发生变化）。单播路由选择通常是在网络拓扑发生变化时才需要更新路由。</li><li>多播路由器在转发多播数据报时，不能仅仅根据多播数据报中的目的地址，还要考虑这个多播数据报从什么地方来和要到什么地方去。原因是，没有加入多播组的主机、加入多播组 A 的主机、加入多播组 B 的主机<strong>都可以</strong>向多播组 B 发送多播数据报。</li><li>多播数据报可以由没有加入多播组的主机发出（同上），也可以通过没有组成员接入的网络（例如，两个网路距离很远，必须通过中间网络转发）。</li></ul><p>和 ICMP 相似，IGMP 使用 IP 数据报传递其报文，但它也向 IP 提供服务。</p><p>IGMP 的工作可分为两个阶段。</p><ol type="1"><li>当某台主机加入新的多播组时，该主机应向多播组的多播地址发送一个 IGMP 报文，声明自己要成为改组的成员。本地的多播路由器收到 IGMP 报文后，还要利用多播路由选择协议把这种组成员关系转发给互联网上的其他多播路由器。</li><li>组成员关系是动态的。本地多播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否还继续是组的成员。只要有一台主机对某个组响应，那么多播路由器就认为这个组是活跃的。但一个组在经过几次的探询后仍然没有一台主机响应，多播路由器就认为本网络上的主机已经离开了这个组，因此也就不再把这个组的成员关系转发给其他的多播路由器。</li></ol><p>IGMP 设计得很仔细，避免了多播控制信息给网络增加大量的开销。IGMP 采用的一些具体措施如下：</p><ul><li>在主机和多播路由器之间的所有通信都是使用 IP 多播。只要有可能，携带 IGMP 报文的数据报都用硬件多播来传送。</li><li>多播路由器在探询组成员关系时，只需要对所有的组发送一个请求信息的询问报文，而不需要对每一个组发送一个询问报文。默认的询问速率是每 125 秒一次。</li><li>当同一个网络上连接有几个多播路由器时，它们能够迅速和有效地选择其中的一个来探询主机的成员关系。</li><li>在 IGMP 的询问报文中有一个数值 N，它指明一个最长响应时间（默认 10 秒）。当收到询问时，主机在 0 到 N 之间随机选择发送响应所需经过的时延。若一台主机同时参加了几个多播组，则主机对每一个多播组选择不同的随机数。对应于最小时延的响应最先发送。</li><li>同一个组内的每一台主机都要监听响应（响应是 IP 多播发送的，因此同一个组内的所有成员都能收到），只要有本组的其他主机先发送了响应，自己就可以不再发送响应了。这样就抑制了不必要的通信量。</li></ul><p>多播路由器并不需要保留组成员关系的准确记录，因为向局域网上的组成员转发数据报是使用硬件多播。多播路由器只需要知道网络上是否有主机是本组成员即可。</p><p>如果一台主机上有多个进程都加入了某个多播，那么这台主机对发给这个多播组的每个多播数据报只接收一个副本，然后给主机中的每一个进程发送一个本地复制的副本。</p><p>最后强调，多播数据报的发送者和接收者都不知道（也无法找出）一个多播组的成员有多少，以及这些成员是哪些主机。任何应用进程都可以在任何时候向任何一个多播组发送多播数据报，而并不需要加入这个多播组。</p><h2 id="多播路由选择协议">多播路由选择协议</h2><p>多播协议已成为建议标准，但多播路由选择协议尚未标准化。</p><p>多播路由选择实际上就是要找出以源主机为根节点的<strong>多播转发树</strong>。对不同的多播组对应于不同的多播转发树。同一个多播组，对不同的源点也会有不同的多播转发树。</p><p>已有了多种实用的多播路由选择协议，它们在转发多播数据报时使用了以下的三种方法：</p><ol type="1"><li><p><strong>洪泛与剪除</strong>。这种方法适用于较小的多播组，而所有的组成员接入的局域网也是相邻的。</p><p>一开始，路由转发多播数据报使用洪泛的方法（广播）。为了避免兜圈子，采用了<strong>反向路径广播</strong> RPB（Reverse Path Broadcasting）的策略。RPB 的要点是：每一个路由器在收到一个多播数据报时，先检查数据报是否是从源点经最短路径传送来的。进行这种检查很容易，只要寻找从本路由器到源点的最短路径（反向路径）上的第一个路由器。若是刚才把多播数据报送来的路由器，就向所有其他方向转发收到的多播数据报。若不是，就丢弃。如果有好几个相邻路由器都处在最短路径上，那么只能选择一条最短路径，选择的准则是看谁的 IP 最小。</p><p>如果在多播转发树上的某个路由器发现它的下游树枝已没有该多播组的成员，就应把它和下游的树枝一起剪除。当某个树枝有新增加的组成员时，可以再接入到多播转发树上。</p><p><img src="/uploads/image/computer-networking/ip-multicast-rpb.jpeg"></p></li><li><p><strong>隧道技术</strong>（tunneling）。隧道技术适用于多播组的位置在地理上很分散的情况。</p><p>路由器对多播数据报进行再次封装，即加上普通数据报的首部，使之成为向单一目的站发送的单播（unicast）数据报，然后通过隧道发送。</p><p>单播数据报到达目的站的路由器后，再剥去首部，恢复成原来的数据报，继续向多个目的站转发。</p><p><img src="/uploads/image/computer-networking/ip-multicast-tunneling.jpeg"></p></li><li><p><strong>基于核心的发现技术</strong>。这种方法对于多播组的大小在较大范围内变化时都合适。这种方法对每一个多播组 G 指定一个核心路由器，给出它的 IP 单播地址。核心路由器创建出对应于多播组 G 的转发树。如果有一个路由器 R1 向核心路由器 R2 发送数据报，若发送的是多播数据报且目的地址是 G，则 R2 就转发这个数据报。若发送的是请求加入 G 的数据报，R2 就把这个信息加到它的路由中，并用隧道技术向 R1 转发每一个多播数据报的副本。这样，参加到多播组 G 的路由器就从核心向外增多了，扩大了多播转发树的覆盖范围。</p></li></ol><h1 id="vpn-和-nat">VPN 和 NAT</h1><h2 id="虚拟专用网-vpn">虚拟专用网 VPN</h2><p>假定在一个机构内部的计算机通信也是采用 TCP/IP 协议，那么从原则上讲，对于这些计算机可以由该机构自行分配 IP 地址。让这些计算机仅在本地使用的有效的 IP 地址称为<strong>本地地址</strong>，而向互联网的管理机构申请的全球唯一的 IP 地址称为<strong>全球地址</strong>。</p><p>使用本地地址可以大大节约宝贵的 IP 地址资源。但是，如果任意选择一些 IP 地址作为本地地址，那么在某种情况下可能会引起一些麻烦。例如，有时机构内部的某台主机需要和互联网连接，那么这种仅在内部使用的本地地址就有可能和互联网中某个 IP 地址重合。</p><p>为了解决这一问题，RFC 1918 指明了一些<strong>专用地址</strong>（private address）。这些地址只能用于一个机构的内部通信，而不能用于和互联网上的主机通信。在互联网中的所有路由器，对目的地址是专用地址的数据报一律不进行转发。</p><p>三个专用地址块分别是：</p><ol type="1"><li>10.0.0.0 到 10.255.255.255 （或记为 10.0.0.0/8，又称为 24 位块，相当于 1 个 A 类网络）</li><li>172.16.0.0 到 172.31.255.255（或记为 172.16.0.0/12，又称为 20 位块，相当于 16 个 B 类网络）</li><li>192.168.0.0 到 192.168.255.255 （或记为 192.168.0.0/16，又称为 16 位块，相当于 256 个 C 类网络）</li></ol><p>采用这样的专用 IP 地址的互联网络称为专用互联网或本地互联网，简称<strong>专用网</strong>。专用地址也叫做<strong>可重用地址</strong>（reusable address）。</p><p>有时一个很大的机构的许多部门分布的范围很广，这些部分经常要互相交换信息。这可以有两种方法。（1）租用电信公司的通信线路。简单方便但价格昂贵。（2）利用互联网作为本机构各专用网之间的通信载体（利用 IP 隧道技术），这样的专用网又称为<strong>虚拟专用网</strong> VPN（Virtual Private Network）。虚拟表示“好像是”，VPN 只是在效果上和真正的专用网一样。一个机构要构建自己的 VPN 就必须为它的每一个场所购买专门的硬件和软件，并进行配置，使每一个场所的 VPN 系统都知道其他场所的地址。</p><p><img src="/uploads/image/computer-networking/ip-vpn.jpeg"></p><h2 id="网络地址转换-nat">网络地址转换 NAT</h2><p>下面讨论另一种情况，专用网内部的一些主机想和互联网上的主机通信。</p><p>最简单的办法就是设法再申请一些全球 IP 地址。但这在很多情况下是很不容易做到的。目前采用得最多的方法是<strong>网络地址转换</strong> NAT（Network Address Translation）。</p><p>这种方法需要在专用网络连接到互联网的路由器上安装 NAT 软件。装有 NAT 软件的路由器叫做 NAT 路由器，它至少有一个（也可以有多个）有效的全球 IP 地址。所有使用本地地址的主机在和外界通信时，都要在 NAT 路由器上将其本地地址转换成全球 IP 地址。当 NAT 路由器具有 n 个全球 IP 地址时，专用网内部最多可以同时有 n 台主机接入到互联网。专用网内较多数量的主机，可以轮流使用 n 个全球 IP 地址。</p><p><img src="/uploads/image/computer-networking/ip-nat.jpeg"></p><p>显然，通过 NAT 路由器的通信必须由专用网内的主机发起（因为内部主机没有全球 IP 地址，而路由器不转发目的地址为本地地址的数据报）。因此，这种专用网内部的主机不能充当服务器用。</p><p>为了更加有效地利用 NAT 路由器上的全球 IP 地址，现在常用的 NAT 转换表把运输层的端口号也利用上。这样，就可以使多个拥有本地地址的主机，共用一个 NAT 路由器上的全球 IP 地址。使用端口号的 NAT 也叫做<strong>网络地址与端口转换</strong> NAPT（Network Address and Port Translation），但在许多文献中不做区分，都使用 NAT。</p><p>从层次的角度看，NAPT 的机制有些特殊。普通路由器在转发 IP 数据报时，对于源 IP 地址或目的 IP 地址都是不改变的。但 NAT 路由器在转发 IP 数据报时，一定要更换其 IP 地址。其次，普通路由器在转发分组时，是工作在网络层。但 NAPT 路由器还要查看和转换运输层的端口号，而这本来应当属于运输层的范畴。</p></div><div class="popular-posts-header">相关文章</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/computer-networking/application-layer/" rel="bookmark">应用层</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/computer-networking/transport-layer/" rel="bookmark">运输层</a></div></li></ul><footer class="post-footer"><div class="post-tags"> <a href="/tags/Computer-Networking/" rel="tag"># Computer Networking</a> <a href="/tags/IP/" rel="tag"># IP</a> <a href="/tags/ICMP/" rel="tag"># ICMP</a> <a href="/tags/IGMP/" rel="tag"># IGMP</a> <a href="/tags/ARP/" rel="tag"># ARP</a></div><div class="post-nav"><div class="post-nav-item"><a href="/programming/leetcode/convert-sorted-list-to-binary-search-tree/" rel="prev" title="Convert Sorted List to Binary Serch Tree"><i class="fa fa-chevron-left"></i> Convert Sorted List to Binary Serch Tree</a></div><div class="post-nav-item"> <a href="/programming/leetcode/longest-chunked-palindrome-decomposition/" rel="next" title="Longest Chunked Palindrome Decomposition">Longest Chunked Palindrome Decomposition<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#网际协议-ip"><span class="nav-number">1.</span> <span class="nav-text">网际协议 IP</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ip-地址"><span class="nav-number">2.</span> <span class="nav-text">IP 地址</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#分类的-ip-地址"><span class="nav-number">3.</span> <span class="nav-text">分类的 IP 地址</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ip-地址和硬件地址"><span class="nav-number">3.1.</span> <span class="nav-text">IP 地址和硬件地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#地址解析协议-arp"><span class="nav-number">3.2.</span> <span class="nav-text">地址解析协议 ARP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ip-数据报的格式"><span class="nav-number">3.3.</span> <span class="nav-text">IP 数据报的格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#转发分组的流程"><span class="nav-number">3.4.</span> <span class="nav-text">转发分组的流程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#划分子网"><span class="nav-number">4.</span> <span class="nav-text">划分子网</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#从两级-ip-到三级-ip"><span class="nav-number">4.1.</span> <span class="nav-text">从两级 IP 到三级 IP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#子网掩码"><span class="nav-number">4.2.</span> <span class="nav-text">子网掩码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用子网时分组的转发"><span class="nav-number">4.3.</span> <span class="nav-text">使用子网时分组的转发</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#无分类编址构造超网"><span class="nav-number">5.</span> <span class="nav-text">无分类编址（构造超网）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#网络前缀"><span class="nav-number">5.1.</span> <span class="nav-text">网络前缀</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最长前缀匹配"><span class="nav-number">5.2.</span> <span class="nav-text">最长前缀匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用二叉线索查找路由"><span class="nav-number">5.3.</span> <span class="nav-text">使用二叉线索查找路由</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#网际控制报文协议-icmp"><span class="nav-number">6.</span> <span class="nav-text">网际控制报文协议 ICMP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#差错报告报文"><span class="nav-number">6.1.</span> <span class="nav-text">差错报告报文</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#询问报文"><span class="nav-number">6.2.</span> <span class="nav-text">询问报文</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#icmp-应用举例"><span class="nav-number">6.3.</span> <span class="nav-text">ICMP 应用举例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#路由选择协议"><span class="nav-number">7.</span> <span class="nav-text">路由选择协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#理想的路由算法"><span class="nav-number">7.1.</span> <span class="nav-text">理想的路由算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分层次的路由选择协议"><span class="nav-number">7.2.</span> <span class="nav-text">分层次的路由选择协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内部网关协议-rip"><span class="nav-number">7.3.</span> <span class="nav-text">内部网关协议 RIP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#距离向量算法"><span class="nav-number">7.3.1.</span> <span class="nav-text">距离向量算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rip-协议的报文格式"><span class="nav-number">7.3.2.</span> <span class="nav-text">RIP 协议的报文格式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内部网关协议-ospf"><span class="nav-number">7.4.</span> <span class="nav-text">内部网关协议 OSPF</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关于-rip-和-ospf-三个要点的总结"><span class="nav-number">7.4.1.</span> <span class="nav-text">关于 RIP 和 OSPF 三个要点的总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ospf-的区域划分"><span class="nav-number">7.4.2.</span> <span class="nav-text">OSPF 的区域划分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ospf-协议的报文格式"><span class="nav-number">7.4.3.</span> <span class="nav-text">OSPF 协议的报文格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ospf-的工作过程"><span class="nav-number">7.4.4.</span> <span class="nav-text">OSPF 的工作过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#外部网关协议-bgp"><span class="nav-number">7.5.</span> <span class="nav-text">外部网关协议 BGP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bgp-协议的三要点"><span class="nav-number">7.5.1.</span> <span class="nav-text">BGP 协议的三要点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bgp-协议的报文格式"><span class="nav-number">7.5.2.</span> <span class="nav-text">BGP 协议的报文格式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#路由器的构成"><span class="nav-number">8.</span> <span class="nav-text">路由器的构成</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ipv6"><span class="nav-number">9.</span> <span class="nav-text">IPv6</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本首部"><span class="nav-number">9.1.</span> <span class="nav-text">基本首部</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ipv6-地址"><span class="nav-number">9.2.</span> <span class="nav-text">IPv6 地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从-ipv4-向-ipv6-过渡"><span class="nav-number">9.3.</span> <span class="nav-text">从 IPv4 向 IPv6 过渡</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#双协议栈"><span class="nav-number">9.3.1.</span> <span class="nav-text">双协议栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#隧道技术"><span class="nav-number">9.3.2.</span> <span class="nav-text">隧道技术</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#icmpv6"><span class="nav-number">9.4.</span> <span class="nav-text">ICMPv6</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ip-多播"><span class="nav-number">10.</span> <span class="nav-text">IP 多播</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#硬件多播"><span class="nav-number">10.1.</span> <span class="nav-text">硬件多播</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网际组管理协议-igmp"><span class="nav-number">10.2.</span> <span class="nav-text">网际组管理协议 IGMP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多播路由选择协议"><span class="nav-number">10.3.</span> <span class="nav-text">多播路由选择协议</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#vpn-和-nat"><span class="nav-number">11.</span> <span class="nav-text">VPN 和 NAT</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#虚拟专用网-vpn"><span class="nav-number">11.1.</span> <span class="nav-text">虚拟专用网 VPN</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络地址转换-nat"><span class="nav-number">11.2.</span> <span class="nav-text">网络地址转换 NAT</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="菜农陈文生" src="/uploads/avatar/nekosensei.png"><p class="site-author-name" itemprop="name">菜农陈文生</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">175</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">11</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">169</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/cncws" title="GitHub → https://github.com/cncws" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a></span><span class="links-of-author-item"><a href="mailto:1031616423@qq.com" title="E-Mail → mailto:1031616423@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">菜农陈文生</span></div><script src="//cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="//cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script><script src="/js/aplayer-el.js"></script><script src="//unpkg.com/video.js/dist/video.min.js"></script><script src="/js/videojs-bilibili.js"></script><script src="/js/videojs-bilibili-el.js"></script></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script><script src="/js/local-search.js"></script><div id="pjax"><script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Axl15EIRi5o5AatKaxXxV4Oq-gzGzoHsz',
      appKey     : 'E0qm04UjsP0qQN1l8ME3GQ25',
      placeholder: "Just go go",
      avatar     : 'identicon',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script></div></body></html>