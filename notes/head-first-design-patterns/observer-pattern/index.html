<!DOCTYPE html><html lang="zh-CN,en,default"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/uploads/icon/drop/128x128.png"><link rel="icon" type="image/png" sizes="32x32" href="/uploads/icon/drop/32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/uploads/icon/drop/16x16.png"><link rel="mask-icon" href="/uploads/icon/drop/drop.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"cwscn.github.io",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1,width:240},copycode:{enable:!0,show_result:!0,style:"flat"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"manual"},fancybox:!1,mediumzoom:!0,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"fadeIn"}},path:"search.xml"}</script><meta name="description" content="导入：Internet气象观测站 气象站建立在 WeatherData 对象上，由 WeatherData 对象负责追踪目前的天气状况（温度、湿度、气压）。我们希望能建立一个应用，有三种布告板，分别显示目前的状况、气象统计以及简单的预报。当 WeatherData 对象获得最新的测量数据时，三种布告板必须实时更新。 而且，这是一个可以扩展的气象站，我们希望公布一组 API，好让其他开发人员可以写出"><meta name="keywords" content="Head First 设计模式"><meta property="og:type" content="article"><meta property="og:title" content="观察者模式"><meta property="og:url" content="https://cwscn.github.io/notes/head-first-design-patterns/observer-pattern/index.html"><meta property="og:site_name" content="春夏秋冬"><meta property="og:description" content="导入：Internet气象观测站 气象站建立在 WeatherData 对象上，由 WeatherData 对象负责追踪目前的天气状况（温度、湿度、气压）。我们希望能建立一个应用，有三种布告板，分别显示目前的状况、气象统计以及简单的预报。当 WeatherData 对象获得最新的测量数据时，三种布告板必须实时更新。 而且，这是一个可以扩展的气象站，我们希望公布一组 API，好让其他开发人员可以写出"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYoW2996SM9UUaSYNd91ONAuId9fPaf1Qv99OaAbHpAIYafvQ40BMa5YMMb1QbQcX2X3nASpDJCaigOVo0ejJYOfXyRceYY9sRcbTIx9oHc9UUcgAXgL2jeA-ly6H7mxFfovvjcF9Yuy9dMxjVjlS_cxtbsRGDx_VqF5kxvDcqdSysJtsoPzQBHQjVR6X-FcM5GYrNBG00"><meta property="og:image" content="http://www.plantuml.com/plantuml/svg/ZP71IiD048RlUOeX9oianNieY5V1Wq-msKpDIZTRPgU5K7EpJo3jeQzHK4HycxQ-XXjrrzfKyRJm___-ymrJgW81zPXhqAXpfAXi5Qb8ZZ1I5ICDXKIudkItA1coB6Y30SmYW9d8BPEGt03XZRBElSejqXJff7VeQpF5tzpAi1hMUswpDz_BVmDCneLW_FWgHy9Qk32L96Jq-6t-d4ZKbmuKp5UfTUfHzYF07Ke7e95BKpJGxyDs_hXvMRwjxhVpfythmsxvl5ilEZXXcvR7izdFrobXZVzrXxRuD8OiIHA8p-B3rIC_flKw8LyHKjbTcgQTZkyh_B2z_0u0"><meta property="og:image" content="http://www.plantuml.com/plantuml/svg/hLDDIyD04BtdLynH3wrtARcqYWT1GS63UDXifirAFihkfX9geOWUL3pfeJUXLCIJNWJnwzUOsFuBDxL9qvZsv6tptkJDUxEp5ZCHq6dA01nq3EIQ5IEKSMgZnbo9l4uemevl72ALKAcacAv3MmFOP4A2PmZaBUH20MrY2Ca9bHtWs50iygq9lRISvnslXVDOrvEi7cJOJiPG0XSuIhmUMIWjv3KYoQomtpI9n9nWZOccJO8r6nrqYuAQlmNZtwXDX82zQOFYKHJcBmZz9wd26YXtrSKW9zBdE2vJq8RlC9F98FdUvYX4mZj8udFiNrGjuZRGpBYj-fmhfkgvIe1vhfWaNZ2pT52PzD26bHM8Uf_VWzVmupeylnhUdqJFbs7t7JffitMF8oL2_aEFmKFqT3FgdqONT-C6YKn9JvTW5PI7yF5ss3rBwKefGt-zl8twlIbtN2vdRq-RRbFCp9kKbj-HXSMpchc154hbQrA5qhvwbIQw1tfkJNy0"><meta property="og:image" content="http://www.plantuml.com/plantuml/svg/hLD1JnD15BxlhvWZ7XRkJTDBaN0mmOE91_4mtNbb9zcTRMQc9arfiX8aW4KEAYczOB0DwWK98QaKzSUmEzkU_0kEMxfEDvMJj_U--VPxxttlhKi98F1hie5yy2l0BVSFub3kU60v7XO2hLK4y1UuuW5gMWWzeaAY8CM02mrWGjRkqeK7EYVWWOGPY0MILXjJIAIO05bsCTi0ejEMHPa4NiKEe2aD5OiPM2gbjOrMWYpKU1DNXEJOaIrKhn4i8IUvJ4NDmus77lZ0v1nXCY6adqscVkg2T84lOuddZxq1yebs3ZYMTGxfI1fQhVkKKDcOveyv235vdogNwvphBie1qqGQC77NtRqJPcCPlQ8cMbf2glCZwLt7tz_6UmUZiorrzJeERr0hAxSIS72maF-bIk-p-lfkVBgjzljf2KF8BcMRAo3TI7n-CWfVcOoYRJ2YmN1ysfbvthHjqtRhxo5iBYx-qpOhlznxoREQEM_cIkKvcOBzJFyh1DZpKkw-B7tkW3oeweEf6buNZ5XrpgD160s-91V3NpVjTJOAsz7W88FLctvy-F4st9eLC-mfe6HuflP-HjSxwl9JlDE-3L_6kn_6npqThBDns4rE-jaUakwsElgcBjzhoTy0"><meta property="og:updated_time" content="2020-08-02T23:48:59.511Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="观察者模式"><meta name="twitter:description" content="导入：Internet气象观测站 气象站建立在 WeatherData 对象上，由 WeatherData 对象负责追踪目前的天气状况（温度、湿度、气压）。我们希望能建立一个应用，有三种布告板，分别显示目前的状况、气象统计以及简单的预报。当 WeatherData 对象获得最新的测量数据时，三种布告板必须实时更新。 而且，这是一个可以扩展的气象站，我们希望公布一组 API，好让其他开发人员可以写出"><meta name="twitter:image" content="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYoW2996SM9UUaSYNd91ONAuId9fPaf1Qv99OaAbHpAIYafvQ40BMa5YMMb1QbQcX2X3nASpDJCaigOVo0ejJYOfXyRceYY9sRcbTIx9oHc9UUcgAXgL2jeA-ly6H7mxFfovvjcF9Yuy9dMxjVjlS_cxtbsRGDx_VqF5kxvDcqdSysJtsoPzQBHQjVR6X-FcM5GYrNBG00"><link rel="canonical" href="https://cwscn.github.io/notes/head-first-design-patterns/observer-pattern/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css"><link rel="stylesheet" href="//unpkg.com/video.js/dist/video-js.min.css"><link rel="stylesheet" href="/css/videojs-bilibili.css"><style>.aplayer.aplayer-arrow .aplayer-icon-loop,.aplayer.aplayer-arrow .aplayer-icon-order{display:inline-block}</style><title>观察者模式 | 春夏秋冬</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">春夏秋冬</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">愿你走出半生 归来仍是少年</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档<span class="badge">209</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类<span class="badge">11</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签<span class="badge">153</span></a></li><li class="menu-item menu-item-收藏"><a href="/favlist/" rel="section"><i class="fa fa-star fa-fw"></i> 收藏</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div><meting-js server="netease" type="playlist" id="67155774" theme="#ff5555" loop="all" order="list" preload="none" volume="" mutex="" list-folded="NaN" fixed="true"></meting-js></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwscn.github.io/notes/head-first-design-patterns/observer-pattern/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar/nekosensei.png"><meta itemprop="name" content="菜农陈文生"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="春夏秋冬"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 观察者模式</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-08-03 07:48:59" itemprop="dateModified" datetime="2020-08-03T07:48:59+08:00">2020-08-03</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/notes/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/notes/head-first-design-patterns/observer-pattern/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/notes/head-first-design-patterns/observer-pattern/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="导入internet气象观测站">导入：Internet气象观测站</h1><p>气象站建立在 WeatherData 对象上，由 WeatherData 对象负责追踪目前的天气状况（温度、湿度、气压）。我们希望能建立一个应用，有三种布告板，分别显示目前的状况、气象统计以及简单的预报。当 WeatherData 对象获得最新的测量数据时，三种布告板必须实时更新。</p><p>而且，这是一个可以扩展的气象站，我们希望公布一组 API，好让其他开发人员可以写出自己的布告板，并插入此应用中。</p> <img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYoW2996SM9UUaSYNd91ONAuId9fPaf1Qv99OaAbHpAIYafvQ40BMa5YMMb1QbQcX2X3nASpDJCaigOVo0ejJYOfXyRceYY9sRcbTIx9oHc9UUcgAXgL2jeA-ly6H7mxFfovvjcF9Yuy9dMxjVjlS_cxtbsRGDx_VqF5kxvDcqdSysJtsoPzQBHQjVR6X-FcM5GYrNBG00"><h2 id="错误示范">错误示范</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 实例变量声明</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measurementsChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">float</span> temp = getTemperature();</span><br><span class="line">      <span class="keyword">float</span> humidity = getHumidity();</span><br><span class="line">      <span class="keyword">float</span> pressure = getPressure();</span><br><span class="line"></span><br><span class="line">      currentConditionsDisplay.update(temp, humidity, pressure);</span><br><span class="line">      statisticsDisplay.update(temp, humidity, pressure);</span><br><span class="line">      forecastDisplay.update(temp, humidity, pressure);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他WeatherData方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个实现中，下列哪种说法正确？（多选）</p><ul><li>[x] A. 我们是针对具体实现编程，而非针对接口。（三个布告板都是实现）</li><li>[x] B. 对于每个新的布告板，我们都得修改代码。</li><li>[x] C. 我们无法在运行时动态地增加（或删除）布告板。</li><li>[ ] D. 布告板没有实现一个共同的接口。（<code>update(temp, humidity, pressure)</code> 看恰里像是一个统一的接口）</li><li>[x] E. 我们尚未封装改变的部分。（<code>display.update</code> 是会改变的部分）</li><li>[ ] F. 我们侵犯了 WeatherData 类的封装。</li></ul><a id="more"></a><h1 id="观察者模式">观察者模式</h1><p>我们看看报纸和杂志的订阅是怎么回事：</p><ol type="1"><li>报社的业务就是出版报纸。</li><li>向某家报社订阅报纸，只要他们有新报纸出版，就会给你送来。只要你是他们的订户，你就会一直收到新报纸。</li><li>当你不想再看报纸的时候，取消订阅，他们就不会再送新报纸来。</li><li>只要报社还在运营，就会一直有人（或单位）向他们订阅报纸或取消订阅报纸。</li></ol><p>出版者 + 订阅者 = 观察者模式</p><p>只要你了解报纸的订阅是怎么回事，其实就知道观察者模式是怎么回事，只是名称不太一样：出版者改称为“主题”（Subject），订阅者改称为“观察者”（Observer）。</p><h2 id="定义">定义</h2><p>观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖着都会收到通知并自动更新。</p> <img src="http://www.plantuml.com/plantuml/svg/ZP71IiD048RlUOeX9oianNieY5V1Wq-msKpDIZTRPgU5K7EpJo3jeQzHK4HycxQ-XXjrrzfKyRJm___-ymrJgW81zPXhqAXpfAXi5Qb8ZZ1I5ICDXKIudkItA1coB6Y30SmYW9d8BPEGt03XZRBElSejqXJff7VeQpF5tzpAi1hMUswpDz_BVmDCneLW_FWgHy9Qk32L96Jq-6t-d4ZKbmuKp5UfTUfHzYF07Ke7e95BKpJGxyDs_hXvMRwjxhVpfythmsxvl5ilEZXXcvR7izdFrobXZVzrXxRuD8OiIHA8p-B3rIC_flKw8LyHKjbTcgQTZkyh_B2z_0u0"><h2 id="松耦合的威力">松耦合的威力</h2><p><strong>当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节。</strong>观察者模式提供了一种对象设计，让主题和观察者之间松耦合。改变主题或观察者其中一方，并不会影响另一方。因为两者是松耦合的，所以只要他们之间的接口仍被遵守（观察者实现了 Observer 接口），我们就可以自由地改变他们。</p><blockquote><p>为了交互对象之间的松耦合设计而努力。</p></blockquote><p><strong>松耦合的设计之所以能让我们建立有弹性的 OO 系统，能够应对变化，是因为对象之间的互相依赖降到了最低。</strong></p><h2 id="设计气象站">设计气象站</h2> <img src="http://www.plantuml.com/plantuml/svg/hLDDIyD04BtdLynH3wrtARcqYWT1GS63UDXifirAFihkfX9geOWUL3pfeJUXLCIJNWJnwzUOsFuBDxL9qvZsv6tptkJDUxEp5ZCHq6dA01nq3EIQ5IEKSMgZnbo9l4uemevl72ALKAcacAv3MmFOP4A2PmZaBUH20MrY2Ca9bHtWs50iygq9lRISvnslXVDOrvEi7cJOJiPG0XSuIhmUMIWjv3KYoQomtpI9n9nWZOccJO8r6nrqYuAQlmNZtwXDX82zQOFYKHJcBmZz9wd26YXtrSKW9zBdE2vJq8RlC9F98FdUvYX4mZj8udFiNrGjuZRGpBYj-fmhfkgvIe1vhfWaNZ2pT52PzD26bHM8Uf_VWzVmupeylnhUdqJFbs7t7JffitMF8oL2_aEFmKFqT3FgdqONT-C6YKn9JvTW5PI7yF5ss3rBwKefGt-zl8twlIbtN2vdRq-RRbFCp9kKbj-HXSMpchc154hbQrA5qhvwbIQw1tfkJNy0"><h1 id="java-内置的观察者模式">Java 内置的观察者模式</h1><p><code>java.util</code> 包内包含最基本的 Observer 接口与 Observable 类，这和我们的 Observer 接口与 Subject 接口很相似。 Observer 接口与 Observable 类使用上更方便，因为许多功能都已经事先准备好了。你甚至可以用“推”（push）或“拉”（pull）的方式传送数据，稍后就会看到这样的例子。</p> <img src="http://www.plantuml.com/plantuml/svg/hLD1JnD15BxlhvWZ7XRkJTDBaN0mmOE91_4mtNbb9zcTRMQc9arfiX8aW4KEAYczOB0DwWK98QaKzSUmEzkU_0kEMxfEDvMJj_U--VPxxttlhKi98F1hie5yy2l0BVSFub3kU60v7XO2hLK4y1UuuW5gMWWzeaAY8CM02mrWGjRkqeK7EYVWWOGPY0MILXjJIAIO05bsCTi0ejEMHPa4NiKEe2aD5OiPM2gbjOrMWYpKU1DNXEJOaIrKhn4i8IUvJ4NDmus77lZ0v1nXCY6adqscVkg2T84lOuddZxq1yebs3ZYMTGxfI1fQhVkKKDcOveyv235vdogNwvphBie1qqGQC77NtRqJPcCPlQ8cMbf2glCZwLt7tz_6UmUZiorrzJeERr0hAxSIS72maF-bIk-p-lfkVBgjzljf2KF8BcMRAo3TI7n-CWfVcOoYRJ2YmN1ysfbvthHjqtRhxo5iBYx-qpOhlznxoREQEM_cIkKvcOBzJFyh1DZpKkw-B7tkW3oeweEf6buNZ5XrpgD160s-91V3NpVjTJOAsz7W88FLctvy-F4st9eLC-mfe6HuflP-HjSxwl9JlDE-3L_6kn_6npqThBDns4rE-jaUakwsElgcBjzhoTy0"><p>Java 内置的观察者模式运作方式，和我们在气象站中的实现类似，但有一点小差异。最明显的差异是 WeatherData （也就是我们的主题）现在<strong>扩展</strong>自 Observable 类，并继承到一些增加、删除、通知观察者的方法（以及其他方法）。</p><h2 id="可观察者如何送出通知">可观察者如何送出通知</h2><ol type="1"><li>先调用 <code>setChanged()</code> 方法，标记状态已经改变的事实。</li><li>然后调用 <code>notifyObservers()</code> 或 <code>notifyObservers(Object arg)</code>。后者可以传送任何的数据对象给每一个观察者。</li></ol><h2 id="观察者如何接受通知">观察者如何接受通知</h2><p>观察者实现了更新的方法，但是方法的签名不太一样：<code>update(Observable o, Object arg)</code>。主题本身 o 当作第一个变量，好让观察者知道是哪个主题通知它的。arg 正是传入 <code>notifyObservers()</code> 的数据对象，如果没有说明则为空。</p><p>如果你想“推”（push）数据给观察者，你可以把数据当作对象传送给 <code>notifyObservers(arg)</code> 方法。否则，观察者就必须从可观察者对象中“拉”（pull）数据。</p><h2 id="setchanged-是怎么一回事"><code>setChanged()</code> 是怎么一回事</h2><p><code>setChanged()</code> 方法用来标记状态已经改变的事实，好让 <code>notifyObservers()</code> 知道当它被调用时应该通知观察者。让我们看看 Observable 内部，以了解这一切。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setChanged() &#123;</span><br><span class="line">    changed = <span class="keyword">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">notifyObservers(Object arg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">        <span class="keyword">for</span> every observer on the list &#123;</span><br><span class="line">            <span class="function">call <span class="title">update</span> <span class="params">(<span class="keyword">this</span>, arg)</span></span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">        changed </span>= <span class="keyword">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">notifyObservers() &#123;</span><br><span class="line">    notifyObservers(<span class="keyword">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做有其必要性。<code>setChanged()</code> 方法可以让你在通知观察者时，有更多的弹性。比方说，如果没有 <code>setChanged()</code> 方法，我们的气象站测量是如此敏锐，以致于温度计读数每十分之一度就会更新，这会造成 WeatherData 对象持续不断地通知观察者，我们并不希望看到这样的事情发生。如果我们希望半度以上才更新，就可以在温度差距达到半度时，调用 <code>setChanged()</code>，进行有效的更新。你也许不会经常用到此功能，但是把这样的功能准备好，当需要时马上就可以使用。</p><h2 id="java.util.observable-的黑暗面"><code>java.util.Observable</code> 的黑暗面</h2><p>可观察者是一个“类”而不是一个“接口”，更糟的是，它甚至没有实现一个接口。不幸的是，<code>java.util.Observable</code> 的实现有许多问题，限制了它的使用和复用。</p><ul><li><p>Observable 是一个类</p><p>首先，因为 Observable 是一个“类”，你必须设计一个类继承它。如果某类相同时具有 Observable 类和另一个超类的行为，就会陷入两难，毕竟 Java 不支持多重继承。再者，因为没有 Observable 接口，所以你无法建立自己的实现，和 Java 内置的 Observer API 搭配使用，也无法将 <code>java.util</code> 的实现换成另一套做法的实现。</p></li><li><p>Observable 将关键的方法保护起来</p><p><code>setChanged()</code> 方法被保护起来了（被定义成 protected）。这意味着：除非你继承自 Observable，否则你无法创建 Observable 实例并组合到你的对象中来。这个设计违反了“多用组合，少用继承”的设计原则。</p></li></ul><h1 id="jdk-中的观察者模式">JDK 中的观察者模式</h1><p>在 JDK 中，并非只有在 <code>java.util</code> 中才能找到观察者模式，其实在 JavaBeans 和 Swing 中，也都实现了观察者模式。让我们看看一个简单的 Swing API：JButton。如果你观察一下 JButton 的超类 AbstractButton，你会看到许多增加与删除倾听者（listener）的方法，这些方法可以让观察者感应到 Swing 组建的不同类型事件。比方说：ActionListener 让你“倾听”可能发生在按钮上的动作，例如按下按钮。你可以在 Swing API 中找到许多不同类型的倾听者。</p><h2 id="一个小的改变生活的程序">一个小的、改变生活的程序</h2><p>我们的程序很简单，你有一个按钮，上面写着 &quot;Should I do it?&quot;。当你按下按钮，倾听者（观察者）必须回答此问题。我们实现了两个倾听者，一个是天使（AngelListener），一个是恶魔（DevilListener）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwingObserverExample</span> </span>&#123;</span><br><span class="line">    JFrame frame;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SwingObserverExample example = <span class="keyword">new</span> SwingObserverExample();</span><br><span class="line">        example.go();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        frame = <span class="keyword">new</span> JFrame();</span><br><span class="line"></span><br><span class="line">        JButton button = <span class="keyword">new</span> JButton(<span class="string">"Should I do it?"</span>);</span><br><span class="line">        button.addActionListener(<span class="keyword">new</span> AngelListener());</span><br><span class="line">        button.addActionListener(<span class="keyword">new</span> DevilListener());</span><br><span class="line">        frame.getContentPane().add(BorderLayout.CENTER, button);</span><br><span class="line">        <span class="comment">// 在这里设置frame属性</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AngelListener</span> <span class="keyword">implements</span> <span class="title">ActionListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Dont't do it, you might regret it!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DevilListener</span> <span class="keyword">implements</span> <span class="title">ActionListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Come on, do it!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="要点">要点</h1><ul><li>观察者定义了对象之间一对多的关系。</li><li>主题（也就是可观察者）用一个共同的接口来更新观察者。</li><li>观察者和可观察者之间用松耦合（loosecoupling）方式结合，可观察者不知道观察者的细节，只知道观察者实现了观察者接口。</li><li>使用此模式时，你可从被观察者处推或拉数据。</li><li>有多个观察者时，不可以依赖特定的通知次序。如果我们的代码依赖这样的次序，就是错的。因为一旦观察者/可观察者的实现有所改变（比如为不同的观察者赋予优先级，按优先级大小次序推送），通知次序就会改变，很可能就会产生错误的结果。这绝对不是我们所认为的松耦合。</li><li>Java 有多种观察者模式的实现，包括了通用的 <code>java.util.Observable</code>。</li><li>要注意 <code>java.util.Observable</code> 实现上所带来的一些问题。</li><li>如果有必要的话，可以实现自己的 Observable，这并不难，不要害怕。</li><li>Swing 大量使用观察者模式，许多 GUI 框架也是如此。</li><li>此模式也被应用在许多地方，例如：JavaBeans、RMI。</li></ul></div><div class="popular-posts-header">相关文章</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/head-first-design-patterns/adapter-pattern-and-facade-pattern/" rel="bookmark">适配器模式与外观模式</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/head-first-design-patterns/command-pattern/" rel="bookmark">命令模式</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/head-first-design-patterns/decorator-pattern/" rel="bookmark">装饰者模式</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/head-first-design-patterns/compound-pattern/" rel="bookmark">复合模式</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/head-first-design-patterns/factory-pattern/" rel="bookmark">工厂模式</a></div></li></ul><footer class="post-footer"><div class="post-tags"> <a href="/tags/head-first-design-patterns/" rel="tag"># Head First 设计模式</a></div><div class="post-nav"><div class="post-nav-item"><a href="/notes/head-first-design-patterns/strategy-pattern/" rel="prev" title="策略模式"><i class="fa fa-chevron-left"></i> 策略模式</a></div><div class="post-nav-item"> <a href="/notes/head-first-design-patterns/decorator-pattern/" rel="next" title="装饰者模式">装饰者模式<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#导入internet气象观测站"><span class="nav-number">1.</span> <span class="nav-text">导入：Internet气象观测站</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#错误示范"><span class="nav-number">1.1.</span> <span class="nav-text">错误示范</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#观察者模式"><span class="nav-number">2.</span> <span class="nav-text">观察者模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#定义"><span class="nav-number">2.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#松耦合的威力"><span class="nav-number">2.2.</span> <span class="nav-text">松耦合的威力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设计气象站"><span class="nav-number">2.3.</span> <span class="nav-text">设计气象站</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#java-内置的观察者模式"><span class="nav-number">3.</span> <span class="nav-text">Java 内置的观察者模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#可观察者如何送出通知"><span class="nav-number">3.1.</span> <span class="nav-text">可观察者如何送出通知</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#观察者如何接受通知"><span class="nav-number">3.2.</span> <span class="nav-text">观察者如何接受通知</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#setchanged-是怎么一回事"><span class="nav-number">3.3.</span> <span class="nav-text">setChanged() 是怎么一回事</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java.util.observable-的黑暗面"><span class="nav-number">3.4.</span> <span class="nav-text">java.util.Observable 的黑暗面</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jdk-中的观察者模式"><span class="nav-number">4.</span> <span class="nav-text">JDK 中的观察者模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一个小的改变生活的程序"><span class="nav-number">4.1.</span> <span class="nav-text">一个小的、改变生活的程序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#要点"><span class="nav-number">5.</span> <span class="nav-text">要点</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="菜农陈文生" src="/uploads/avatar/nekosensei.png"><p class="site-author-name" itemprop="name">菜农陈文生</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">209</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">11</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">153</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/cncws" title="GitHub → https://github.com/cncws" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a></span><span class="links-of-author-item"><a href="mailto:1031616423@qq.com" title="E-Mail → mailto:1031616423@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">菜农陈文生</span></div><script src="//cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="//cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script><script src="/js/aplayer-el.js"></script><script src="//unpkg.com/video.js/dist/video.min.js"></script><script src="/js/videojs-bilibili.js"></script><script src="/js/videojs-bilibili-el.js"></script></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script><script src="/js/local-search.js"></script><div id="pjax"><script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Axl15EIRi5o5AatKaxXxV4Oq-gzGzoHsz',
      appKey     : 'E0qm04UjsP0qQN1l8ME3GQ25',
      placeholder: "Just go go",
      avatar     : 'identicon',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script></div></body></html>