<!DOCTYPE html><html lang="zh-CN,en,default"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/uploads/icon/drop/128x128.png"><link rel="icon" type="image/png" sizes="32x32" href="/uploads/icon/drop/32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/uploads/icon/drop/16x16.png"><link rel="mask-icon" href="/uploads/icon/drop/drop.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"cwscn.github.io",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1,width:240},copycode:{enable:!0,show_result:!0,style:"flat"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"manual"},fancybox:!1,mediumzoom:!0,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"fadeIn"}},path:"search.xml"}</script><meta name="description" content="简介 最短路径问题（Shortest path problem, SPP）旨在寻找图中两个结点之间的最短路径。本文介绍单源最短路径问题：给定一个图 \(G=(V,E)\)，我们希望找到从给定源节点 \(s\) 到每个结点 \(v\in{V}\) 的最短路径。广度优先搜索就是权重均为1的单源最短路径问题，根节点（源点）到每个结点的最短距离等于最短路径上的边的条数。单源最短路径问题可以用来解决许多其他"><meta name="keywords" content="Introduction to Algorithms,algorithms,fibonacci heap,greedy method,priority queue"><meta property="og:type" content="article"><meta property="og:title" content="单源最短路径"><meta property="og:url" content="https://cwscn.github.io/notes/introduction-to-algorithms/single-source-shortest-paths/index.html"><meta property="og:site_name" content="水滴"><meta property="og:description" content="简介 最短路径问题（Shortest path problem, SPP）旨在寻找图中两个结点之间的最短路径。本文介绍单源最短路径问题：给定一个图 \(G=(V,E)\)，我们希望找到从给定源节点 \(s\) 到每个结点 \(v\in{V}\) 的最短路径。广度优先搜索就是权重均为1的单源最短路径问题，根节点（源点）到每个结点的最短距离等于最短路径上的边的条数。单源最短路径问题可以用来解决许多其他"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://cwscn.github.io/uploads/image/introduction-to-algorithms/negative-edge-weights-in-a-directed-graph.png"><meta property="og:image" content="https://cwscn.github.io/uploads/image/introduction-to-algorithms/two-shortest-paths-trees-with-the-same-root.png"><meta property="og:image" content="https://cwscn.github.io/uploads/image/introduction-to-algorithms/single-source-shortest-path-relax.png"><meta property="og:image" content="https://cwscn.github.io/uploads/image/introduction-to-algorithms/execution-of-bellman-ford.png"><meta property="og:image" content="https://cwscn.github.io/uploads/image/introduction-to-algorithms/execution-of-dijkstra.png"><meta property="og:updated_time" content="2020-03-05T07:01:14.289Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="单源最短路径"><meta name="twitter:description" content="简介 最短路径问题（Shortest path problem, SPP）旨在寻找图中两个结点之间的最短路径。本文介绍单源最短路径问题：给定一个图 \(G=(V,E)\)，我们希望找到从给定源节点 \(s\) 到每个结点 \(v\in{V}\) 的最短路径。广度优先搜索就是权重均为1的单源最短路径问题，根节点（源点）到每个结点的最短距离等于最短路径上的边的条数。单源最短路径问题可以用来解决许多其他"><meta name="twitter:image" content="https://cwscn.github.io/uploads/image/introduction-to-algorithms/negative-edge-weights-in-a-directed-graph.png"><link rel="canonical" href="https://cwscn.github.io/notes/introduction-to-algorithms/single-source-shortest-paths/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css"><link rel="stylesheet" href="//unpkg.com/video.js/dist/video-js.min.css"><link rel="stylesheet" href="/css/videojs-bilibili.css"><style>.aplayer.aplayer-arrow .aplayer-icon-loop,.aplayer.aplayer-arrow .aplayer-icon-order{display:inline-block}</style><title>单源最短路径 | 水滴</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">水滴</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">愿你走出半生 归来仍是少年</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档<span class="badge">134</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类<span class="badge">11</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签<span class="badge">136</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i> 关于</a></li><li class="menu-item menu-item-收藏"><a href="/favlist/" rel="section"><i class="fa fa-star fa-fw"></i> 收藏</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div><meting-js server="netease" type="playlist" id="67155774" theme="#ff5555" loop="all" order="list" preload="none" volume="" mutex="" list-folded="NaN" fixed="true"></meting-js></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwscn.github.io/notes/introduction-to-algorithms/single-source-shortest-paths/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar/nekosensei.png"><meta itemprop="name" content="菜农陈文生"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="水滴"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 单源最短路径</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-03-05 15:01:14" itemprop="dateModified" datetime="2020-03-05T15:01:14+08:00">2020-03-05</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/notes/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/notes/introduction-to-algorithms/single-source-shortest-paths/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/notes/introduction-to-algorithms/single-source-shortest-paths/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="简介">简介</h1><p>最短路径问题（Shortest path problem, SPP）旨在寻找图中两个结点之间的最短路径。本文介绍单源最短路径问题：给定一个图 <span class="math inline">\(G=(V,E)\)</span>，我们希望找到从给定源节点 <span class="math inline">\(s\)</span> 到每个结点 <span class="math inline">\(v\in{V}\)</span> 的最短路径。广度优先搜索就是权重均为1的单源最短路径问题，根节点（源点）到每个结点的最短距离等于最短路径上的边的条数。单源最短路径问题可以用来解决许多其他问题，其中就包括它的几个变体：</p><ul><li>单目的地最短路径问题：找到从给定结点 <span class="math inline">\(v\)</span> 到给定目的地结点 <span class="math inline">\(t\)</span> 的最短路径。如果将图的每条边的方向翻转过来，就可以将这个问题转换为单源最短路径问题。</li><li>单节点对最短路径问题：找到从给定结点 <span class="math inline">\(u\)</span> 到给定节点 <span class="math inline">\(v\)</span> 的最短距离。如果解决了针对单个结点 <span class="math inline">\(u\)</span> 的单源最短路径问题，那么也就解决了这个问题。而且，在该问题的所有已知算法中，最坏情况下的渐进运行时间都和最好的单源最短路径算法的运行时间一样。</li><li>所有结点对最短距离：对于每对结点 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(v\)</span>，找到从结点 <span class="math inline">\(u\)</span> 到结点 <span class="math inline">\(v\)</span> 的最短路径。可以针对每个结点运行一遍单源最短路径算法，但可以更快地解决这个问题。此类问题适合使用Floyd-Warshall算法。</li></ul><a id="more"></a><h1 id="最短路径的最优子结构">最短路径的最优子结构</h1><blockquote><p>引理24.1 （最短路径的子路径也是最短路径）</p><p>给定带权重的有向图 <span class="math inline">\(G=(V,E)\)</span> 和权重函数 <span class="math inline">\(w:E\rightarrow{R}\)</span>。设 <span class="math inline">\(p=\langle{v_0,v_1,\dots,v_k\rangle}\)</span> 为从结点 <span class="math inline">\(v_0\)</span> 到结点 <span class="math inline">\(v_k\)</span> 的一条最短路径，并且对于任意的 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j，0\le{I}\le{j}\le{k}\)</span>，设 <span class="math inline">\(p_{ij}=\langle{v_i,v_{i+1},\dots,v_j}\rangle\)</span> 为路径 <span class="math inline">\(p\)</span> 中从结点 <span class="math inline">\(v_i\)</span> 到结点 <span class="math inline">\(v_j\)</span> 的子路径。那么 <span class="math inline">\(p_{ij}\)</span> 是从结点 <span class="math inline">\(v_i\)</span> 到结点 <span class="math inline">\(v_j\)</span> 的一条最短路径。</p></blockquote><p><strong>证明</strong>：假设 <span class="math inline">\(p\)</span> 是从 <span class="math inline">\(v_0\)</span> 到 <span class="math inline">\(v_k\)</span> 的一条最短路径。将路径p分解为</p><p><span class="math display">\[ v_0\mathop{\rightsquigarrow}^{p_{0i}}v_i\mathop{\rightsquigarrow}^{p_{ij}}v_j\mathop{\rightsquigarrow}^{p_{jk}}v_k \]</span></p><p>则有 <span class="math inline">\(w(p)=w(p_{0i})+w(p_{ij})+w(p_{jk})\)</span>。</p><p>假设存在一条从 <span class="math inline">\(v_i\)</span> 到 <span class="math inline">\(v_j\)</span> 的路径 <span class="math inline">\(p^\prime_{ij}\)</span>，且 <span class="math inline">\(w(p^\prime_{ij})&lt;w(p_{ij})\)</span>。则</p><p><span class="math display">\[ v_0\mathop{\rightsquigarrow}^{p_{0i}}v_i\mathop{\rightsquigarrow}^{\color{red}{p^\prime_{ij}}}v_j\mathop{\rightsquigarrow}^{p_{jk}}v_k \]</span></p><p>是一条从结点 <span class="math inline">\(v_0\)</span> 到结点 <span class="math inline">\(v_k\)</span> 的权重为 <span class="math inline">\(w(p^\prime)=w(p_{0i})+w(p^\prime_{ij})+w(p_{jk})\)</span> 的路径，而该权重小于 <span class="math inline">\(w(p)\)</span>。</p><p>这与 <span class="math inline">\(p\)</span> 是从 <span class="math inline">\(v_0\)</span> 到 <span class="math inline">\(v_k\)</span> 的一条最短路径这一假设矛盾。</p><h1 id="环路">环路</h1><p>不失一般性，我们可以假定找到的最短路径中没有环路，即它们都是简单路径。</p><ul><li><p>若一条路径包含权重为正值的环路，那么将环路从路径上删除就可以得到一条源点和终点相同的权重更小的路径。</p></li><li><p>若包含权重为负值的环路，那么只要沿着环路再遍历一遍，就能找到一条权重更小的路径。如果从结点s到结点v的某条路径上存在权重为负值的环路，我们定义结点s到结点v的最短路径<span class="math inline">\(\delta(s,v)=-\infty\)</span>。例如下图中，存在<span class="math inline">\(\langle{e,f,e}\rangle\)</span>这条权重为-3的环路，因此所有经过这条环路可达的结点e,f,g的最短路径权重为<span class="math inline">\(-\infty\)</span>。</p><p><img src="/uploads/image/introduction-to-algorithms/negative-edge-weights-in-a-directed-graph.png" title="包含权重为负值的环路的有向图"></p></li><li><p>若包含权重为0的环路，那么删除该环路后得到的路径权重与原来的相等。只要一条最短路径上还有权重为0的环路，我们就可以重复删除这些环路，直到得到一条不包含环路的简单路径。</p></li></ul><p>由于图<span class="math inline">\(G=(V,E)\)</span>中的任意无环路径最多包含|V|个不同的结点，到任意结点的最短路径最多包含|V|-1条边。</p><h1 id="最短路径的表示">最短路径的表示</h1><p>通常情况下，我们不但希望计算出最短路径权重，还希望计算出最短路径上的结点。</p><p>给定图<span class="math inline">\(G=(V,E)\)</span>，对于每个结点v，维持一个<strong>前驱结点</strong><span class="math inline">\(v.\pi\)</span>。该前驱结点可能是另一个结点或者NIL。将从结点v开始的前驱结点链反转过来，就是从s到v的一条最短路径。</p><p>我们感兴趣的是由<span class="math inline">\(\pi\)</span>值所诱导的<strong>前驱子图</strong><span class="math inline">\(G_\pi=(V_\pi,E_\pi)\)</span>。定义结点集<span class="math inline">\(V_\pi\)</span>为图G中的前驱结点不为NIL的结点的集合，再加上源节点s，即<span class="math inline">\(V_\pi=\{v\in{V}:v.\pi\neq{NIL}\}\cup\{s\}\)</span>。有向边集合<span class="math inline">\(E_\pi\)</span>是由<span class="math inline">\(V_\pi\)</span>中的结点的<span class="math inline">\(\pi\)</span>值所诱导的边的集合，即<span class="math inline">\(E_\pi=\{(v.\pi,v)\in{E}:v\in{V_\pi-\{s\}}\}\)</span>。</p><p>一个正确的单源最短路径算法：在算法终止时，<span class="math inline">\(G_\pi\)</span>是一棵“最短路径树“。最短路径树是一棵有根节点的树，该树包括了从源节点s到每个可以从s到达的结点的一条最短路径。类似于广度优先搜索中的广度优先树，但它所包括的最短路径是以边的权重来定义的，而不是边的条数。</p><p>需要指出的是，最短路径不一定是唯一的，最短路径树也不一定是唯一的。如下图(a)所示的带权重的有向图中，有(b)和(c)两种最短路径，即存在两棵根节点为s的最短路径树。</p><p><img src="/uploads/image/introduction-to-algorithms/two-shortest-paths-trees-with-the-same-root.png" title="根结点相同的两棵不同的最短路径树"></p><h1 id="松弛操作">松弛操作</h1><p>本文的算法需要使用松弛（relaxation）技术。对于每个结点v来说，维持一个属性v.d，用来记录从源节点s到结点v的最短路径权重的上界。称之为s到v的<strong>最短路径估计</strong>。使用下面运行时间为<span class="math inline">\(\Theta(V)\)</span>的算法来对最短路径估计和前驱结点进行初始化。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INITIALIZE-SINGLE-SOURCE(G, s):</span><br><span class="line">    <span class="keyword">for</span> each vertex v <span class="keyword">in</span> G.V:</span><br><span class="line">        v.d = infinity</span><br><span class="line">        v.pi = NIL</span><br><span class="line">    s.d = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>下面的伪代码给出了对边(u,v)在O(1)时间内进行的松弛操作：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">RELAX(u, v, w)：</span><br><span class="line">    <span class="keyword">if</span> v.d &gt; u.d + w(u, v):</span><br><span class="line">        v.d = u.d + w(u, v)</span><br><span class="line">        v.pi = u</span><br></pre></td></tr></table></figure><p>对一条边的松弛过程为：</p><p>首先测试一下是否可以对从s到v的最短距离进行改善。测试方法是，将从结点s到结点u之间的最短路径距离u.d加上结点u与v之间的边权重w(u, v)，并与当前的s到v的最短路径估计v.d进行比较。如果前者更小，则对v.d和v.pi进行更新。如下图：</p><ol type="a"><li><p>v.d=9; u.d=5; w(u,v)=2，9&gt;5+2，因此v的最短路径估计v.d降低，同时v的前驱结点也要更新为u。称这种情况为松弛成功。</p></li><li><p>6&lt;5+2，因此v.d和v.pi属性都不会变化。称这种情况为松弛失败。</p></li></ol><p><img src="/uploads/image/introduction-to-algorithms/single-source-shortest-path-relax.png" title="松弛成功和松弛失败"></p><h1 id="bellman-ford算法">Bellman-Ford算法</h1><p>Bellman-Ford算法解决的是一般情况下的单源最短路径问题。边的权重可以为负值。算法返回一个布尔值，以表明是否存在一个从源节点可以到达的权重为负值的环路。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BELLMAN-FORD(G, w, s):</span><br><span class="line">    INITIALIZE-SINGLE-SOURCE(G, s)</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to |G.V| - <span class="number">1</span>:        <span class="comment"># 算法对每条边进行|V|-1次处理</span></span><br><span class="line">        <span class="keyword">for</span> each edge(u, v) <span class="keyword">in</span> G.E:</span><br><span class="line">            RELAX(u, v, w)</span><br><span class="line">    <span class="keyword">for</span> each edge(u, v) <span class="keyword">in</span> G.E:    <span class="comment"># 检查是否存在权重为负值的环路</span></span><br><span class="line">        <span class="keyword">if</span> v.d &gt; u.d + w(u, v):</span><br><span class="line">            <span class="keyword">return</span> false           <span class="comment"># 若存在，返回false</span></span><br><span class="line">    <span class="keyword">return</span> true</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-algorithms/execution-of-bellman-ford.png" title="Bellman Ford每次迭代后的结果"></p><p>例如在图(a)所示的带权重的有向图中，按(t,x), (t,y), (t,z), (x,t), (y,x), (y,z), (z,x), (z,s), (s,t), (s,y)的顺序对边执行松弛操作的过程。有向图中有6个顶点，因此需要循环5次。单次循环后的结果分为如图(b)~(e)所示。只有v.d值降低的结点成功松弛。</p><p>边的顺序不会对最终结果产生影响，但若斟酌选择，可以减少松弛失败的次数，从而提高代码的执行效率。在后续的优化中将会提到一种选择方案。</p><h2 id="分析">分析</h2><p>INITIALIZE-SINGLE-SOURCE所需时间为<span class="math inline">\(\Theta(V)\)</span>，内层循环对每条边都执行一次RELAX操作，因此运行时间为<span class="math inline">\(\Theta(E)\)</span>，且一共要进行|V|-1次循环，检测是否存在权重为负值的环路所需时间为O(E)，Bellman-Ford算法的总运行时间为<span class="math inline">\(\Theta(V)+(|V|-1)\Theta(E)+O(E)=O(VE)\)</span>。</p><h2 id="优化">优化</h2><ol type="1"><li><p>提前跳出循环。</p><p>实际操作中，Bellman-Ford算法经常会在未达到|V|-1次前就出解，|V|-1其实是最大值。于是可以在循环中设置判定，在某次循环不再进行松弛时，直接退出循环，进行负权环判定。（若存在负权环，则循环次数一定会达到|V|-1次，因此，若是提前跳出循环，则说明图中没有负权环）</p></li><li><p>队列优化。参考最短路径快速算法。</p><p>松弛操作必定只会发生在最短路径前驱结点松弛成功过的结点上：结点v的所有前驱结点<span class="math inline">\(\{u|(u,v)\in{E}\}\)</span>中，若存在松弛成功（更新了最短路径估计d和前驱结点pi）的结点，则对结点v执行松弛操作RELAX(v, n, w)。</p><p>反过来说，我们应该对哪些结点v执行松弛操作：若结点u成功松弛，则应该对u的所有后继结点<span class="math inline">\(\{v|(u,v)\in{E}\}\)</span>执行松弛操作。</p><p>用一个队列记录松弛过的结点，避免了冗余计算。</p></li></ol><h2 id="代码">代码</h2><p>图用邻接链表的方式存储。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_f</span><span class="params">(graph, result=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> result <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        print(<span class="string">'has negative cycle or not?'</span>, <span class="keyword">not</span> result)</span><br><span class="line">    fmt = <span class="string">'&#123;0:&lt;10s&#125; &#123;1:&lt;10s&#125; &#123;2:&lt;10s&#125;\n'</span></span><br><span class="line">    title = fmt.format(<span class="string">'vertex'</span>, <span class="string">'distance'</span>, <span class="string">'previous'</span>)</span><br><span class="line">    data = <span class="string">''</span>.join(fmt.format(str(k), str(attr[<span class="string">'distance'</span>]), str(attr[<span class="string">'previous'</span>])) <span class="keyword">for</span> k, attr <span class="keyword">in</span> graph.nodes.items())</span><br><span class="line">    print(title + data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_single_source</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    <span class="string">"""初始化单源点"""</span></span><br><span class="line">    <span class="keyword">for</span> attr <span class="keyword">in</span> graph.nodes.values():</span><br><span class="line">        attr[<span class="string">'previous'</span>] = <span class="literal">None</span></span><br><span class="line">        attr[<span class="string">'distance'</span>] = float(<span class="string">'inf'</span>)</span><br><span class="line">    graph.nodes[s][<span class="string">'distance'</span>] = <span class="number">0</span>  <span class="comment"># 源点距离初始为0，其他为无穷远</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relax</span><span class="params">(graph, u, v, w)</span>:</span></span><br><span class="line">    <span class="string">"""relax操作，distance的值只在此处发生改变"""</span></span><br><span class="line">    u_attr, v_attr = graph.nodes[u], graph.nodes[v]</span><br><span class="line">    <span class="keyword">if</span> v_attr[<span class="string">'distance'</span>] &gt; u_attr[<span class="string">'distance'</span>] + w:</span><br><span class="line">        v_attr[<span class="string">'distance'</span>] = u_attr[<span class="string">'distance'</span>] + w  <span class="comment"># 更新最短距离</span></span><br><span class="line">        v_attr[<span class="string">'previous'</span>] = u  <span class="comment"># 更新前驱结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detect_negative_cycle</span><span class="params">(graph)</span>:</span></span><br><span class="line">    <span class="string">"""检测图g中是否包含负权环路"""</span></span><br><span class="line">    <span class="keyword">for</span> u, v, w <span class="keyword">in</span> graph.edges.data(<span class="string">'weight'</span>):</span><br><span class="line">        <span class="keyword">if</span> graph.nodes[v][<span class="string">'distance'</span>] &gt; graph.nodes[u][<span class="string">'distance'</span>] + w:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bellman_ford</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    <span class="string">"""Bellman Ford算法，同时判断是否存在权重为负值的环路"""</span></span><br><span class="line">    initialize_single_source(graph, s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(graph.number_of_nodes() - <span class="number">1</span>):  <span class="comment"># 重复|V|-1遍</span></span><br><span class="line">        <span class="keyword">for</span> u, v, w <span class="keyword">in</span> graph.edges.data(<span class="string">'weight'</span>):  <span class="comment"># 对每条边执行一次relax</span></span><br><span class="line">            relax(graph, u, v, w)</span><br><span class="line">    <span class="keyword">return</span> detect_negative_cycle(graph)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bellman_ford_op_1</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    <span class="string">"""优化方案1：提前跳出循环"""</span></span><br><span class="line">    initialize_single_source(graph, s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(graph.number_of_nodes() - <span class="number">1</span>):</span><br><span class="line">        relaxed = <span class="literal">False</span>  <span class="comment"># 一次循环开始前，标志位置为0</span></span><br><span class="line">        <span class="keyword">for</span> u, v, w <span class="keyword">in</span> graph.edges.data(<span class="string">'weight'</span>):</span><br><span class="line">            <span class="keyword">if</span> relax(graph, u, v, w) <span class="keyword">is</span> <span class="literal">True</span>:  <span class="comment"># 若松弛成功，标志位置为1</span></span><br><span class="line">                relaxed = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> relaxed <span class="keyword">is</span> <span class="literal">False</span>:  <span class="comment"># 提前跳出循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 若完整执行了|V|-1次循环，则去判断是否包含负权环</span></span><br><span class="line">        <span class="keyword">return</span> detect_negative_cycle(graph)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bellman_ford_op_2</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    <span class="string">"""队列优化"""</span></span><br><span class="line">    initialize_single_source(graph, s)</span><br><span class="line">    q = Queue()</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> graph.edges:</span><br><span class="line">        graph[u][v][<span class="string">'__times__'</span>] = <span class="number">0</span>  <span class="comment"># 记录松弛次数（不论结果），当超过|V|-1次时，说明图中包含负权环</span></span><br><span class="line">    q.put(s)  <span class="comment"># 初始放入源点</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">        u = q.get()</span><br><span class="line">        <span class="keyword">for</span> v, attr <span class="keyword">in</span> graph[u].items():  <span class="comment"># 遍历邻接边</span></span><br><span class="line">            <span class="keyword">if</span> relax(graph, u, v, attr[<span class="string">'weight'</span>]) <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">                q.put(v)  <span class="comment"># 将松弛成功过的结点放入队列</span></span><br><span class="line">                graph[u][v][<span class="string">'__times__'</span>] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> graph[u][v][<span class="string">'__times__'</span>] &gt; graph.number_of_nodes() - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># Bellman-Ford示例</span></span><br><span class="line">    g = nx.DiGraph()</span><br><span class="line">    g.add_nodes_from(<span class="string">'stxyz'</span>)</span><br><span class="line">    edges = [(<span class="string">'s'</span>, <span class="string">'t'</span>, <span class="number">6</span>), (<span class="string">'s'</span>, <span class="string">'y'</span>, <span class="number">7</span>), (<span class="string">'t'</span>, <span class="string">'x'</span>, <span class="number">5</span>), (<span class="string">'t'</span>, <span class="string">'y'</span>, <span class="number">8</span>), (<span class="string">'t'</span>, <span class="string">'z'</span>, <span class="number">-4</span>), (<span class="string">'x'</span>, <span class="string">'t'</span>, <span class="number">-2</span>), (<span class="string">'y'</span>, <span class="string">'x'</span>, <span class="number">-3</span>),</span><br><span class="line">             (<span class="string">'y'</span>, <span class="string">'z'</span>, <span class="number">9</span>), (<span class="string">'z'</span>, <span class="string">'s'</span>, <span class="number">2</span>), (<span class="string">'z'</span>, <span class="string">'x'</span>, <span class="number">7</span>)]</span><br><span class="line">    g.add_weighted_edges_from(edges)</span><br><span class="line">    r = bellman_ford(g, <span class="string">'s'</span>)</span><br><span class="line">    print_f(g, r)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 一个带有负权环路的示例</span></span><br><span class="line">    g.clear()</span><br><span class="line">    g.add_nodes_from(<span class="string">'s1234t'</span>)</span><br><span class="line">    edges = [(<span class="string">'s'</span>, <span class="string">'1'</span>, <span class="number">1</span>), (<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="number">1</span>), (<span class="string">'2'</span>, <span class="string">'1'</span>, <span class="number">-2</span>), (<span class="string">'1'</span>, <span class="string">'3'</span>, <span class="number">1</span>), (<span class="string">'3'</span>, <span class="string">'4'</span>, <span class="number">-4</span>), (<span class="string">'4'</span>, <span class="string">'1'</span>, <span class="number">1</span>), (<span class="string">'4'</span>, <span class="string">'t'</span>, <span class="number">1</span>)]</span><br><span class="line">    g.add_weighted_edges_from(edges)</span><br><span class="line">    r = bellman_ford_op_2(g, <span class="string">'s'</span>)</span><br><span class="line">    print_f(g, r)</span><br><span class="line"></span><br><span class="line">    g.clear()</span><br><span class="line">    g.add_nodes_from(<span class="string">'s1234t'</span>)</span><br><span class="line">    edges = [(<span class="string">'s'</span>, <span class="string">'1'</span>, <span class="number">3</span>), (<span class="string">'1'</span>, <span class="string">'s'</span>, <span class="number">-3</span>), (<span class="string">'s'</span>, <span class="string">'2'</span>, <span class="number">4</span>), (<span class="string">'2'</span>, <span class="string">'s'</span>, <span class="number">-4</span>), (<span class="string">'2'</span>, <span class="string">'1'</span>, <span class="number">3</span>), (<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="number">-3</span>), (<span class="string">'1'</span>, <span class="string">'3'</span>, <span class="number">7</span>),</span><br><span class="line">             (<span class="string">'3'</span>, <span class="string">'1'</span>, <span class="number">-7</span>), (<span class="string">'3'</span>, <span class="string">'2'</span>, <span class="number">5</span>), (<span class="string">'2'</span>, <span class="string">'4'</span>, <span class="number">6</span>), (<span class="string">'4'</span>, <span class="string">'2'</span>, <span class="number">-6</span>), (<span class="string">'3'</span>, <span class="string">'4'</span>, <span class="number">-8</span>), (<span class="string">'3'</span>, <span class="string">'t'</span>, <span class="number">6</span>),</span><br><span class="line">             (<span class="string">'t'</span>, <span class="string">'3'</span>, <span class="number">-6</span>), (<span class="string">'4'</span>, <span class="string">'t'</span>, <span class="number">9</span>), (<span class="string">'t'</span>, <span class="string">'4'</span>, <span class="number">-9</span>)]</span><br><span class="line">    g.add_weighted_edges_from(edges)</span><br><span class="line">    r = bellman_ford_op_1(g, <span class="string">'s'</span>)</span><br><span class="line">    print_f(g, r)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">has negative cycle or not? False</span><br><span class="line">vertex     distance   previous  </span><br><span class="line">s          0          None</span><br><span class="line">t          2          x</span><br><span class="line">x          4          y</span><br><span class="line">y          7          s</span><br><span class="line">z          -2         t</span><br><span class="line"></span><br><span class="line">has negative cycle or not? True</span><br><span class="line">vertex     distance   previous  </span><br><span class="line">s          0          None</span><br><span class="line">1          -4         4</span><br><span class="line">2          -3         1</span><br><span class="line">3          -2         1</span><br><span class="line">4          -6         3</span><br><span class="line">t          -4         4</span><br><span class="line"></span><br><span class="line">has negative cycle or not? True</span><br><span class="line">vertex     distance   previous  </span><br><span class="line">s          -23        2</span><br><span class="line">1          -17        3</span><br><span class="line">2          -24        4</span><br><span class="line">3          -15        t</span><br><span class="line">4          -18        3</span><br><span class="line">t          -9         4</span><br></pre></td></tr></table></figure><h1 id="dijkstra算法">Dijkstra算法</h1><p>Dijkstra算法是另一个解决单源最短路径问题的算法，该要求所有边的权重都为非负值。</p><p>Dijkstra算法在运行过程中维持的关键信息是一组结点集合S。从源节点s到该集合中每个结点之间的最短距离已经被找到。算法重复从结点集V-S中选择<strong>最短路径估计最小</strong>的结点u，将u加入到集合S，然后对所有从u发出的边进行松弛（对于边<span class="math inline">\((u,v),v\in{S}\)</span>是没有松弛的必要的，即使对之松弛，松弛一定不会成功，因为s到v的最短距离已经求出）。因为算法总是选择集合V-S中最近的结点来加入到集合S中，该算法使用的是贪心策略。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DIJKSTRA(G, w, s):</span><br><span class="line">    INITIALIZE-SINGLE-SOURCE(G, s)</span><br><span class="line">    S = empty set           <span class="comment"># 到源点s的最短距离被找到的结点集，伪代码中体现的作用不大</span></span><br><span class="line">    Q = G.V                 <span class="comment"># 初始时将所有结点放入优先队列</span></span><br><span class="line">    <span class="keyword">while</span> Q <span class="keyword">not</span> empty:</span><br><span class="line">        u = EXTRACT-MIN(Q)  <span class="comment"># 选择最短路径估计最小的结点</span></span><br><span class="line">        S = S + &#123;u&#125;         <span class="comment"># 将u加入集合S</span></span><br><span class="line">        <span class="keyword">for</span> each vertex v <span class="keyword">in</span> G.Adj[u]:     <span class="comment"># 松弛所有从u发出的边</span></span><br><span class="line">            RELAX(u, v, w)  <span class="comment"># 如果松弛成功，还要改变优先队列中结点v的减值</span></span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-algorithms/execution-of-dijkstra.png" title="Dijkstra每次迭代后的结果"></p><p>在一个结点个数为5的带权重的有向图上执行Dijkstra算法的过程如上图。</p><p>(a)~(e) 为每次while循环开始时，灰色结点为最短路径估计最小的结点。白色结点属于集合V-S。</p><p>(b)~(f) 为每次for循环结束后，阴影的边描述了前驱节点。黑色的结点属于集合S。图(f)就是最终结果。</p><h2 id="分析-1">分析</h2><p>首先分析算法的循环次数。算法调用1次INITIALIZE-SINGLE-SOURCE操作和1次初始化优先队列操作Q=G.V。之后的while循环执行次数为|V|次，因为每次循环都从最小优先队列Q中提取一个结点。因此，EXTRACT-MIN也执行了|V|次。内层的for循环对从结点u发出的边执行一次松弛操作，而在while循环过程中，u取到了图中所有的结点且各取到一次。因此for循环实际上对图中所有的边执行了1次松弛操作，即RELAX操作的执行次数为|E|。暗含在其中的降低键值DECREASE-KEY操作也执行了|E|次。</p><p>如何实现算法中的优先队列直接影响到算法的时间复杂度。在此列出3中实现下的时间复杂度分析。</p><table><thead><tr class="header"><th>实现方式</th><th>初始化代价*1</th><th>提取最小值代价*V</th><th>降低键值代价*E</th><th>Dijkstra算法总代价</th></tr></thead><tbody><tr class="odd"><td>数组</td><td><span class="math inline">\(O(V)\)</span></td><td><span class="math inline">\(O(V)\)</span>，搜索整个数组</td><td><span class="math inline">\(O(1)\)</span></td><td><span class="math inline">\(O(V^2+E)=O(V^2)\)</span></td></tr><tr class="even"><td>二叉堆</td><td><span class="math inline">\(O(V)\)</span></td><td><span class="math inline">\(O(\lg{V})\)</span>，调整队</td><td><span class="math inline">\(O(\lg{V})\)</span>，调整堆</td><td><span class="math inline">\(O((V+E)\lg{V})\)</span></td></tr><tr class="odd"><td>斐波那契堆</td><td><span class="math inline">\(O(V)\)</span></td><td><span class="math inline">\(O(\lg{V})\)</span>，摊还代价</td><td><span class="math inline">\(O(1)\)</span>，摊还代价</td><td><span class="math inline">\(O(V\lg{V}+E)\)</span></td></tr></tbody></table><p>若所有结点都可以从源节点到达（|V|&lt;|E|），则<span class="math inline">\(O((V+E)\lg{V})=O(E\lg{V})\)</span>。对于稀疏图，特别地，如果<span class="math inline">\(E=o(V^2/\lg{V})\)</span>，则使用二叉堆实现最小优先队列相对于用数组直接实现的<span class="math inline">\(O(V^2)\)</span>代价有改善。</p><p>Dijkstra算法与广度优先搜索算法及计算最小生成树的Prim算法的相似点：</p><ul><li>与广度优先搜索算法：集合S对应的是广度优先搜索中的黑色结点集合：正如集合S中的结点的最短路径权重已经计算出来一样，在广度优先搜索中，黑色结点的正确广度优先距离也已经计算出来。</li><li>与Prim算法：两个算法都使用最小优先队列来寻找集合之外“最轻”结点，将该节点加入到集合里，并对位于集合外面的结点的权重进行相应调整。</li></ul><h2 id="代码-1">代码</h2><p>使用内建的优先队列时的妥协：</p><p>因为无法改变优先队列中的键值（或者说改变了也没有意义，优先队列不会调整结点在队列中的先后顺序），所以在初始时<span class="math inline">\(Q\neq{G.V}\)</span>，而是只将源点s放入优先队列。之后在松弛过程中，若发现集合S中不存在的结点，再将之放入优先队列。</p><p>但这也随之产生了一个问题：多条不同的边可能指向同一个集合S外的结点u，当这些边成功松弛多次时，结点u被多次加入队列中（因为内建的优先队列没有提供DECREASE-KEY操作，只能通过重复放入的方式更新键值）。这些重复加入的结点u携带不同的键值，显然，因最近一次松弛成功而被加入队列的结点u携带最小的键值。携带较大键值的结点u对算法没有意义，但它们仍然存在于队列中。因此，在循环开始时对取得的结点进行判断：若u结点在visit集合中，说明源结点s到u的最短距离已经求出，跳过这样的结点。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue</span><br><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"><span class="keyword">from</span> graph.bellman_ford <span class="keyword">import</span> initialize_single_source, relax, print_f</span><br><span class="line"><span class="keyword">from</span> data_structure.fib_heap <span class="keyword">import</span> FibHeap, Node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dijkstra_queue</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    <span class="string">"""使用优先队列"""</span></span><br><span class="line">    initialize_single_source(graph, s)</span><br><span class="line">    visit, q = set(), PriorityQueue()  <span class="comment"># visit：集合S</span></span><br><span class="line">    q.put((graph.nodes[s][<span class="string">'distance'</span>], s))  <span class="comment"># 初始时s入队列</span></span><br><span class="line">    <span class="keyword">while</span> q.empty() <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">        u = q.get()[<span class="number">1</span>]  <span class="comment"># 选择最近的节点u</span></span><br><span class="line">        <span class="keyword">if</span> u <span class="keyword">not</span> <span class="keyword">in</span> visit:</span><br><span class="line">            visit.add(u)</span><br><span class="line">            <span class="keyword">for</span> v, e_attr <span class="keyword">in</span> graph[u].items():</span><br><span class="line">                <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> visit:  <span class="comment"># 已经访问过的顶点无需入队列</span></span><br><span class="line">                    relax(graph, u, v, e_attr[<span class="string">'weight'</span>])  <span class="comment"># relax最近顶点u的临界点</span></span><br><span class="line">                    q.put((graph.nodes[v][<span class="string">'distance'</span>], v))  <span class="comment"># 临接顶点入队列，同一顶点可能带有不同的distance值多次入队列</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dijkstra_fibonacci</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    <span class="string">"""使用斐波那契堆优化算法"""</span></span><br><span class="line">    initialize_single_source(graph, s)</span><br><span class="line">    m, visit, heap = &#123;&#125;, set(), FibHeap()  <span class="comment"># m：顶点到堆中结点的映射&#123;v.key:Node&#125;</span></span><br><span class="line">    <span class="keyword">for</span> v, v_attr <span class="keyword">in</span> graph.nodes.items():  <span class="comment"># 所有顶点入堆</span></span><br><span class="line">        n = Node(v_attr[<span class="string">'distance'</span>])</span><br><span class="line">        n.v = v  <span class="comment"># 为fibonacci node添加属性v，记录指向顶点的指针</span></span><br><span class="line">        heap.insert(n)</span><br><span class="line">        m[v] = n</span><br><span class="line">    <span class="keyword">while</span> heap.n &gt; <span class="number">0</span>:  <span class="comment"># 实际上循环|V|-1次，等价于for i in range(len(g.get_v_set()))</span></span><br><span class="line">        u = heap.pop().v  <span class="comment"># 选择最近的节点u</span></span><br><span class="line">        visit.add(u)</span><br><span class="line">        <span class="keyword">for</span> v, e_attr <span class="keyword">in</span> graph[u].items():</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> visit:</span><br><span class="line">                relax(graph, u, v, e_attr[<span class="string">'weight'</span>])</span><br><span class="line">                heap.decrease_key(m[v], graph.nodes[v][<span class="string">'distance'</span>])  <span class="comment"># 修改heap中对应节点的key值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># Dijkstra示例</span></span><br><span class="line">    g = nx.DiGraph()</span><br><span class="line">    g.add_nodes_from(<span class="string">'s12345t'</span>)</span><br><span class="line">    edges = [(<span class="string">'s'</span>, <span class="string">'1'</span>, <span class="number">2</span>), (<span class="string">'s'</span>, <span class="string">'2'</span>, <span class="number">3</span>), (<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="number">4</span>), (<span class="string">'1'</span>, <span class="string">'3'</span>, <span class="number">8</span>), (<span class="string">'1'</span>, <span class="string">'4'</span>, <span class="number">5</span>), (<span class="string">'2'</span>, <span class="string">'4'</span>, <span class="number">3</span>), (<span class="string">'2'</span>, <span class="string">'5'</span>, <span class="number">4</span>),</span><br><span class="line">             (<span class="string">'3'</span>, <span class="string">'4'</span>, <span class="number">2</span>), (<span class="string">'3'</span>, <span class="string">'t'</span>, <span class="number">9</span>), (<span class="string">'4'</span>, <span class="string">'t'</span>, <span class="number">6</span>), (<span class="string">'5'</span>, <span class="string">'t'</span>, <span class="number">10</span>)]</span><br><span class="line">    g.add_weighted_edges_from(edges)</span><br><span class="line">    dijkstra_queue(g, <span class="string">'s'</span>)</span><br><span class="line">    print_f(g)</span><br><span class="line"></span><br><span class="line">    g.clear()</span><br><span class="line">    g.add_nodes_from(<span class="string">'stxyz'</span>)</span><br><span class="line">    edges = [(<span class="string">'s'</span>, <span class="string">'t'</span>, <span class="number">10</span>), (<span class="string">'s'</span>, <span class="string">'y'</span>, <span class="number">5</span>), (<span class="string">'t'</span>, <span class="string">'x'</span>, <span class="number">1</span>), (<span class="string">'t'</span>, <span class="string">'y'</span>, <span class="number">2</span>), (<span class="string">'x'</span>, <span class="string">'z'</span>, <span class="number">4</span>), (<span class="string">'y'</span>, <span class="string">'t'</span>, <span class="number">3</span>), (<span class="string">'y'</span>, <span class="string">'x'</span>, <span class="number">9</span>),</span><br><span class="line">             (<span class="string">'y'</span>, <span class="string">'z'</span>, <span class="number">2</span>), (<span class="string">'z'</span>, <span class="string">'s'</span>, <span class="number">7</span>), (<span class="string">'z'</span>, <span class="string">'x'</span>, <span class="number">6</span>)]</span><br><span class="line">    g.add_weighted_edges_from(edges)</span><br><span class="line">    dijkstra_fibonacci(g, <span class="string">'s'</span>)</span><br><span class="line">    print_f(g)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vertex     distance   previous  </span><br><span class="line">s          0          None</span><br><span class="line">1          2          s</span><br><span class="line">2          3          s</span><br><span class="line">3          10         1</span><br><span class="line">4          6          2</span><br><span class="line">5          7          2</span><br><span class="line">t          12         4</span><br><span class="line"></span><br><span class="line">vertex     distance   previous  </span><br><span class="line">s          0          None</span><br><span class="line">t          8          y</span><br><span class="line">x          9          t</span><br><span class="line">y          5          s</span><br><span class="line">z          7          y</span><br></pre></td></tr></table></figure></div><div class="popular-posts-header">相关文章</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/introduction-to-algorithms/breadth-first-search-and-depth-first-search/" rel="bookmark">广度优先搜索和深度优先搜索</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/introduction-to-algorithms/fibonacci-heaps/" rel="bookmark">斐波那契堆</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/introduction-to-algorithms/insertion-sort-selection-sort-and-bubble-sort/" rel="bookmark">插入排序、选择排序和冒泡排序</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/introduction-to-algorithms/order-statistics/" rel="bookmark">顺序统计量</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/introduction-to-algorithms/maximum-subarray-problems/" rel="bookmark">最大子数组问题</a></div></li></ul><footer class="post-footer"><div class="post-tags"> <a href="/tags/Introduction-to-Algorithms/" rel="tag"># Introduction to Algorithms</a> <a href="/tags/algorithms/" rel="tag"># algorithms</a> <a href="/tags/fibonacci-heap/" rel="tag"># fibonacci heap</a> <a href="/tags/greedy-method/" rel="tag"># greedy method</a> <a href="/tags/priority-queue/" rel="tag"># priority queue</a></div><div class="post-nav"><div class="post-nav-item"><a href="/notes/introduction-to-algorithms/binary-search-trees/" rel="prev" title="二叉搜索树"><i class="fa fa-chevron-left"></i> 二叉搜索树</a></div><div class="post-nav-item"> <a href="/operations-research/cplex-in-python/" rel="next" title="在 Python 中使用 CPLEX">在 Python 中使用 CPLEX<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#简介"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#最短路径的最优子结构"><span class="nav-number">2.</span> <span class="nav-text">最短路径的最优子结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#环路"><span class="nav-number">3.</span> <span class="nav-text">环路</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#最短路径的表示"><span class="nav-number">4.</span> <span class="nav-text">最短路径的表示</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#松弛操作"><span class="nav-number">5.</span> <span class="nav-text">松弛操作</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#bellman-ford算法"><span class="nav-number">6.</span> <span class="nav-text">Bellman-Ford算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#分析"><span class="nav-number">6.1.</span> <span class="nav-text">分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#优化"><span class="nav-number">6.2.</span> <span class="nav-text">优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码"><span class="nav-number">6.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#dijkstra算法"><span class="nav-number">7.</span> <span class="nav-text">Dijkstra算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#分析-1"><span class="nav-number">7.1.</span> <span class="nav-text">分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码-1"><span class="nav-number">7.2.</span> <span class="nav-text">代码</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="菜农陈文生" src="/uploads/avatar/nekosensei.png"><p class="site-author-name" itemprop="name">菜农陈文生</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">134</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">11</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">136</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="cc-license motion-element" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">菜农陈文生</span></div><script src="//cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="//cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script><script src="/js/aplayer-el.js"></script><script src="//unpkg.com/video.js/dist/video.min.js"></script><script src="/js/videojs-bilibili.js"></script><script src="/js/videojs-bilibili-el.js"></script></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script><script src="/js/local-search.js"></script><div id="pjax"><script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Axl15EIRi5o5AatKaxXxV4Oq-gzGzoHsz',
      appKey     : 'E0qm04UjsP0qQN1l8ME3GQ25',
      placeholder: "Just go go",
      avatar     : 'identicon',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script></div></body></html>