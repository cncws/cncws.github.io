<!DOCTYPE html><html lang="zh-CN,en,default"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/uploads/icon/drop/128x128.png"><link rel="icon" type="image/png" sizes="32x32" href="/uploads/icon/drop/32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/uploads/icon/drop/16x16.png"><link rel="mask-icon" href="/uploads/icon/drop/drop.svg" color="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="NKt2iJb3Hnl6-Sm7LB-fTT7LRyi9cg5yZrB-zd0ohtk"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"cwscn.github.io",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1,width:240},copycode:{enable:!0,show_result:!0,style:"flat"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"manual"},fancybox:!1,mediumzoom:!0,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"fadeIn"}},path:"search.xml"}</script><meta name="description" content="斐波那契堆 斐波那契堆数据结构有两种用途：  它支持一些列操作，这些操作构成了所谓的“可合并堆”。 斐波那契堆的一些操作（INSERT/UNION/DECREASE-KEY）可以在常数摊还时间内完成，非常适用于需要频繁使用这些操作的应用。     操作 二项堆（最坏情形） 斐波那契堆（摊还）     MAKE-HEAP()：创建空堆 \(\Theta(1)\) \(\Theta(1)\)   IN"><meta name="keywords" content="算法导论,堆"><meta property="og:type" content="article"><meta property="og:title" content="斐波那契堆"><meta property="og:url" content="https://cwscn.github.io/notes/introduction-to-algorithms/fibonacci-heaps/index.html"><meta property="og:site_name" content="春夏秋冬"><meta property="og:description" content="斐波那契堆 斐波那契堆数据结构有两种用途：  它支持一些列操作，这些操作构成了所谓的“可合并堆”。 斐波那契堆的一些操作（INSERT/UNION/DECREASE-KEY）可以在常数摊还时间内完成，非常适用于需要频繁使用这些操作的应用。     操作 二项堆（最坏情形） 斐波那契堆（摊还）     MAKE-HEAP()：创建空堆 \(\Theta(1)\) \(\Theta(1)\)   IN"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://cwscn.github.io/uploads/image/introduction-to-algorithms/fibonacci-heap.png"><meta property="og:image" content="https://cwscn.github.io/uploads/image/introduction-to-algorithms/fib-heap-insert.png"><meta property="og:image" content="https://cwscn.github.io/uploads/image/introduction-to-algorithms/fib-heap-extract-min.png"><meta property="og:image" content="https://cwscn.github.io/uploads/image/introduction-to-algorithms/fib-heap-decrease-key.png"><meta property="og:updated_time" content="2020-08-09T01:59:39.785Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="斐波那契堆"><meta name="twitter:description" content="斐波那契堆 斐波那契堆数据结构有两种用途：  它支持一些列操作，这些操作构成了所谓的“可合并堆”。 斐波那契堆的一些操作（INSERT/UNION/DECREASE-KEY）可以在常数摊还时间内完成，非常适用于需要频繁使用这些操作的应用。     操作 二项堆（最坏情形） 斐波那契堆（摊还）     MAKE-HEAP()：创建空堆 \(\Theta(1)\) \(\Theta(1)\)   IN"><meta name="twitter:image" content="https://cwscn.github.io/uploads/image/introduction-to-algorithms/fibonacci-heap.png"><link rel="canonical" href="https://cwscn.github.io/notes/introduction-to-algorithms/fibonacci-heaps/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css"><link rel="stylesheet" href="//unpkg.com/video.js/dist/video-js.min.css"><link rel="stylesheet" href="/css/videojs-bilibili.css"><style>.aplayer.aplayer-arrow .aplayer-icon-loop,.aplayer.aplayer-arrow .aplayer-icon-order{display:inline-block}</style><title>斐波那契堆 | 春夏秋冬</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">春夏秋冬</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">愿你走出半生 归来仍是少年</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档<span class="badge">242</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类<span class="badge">13</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签<span class="badge">159</span></a></li><li class="menu-item menu-item-收藏"><a href="/favlist/" rel="section"><i class="fa fa-star fa-fw"></i> 收藏</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div><meting-js server="netease" type="playlist" id="67155774" theme="#ff5555" loop="all" order="list" preload="none" volume="" mutex="" list-folded="NaN" fixed="true"></meting-js></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwscn.github.io/notes/introduction-to-algorithms/fibonacci-heaps/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar/nekosensei.png"><meta itemprop="name" content="菜农陈文生"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="春夏秋冬"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 斐波那契堆</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-08-09 09:59:39" itemprop="dateModified" datetime="2020-08-09T09:59:39+08:00">2020-08-09</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/notes/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a></span></span><span id="/notes/introduction-to-algorithms/fibonacci-heaps/" class="post-meta-item leancloud_visitors" data-flag-title="斐波那契堆" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/notes/introduction-to-algorithms/fibonacci-heaps/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/notes/introduction-to-algorithms/fibonacci-heaps/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="斐波那契堆">斐波那契堆</h1><p>斐波那契堆数据结构有两种用途：</p><ul><li>它支持一些列操作，这些操作构成了所谓的“可合并堆”。</li><li>斐波那契堆的一些操作（INSERT/UNION/DECREASE-KEY）可以在常数摊还时间内完成，非常适用于需要频繁使用这些操作的应用。</li></ul><table><thead><tr class="header"><th>操作</th><th>二项堆（最坏情形）</th><th>斐波那契堆（摊还）</th></tr></thead><tbody><tr class="odd"><td>MAKE-HEAP()：创建空堆</td><td><span class="math inline">\(\Theta(1)\)</span></td><td><span class="math inline">\(\Theta(1)\)</span></td></tr><tr class="even"><td>INSERT(H, x)：插入元素x</td><td><span class="math inline">\(\Theta(\lg{n})\)</span></td><td><span class="math inline">\(\Theta(1)\)</span></td></tr><tr class="odd"><td>MINIMUM()：提取最小元素</td><td><span class="math inline">\(\Theta(1)\)</span></td><td><span class="math inline">\(\Theta(1)\)</span></td></tr><tr class="even"><td>EXTRACT-MIN()：删除并返回最小元素</td><td><span class="math inline">\(\Theta(\lg{n})\)</span></td><td><span class="math inline">\(O(\lg{n})\)</span></td></tr><tr class="odd"><td>UNION(H1, H2)：创建一个包含H1和H2中所有元素的新堆</td><td><span class="math inline">\(\Theta(n)\)</span></td><td><span class="math inline">\(\Theta(1)\)</span></td></tr><tr class="even"><td>DECREASE-KEY(H, x, k)：将元素x的关键字赋予新值k</td><td><span class="math inline">\(\Theta(\lg{n})\)</span></td><td><span class="math inline">\(\Theta(1)\)</span></td></tr><tr class="odd"><td>DELETE(H, x)：删除元素x</td><td><span class="math inline">\(\Theta(\lg{n})\)</span></td><td><span class="math inline">\(O(\lg{n})\)</span></td></tr></tbody></table><ul><li>从理论上看，当EXTRACT-MIN和DELETE数目相比于其他操作小得多的时候，斐波那契堆尤为合适。例如，一些图问题算法可能每条边调用一次DECREASE-KEY。对于有很多边的稠密图，每次调用DECREASE-KEY需要<span class="math inline">\(\Theta(1)\)</span>摊还时间，相比起二叉堆最坏情况时间<span class="math inline">\(\Theta(\lg{n})\)</span>，其积累起来是个很大的改进。如最小生成树和寻找单源最短路径的快速算法必不可少地要用到斐波那契堆。</li><li>从实际上看，除了某些需要管理大量数据的应用外，对于大多数应用，斐波那契堆的常数因子和编程复杂性使得它比起普通二项（或k项）堆并不那么适用。因此对斐波那契堆的研究主要出于理论研究。</li></ul><a id="more"></a><h1 id="结构">结构</h1><p>一个斐波那契堆（Fibonacci heap）一系列具有最小堆序（min-heap ordered）的有根树的集合。也就是说，每棵树均遵守最小堆性质（min-heap property）：每个结点的关键字大于或等于它的父结点的关键字。</p><p>斐波那契堆的每个结点x包含：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    int     key      <span class="comment"># 值</span></span><br><span class="line">    int     degree   <span class="comment"># 度，孩子数目</span></span><br><span class="line">    Node    left     <span class="comment"># 左兄弟</span></span><br><span class="line">    Node    right    <span class="comment"># 右兄弟</span></span><br><span class="line">    Node    p        <span class="comment"># 父节点</span></span><br><span class="line">    Node    child    <span class="comment"># 任意一个孩子</span></span><br><span class="line">    bool    marked   <span class="comment"># 是否第一次被删除某个孩子</span></span><br></pre></td></tr></table></figure><p>x的所有孩子被链接成一个环形的双向链表（如下图(b)所示，通常情况下省略了指针，将图画成(a)的样子，因为很容易从(a)中推断出指针指向），称为x的孩子链表（child list）。</p><p>斐波那契堆H包含：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FiboHeap</span>:</span></span><br><span class="line">    Node        min        <span class="comment"># 堆中最小结点（minimum node）</span></span><br><span class="line">    LinkedList  root_list  <span class="comment"># 包含所有根结点的双向环形链表</span></span><br><span class="line">    int         n          <span class="comment"># 堆中所有结点数目</span></span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-algorithms/fibonacci-heap.png" title="斐波那契堆"></p><h1 id="可合并堆">可合并堆</h1><h2 id="创建一个新的斐波那契堆">创建一个新的斐波那契堆</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MAKE-FIB-HEAP():</span><br><span class="line">    H = FiboHeap()</span><br><span class="line">    H.n         = <span class="number">0</span>                 <span class="comment"># 结点数目为0</span></span><br><span class="line">    H.min       = NIL               <span class="comment"># 最小结点为NIL</span></span><br><span class="line">    H.root_list = new LinkedList()  <span class="comment"># 根链表初始为空</span></span><br><span class="line">    <span class="keyword">return</span> H</span><br></pre></td></tr></table></figure><h2 id="插入一个结点">插入一个结点</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FIB-HEAP-INSERT(H, x):</span><br><span class="line">    x.degree    = <span class="number">0</span>                        <span class="comment"># 初始化x的属性</span></span><br><span class="line">    x.p         = NIL</span><br><span class="line">    x.child     = NIL</span><br><span class="line">    x.mark      = <span class="literal">False</span></span><br><span class="line">    H.root_list.insert(x)                  <span class="comment"># 将x插入H的根链表</span></span><br><span class="line">    <span class="keyword">if</span> H.min == NIL <span class="keyword">or</span> x.key &lt; H.min.key:  <span class="comment"># 更新H.min</span></span><br><span class="line">        H.min = x</span><br><span class="line">    H.n = H.n + <span class="number">1</span>                          <span class="comment"># 更新结点数目</span></span><br></pre></td></tr></table></figure><p>在一个斐波那契堆中插入键值为21的结点：</p><p><img src="/uploads/image/introduction-to-algorithms/fib-heap-insert.png" title="插入"></p><p>图中插入位置为H.min的前驱，实际的插入位置没有影响。</p><h2 id="两个斐波那契堆的合并">两个斐波那契堆的合并</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FIB-HEAP-UNION(H1, H2):</span><br><span class="line">    H = MAKE-FIB-HEAP()</span><br><span class="line">    H.root_list = concatenate(H1.root_list, H2.root_list) <span class="comment"># 合并根链表</span></span><br><span class="line">    H.min = H1.min      <span class="comment"># 判断合并后堆的最小结点</span></span><br><span class="line">    <span class="keyword">if</span> H1.min == NIL <span class="keyword">or</span> (H2.min != NIL <span class="keyword">and</span> H2.min.key &lt; H1.min.key):</span><br><span class="line">        H.min = H2.min</span><br><span class="line">    H.n = H1.n + H2.n   <span class="comment"># 更新结点数目</span></span><br><span class="line">    <span class="keyword">return</span> H</span><br></pre></td></tr></table></figure><h2 id="抽取最小结点">抽取最小结点</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FIB-HEAP-EXTRACT-MIN(H):</span><br><span class="line">    z = H.min</span><br><span class="line">    <span class="keyword">if</span> z != NIL:</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> z.child:           <span class="comment"># 将min的所有孩子结点移动到根链表</span></span><br><span class="line">            H.root_list.insert(x)   <span class="comment"># 更新left和right</span></span><br><span class="line">            x.p = NIL               <span class="comment"># 更新父节点，不更新child意味着孩子结点x的孩子结点不变</span></span><br><span class="line">        H.root_list.delete(z)       <span class="comment"># 删除最小结点min</span></span><br><span class="line">        H.min = NIL</span><br><span class="line">        CONSOLIDATE(H)              <span class="comment"># 子过程</span></span><br><span class="line">        H.n = H.n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> z</span><br></pre></td></tr></table></figure><p>其中子过程CONSOLIDATE(H)用来把具有相同度数的根节点合并（consolidating），直到每个度数至多只有一个根。该过程使用一个辅助数组<code>A[0...D(H.n)]</code>来记录根节点对用的度数的轨迹，其中D(H.n)表示一个n个结点的斐波那契堆中任何结点的最大度数上界（<span class="math inline">\(D(n)=O(\lg{n})\)</span>）。如果A[i]=y，那么当前的y是一个具有y.degree=i的根。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CONSOLIDATE(H):</span><br><span class="line">    let A[<span class="number">0.</span>.D(H.n)] be a new array</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to D(H.n):  <span class="comment"># 初始化A</span></span><br><span class="line">        A[i] = NIL</span><br><span class="line">    <span class="keyword">for</span> each node w <span class="keyword">in</span> the root list of H:</span><br><span class="line">        x = w</span><br><span class="line">        d = x.degree</span><br><span class="line">        <span class="keyword">while</span> A[d] != NIL:</span><br><span class="line">            y = A[d]      <span class="comment"># 另一个具有相同度数d的结点y</span></span><br><span class="line">            <span class="keyword">if</span> x.key &gt; y.key:</span><br><span class="line">                exchange x <span class="keyword">with</span> y   <span class="comment"># 始终保证x.key &lt; y.key</span></span><br><span class="line">            FIB-HEAP-LINK(H, y, x)  <span class="comment"># 子过程：将y链接为x的孩子结点</span></span><br><span class="line">            A[d] = NIL              <span class="comment"># 合并后具有度数d的结点不存在了</span></span><br><span class="line">            d = d + <span class="number">1</span>               <span class="comment"># 合并后x的度数，通过while循环再次寻找具有相同度数的结点y</span></span><br><span class="line">        A[d] = x                    <span class="comment"># 不存在相同度数d的y，记录x的度数信息</span></span><br><span class="line">        <span class="keyword">if</span> H.min == NIL <span class="keyword">or</span> x.key &lt; H.min.key:  <span class="comment"># 更新min结点</span></span><br><span class="line">            H.min = x</span><br><span class="line"></span><br><span class="line">FIB-HEAP-LINK(H, y, x):</span><br><span class="line">    H.root_list.delete(y)    <span class="comment"># 从H的根链表中移除y</span></span><br><span class="line">    x.child.insert(y)        <span class="comment"># 将y添加到x的孩子结点中</span></span><br><span class="line">    x.degree = x.degree + <span class="number">1</span>  <span class="comment"># 更新x的度</span></span><br><span class="line">    y.mark = <span class="literal">False</span>           <span class="comment"># 清除y上的标记</span></span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-algorithms/fib-heap-extract-min.png" title="提取最小的元素"></p><ul><li><span class="math inline">\((a)\)</span> 从当前的斐波那契堆中提取最小结点H.min。以后把“键值为x的结点”省略称为“结点x“。</li><li><span class="math inline">\((a)\rightarrow(b)\)</span> 将结点3的所有子节点移动到根链表。H.min指针右移一位。此时不一定指向最小元素，在后续操作中会调整。</li><li><span class="math inline">\((b)\rightarrow(c)\)</span> 创建一个辅助数组A，遍历根链表。当前结点的度数为1，A[1]为空，将A[1]指向当前结点。继续下一位。</li><li><span class="math inline">\((d)\rightarrow(e)\)</span> 过程类似。结果是A[2]指向度数为2的结点24；A[0]指向度数为0的结点23。</li><li><span class="math inline">\((e)\rightarrow(f)\)</span> 结点7的度数为0，但A[0]不为空，将结点7与A[0]指向的结点23合并：键值较大的结点23移动到结点7的子节点链表中。移动后，清除A[0]。</li><li><span class="math inline">\((f)\rightarrow(g)\)</span> 结点7的度数为1，A[1]不为空且指向结点17。于是将结点17移动到结点7的子结点链表中。清除A[1]。</li><li><span class="math inline">\((g)\rightarrow(h)\)</span> 结点7的度数为2，A[2]不为空且指向24。合并结点7与结点24。清除A[2]。此时结点7的度数为3，而A[3]为空，令A[3]指向结点结点7。继续下一个结点。</li><li><span class="math inline">\((i)\rightarrow(j)\)</span> A[0]指向结点21；A[1]指向结点18。</li><li><span class="math inline">\((j)\rightarrow(k)\)</span> 结点52度数为0，A[0]不为空且指向21。合并结点21与结点52。清除A[0]；合并后结点21的度数为1，A[1]指向结点18。合并结点21与结点18。清除A[1]；合并后结点18度数为2，A[2]为空，令A[2]指向结点18。继续下一结点。</li><li><span class="math inline">\((k)\rightarrow(l)\)</span> 结点38的度数为1，A[1]为空。令A[1]指向结点38。继续下一节点。</li><li><span class="math inline">\((m)\)</span> 所有结点遍历完毕。更新H.min。</li></ul><h1 id="减值和删除">减值和删除</h1><h2 id="关键字减值">关键字减值</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FIB-HEAP-DECREASE-KEY(H, x, k):</span><br><span class="line">    <span class="keyword">if</span> k &gt; x.key:</span><br><span class="line">        error <span class="string">"new key is greater than current key"</span></span><br><span class="line">    x.key = k</span><br><span class="line">    y = x.p</span><br><span class="line">    <span class="keyword">if</span> y != NIL <span class="keyword">and</span> x.key &lt; y.key:  <span class="comment"># 如果更新后x的值小于父节点的值，调整堆</span></span><br><span class="line">        CUT(H, x, y)                <span class="comment"># 子过程：切断x与其父节点y之间的链接</span></span><br><span class="line">        CASCADING-CUT(H, y)         <span class="comment"># 子过程：级联切断</span></span><br><span class="line">    <span class="keyword">if</span> x.key &lt; H.min.key:           <span class="comment"># 更新min结点</span></span><br><span class="line">        H.min = x</span><br><span class="line"></span><br><span class="line">CUT(H, x, y):                <span class="comment"># 切断x与其父节点y之间的链接，并将x添加到根链表</span></span><br><span class="line">    y.child.delete(x)        <span class="comment"># remove x from the child list of y</span></span><br><span class="line">    y.degree = y.degree - <span class="number">1</span>  <span class="comment"># decrementint y.degree</span></span><br><span class="line">    H.root_list.insert(x)    <span class="comment"># add x to the root list of H</span></span><br><span class="line">    x.p = NIL</span><br><span class="line">    x.mark = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">CASCADING-CUT(H, y):            <span class="comment"># 级联切断</span></span><br><span class="line">    z = y.p</span><br><span class="line">    <span class="keyword">if</span> z != NIL:</span><br><span class="line">        <span class="keyword">if</span> y.mark == <span class="literal">False</span>:     <span class="comment"># 如果mark为false，那么上次CUT中，是结点y第一次失去孩子</span></span><br><span class="line">            y.mark == <span class="literal">True</span>      <span class="comment"># 第一次失去孩子，mark置为True</span></span><br><span class="line">        <span class="keyword">else</span>:                   <span class="comment"># 如果mark为True，那么上次CUT之前，y已经失去过孩子</span></span><br><span class="line">            CUT(H, y, z)</span><br><span class="line">            CASCADING-CUT(H, Z) <span class="comment"># 向上递归，直到遇到根节点或者一个未被标记的结点（mark=False）</span></span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-algorithms/fib-heap-decrease-key.png" title="减小元素的值"></p><ul><li><span class="math inline">\((a)\)</span> 初始斐波那契堆。将结点46的键值降低为15。</li><li><p><span class="math inline">\((a)\rightarrow(b)\)</span> 修改键值。将修改后的结点15移动到根链表（切断）。其父节点24，之前未被标记。现在失去了一个孩子，标记它。</p></li><li><p><span class="math inline">\((b)\)</span> 在此斐波那契堆上，将结点35的键值降低为5。</p></li><li><span class="math inline">\((b)\rightarrow(c)\)</span> 修改键值，将修改后的结点5移动到根链表（切断）。</li><li><span class="math inline">\((c)\rightarrow(d)\)</span> 结点5的原来的父节点26是被标记的，触发级联切断的条件：切断结点26与其父节点，将结点26移动到根链表，清除其标记。之后对结点26的原来的父节点24递归地调用级联切断过程。</li><li><span class="math inline">\((d)\rightarrow(e)\)</span> 结点24同样是被标记的，切断结点24与其父节点7。最后对结点24的原来的父节点7递归地调用级联切断。</li><li><p>结点7没有父节点，级联切断不处理此类结点。</p></li></ul><h2 id="删除一个结点">删除一个结点</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FIB-HEAP-DELETE(H, x):</span><br><span class="line">    FIB-HEAP-DECREASE-KEY(H, x, -infinty)</span><br><span class="line">    FIB-HEAP-EXTRACT-MIN(H)</span><br></pre></td></tr></table></figure><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> data_structure.linked_list <span class="keyword">import</span> Element, LinkedList, union <span class="keyword">as</span> union_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(Element)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        Element.__init__(self, k)</span><br><span class="line">        self.degree, self.mark = <span class="number">0</span>, <span class="literal">False</span>  <span class="comment"># mark：第1次失去孩子后为True、第2次后为False</span></span><br><span class="line">        self.p = self.child = self.prev = self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.value())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">value</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.child <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> len(self.child) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.key</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;self.key: [c.value() <span class="keyword">for</span> c <span class="keyword">in</span> self.child]&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FibHeap</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.n, self.min = <span class="number">0</span>, <span class="literal">None</span>  <span class="comment"># 堆中结点数目, 堆中最小结点</span></span><br><span class="line">        self.root_list = LinkedList()  <span class="comment"># 根链表</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        s = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self.root_list:</span><br><span class="line">            s.append(str(x))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">', '</span>.join(s)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x.degree, x.mark = <span class="number">0</span>, <span class="literal">False</span></span><br><span class="line">        x.p = x.child = <span class="literal">None</span></span><br><span class="line">        self.root_list.insert(x)  <span class="comment"># 插入根链表</span></span><br><span class="line">        <span class="keyword">if</span> self.min <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> x.key &lt; self.min.key:</span><br><span class="line">            self.min = x</span><br><span class="line">        self.n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        z = self.min</span><br><span class="line">        <span class="keyword">if</span> z <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> z.child <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment"># 将所有子节点插入到根链表</span></span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> z.child:</span><br><span class="line">                    self.root_list.insert(x)</span><br><span class="line">                    x.p = <span class="literal">None</span></span><br><span class="line">            self.min = <span class="literal">None</span></span><br><span class="line">            self.root_list.delete(z)  <span class="comment"># 从根链表中移除</span></span><br><span class="line">            self.consolidate()  <span class="comment"># 合并度数相同的结点</span></span><br><span class="line">            self.n -= <span class="number">1</span>  <span class="comment"># 总结点数目减1</span></span><br><span class="line">            z.child = <span class="literal">None</span>  <span class="comment"># 清除指针，不清除对斐波那契堆也没什么影响</span></span><br><span class="line">        <span class="keyword">return</span> z</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">consolidate</span><span class="params">(self)</span>:</span></span><br><span class="line">        degree = &#123;&#125;  <span class="comment"># degree[i]=y，那么y.degree=i</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self.root_list:  <span class="comment"># 在link()中可能被删除的元素已经访问过，因此可以使用迭代器</span></span><br><span class="line">            d = x.degree</span><br><span class="line">            <span class="keyword">while</span> d <span class="keyword">in</span> degree:</span><br><span class="line">                y = degree.pop(d)  <span class="comment"># another node with the same degree as x</span></span><br><span class="line">                <span class="keyword">if</span> x.key &gt; y.key:</span><br><span class="line">                    x, y = y, x</span><br><span class="line">                self.link(y, x)</span><br><span class="line">                d = d + <span class="number">1</span></span><br><span class="line">            degree[d] = x</span><br><span class="line">            <span class="keyword">if</span> self.min <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> self.min.key &gt; x.key:</span><br><span class="line">                self.min = x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">link</span><span class="params">(self, y, x)</span>:</span></span><br><span class="line">        self.root_list.delete(y)</span><br><span class="line">        y.p = x</span><br><span class="line">        <span class="keyword">if</span> x.child <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            x.child = LinkedList()</span><br><span class="line">        x.child.insert(y)</span><br><span class="line">        x.degree += <span class="number">1</span></span><br><span class="line">        y.mark = <span class="literal">False</span>  <span class="comment"># y成为孩子结点时，mark置为False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decrease_key</span><span class="params">(self, x, k)</span>:</span> <span class="comment"># 没有对结点x是否在堆中进行判断，heap.min可能会指向堆外结点</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; x.key:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'new key is greater than current key'</span>)</span><br><span class="line">        x.key, y = k, x.p</span><br><span class="line">        <span class="keyword">if</span> y <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> x.key &lt; y.key:  <span class="comment"># 当更新后的值小于父节点时调整堆</span></span><br><span class="line">            self.cut(x, y)  <span class="comment"># 切断x与y</span></span><br><span class="line">            self.cascading_cut(y)</span><br><span class="line">        <span class="keyword">if</span> x.key &lt; self.min.key:</span><br><span class="line">            self.min = x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cut</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        y.child.delete(x)  <span class="comment"># 分离x与其父节点y</span></span><br><span class="line">        self.root_list.insert(x)  <span class="comment"># 使x成为根节点</span></span><br><span class="line">        y.degree -= <span class="number">1</span></span><br><span class="line">        x.p, x.mark = <span class="literal">None</span>, <span class="literal">False</span>  <span class="comment"># x成为根结点时，mark置为False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cascading_cut</span><span class="params">(self, y)</span>:</span></span><br><span class="line">        z = y.p</span><br><span class="line">        <span class="keyword">if</span> z <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> y.mark <span class="keyword">is</span> <span class="literal">False</span>:  <span class="comment"># mark=False，是第一次失去孩子</span></span><br><span class="line">                y.mark = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># mark=True,是第二次失去孩子</span></span><br><span class="line">                self.cut(y, z)</span><br><span class="line">                self.cascading_cut(z)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.decrease_key(x, float(<span class="string">'-inf'</span>))</span><br><span class="line">        self.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(h1, h2)</span>:</span></span><br><span class="line">    h = FibHeap()  <span class="comment"># 初始化新堆</span></span><br><span class="line">    h.root_list = union_list(h1.root_list, h2.root_list)  <span class="comment"># 合并根链表，h1和h2的根链表会被销毁</span></span><br><span class="line">    h.min = h1.min  <span class="comment"># 比较最小结点</span></span><br><span class="line">    <span class="keyword">if</span> h1.min <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> (h2.min <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> h2.min.key &lt; h1.min.key):</span><br><span class="line">        h.min = h2.min</span><br><span class="line">    h.n = h1.n + h2.n  <span class="comment"># 结点数目相加</span></span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    h1, h2 = FibHeap(), FibHeap()</span><br><span class="line">    key1, key2 = [<span class="number">23</span>, <span class="number">7</span>, <span class="number">21</span>, <span class="number">3</span>, <span class="number">17</span>, <span class="number">24</span>, <span class="number">18</span>], [<span class="number">52</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">26</span>, <span class="number">46</span>, <span class="number">39</span>, <span class="number">41</span>, <span class="number">35</span>]</span><br><span class="line">    [h1.insert(Node(i)) <span class="keyword">for</span> i <span class="keyword">in</span> key1]</span><br><span class="line">    [h2.insert(Node(i)) <span class="keyword">for</span> i <span class="keyword">in</span> key2]</span><br><span class="line">    print(<span class="string">'h1:'</span>, h1)</span><br><span class="line">    print(<span class="string">'h2:'</span>, h2)</span><br><span class="line">    h = union(h1, h2)  <span class="comment"># union，合并根链表</span></span><br><span class="line">    print(<span class="string">'h:'</span>, h)</span><br><span class="line">    print(<span class="string">'&#123;0:&lt;3s&#125; &#123;1:&lt;6s&#125;'</span>.format(<span class="string">'pop'</span>, <span class="string">'h'</span>))</span><br><span class="line">    <span class="keyword">while</span> h.n &gt; <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">'&#123;0:&lt;3d&#125; &#123;1:&lt;6s&#125;'</span>.format(h.pop().key, str(h)))</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h1: 18, 24, 17, 3, 21, 7, 23</span><br><span class="line">h2: 35, 41, 39, 46, 26, 30, 38, 52</span><br><span class="line">h: 18, 24, 17, 3, 21, 7, 23, 35, 41, 39, 46, 26, 30, 38, 52</span><br><span class="line">pop h</span><br><span class="line">3   &#123;7: [&#123;17: [&#123;18: [24]&#125;, 21]&#125;, &#123;35: [41]&#125;, 23]&#125;, &#123;26: [&#123;39: [46]&#125;, 30]&#125;, &#123;38: [52]&#125;</span><br><span class="line">7   23, &#123;35: [&#123;38: [52]&#125;, 41]&#125;, &#123;17: [&#123;26: [&#123;39: [46]&#125;, 30]&#125;, &#123;18: [24]&#125;, 21]&#125;</span><br><span class="line">17  &#123;18: [&#123;26: [&#123;39: [46]&#125;, 30]&#125;, &#123;21: [23]&#125;, 24]&#125;, &#123;35: [&#123;38: [52]&#125;, 41]&#125;</span><br><span class="line">18  24, &#123;21: [23]&#125;, &#123;26: [&#123;35: [&#123;38: [52]&#125;, 41]&#125;, &#123;39: [46]&#125;, 30]&#125;</span><br><span class="line">21  &#123;23: [24]&#125;, &#123;26: [&#123;35: [&#123;38: [52]&#125;, 41]&#125;, &#123;39: [46]&#125;, 30]&#125;</span><br><span class="line">23  24, &#123;26: [&#123;35: [&#123;38: [52]&#125;, 41]&#125;, &#123;39: [46]&#125;, 30]&#125;</span><br><span class="line">24  &#123;26: [&#123;35: [&#123;38: [52]&#125;, 41]&#125;, &#123;39: [46]&#125;, 30]&#125;</span><br><span class="line">26  30, &#123;39: [46]&#125;, &#123;35: [&#123;38: [52]&#125;, 41]&#125;</span><br><span class="line">30  &#123;39: [46]&#125;, &#123;35: [&#123;38: [52]&#125;, 41]&#125;</span><br><span class="line">35  41, &#123;38: [&#123;39: [46]&#125;, 52]&#125;</span><br><span class="line">38  &#123;39: [&#123;41: [52]&#125;, 46]&#125;</span><br><span class="line">39  46, &#123;41: [52]&#125;</span><br><span class="line">41  &#123;46: [52]&#125;</span><br><span class="line">46  52</span><br><span class="line">52</span><br></pre></td></tr></table></figure><h1 id="应用">应用</h1><ul><li>Dijkstra算法</li><li>Prim算法</li></ul></div><div class="popular-posts-header">相关文章</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/introduction-to-algorithms/heaps-and-heapsort/" rel="bookmark">堆和堆排序</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/introduction-to-algorithms/single-source-shortest-paths/" rel="bookmark">单源最短路径</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/introduction-to-algorithms/binary-search-trees/" rel="bookmark">二叉搜索树</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/introduction-to-algorithms/insertion-sort-selection-sort-and-bubble-sort/" rel="bookmark">插入排序、选择排序和冒泡排序</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/introduction-to-algorithms/merge-sort/" rel="bookmark">归并排序</a></div></li></ul><footer class="post-footer"><div class="post-tags"> <a href="/tags/introduction-to-algorithms/" rel="tag"># 算法导论</a> <a href="/tags/heap/" rel="tag"># 堆</a></div><div class="post-nav"><div class="post-nav-item"><a href="/further-mathematics/stirlings-approximation/" rel="prev" title="斯特灵近似公式"><i class="fa fa-chevron-left"></i> 斯特灵近似公式</a></div><div class="post-nav-item"> <a href="/documentation/tex-commands/" rel="next" title="Tex Commands">Tex Commands<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#斐波那契堆"><span class="nav-number">1.</span> <span class="nav-text">斐波那契堆</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#结构"><span class="nav-number">2.</span> <span class="nav-text">结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#可合并堆"><span class="nav-number">3.</span> <span class="nav-text">可合并堆</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建一个新的斐波那契堆"><span class="nav-number">3.1.</span> <span class="nav-text">创建一个新的斐波那契堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#插入一个结点"><span class="nav-number">3.2.</span> <span class="nav-text">插入一个结点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#两个斐波那契堆的合并"><span class="nav-number">3.3.</span> <span class="nav-text">两个斐波那契堆的合并</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#抽取最小结点"><span class="nav-number">3.4.</span> <span class="nav-text">抽取最小结点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#减值和删除"><span class="nav-number">4.</span> <span class="nav-text">减值和删除</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#关键字减值"><span class="nav-number">4.1.</span> <span class="nav-text">关键字减值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除一个结点"><span class="nav-number">4.2.</span> <span class="nav-text">删除一个结点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#代码"><span class="nav-number">5.</span> <span class="nav-text">代码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#应用"><span class="nav-number">6.</span> <span class="nav-text">应用</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="菜农陈文生" src="/uploads/avatar/nekosensei.png"><p class="site-author-name" itemprop="name">菜农陈文生</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">242</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">13</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">159</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/cncws" title="GitHub → https://github.com/cncws" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a></span><span class="links-of-author-item"><a href="mailto:1031616423@qq.com" title="E-Mail → mailto:1031616423@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">菜农陈文生</span></div><script src="//cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="//cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script><script src="/js/aplayer-el.js"></script><script src="//unpkg.com/video.js/dist/video.min.js"></script><script src="/js/videojs-bilibili.js"></script><script src="/js/videojs-bilibili-el.js"></script></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script><script src="/js/local-search.js"></script><div id="pjax"><script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Axl15EIRi5o5AatKaxXxV4Oq-gzGzoHsz',
      appKey     : 'E0qm04UjsP0qQN1l8ME3GQ25',
      placeholder: "Just go go",
      avatar     : 'identicon',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script></div></body></html>