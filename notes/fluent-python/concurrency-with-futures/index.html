<!DOCTYPE html><html lang="zh-CN,en,default"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/uploads/icons/taraxacum-blue.png"><link rel="icon" type="image/png" sizes="16x16" href="/uploads/icons/taraxacum-blue.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|ZCOOL XiaoWei:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:new URL("https://cwscn.github.io").hostname,root:"/",scheme:"Gemini",version:"7.7.1",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!0,lazyload:!0,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"fadeIn"}}}</script><meta name="description" content="本章讨论Python3.2引入的concurrent.futures模块。“期物”（future）是译者自创的词。期物指一种对象，表示异步执行的操作。 示例：网络下载的三种风格 为了高效处理网络I/O，需要使用并发，因为网络有很高的延迟，所以为了不浪费CPU周期去等待，最好在收到网络相应之前做些其他的事。本章有3个示例程序，从网上下载20个国家的国旗图像。第一个示例程序是依序下载的：下载完一个图像"><meta name="keywords" content="Fluent Python,concurrency,futures"><meta property="og:type" content="article"><meta property="og:title" content="使用futures处理并发"><meta property="og:url" content="https://cwscn.github.io/notes/fluent-python/concurrency-with-futures/index.html"><meta property="og:site_name" content="蒲公英花园"><meta property="og:description" content="本章讨论Python3.2引入的concurrent.futures模块。“期物”（future）是译者自创的词。期物指一种对象，表示异步执行的操作。 示例：网络下载的三种风格 为了高效处理网络I/O，需要使用并发，因为网络有很高的延迟，所以为了不浪费CPU周期去等待，最好在收到网络相应之前做些其他的事。本章有3个示例程序，从网上下载20个国家的国旗图像。第一个示例程序是依序下载的：下载完一个图像"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2020-01-29T09:40:03.474Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="使用futures处理并发"><meta name="twitter:description" content="本章讨论Python3.2引入的concurrent.futures模块。“期物”（future）是译者自创的词。期物指一种对象，表示异步执行的操作。 示例：网络下载的三种风格 为了高效处理网络I/O，需要使用并发，因为网络有很高的延迟，所以为了不浪费CPU周期去等待，最好在收到网络相应之前做些其他的事。本章有3个示例程序，从网上下载20个国家的国旗图像。第一个示例程序是依序下载的：下载完一个图像"><link rel="canonical" href="https://cwscn.github.io/notes/fluent-python/concurrency-with-futures/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0}</script><title>使用futures处理并发 | 蒲公英花园</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">蒲公英花园</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">去留无意 闲看庭前花开花落<br>宠辱不惊 漫随天外云卷云舒</p></div><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i> 分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css"><meting-js server="netease" type="playlist" id="70770150" theme="#ffafc9" loop="all" order="list" preload="none" volume="" list-folded="NaN" fixed="true"></meting-js></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwscn.github.io/notes/fluent-python/concurrency-with-futures/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar/nekosensei.png"><meta itemprop="name" content="Chen"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="蒲公英花园"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 使用futures处理并发</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-01-29 17:40:03" itemprop="dateModified" datetime="2020-01-29T17:40:03+08:00">2020-01-29</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/notes/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/notes/fluent-python/concurrency-with-futures/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/notes/fluent-python/concurrency-with-futures/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><p>本章讨论Python3.2引入的concurrent.futures模块。“期物”（future）是译者自创的词。期物指一种对象，表示异步执行的操作。</p><h1 id="示例网络下载的三种风格">示例：网络下载的三种风格</h1><p>为了高效处理网络I/O，需要使用并发，因为网络有很高的延迟，所以为了不浪费CPU周期去等待，最好在收到网络相应之前做些其他的事。本章有3个示例程序，从网上下载20个国家的国旗图像。第一个示例程序是依序下载的：下载完一个图像，并将其保存在硬盘中之后，才请求下一个图像。另外两个脚本是并发下载（分别使用concurrent.futres模块和asyncio包）的：几乎同时请求所有图像，每下载完一个文件就保存一个文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ python flags.py</span><br><span class="line">BD BR CD CN DE EG ET FR ID IN IR JP MX NG PH PK RU TR US VN</span><br><span class="line">20 flags downloaded in 3.41s</span><br><span class="line">$ python flags_threadpool.py</span><br><span class="line">IN ID CN EG TR NG JP FR DE PK VN RU ET MX PH US IR CD BR BD</span><br><span class="line">20 flags downloaded in 0.20s</span><br><span class="line">$ python flags_asyncio.py</span><br><span class="line">JP CN PK PH EG FR TR BD IN ET RU BR DE ID US NG MX IR CD VN</span><br><span class="line">20 flags downloaded in 0.26s</span><br></pre></td></tr></table></figure><p>两个并发下载的脚本之间性能差异不大，不过都比依序下载的脚本快5倍多（原书是5倍多，我的结果相差更大）。这只是一个特别小的任务，如果把下载的文件数量增加到几百个，并发下载的脚本能比依序下载的脚本快20倍或更多。将这三个脚本一起演示是为了表明一个观点：<strong>在I/O密集型应用中，如果代码写的正确，那么不管使用哪种并发策略（使用线程或asyncio包），吞吐量都比依序执行的代码高得多。</strong></p><a id="more"></a><h2 id="依序下载的脚本">依序下载的脚本</h2><figure class="highlight python"><figcaption><span>flags.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests  <span class="comment"># 导入requests库，这个库不在标准库中</span></span><br><span class="line"></span><br><span class="line">POP20_CC = (<span class="string">'CN IN US ID BR PK NG BD RU JP '</span></span><br><span class="line">            <span class="string">'MX PH VN ET EG DE IR TR CD FR'</span>).split()</span><br><span class="line"></span><br><span class="line">BASE_URL = <span class="string">'http://flupy.org/data/flags'</span></span><br><span class="line"></span><br><span class="line">DEST_DIR = <span class="string">'downloads/'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_flag</span><span class="params">(img, filename)</span>:</span></span><br><span class="line">    path = os.path.join(DEST_DIR, filename)</span><br><span class="line">    <span class="keyword">with</span> open(path, <span class="string">'wb'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(img)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flag</span><span class="params">(cc)</span>:</span></span><br><span class="line">    url = <span class="string">'&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif'</span>.format(BASE_URL, cc=cc.lower())</span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    <span class="keyword">return</span> resp.content</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(text)</span>:</span></span><br><span class="line">    print(text, end=<span class="string">' '</span>)</span><br><span class="line">    sys.stdout.flush()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> cc <span class="keyword">in</span> sorted(cc_list):  <span class="comment"># 按序下载</span></span><br><span class="line">        image = get_flag(cc)</span><br><span class="line">        show(cc)</span><br><span class="line">        save_flag(image, cc.lower() + <span class="string">'.gif'</span>)</span><br><span class="line">    <span class="keyword">return</span> len(cc_list)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(download_many)</span>:</span></span><br><span class="line">    t0 = time.time()</span><br><span class="line">    count = download_many(POP20_CC)</span><br><span class="line">    elapsed = time.time() - t0</span><br><span class="line">    msg = <span class="string">'\n&#123;&#125; flags downloaded in &#123;:.2f&#125;s'</span></span><br><span class="line">    print(msg.format(count, elapsed))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main(download_many)</span><br></pre></td></tr></table></figure><h2 id="使用concurrent.futures模块下载">使用concurrent.futures模块下载</h2><p>concurrent.futures模块的主要特色是ThreadPoolExecutor和ProcessPoolExecutor类，这两个类实现的接口能分别在不同的线程或进程中执行可调用的对象。这两个类在内部维护这一个工作线程或进程池，以及要执行的任务队列。不过，这个接口抽象的层级很高，像下载国旗这种简单的案例，无需关心任何细节。</p><figure class="highlight python"><figcaption><span>flags_threadpool.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flags <span class="keyword">import</span> save_flag, get_flag, show, main  <span class="comment"># 重用函数</span></span><br><span class="line"></span><br><span class="line">MAX_WOKERS = <span class="number">20</span>  <span class="comment"># 设置最大线程数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_one</span><span class="params">(cc)</span>:</span>  <span class="comment"># 下载一个国旗，这是在各个线程中执行的函数</span></span><br><span class="line">    image = get_flag(cc)</span><br><span class="line">    show(cc)</span><br><span class="line">    save_flag(image, cc.lower() + <span class="string">'.gif'</span>)</span><br><span class="line">    <span class="keyword">return</span> cc</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list)</span>:</span></span><br><span class="line">    wokers = min(MAX_WOKERS, len(cc_list))  <span class="comment"># 避免创建多余的线程</span></span><br><span class="line">    <span class="comment"># executor.__exit__方法会调用executor.shutdown(wait=True)方法</span></span><br><span class="line">    <span class="comment"># 它会在所有线程都执行完毕前阻塞线程</span></span><br><span class="line">    <span class="keyword">with</span> futures.ThreadPoolExecutor(wokers) <span class="keyword">as</span> executor:</span><br><span class="line">        res = executor.map(download_one, sorted(cc_list))  <span class="comment"># 返回一个生成器</span></span><br><span class="line">    <span class="keyword">return</span> len(list(res))  <span class="comment"># 获取各个函数返回的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main(download_many)</span><br></pre></td></tr></table></figure><h3 id="期物在哪里">期物在哪里</h3><p>期物是concurrent.futures模块和asyncio包的重要组件，可是，作为这两个库的用户，我们有时却见不到期物。</p><p>从Python3.4起，标准库中有两个名为Future的类：concurrent.futures.Future和asyncio.Future。这两个类的作用相同：两个Future类的实例都表示可能已经完成或者尚未完成的延迟计算。这与Twisted引擎中的Deferred类、Tornado框架中的Future类，以及多个JavaScript库中的Promise对象类似。</p><p>期物封装待完成的操作，可以放入队列，完成的状态可以查询，得到结果（或抛出异常）后可以获取结果（或异常）。</p><p>我们要记住一件事：<strong>通常情况下自己不应该创建期物，而只能由并发框架（concurrent.futures或asyncio）实例化。</strong>原因很简单：期物表示终将发生的事情，而确定某件事会发生的唯一方式是执行的时间已经排定。因此，只有排定把某件事交给concurrent.futures.Executor子类处理时，才会创建concurrent.futures.Future实例。例如，Executor.submit方法的参数是一个可调用的对象，调用这个方法后会为传入的可调用对象排期，并返回一个期物。</p><p>客户端代码不应该改变期物的状态，并发框架在期物表示的延迟计算结束后会改变期物的状态，而我们无法控制计算何时结束。</p><p>这两种期物都有done方法，这个方法不阻塞，返回值是布尔值，指明期物链接的可调用对象是否已经执行。客户端代码通常不会询问期物是否运行结束，而是会等待通知。因此，两个Future类都有add_done_callback方法：这个方法只有一个参数，类型是可调用的对象，期物运行结束后会调用指定的可调用对象。</p><p>此外，还有result方法。在期物运行结束后调用的话，这个方法在两个Future类中的作用相同：返回可调用对象的结果，或者重新抛出执行可调用的对象时抛出的异常。可是，如果期物没有运行结束，result方法在两个Future类中的行为相差很大。对concurrency.futures.Future实例来说，调用f.result()方法会阻塞调用方所在的线程，直到有结果可以返回。此时，result方法可以接收可选的timeout参数，如果在指定的时间内没有运行完毕，会抛出TimeoutError异常。asyncio.Future.result方法不支持设定超过时间，在那个库中获取期物的结果最好使用yield from结构。不过，对concurrency.futures.Future实例不能这么做。</p><p>这两个库中有几个函数会返回期物，其他函数则使用期物，以易于用户理解的方式实现自身。Executor.map方法属于后者：返回值是一个迭代器，迭代器的<code>__next__</code>方法调用各个期物的result方法，因此我们得到的是各个期物的结果，而非期物本身。</p><p>为了从实用的角度理解期物，我们可以实用concurrent.futures.as_completed函数重写示例。这个函数的参数是一个期物列表，返回值是一个迭代器，在期物运行结束后产出期物。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list)</span>:</span></span><br><span class="line">    cc_list = cc_list[:<span class="number">5</span>]  <span class="comment"># 使用5个做演示</span></span><br><span class="line">    <span class="keyword">with</span> futures.ThreadPoolExecutor(max_workers=<span class="number">3</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        to_do = []</span><br><span class="line">        <span class="keyword">for</span> cc <span class="keyword">in</span> sorted(cc_list):</span><br><span class="line">            future = executor.submit(download_one, cc)  <span class="comment"># 排定可调用对象的执行时间，返回一个期物</span></span><br><span class="line">            to_do.append(future)</span><br><span class="line">            msg = <span class="string">'Scheduled for &#123;&#125;: &#123;&#125;'</span></span><br><span class="line">            print(msg.format(cc, future))</span><br><span class="line">        results = []</span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> futures.as_completed(to_do):  <span class="comment"># 在期物运行结束后产出期物</span></span><br><span class="line">            res = future.result()  <span class="comment"># 这次不会阻塞，因为future由as_completed函数产出</span></span><br><span class="line">            msg = <span class="string">'&#123;&#125; result: &#123;!r&#125;'</span></span><br><span class="line">            print(msg.format(future, res))</span><br><span class="line">            results.append(res)</span><br><span class="line">        <span class="keyword">return</span> len(results)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ python flags_threadpool.py</span><br><span class="line">Scheduled for BR: &lt;Future at 0x1031a25f8 state=running&gt;</span><br><span class="line">Scheduled for CN: &lt;Future at 0x1031ae0f0 state=running&gt;</span><br><span class="line">Scheduled for ID: &lt;Future at 0x1031ae6a0 state=running&gt;  # 最大3个</span><br><span class="line">Scheduled for IN: &lt;Future at 0x1031bb080 state=pending&gt;</span><br><span class="line">Scheduled for US: &lt;Future at 0x1031bb160 state=pending&gt;</span><br><span class="line">CN &lt;Future at 0x1031ae0f0 state=finished returned str&gt; result: &apos;CN&apos;</span><br><span class="line">ID BR &lt;Future at 0x1031ae6a0 state=finished returned str&gt; result: &apos;ID&apos;</span><br><span class="line">&lt;Future at 0x1031a25f8 state=finished returned str&gt; result: &apos;BR&apos;</span><br><span class="line">IN &lt;Future at 0x1031bb080 state=finished returned str&gt; result: &apos;IN&apos;</span><br><span class="line">US &lt;Future at 0x1031bb160 state=finished returned str&gt; result: &apos;US&apos;</span><br><span class="line"></span><br><span class="line">5 flags downloaded in 0.32s</span><br></pre></td></tr></table></figure><p>多次运行脚本看到的结果有所不同。如果把max_workers参数的值增大到5，结果的顺序变化更多。把max_workers参数的值设为1，代码依序运行，结果的顺序始终与调用submit方法的顺序一致。</p><h2 id="使用asyncio模块下载">使用asyncio模块下载</h2><figure class="highlight python"><figcaption><span>flags_asyncio.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这段脚本与原文的脚本代码不同，使用了Python3.5引入的async和await关键字</span></span><br><span class="line"><span class="comment"># 原脚本中的一些写法可能不再是推荐写法了，愿脚本的代码也不进行分析了</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> aiohttp  <span class="comment"># 它不在标准库中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flags <span class="keyword">import</span> BASE_URL, save_flag, show, main</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_flag</span><span class="params">(client, cc)</span>:</span></span><br><span class="line">    url = <span class="string">'&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif'</span>.format(BASE_URL, cc=cc.lower())</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> client.get(url) <span class="keyword">as</span> resp:</span><br><span class="line">        <span class="keyword">assert</span> resp.status == <span class="number">200</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> resp.read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">download_one</span><span class="params">(cc)</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> client:</span><br><span class="line">        image = <span class="keyword">await</span> get_flag(client, cc)</span><br><span class="line">        show(cc)</span><br><span class="line">        save_flag(image, cc.lower() + <span class="string">'.gif'</span>)</span><br><span class="line">        <span class="keyword">return</span> cc</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list)</span>:</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    to_do = [download_one(cc) <span class="keyword">for</span> cc <span class="keyword">in</span> sorted(cc_list)]</span><br><span class="line">    <span class="comment"># 虽然函数名是wait，但它不是阻塞性函数。wait是一个协程，等传给它所有协程运行完毕后结束</span></span><br><span class="line">    wait_coro = asyncio.wait(to_do)</span><br><span class="line">    <span class="comment"># 执行事件循环，直到wait_coro运行结束；事件循环运行的过程中，这个脚本会在这里阻塞</span></span><br><span class="line">    res, _ = loop.run_until_complete(wait_coro)</span><br><span class="line">    loop.close()  <span class="comment"># 关闭事件循环</span></span><br><span class="line">    <span class="keyword">return</span> len(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main(download_many)</span><br></pre></td></tr></table></figure><p>严格来说，我们目前测试的并发脚本都不能并行下载。使用concurrent.futures库实现的那两个示例受GIL（Global Interpreter Lock，全局解释器锁）的限制，而使用asyncio库实现的脚本在单个线程中运行。</p><ul><li>既然Python线程受GIL的限制，任何时候都只允许运行一个线程，那么flags_threadpool.py脚本的下载速度怎么会比flags.py脚本快5倍？这是因为GIL几乎对<strong>I/O密集型</strong>处理无害。原因见下一节阻塞型I/O和GIL。</li><li>flags_asyncio.py脚本和flags.py脚本都在单个线程中运行，前者怎么会比后者快5倍？原因见下下一节避免阻塞型调用。</li></ul><h1 id="阻塞型io和gil">阻塞型I/O和GIL</h1><p>CPython解释器本身就不是线程安全的，因此有全局解释器锁（GIL），一次只允许使用一个线程执行Python字节码（这是CPython解释器的局限，与Python语言本身无关）。因此，一个Python进程通常不能同时使用多个CPU核心。</p><p>编写Python代码时无法控制GIL；不过，执行耗时的任务时，可以使用一个内置的函数或一个使用C语言编写的扩展释放GIL。其实，有个使用C语言编写的Python库能管理GIL，自行启动操作系统线程，利用全部可用的CPU核心。这样做会极大地增加库代码的复杂度，因此大多数库的作者都不这么做。</p><p>然而，<strong>标准库中的所有执行阻塞型I/O操作的函数，在等待操作系统返回结果时都会释放GIL。这意味着在Python语言这个层次上可以使用多线程，而I/O密集型Python程序能从中受益：一个Python线程等待网络响应时，阻塞型I/O函数会释放GIL，再运行一个线程。</strong></p><p>下面简单说明如何在<strong>CPU密集型</strong>作业中使用concurrent.futures模块轻松绕开GIL。</p><h1 id="避免阻塞型调用">避免阻塞型调用</h1><p>用asyncio包时，我们编写的异步代码中包含由asyncio本身驱动的协程（即委派生成器），而生成器最终把职责委托给asyncio包或第三方库（如aiohttp）中的协程。这种处理方式相当于架起了管道，让asyncio事件循环（通过我们编写的协程）驱动执行低层异步I/O操作的库函数。</p><p>有两种方法能避免阻塞型调用中止整个应用程序的进程：</p><ul><li>在单独的线程中运行各个阻塞型操作</li><li>把每个阻塞型操作转换成非阻塞的异步调用使用</li></ul><p>多个线程是可以的，但是各个操作系统线程（Python使用的是这种线程）消耗的内存达兆字节（具体的量取决于操作系统种类）。如果要处理几千个连接，而每个连接都使用一个线程的话，我们负担不起。</p><p>为了降低内存的消耗，通常使用回调来实现异步调用。使用回调时，我们不等待响应，而是注册一个函数，在发生某件事时调用。这样，所有调用都是非阻塞的。因为回调简单，而且消耗低，所以Ryan Dahl（Node.js的发明者）用户这种方式。</p><p>当然，只有异步应用程序底层的事件循环能依靠各种基础设置的中断、线程、轮询和后台进程等，确保多个并发请求能取得进展并最终完成，这样才能使用回调。事件循环获得响应后，会回过头来调用我们指定的回调。不过，如果做法正确，事件循环和应用代码共用的主线程绝不会阻塞。</p><p>把生成器当作协程使用是异步编程的另一种方式。对事件循环来说，调用回调与在暂停的协程上调用send方法效果差不多。各个暂停的协程是要消耗内存，但是比线程消耗的内存数量级小。而且，协程能避免可怕的“回调地狱”。</p><p>flags.py脚本依序下载，而每次下载都要用几十亿个CPU周期等待即过。其实，CPU同时做了很多事，只是没有运行你的程序。与此相比，在flags_asyncio.py脚本中，在download_many函数中调用loop.run_until_complete方法时，事件循环驱动各个download_one协程，各个download_one协程中又驱动各个get_flag协程，运行到client.get(url)。这些调用都不会阻塞，因此在零点几秒内所有请求全部开始。</p><p>asyncio的基础设施获得第一个响应后，事件循环把响应发给等待结果的get_flag协程。得到响应后，get_flag向前执行，调用resp.read方法，然后把控制权还给主循环。（我不确定这段描述是否符合<code>return await resp.read()</code>的运行过程；作为参考，原脚本的代码是<code>return yield from resp.read()</code>）</p><p>因为异步操作是交叉执行的，所以并发下载多张图像所需的总时间比依序下载少得多。</p><h1 id="使用concurrent.futures模块启动进程">使用concurrent.futures模块启动进程</h1><p>concurrent.futures模块的文档副标题是“Launching parallel tasks”（执行并行任务）。这个模块实现的是真正的并行计算，因为它使用ProcessPoolExecutor类把工作分配给多个Python进程处理。因此，如果需要做CPU密集型处理，使用这个模块能绕开GIL，利用所有可用CPU核心。</p><p><a href="https://devdocs.io/python~3.6/library/concurrent.futures#concurrent.futures.ProcessPoolExecutor" target="_blank" rel="noopener">ProcessPoolExecutor</a>和<a href="https://devdocs.io/python~3.6/library/concurrent.futures#concurrent.futures.ThreadPoolExecutor" target="_blank" rel="noopener">ThreadPoolExecutor</a>类都实现了通用的Executor接口，因此使用concurrent.futures模块能特别轻松地把基于线程的方案转成基于进程的方案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list)</span>:</span></span><br><span class="line">    workers = min(MAX_WORKERS, len(cc_list))</span><br><span class="line">    <span class="keyword">with</span> futures.ThreadPoolExecutor(workers) <span class="keyword">as</span> executor:  <span class="comment"># 基于线程</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> futures.ProcessPoolExecutor() <span class="keyword">as</span> executor:  <span class="comment"># 基于进程</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p><code>ThreadPoolExecutor.__init__</code>方法需要<code>max_workers</code>参数，指定线程池中线程的数量。在ProcessPoolExecutor类中，那个参数是可选的，而且大多数情况下不实用——默认值是<code>os.cpu_count()</code>函数返回的CPU数量。这样处理说得通，因为对于CPU密集型的处理来说，不可能要求使用超过CPU数量的workers。而对I/O密集型处理来说，可以在一个ThreadPoolExecutor实例中使用10个、100个或1000个线程；最佳线程数取决于做的是什么事，以及可用内存有多少，因此要仔细测试才能找到最佳的线程数。</p><h1 id="实验executor.map方法">实验Executor.map方法</h1><p>若想并发运行多个可调用的对象，最简单的方式是使用示例中见过的Executor.map方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep, strftime</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(*args)</span>:</span>  <span class="comment"># 打印传入的参数并在前加一个时间戳</span></span><br><span class="line">    print(strftime(<span class="string">'[%H:%M:%S]'</span>), end=<span class="string">' '</span>)</span><br><span class="line">    print(*args)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loiter</span><span class="params">(n)</span>:</span></span><br><span class="line">    msg = <span class="string">'&#123;&#125;loiter(&#123;&#125;): doing nothing for &#123;&#125;s...'</span></span><br><span class="line">    display(msg.format(<span class="string">'\t'</span>*n, n, n))</span><br><span class="line">    sleep(n)</span><br><span class="line">    msg = <span class="string">'&#123;&#125;loiter(&#123;&#125;): done.'</span></span><br><span class="line">    display(msg.format(<span class="string">'\t'</span>*n, n))</span><br><span class="line">    <span class="keyword">return</span> n * <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    display(<span class="string">'Script starting.'</span>)</span><br><span class="line">    executor = futures.ThreadPoolExecutor(max_workers=<span class="number">3</span>)</span><br><span class="line">    results = executor.map(loiter, range(<span class="number">5</span>))</span><br><span class="line">    display(<span class="string">'results:'</span>, results)  <span class="comment"># 返回的是生成器，目前不会阻塞</span></span><br><span class="line">    display(<span class="string">'Waiting for individual results:'</span>)</span><br><span class="line">    <span class="keyword">for</span> i, result <span class="keyword">in</span> enumerate(results):</span><br><span class="line">        display(<span class="string">'result &#123;&#125;: &#123;&#125;'</span>.format(i, result))</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ python demo_executor_map.py</span><br><span class="line">[21:31:07] Script starting.</span><br><span class="line">[21:31:07] loiter(0): doing nothing for 0s...</span><br><span class="line">[21:31:07] loiter(0): done.</span><br><span class="line">[21:31:07]     loiter(1): doing nothing for 1s...</span><br><span class="line">[21:31:07]         loiter(2): doing nothing for 2s...</span><br><span class="line">[21:31:07] results: &lt;generator object Executor.map.&lt;locals&gt;.result_iterator at 0x10cd970f8&gt;</span><br><span class="line">[21:31:07] Waiting for individual results:</span><br><span class="line">[21:31:07] result 0: 0  # loiter(0)运行结束了，第一个worker就可以启动第四个线程，运行loiter(3)</span><br><span class="line">[21:31:07]             loiter(3): doing nothing for 3s...</span><br><span class="line">[21:31:08]     loiter(1): done.</span><br><span class="line">[21:31:08]                 loiter(4): doing nothing for 4s...</span><br><span class="line">[21:31:08] result 1: 10</span><br><span class="line">[21:31:09]         loiter(2): done.</span><br><span class="line">[21:31:09] result 2: 20</span><br><span class="line">[21:31:10]             loiter(3): done.</span><br><span class="line">[21:31:10] result 3: 30</span><br><span class="line">[21:31:12]                 loiter(4): done.</span><br><span class="line">[21:31:12] result 4: 40</span><br></pre></td></tr></table></figure><p>第一个线程执行loiter(0)，因此会休眠0秒，甚至会在第二个线程开始之前就结束，不过具体情况因人而异：对线程来说，你永远不知道某一时刻事件的具体排序；有可能在另一台设备中会看到loiter(1)在loiter(0)结束之前开始，这是因为sleep函数总会释放GIL。因此，即便休眠0秒，Python也可能会切换到另一个线程。</p><p><strong>Executor.map函数易于使用，不过有个特性可能有用，也可能没用，具体情况取决于需求：这个函数返回结果的顺序与调用开始的顺序一致。如果第一个调用生成结果用时10秒，而其他调用只用1秒，代码会阻塞10秒，获取map方法返回的生成器产出的第一个结果。在此之后，获取后续结果时不会阻塞，因为后续的调用已经结束。如果必须等到获取所有结果后再处理，这种行为没问题；不过，通常更可取的方式是，不管提交的顺序，只要有结果就获取。为此，要把Executor.submit方法和futures.as_completed函数结合起来使用（之前的示例中演示过如何组合使用）。</strong></p><p>executor.submit和futures.as_completed这个组合比executor.map更灵活，因为submit方法能处理不同的可调用对象和参数，而executor.map只能处理参数不同的同一个可调用对象。此外，传给futures.as_completed函数的期物集合可以来自Executor实例，例如一些由ThreadPoolExecutor实例创建，另一些由ProcessPoolExecutor实例创建。</p><h1 id="显示下载进度并处理错误节选">显示下载进度并处理错误（节选）</h1><h2 id="依序下载">依序下载</h2><p>在download_one函数中处理HTTP 404错误，其他异常则向上冒泡，交给download_many函数处理。</p><figure class="highlight python"><figcaption><span>flags2_sequential.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flag</span><span class="params">(base_url, cc)</span>:</span></span><br><span class="line">    url = <span class="string">'&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif'</span>.format(base_url, cc=cc.lower())</span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    <span class="keyword">if</span> resp.status_code != <span class="number">200</span>:</span><br><span class="line">        resp.raise_for_status()  <span class="comment"># 状态码不是200时，抛出异常</span></span><br><span class="line">    <span class="keyword">return</span> resp.content</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_one</span><span class="params">(cc, base_url, verbose=False)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        image = get_flag(base_url, cc)</span><br><span class="line">    <span class="keyword">except</span> requests.exceptions.HTTPError <span class="keyword">as</span> exc:  <span class="comment"># 捕获异常</span></span><br><span class="line">        res = exc.response</span><br><span class="line">        <span class="keyword">if</span> res.status_code == <span class="number">404</span>:  <span class="comment"># 单独处理404异常</span></span><br><span class="line">            status = HTTPStatus.not_found  <span class="comment"># HTTPStatus是自定义的Enum对象</span></span><br><span class="line">            msg = <span class="string">'not found'</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 抛出其他异常</span></span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 没有异常时</span></span><br><span class="line">        save_flag(image, cc.lower() + <span class="string">'.gif'</span>)</span><br><span class="line">        status = HTTPStatus.ok</span><br><span class="line">        msg = <span class="string">'OK'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> verbose:  <span class="comment"># 是否显示消息</span></span><br><span class="line">        print(cc, msg)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result(status, cc)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list, base_url, verbose, max_req)</span>:</span></span><br><span class="line">    counter = collections.Counter()  <span class="comment"># 计数</span></span><br><span class="line">    cc_iter = sorted(cc_list)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> verbose:  <span class="comment"># 是否显示进度条</span></span><br><span class="line">        <span class="comment"># 把cc_iter传给tqdm函数，返回一个迭代器，产出cc_iter中的元素，还会显示进度条动画</span></span><br><span class="line">        cc_iter = tqdm.tqdm(cc_iter)</span><br><span class="line">    <span class="keyword">for</span> cc <span class="keyword">in</span> cc_iter:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            res = download_one(cc, base_url, verbose)</span><br><span class="line">        <span class="keyword">except</span> requests.exceptions.HTTPError <span class="keyword">as</span> exc:  <span class="comment"># 与HTTP有关且download_one中没处理的异常</span></span><br><span class="line">            error_msg = <span class="string">'HTTP error &#123;res.status_code&#125; - &#123;res.reasion&#125;'</span></span><br><span class="line">            error_msg = errormsg.format(res=exc.response)</span><br><span class="line">        <span class="keyword">except</span> requests.exceptions.ConnectionError <span class="keyword">as</span> exc:  <span class="comment"># 与网络有关的异常</span></span><br><span class="line">            error_msg = <span class="string">'Connection error'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            error_msg = <span class="string">''</span></span><br><span class="line">            status = res.status</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> error_msg:</span><br><span class="line">            status = HTTPStatus.error</span><br><span class="line">        counter[status] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> verbose <span class="keyword">and</span> error_msg:</span><br><span class="line">            print(<span class="string">'*** Error for &#123;&#125;: &#123;&#125;'</span>.format(cc, error_msg))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> counter</span><br></pre></td></tr></table></figure><h2 id="使用futures.as_completed函数">使用futures.as_completed函数</h2><p>为了集成TQDM进度条，并处理各次请求中的错误，flags2_threadpool.py脚本用到futures.ThreadPoolExecutor类和futures.as_completed函数。</p><figure class="highlight python"><figcaption><span>flags2_threadpool.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list, base_url, verbose, concur_req)</span>:</span></span><br><span class="line">    counter = collections.Counter()</span><br><span class="line">    <span class="keyword">with</span> futures.ThreadPoolExecutor(max_workers=concur_req) <span class="keyword">as</span> executor:</span><br><span class="line">        to_do_map = &#123;&#125;  <span class="comment"># 把各个Future实例（表示一次下载）映射到相应的国家代码</span></span><br><span class="line">        <span class="keyword">for</span> cc <span class="keyword">in</span> sorted(cc_list):</span><br><span class="line">            future = executor.submit(download_one, cc, base_url, verbose)  <span class="comment"># 排定执行时间</span></span><br><span class="line">            to_do_map[future] = cc</span><br><span class="line">        done_iter = futures.as_completed(to_do_map)  <span class="comment"># 返回一个迭代器，在期物运行结束后产出期物</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> verbose:</span><br><span class="line">            <span class="comment"># done_iter没有__len__方法，必须通过total参数告诉tqdm函数预期的元素数量</span></span><br><span class="line">            done_iter = tqdm.tqdm(done_iter, total=len(cc_list))</span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> done_iter:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                res = future.result()  <span class="comment"># 不会阻塞，因为as_completed函数只返回已经运行结束的期物</span></span><br><span class="line">            <span class="keyword">except</span> requests.exceptions.HTTPError <span class="keyword">as</span> exc:</span><br><span class="line">                error_msg = <span class="string">'HTTP &#123;res.status_code&#125; - &#123;res.reason&#125;'</span></span><br><span class="line">                error_msg = error_msg.format(res=exc.response)</span><br><span class="line">            <span class="keyword">except</span> requests.exceptions.ConnectionError <span class="keyword">as</span> exc:</span><br><span class="line">                error_msg = <span class="string">'Connection error'</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                error_msg = <span class="string">''</span></span><br><span class="line">                status = res.status</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> error_msg:</span><br><span class="line">                status = HTTPStatus.error</span><br><span class="line">            counter[status] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> verbose <span class="keyword">and</span> error_msg:</span><br><span class="line">                cc = to_do_map[future]</span><br><span class="line">                print(<span class="string">'*** Error for &#123;&#125;: &#123;&#125;'</span>.format(cc, error_msg))</span><br><span class="line">    <span class="keyword">return</span> counter</span><br></pre></td></tr></table></figure></div><div class="popular-posts-header">相关文章</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/fluent-python/concurrency-with-asyncio/" rel="bookmark">使用asyncio包处理并发</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/fluent-python/a-pythonic-object/" rel="bookmark">符合Python风格的对象</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/fluent-python/abc-s-in-standard-library/" rel="bookmark">标准库中的抽象基类</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/fluent-python/context-managers-and-else-blocks/" rel="bookmark">上下文管理器和else块</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/fluent-python/coroutines-for-discrete-event-simulation/" rel="bookmark">使用协程做离散事件仿真</a></div></li></ul><footer class="post-footer"><div class="post-tags"> <a href="/tags/Fluent-Python/" rel="tag"># Fluent Python</a> <a href="/tags/concurrency/" rel="tag"># concurrency</a> <a href="/tags/futures/" rel="tag"># futures</a></div><div class="post-nav"><div class="post-nav-item"><a href="/notes/fluent-python/coroutines-for-discrete-event-simulation/" rel="prev" title="使用协程做离散事件仿真"><i class="fa fa-chevron-left"></i> 使用协程做离散事件仿真</a></div><div class="post-nav-item"> <a href="/notes/introduction-to-machine-learning-with-python/introduction-to-machine-learning/" rel="next" title="机器学习引言">机器学习引言<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><div class="comments" id="valine-comments"></div><script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#示例网络下载的三种风格"><span class="nav-number">1.</span> <span class="nav-text">示例：网络下载的三种风格</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#依序下载的脚本"><span class="nav-number">1.1.</span> <span class="nav-text">依序下载的脚本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用concurrent.futures模块下载"><span class="nav-number">1.2.</span> <span class="nav-text">使用concurrent.futures模块下载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#期物在哪里"><span class="nav-number">1.2.1.</span> <span class="nav-text">期物在哪里</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用asyncio模块下载"><span class="nav-number">1.3.</span> <span class="nav-text">使用asyncio模块下载</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#阻塞型io和gil"><span class="nav-number">2.</span> <span class="nav-text">阻塞型I/O和GIL</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#避免阻塞型调用"><span class="nav-number">3.</span> <span class="nav-text">避免阻塞型调用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用concurrent.futures模块启动进程"><span class="nav-number">4.</span> <span class="nav-text">使用concurrent.futures模块启动进程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#实验executor.map方法"><span class="nav-number">5.</span> <span class="nav-text">实验Executor.map方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#显示下载进度并处理错误节选"><span class="nav-number">6.</span> <span class="nav-text">显示下载进度并处理错误（节选）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#依序下载"><span class="nav-number">6.1.</span> <span class="nav-text">依序下载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用futures.as_completed函数"><span class="nav-number">6.2.</span> <span class="nav-text">使用futures.as_completed函数</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Chen" src="/uploads/avatar/nekosensei.png"><p class="site-author-name" itemprop="name">Chen</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">65</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">10</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">94</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/cwscn/cwscn.github.io" title="GitHub → https://github.com/cwscn/cwscn.github.io" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a></span><span class="links-of-author-item"><a href="mailto:chenws2015@gmail.com" title="E-Mail → mailto:chenws2015@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a></span></div><div class="cc-license motion-element" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Chen</span></div><script src="//cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="//cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/lozad.js/1.9.0/lozad.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      script.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script><script src="/js/local-search.js"></script><div id="pjax"><script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el: '#valine-comments',
      verify: false,
      notify: false,
      appId: 'Axl15EIRi5o5AatKaxXxV4Oq-gzGzoHsz',
      appKey: 'E0qm04UjsP0qQN1l8ME3GQ25',
      placeholder: "Just go go",
      avatar: 'identicon',
      meta: guest,
      pageSize: '10' || 10,
      visitor: false,
      lang: 'zh-cn' || 'zh-cn',
      path: location.pathname,
      recordIP: true,
      serverURLs: ''
    });
  }, window.Valine);
});
</script></div></body></html>