<!DOCTYPE html><html lang="zh-CN,en,default"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/uploads/icon/drop/128x128.png"><link rel="icon" type="image/png" sizes="32x32" href="/uploads/icon/drop/32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/uploads/icon/drop/16x16.png"><link rel="mask-icon" href="/uploads/icon/drop/drop.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"cwscn.github.io",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1,width:240},copycode:{enable:!0,show_result:!0,style:"flat"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"manual"},fancybox:!1,mediumzoom:!0,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"fadeIn"}},path:"search.xml"}</script><meta name="description" content="得益于Python数据模型，自定义类型的行为可以像内置类型那样自然。实现如此自然的行为，靠的不是继承，而是鸭子类型（duck typing）：我们只需按照预定行为实现对象所需的方法即可。 对象表示形式 每门面向对象的语言至少都有一种获取对象的字符串表示形式的标准方式。Python提供了两种方式。 repr()：以便于开发者理解的方式返回对象的字符串表示形式，由特殊方法__repr__支持。 str"><meta name="keywords" content="Fluent Python"><meta property="og:type" content="article"><meta property="og:title" content="符合Python风格的对象"><meta property="og:url" content="https://cwscn.github.io/notes/fluent-python/a-pythonic-object/index.html"><meta property="og:site_name" content="水滴"><meta property="og:description" content="得益于Python数据模型，自定义类型的行为可以像内置类型那样自然。实现如此自然的行为，靠的不是继承，而是鸭子类型（duck typing）：我们只需按照预定行为实现对象所需的方法即可。 对象表示形式 每门面向对象的语言至少都有一种获取对象的字符串表示形式的标准方式。Python提供了两种方式。 repr()：以便于开发者理解的方式返回对象的字符串表示形式，由特殊方法__repr__支持。 str"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2020-02-04T14:53:22.231Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="符合Python风格的对象"><meta name="twitter:description" content="得益于Python数据模型，自定义类型的行为可以像内置类型那样自然。实现如此自然的行为，靠的不是继承，而是鸭子类型（duck typing）：我们只需按照预定行为实现对象所需的方法即可。 对象表示形式 每门面向对象的语言至少都有一种获取对象的字符串表示形式的标准方式。Python提供了两种方式。 repr()：以便于开发者理解的方式返回对象的字符串表示形式，由特殊方法__repr__支持。 str"><link rel="canonical" href="https://cwscn.github.io/notes/fluent-python/a-pythonic-object/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css"><link rel="stylesheet" href="//unpkg.com/video.js/dist/video-js.min.css"><link rel="stylesheet" href="/css/videojs-bilibili.css"><style>.aplayer.aplayer-arrow .aplayer-icon-loop,.aplayer.aplayer-arrow .aplayer-icon-order{display:inline-block}</style><title>符合Python风格的对象 | 水滴</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">水滴</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">愿你走出半生 归来仍是少年</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档<span class="badge">160</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类<span class="badge">11</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签<span class="badge">162</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i> 关于</a></li><li class="menu-item menu-item-收藏"><a href="/favlist/" rel="section"><i class="fa fa-star fa-fw"></i> 收藏</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div><meting-js server="netease" type="playlist" id="67155774" theme="#ff5555" loop="all" order="list" preload="none" volume="" mutex="" list-folded="NaN" fixed="true"></meting-js></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwscn.github.io/notes/fluent-python/a-pythonic-object/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar/nekosensei.png"><meta itemprop="name" content="菜农陈文生"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="水滴"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 符合Python风格的对象</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-02-04 22:53:22" itemprop="dateModified" datetime="2020-02-04T22:53:22+08:00">2020-02-04</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/notes/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/notes/fluent-python/a-pythonic-object/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/notes/fluent-python/a-pythonic-object/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><p>得益于Python数据模型，自定义类型的行为可以像内置类型那样自然。实现如此自然的行为，靠的不是继承，而是鸭子类型（duck typing）：我们只需按照预定行为实现对象所需的方法即可。</p><h1 id="对象表示形式">对象表示形式</h1><p>每门面向对象的语言至少都有一种获取对象的字符串表示形式的标准方式。Python提供了两种方式。</p><p>repr()：以便于开发者理解的方式返回对象的字符串表示形式，由特殊方法<code>__repr__</code>支持。</p><p>str()：以便于用户理解的方式返回对象的字符串表示形式，由特殊方法<code>__str__</code>支持。</p><p>为了给对象提供其他的表示形式，还会用到另外两个特殊方法：<code>__bytes__</code>和<code>__format__</code>。<code>__bytes__</code>方法与<code>__str__</code>方法类似，bytes()函数调用它获取对象的字节序列表示形式。而<code>__format__</code>方法会被内置的format()函数和str.format()方法调用，使用特殊的格式代码显示对象的字符串表示形式。</p><a id="more"></a><h1 id="再谈向量类">再谈向量类</h1><p>为了说明用于生成对象表示形式的众多方法，我们将使用一个Vector2d类。</p><figure class="highlight python"><figcaption><span>vector2d.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span>:</span></span><br><span class="line">    typecode = <span class="string">'d'</span>  <span class="comment"># 类属性，在实例和字节序列之间转换时使用</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = float(x)  <span class="comment"># 把x和y转换成浮点数，尽早捕获错误</span></span><br><span class="line">        self.y = float(y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span>  <span class="comment"># 把Vector2d变成可迭代对象，这样才能拆包</span></span><br><span class="line">        <span class="keyword">return</span> (i <span class="keyword">for</span> i <span class="keyword">in</span> (self.x, self.y))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span>  <span class="comment"># __repr__方法使用&#123;!r&#125;获取各个分量的表示形式，然后插值，构成一个字符串</span></span><br><span class="line">        class_name = type(self).__name__</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&#123;&#125;(&#123;!r&#125;, &#123;!r&#125;)'</span>.format(class_name, *self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>  <span class="comment"># 从可迭代的实例中可以轻松地得到一个元组</span></span><br><span class="line">        <span class="keyword">return</span> str(tuple(self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bytes__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (bytes([ord(self.typecode)]) +  <span class="comment"># 为了生成字节序列，把typecode转换成字节序列，然后</span></span><br><span class="line">                bytes(array(self.typecode, self)))  <span class="comment"># 迭代实例，得到一个数组，再把数组转换成字节序列</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span>  <span class="comment"># 可用，但有点问题，比如Vector2d(3, 4) == [3, 4]的结果会是True。</span></span><br><span class="line">        <span class="keyword">return</span> tuple(self) == tuple(other)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> math.hypot(self.x, self.y)  <span class="comment"># 模是x和y分量构成的直角三角形的斜边长</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(abs(self))  <span class="comment"># abs(0.0)是False，非零值是True</span></span><br></pre></td></tr></table></figure><p>Vector2d实例具有以下基本行为：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector2d(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(v1.x, v1.y)  <span class="comment"># 实例的分量可以直接通过属性访问</span></span><br><span class="line"><span class="number">3.0</span> <span class="number">4.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = v1  <span class="comment"># 实例可以拆包成变量元组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y</span><br><span class="line">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1  <span class="comment"># repr函数调用实例，得到的结果类似于构建实例的源码</span></span><br><span class="line">Vector2d(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1_clone = eval(repr(v1))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 == v1_clone</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(v1)  <span class="comment"># print函数会调用str函数</span></span><br><span class="line">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>octets = bytes(v1)  <span class="comment"># bytes函数会调用__bytes__方法，生成实例的二进制表示形式</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>octets</span><br><span class="line"><span class="string">b'd\\x00\\x00\\x00\\x00\\x00\\x00\\x08@\\x00\\x00\\x00\\x00\\x00\\x00\\x10@'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>abs(v1)  <span class="comment"># abs函数会调用__abs__方法，返回实例的模</span></span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(v1), bool(Vector2d(<span class="number">0</span>, <span class="number">0</span>))  <span class="comment"># bool函数会调用__bool__方法，如果实例的模为0，返回False，否则返回True</span></span><br><span class="line"><span class="literal">True</span>, <span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="备选构造方法">备选构造方法</h1><p>我么可以把Vector2d实例转换成字节序列；同理，也应该能从字节序列转换成Vector2d实例。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在类中定义</span></span><br><span class="line"><span class="meta">@classmethod  # 类方法：从字节序列转换成Vector2d实例</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">frombytes</span><span class="params">(cls, octets)</span>:</span>  <span class="comment"># 不用传入self参数，相反，要通过cls传入类本身</span></span><br><span class="line">    typecode = chr(octets[<span class="number">0</span>])  <span class="comment"># 从第一个字节中读取typecode</span></span><br><span class="line">    memv = memoryview(octets[<span class="number">1</span>:]).cast(typecode)  <span class="comment"># 使用传入的octets字节序列创建一个memoryview，然后使用typecode转换</span></span><br><span class="line">    <span class="keyword">return</span> cls(*memv)  <span class="comment"># 拆包转换后的memoryview，得到构造方法所需的一对参数</span></span><br></pre></td></tr></table></figure><h2 id="classmethod与staticmethod">classmethod与staticmethod</h2><p>classmethod装饰器定义操作类，而不是操作实例的方法。classmethod改变了调用方法的方式，因此类方法的第一个参数是类本身，而不是实例。classmethod最常见的用途是定义备选构造方法。按照约定，类方法的第一个参数名为cls（但是Python不介意具体怎么命名）。</p><p>staticmethod装饰器也会改变方法的调用方式，但是第一个参数不是特殊的值。其实，静态方法就是普通的函数，只是碰巧在类的定义体中，而不是在模块层定义。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>:</span></span><br><span class="line"><span class="meta">... </span>    @classmethod</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">klassmeth</span><span class="params">(*args)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> args  <span class="comment"># 返回全部参数</span></span><br><span class="line"><span class="meta">... </span>    @staticmethod</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">statmeth</span><span class="params">(*args)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> args  <span class="comment"># 返回全部参数</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Demo.klassmeth()  <span class="comment"># 不管怎样调用类方法，第一个参数始终是Demo类</span></span><br><span class="line">(&lt;class '__main__.Demo'&gt;,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Demo.klassmeth(<span class="string">'spam'</span>)</span><br><span class="line">(&lt;class '__main__.Demo'&gt;, 'spam')</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Demo.statmeth()  <span class="comment"># 静态方法的行为与普通的函数类似</span></span><br><span class="line">()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Demo.statmeth(<span class="string">'spam'</span>)</span><br><span class="line">(<span class="string">'spam'</span>,)</span><br></pre></td></tr></table></figure><h1 id="格式化显示">格式化显示</h1><p>内置的format()函数和str.format()方法把各个类型的格式化方法委托给相应的<code>.__format__(format_spec)</code>方法。format_spec是格式说明符，它是：</p><ul><li>format(my_obj, format_spec)的第二个参数，或者</li><li>str.format()方法的格式字符串，{}里代换字段中冒号后面的部分。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>brl = <span class="number">1</span>/<span class="number">2.43</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>brl</span><br><span class="line"><span class="number">0.4115226337448559</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(brl, <span class="string">'0.4f'</span>)  <span class="comment"># 格式说明符是 '0.4f'</span></span><br><span class="line"><span class="string">'0.4115'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'1 BRL = &#123;rate:0.2f&#125; USD'</span>.format(rate=brl)  <span class="comment"># 格式说明符是 '0.2f'</span></span><br><span class="line"><span class="string">'1 BRL = 0.41 USD'</span></span><br></pre></td></tr></table></figure><p>'{rate:0.2f}'这样的格式字符串包含两部分，冒号左边的'rate'在代换字段句法中是字段名，冒号后面的'0.2f'是格式说明符。格式说明符使用的表示法叫格式规范微语言（“<a href="https://devdocs.io/python~3.6/library/string#formatspec" target="_blank" rel="noopener">Format Specification Mini-LMini-Language</a>“）。</p><p>格式规范微语言是可扩展的，因为各个类可以自行决定如果解释format_spec参数。例如，datetime模块中的类，它们的<code>__format__</code>方法使用的格式代码与strftime()函数一样。下面是内置的format()函数和str.format()方法的几个示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(now, <span class="string">'%H:%M:%S'</span>)</span><br><span class="line"><span class="string">'11:46:10'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"It's now &#123;:%I:%M %p&#125;"</span>.format(now)</span><br><span class="line"><span class="string">"It's now 11:46 AM"</span></span><br></pre></td></tr></table></figure><p>如果类没有定义<code>__format__</code>方法，从object继承的方法会返回str(my_object)。然而没如果传入格式说明符，<code>object.__format__</code>方法会抛出TypeError。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector2d(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(v1)  <span class="comment"># 若没有定义__format__方法，则返回str(v1)</span></span><br><span class="line"><span class="string">'(3.0, 4.0)'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(v1, <span class="string">'.3f'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">TypeError: unsupported format string passed to Vector2d.__format__</span><br></pre></td></tr></table></figure><p>我们将自己实现微语言来解决这个问题。首先，假设用户提供的格式说明符是用于格式化向量中各个浮点数分量的，想达到的效果是：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector2d(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(v1)</span><br><span class="line"><span class="string">'(3.0, 4.0)'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(v1, <span class="string">'.2f'</span>)</span><br><span class="line"><span class="string">'(3.00, 4.00)'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(v1, <span class="string">'.3e'</span>)</span><br><span class="line"><span class="string">'(3.000e+00, 4.000e+00)'</span></span><br></pre></td></tr></table></figure><p>实现这种输出的<code>__format__</code>方法如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在类中定义</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__format__</span><span class="params">(self, fmt_spec=<span class="string">''</span>)</span>:</span></span><br><span class="line">    components = (format(c, fmt_spec) <span class="keyword">for</span> c <span class="keyword">in</span> self)  <span class="comment"># 使用内置的format函数把fmt_spec应用到向量的各个分量上</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'(&#123;&#125;, &#123;&#125;)'</span>.format(*components)</span><br></pre></td></tr></table></figure><p>下面要在微语言中添加一个自定义的格式代码：如果格式说明符以'p'结尾，那么在极坐标中显示向量，即&lt;r, <span class="math inline">\(\theta\)</span>&gt;，其中r是模，<span class="math inline">\(\theta\)</span>是弧度；其他部分（'p'之前的部分）像往常那样解释。</p><p>对极坐标来说，我们已经定义了计算模的<code>__abs__</code>方法，因此还要定义一个简单的angle方法，使用math.atan2()函数计算角度。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在类中定义</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">angle</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> math.atan2(self.y, self.x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__format__</span><span class="params">(self, fmt_spec)</span>:</span>  <span class="comment"># 增强型__format__方法</span></span><br><span class="line">    <span class="keyword">if</span> fmt_spec.endswith(<span class="string">'p'</span>):</span><br><span class="line">        fmt_spec = fmt_spec[:<span class="number">-1</span>]</span><br><span class="line">        coords = (abs(self), self.angle())  <span class="comment"># 极坐标</span></span><br><span class="line">        outer_fmt = <span class="string">'&lt;&#123;&#125;, &#123;&#125;&gt;'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        coords = self</span><br><span class="line">        outer_fmt = <span class="string">'(&#123;&#125;, &#123;&#125;)'</span></span><br><span class="line">    components = (format(c, fmt_spec) <span class="keyword">for</span> c <span class="keyword">in</span> coords)</span><br><span class="line">    <span class="keyword">return</span> outer_fmt.format(*components)</span><br></pre></td></tr></table></figure><p>示例中的代码得到的结果如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(Vector2d(<span class="number">1</span>, <span class="number">1</span>), <span class="string">'p'</span>)</span><br><span class="line"><span class="string">'&lt;1.4142135623730951, 0.7853981633974483&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(Vector2d(<span class="number">1</span>, <span class="number">1</span>), <span class="string">'.3ep'</span>)</span><br><span class="line"><span class="string">'&lt;1.414e+00, 7.854e-01&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(Vector2d(<span class="number">1</span>, <span class="number">1</span>), <span class="string">'0.5fp'</span>)</span><br><span class="line"><span class="string">'&lt;1.41421, 0.78540&gt;'</span></span><br></pre></td></tr></table></figure><h1 id="可散列的vector2d">可散列的Vector2d</h1><p>目前Vector2d实例是不可散列的，因此不能放入集合（set）中。为了把Vector2d实例变成可散列的，必须使用<code>__hash__</code>方法（还需要<code>__eq__</code>方法）。此外，还要让向量不可变，为此，我们要把x和y分量设为只读属性。（要想创建可散列的类型，不一定要实现特性，也不一定要保护实例属性。只需正确地实现<code>__hash__</code>和<code>__eq__</code>方法即可。但是实例的散列值绝不应该变化，因此借机提到了只读属性）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 类中定义</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">    self.__x = x  <span class="comment"># 使用两个前导下划线，把属性标记为私有的</span></span><br><span class="line">    self.__y = y</span><br><span class="line"></span><br><span class="line"><span class="meta">@property  # @property装饰器把读值方法标记为特性</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.__x</span><br><span class="line"></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">y</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.__y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他方法保持不变，通过self.x和self.y读取公开特性，而不必读取私有属性</span></span><br></pre></td></tr></table></figure><p>让这些向量不可变是有原因的，因为这样才能实现<code>__hash__</code>方法。这个方法应该返回一个整数，理想情况下还要考虑对象属性的散列值（<code>__eq__</code>方法也要使用），因为相等的对象应该具有相同的散列值。根据<a href="https://docs.python.org/3/reference/datamodel.html" target="_blank" rel="noopener">特殊方法<code>__hash__</code>的文档</a>，最好使用位运算符异或（^）混合各分量的散列值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在类中定义</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> hash(self.x) ^ hash(self.y)</span><br></pre></td></tr></table></figure><p>完整代码清单，包含全部doctest。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">A two-dimensional vector class</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 = Vector2d(3, 4)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print(v1.x, v1.y)</span></span><br><span class="line"><span class="string">    3.0 4.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; x, y = v1</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; x, y</span></span><br><span class="line"><span class="string">    (3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1</span></span><br><span class="line"><span class="string">    Vector2d(3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone = eval(repr(v1))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 == v1_clone</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print(v1)</span></span><br><span class="line"><span class="string">    (3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; octets = bytes(v1)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; octets b'd\\x00\\x00\\x00\\x00\\x00\\x00\\x08@\\x00\\x00\\x00\\x00\\x00\\x00\\x10@'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(v1)</span></span><br><span class="line"><span class="string">    5.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; bool(v1), bool(Vector2d(0, 0))</span></span><br><span class="line"><span class="string">    (True, False)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Test of ``.frombytes()`` class method:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone = Vector2d.frombytes(bytes(v1))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone</span></span><br><span class="line"><span class="string">    Vector2d(3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 == v1_clone</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of ``format()`` with Cartesian coordinates:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(v1)</span></span><br><span class="line"><span class="string">    '(3.0, 4.0)'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(v1, '.2f')</span></span><br><span class="line"><span class="string">    '(3.00, 4.00)'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(v1, '.3e')</span></span><br><span class="line"><span class="string">    '(3.000e+00, 4.000e+00)'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of the ``angle`` method::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; Vector2d(0, 0).angle()</span></span><br><span class="line"><span class="string">    0.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; Vector2d(1, 0).angle()</span></span><br><span class="line"><span class="string">    0.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; epsilon = 10**-8</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(Vector2d(0, 1).angle() - math.pi/2) &lt; epsilon</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(Vector2d(1, 1).angle() - math.pi/4) &lt; epsilon</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of ``format()`` with polar coordinates:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector2d(1, 1), 'p') # doctest:+ELLIPSIS</span></span><br><span class="line"><span class="string">    '&lt;1.414213..., 0.785398...&gt;'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector2d(1, 1), '.3ep')</span></span><br><span class="line"><span class="string">    '&lt;1.414e+00, 7.854e-01&gt;'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector2d(1, 1), '0.5fp')</span></span><br><span class="line"><span class="string">    '&lt;1.41421, 0.78540&gt;'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of `x` and `y` read-only properties:</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1.x, v1.y</span></span><br><span class="line"><span class="string">    (3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1.x = 123</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">      ...</span></span><br><span class="line"><span class="string">    AttributeError: can't set attribute</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of hashing:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 = Vector2d(3, 4)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v2 = Vector2d(3.1, 4.2)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; hash(v1), hash(v2)</span></span><br><span class="line"><span class="string">    (7, 384307168202284039)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; len(set([v1, v2]))</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span>:</span></span><br><span class="line">    typecode = <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.__x = float(x)</span><br><span class="line">        self.__y = float(y)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__x</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">y</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (i <span class="keyword">for</span> i <span class="keyword">in</span> (self.x, self.y))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        class_name = type(self).__name__</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&#123;&#125;(&#123;!r&#125;, &#123;!r&#125;)'</span>.format(class_name, *self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(tuple(self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bytes__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (bytes([ord(self.typecode)]) +</span><br><span class="line">                bytes(array(self.typecode, self)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> tuple(self) == tuple(other)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> hash(self.x) ^ hash(self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> math.hypot(self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(abs(self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">angle</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> math.atan2(self.y, self.x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__format__</span><span class="params">(self, fmt_spec=<span class="string">''</span>)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> fmt_spec.endswith(<span class="string">'p'</span>):</span><br><span class="line">            fmt_spec = fmt_spec[:<span class="number">-1</span>]</span><br><span class="line">            coords = (abs(self), self.angle())</span><br><span class="line">            outer_fmt = <span class="string">'&lt;&#123;&#125;, &#123;&#125;&gt;'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            coords = self</span><br><span class="line">            outer_fmt = <span class="string">'(&#123;&#125;, &#123;&#125;)'</span></span><br><span class="line">            components = (format(c, fmt_spec) <span class="keyword">for</span> c <span class="keyword">in</span> coords)</span><br><span class="line">        <span class="keyword">return</span> outer_fmt.format(*components)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">frombytes</span><span class="params">(cls, octets)</span>:</span></span><br><span class="line">        typecode = chr(octets[<span class="number">0</span>])</span><br><span class="line">        memv = memoryview(octets[<span class="number">1</span>:]).cast(typecode)</span><br><span class="line">        <span class="keyword">return</span> cls(*memv)</span><br></pre></td></tr></table></figure><h1 id="python的私有属性和受保护的属性">Python的私有属性和“受保护的”属性</h1><p>Python不能像Java那样使用private修饰符创建私有属性，但是Python有个简单的机制，能避免子类意外覆盖“私有”属性。举个例子，有人编写了一个名为Dog的类，这个类的内部用到了mood实例属性，但是没有将其开放。现在，你创建了Dog的子类：Beagle。如果你在毫不知情的情况下又创建了名为mood的实例属性，那么在继承的方法中就会把Dog类的mood属性覆盖掉。这是个难以调试的问题。</p><p>为了避免这种情况，如果以<code>__mood</code>的形式命名实例属性，Python会把属性名存入实例的<code>__dict__</code>属性中，而且会在前面加上一个下划线和类名。因此，对Dog类来说，<code>__mood</code>会变成<code>_Dog__mood</code>；对Beagle类来说，会变成<code>_Beagle__mood</code>。这个语言特性叫名称改写（name mangling）。名称改写是一种安全措施，不能保证万无一失：它的目的是避免意外访问，不能防止故意做错事。</p><p>以上一节定义的Vector2d类为例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector2d(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1.__dict__</span><br><span class="line">&#123;<span class="string">'_Vector2d__x'</span>: <span class="number">3.0</span>, <span class="string">'_Vector2d__y'</span>: <span class="number">4.0</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1._Vector2d__x  <span class="comment"># 故意访问</span></span><br><span class="line"><span class="number">3.0</span></span><br></pre></td></tr></table></figure><p>不是所有Python程序员都喜欢名称改写功能，也不是所有人都喜欢<code>self.__x</code>这种不对称的名称。有些人不喜欢这种句法，他们约定使用一个下环线前缀编写“受保护”的属性（如<code>self._x</code>）。批评使用两个下划线这种改写机制的人认为，应该使用命名约定来避免意外覆盖属性。</p><blockquote><p>绝对不要使用两个前导下划线，这是很烦人的自私行为。如果担心命名冲突，应该明确使用一种名称改写方式（如<code>_MyThing_blahblah</code>）。这其实与使用双下划线一样，不过自己定的规则比双下划线易于理解。</p><p>—— Ian Bicking，<a href="http://pythonpaste.org/StyleGuide.html" target="_blank" rel="noopener">Paste的风格指南</a></p></blockquote><p>Python解释器不会对使用单个下划线的属性名做特殊处理，不过这是很多Python程序员严格遵守的约定，他们不会在类外部访问这种属性（不过在模块中，顶层名称使用一个前导下划线的话，的确会有影响：对from mymod import *来说，mymod中前缀为下划线的名称不会被导入。然而，依旧可以使用from mymod import _privatefunc将其导入）。遵守使用一个下划线标记对象的私有属性很容易，就像遵守使用全大写字母编写常量那样容易。</p><p>Vector2d的分量都是”私有的“，而且Vector2d实例都是”不可变的”。我用了两对引号，这是因为并不能真正实现私有和不可变。</p><h1 id="使用__slots__类属性节省空间">使用<code>__slots__</code>类属性节省空间</h1><p>默认情况下，Python在各个实例中名为<code>__dict__</code>的字典里存储实例属性。为了使用底层的散列表提升访问速度，字典会消耗大量内存。如果要处理数百万个属性不多的实例，通过<code>__slots__</code>类属性，能节省大量内存，方法是让解释器在元组中存储实例属性，而不使用字典。（继承自超类的<code>__slots__</code>属性没有效果。Python只会使用各个类中定义的<code>__slots__</code>属性）</p><p>定义<code>__slots__</code>的方式是，创建一个类属性，使用<code>__slots__</code>这个名字，并把它的值设为一个字符串构成的可迭代对象，其中各个元素表示各个实例属性。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span>:</span></span><br><span class="line">    __solots__ = (<span class="string">'__x'</span>, <span class="string">'__y'</span>)</span><br><span class="line"></span><br><span class="line">    typecode = <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类方法</span></span><br></pre></td></tr></table></figure><p>如果要处理数百万个数值对象，应该使用NumPy数组。NumPy数组能高效使用内存，而且提供了高度优化的数值处理函数，其中很多都一次操作整个数组。</p><p>在类中定义<code>__slots__</code>属性之后，实例不能再有<code>__slots__</code>中所列名称之外的其他属性。这只是一个副作用，不是<code>__slots__</code>存在的真正原因，不要使用<code>__slots__</code>属性禁止类的用户新增实例。<code>__slots__</code>是用于优化的，不是为了约束程序员。</p><p>然而，“节省的内存也可能被再次吃掉”：如果把'<code>__dict__</code>'这个名称添加到<code>__slots__</code>中，实例会在元组中保存各个实例的属性，此外还支持动态创建属性，这些属性存储在常规的<code>__dict__</code>中。当然，把'<code>__dict__</code>'添加到<code>__slots__</code>中可能完全违背了初衷，这取决于各个实例的静态属性和动态属性的数量及其用法。</p><p>此外，还有一个实例属性可能需要注意，即<code>__weakref__</code>属性，为了让对象支持弱引用，必须有这个属性。用户定义的类中默认就有<code>__weakref__</code>属性。可是，如果类中定义了<code>__slots__</code>属性，而且想把实例作为弱引用的目标，那么要把'<code>__weakref__</code>'添加到<code>__slots__</code>中。</p><p>综上，<code>__slots__</code>属性有些需要注意的地方，而且不能滥用，不能使用它限制用户能赋值的属性。处理列表数据时<code>__slots__</code>属性最有用，例如模式固定的数据库记录，以及特大型数据库。然而，如果你经常处理大量数据，一定要了解一下<a href="http://www.numpy.org" target="_blank" rel="noopener">NumPy</a>；此外，数据分析库<a href="http://pandas.pydata.org" target="_blank" rel="noopener">pandas</a>也值得了解，这个库可以处理非数值数据，而且能导入/导出很多不同的列表数据格式。</p><p>总之，如果使用得当，<code>__slots__</code>能显著节省内存，不过要注意以下几点：</p><ul><li>每个子类都要定义<code>__slots__</code>属性，因为解释器会忽略继承的<code>__slots__</code>属性。</li><li>实例只能拥有<code>__slots__</code>中列出的属性，除非把'<code>__dict__</code>'加入<code>__slots__</code>中（这样做就失去了节省内存的功效）。</li><li>如果不把'<code>__weakref__'</code>加入<code>__slots__</code>，实例就不能作为弱引用的目标。</li></ul><h1 id="覆盖类属性">覆盖类属性</h1><p>Python有个很独特的特性：类属性可用于为实例属性提供默认值。Vector2d中有个typecode类属性，<code>__bytes__</code>方法两次用到了它，而且都故意使用self.typecode读取它的值。因此Vector2d实例本身没有typecode属性，所以self.typecode默认获取的是Vector2d.typecode类属性的值。</p><p>但是，如果为不存在的实例属性赋值，会新建实例属性。假如我们为typecode实例属性赋值，那么同名类属性不受影响。然而，自此之后，实例读取的self.typecode是实例属性typecode，也就是把同名类属性遮盖了。借助这一特性，可以为各个实例的typecode属性定制不同的值。</p><p>Vector2d.typecode属性的默认值是'd'，即转换成字节序列时使用8字节双精度浮点数表示向量的各个分量。如果转换之前把Vector2d实例的typecode属性设为'f'，那么使用4字节的单精度浮点数表示各个分量。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector2d(<span class="number">1.1</span>, <span class="number">2.2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dumpd = bytes(v1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dumpd</span><br><span class="line"><span class="string">b'd\x9a\x99\x99\x99\x99\x99\xf1?\x9a\x99\x99\x99\x99\x99\x01@'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(dumpd)</span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1.typecode = <span class="string">'f'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dumpf = bytes(v1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dumpf</span><br><span class="line"><span class="string">b'f\xcd\xcc\x8c?\xcd\xcc\x0c@'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(dumpf)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Vector2d.typecode, v1.typecode</span><br><span class="line">(<span class="string">'d'</span>, <span class="string">'f'</span>)</span><br></pre></td></tr></table></figure><p>如果想修改类属性的值，必须直接在类上修改，不能通过实例修改。如果想修改所有实例（没有typecode实例变量）的typecode属性的默认值，可以这么做：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Vector2d.typecode = <span class="string">'f'</span></span><br></pre></td></tr></table></figure><p>然而，有种修改方法更符合Python风格，而且效果持久，也更有针对性。类属性是公开的，因此会被子类继承，于是经常会创建一个子类，只用于定制类的数据属性。Diango基于类的视图就大量使用了这个技术。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShortVector2d</span><span class="params">(Vector2d)</span>:</span></span><br><span class="line">    typecode = <span class="string">'f'</span></span><br></pre></td></tr></table></figure></div><div class="popular-posts-header">相关文章</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/fluent-python/abc-s-in-standard-library/" rel="bookmark">标准库中的抽象基类</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/fluent-python/attribute-descriptors/" rel="bookmark">属性描述符</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/fluent-python/class-metaprogramming/" rel="bookmark">类元编程</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/fluent-python/concurrency-with-asyncio/" rel="bookmark">使用asyncio包处理并发</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/fluent-python/concurrency-with-futures/" rel="bookmark">使用futures处理并发</a></div></li></ul><footer class="post-footer"><div class="post-tags"> <a href="/tags/Fluent-Python/" rel="tag"># Fluent Python</a></div><div class="post-nav"><div class="post-nav-item"><a href="/notes/fluent-python/object-references-mutability-and-recycling/" rel="prev" title="对象引用、可变性和垃圾回收"><i class="fa fa-chevron-left"></i> 对象引用、可变性和垃圾回收</a></div><div class="post-nav-item"> <a href="/notes/fluent-python/sequence-hacking-hashing-and-slicing/" rel="next" title="序列的修改、散列和切片">序列的修改、散列和切片<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#对象表示形式"><span class="nav-number">1.</span> <span class="nav-text">对象表示形式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#再谈向量类"><span class="nav-number">2.</span> <span class="nav-text">再谈向量类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#备选构造方法"><span class="nav-number">3.</span> <span class="nav-text">备选构造方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#classmethod与staticmethod"><span class="nav-number">3.1.</span> <span class="nav-text">classmethod与staticmethod</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#格式化显示"><span class="nav-number">4.</span> <span class="nav-text">格式化显示</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#可散列的vector2d"><span class="nav-number">5.</span> <span class="nav-text">可散列的Vector2d</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#python的私有属性和受保护的属性"><span class="nav-number">6.</span> <span class="nav-text">Python的私有属性和“受保护的”属性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用__slots__类属性节省空间"><span class="nav-number">7.</span> <span class="nav-text">使用__slots__类属性节省空间</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#覆盖类属性"><span class="nav-number">8.</span> <span class="nav-text">覆盖类属性</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="菜农陈文生" src="/uploads/avatar/nekosensei.png"><p class="site-author-name" itemprop="name">菜农陈文生</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">160</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">11</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">162</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/cncws" title="GitHub → https://github.com/cncws" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a></span><span class="links-of-author-item"><a href="mailto:1031616423@qq.com" title="E-Mail → mailto:1031616423@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">菜农陈文生</span></div><script src="//cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="//cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script><script src="/js/aplayer-el.js"></script><script src="//unpkg.com/video.js/dist/video.min.js"></script><script src="/js/videojs-bilibili.js"></script><script src="/js/videojs-bilibili-el.js"></script></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script><script src="/js/local-search.js"></script><div id="pjax"><script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Axl15EIRi5o5AatKaxXxV4Oq-gzGzoHsz',
      appKey     : 'E0qm04UjsP0qQN1l8ME3GQ25',
      placeholder: "Just go go",
      avatar     : 'identicon',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script></div></body></html>