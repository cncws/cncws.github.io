<!DOCTYPE html><html lang="zh-CN,en,default"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/uploads/icon/drop/128x128.png"><link rel="icon" type="image/png" sizes="32x32" href="/uploads/icon/drop/32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/uploads/icon/drop/16x16.png"><link rel="mask-icon" href="/uploads/icon/drop/drop.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"cwscn.github.io",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1,width:240},copycode:{enable:!0,show_result:!0,style:"flat"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"manual"},fancybox:!1,mediumzoom:!0,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"fadeIn"}},path:"search.xml"}</script><meta name="description" content="在Python中，数据的属性和处理数据的方法统称属性（attribute）。其实，方式只是可调用的属性。除了这二者之外，我们还可以创建特性（property），在不改变接口的前提下，使用存取方法（即读值方法和设值方法）修改数据属性。这与统一访问原则相符：不管服务是由存储还是计算实现的，一个模块提供的所有服务都应该通过统一的方式使用。 除了特性，Python还提供了丰富的API，用于控制属性的访问权"><meta name="keywords" content="Fluent Python,attribute"><meta property="og:type" content="article"><meta property="og:title" content="使用动态属性转换数据"><meta property="og:url" content="https://cwscn.github.io/notes/fluent-python/data-wrangling-with-dynamic-attributes/index.html"><meta property="og:site_name" content="水滴"><meta property="og:description" content="在Python中，数据的属性和处理数据的方法统称属性（attribute）。其实，方式只是可调用的属性。除了这二者之外，我们还可以创建特性（property），在不改变接口的前提下，使用存取方法（即读值方法和设值方法）修改数据属性。这与统一访问原则相符：不管服务是由存储还是计算实现的，一个模块提供的所有服务都应该通过统一的方式使用。 除了特性，Python还提供了丰富的API，用于控制属性的访问权"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://www.plantuml.com/plantuml/svg/TOzH3i8W44J_UugzW3VmKo_W1KWBeoLAmMKrQR1t5ojfBAdxHTumkpEzDI2u82Cvk0xSw5iR8vsWFHjA3UL93j9xCv5ITh2YL4rnpsmgraEtDaTfnUhypNHhtw94o7_niY6U8RgdDDyhh8x42FmJwlZ482LHVZv0AR0FO1c_rXZGNi6nvbihIx_zQxUKRPRM7pfVUmC0"><meta property="og:updated_time" content="2020-05-21T01:52:14.550Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="使用动态属性转换数据"><meta name="twitter:description" content="在Python中，数据的属性和处理数据的方法统称属性（attribute）。其实，方式只是可调用的属性。除了这二者之外，我们还可以创建特性（property），在不改变接口的前提下，使用存取方法（即读值方法和设值方法）修改数据属性。这与统一访问原则相符：不管服务是由存储还是计算实现的，一个模块提供的所有服务都应该通过统一的方式使用。 除了特性，Python还提供了丰富的API，用于控制属性的访问权"><meta name="twitter:image" content="http://www.plantuml.com/plantuml/svg/TOzH3i8W44J_UugzW3VmKo_W1KWBeoLAmMKrQR1t5ojfBAdxHTumkpEzDI2u82Cvk0xSw5iR8vsWFHjA3UL93j9xCv5ITh2YL4rnpsmgraEtDaTfnUhypNHhtw94o7_niY6U8RgdDDyhh8x42FmJwlZ482LHVZv0AR0FO1c_rXZGNi6nvbihIx_zQxUKRPRM7pfVUmC0"><link rel="canonical" href="https://cwscn.github.io/notes/fluent-python/data-wrangling-with-dynamic-attributes/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css"><link rel="stylesheet" href="//unpkg.com/video.js/dist/video-js.min.css"><link rel="stylesheet" href="/css/videojs-bilibili.css"><style>.aplayer.aplayer-arrow .aplayer-icon-loop,.aplayer.aplayer-arrow .aplayer-icon-order{display:inline-block}</style><title>使用动态属性转换数据 | 水滴</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">水滴</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">愿你走出半生 归来仍是少年</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档<span class="badge">177</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类<span class="badge">11</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签<span class="badge">170</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i> 关于</a></li><li class="menu-item menu-item-收藏"><a href="/favlist/" rel="section"><i class="fa fa-star fa-fw"></i> 收藏</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div><meting-js server="netease" type="playlist" id="67155774" theme="#ff5555" loop="all" order="list" preload="none" volume="" mutex="" list-folded="NaN" fixed="true"></meting-js></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwscn.github.io/notes/fluent-python/data-wrangling-with-dynamic-attributes/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar/nekosensei.png"><meta itemprop="name" content="菜农陈文生"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="水滴"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 使用动态属性转换数据</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-05-21 09:52:14" itemprop="dateModified" datetime="2020-05-21T09:52:14+08:00">2020-05-21</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/notes/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/notes/fluent-python/data-wrangling-with-dynamic-attributes/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/notes/fluent-python/data-wrangling-with-dynamic-attributes/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><p>在Python中，数据的属性和处理数据的方法统称属性（attribute）。其实，方式只是可调用的属性。除了这二者之外，我们还可以创建特性（property），在不改变接口的前提下，使用存取方法（即读值方法和设值方法）修改数据属性。这与统一访问原则相符：不管服务是由存储还是计算实现的，一个模块提供的所有服务都应该通过统一的方式使用。</p><p>除了特性，Python还提供了丰富的API，用于控制属性的访问权限，以及实现动态属性。使用点号访问属性时（如obj.attr），Python解释器会调用特殊的方法（如<code>__getattr__</code>和<code>__setattr__</code>）计算属性。用户自己定义的类可以通过<code>__getattr__</code>方法实现“虚拟属性”，当访问不存在的属性时，即时计算属性的值。</p><p>动态创建属性是一种元编程，框架的作者经常这么做。然而，在Python中，相关的基础技术十分简单，任何人都可以使用，甚至在日常的数据转换任务中也能用到。下面以这种任务开启本章的话题。</p><a id="more"></a><h1 id="使用动态属性转换数据">使用动态属性转换数据</h1><figure class="highlight json"><figcaption><span>osconfeed.json</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">"Schedule"</span>:</span><br><span class="line">  &#123; <span class="attr">"conferences"</span>: [&#123;<span class="attr">"serial"</span>: <span class="number">115</span> &#125;],</span><br><span class="line">    <span class="attr">"events"</span>: [</span><br><span class="line">      &#123; <span class="attr">"serial"</span>: <span class="number">34505</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Why Schools Don ́t Use Open Source to Teach Programming"</span>,</span><br><span class="line">        <span class="attr">"event_type"</span>: <span class="string">"40-minute conference session"</span>,</span><br><span class="line">        <span class="attr">"time_start"</span>: <span class="string">"2014-07-23 11:30:00"</span>,</span><br><span class="line">        <span class="attr">"time_stop"</span>: <span class="string">"2014-07-23 12:10:00"</span>,</span><br><span class="line">        <span class="attr">"venue_serial"</span>: <span class="number">1462</span>,</span><br><span class="line">        <span class="attr">"description"</span>: <span class="string">"Aside from the fact that high school programming..."</span>,</span><br><span class="line">        <span class="attr">"website_url"</span>: <span class="string">"http://oscon.com/oscon2014/public/schedule/detail/34505"</span>,</span><br><span class="line">        <span class="attr">"speakers"</span>: [<span class="number">157509</span>],</span><br><span class="line">        <span class="attr">"categories"</span>: [<span class="string">"Education"</span>] &#125;,</span><br><span class="line">      &#123; <span class="attr">"更多条记录"</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"speakers"</span>: [</span><br><span class="line">      &#123; <span class="attr">"serial"</span>: <span class="number">157509</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Robert Lefkowitz"</span>,</span><br><span class="line">        <span class="attr">"photo"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"url"</span>: <span class="string">"http://sharewave.com/"</span>,</span><br><span class="line">        <span class="attr">"position"</span>: <span class="string">"CTO"</span>,</span><br><span class="line">        <span class="attr">"affiliation"</span>: <span class="string">"Sharewave"</span>,</span><br><span class="line">        <span class="attr">"twitter"</span>: <span class="string">"sharewaveteam"</span>,</span><br><span class="line">        <span class="attr">"bio"</span>: <span class="string">"Robert  ́r0ml ́ Lefkowitz is the CTO at Sharewave, a startup..."</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">"更多条记录"</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"venues"</span>: [</span><br><span class="line">      &#123; <span class="attr">"serial"</span>: <span class="number">1462</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"F151"</span>,</span><br><span class="line">        <span class="attr">"category"</span>: <span class="string">"Conference Venues"</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">"更多条记录"</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>osconfeed.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">URL = <span class="string">'http://www.oreilly.com/pub/sc/osconfeed'</span></span><br><span class="line">JSON = <span class="string">'data/osconfeed.json'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(JSON):  <span class="comment"># 如果文件不存在就去下载</span></span><br><span class="line">        msg = <span class="string">'downloading &#123;&#125; to &#123;&#125;'</span>.format(URL, JSON)</span><br><span class="line">        warnings.warn(msg)  <span class="comment"># 发出警告</span></span><br><span class="line">        <span class="comment"># 在with语句中使用两个上下文管理器</span></span><br><span class="line">        <span class="keyword">with</span> urlopen(URL) <span class="keyword">as</span> remote, open(JSON, <span class="string">'wb'</span>) <span class="keyword">as</span> local:</span><br><span class="line">            local.write(remote.read())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(JSON) <span class="keyword">as</span> fp:</span><br><span class="line">        <span class="keyword">return</span> json.load(fp)  <span class="comment"># 返回Python原生对象</span></span><br></pre></td></tr></table></figure><h1 id="使用动态属性访问json类数据">使用动态属性访问JSON类数据</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> osconfeed <span class="keyword">import</span> load</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>feed = load()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(feed[<span class="string">'Schedule'</span>].keys())  <span class="comment"># feed是一个字典，里面嵌套这字典和列表</span></span><br><span class="line">[<span class="string">'conferences'</span>, <span class="string">'events'</span>, <span class="string">'speakers'</span>, <span class="string">'venues'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key, value <span class="keyword">in</span> sorted(feed[<span class="string">'Schedule'</span>].items()):</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'&#123;:3&#125; &#123;&#125;'</span>.format(len(value), key))</span><br><span class="line">...</span><br><span class="line">  <span class="number">1</span> conferences</span><br><span class="line"><span class="number">494</span> events</span><br><span class="line"><span class="number">357</span> speakers</span><br><span class="line"> <span class="number">53</span> venues</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>feed[<span class="string">'Schedule'</span>][<span class="string">'speakers'</span>][<span class="number">-1</span>][<span class="string">'name'</span>]  <span class="comment"># 最后一位演讲者的名字</span></span><br><span class="line"><span class="string">'Carina C. Zona'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>feed[<span class="string">'Schedule'</span>][<span class="string">'speakers'</span>][<span class="number">-1</span>][<span class="string">'serial'</span>]  <span class="comment"># 最后一位演讲者的编号</span></span><br><span class="line"><span class="number">141590</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>feed[<span class="string">'Schedule'</span>][<span class="string">'events'</span>][<span class="number">40</span>][<span class="string">'name'</span>]  <span class="comment"># 事件名称</span></span><br><span class="line"><span class="string">'There *Will* Be Bugs'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>feed[<span class="string">'Schedule'</span>][<span class="string">'events'</span>][<span class="number">40</span>][<span class="string">'speakers'</span>]  <span class="comment"># 事件的演讲者列表</span></span><br><span class="line">[<span class="number">3471</span>, <span class="number">5199</span>]</span><br></pre></td></tr></table></figure><h2 id="使用动态属性访问json类数据-1">使用动态属性访问JSON类数据</h2><p>feed['Schedule']['events'][40]['name']这种句法很冗长。在JavaScript中，可以使用feed.Schedule.events[40].name获取那个值。在Python中，可以实现一个近似字典的类（网上有大量实现，最常提到的一个实现是<a href="https://pypi.python.org/pypi/attrdict" target="_blank" rel="noopener">AttrDict</a>，还有一个实现能快速创建嵌套的映射——<a href="https://pypi.python.org/pypi/addict" target="_blank" rel="noopener">addict</a>），达到同样的效果。</p><figure class="highlight python"><figcaption><span>explore0.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrozenJSON</span>:</span></span><br><span class="line">    <span class="string">"""一个只读接口，使用属性表示法访问JSON类对象</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, mapping)</span>:</span></span><br><span class="line">        self.__data = dict(mapping)  <span class="comment"># 使用mapping创建一个字典副本</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(self.__data, name):  <span class="comment"># name是__data的属性</span></span><br><span class="line">            <span class="keyword">return</span> getattr(self.__data, name)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 从__data中获取name键对应的元素</span></span><br><span class="line">            <span class="keyword">try</span>:  <span class="comment"># 捕获异常的姿势可能不正确</span></span><br><span class="line">                <span class="keyword">return</span> FrozenJSON.build(self.__data[name])</span><br><span class="line">            <span class="keyword">except</span> KeyError:  <span class="comment"># 可能出现KeyError异常</span></span><br><span class="line">                msg = <span class="string">'&#123;!r&#125; object has no attribute &#123;!r&#125;'</span></span><br><span class="line">                <span class="comment"># 属性访问应该抛出AttributeError</span></span><br><span class="line">                <span class="keyword">raise</span> AttributeError(msg.format(type(self).__name__, name))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(cls, obj)</span>:</span>  <span class="comment"># 备选构造方法</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(obj, abc.Mapping):  <span class="comment"># 是映射</span></span><br><span class="line">            <span class="keyword">return</span> cls(obj)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(obj, abc.MutableSequence):  <span class="comment"># 是列表</span></span><br><span class="line">            <span class="keyword">return</span> [cls.build(item) <span class="keyword">for</span> item <span class="keyword">in</span> obj]</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 其他</span></span><br><span class="line">            <span class="keyword">return</span> obj</span><br></pre></td></tr></table></figure><p>我们要记住重要的一点，<strong>仅当无法使用常规的方式获取属性（即在实例、类或超类中找不到指定的属性），解释器才会调用特殊的<code>__getattr__</code>方法。</strong>这个方法首先查看<code>self.__data</code>字典有没有指定名称的属性（不是键），这样FrozenJSON实例便可以处理字典的所有方法，例如把items方法委托给<code>self.__data.items</code>方法。如果<code>self.__data</code>没有指定名称的属性，那么<code>__getattr__</code>方法以那个名称为键，从<code>self.__data</code>中获取一个元素，传给FrozenJSON.build方法。这样就能深入JSON数据的嵌套结构，使用类方法build把每一层嵌套转换成一个FrozenJSON实例。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> osconfeed <span class="keyword">import</span> load</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> explore0 <span class="keyword">import</span> FrozenJSON</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>raw_feed = load()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>feed = FrozenJSON(raw_feed)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(feed.Schedule.speakers)</span><br><span class="line"><span class="number">357</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(feed.Schedule.keys())</span><br><span class="line">[<span class="string">'conferences'</span>, <span class="string">'events'</span>, <span class="string">'speakers'</span>, <span class="string">'venues'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>talk = feed.Schedule.events[<span class="number">40</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(talk)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">explore0</span>.<span class="title">FrozenJSON</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">talk</span>.<span class="title">name</span></span></span><br><span class="line"><span class="class">'<span class="title">There</span> *<span class="title">Will</span>* <span class="title">Be</span> <span class="title">Bugs</span>'</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">talk</span>.<span class="title">flavor</span></span></span><br><span class="line"><span class="class"><span class="title">Traceback</span> <span class="params">(most recent call last)</span>:</span></span><br><span class="line">  File <span class="string">"/Users/cws/Desktop/explore0.py"</span>, line <span class="number">15</span>, <span class="keyword">in</span> __getattr__</span><br><span class="line">    <span class="keyword">return</span> FrozenJSON.build(self.__data[name])</span><br><span class="line">KeyError: <span class="string">'flavor'</span>  <span class="comment"># 这个也出来了？</span></span><br><span class="line"></span><br><span class="line">During handling of the above exception, another exception occurred:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"/Users/cws/Desktop/explore0.py"</span>, line <span class="number">19</span>, <span class="keyword">in</span> __getattr__</span><br><span class="line">    <span class="keyword">raise</span> AttributeError(msg.format(type(self).__name__, name))</span><br><span class="line">AttributeError: <span class="string">'FrozenJSON'</span> object has no attribute <span class="string">'flavor'</span></span><br></pre></td></tr></table></figure><p>注意，我们没有缓存或转换原始数据源。在迭代数据源的过程中，嵌套的数据结构不断被转换成FrozenJSON对象。这么做没问题，因为数据集不大，而且这个脚本只用于访问或转换数据。</p><p>从随机源中生成或仿效动态属性名的脚本都必须处理一个问题：原始数据中的键可能不适合作为属性名。</p><h2 id="处理无效属性名">处理无效属性名</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>grad = FrozenJSON(&#123;<span class="string">'name'</span>: <span class="string">'Jim Bo'</span>, <span class="string">'class'</span>: <span class="number">1982</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grad.<span class="keyword">class</span>  <span class="comment"># 无法读取，因为在Python中class是保留字</span></span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    grad.<span class="keyword">class</span></span><br><span class="line">             ^</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(grad, <span class="string">'class'</span>)  <span class="comment"># 可以这么做，但是不够便利</span></span><br><span class="line"><span class="number">1982</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>explore1.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword  <span class="comment"># 检查关键字</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># FrozenJSON类中修改</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, mapping)</span>:</span></span><br><span class="line">        self.__data = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> mapping.items():  <span class="comment"># 检查每个键名</span></span><br><span class="line">            <span class="keyword">if</span> keyword.iskeyword(key):  <span class="comment"># 在关键字的属性后面加_</span></span><br><span class="line">                key += <span class="string">'_'</span></span><br><span class="line">            self.__data[key] = value</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> osconfeed <span class="keyword">import</span> load</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grad = FrozenJSON(&#123;<span class="string">'name'</span>: <span class="string">'Jim Bo'</span>, <span class="string">'class'</span>: <span class="number">1982</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grad.class_  <span class="comment"># 这样访问</span></span><br></pre></td></tr></table></figure><p>如果JSON对象中的键不是有效的Python标识符，也会遇到类似的问题：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = FrozenJSON(&#123;<span class="string">'2be'</span>:<span class="string">'or not'</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x<span class="number">.2</span>be</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    x<span class="number">.2</span>be</span><br><span class="line">      ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><p>这种有问题的键在Python3中易于检测，因为str类提供的isidentifier方法能根据语言的语法判断s是否为有效的Python标识符。但是，把无效的标识符变成有效的属性名却不容易。对此，有两个简单的解决方法，一个是抛出异常，另一个是把无效的键换成通用名称，例如attr_0、attr_1，等等。</p><p>类方法build把嵌套结构转换成FrozenJSON实例或FrozenJSON实例列表，因为<code>__getattr__</code>方法使用这个方法访问属性时，能为不同的值返回不同类型的对象。除了在类方法中实现这样的逻辑之外，还可以在特殊的<code>__new__</code>方法中实现。</p><h2 id="使用__new__方法以灵活的方式创建对象">使用<code>__new__</code>方法以灵活的方式创建对象</h2><p>我们通常把<code>__init__</code>称为构造方法，这是从其他语言借鉴过来的术语。其实，用于构建实例的是特殊方法<code>__new__</code>：这是个类方法（使用特殊方式处理，因此不必使用@classmethod装饰器），必须返回一个实例。返回的实例会作为第一个参数（即self）传给<code>__init__</code>方法。因为调用<code>__init__</code>方法时要传入实例，而且禁止返回任何值，所以<code>__init__</code>方法其实是“初始化方法”。真正的构造方法是<code>__new__</code>。我们几乎不需要自己编写<code>__new__</code>方法，因为从object类继承的实现已经足够了。</p><p>从<code>__new__</code>方法到<code>__init__</code>方法，是最常见的，但不是唯一的。<code>__new__</code>方法也可以返回其他类的实例，此时，解释器不会调用<code>__init__</code>方法。</p><p>也就是说，Python构建对象的过程可以使用下述伪代码概括：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构建对象的伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object_maker</span><span class="params">(the_class, some_arg)</span>:</span></span><br><span class="line">    new_object = the_class.__new__(some_arg)</span><br><span class="line">    <span class="keyword">if</span> isinstance(new_object, the_class):</span><br><span class="line">        the_class.__init__(new_object, some_arg)</span><br><span class="line">    <span class="keyword">return</span> new_object</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下述两个语句的作用基本等效</span></span><br><span class="line">x = Foo(<span class="string">'bar'</span>)</span><br><span class="line">x = object_maker(Foo, <span class="string">'bar'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>explore2.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrozenJSON</span>:</span></span><br><span class="line">    <span class="string">"""一个只读接口，使用属性表示法访问JSON类对象</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, arg)</span>:</span>  <span class="comment"># 第一个参数是类本身</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(arg, abc.Mapping):</span><br><span class="line">            <span class="keyword">return</span> super().__new__(cls)  <span class="comment"># 默认的行为</span></span><br><span class="line">        <span class="keyword">elif</span> isinstance(arg, abc.MutableSequence):</span><br><span class="line">            <span class="keyword">return</span> [cls(item) <span class="keyword">for</span> item <span class="keyword">in</span> arg]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> arg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, mapping)</span>:</span></span><br><span class="line">        self.__data = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> mapping.items():</span><br><span class="line">            <span class="keyword">if</span> iskeyword(key):</span><br><span class="line">                key += <span class="string">'_'</span></span><br><span class="line">            self.__data[key] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(self.__data, name):</span><br><span class="line">            <span class="keyword">return</span> getattr(self.__data, name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> FrozenJSON(self.__data[name])  <span class="comment"># 直接调用构造方法</span></span><br></pre></td></tr></table></figure><p><code>__new__</code>方法的第一个参数是类，因为创建的对象通常是那个类的实例。所以，在<code>FrozenJSON.__new__</code>方法中，<code>super().__new__(cls)</code>表达式会调用<code>object.__new__(FrozenJSON)</code>，而object类构建的实例其实是FrozenJSON实例，即那个实例的<code>__class__</code>属性存储的是FrozenJSON类的引用。不过，真正的构建操作由解释器调用C语言实现的<code>object.__new__</code>方法执行。</p><p>OSCON的JSON数据源有一个明显的缺点：索引为40的事件，即名为'There *Will* Be Bugs'的那个，有两位演讲者，3471和5199，但却不容易找到他们，因为提供的是编号，而 Schedule.speakers列表没有使用编号建立索引。此外，每条事件记录中都有venue_serial字段，存储的值也是编号，但是如果想找到对应的记录，那就要线性搜索Schedule.venues列表。接下来的任务是，调整数据结构，以便自动获取所链接的记录。</p><h2 id="使用shelve模块调整oscon数据源的结构">使用shelve模块调整OSCON数据源的结构</h2><p>标准库中有个<a href="https://devdocs.io/python~3.6/library/shelve" target="_blank" rel="noopener">shelve</a>（架子）模块，shelve模块提供了pickle（泡菜，Python对象序列化格式的名字）存储方式。</p><p><a href="https://devdocs.io/python~3.6/library/shelve#shelve.open" target="_blank" rel="noopener">shelve.open</a>高阶函数返回一个shelve.Shelf实例，这是简单的键值对象数据库，背后由<a href="https://devdocs.io/python~3.6/library/dbm" target="_blank" rel="noopener">dbm</a>模块支持，具有下述特点：</p><ul><li>shelve.Shelf是abc.MutableMapping的子类，因此提供了处理映射类型的重要方法。</li><li>此外，shelve.Shelf类还提供了几个管理I/O的方法，如sync和close；它也是一个上下文管理器。</li><li>只要把新值赋予键，就会保存键和值。</li><li>键必须是字符串。</li><li>值必须是pickle模块能处理的对象。</li></ul><p>shelve模块为识别OSCON的日程数据提供了一种简单有效的方式。我们将从JSON文件中读取所有记录，将其存在一个shelve.Shelf对象中，键由记录类型和编号组成（例如，'event.33950'或'speaker.3471'），而值是我们即将定义的Record类的实例。</p><figure class="highlight python"><figcaption><span>schedule1.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> osconfeed</span><br><span class="line"></span><br><span class="line">DB_NAME = <span class="string">'data/schedule1_db'</span></span><br><span class="line">CONFERENCE = <span class="string">'conference.115'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Record</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        self.__dict__.update(kwargs)  <span class="comment"># 更新实例的__dict__属性</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_db</span><span class="params">(db)</span>:</span></span><br><span class="line">    raw_data = osconfeed.load()  <span class="comment"># 加载数据</span></span><br><span class="line">    warnings.warn(<span class="string">'loading '</span> + DB_NAME)</span><br><span class="line">    <span class="keyword">for</span> collection, rec_list <span class="keyword">in</span> raw_data[<span class="string">'Schedule'</span>].items():</span><br><span class="line">        record_type = collection[:<span class="number">-1</span>]  <span class="comment"># 去掉尾部's'后的集合名，例如event</span></span><br><span class="line">        <span class="keyword">for</span> record <span class="keyword">in</span> rec_list:</span><br><span class="line">            key = <span class="string">'&#123;&#125;.&#123;&#125;'</span>.format(record_type, record[<span class="string">'serial'</span>])</span><br><span class="line">            record[<span class="string">'serial'</span>] = key  <span class="comment"># 把serial的值设置为完整的键：type.serial</span></span><br><span class="line">            db[key] = Record(**record)  <span class="comment"># 在数据库中存储Record实例</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python -i schedule1.py  <span class="comment"># 启动加载了schedule1模块的控制台</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> shelve</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db = shelve.open(DB_NAME)  <span class="comment"># 打开数据库，或者新建一个</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> CONFERENCE <span class="keyword">not</span> <span class="keyword">in</span> db:  <span class="comment"># 判断数据库是否填充</span></span><br><span class="line"><span class="meta">... </span>    load_db(db)  <span class="comment"># 加载数据库</span></span><br><span class="line">...</span><br><span class="line">schedule1.py:<span class="number">14</span>: UserWarning: loading data/schedule1_db</span><br><span class="line">  warnings.warn(<span class="string">'loading '</span> + DB_NAME)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>speaker = db[<span class="string">'speaker.3471'</span>]  <span class="comment"># 一条speaker记录</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(speaker)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Record</span>'&gt;</span></span><br><span class="line">&gt;&gt;&gt; speaker.name, speaker.twitter  # 在某些应用中，Record类可能要处理不能作为属性名使用的键</span><br><span class="line">(<span class="string">'Anna Ravenscroft'</span>, <span class="string">'annaraven'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db.close()  <span class="comment"># 关闭Shelf对象。如果可以，使用with块确保Shelf对象会关闭</span></span><br></pre></td></tr></table></figure><p>FrozenJSON类要递归转换嵌套的映射和列表；而Record类不需要这么做，因为转换好的数据集中没有嵌套的映射和列表，记录中只有字符串、整数、字符串列表和整数列表。FrozenJSON类要访问内嵌的<code>__data</code>（值是字典）属性，而现在我们不需要这么做了（因为<code>self.__dict__.update(kwargs)</code>已经将传入的键值对保存到实例属性中了）。</p><p>Python标准库中至少有两个与Record类似的类，其实例可以有任意个属性，由传给构造方法的关键字参数构建——<a href="https://devdocs.io/python~3.6/library/multiprocessing#multiprocessing.managers.Namespace" target="_blank" rel="noopener">multiprocessing.managers.Namespace</a>类和<a href="https://devdocs.io/python~3.6/library/argparse#argparse.Namespace" target="_blank" rel="noopener">argparse.Namespace</a>类。之所以自己实现Record，是为了说明一个重要的做法：在<code>__init__</code>方法中更新实例的<code>__dict__</code>属性。</p><h2 id="使用特性获取链接的记录">使用特性获取链接的记录</h2><p>我们可以扩展Record类，让它提供一个有用的服务：自动获取event记录引用的venue和speaker记录，而不是编号。</p> <img src="http://www.plantuml.com/plantuml/svg/TOzH3i8W44J_UugzW3VmKo_W1KWBeoLAmMKrQR1t5ojfBAdxHTumkpEzDI2u82Cvk0xSw5iR8vsWFHjA3UL93j9xCv5ITh2YL4rnpsmgraEtDaTfnUhypNHhtw94o7_niY6U8RgdDDyhh8x42FmJwlZ482LHVZv0AR0FO1c_rXZGNi6nvbihIx_zQxUKRPRM7pfVUmC0"><p>Record：<code>__init__</code>方法不变；为了辅助测试，增加了<code>__eq__</code>方法。</p><p>DbRecord：Record类的子类，添加了<code>__db</code>类属性，用于设置和获取<code>__db</code>属性的set_db和get_db静态方法，用于从数据库中获取记录的fetch类方法，以及辅助调试和测试的<code>__repr__</code>实例方法。</p><p>Event：DbRecord类的子类，添加了用于获取所链接记录的venue和speakers属性，以及特殊的<code>__repr__</code>方法。</p><figure class="highlight python"><figcaption><span>schedule2.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> osconfeed</span><br><span class="line"></span><br><span class="line">DB_NAME = <span class="string">'data/schedule2_db'</span></span><br><span class="line">CONFERENCE = <span class="string">'conference.115'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Record</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        self.__dict__.update(kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(other, Record):</span><br><span class="line">            <span class="keyword">return</span> self.__dict__ == other.__dict__</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MissingDatabaseError</span><span class="params">(RuntimeError)</span>:</span>  <span class="comment"># 自定义的异常通常是标志类</span></span><br><span class="line">    <span class="string">"""需要数据库但没有指定数据库时抛出"""</span>   <span class="comment"># 没有定义体，写一个文档字符串</span></span><br><span class="line">                                        <span class="comment"># 说明异常的用途，比pass语句要好</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DbRecord</span><span class="params">(Record)</span>:</span>  <span class="comment"># 扩展Record类</span></span><br><span class="line"></span><br><span class="line">    __db = <span class="literal">None</span>  <span class="comment"># 存储一个打开的Shelf数据库引用</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod  # 静态方法，以此强调不管调用多少次</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_db</span><span class="params">(db)</span>:</span>  <span class="comment"># 效果始终一样</span></span><br><span class="line">        DbRecord.__db = db</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_db</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> DbRecord.__db</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod  # 类方法，在子类中易于定制它的行为</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(cls, ident)</span>:</span></span><br><span class="line">        db = cls.get_db()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> db[ident]  <span class="comment"># 从数据库中获取</span></span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="keyword">if</span> db <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 数据库为空时，抛出自定义异常</span></span><br><span class="line">                msg = <span class="string">"database not set; call '&#123;&#125;.set_db(my_db)'"</span></span><br><span class="line">                <span class="keyword">raise</span> MissingDatabseError(msg.format(cls.__name__))</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 否则重新抛出TypeError，因为我们不知道怎么处理</span></span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(self, <span class="string">'serial'</span>):</span><br><span class="line">            cls_name = self.__class__.__name__</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'&lt;&#123;&#125; serial=&#123;!r&#125;&gt;'</span>.format(cls_name, self.serial)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 调用继承的方法</span></span><br><span class="line">            <span class="keyword">return</span> super().__repr__()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span><span class="params">(DbRecord)</span>:</span>  <span class="comment"># 扩展DbRecord类</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">venue</span><span class="params">(self)</span>:</span>  <span class="comment"># venue特性</span></span><br><span class="line">        key = <span class="string">'venue.&#123;&#125;'</span>.format(self.venue_serial)</span><br><span class="line">        <span class="keyword">return</span> self.__class__.fetch(key)  <span class="comment"># 不直接使用self.fetch(key)</span></span><br><span class="line">        <span class="comment"># 对这个OSCON数据源来说，可以使用后者，因为事件记录都没有'fetch'键</span></span><br><span class="line">        <span class="comment"># 哪怕只有一个事件记录有名为'fetch'的键，那么在那个Event实例中</span></span><br><span class="line">        <span class="comment"># self.fetch获取的是fetch字段的值，而不是继承自DbRecord的fetch类方法</span></span><br><span class="line">        <span class="comment"># 这个缺陷不明显，很容易被测试忽略</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speakers</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">'_speaker_objs'</span>):</span><br><span class="line">            <span class="comment"># 从__dict__实例属性中获取</span></span><br><span class="line">            <span class="comment"># self.speakers会出现无限递归，因为特性的公开名称也是speakers</span></span><br><span class="line">            spkr_serials = self.__dict__[<span class="string">'speakers'</span>]</span><br><span class="line">            fetch = self.__class__.fetch  <span class="comment"># 获取类方法的引用</span></span><br><span class="line">            self._speaker_objs = [fetch(<span class="string">'speaker.&#123;&#125;'</span>.format(key))</span><br><span class="line">                                  <span class="keyword">for</span> key <span class="keyword">in</span> spkr_serials]</span><br><span class="line">        <span class="keyword">return</span> self._speaker_objs</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(self, <span class="string">'name'</span>):</span><br><span class="line">            cls_name = self.__class__.__name__</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'&lt;&#123;&#125; &#123;!r&#125;&gt;'</span>.format(cls_name, self.name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> super().__repr__()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_db</span><span class="params">(db)</span>:</span></span><br><span class="line">    raw_data = osconfeed.load()</span><br><span class="line">    warnings.warn(<span class="string">'loading '</span> + DB_NAME)</span><br><span class="line">    <span class="keyword">for</span> collection, rec_list <span class="keyword">in</span> raw_data[<span class="string">'Schedule'</span>].items():</span><br><span class="line">        record_type = collection[:<span class="number">-1</span>]</span><br><span class="line">        cls_name = record_type.capitalize()  <span class="comment"># 首字母大写，例如Event</span></span><br><span class="line">        <span class="comment"># 从模块的全局作用域中获取对应的对象，默认使用DbRecord</span></span><br><span class="line">        <span class="comment"># 只有事件类型的记录有自定义的类——Event。不过，如果定义了</span></span><br><span class="line">        <span class="comment"># Speaker或Venue类，load_db函数构建和保存记录时会自动使用这两个类</span></span><br><span class="line">        cls = globals().get(cls_name, DbRecord)</span><br><span class="line">        <span class="keyword">if</span> inspect.isclass(cls) <span class="keyword">and</span> issubclass(cls, DbRecord):</span><br><span class="line">            factory = cls</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            factory = DbRecord</span><br><span class="line">        <span class="keyword">for</span> record <span class="keyword">in</span> rec_list:</span><br><span class="line">            key = <span class="string">'&#123;&#125;.&#123;&#125;'</span>.format(record_type, record[<span class="string">'serial'</span>])</span><br><span class="line">            record[<span class="string">'serial'</span>] = key</span><br><span class="line">            db[key] = factory(**record)</span><br></pre></td></tr></table></figure><p><strong>从数据中创建实例属性的名称时有可能会引入缺陷，因为类属性（例如方法）可能被遮盖，或者由于意外覆盖现有的实例属性而丢失数据。这个问题可能是Python字典不能像JavaScript对象那样（obj.key）访问的原因。</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python -i schedule2.py</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> shelve</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db = shelve.open(DB_NAME)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>load_db(db)</span><br><span class="line">schedule2.py:<span class="number">85</span>: UserWarning: loading data/schedule2_db</span><br><span class="line">  warnings.warn(<span class="string">'loading '</span> + DB_NAME)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db[<span class="string">'event.33950'</span>]  <span class="comment"># 现在获取的是记录对象，而不是编号</span></span><br><span class="line">&lt;Event <span class="string">'There *Will* Be Bugs'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>DbRecord.set_db(db)  <span class="comment"># 将数据库放入类中，方便操作</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>event = DbRecord.fetch(<span class="string">'event.33950'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>event.venue  <span class="comment"># 返回记录</span></span><br><span class="line">&lt;DbRecord serial=<span class="string">'venue.1449'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>event.venue.name  <span class="comment"># 找出venue.name更容易了</span></span><br><span class="line"><span class="string">'Portland 251'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> spkr <span class="keyword">in</span> event.speakers:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'&#123;0.serial&#125;: &#123;0.name&#125;'</span>.format(spkr))</span><br><span class="line">...</span><br><span class="line">speaker<span class="number">.3471</span>: Anna Ravenscroft</span><br><span class="line">speaker<span class="number">.5199</span>: Alex Martelli</span><br></pre></td></tr></table></figure><p>特性经常用于把公开的属性变成使用读值方法和设值方法管理的属性，且在不影响代码的前提下实施业务规则。</p></div><div class="popular-posts-header">相关文章</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/fluent-python/a-pythonic-object/" rel="bookmark">符合Python风格的对象</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/fluent-python/abc-s-in-standard-library/" rel="bookmark">标准库中的抽象基类</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/fluent-python/attribute-descriptors/" rel="bookmark">属性描述符</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/fluent-python/concurrency-with-asyncio/" rel="bookmark">使用asyncio包处理并发</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/fluent-python/concurrency-with-futures/" rel="bookmark">使用futures处理并发</a></div></li></ul><footer class="post-footer"><div class="post-tags"> <a href="/tags/Fluent-Python/" rel="tag"># Fluent Python</a> <a href="/tags/attribute/" rel="tag"># attribute</a></div><div class="post-nav"><div class="post-nav-item"><a href="/programming/support-chinese-character-in-pyplot/" rel="prev" title="让pyplot支持汉字"><i class="fa fa-chevron-left"></i> 让pyplot支持汉字</a></div><div class="post-nav-item"> <a href="/notes/fluent-python/property/" rel="next" title="特性">特性<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#使用动态属性转换数据"><span class="nav-number">1.</span> <span class="nav-text">使用动态属性转换数据</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用动态属性访问json类数据"><span class="nav-number">2.</span> <span class="nav-text">使用动态属性访问JSON类数据</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用动态属性访问json类数据-1"><span class="nav-number">2.1.</span> <span class="nav-text">使用动态属性访问JSON类数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#处理无效属性名"><span class="nav-number">2.2.</span> <span class="nav-text">处理无效属性名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用__new__方法以灵活的方式创建对象"><span class="nav-number">2.3.</span> <span class="nav-text">使用__new__方法以灵活的方式创建对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用shelve模块调整oscon数据源的结构"><span class="nav-number">2.4.</span> <span class="nav-text">使用shelve模块调整OSCON数据源的结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用特性获取链接的记录"><span class="nav-number">2.5.</span> <span class="nav-text">使用特性获取链接的记录</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="菜农陈文生" src="/uploads/avatar/nekosensei.png"><p class="site-author-name" itemprop="name">菜农陈文生</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">177</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">11</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">170</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/cncws" title="GitHub → https://github.com/cncws" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a></span><span class="links-of-author-item"><a href="mailto:1031616423@qq.com" title="E-Mail → mailto:1031616423@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">菜农陈文生</span></div><script src="//cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="//cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script><script src="/js/aplayer-el.js"></script><script src="//unpkg.com/video.js/dist/video.min.js"></script><script src="/js/videojs-bilibili.js"></script><script src="/js/videojs-bilibili-el.js"></script></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script><script src="/js/local-search.js"></script><div id="pjax"><script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Axl15EIRi5o5AatKaxXxV4Oq-gzGzoHsz',
      appKey     : 'E0qm04UjsP0qQN1l8ME3GQ25',
      placeholder: "Just go go",
      avatar     : 'identicon',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script></div></body></html>