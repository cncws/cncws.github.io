<!DOCTYPE html><html lang="zh-CN,en,default"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/uploads/icon/drop/128x128.png"><link rel="icon" type="image/png" sizes="32x32" href="/uploads/icon/drop/32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/uploads/icon/drop/16x16.png"><link rel="mask-icon" href="/uploads/icon/drop/drop.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|ZCOOL XiaoWei:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"cwscn.github.io",root:"/",scheme:"Gemini",version:"7.7.2",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"flat"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"fadeIn"}},path:"search.xml"}</script><meta name="description" content="（元类）是深奥的知识，99%的用户都无需关注。如果你想知道是否需要使用元类，我告诉你，不需要（真正需要使用元类的人确信他们需要，无需解释原因）。 ——Tim Peters（Timsort算法的发明者，活跃的Python贡献者）  类元编程是指在运行时创建或定制类的技艺。在Python中，类是一等对象，因此任何时候都可以使用函数新建类，而无需使用class关键字。类装饰器也是函数，不过能够审查、修"><meta name="keywords" content="Fluent Python,metaprogramming"><meta property="og:type" content="article"><meta property="og:title" content="类元编程"><meta property="og:url" content="https://cwscn.github.io/notes/fluent-python/class-metaprogramming/index.html"><meta property="og:site_name" content="水滴"><meta property="og:description" content="（元类）是深奥的知识，99%的用户都无需关注。如果你想知道是否需要使用元类，我告诉你，不需要（真正需要使用元类的人确信他们需要，无需解释原因）。 ——Tim Peters（Timsort算法的发明者，活跃的Python贡献者）  类元编程是指在运行时创建或定制类的技艺。在Python中，类是一等对象，因此任何时候都可以使用函数新建类，而无需使用class关键字。类装饰器也是函数，不过能够审查、修"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://www.plantuml.com/plantuml/svg/NOn12eCm50Ntdk9TuES09MGlz18nVM9AVnJpDuA7hqGArUKCp4pvHL0Nsw3KWMkNFh5MsBOGtYijDX52rvJ87Z0FRoOxXNVkpWxLrZzwviBUg7WSnrognPA8UJoUPmc_YqYhBk8NVW40"><meta property="og:image" content="http://www.plantuml.com/plantuml/svg/FOmn3eCm40Hxl-8-00-84598bIAFk3CRGOG1-Iu5KXuVOmFbhcPc67iGmceR1GH1T7vYLR9j1JLDW74-sjQng4NsHaz3P9dW2bJNjCW7texzgogwTuzNKkcM6lgLqbpUgLBGGbsX4zzRvvdTSLRZsIExVm00"><meta property="og:image" content="http://www.plantuml.com/plantuml/svg/bL71QeGm5BpdAm9xAyr-G16XXHuAtK8fz1go-ggX9X7pR2dgl_TLZRfg2_La9ZFptanodG87K-8NDs3EKB6aKDxpsnhT2xfAPS2ZA0MVLBgaSnppXd7wf4nSRP44FoS_KALL1dgWCO2vIplYQQjHoZMQmGxeUx1ZwkonKWdoLrNeL26a-qjif1TW4smw_Z7waFUGxxbM5ZMb_jjtetjozgvGzft_L_YeBJmWc51VC3e45-tiS1DMEto2pd9SWMMbazyg3hFkU-e9KD6Mn58zlDVQ9BnuxrRCnRF54xH2JCMjyP27pSqASJN7lg5fGo0fh-c_pq6ZfqAtz4KpH9okH5sADXv3icNMut54IHv5sdfKDW7ktkBu6m00"><meta property="og:updated_time" content="2020-02-08T03:23:29.009Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="类元编程"><meta name="twitter:description" content="（元类）是深奥的知识，99%的用户都无需关注。如果你想知道是否需要使用元类，我告诉你，不需要（真正需要使用元类的人确信他们需要，无需解释原因）。 ——Tim Peters（Timsort算法的发明者，活跃的Python贡献者）  类元编程是指在运行时创建或定制类的技艺。在Python中，类是一等对象，因此任何时候都可以使用函数新建类，而无需使用class关键字。类装饰器也是函数，不过能够审查、修"><meta name="twitter:image" content="http://www.plantuml.com/plantuml/svg/NOn12eCm50Ntdk9TuES09MGlz18nVM9AVnJpDuA7hqGArUKCp4pvHL0Nsw3KWMkNFh5MsBOGtYijDX52rvJ87Z0FRoOxXNVkpWxLrZzwviBUg7WSnrognPA8UJoUPmc_YqYhBk8NVW40"><link rel="canonical" href="https://cwscn.github.io/notes/fluent-python/class-metaprogramming/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0}</script><title>类元编程 | 水滴</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">水滴</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">绳锯木断 水滴石穿</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i> 分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="menu-item menu-item-收藏"><a href="/favlist/" rel="section"><i class="fa fa-fw fa-heart"></i> 收藏</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css"><script src="//cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><meting-js server="netease" type="playlist" id="67155774" theme="#ffafc9" loop="all" order="list" preload="none" volume="" list-folded="NaN" fixed="true"></meting-js></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwscn.github.io/notes/fluent-python/class-metaprogramming/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar/nekosensei.png"><meta itemprop="name" content="Chen"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="水滴"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 类元编程</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-02-08 11:23:29" itemprop="dateModified" datetime="2020-02-08T11:23:29+08:00">2020-02-08</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/notes/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/notes/fluent-python/class-metaprogramming/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/notes/fluent-python/class-metaprogramming/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><blockquote><p>（元类）是深奥的知识，99%的用户都无需关注。如果你想知道是否需要使用元类，我告诉你，不需要（真正需要使用元类的人确信他们需要，无需解释原因）。</p><p>——Tim Peters（Timsort算法的发明者，活跃的Python贡献者）</p></blockquote><p>类元编程是指在运行时创建或定制类的技艺。在Python中，类是一等对象，因此任何时候都可以使用函数新建类，而无需使用class关键字。类装饰器也是函数，不过能够审查、修改，甚至把被装饰的类替换成其他类。</p><p>元类是类元编程最高级的工具：使用元类可以创建具有某种特质的全新类种，例如抽象基类。元类功能强大，但是难以掌握。类装饰器能使用更简单的方式解决更多问题。</p><p><strong>除非开发框架，否则不要编写元类</strong>。</p><a id="more"></a><h1 id="类工厂函数">类工厂函数</h1><p>本书多次提高标准库中的一个类工厂函数——collections.namedtuple。我们把一个类名和几个属性名传给这个函数，它会创建一个tuple的子类，其中的元素通过名称获取，还为调试提供了友好的字符串表示形式（<code>__repr__</code>）。</p><p>有时，我觉得应该有类似的工厂函数，用于创建可变对象。假设我在编写一个宠物点应用程序时，我想把狗的数据当作简单的记录处理。编写下面的样板代码让人厌烦：</p><figure class="highlight python"><figcaption><span>dog.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, weight, owner)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.owner = owner</span><br></pre></td></tr></table></figure><p>各个字段名称出现了3次。写了这么多样板代码，甚至字符串表示形式都不友好：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> dog <span class="keyword">import</span> Dog</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rex = Dog(<span class="string">'Rex'</span>, <span class="number">30</span>, <span class="string">'Bob'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rex</span><br><span class="line">&lt;dog.Dog object at <span class="number">0x10dbd3ef0</span>&gt;</span><br></pre></td></tr></table></figure><p>参考collections.namedtuple，下面我们创建一个record_factory函数，即时创建简单的类（如Dog）。</p><figure class="highlight python"><figcaption><span>record_factory.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record_factory</span><span class="params">(cls_name, field_names)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:  <span class="comment"># 体现了鸭子类型：尝试在逗号或空格处拆分field_names</span></span><br><span class="line">        field_names = field_names.replace(<span class="string">','</span>, <span class="string">' '</span>).split()</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        <span class="keyword">pass</span>  <span class="comment"># 如果失败，那么假定field_names本就是可迭代的对象</span></span><br><span class="line">    field_names = tuple(field_names)  <span class="comment"># 一个元素对应一个属性名</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        attrs = dict(zip(self.__slots__, args))  <span class="comment"># 位置参数</span></span><br><span class="line">        attrs.update(kwargs)  <span class="comment"># 关键字参数</span></span><br><span class="line">        <span class="keyword">for</span> name, value <span class="keyword">in</span> attrs.items():</span><br><span class="line">            setattr(self, name, value)  <span class="comment"># 设值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> self.__slots__:</span><br><span class="line">            <span class="keyword">yield</span> getattr(self, name)  <span class="comment"># 按顺序产值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span>  <span class="comment"># 生成友好的字符串表示形式</span></span><br><span class="line">        values = <span class="string">', '</span>.join(<span class="string">'&#123;&#125;=&#123;!r&#125;'</span>.format(*i) <span class="keyword">for</span> i</span><br><span class="line">                            <span class="keyword">in</span> zip(self.__slots__, self))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&#123;&#125;(&#123;&#125;)'</span>.format(self.__class__.__name__, values)</span><br><span class="line"></span><br><span class="line">    cls_attrs = dict(__slots__ = field_names,</span><br><span class="line">                     __init__ = __init__,</span><br><span class="line">                     __iter__ = __iter__,</span><br><span class="line">                     __repr__ = __repr__)</span><br><span class="line">    <span class="comment"># 调用type构造方法，构建新类</span></span><br><span class="line">    <span class="keyword">return</span> type(cls_name, (object,), cls_attrs)</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> record_factory <span class="keyword">import</span> record_factory</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Dog = record_factory(<span class="string">'Dog'</span>, <span class="string">'name weight owner'</span>)  <span class="comment"># 签名与namedtuple类似</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rex = Dog(<span class="string">'Rex'</span>, <span class="number">30</span>, <span class="string">'Bob'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rex  <span class="comment"># 友好的字符串表示形式</span></span><br><span class="line">Dog(name=<span class="string">'Rex'</span>, weight=<span class="number">30</span>, owner=<span class="string">'Bob'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name, weight, owner = rex  <span class="comment"># 便利地拆包</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name, weight</span><br><span class="line">(<span class="string">'Rex'</span>, <span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"&#123;2&#125;'s dog weights &#123;1&#125;kg"</span>.format(*rex)  <span class="comment"># 传给format等函数时也可以拆包</span></span><br><span class="line"><span class="string">"Bob's dog weights 32kg"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rex.weight = <span class="number">32</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rex</span><br><span class="line">Dog(name=<span class="string">'Rex'</span>, weight=<span class="number">32</span>, owner=<span class="string">'Bob'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Dog.__mro__  <span class="comment"># 继承自object，与创建它的工厂函数没有关系</span></span><br><span class="line">(&lt;class 'record_factory.Dog'&gt;, &lt;class 'object'&gt;)</span><br></pre></td></tr></table></figure><p><strong>通常，我们把type视作函数，因为我们像函数那样使用它</strong>，例如，调用type(my_object)获取对象所属的类——作用与<code>my_object.__class__</code>相同。然而，type是一个类。传入三个参数可以新建一个类。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/functions#type" target="_blank" rel="noopener"><code>class type(object)</code></a></p><p><code>class type(name, bases, dict)</code></p><p>With one argument, return the type of an object. The return value is a type object and generally the same object as returned by <code>object.__class__</code>.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyClass = type(<span class="string">'MyClass'</span>, (MySuperClass, MyMixin), &#123;<span class="string">'x'</span>: <span class="number">42</span>, <span class="string">'x2'</span>: <span class="keyword">lambda</span> self: self.x * <span class="number">2</span>&#125;)</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(MySuperClass, MyMixin)</span>:</span></span><br><span class="line">    x = <span class="number">42</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x2</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.x * <span class="number">2</span></span><br></pre></td></tr></table></figure><p>让人觉得新奇的是，<strong>type的实例是类</strong>。</p><p>总之，<code>record_factory</code>函数的最后一行会构建一个类，类的名称是<code>cls_name</code>参数的值，唯一的直接超类是object，有<code>__slots__</code>、<code>__init__</code>、<code>__iter__</code>和<code>__repr__</code>四个类属性，其中后三个是实例方法。</p><p>把三个参数传给type是动态创建类的常用方式。如果查看namedtuple函数的远吗，你会发现另一个种方式：先声明一个<code>_class_template</code>变量，其值是字符串形式的源码模板；然后在namedtuple函数中调用<code>_class_template.format(...)</code>方法，填充模板里的空白；最后，使用内置的exec函数计算得到的源码字符串。</p><p>在Python中做元编程时，最好不用exec和eval函数。如果接收的字符串（或片段）来自不可信的源，那么这两个函数会带来严重的安全风险。Python提供了充足的内省工具，大多数时候都不需要使用exec和eval函数。然而，Python核心开发者实现namedtuple函数时选择了使用exec函数，这样做是为了让生成的类代码能通过<code>._source</code>属性获取。</p><p>record_factory函数创建的类，其实例有个局限——不能序列化，即不能使用pickle模块里的dump/load函数处理。如果想了解完整的方案，请分析collections.namedtuple函数的源码，搜索“pickling”这个词。</p><h1 id="定制描述符的类装饰器">定制描述符的类装饰器</h1><p>LineItem示例还有个问题没有解决：储存属性的名称不具有描述性，即属性（如weight）的值存储在名为<code>_Quantity#0</code>的实例属性中，这样的名称有点不便于调试。如果储存属性的名称中包含托管属性的名称更好：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>LineItem.weight.storage_name</span><br><span class="line"><span class="string">'_Quantity#weight'</span></span><br></pre></td></tr></table></figure><p>我们不能使用描述性的储存属性名称，因为实例化描述符时无法得知托管属性的名称。可是，一旦组建好整个类，而且把描述符绑定到类属性上之后，我们就可以审查类，并为描述符设值合理的储存属性名称。</p><p>LineItem类的<code>__new__</code>方法可以做到这一点，因此，在<code>__init__</code>方法中使用描述符时，储存属性已经设置了正确的名称。为了解决这个问题而使用<code>__new__</code>方法纯属白费力气：每次新建LineItem实例时都会运行<code>__new__</code>方法中的逻辑，可是，一旦LineItem类构建好了，描述符与托管属性之间的绑定就不会变了。因此，我们要在创建类时设置储存属性的名称。使用类装饰器或元类可以做到这一点。</p><p>类装饰器与函数装饰器非常类似，是参数为类对象的函数，返回原来的类或修改后的类。</p><figure class="highlight python"><figcaption><span>model_v5.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoStorage</span>:</span></span><br><span class="line">    __counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        cls = self.__class__</span><br><span class="line">        prefix = cls.__name__</span><br><span class="line">        index = cls.__counter</span><br><span class="line">        self.storage_name = <span class="string">'_&#123;&#125;#&#123;&#125;'</span>.format(prefix, index)</span><br><span class="line">        cls.__counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> getattr(instance, self.storage_name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        setattr(instance, self.storage_name, value)  <span class="comment"># 无验证</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Validate</span><span class="params">(abc.ABC, AutoStorage)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        value = self.validate(instance, value)  <span class="comment"># 委托validate方法</span></span><br><span class="line">        super().__set__(instance, value)  <span class="comment"># 然后把返回的value传给超类的__set__方法，存储值</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, instance, value)</span>:</span>  <span class="comment"># 抽象方法</span></span><br><span class="line">        <span class="string">"""return validated value or raise ValueError"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span><span class="params">(Validate)</span>:</span></span><br><span class="line">    <span class="string">"""a number greater than zero"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonBlank</span><span class="params">(Validate)</span>:</span></span><br><span class="line">    <span class="string">"""a string with at least one non-space character"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        value = value.strip()</span><br><span class="line">        <span class="keyword">if</span> len(value) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value cannot be empty or blank'</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>model_v6.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> model_v5 <span class="keyword">import</span> Validate, Quantity, NonBlank</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">entity</span><span class="params">(cls)</span>:</span>  <span class="comment"># 参数是一个类</span></span><br><span class="line">    <span class="keyword">for</span> key, attr <span class="keyword">in</span> cls.__dict__.items():</span><br><span class="line">        <span class="keyword">if</span> isinstance(attr, Validate):</span><br><span class="line">            type_name = type(attr).__name__</span><br><span class="line">            <span class="comment"># 使用描述符类的名称和托管属性的名称命名storage_name</span></span><br><span class="line">            attr.storage_name = <span class="string">'_&#123;&#125;#&#123;&#125;'</span>.format(type_name, key)</span><br><span class="line">    <span class="keyword">return</span> cls  <span class="comment"># 返回修改后的类</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>bulkfood_v6.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> model_v6 <span class="keyword">as</span> model</span><br><span class="line"></span><br><span class="line"><span class="meta">@model.entity  # LineItem类唯一的变化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">    description = model.NonBlank()</span><br><span class="line">    weight = model.Quantity()</span><br><span class="line">    price = model.Quantity()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, price)</span>:</span></span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> bulkfood_v6 <span class="keyword">import</span> LineItem</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>raisins = LineItem(<span class="string">'Golden raisins'</span>, <span class="number">10</span>, <span class="number">6.95</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(raisins)[:<span class="number">3</span>]</span><br><span class="line">[<span class="string">'_NonBlank#description'</span>, <span class="string">'_Quantity#price'</span>, <span class="string">'_Quantity#weight'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>LineItem.description.storage_name</span><br><span class="line"><span class="string">'_NonBlank#description'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>raisins.description</span><br><span class="line"><span class="string">'Golden raisins'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(raisins, <span class="string">'_NonBlank#description'</span>)</span><br><span class="line"><span class="string">'Golden raisins'</span></span><br></pre></td></tr></table></figure><p>类装饰器能以比较简单的方式做到以前需要使用元类去做的事情——创建类时定制类。<strong>类装饰器有个重大缺点：只对直接依附的类有效。这意味着，被装饰的类的子类可能继承也可能不继承装饰器所做的改动，具体情况视改动的方式而定。</strong>接下来会探讨这个问题，并给出解决方案。</p><h1 id="导入时和运行时比较">导入时和运行时比较</h1><p>为了正确地做元编程，你必须知道Python解释器什么时候计算各个代码块。Python程序员会区分“导入时”和“运行时”，不过这两个术语没有严格的定义，而且二者之间存在着灰色地带。在导入时，解释器会从上到下一次性解析完模块的源码，然后生成用于执行的字节码。如果句法有错误，就在此时报告。如果本地的文件夹中有<code>__pycache__</code>文件夹中有最新的.pyc文件，解释器会跳过上述步骤，因为已经有运行所需的字节码了。</p><p>编译肯定是导入时的活动，不过那个时期还会做其他事，因为Python中的语句几乎都是可执行的，也就是说语句可能会运行用户代码，修改用户程序的状态。尤其是import语句，它不只是声明（Java中的import语句则只是声明，用于告知编辑器需要特定的包），在进程中首次导入模块时，还会运行所导入模块中的全部顶层代码——以后导入相同的模块则使用缓存，只做名称绑定。哪些顶层代码可以做任何事，包括通常在“运行时”做的事，例如连接数据库（虽然不应该这么做，但是可以做到）。因此，“导入时”和“运行时”之间的界限是模糊的：import语句可以触发任何“运行时”行为。</p><p>导入时会”运行全部顶层代码“，但是”顶层代码”会经过一些加工。导入模块时，解释器会执行顶层的def语句，解释器会编译函数的定义体（首次导入模块时），把函数对象绑定到对应的全局名称上，但是显然解释器不会执行函数的定义体。通常这意味着解释器在导入时定义顶层函数，但是仅当在运行时调用函数时才会执行函数的定义体。</p><p>对类来说，情况就不同了：在导入时，解释器会执行每个类的定义体，甚至会执行嵌套类的定义体。执行类定义体的结果是，定义了类的属性和方法，并构建了类的对象。从这个意义上理解，类的定义体属于”顶层代码“，因为它在导入时运行。</p><p>下面的示例帮助我们理解“导入时”和“运行时”的区别。</p><figure class="highlight python"><figcaption><span>evaltime.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> evalsupport <span class="keyword">import</span> deco_alpha</span><br><span class="line"></span><br><span class="line">print(<span class="string">'&lt;[1]&gt; evaltime module start'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassOne</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[2]&gt; ClassOne body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[3]&gt; ClassOne.__init__'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[4]&gt; ClassOne.__del__'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_x</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[5]&gt; ClassOne.method_x'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ClassTwo</span><span class="params">(object)</span>:</span></span><br><span class="line">            print(<span class="string">'&lt;[6]&gt; ClassTwo body'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@deco_alpha</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassThree</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[7]&gt; ClassThree body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_y</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[8]&gt; ClassThree.method_y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassFour</span><span class="params">(ClassThree)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[9]&gt; ClassFour body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_y</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[10]&gt; ClassFour.method_y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'&lt;[11]&gt; ClassOne tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    one = ClassOne()</span><br><span class="line">    one.method_x()</span><br><span class="line">    print(<span class="string">'&lt;[12]&gt; ClassThree tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    three = ClassThree()</span><br><span class="line">    three.method_y()</span><br><span class="line">    print(<span class="string">'&lt;[13]&gt; ClassFour tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    four = ClassFour()</span><br><span class="line">    four.method_y()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'&lt;[14]&gt; evaltime module end'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>evalsupport.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># evaltime.py导入的模块</span></span><br><span class="line">print(<span class="string">'&lt;[100]&gt; evalsupport module start'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco_alpha</span><span class="params">(cls)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[200]&gt; deco_alpha'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_1</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[300]&gt; deco_alpha:inner_1'</span>)</span><br><span class="line"></span><br><span class="line">    cls.method_y = inner_1</span><br><span class="line">    <span class="keyword">return</span> cls</span><br><span class="line"></span><br><span class="line"><span class="comment"># BEGIN META_ALEPH</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MetaAleph</span><span class="params">(type)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[400]&gt; MetaAleph body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, name, bases, dic)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[500]&gt; MetaAleph.__init__'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner_2</span><span class="params">(self)</span>:</span></span><br><span class="line">            print(<span class="string">'&lt;[600]&gt; MetaAleph.__init__:inner_2'</span>)</span><br><span class="line"></span><br><span class="line">        cls.method_z = inner_2</span><br><span class="line"><span class="comment"># END META_ALEPH</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'&lt;[700]&gt; evalsupport module end'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> evaltime  <span class="comment"># 导入模块</span></span><br><span class="line">&lt;[<span class="number">100</span>]&gt; evalsupport module start  <span class="comment"># evalsupport模块的所有顶层代码在导入时运行</span></span><br><span class="line">&lt;[<span class="number">400</span>]&gt; MetaAleph body</span><br><span class="line">&lt;[<span class="number">700</span>]&gt; evalsupport module end</span><br><span class="line">&lt;[<span class="number">1</span>]&gt; evaltime module start</span><br><span class="line">&lt;[<span class="number">2</span>]&gt; ClassOne body</span><br><span class="line">&lt;[<span class="number">6</span>]&gt; ClassTwo body  <span class="comment"># 嵌套的函数定义体也会执行</span></span><br><span class="line">&lt;[<span class="number">7</span>]&gt; ClassThree body</span><br><span class="line">&lt;[<span class="number">200</span>]&gt; deco_alpha</span><br><span class="line">&lt;[<span class="number">9</span>]&gt; ClassFour body</span><br><span class="line">&lt;[<span class="number">14</span>]&gt; evaltime module end</span><br></pre></td></tr></table></figure><p>对于第一个示例，要注意以下几点：</p><ol type="1"><li>这个场景由简单的import evaltime语句触发。</li><li>解释器会执行所导入模块及其依赖中的每个类定义体。</li><li>解释器先计算类的定义体，然后调用依附在类上的装饰器函数，这是合理的行为，因为必须先构建对象，装饰器才有类对象可处理。</li><li>在这个场景中，只运行了一个用户定义的函数或方法——deco_alpha装饰器。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ python evaltime.py</span><br><span class="line">&lt;[<span class="number">100</span>]&gt; evalsupport module start</span><br><span class="line">&lt;[<span class="number">400</span>]&gt; MetaAleph body</span><br><span class="line">&lt;[<span class="number">700</span>]&gt; evalsupport module end</span><br><span class="line">&lt;[<span class="number">1</span>]&gt; evaltime module start</span><br><span class="line">&lt;[<span class="number">2</span>]&gt; ClassOne body</span><br><span class="line">&lt;[<span class="number">6</span>]&gt; ClassTwo body</span><br><span class="line">&lt;[<span class="number">7</span>]&gt; ClassThree body</span><br><span class="line">&lt;[<span class="number">200</span>]&gt; deco_alpha</span><br><span class="line">&lt;[<span class="number">9</span>]&gt; ClassFour body</span><br><span class="line">&lt;[<span class="number">11</span>]&gt; ClassOne tests ..............................</span><br><span class="line">&lt;[<span class="number">3</span>]&gt; ClassOne.__init__</span><br><span class="line">&lt;[<span class="number">5</span>]&gt; ClassOne.method_x</span><br><span class="line">&lt;[<span class="number">12</span>]&gt; ClassThree tests ..............................</span><br><span class="line">&lt;[<span class="number">300</span>]&gt; deco_alpha:inner_1</span><br><span class="line">&lt;[<span class="number">13</span>]&gt; ClassFour tests ..............................</span><br><span class="line">&lt;[<span class="number">10</span>]&gt; ClassFour.method_y</span><br><span class="line">&lt;[<span class="number">14</span>]&gt; evaltime module end</span><br><span class="line">&lt;[<span class="number">4</span>]&gt; ClassOne.__del__  <span class="comment"># 程序结束时，绑定在全局变量one上的ClassOne实例才会被垃圾回收程序回收</span></span><br></pre></td></tr></table></figure><p>第二个示例主要想说明的是，类装饰器可能对子类没有影响。我们把ClassFour定义为ClassThree的子类。ClassThree类上依附的<code>@deco_alpha</code>装饰器把<code>method_y</code>方法替换掉了，但是这对ClassFour类根本没有影响。当然，如果<code>ClassFour.method_y</code>方法使用super调用<code>ClassThree.method_y</code>方法，我们便会看到装饰器起作用，执行<code>inner_1</code>函数。</p><p>与此不同的是，如果想定制整个类层次结构，而不是一次只制定一个类，使用元类更高效。</p><h1 id="元类基础知识">元类基础知识</h1><p>元类是制造类的工厂，不过不是函数，而是类。根据Python对象模型，类是对象，因此类肯定是另外某个类的实例。默认情况下，Python中类是type类的实例。也就是说，type是大多数内置的类和用户定义的类的元类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'spam'</span>.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">str</span>.<span class="title">__class__</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">type</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">from</span> <span class="title">bulkfood_v6</span> <span class="title">import</span> <span class="title">LineItem</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">LineItem</span>.<span class="title">__class__</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">type</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span>.<span class="title">__class__</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">type</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>注意，我没有说str和LineItem继承自type。我的意思是，str和LineItem是type的实例。这两个类是object的子类。下图可能有助于你理清这个奇怪的现象。</p> <img src="http://www.plantuml.com/plantuml/svg/NOn12eCm50Ntdk9TuES09MGlz18nVM9AVnJpDuA7hqGArUKCp4pvHL0Nsw3KWMkNFh5MsBOGtYijDX52rvJ87Z0FRoOxXNVkpWxLrZzwviBUg7WSnrognPA8UJoUPmc_YqYhBk8NVW40"><p>object类和type类之间的关系很独特：object是type的实例，而type是object的子类。这种关系很“神奇”，无法使用Python代码表述，因为定义其中一个之前另一个必须存在。type是自身的实例这一点也很神奇。</p><p>除了type，标准库中还有一些别的元类，例如ABCMeta和Enum。如下所示，Iterable所属的类是ABCMeta。Iterable是抽象类，而ABCMeta不是——不管怎样，Iterable是ABCMeta的实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> collections</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>collections.Iterable.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">abc</span>.<span class="title">ABCMeta</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">import</span> <span class="title">abc</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">abc</span>.<span class="title">ABCMeta</span>.<span class="title">__class__</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">type</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">abc</span>.<span class="title">ABCMeta</span>.<span class="title">__mro__</span></span></span><br><span class="line"><span class="class"><span class="params">(&lt;class <span class="string">'abc.ABCMeta'</span>&gt;, &lt;class <span class="string">'type'</span>&gt;, &lt;class <span class="string">'object'</span>&gt;)</span></span></span><br></pre></td></tr></table></figure><p>向上追溯，ABCMeta最终所属的类也是type。所有类都直接或间接地是type的实例，不过只有元类同时也是type的子类。<strong>若想理解元类，一定要知道这种关系：元类（如ABCMeta））从type继承了构建类的能力。</strong></p> <img src="http://www.plantuml.com/plantuml/svg/FOmn3eCm40Hxl-8-00-84598bIAFk3CRGOG1-Iu5KXuVOmFbhcPc67iGmceR1GH1T7vYLR9j1JLDW74-sjQng4NsHaz3P9dW2bJNjCW7texzgogwTuzNKkcM6lgLqbpUgLBGGbsX4zzRvvdTSLRZsIExVm00"><p>我们要抓住的重点是，<strong>所有类都是type的实例，但是元类还是type的子类</strong>，因此可以作为制造类的工厂。具体来说，元类可以通过实现<code>__init__</code>方法定制实例。元类的<code>__init__</code>方法可以做到类装饰器能做的任何事情，但是作用更大，如接下来的示例。</p><figure class="highlight python"><figcaption><span>evaltime_meta.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> evalsupport <span class="keyword">import</span> deco_alpha</span><br><span class="line"><span class="keyword">from</span> evalsupport <span class="keyword">import</span> MetaAleph</span><br><span class="line"></span><br><span class="line">print(<span class="string">'&lt;[1]&gt; evaltime_meta module start'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@deco_alpha</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassThree</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[2]&gt; ClassThree body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_y</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[3]&gt; ClassThree.method_y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassFour</span><span class="params">(ClassThree)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[4]&gt; ClassFour body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_y</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[5]&gt; ClassFour.method_y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassFive</span><span class="params">(metaclass=MetaAleph)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[6]&gt; ClassFive body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[7]&gt; ClassFive.__init__'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_z</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[8]&gt; ClassFive.method_y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassSix</span><span class="params">(ClassFive)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[9]&gt; ClassSix body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_z</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[10]&gt; ClassSix.method_y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'&lt;[11]&gt; ClassThree tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    three = ClassThree()</span><br><span class="line">    three.method_y()</span><br><span class="line">    print(<span class="string">'&lt;[12]&gt; ClassFour tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    four = ClassFour()</span><br><span class="line">    four.method_y()</span><br><span class="line">    print(<span class="string">'&lt;[13]&gt; ClassFive tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    five = ClassFive()</span><br><span class="line">    five.method_z()</span><br><span class="line">    print(<span class="string">'&lt;[14]&gt; ClassSix tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    six = ClassSix()</span><br><span class="line">    six.method_z()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'&lt;[15]&gt; evaltime_meta module end'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> evaltime_meta</span><br><span class="line">&lt;[<span class="number">100</span>]&gt; evalsupport module start</span><br><span class="line">&lt;[<span class="number">400</span>]&gt; MetaAleph body</span><br><span class="line">&lt;[<span class="number">700</span>]&gt; evalsupport module end</span><br><span class="line">&lt;[<span class="number">1</span>]&gt; evaltime_meta module start</span><br><span class="line">&lt;[<span class="number">2</span>]&gt; ClassThree body</span><br><span class="line">&lt;[<span class="number">200</span>]&gt; deco_alpha</span><br><span class="line">&lt;[<span class="number">4</span>]&gt; ClassFour body</span><br><span class="line">&lt;[<span class="number">6</span>]&gt; ClassFive body</span><br><span class="line">&lt;[<span class="number">500</span>]&gt; MetaAleph.__init__  <span class="comment"># 创建ClassFive时调用了MetaAleph.__init__方法</span></span><br><span class="line">&lt;[<span class="number">9</span>]&gt; ClassSix body</span><br><span class="line">&lt;[<span class="number">500</span>]&gt; MetaAleph.__init__  <span class="comment"># 创建ClassSix时也调用了</span></span><br><span class="line">&lt;[<span class="number">15</span>]&gt; evaltime_meta module end</span><br></pre></td></tr></table></figure><p>Python解释器计算ClassFive类的定义体时没有调用type构建具体的类定义体，而是调用MetaAleph类。<code>MetaAleph.__init__</code>方法有四个参数。</p><p>self：这是要初始化的类对象。编写元类时，通常会把self参数改为cls，表明要构建的实例是类。</p><p>name、bases、dict：与构建类时传给type的参数一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ python evaltime_meta.py</span><br><span class="line">&lt;[<span class="number">100</span>]&gt; evalsupport module start</span><br><span class="line">&lt;[<span class="number">400</span>]&gt; MetaAleph body</span><br><span class="line">&lt;[<span class="number">700</span>]&gt; evalsupport module end</span><br><span class="line">&lt;[<span class="number">1</span>]&gt; evaltime_meta module start</span><br><span class="line">&lt;[<span class="number">2</span>]&gt; ClassThree body</span><br><span class="line">&lt;[<span class="number">200</span>]&gt; deco_alpha</span><br><span class="line">&lt;[<span class="number">4</span>]&gt; ClassFour body</span><br><span class="line">&lt;[<span class="number">6</span>]&gt; ClassFive body</span><br><span class="line">&lt;[<span class="number">500</span>]&gt; MetaAleph.__init__</span><br><span class="line">&lt;[<span class="number">9</span>]&gt; ClassSix body</span><br><span class="line">&lt;[<span class="number">500</span>]&gt; MetaAleph.__init__</span><br><span class="line">&lt;[<span class="number">11</span>]&gt; ClassThree tests ..............................</span><br><span class="line">&lt;[<span class="number">300</span>]&gt; deco_alpha:inner_1  <span class="comment"># 装饰器依附到ClassThree类上之后，method_y方法被替换了</span></span><br><span class="line">&lt;[<span class="number">12</span>]&gt; ClassFour tests ..............................</span><br><span class="line">&lt;[<span class="number">5</span>]&gt; ClassFour.method_y  <span class="comment"># 虽然ClassFour是ClassThree的子类，但是没有依附装饰器，不受影响</span></span><br><span class="line">&lt;[<span class="number">13</span>]&gt; ClassFive tests ..............................</span><br><span class="line">&lt;[<span class="number">7</span>]&gt; ClassFive.__init__</span><br><span class="line">&lt;[<span class="number">600</span>]&gt; MetaAleph.__init__:inner_2  <span class="comment"># MetaAleph.__init__方法替换了ClassFive.method_z方法</span></span><br><span class="line">&lt;[<span class="number">14</span>]&gt; ClassSix tests ..............................</span><br><span class="line">&lt;[<span class="number">7</span>]&gt; ClassFive.__init__</span><br><span class="line">&lt;[<span class="number">600</span>]&gt; MetaAleph.__init__:inner_2  <span class="comment"># ClassSix.method_z方法也被替换了</span></span><br><span class="line">&lt;[<span class="number">15</span>]&gt; evaltime_meta module end</span><br></pre></td></tr></table></figure><p>注意，ClassSix类没有直接引用MetaAleph类，但是却受到了影响，因为它是ClassFive的子类，进而也是MetaAleph类的实例，所有由<code>MetaAleph.__init__</code>方法初始化。</p><p>如果想进一步定制类，可以在元类中实现<code>__new__</code>方法。不过，通常情况下实现<code>__init__</code>方法就够了。</p><h1 id="定制描述符的元类">定制描述符的元类</h1><p>现在，我们可以实践这些理论了。我们将创建一个元类，让描述符以最佳的方式自动创建储存属性的名称。</p><figure class="highlight python"><figcaption><span>model_v7.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> model_v5 <span class="keyword">import</span> Validate, Quantity, NonBlank</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EntityMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="string">"""元类，用于创建带有验证字段的业务实体"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, name, bases, attr_dict)</span>:</span></span><br><span class="line">        super().__init__(name, bases, attr_dict)  <span class="comment"># 调用type.__init__方法</span></span><br><span class="line">        <span class="keyword">for</span> key, attr <span class="keyword">in</span> attr_dict.items():  <span class="comment"># 修改storage_name，与@entity装饰器的逻辑一样</span></span><br><span class="line">            <span class="keyword">if</span> isinstance(attr, Validate):</span><br><span class="line">                type_name = type(attr).__name__</span><br><span class="line">                attr.storage_name = <span class="string">'_&#123;&#125;#&#123;&#125;'</span>.format(type_name, key)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span><span class="params">(metaclass=EntityMeta)</span>:</span>  <span class="comment"># 这个类只是为了用起来便利：用户直接继承Entity类即可</span></span><br><span class="line">    <span class="string">"""带有验证字段的业务实体"""</span>         <span class="comment"># 无需关心EntityMeta元类，甚至不需要知道它的存在</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>bulkfood_v7.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> model_v7 <span class="keyword">as</span> model</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span><span class="params">(model.Entity)</span>:</span>  <span class="comment"># 继承Entity类</span></span><br><span class="line">    description = model.NonBlank()</span><br><span class="line">    weight = model.Quantity()</span><br><span class="line">    price = model.Quantity()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, price)</span>:</span></span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br></pre></td></tr></table></figure> <img src="http://www.plantuml.com/plantuml/svg/bL71QeGm5BpdAm9xAyr-G16XXHuAtK8fz1go-ggX9X7pR2dgl_TLZRfg2_La9ZFptanodG87K-8NDs3EKB6aKDxpsnhT2xfAPS2ZA0MVLBgaSnppXd7wf4nSRP44FoS_KALL1dgWCO2vIplYQQjHoZMQmGxeUx1ZwkonKWdoLrNeL26a-qjif1TW4smw_Z7waFUGxxbM5ZMb_jjtetjozgvGzft_L_YeBJmWc51VC3e45-tiS1DMEto2pd9SWMMbazyg3hFkU-e9KD6Mn58zlDVQ9BnuxrRCnRF54xH2JCMjyP27pSqASJN7lg5fGo0fh-c_pq6ZfqAtz4KpH9okH5sADXv3icNMut54IHv5sdfKDW7ktkBu6m00"><h1 id="元类的特殊方法__prepare__">元类的特殊方法<code>__prepare__</code></h1><p>在某些应用中，可能需要知道类的属性定义的顺序。例如，对读写CSV文件的库来说，用户定义的类可能想把类中按顺序声明的字段与CSV文件中各列的顺序对应起来。</p><p>type构造方法及元类的<code>__new__</code>和<code>__init__</code>方法都会收到要计算的类的定义体，形式是名称到属性的映像。然而在默认情况下，那个映射是字典；也就是说，元类或装饰器获得映像时，属性在类定义体中的顺序已经丢失了。</p><p>这个问题的解决方法是，使用Python3引入的特殊方法<code>__prepare__</code>。这个特殊方法只在元类中有用，而且必须声明为类方法（即，要使用@classmethod装饰器定义）。解释器调用元类的<code>__new__</code>方法之前会先调用<code>__prepare__</code>方法，使用类定义体中的属性创建映射。<code>__prepare__</code>方法的第一个参数是元类，随后两个参数分别是要构建的类的映射和基类组成的元组，返回值必须是映射。元类构建新类时，<code>__prepare__</code>方法返回的映射会传给<code>__new__</code>方法的最后一个参数，然后再传给<code>__init__</code>方法。</p><p>理论听起来很复杂，但是我见过的<code>__prepare__</code>方法都十分简单。</p><figure class="highlight python"><figcaption><span>model_v8.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> model_v5 <span class="keyword">import</span> Validate, Quantity, NonBlank</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EntityMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="string">"""元类，用于创建带有验证字段的业务实体"""</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__prepare__</span><span class="params">(cls, name, bases)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> collections.OrderedDict()  <span class="comment"># 返回空的OrderDict实例</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, name, bases, attr_dict)</span>:</span>  <span class="comment"># OrderedDict实例会绑定到attr_dict上</span></span><br><span class="line">        super().__init__(name, bases, attr_dict)</span><br><span class="line">        cls._field_names = []  <span class="comment"># 在要构建的类中创建一个_field_names属性</span></span><br><span class="line">        <span class="keyword">for</span> key, attr <span class="keyword">in</span> attr_dict.items():  <span class="comment"># 因此for循环迭代attr_dict时会按添加的顺序迭代</span></span><br><span class="line">            <span class="keyword">if</span> isinstance(attr, Validate):</span><br><span class="line">                type_name = type(attr).__name__</span><br><span class="line">                attr.storage_name = <span class="string">'_&#123;&#125;#&#123;&#125;'</span>.format(type_name, key)</span><br><span class="line">                cls._field_names.append(key)  <span class="comment"># 把各个Validate字段添加到_field_names</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span><span class="params">(metaclass=EntityMeta)</span>:</span></span><br><span class="line">    <span class="string">"""带有验证字段的业务实体"""</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">field_names</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> cls._field_names:</span><br><span class="line">            <span class="keyword">yield</span> name</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>bulkfood_v8.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> model_v8 <span class="keyword">as</span> model  <span class="comment"># 从v8中导入，其他不变</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span><span class="params">(model.Entity)</span>:</span></span><br><span class="line">    description = model.NonBlank()</span><br><span class="line">    weight = model.Quantity()</span><br><span class="line">    price = model.Quantity()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, price)</span>:</span></span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> bulkfood_v8 <span class="keyword">import</span> LineItem</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name <span class="keyword">in</span> LineItem.field_names():</span><br><span class="line"><span class="meta">... </span>    print(name)</span><br><span class="line">...</span><br><span class="line">description</span><br><span class="line">weight</span><br><span class="line">price</span><br></pre></td></tr></table></figure><p>在现实世界中，框架和库会使用元类协助程序员执行很多任务，例如：</p><ul><li>验证属性</li><li>一次把装饰器依附到多个类上</li><li>序列化对象或转换数据</li><li>对象关系映射</li><li>基于对象的持久存储</li><li>动态转换使用其他语言编写的类结构</li></ul><h1 id="类作为对象">类作为对象</h1><p>Python数据模型为每个类定义了很多属性，其中三个属性在本书中已经见过多次：<code>__mro__</code>、<code>__class__</code>和<code>__name__</code>。此外，还有以下属性。</p><ul><li><p><code>cls.__bases__</code></p><p>由类的基类组成的元组。</p></li><li><p><code>cls.__qualname__</code></p><p>Python3.3新引入的属性，其值是类或函数的限定名称，即从模块的全局作用域到类的点分路径。</p></li><li><p><code>cls.__subclasses__()</code></p><p>这个方法返回一个列表，包含类的直接子类。这个方法的实现使用弱引用，防止在超类和子类之间出现循环引用（子类在<code>__bases__</code>属性中存储指向超类的强引用）。这个方法返回的列表中是内存里现存的子类。</p></li><li><p><code>cls.mro()</code></p><p>构建类时，如果需要获取存储在类属性<code>__mro__</code>中的超类元组，解释器会调用这个方法。元类可以覆盖这个方法，定制要构建的类解析方法的顺序。</p></li></ul><p>dir函数不会列出本节提到的任何一个属性。</p></div><div class="popular-posts-header">相关文章</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/fluent-python/attribute-descriptors/" rel="bookmark">属性描述符</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/fluent-python/a-pythonic-object/" rel="bookmark">符合Python风格的对象</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/fluent-python/abc-s-in-standard-library/" rel="bookmark">标准库中的抽象基类</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/fluent-python/concurrency-with-futures/" rel="bookmark">使用futures处理并发</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/fluent-python/context-managers-and-else-blocks/" rel="bookmark">上下文管理器和else块</a></div></li></ul><footer class="post-footer"><div class="post-tags"> <a href="/tags/Fluent-Python/" rel="tag"># Fluent Python</a> <a href="/tags/metaprogramming/" rel="tag"># metaprogramming</a></div><div class="post-nav"><div class="post-nav-item"><a href="/notes/fluent-python/attribute-descriptors/" rel="prev" title="属性描述符"><i class="fa fa-chevron-left"></i> 属性描述符</a></div><div class="post-nav-item"> <a href="/notes/introduction-to-ml-with-python/supervised-learning/" rel="next" title="监督学习">监督学习<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><div class="comments" id="valine-comments"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#类工厂函数"><span class="nav-number">1.</span> <span class="nav-text">类工厂函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#定制描述符的类装饰器"><span class="nav-number">2.</span> <span class="nav-text">定制描述符的类装饰器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#导入时和运行时比较"><span class="nav-number">3.</span> <span class="nav-text">导入时和运行时比较</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#元类基础知识"><span class="nav-number">4.</span> <span class="nav-text">元类基础知识</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#定制描述符的元类"><span class="nav-number">5.</span> <span class="nav-text">定制描述符的元类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#元类的特殊方法__prepare__"><span class="nav-number">6.</span> <span class="nav-text">元类的特殊方法__prepare__</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类作为对象"><span class="nav-number">7.</span> <span class="nav-text">类作为对象</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Chen" src="/uploads/avatar/nekosensei.png"><p class="site-author-name" itemprop="name">Chen</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">83</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">10</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">116</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="cc-license motion-element" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Chen</span></div><script src="//cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script><script>
window.addEventListener('pjax:send', () => {
    if (window.aplayers) {
        for (let i = 0; i < window.aplayers.length; i++) {
            window.aplayers[i].list.clear();
            window.aplayers[i].destroy();
        }
        window.aplayers = [];
    }
});
</script></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      script.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script><script src="/js/local-search.js"></script><div id="pjax"><script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Axl15EIRi5o5AatKaxXxV4Oq-gzGzoHsz',
      appKey     : 'E0qm04UjsP0qQN1l8ME3GQ25',
      placeholder: "Just go go",
      avatar     : 'identicon',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script></div></body></html>