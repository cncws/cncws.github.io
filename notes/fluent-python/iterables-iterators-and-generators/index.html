<!DOCTYPE html><html lang="zh-CN,en,default"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/uploads/icon/drop/128x128.png"><link rel="icon" type="image/png" sizes="32x32" href="/uploads/icon/drop/32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/uploads/icon/drop/16x16.png"><link rel="mask-icon" href="/uploads/icon/drop/drop.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"cwscn.github.io",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1,width:240},copycode:{enable:!0,show_result:!0,style:"flat"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"manual"},fancybox:!1,mediumzoom:!0,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"fadeIn"}},path:"search.xml"}</script><meta name="description" content="Sentence类第1版：单词序列 sentence.pyimport reimport reprlibRE_WORD = re.compile(&apos;\w+&apos;)class Sentence:    def __init__(self, text):        self.text = text        self.words = RE_WORD.findall(text)  # 返回全部菲重叠"><meta name="keywords" content="Fluent Python,generators,iterables,iterators"><meta property="og:type" content="article"><meta property="og:title" content="可迭代对象、迭代器和生成器"><meta property="og:url" content="https://cwscn.github.io/notes/fluent-python/iterables-iterators-and-generators/index.html"><meta property="og:site_name" content="水滴"><meta property="og:description" content="Sentence类第1版：单词序列 sentence.pyimport reimport reprlibRE_WORD = re.compile(&apos;\w+&apos;)class Sentence:    def __init__(self, text):        self.text = text        self.words = RE_WORD.findall(text)  # 返回全部菲重叠"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYIamgBYbAJ2vHy2n9BKfCoabLgEPI089gc4IjGdLkQab6VagjGdny9b1HV3nNBPgsalmYlDhoKYjAWDh02h0ObfTVagfGb9cUKQAGdmPt25ZvqzRjJ_PEVZwh1IQgLmVJ-6pQpcURfq9KxPhoOltI5_kdF9qzxycEXYSxLi6SzNJTl2VxkhbIyr8KGBPWimge2cn8IcgQ0jnmZUBKd3HDAx0421IbbfGMvIc0H1KKb1KWLa4CVpPdpOjTgn5Mm0FIfaPN5s45N5XFJyyE4MnM2i_cjJpTlGi0"><meta property="og:updated_time" content="2020-01-19T12:58:34.589Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="可迭代对象、迭代器和生成器"><meta name="twitter:description" content="Sentence类第1版：单词序列 sentence.pyimport reimport reprlibRE_WORD = re.compile(&apos;\w+&apos;)class Sentence:    def __init__(self, text):        self.text = text        self.words = RE_WORD.findall(text)  # 返回全部菲重叠"><meta name="twitter:image" content="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYIamgBYbAJ2vHy2n9BKfCoabLgEPI089gc4IjGdLkQab6VagjGdny9b1HV3nNBPgsalmYlDhoKYjAWDh02h0ObfTVagfGb9cUKQAGdmPt25ZvqzRjJ_PEVZwh1IQgLmVJ-6pQpcURfq9KxPhoOltI5_kdF9qzxycEXYSxLi6SzNJTl2VxkhbIyr8KGBPWimge2cn8IcgQ0jnmZUBKd3HDAx0421IbbfGMvIc0H1KKb1KWLa4CVpPdpOjTgn5Mm0FIfaPN5s45N5XFJyyE4MnM2i_cjJpTlGi0"><link rel="canonical" href="https://cwscn.github.io/notes/fluent-python/iterables-iterators-and-generators/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css"><link rel="stylesheet" href="//unpkg.com/video.js/dist/video-js.min.css"><link rel="stylesheet" href="/css/videojs-bilibili.css"><style>.aplayer.aplayer-arrow .aplayer-icon-loop,.aplayer.aplayer-arrow .aplayer-icon-order{display:inline-block}</style><title>可迭代对象、迭代器和生成器 | 水滴</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">水滴</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">愿你走出半生 归来仍是少年</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档<span class="badge">132</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类<span class="badge">11</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签<span class="badge">135</span></a></li><li class="menu-item menu-item-收藏"><a href="/favlist/" rel="section"><i class="fa fa-star fa-fw"></i> 收藏</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div><meting-js server="netease" type="playlist" id="67155774" theme="#ffafc9" loop="all" order="list" preload="none" volume="" list-folded="NaN" fixed="true"></meting-js></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwscn.github.io/notes/fluent-python/iterables-iterators-and-generators/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar/nekosensei.png"><meta itemprop="name" content="菜农陈文生"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="水滴"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 可迭代对象、迭代器和生成器</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-01-19 20:58:34" itemprop="dateModified" datetime="2020-01-19T20:58:34+08:00">2020-01-19</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/notes/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/notes/fluent-python/iterables-iterators-and-generators/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/notes/fluent-python/iterables-iterators-and-generators/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="sentence类第1版单词序列">Sentence类第1版：单词序列</h1><figure class="highlight python"><figcaption><span>sentence.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">        self.words = RE_WORD.findall(text)  <span class="comment"># 返回全部菲重叠匹配</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.words[index]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.words)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Sentence(%s)'</span> % reprlib.repr(self.text)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sentence <span class="keyword">import</span> Sentence</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Sentence(<span class="string">'"The time has come," the Walrus said,'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">Sentence(<span class="string">'"The time ha... Walrus said,'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(s)  <span class="comment"># Sentence实例是可迭代的，因此可以用于构建列表和其他可迭代的类型</span></span><br><span class="line">[<span class="string">'The'</span>, <span class="string">'time'</span>, <span class="string">'has'</span>, <span class="string">'come'</span>, <span class="string">'the'</span>, <span class="string">'Walrus'</span>, <span class="string">'said'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(s, abc.Iterable)  <span class="comment"># 虽然可以迭代，但无法通过isinstance检测</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(Sentence, abc.Iterable)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>解释器需要迭代对象x时，会自动调用iter(x)。内置的iter函数有以下作用。</p><ol type="1"><li>检查对象是否实现了<code>__iter__</code>方法，如果实现了就调用它，获取一个迭代器。</li><li>如果没有实现<code>__iter__</code>方法，但是实现了<code>__getitem__</code>方法，Python会创建一个迭代器，尝试按顺序获取元素。</li><li>如果尝试失败，Python抛出TypeError异常，通常会提示“C object is not iterable”，其中C是目标对象所属的类。</li></ol><p>任何Python序列都可迭代的原因是，它们都实现了<code>__getitem__</code>方法。其实，标准的序列也都实现了<code>__iter__</code>方法，因此你也应该这么做。之所以对<code>__getitem__</code>方法做特殊处理，是为了向后兼容，而未来可能不会再这么做。</p><p>因为abc.Iterable类实现了<code>__subclasshook__</code>方法，该方法将定义了<code>__iter__</code>方法的类认作自己的虚拟子类。因此，虽然Sentence类可以迭代，但是无法通过issubclass(Sentence, abc.Iterable)测试。</p><p><strong>从Python3.4开始，检查对象x能否迭代，最准确的方法是：调用iter(x)函数，如果不可迭代，再处理TypeError异常。</strong>这比使用isinstance(x, abc.Iterable)更准确，因为iter(x)函数会考虑到遗留的<code>__getitem__</code>方法，而abc.Iterable类则不考虑。</p><h2 id="可迭代的对象与迭代器的对比">可迭代的对象与迭代器的对比</h2><p>可迭代的对象：使用iter内置函数可以获取迭代器的对象。如果对象实现了能返回迭代器的<code>__iter__</code>方法，那么对象就是可迭代的。序列都可以迭代；实现了<code>__getitem__</code>方法，而且其参数是从零开始的索引，这种对象也可以迭代。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> char <span class="keyword">in</span> s:  <span class="comment"># 使用for循环迭代，背后有迭代器，但是看不到</span></span><br><span class="line"><span class="meta">... </span>    print(char)</span><br><span class="line">...</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it = iter(s)  <span class="comment"># 使用迭代器迭代</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>        print(next(it))</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">except</span> StopIteration:  <span class="comment"># 迭代器到头</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">del</span> it  <span class="comment"># 释放引用</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">break</span></span><br><span class="line">...</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br></pre></td></tr></table></figure> <img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYIamgBYbAJ2vHy2n9BKfCoabLgEPI089gc4IjGdLkQab6VagjGdny9b1HV3nNBPgsalmYlDhoKYjAWDh02h0ObfTVagfGb9cUKQAGdmPt25ZvqzRjJ_PEVZwh1IQgLmVJ-6pQpcURfq9KxPhoOltI5_kdF9qzxycEXYSxLi6SzNJTl2VxkhbIyr8KGBPWimge2cn8IcgQ0jnmZUBKd3HDAx0421IbbfGMvIc0H1KKb1KWLa4CVpPdpOjTgn5Mm0FIfaPN5s45N5XFJyyE4MnM2i_cjJpTlGi0"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterator</span><span class="params">(Iterable)</span>:</span>  <span class="comment"># abc.Iterator类源码</span></span><br><span class="line"></span><br><span class="line">    __slots__ = ()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'Return the next item from the iterator. When exhausted, raise StopIteration'</span></span><br><span class="line">        <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__subclasshook__</span><span class="params">(cls, C)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">is</span> Iterator:</span><br><span class="line">            <span class="keyword">if</span> (any(<span class="string">"__next__"</span> <span class="keyword">in</span> B.__dict__ <span class="keyword">for</span> B <span class="keyword">in</span> C.__mro__) <span class="keyword">and</span></span><br><span class="line">                any(<span class="string">"__iter__"</span> <span class="keyword">in</span> B.__dict__ <span class="keyword">for</span> B <span class="keyword">in</span> C.__mro__)):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Sentence(<span class="string">'A B'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it = iter(s)  <span class="comment"># 获取迭代器</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)  <span class="comment"># 获取下一个单词</span></span><br><span class="line"><span class="string">'A'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)</span><br><span class="line"><span class="string">'B'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)  <span class="comment"># 迭代到头</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(it)  <span class="comment"># 迭代器空了</span></span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(iter(s))  <span class="comment"># 重新构建迭代器</span></span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'B'</span>]</span><br></pre></td></tr></table></figure><h1 id="sentence类第2版典型的迭代器">Sentence类第2版：典型的迭代器</h1><figure class="highlight python"><figcaption><span>sentence_iter.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span>  <span class="comment"># 使用迭代器模式实现Sentence类</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">        self.words = RW_WORD.findall(text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Sentence(%s)'</span> % reprlib.repr(self.text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span>  <span class="comment"># 实例化并返回一个迭代器</span></span><br><span class="line">        <span class="keyword">return</span> SentenceIterator(self.words)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SentenceIterator</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        self.words = words  <span class="comment"># 引用单词列表</span></span><br><span class="line">        self.index = <span class="number">0</span>  <span class="comment"># 下一个要获取的单词</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            word = self.words[index]  <span class="comment"># 获取索引位上的单词</span></span><br><span class="line">        <span class="keyword">except</span> IndexError:  <span class="comment"># 如果索引位上没有单词</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration()  <span class="comment"># 抛出StopIteration异常</span></span><br><span class="line">        self.index += <span class="number">1</span>  <span class="comment"># 递增索引</span></span><br><span class="line">        <span class="keyword">return</span> word  <span class="comment"># 返回单词</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span>  <span class="comment"># 迭代器应该一直可以迭代</span></span><br><span class="line">        <span class="keyword">return</span> self  <span class="comment"># 因此__iter__方法应该返回自身</span></span><br></pre></td></tr></table></figure><p>对这个示例来说，其实没必要在SentenceIterator类中实现<code>__iter__</code>方法，不过这么做是对的，因为迭代器应该实现<code>__next__</code>和<code>__iter__</code>两个方法，而且这么做能让迭代器通过<code>issubclass(SentenceIterator, abc.Iterator)</code>测试。如果让SentenceIterator类继承abc.Iterator类，那么它会继承<code>abc.Iterator.__iter__</code>这个具体方法。</p><h2 id="把sentence编程迭代器坏主意">把Sentence编程迭代器：坏主意</h2><p>构建可迭代的对象和迭代器时经常会出现错误，原因是混淆了二者。可迭代的对象有个<code>__iter__</code>方法，每次都实例化一个新的迭代器；而迭代器要实现<code>__next__</code>方法，返回单个元素，此外还要实现<code>__iter__</code>方法，返回迭代器本身。</p><p>除了<code>__iter__</code>方法之外，你可能还想在Sentence类中实现<code>__next__</code>方法，让Sentence实例既是可迭代的对象，也是自身的迭代器。可是，这种想法非常糟糕。</p><p>迭代器模式可用来：（出自《设计模式：可复用面向对象软件的基础》）</p><ul><li>访问一个聚合对象的内容而无需暴露它的内部表示</li><li>支持对聚合对象的多种遍历</li><li>为遍历不同的聚合结构提供一个同一的接口（既支持多态迭代）</li></ul><p>为了“支持多种遍历”，必须能从同一个可迭代的实例中获取多个独立的迭代器，而且各个迭代器要能维护自身的内部状态，因此这一模式正确的实现方式是，每次调用iter(my_iterable)都构建一个独立的迭代器。</p><h1 id="sentence类第3版生成器函数">Sentence类第3版：生成器函数</h1><p>用生成器函数代替SentenceIterator类。</p><figure class="highlight python"><figcaption><span>sentence_gen.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">        self.words = RE_WORD.findall(text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Sentence(%s)'</span> % reprlib.repr(self.text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> self.words:</span><br><span class="line">            <span class="keyword">yield</span> word  <span class="comment"># 产出当前的word</span></span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><code>__iter__</code>方法的return语句不是必要的；这个函数可以直接“落空”，自动返回。不管有没有return语句，生成器函数都不会抛出StopIteration异常，而是在生成完全部值之后直接退出。</p><h2 id="生成器函数的工作原理">生成器函数的工作原理</h2><p>只要Python函数的定义体中有yield关键字，该函数就是生成器函数。调用生成器函数时，会返回一个生成器对象。也就是说，生成器函数是生成器工厂。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span>  <span class="comment"># 只要包含关键字yield，该函数就是生成器函数</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'start'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">1</span>  <span class="comment"># 生成器函数的定义体中通常都有循环</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'continue'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">2</span>  <span class="comment"># 不过这不是必要条件</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'end'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen  <span class="comment"># 函数对象</span></span><br><span class="line">&lt;function gen at <span class="number">0x10094ec80</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen()  <span class="comment"># 调用时返回一个生成器对象</span></span><br><span class="line">&lt;generator object gen at <span class="number">0x10094dba0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> gen():</span><br><span class="line"><span class="meta">... </span>    print(i)</span><br><span class="line">...</span><br><span class="line">start</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">end</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = gen()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)  <span class="comment"># 第一次调用，会打印'start'，然后停在第一个yield语句</span></span><br><span class="line">start</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)  <span class="comment"># 第二次调用，打印'continue'，停在第二个yield语句</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)  <span class="comment"># 第三次调用，打印'end'，到达定义体末尾，抛出异常</span></span><br><span class="line">end</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><h1 id="sentence类第4版惰性实现">Sentence类第4版：惰性实现</h1><p>惰性求值（lazy evaluation）和及早求值（eager evaluation）是编程语言理论方面的技术用语。</p><p>目前实现的几版Sentence类都不够惰性，因为<code>__init__</code>方法急迫地构建好了文本中的单词列表，然后将其绑定到self.words属性上。这样就得处理整个文本，列表使用的内存量可能与文本本身一样多（获取更多，这取决于文本中有多少非单词字符）。如果只需迭代前几个单词，大多数工作都是白费力气。</p><p>只要使用Python3，思索着做某件事有没有懒惰的方式，答案通常都是肯定的。re.finditer函数是re.findall函数的惰性版本，返回一个生成器，按需生成re.MatchObject实例。如果有很多匹配，re.finditer函数能节省大量内存。</p><figure class="highlight python"><figcaption><span>sentence_gen2.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Sentence(%s)'</span> % reprlib.repr(self.text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> match <span class="keyword">in</span> RE_WORD.finditer(self.text):</span><br><span class="line">            <span class="keyword">yield</span> match.group()  <span class="comment"># 提取具体文本</span></span><br></pre></td></tr></table></figure><h1 id="sentence类第5版生成器表达式">Sentence类第5版：生成器表达式</h1><p>生成器表达式可以理解为列表推导的惰性版本：不会迫切地构建列表，而是返回一个生成器，按需惰性生成元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'yield 1'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'yield 2'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res1 = [x * <span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> gen()]  <span class="comment"># 列表推导</span></span><br><span class="line"><span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">yield</span> <span class="number">2</span>  <span class="comment"># gen函数全部运行</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res1</span><br><span class="line">[<span class="number">3</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res2 = (x * <span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> gen())  <span class="comment"># 生成器，gen函数没有运行，故没有任何输出</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res2</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x10094daf0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> res2:  <span class="comment"># 循环迭代res2时，gen函数才会真正执行</span></span><br><span class="line"><span class="meta">... </span>    print(i)</span><br><span class="line">...</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="keyword">yield</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>sentence_genexp.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Sentence(%s)'</span> % reprlib.repr(self.text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (match.group() <span class="keyword">for</span> match <span class="keyword">in</span> RE_WORD.finditer(self.text))</span><br></pre></td></tr></table></figure><p><code>__iter__</code>不是生成器函数了（没有yield），而是使用生成器表达式构建生成器，然后将其返回。不过，最终的效果一样：调用<code>__iter__</code>方法会得到一个生成器对象。生成器表达式是语法糖：完全可以替换成生成器函数，不过有时使用生成器表达式更便利。</p><h1 id="何时使用生成器表达式">何时使用生成器表达式</h1><p>生成器表达式是创建生成器的简洁句法，这样无需先定义函数再调用。不过生成器函数灵活得多，可以使用多个语句实现复杂的逻辑，也可以作为协程使用。</p><p>遇到简单的情况时，可以使用生成器表达式，因为这样扫一眼就知道代码的作用；如果生成器表达式要分成多行写，倾向于定义生成器函数，以便提高可读性。此外，生成器函数有名称，因此可以重用。</p><h1 id="另一个示例等差数列生成器">另一个示例：等差数列生成器</h1><p>典型的迭代器模式作用很简单——遍历数据结构。不过，即便不是从集合中获取元素，而是获取序列中即时生成的下一个值时，也用得到这种基于方法的标准接口。例如，内置的range函数用于生成有穷整数等差数列（Arithmetic Progression，AP），itertools.count函数用于生成无穷等差数列。</p><figure class="highlight python"><figcaption><span>arithmetic_progression.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArithmeticProgression</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, begin, step, end=None)</span>:</span></span><br><span class="line">        self.begin = begin</span><br><span class="line">        self.step = step</span><br><span class="line">        self.end = end  <span class="comment"># None -&gt; 无穷数列</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        result = type(self.begin + self.step)(self.begin)  <span class="comment"># 强制转换类型</span></span><br><span class="line">        forever = self.end <span class="keyword">is</span> <span class="literal">None</span>  <span class="comment"># 提高可读性</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> forever <span class="keyword">or</span> result &lt; self.end:</span><br><span class="line">            <span class="keyword">yield</span> result</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">            result = self.begin + self.step * index  <span class="comment"># 没有累加，为了降低处理浮点数时累积效应致错的风险</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> arithmetic_progression <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ap = ArithmeticProgression(<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>)  <span class="comment"># 整型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(ap)</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ap = ArithmeticProgression(<span class="number">1</span>, <span class="number">.5</span>, <span class="number">3</span>)  <span class="comment"># 浮点型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(ap)</span><br><span class="line">[<span class="number">1.0</span>, <span class="number">1.5</span>, <span class="number">2.0</span>, <span class="number">2.5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ap = ArithmeticProgression(<span class="number">0</span>, <span class="number">1</span>/<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(ap)</span><br><span class="line">[<span class="number">0.0</span>, <span class="number">0.3333333333333333</span>, <span class="number">0.6666666666666666</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ap = ArithmeticProgression(<span class="number">0</span>, Fraction(<span class="number">1</span>, <span class="number">3</span>), <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(ap)</span><br><span class="line">[Fraction(<span class="number">0</span>, <span class="number">1</span>), Fraction(<span class="number">1</span>, <span class="number">3</span>), Fraction(<span class="number">2</span>, <span class="number">3</span>)]  <span class="comment"># 第一个数被转换成了Fraction类型</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ap = ArithmeticProgression(<span class="number">0</span>, Decimal(<span class="string">'.1'</span>), <span class="number">.3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(ap)</span><br><span class="line">[Decimal(<span class="string">'0'</span>), Decimal(<span class="string">'0.1'</span>), Decimal(<span class="string">'0.2'</span>)]</span><br></pre></td></tr></table></figure><p>这个简单的示例，说明了如何使用生成器函数实现特殊的<code>__iter__</code>方法。然而，如果一个类只是为了构建生成器而去实现<code>__iter__</code>方法，那还不如使用生成器函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aritprog_gen</span><span class="params">(begin, step, end=None)</span>:</span></span><br><span class="line">    result = type(self.begin + self.step)(self.begin)</span><br><span class="line">    forever = self.end <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> forever <span class="keyword">or</span> result &lt; self.end:</span><br><span class="line">        <span class="keyword">yield</span> result</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">        result = self.begin + self.step * index</span><br></pre></td></tr></table></figure><h2 id="使用itertools模块生成等差数列">使用itertools模块生成等差数列</h2><p>Python3.4中的<a href="https://devdocs.io/python~3.6/library/itertools" target="_blank" rel="noopener">itertools</a>模块提供了19个生成器函数，结合起来使用能实现很多有趣的用法。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/itertools#itertools.count" target="_blank" rel="noopener"><code>itertools.count(start=0, step=1)</code></a></p><p>Make an iterator that returns evenly spaced values starting with number start. Often used as an argument to map() to generate consecutive data points. Also, used with zip() to add sequence numbers. Roughly equivalent to:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(start=<span class="number">0</span>, step=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="comment"># count(10) --&gt; 10 11 12 13 14 ...</span></span><br><span class="line">    <span class="comment"># count(2.5, 0.5) -&gt; 2.5 3.0 3.5 ...</span></span><br><span class="line">    n = start</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        n += step</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>When counting with floating point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: <code>(start + step * i for i in count())</code>.</p></blockquote><p>itertools.count函数返回的生成器能生成等差数列。然而，itertools.count函数从不停止。因此，如果调用list(count())，Python会创建一个特别大的列表，超出可用内存，在调用失败之前，电脑会疯狂地运转。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/itertools#itertools.takewhile" target="_blank" rel="noopener"><code>itertools.takewhile(predicate, iterable)</code></a></p><p>Make an iterator that returns elements from the iterable as long as the predicate is true. Roughly equivalent to:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">takewhile</span><span class="params">(predicate, iterable)</span>:</span></span><br><span class="line">    <span class="comment"># takewhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 1 4</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">if</span> predicate(x):</span><br><span class="line">            <span class="keyword">yield</span> x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure></blockquote><p>itertools.takewhile函数则不同，它会生成一个使用另一个生成器的生成器，在指定的条件计算结果为false时停止。因此，可以把这两个函数结合在一起使用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> itertools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen = itertools.takewhile(<span class="keyword">lambda</span> n: n &lt; <span class="number">3</span>, itertools.count(<span class="number">1</span>, <span class="number">.5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(gen)</span><br><span class="line">[<span class="number">1</span>, <span class="number">1.5</span>, <span class="number">2.0</span>, <span class="number">2.5</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aritprog_gen</span><span class="params">(begin, step, end=None)</span>:</span>  <span class="comment"># 利用已有的生成器实现</span></span><br><span class="line">    first = type(begin + step)(begin)</span><br><span class="line">    ap_gen = itertools.count(first, step)</span><br><span class="line">    <span class="keyword">if</span> end <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        ap_gen = itertools.takewhile(<span class="keyword">lambda</span> n: n &lt; end, ap_gen)</span><br><span class="line">    <span class="keyword">return</span> ap_gen</span><br></pre></td></tr></table></figure><h1 id="python3.3中新出现的句法yield-from">Python3.3中新出现的句法：yield from</h1><p>如果生成器函数需要产出另一个生成器生成的值，传统的解决方法是使用嵌套的for循环。例如，chain生成器的等价实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chain</span><span class="params">(*iterables)</span>:</span></span><br><span class="line">    <span class="comment"># chain('ABC', 'DEF') --&gt; A B C D E F</span></span><br><span class="line">    <span class="keyword">for</span> it <span class="keyword">in</span> iterables:</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> it:  <span class="comment"># 使用循环</span></span><br><span class="line">            <span class="keyword">yield</span> element</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chain</span><span class="params">(*iterables)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> it <span class="keyword">in</span> iterables:</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> it  <span class="comment"># 使用yield from</span></span><br></pre></td></tr></table></figure><p>在这个示例中使用yield from是对的，而且代码读起来更顺畅，不过感觉更像是语法糖。除了代替循环之外，yield from还会创建通道，把内层生成器直接与外层生成器的客户端联系起来。把生成器当成协程使用时，这个通道特别重要，不仅能为客户端代码生成值，还能使用客户端提供的值。</p><h1 id="深入分析iter函数">深入分析iter函数</h1><p>在Python中迭代对象x时会调用iter(x)。可是，iter函数还有一个鲜为人知的用法：传入两个参数，使用常规的函数或任何可调用的对象创建迭代器。这样使用时，第一个参数必须是可调用的对象，用于不断调用（没有参数），产出各个值。第二个值是哨符，这是个标记值，当可调用的对象返回这个值时，触发迭代器抛出StopIteration异常，而不产出哨符。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/functions#iter" target="_blank" rel="noopener"><code>iter(object[, sentinel])</code></a></p><p>Return an iterator object. The first argument is interpreted very differently depending on the presence of the second argument. Without a second argument, object must be a collection object which supports the iteration protocol (the <code>__iter__()</code> method), or it must support the sequence protocol (the <code>__getitem__()</code> method with integer arguments starting at 0). If it does not support either of those protocols, TypeError is raised. If the second argument, sentinel, is given, then object must be a callable object. The iterator created in this case will call object with no arguments for each call to its <code>__next__()</code> method; if the value returned is equal to sentinel, StopIteration will be raised, otherwise the value will be returned.</p><p>One useful application of the second form of iter() is to read lines of a file until a certain line is reached. The following example reads a file until the readline() method returns an empty string:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'mydata.txt'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> iter(fp.readline, <span class="string">''</span>):  <span class="comment"># 逐行读取文件，直到遇到空行或者到达文件末尾</span></span><br><span class="line">        process_line(line)</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">d6</span><span class="params">()</span>:</span>  <span class="comment"># 掷骰子</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> randint(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d6_iter = iter(d6, <span class="number">1</span>)  <span class="comment"># 掷到1为止，但不会产出1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d6_iter  <span class="comment"># 返回的是一个callable_iterator对象</span></span><br><span class="line">&lt;callable_iterator object at <span class="number">0x101472e10</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> roll <span class="keyword">in</span> d6_iter:</span><br><span class="line"><span class="meta">... </span>    print(roll)</span><br><span class="line">...</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(d6_iter)  <span class="comment"># 与常规迭代器一样，一旦耗尽就没用了，想重新开始，必须再次创建</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure></div><div class="popular-posts-header">相关文章</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/fluent-python/generator-functions-in-standard-library/" rel="bookmark">标准库中的生成器函数</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/fluent-python/a-pythonic-object/" rel="bookmark">符合Python风格的对象</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/fluent-python/abc-s-in-standard-library/" rel="bookmark">标准库中的抽象基类</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/fluent-python/class-metaprogramming/" rel="bookmark">类元编程</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/notes/fluent-python/concurrency-with-asyncio/" rel="bookmark">使用asyncio包处理并发</a></div></li></ul><footer class="post-footer"><div class="post-tags"> <a href="/tags/Fluent-Python/" rel="tag"># Fluent Python</a> <a href="/tags/generators/" rel="tag"># generators</a> <a href="/tags/iterables/" rel="tag"># iterables</a> <a href="/tags/iterators/" rel="tag"># iterators</a></div><div class="post-nav"><div class="post-nav-item"><a href="/notes/fluent-python/operator-overloading/" rel="prev" title="运算符重载"><i class="fa fa-chevron-left"></i> 运算符重载</a></div><div class="post-nav-item"> <a href="/notes/fluent-python/generator-functions-in-standard-library/" rel="next" title="标准库中的生成器函数">标准库中的生成器函数<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#sentence类第1版单词序列"><span class="nav-number">1.</span> <span class="nav-text">Sentence类第1版：单词序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#可迭代的对象与迭代器的对比"><span class="nav-number">1.1.</span> <span class="nav-text">可迭代的对象与迭代器的对比</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sentence类第2版典型的迭代器"><span class="nav-number">2.</span> <span class="nav-text">Sentence类第2版：典型的迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#把sentence编程迭代器坏主意"><span class="nav-number">2.1.</span> <span class="nav-text">把Sentence编程迭代器：坏主意</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sentence类第3版生成器函数"><span class="nav-number">3.</span> <span class="nav-text">Sentence类第3版：生成器函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#生成器函数的工作原理"><span class="nav-number">3.1.</span> <span class="nav-text">生成器函数的工作原理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sentence类第4版惰性实现"><span class="nav-number">4.</span> <span class="nav-text">Sentence类第4版：惰性实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sentence类第5版生成器表达式"><span class="nav-number">5.</span> <span class="nav-text">Sentence类第5版：生成器表达式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#何时使用生成器表达式"><span class="nav-number">6.</span> <span class="nav-text">何时使用生成器表达式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#另一个示例等差数列生成器"><span class="nav-number">7.</span> <span class="nav-text">另一个示例：等差数列生成器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用itertools模块生成等差数列"><span class="nav-number">7.1.</span> <span class="nav-text">使用itertools模块生成等差数列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#python3.3中新出现的句法yield-from"><span class="nav-number">8.</span> <span class="nav-text">Python3.3中新出现的句法：yield from</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#深入分析iter函数"><span class="nav-number">9.</span> <span class="nav-text">深入分析iter函数</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="菜农陈文生" src="/uploads/avatar/nekosensei.png"><p class="site-author-name" itemprop="name">菜农陈文生</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">132</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">11</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">135</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="cc-license motion-element" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">菜农陈文生</span></div><script src="//cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="//cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script><script src="/js/aplayer-el.js"></script><script src="//unpkg.com/video.js/dist/video.min.js"></script><script src="/js/videojs-bilibili.js"></script><script src="/js/videojs-bilibili-el.js"></script></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script><script src="/js/local-search.js"></script><div id="pjax"><script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Axl15EIRi5o5AatKaxXxV4Oq-gzGzoHsz',
      appKey     : 'E0qm04UjsP0qQN1l8ME3GQ25',
      placeholder: "Just go go",
      avatar     : 'identicon',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script></div></body></html>