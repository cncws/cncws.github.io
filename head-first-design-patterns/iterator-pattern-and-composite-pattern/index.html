<!DOCTYPE html><html lang="zh-CN,en,default"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/uploads/icon/drop/128x128.png"><link rel="icon" type="image/png" sizes="32x32" href="/uploads/icon/drop/32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/uploads/icon/drop/16x16.png"><link rel="mask-icon" href="/uploads/icon/drop/drop.svg" color="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="NKt2iJb3Hnl6-Sm7LB-fTT7LRyi9cg5yZrB-zd0ohtk"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"cwscn.github.io",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1,width:240},copycode:{enable:!0,show_result:!0,style:"flat"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"manual"},fancybox:!1,mediumzoom:!0,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"fadeIn"}},path:"search.xml"}</script><meta name="description" content="迭代器模式：封装遍历 导入：餐厅和煎饼屋合并了  真是个好消息！现在我们可以在同一个地方，享用煎饼屋美味的煎饼早餐，和好吃的餐厅午餐了。但是，好像有一点小麻烦……有两种不同的菜单表现方式，这会带来什么问题？ 假设你已经被合组的新公司雇佣。你的工作是要创建一个 Java 版本的女招待。  public void printMenu() &amp;#123;    ArrayList breakfastIte"><meta name="keywords" content="blog"><meta property="og:type" content="article"><meta property="og:title" content="迭代器模式和组合模式"><meta property="og:url" content="https://cwscn.github.io/head-first-design-patterns/iterator-pattern-and-composite-pattern/index.html"><meta property="og:site_name" content="春夏秋冬"><meta property="og:description" content="迭代器模式：封装遍历 导入：餐厅和煎饼屋合并了  真是个好消息！现在我们可以在同一个地方，享用煎饼屋美味的煎饼早餐，和好吃的餐厅午餐了。但是，好像有一点小麻烦……有两种不同的菜单表现方式，这会带来什么问题？ 假设你已经被合组的新公司雇佣。你的工作是要创建一个 Java 版本的女招待。  public void printMenu() &amp;#123;    ArrayList breakfastIte"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://www.plantuml.com/plantuml/svg/TP31Im915CRl-rUyOnt4UqGGT2We23gAXt7dwGxjpiZiA8XuKoWoaqY3yY8KU0cA81IB_XbdL_-BTjSSK-dulddVz_lcEOmYe5TK5V3Gow6qd5YncRHTj6oN-3wS82yTAVIWQW6SASbu0JZnS3bHz6t9Yee97eavuRf8E9InW8f8HcAHYbBEHIXAPgDL-qq-9TmcvtWeIZx6b8ImBoMf73DVHOtcO3zIou9H89J6yzRsobf4MLJqawUgXyeHj0RfDEZ6nsJS3RgZuBrZk0UCepJ0XJcJJOZiF-AVlJLapJ8tsasbDhwr-chWrh96AXETdIBFxcsQkL08aXKS1I9lIkp0xAcjMmrzsmmRhTdpftwx2dgNuUDGjvlXGtrwqzFNdLb_jEPVZzy1OzUzmTmr6RvClhx3ku6-k9_s1_C45_D9W2bj6cpOWivhEAx_0000"><meta property="og:image" content="http://www.plantuml.com/plantuml/svg/ROxDIiD058NtUOfPrbNVGLmeABZIzNLwQuOcOvYPBAGKYWWsOaX1nRzG5RLGDt7XeehWotIcoSfNS6e8qkhkt7FFT-znMGC9-e7Q9pxwEoWST-PG9gY73lL0Ih8DJ0cqekqGiWcSGWjNzqA96yX34YmODhF2E8gVPQDIrWq4usgcQqkaJUfrOg9J7R_ee_SyINLyFXaVJwyFJPPCnjtY_erqAcPP8BIQ8ETWdJoNlBaO5O_zEM0zvDJzDwpZtc9u2tTHWM30_tOpKTUaaMqrVRqh7cxBdXNDv9f2_nUlSV2nUZWyC8Cqpvvis5nc9VxrSP9_dkcRWGe5sa7tXxftLLfDy2JQivrl"><meta property="og:image" content="http://www.plantuml.com/plantuml/svg/ZPDDIm916CVl-oa6JtNO1QyY2q67Wenk7Sp3k3xYaZihCoCava5AyL84lK1vAF3Y9GWIeaJyCeultwBnRNRTRSdJxlwV__DxNcQsOES0WLFY5UI0amMg5UQAPLEh29fLn8oXKsnp2lAbgY5KeZRXAI3bdLsjjZASO6BXSpXmompceOLnZr9SER8Pbs1IFkJWCAdA9yNSfSYYW3ciFtsmVPi0LPJKAZUTMM3iBJ2oFw1vR87dIYQLQ9eBRXLd6QVOuZLKmEmOBhZCtP39KekQKR7dD3yYaAV6-Jz1xLdNTJDKC11MN4ytJ3Mnver-QHX6PFT1NwXRBNIsXXbDyyxECFzW4PS3AaAU8pUlRbK2ZGR3oKDtxPhLRyHjSzPkYhkMQ5nDUc-RUS7YYT0TcFPUfxtE6H6jjkZ_YCRNQ70_URcU3jz7_OvuxYvvCV5HdtOQiijLczAoh3r--Xv_FiOGPeZ4DH97sor6JyjV9mSaupySRoE-SDJ-VW40"><meta property="og:image" content="http://www.plantuml.com/plantuml/svg/VP9DImCn48Rl-HN1KtjemQjAGV2WekBDG_MGRaSRx6ObcnPBBLGHLB0LGSMFwi5I4L6hA5W_m1_ZxdOz-HTClx8hhRqbxypxJ2Op2He73FgAo60Tz1Xmb6We6kLQ4f2M9AQ9vmWL7EGXYp1UuPI9QM2fG13bsWcpX6ba6SQDb0cDK3Dnb7EIcQAca62McX2WcrBLE101yiQ9C7WWYBEOWqXnvcM5gOeEuvmgCaOPS4MVRcT75vf6-WzUkkLpWIyI3PeUF3AYX4YaYSgIc2auqKIklxqZzqSaY3a3gq9w_yYiXyP1DzBW-qVLeYhLWFk92kFpjjeAgJ6rXRLmk6imlf1N3AdvXYEgIUHrsyZkUXdonY5TtU6kbGX5vMB5WItuiX4p161Ebn826ukgzX2U96bIFzti2FFCALRilRBxUUoKTgnQtghTpBFE5pX7hyxJuLT-euKRK8kdSjtF0_liedE-izxBzicrv7kBfXYoLE7ItgkurNEt-lppiUjixrlljrQjy5tAkrVhLkrDyUtxYthnmTswiLyU9KsH9MO04nEpGSG6SOyn_080"><meta property="og:image" content="http://www.plantuml.com/plantuml/svg/VP3BJi9068NtVOfPweO7C8R4k7BZ4x0fTMX9Q6k6YT4W2HT1Y4XDC1YLS95B20b5t1J2xM7ib7R5ApYbePH0t9vpvfpl7o5y1G4Kh_4T4A4OX8WHR8KB8ou2cR248Ggn70HdF8yWps88JazTrUy7CGQ061kCOiHoE0uu16dcWleibj7HCHFtT6pa_oi4Dde9Rp5zkoDB1pG4HVa6hbUu21kDWdDPeWGORcdjyWDGkt4Np4vxzzrHpvBd9-vzllr9Pdkcrz-ep3wZpx-NEW54hUhp9r8ewwE4FkgHZARFIW79NFJrIPEyTrVJWfcUaLRDIZwJOZOWaS7O73QiponvoQscEVEnHxJXQffd99bkH6080pcqZsilVHavZNHIHhLYLH9c9-bMgcawOxpLgRoijQraYIhBZmVRgIwBtqPvJAOAZH2bvqG24WsvZ3Hg5Dj4QVucKWu62lF2ccDxg9icYupLc3ZD0Sdejvotj5wVrOaoq2UqNfyjbgzTelqObJojjyrnZVAiRUTcKvsRQiFvDZhy1m00"><meta property="og:image" content="http://www.plantuml.com/plantuml/svg/TP7BJjj058RtVefPbaNw05759jk-GTs5IIR4aZsE7AjIHP7IN5329QuAHPH4XRHKGPLmsY9WR8ZoCCoClUihz7WiNuZ4RdoEv_ilqz1h666pwRn79ZOtiAqquabLjwi6LhIDbcDhLGTLBBDf4KmSjAKWj9NEjv7LnBRcw1PviVPqeTLggoCRczOxl3hTn4wbeHlntzjArT1QBVGQQtKfLAIdIscbfJjO_f7A5DW5u2gXOkXnXfVhUI0bZ_RgGwaajLTdcMHnyMGk7PVUG7SrJDwk5pR40gS6hZl8ggD4luouzrqCxjXY6HvTPaYLYD5FxluGXmTiCGdlU_pJWD6hyBJ7vtxqP_hOxYGqMzzi9BZqQZa_CXeKhm9qs1QJOOBWtYdpXuos6VsLYFrxs5S9emUXDnKdy-Hcj3o1CtTlezrEsF4ptJH571Oof7lcduNtCp5Sic27Trtv8e_jZof9tuH_ti_VH2NHygiulmDlujWNrr_00KnOC4u-LG9MCxOO74SU5N-d447qN33_J0jnr-Ny29wuzoqS_GPFG4nnuPZo_dKiBJi65Ypxjr0LyEDQm8NSS7SUTHVI2mj66JQn80lZ5pDmpiVdukg2JoxZ2D1fjmztTcuOtKi8B9Y5HsVyeSCf1RN_"><meta property="og:image" content="http://www.plantuml.com/plantuml/svg/fLDDIyD04BtdLyon7eft4K7q8gW8WXxKmpQPjWl9fcnMGMf1j2gA6X7RYlKYedYGUX2AiKf_ZDaq_HUkBVtIIYlUTcTVthnvRvAa1W9QAR495benv5hogw9JhfkeaPWZED45p25RdxAjbCsG2KXh00aKyyJ2o0YaONGKWgEYF7WDgsVXpN5GACkt7Vdo0facS1eTdTEKe3OR2h_0gJu4CtMMKA49fsG8tXIdJ0o64SE8T2R5WNYEbhs1V_f4QPvAKjE8A4501y0pccuInsaaC2FGQfY_ADGm2M0g07LBnocQHkQBHUwL_KfUkfVr0xSxf3uvz5ZzmysEOUgaSoG2LNTEXCrLgLjK7q6Jd9FDMUe8jLDTU-FyHsj7pVU4-eVmq-V-WomJAZYgMQ8JlLkkzUxy-5OqsWxXjxVlzUvo8xpeYlgz36HhpMOQimM2YN41TXnQKiR0Vw_MBXv2zrgUv6gLh5yf1wTtqhrTPM6fMY-KcY_o_BXvgDzu7zixlMIjbcFGnhJnuVr-hPZtN_TNcNpoP6dNhpm6ruT1rlMzmzfLDiXxmNDEKNu2"><meta property="og:image" content="http://www.plantuml.com/plantuml/svg/fLDDIyD04BtdL-on7Xh_W1IaNWGjWg3dxMRQB6GtONOhbZGNGGeYr9CAdlmJfQZWdp6b_WktgSr74qcBnxnvy_9ctgpB7I0W0Zqa0aGNq7AN2EF8FB1eLscaJ9DJa8EsBm9VWjGaj0ZfW-vG0Oqz4fBzVJA_Uud7RulFXyNh_Vnf6d_SnBCPYLR48r0CUQ2vBxVYdo5dMoXpTG66JP7JBNG3v5BNqwZZDB99ePQF8FmhsAd5U6wxt7CQnX3XjNI6G3KSQq2gVQoR8BAOHvLA4ZCz8WdhN9lX-qIQmCnNsEFWET5I9RwTVhq_nfFdx_4a7sf5ReLeIjlF5bpXk62gmj0X8XsUSAND3URkJFt7Q-PcCz7gqCgvL0zYQe0zoe2iuMIWSFrK8k9IrO7hrRzpiAp0Vdra2qeSAPxzCn7FAwOofTxEmFDsQhkaN2EOJhjLVE1MyRaVZ9hDz9x-gctYQxWyaMsFMkdoh8BhOYazOTiOpFEIIeAMr7D3sPdK3m00"><meta property="og:updated_time" content="2020-08-22T07:34:51.049Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="迭代器模式和组合模式"><meta name="twitter:description" content="迭代器模式：封装遍历 导入：餐厅和煎饼屋合并了  真是个好消息！现在我们可以在同一个地方，享用煎饼屋美味的煎饼早餐，和好吃的餐厅午餐了。但是，好像有一点小麻烦……有两种不同的菜单表现方式，这会带来什么问题？ 假设你已经被合组的新公司雇佣。你的工作是要创建一个 Java 版本的女招待。  public void printMenu() &amp;#123;    ArrayList breakfastIte"><meta name="twitter:image" content="http://www.plantuml.com/plantuml/svg/TP31Im915CRl-rUyOnt4UqGGT2We23gAXt7dwGxjpiZiA8XuKoWoaqY3yY8KU0cA81IB_XbdL_-BTjSSK-dulddVz_lcEOmYe5TK5V3Gow6qd5YncRHTj6oN-3wS82yTAVIWQW6SASbu0JZnS3bHz6t9Yee97eavuRf8E9InW8f8HcAHYbBEHIXAPgDL-qq-9TmcvtWeIZx6b8ImBoMf73DVHOtcO3zIou9H89J6yzRsobf4MLJqawUgXyeHj0RfDEZ6nsJS3RgZuBrZk0UCepJ0XJcJJOZiF-AVlJLapJ8tsasbDhwr-chWrh96AXETdIBFxcsQkL08aXKS1I9lIkp0xAcjMmrzsmmRhTdpftwx2dgNuUDGjvlXGtrwqzFNdLb_jEPVZzy1OzUzmTmr6RvClhx3ku6-k9_s1_C45_D9W2bj6cpOWivhEAx_0000"><link rel="canonical" href="https://cwscn.github.io/head-first-design-patterns/iterator-pattern-and-composite-pattern/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css"><link rel="stylesheet" href="//unpkg.com/video.js/dist/video-js.min.css"><link rel="stylesheet" href="/css/videojs-bilibili.css"><style>.aplayer.aplayer-arrow .aplayer-icon-loop,.aplayer.aplayer-arrow .aplayer-icon-order{display:inline-block}</style><title>迭代器模式和组合模式 | 春夏秋冬</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">春夏秋冬</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">人有悲欢离合 月有阴晴圆缺</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档<span class="badge">295</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类<span class="badge">28</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签<span class="badge">116</span></a></li><li class="menu-item menu-item-收藏"><a href="/favlist/" rel="section"><i class="fa fa-star fa-fw"></i> 收藏</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div><meting-js server="netease" type="playlist" id="67155774" theme="#ff5555" loop="all" order="list" preload="none" volume="" mutex="" list-folded="NaN" fixed="true"></meting-js></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwscn.github.io/head-first-design-patterns/iterator-pattern-and-composite-pattern/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar/nekosensei.png"><meta itemprop="name" content="菜农陈文生"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="春夏秋冬"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 迭代器模式和组合模式</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-08-22 15:34:51" itemprop="dateModified" datetime="2020-08-22T15:34:51+08:00">2020-08-22</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/books/" itemprop="url" rel="index"><span itemprop="name">书籍</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/books/head-first-design-patterns/" itemprop="url" rel="index"><span itemprop="name">Head First 设计模式</span></a></span></span><span id="/head-first-design-patterns/iterator-pattern-and-composite-pattern/" class="post-meta-item leancloud_visitors" data-flag-title="迭代器模式和组合模式" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/head-first-design-patterns/iterator-pattern-and-composite-pattern/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/head-first-design-patterns/iterator-pattern-and-composite-pattern/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="迭代器模式封装遍历">迭代器模式：封装遍历</h1><h2 id="导入餐厅和煎饼屋合并了">导入：餐厅和煎饼屋合并了</h2> <img src="http://www.plantuml.com/plantuml/svg/TP31Im915CRl-rUyOnt4UqGGT2We23gAXt7dwGxjpiZiA8XuKoWoaqY3yY8KU0cA81IB_XbdL_-BTjSSK-dulddVz_lcEOmYe5TK5V3Gow6qd5YncRHTj6oN-3wS82yTAVIWQW6SASbu0JZnS3bHz6t9Yee97eavuRf8E9InW8f8HcAHYbBEHIXAPgDL-qq-9TmcvtWeIZx6b8ImBoMf73DVHOtcO3zIou9H89J6yzRsobf4MLJqawUgXyeHj0RfDEZ6nsJS3RgZuBrZk0UCepJ0XJcJJOZiF-AVlJLapJ8tsasbDhwr-chWrh96AXETdIBFxcsQkL08aXKS1I9lIkp0xAcjMmrzsmmRhTdpftwx2dgNuUDGjvlXGtrwqzFNdLb_jEPVZzy1OzUzmTmr6RvClhx3ku6-k9_s1_C45_D9W2bj6cpOWivhEAx_0000"><p>真是个好消息！现在我们可以在同一个地方，享用煎饼屋美味的煎饼早餐，和好吃的餐厅午餐了。但是，好像有一点小麻烦……有两种不同的菜单表现方式，这会带来什么问题？</p><p>假设你已经被合组的新公司雇佣。你的工作是要创建一个 Java 版本的女招待。</p> <img src="http://www.plantuml.com/plantuml/svg/ROxDIiD058NtUOfPrbNVGLmeABZIzNLwQuOcOvYPBAGKYWWsOaX1nRzG5RLGDt7XeehWotIcoSfNS6e8qkhkt7FFT-znMGC9-e7Q9pxwEoWST-PG9gY73lL0Ih8DJ0cqekqGiWcSGWjNzqA96yX34YmODhF2E8gVPQDIrWq4usgcQqkaJUfrOg9J7R_ee_SyINLyFXaVJwyFJPPCnjtY_erqAcPP8BIQ8ETWdJoNlBaO5O_zEM0zvDJzDwpZtc9u2tTHWM30_tOpKTUaaMqrVRqh7cxBdXNDv9f2_nUlSV2nUZWyC8Cqpvvis5nc9VxrSP9_dkcRWGe5sa7tXxftLLfDy2JQivrl"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ArrayList breakfastItems = pancakeHouseMenu.getMenuItems();</span><br><span class="line">    MenuItem[] launchItems = dinerMenu.getMenuItems();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; breakfastItems.size(); i++) &#123;</span><br><span class="line">        MenuItem menuItem = (MenuItem)breakfastItems.get(i);</span><br><span class="line">        <span class="comment">// 打印menuItem</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lunchItems.length; i++) &#123;</span><br><span class="line">        MenuItem menuItem = lunchItems[i];</span><br><span class="line">        <span class="comment">// 打印menuItem</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现其他方法，做法也类似。我们总是需要处理两个菜单，并且用两个循环遍历。如果还有第三家餐厅以不同的实现出现，我们就需要有三个循环。</p><a id="more"></a><p>根据我们的 <code>printMenu()</code> 实现：</p><ul><li>我们是针对 PancakeHouseMenu 和 DinerMenu 的具体实现编码，而不是针对接口。</li><li>如果我们决定从 DinerMenu 切换到另一种菜单，此菜单的项使用 Hashtable 来存放的，我们会因此需要修改女招待中的许多代码。</li><li>女招待需要知道每个菜单如何表达内部的菜单项集合，这违反了封装。</li><li>我们有重复的代码：<code>printMenu()</code> 方法需要两个循环，来遍历两种不同的菜单。如果我们加上第三种菜单，我们就需要第三个循环。</li></ul><p>如果你从本书中学习了一件事情，那就是封装变化的部分。很明显，在这里发生变化的是：由不同的集合（collection）类型所造成的遍历。</p><h2 id="应用迭代器模式">应用迭代器模式</h2> <img src="http://www.plantuml.com/plantuml/svg/ZPDDIm916CVl-oa6JtNO1QyY2q67Wenk7Sp3k3xYaZihCoCava5AyL84lK1vAF3Y9GWIeaJyCeultwBnRNRTRSdJxlwV__DxNcQsOES0WLFY5UI0amMg5UQAPLEh29fLn8oXKsnp2lAbgY5KeZRXAI3bdLsjjZASO6BXSpXmompceOLnZr9SER8Pbs1IFkJWCAdA9yNSfSYYW3ciFtsmVPi0LPJKAZUTMM3iBJ2oFw1vR87dIYQLQ9eBRXLd6QVOuZLKmEmOBhZCtP39KekQKR7dD3yYaAV6-Jz1xLdNTJDKC11MN4ytJ3Mnver-QHX6PFT1NwXRBNIsXXbDyyxECFzW4PS3AaAU8pUlRbK2ZGR3oKDtxPhLRyHjSzPkYhkMQ5nDUc-RUS7YYT0TcFPUfxtE6H6jjkZ_YCRNQ70_URcU3jz7_OvuxYvvCV5HdtOQiijLczAoh3r--Xv_FiOGPeZ4DH97sor6JyjV9mSaupySRoE-SDJ-VW40"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Waitress &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他变量和方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterator pancakeIterator = pancakeHouseMenu.createIterator();</span><br><span class="line">        Iterator dinerIterator = dinerMenu.createIterator();</span><br><span class="line">        printMenu(pancakeIterator);</span><br><span class="line">        printMenu(dinerIterator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printMenu</span><span class="params">(Iterator iterator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            MenuItem menuItem = (MenuItem)iterator.next();</span><br><span class="line">            <span class="comment">// 打印menuItem</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DinerMenuIterator</span> </span>&#123;</span><br><span class="line">    MenuItem[] items;  <span class="comment">// 餐厅菜单</span></span><br><span class="line">    <span class="keyword">int</span> position = <span class="number">0</span>; <span class="comment">// 记录当前遍历的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DinerMenuIterator</span><span class="params">(MenuItems[] items)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.items = items;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MenuItem menuItem = items[position];</span><br><span class="line">        position++;</span><br><span class="line">        <span class="keyword">return</span> menuItem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (position &gt;= item.length || items[position] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DinerMenu</span> </span>&#123;</span><br><span class="line">    MenuItem[] menuItems;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他变量和方法</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DinerMenuIterator(menuItems);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="做一些改良">做一些改良</h2><p>两份菜单要必须实现 <code>createIterator()</code> 方法，但我们没有为它们设计一个共同的接口。所以，接下来就要这么做。</p><p>为社么我们不使用 Java 的 Iterator 接口呢——我们之所以这么做，是为了要让你了解如果从头创建一个迭代器，我们自己定义了 Iterable 接口。现在我们的目的已经达到了，所以就要改变做法，开始使用 Java 的 Iterator 接口。</p> <img src="http://www.plantuml.com/plantuml/svg/VP9DImCn48Rl-HN1KtjemQjAGV2WekBDG_MGRaSRx6ObcnPBBLGHLB0LGSMFwi5I4L6hA5W_m1_ZxdOz-HTClx8hhRqbxypxJ2Op2He73FgAo60Tz1Xmb6We6kLQ4f2M9AQ9vmWL7EGXYp1UuPI9QM2fG13bsWcpX6ba6SQDb0cDK3Dnb7EIcQAca62McX2WcrBLE101yiQ9C7WWYBEOWqXnvcM5gOeEuvmgCaOPS4MVRcT75vf6-WzUkkLpWIyI3PeUF3AYX4YaYSgIc2auqKIklxqZzqSaY3a3gq9w_yYiXyP1DzBW-qVLeYhLWFk92kFpjjeAgJ6rXRLmk6imlf1N3AdvXYEgIUHrsyZkUXdonY5TtU6kbGX5vMB5WItuiX4p161Ebn826ukgzX2U96bIFzti2FFCALRilRBxUUoKTgnQtghTpBFE5pX7hyxJuLT-euKRK8kdSjtF0_liedE-izxBzicrv7kBfXYoLE7ItgkurNEt-lppiUjixrlljrQjy5tAkrVhLkrDyUtxYthnmTswiLyU9KsH9MO04nEpGSG6SOyn_080"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DinerMenuIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    MenuItem[] list;</span><br><span class="line">    <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他变量和方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// next()方法和hasNext()方法保持不变</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加remove()方法的实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (position &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException</span><br><span class="line">                (<span class="string">"You can't remove an item until you've done at least one next()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list[position-<span class="number">1</span>] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = position-<span class="number">1</span>; i &lt; (list.length-<span class="number">1</span>); i++) &#123;</span><br><span class="line">                list[i] = list[i+<span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            list[list.length-<span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>问</strong>：如果我不想让客户具备删除的能力，该怎么办？</p><p><strong>答</strong>：<code>remove()</code> 方法其实是可有可无的，不一定要提供删除的功能。但是，很明显的，你需要提供这样的方法，因为毕竟它被声明在 Iterator 接口中，如果你不允许 <code>remove()</code> 的话，可以抛出一个 <code>java.lang.UnsupportedOperationException</code> 运行时异常。</p><p><strong>Iterator 的 API 文件提到可以让 <code>remove()</code> 方法抛出这样的异常，而任何良好的客户程序只要调用了 <code>remove()</code> 方法，就应该检查是否会发生这个异常</strong>。</p></li><li><p><strong>问</strong>：在多线程的情况下，可能会有多个迭代器引用同一个对象集合。<code>remove()</code> 会造成怎样的影响？</p><p><strong>答</strong>：后果并没有指明，所以很难预料。当你的程序在多线程的代码中使用到迭代器时，必须特别小心。</p></li></ul><h2 id="定义迭代器模式">定义迭代器模式</h2><p>迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。</p><p>这个模式给你提供了一个方法，<strong>可以顺序访问一个聚集对象中的元素，而又不用知道内部是如何表示的</strong>。</p><p>另一个对你的设计造成重要影响的，是<strong>迭代器模式把在元素之间游走的责任交给迭代器，而不是聚合对象</strong>。这不仅让聚合的接口和实现变得更简洁，而可以让聚合更专注在它所应该专注的事情上面（也就是管理对象集合），而不必去理会遍历的事情。</p> <img src="http://www.plantuml.com/plantuml/svg/VP3BJi9068NtVOfPweO7C8R4k7BZ4x0fTMX9Q6k6YT4W2HT1Y4XDC1YLS95B20b5t1J2xM7ib7R5ApYbePH0t9vpvfpl7o5y1G4Kh_4T4A4OX8WHR8KB8ou2cR248Ggn70HdF8yWps88JazTrUy7CGQ061kCOiHoE0uu16dcWleibj7HCHFtT6pa_oi4Dde9Rp5zkoDB1pG4HVa6hbUu21kDWdDPeWGORcdjyWDGkt4Np4vxzzrHpvBd9-vzllr9Pdkcrz-ep3wZpx-NEW54hUhp9r8ewwE4FkgHZARFIW79NFJrIPEyTrVJWfcUaLRDIZwJOZOWaS7O73QiponvoQscEVEnHxJXQffd99bkH6080pcqZsilVHavZNHIHhLYLH9c9-bMgcawOxpLgRoijQraYIhBZmVRgIwBtqPvJAOAZH2bvqG24WsvZ3Hg5Dj4QVucKWu62lF2ccDxg9icYupLc3ZD0Sdejvotj5wVrOaoq2UqNfyjbgzTelqObJojjyrnZVAiRUTcKvsRQiFvDZhy1m00"><p>迭代器模式的类图看起来很像我们所学的另一个模式，你知道是哪个模式吗？提示：子类决定要创建哪个对象。（工厂方法模式）</p><h2 id="问答">问答</h2><ul><li><p><strong>问</strong>：我听说过“内部的”迭代器和“外部的”迭代器。这是什么？我们在前面的例子中实现的是哪一种？</p><p><strong>答</strong>：我们实现的是外部迭代器，也就是说，客户通过调用 <code>next()</code> 取得下一个元素。<strong>而内部的迭代器则是由迭代器自己控制。在这种情况下，因为是由迭代器自行在元素之间游走，所以你必须高速迭代器在游走的过程中，要做些什么事情，也就是说，你必须将操作传入给迭代器</strong>。因为客户无法控制遍历的过程，所以内部迭代器比外部迭代器更没有弹性。然而，某些人可能认为内部的迭代器比较容易使用，因为只需将操作告诉它，它就会帮你做完所有事情。</p></li><li><p><strong>问</strong>：你说可以用迭代器写出“多态的代码”，可以再多做一些解释吗？</p><p><strong>答</strong>：当我们写了一个需要以迭代器当作参数的方法时，其实就是在使用多态的迭代。也就是说，我们所写出的代码，可以在不同的集合中游走，只要这个集合支持迭代器即可。我们不在乎这个集合是如何被实现的，但依然可以编程在它内部的元素之间游走。</p></li></ul><h1 id="单一责任和内聚">单一责任和内聚</h1><p>当我们郧西一个类不但要完成自己的事情（管理某种聚合），还同时要负担更多的责任（例如遍历）时，我们就给了这个类两个变化的原因。如果这个集合改变的话，这个类必须改变；如果我们遍历的方式改变的话，这个类也必须改变。</p><blockquote><p>一个类应该只有一个引起变化的原因。</p></blockquote><p>这个原则告诉我们将一个责任只指派给一个类。这听起来很容易，但其实做起来并不简单：<strong>区分设计中的责任，是最困难的事情之一</strong>。我们的大脑很习惯看着一大群的行为，然后将它们集中在一起，尽管它们可能属于两个或多个不同的责任。想要成功的唯一方法，就是努力不懈地检查你的设计，随着系统的成长，随时观察有没有迹象显示某个类改变的原因超出一个。</p><p>内聚（cohesion）这个术语用来度量一个类或模块紧密地达到单一目的或责任。当一个模块被设计成只支持一组相关的功能时，我们说它具有高内聚；反之，当被设计成支持一组不相关的功能时，我们说它具有低内聚。</p><p>内聚是一个比单一责任原则更普遍的概念，但两者其实关系是很密切的。遵守这个原则的类容易具有很高的凝聚力，而且比背负许多责任的低内聚类更容易维护。</p><h1 id="组合模式迎接新的菜单">组合模式：迎接新的菜单</h1><p>我们花了很多时间在女招待 Waitress 上，但还是得承认，程序中调用两次 <code>printMenu()</code> 看起来有点丑。每次我们一有新菜单加入，就必须打开 Waitress 并加入更多的代码。这算不算是“违反开放-关闭原则“？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator pancakeIterator = pancakeHouseMenu.createIterator();</span><br><span class="line">    Iterator dinerIterator = dinerMenu.createIterator();</span><br><span class="line">    Iterator cafeIterator = cafeMenu.createIterator();  <span class="comment">// 添加咖啡厅菜单</span></span><br><span class="line">    printMenu(pancakeIterator);</span><br><span class="line">    printMenu(dinerIterator);</span><br><span class="line">    printMenu(cafeIterator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这不是女招待的错。对于将她从菜单的实现上解耦和提取遍历动作到迭代器，我们都做的很好。但我们让然将菜单处理成分离而独立的对象——我们需要一种一起管理它们的方法。</p><h2 id="将菜单打包进-arraylist">将菜单打包进 ArrayList</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Waitress</span> </span>&#123;</span><br><span class="line">    ArrayList menus;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Waitress</span><span class="params">(ArrayList menus)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.menus = menus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterator menuIterator = menus.iterator(); <span class="comment">// 遍历菜单</span></span><br><span class="line">        <span class="keyword">while</span> (menuIterator.hasNext()) &#123;</span><br><span class="line">            Menu menu = (Menu)menuIterator.next();</span><br><span class="line">            printMenu(menu.createIterator());  <span class="comment">// 遍历并打印菜单项</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printMenu</span><span class="params">(Iterator iterator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            MenuItem menuItem = (MenuItem)iterator.next();</span><br><span class="line">            <span class="comment">// 打印菜单项内容</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来相当不错，虽然我们失去了菜单的名字，但是可以把名字加进每个菜单中。</p><p>正当我们认为这很安全的时候，现在他们希望能够加上一份餐后甜点的“子菜单”。根据现有的实现，根本做不到。<strong>我们需要让餐厅菜单持有一份子菜单，但是不能真的把它赋值给菜单项数组，因为类型不同，所以不能这么做</strong>。</p><p>该是做决策来改写厨师的实现以符合所有菜单的需求的时候了。在我们的新设计中，真正需要些什么呢？</p><ul><li>我们需要某种<strong>树形结构，可以容纳菜单、子菜单和菜单项</strong>。</li><li>我们需要确定能够在每个菜单的各个项之间游走，而且至少要像现在用迭代器一样方便。</li><li>我们也需要能够更有弹性地菜单项之间游走。比方说，可能只需要遍历甜品菜单，或者可以遍历餐厅的整个餐单（包括甜品菜单在内）。</li></ul><h2 id="定义组合模式">定义组合模式</h2><p>我们要介绍另一个模式解决这个难题。我们并没有放弃迭代器——它仍然是我们解决方案中的一部分——然而，管理菜单的问题已经到了一个迭代器无法解决的新维度。</p><p>组合模式允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。</p> <img src="http://www.plantuml.com/plantuml/svg/TP7BJjj058RtVefPbaNw05759jk-GTs5IIR4aZsE7AjIHP7IN5329QuAHPH4XRHKGPLmsY9WR8ZoCCoClUihz7WiNuZ4RdoEv_ilqz1h666pwRn79ZOtiAqquabLjwi6LhIDbcDhLGTLBBDf4KmSjAKWj9NEjv7LnBRcw1PviVPqeTLggoCRczOxl3hTn4wbeHlntzjArT1QBVGQQtKfLAIdIscbfJjO_f7A5DW5u2gXOkXnXfVhUI0bZ_RgGwaajLTdcMHnyMGk7PVUG7SrJDwk5pR40gS6hZl8ggD4luouzrqCxjXY6HvTPaYLYD5FxluGXmTiCGdlU_pJWD6hyBJ7vtxqP_hOxYGqMzzi9BZqQZa_CXeKhm9qs1QJOOBWtYdpXuos6VsLYFrxs5S9emUXDnKdy-Hcj3o1CtTlezrEsF4ptJH571Oof7lcduNtCp5Sic27Trtv8e_jZof9tuH_ti_VH2NHygiulmDlujWNrr_00KnOC4u-LG9MCxOO74SU5N-d447qN33_J0jnr-Ny29wuzoqS_GPFG4nnuPZo_dKiBJi65Ypxjr0LyEDQm8NSS7SUTHVI2mj66JQn80lZ5pDmpiVdukg2JoxZ2D1fjmztTcuOtKi8B9Y5HsVyeSCf1RN_"><p><strong>利用组合结构，我们能把相同的操作应用在组合和个别对象上。换句话说，在大多数情况下我们可以忽略对象组合和个别对象之间的差别。</strong></p><p><strong>问</strong>：这和迭代器有什么关系？</p><p><strong>答</strong>：我们现在在采取一个新的方法，打算用新的方案——组合模式，来重新实现菜单。不要认为迭代器和组合之间有什么神奇的转换。我们可以说，这两者可以合作无间，你很快就会看到我们可以在组合的实现中使用迭代器，而且做法还不止一种。</p><h2 id="利用组合设计菜单">利用组合设计菜单</h2> <img src="http://www.plantuml.com/plantuml/svg/fLDDIyD04BtdLyon7eft4K7q8gW8WXxKmpQPjWl9fcnMGMf1j2gA6X7RYlKYedYGUX2AiKf_ZDaq_HUkBVtIIYlUTcTVthnvRvAa1W9QAR495benv5hogw9JhfkeaPWZED45p25RdxAjbCsG2KXh00aKyyJ2o0YaONGKWgEYF7WDgsVXpN5GACkt7Vdo0facS1eTdTEKe3OR2h_0gJu4CtMMKA49fsG8tXIdJ0o64SE8T2R5WNYEbhs1V_f4QPvAKjE8A4501y0pccuInsaaC2FGQfY_ADGm2M0g07LBnocQHkQBHUwL_KfUkfVr0xSxf3uvz5ZzmysEOUgaSoG2LNTEXCrLgLjK7q6Jd9FDMUe8jLDTU-FyHsj7pVU4-eVmq-V-WomJAZYgMQ8JlLkkzUxy-5OqsWxXjxVlzUvo8xpeYlgz36HhpMOQimM2YN41TXnQKiR0Vw_MBXv2zrgUv6gLh5yf1wTtqhrTPM6fMY-KcY_o_BXvgDzu7zixlMIjbcFGnhJnuVr-hPZtN_TNcNpoP6dNhpm6ruT1rlMzmzfLDiXxmNDEKNu2"><p><strong>所有的组件都必须实现 MenuComponent 接口，然而，叶节点和组合节点的角色不同，所以有些方法可能并不适合某种节点。面对这种情况，有时候，你最好是抛出运行时异常。</strong></p><h2 id="实现菜单项和菜单">实现菜单项和菜单</h2><p>本节重点关注 <code>print()</code> 方法。观察组合模式是如何让 Waitress 能够忽略 MenuItem 和 Menu 的差别。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MenuItem</span> <span class="keyword">extends</span> <span class="title">MenuComponent</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 其他变量和方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;  <span class="comment">// 打印菜单项</span></span><br><span class="line">        System.out.print(<span class="string">"  "</span> + getName());</span><br><span class="line">        <span class="keyword">if</span> (isVegetarian()) &#123;</span><br><span class="line">            System.out.print(<span class="string">"(v)"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">", "</span> + getPrice());</span><br><span class="line">        System.out.println(<span class="string">"     -- "</span> + getDescription());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Menu</span> <span class="keyword">extends</span> <span class="title">MenuComponent</span> </span>&#123;</span><br><span class="line">    ArrayList menuComponents = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他方法和变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;  <span class="comment">// 打印菜单的名字和描述</span></span><br><span class="line">        System.out.print(<span class="string">"\n"</span> + getName());</span><br><span class="line">        System.out.println(<span class="string">", "</span> + getDescription());</span><br><span class="line">        System.out.println(<span class="string">"---------------------"</span>);</span><br><span class="line">        <span class="comment">// 我们如何打印菜单里每个菜单项的内容：我们可以让每个组件打印自己。</span></span><br><span class="line">        Iterator iterator = menuComponents.itertor();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="comment">// menuComponent可能是菜单，也可能是菜单项。无论如何，都有一个print()方法。</span></span><br><span class="line">            MenuComponent menuComponent = (MenuComponent)iterator.next();</span><br><span class="line">            menuComponent.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Waitress</span> </span>&#123;</span><br><span class="line">    MenuComponent allMenus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他方法和变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paintMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只需要调用最顶层菜单的print()，就可以打印整个菜单。</span></span><br><span class="line">        allMenus.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单一责任和组合模式">单一责任和组合模式</h1><p>你告诉我们“一个类，一个责任”，现在却给我们一个让一个类有两个责任的模式。组合模式不但要管理层次结构，而且还要执行菜单的操作。</p><p>你的观察有几分真实性。我们可以这么说，组合模式以单一责任设计原则换取透明性（transparency）。什么是透明性？通过让组件接口同时包含一些管理子节点和叶节点的操作，客户就可以将组合节点和叶节点一视同仁。也就是说，<strong>一个元素究竟是组合还是叶节点，对客户是透明的</strong>。</p><p>现在，我们在 MenuComponent 类中同时具有两种类型的操作。因为客户有机会对一个元素做一些不恰当或是没有意义的操作（例如试图把菜单添加到菜单项），所以我们失去了一些“安全性”。这是设计上的抉择：我们当然也可以采用另一种方向的设计，将责任区分开来放在不同的接口中。这么一来，设计上就比较安全，但我们也因此失去了透明性，客户的代码将必须用条件语句和 instanceof 操作符处理不同类型的节点。</p><p>所以，回到你的问题，<strong>这是一个很典型的折衷案例。尽管我们受到设计原则的指导，但是，我们总是需要观察某原则对我们的设计所造成的影响</strong>。有时候，我们会故意做一些违反原则的事情。然而，在某些例子中，这是观点的问题；比方说，让管理孩子的操作（例如 <code>add()</code>、<code>remove()</code>、<code>getChild()</code>）出现在叶节点中，似乎很不恰当。但是换个角度来看，你可以把叶节点视为没有孩子的节点。</p><h1 id="组合迭代器遍历组合菜单">组合迭代器：遍历组合菜单</h1><p>我们答应过会告诉你怎样用组合来使用迭代器。我们其实已经在 <code>print()</code> 方法内部的实现中使用了迭代器，除此之外，如果有需要，我们也能使用迭代器遍历整个组合。比方说，游走整个菜单，挑出素食项。</p><p><em>遍历打印菜单和遍历菜单是不同的。前者我们已经实现；后者要求客户能取出每一个菜单项，而不单单是显示其内容。后面我们会解释，这是内部迭代器和外部迭代器的区别。</em></p><p>想要实现一个组合迭代器，让我们为每个组件都加上 <code>createIterator()</code> 方法。</p> <img src="http://www.plantuml.com/plantuml/svg/fLDDIyD04BtdL-on7Xh_W1IaNWGjWg3dxMRQB6GtONOhbZGNGGeYr9CAdlmJfQZWdp6b_WktgSr74qcBnxnvy_9ctgpB7I0W0Zqa0aGNq7AN2EF8FB1eLscaJ9DJa8EsBm9VWjGaj0ZfW-vG0Oqz4fBzVJA_Uud7RulFXyNh_Vnf6d_SnBCPYLR48r0CUQ2vBxVYdo5dMoXpTG66JP7JBNG3v5BNqwZZDB99ePQF8FmhsAd5U6wxt7CQnX3XjNI6G3KSQq2gVQoR8BAOHvLA4ZCz8WdhN9lX-qIQmCnNsEFWET5I9RwTVhq_nfFdx_4a7sf5ReLeIjlF5bpXk62gmj0X8XsUSAND3URkJFt7Q-PcCz7gqCgvL0zYQe0zoe2iuMIWSFrK8k9IrO7hrRzpiAp0Vdra2qeSAPxzCn7FAwOofTxEmFDsQhkaN2EOJhjLVE1MyRaVZ9hDz9x-gctYQxWyaMsFMkdoh8BhOYazOTiOpFEIIeAMr7D3sPdK3m00"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Menu</span> <span class="keyword">extends</span> <span class="title">MenuComponent</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 其他部分的代码不需要修改</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// CompositeIterator可以遍历组合菜单（包括子菜单）</span></span><br><span class="line">        <span class="comment">// 我们将目前组合的迭代器传入它的构造器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CompositeIterator(menuComponents.iterator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MenuItem</span> <span class="keyword">extends</span> <span class="title">MenuComponent</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 其他部分的代码不需要修改</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NullIterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CompositeIterator 是一个不容小觑的迭代器。它的工作是遍历组件内的菜单项，而且确保所有的子菜单（以及子子菜单……）都被包括进来。注意：跟着我默念“递归是我的朋友，递归是我的朋友……”</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositeIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    Stack stack = <span class="keyword">new</span> Stack();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CompositeIterator</span><span class="params">(Iterator iterator)</span> </span>&#123;</span><br><span class="line">        stack.push(iterator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hasNext()) &#123;</span><br><span class="line">            Iterator iterator = (Iterator) stack.peek();</span><br><span class="line">            MenuComponent component = (MenuComponent) iterator.next();</span><br><span class="line">            <span class="comment">// 如果元素是一个菜单，将它丢进堆栈中</span></span><br><span class="line">            <span class="comment">// 下次next()被调用的时候，就能从子菜单中取出元素</span></span><br><span class="line">            <span class="keyword">if</span> (component <span class="keyword">instanceof</span> Menu) &#123;</span><br><span class="line">                stack.push(component.createIterator());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> component</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Iterator iterator = (Iterator) stack.peek();</span><br><span class="line">            <span class="comment">// 若当前栈顶的迭代器为空，则丢弃它，再次检查栈顶</span></span><br><span class="line">            <span class="keyword">if</span> (!iterator.hasNext()) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">return</span> hasNext(); <span class="comment">// 递归调用hasNext()</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不打算支持删除操作</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真是不可小觑的代码……究竟为什么遍历组合好像比以前为 MenuComponent 类的 <code>print()</code> 写过的遍历代码复杂？</p><p>在我们写 MenuComponent 类的 <code>print()</code> 方法的时候，我们利用了一个迭代器来遍历组件内的每个项。如果遇到的是菜单，我们就会递归地调用 <code>print()</code> 方法处理它。换句话说，MenuComponent 是在“内部”自行处理遍历。</p><p>但是在上面的代码中，我们实现的是一个“外部”的迭代器，所以有许多需要追踪的事情。外部迭代器必须维护它在遍历中的位置，以便外部客户可以通过调用 <code>hasNext()</code> 和 <code>next()</code> 来驱动遍历。在这个例子中，我们的代码也必须维护组合递归结构的位置。</p><h2 id="空迭代器">空迭代器</h2><p>菜单项内没什么可以遍历的，对吧？那么我们要如何实现菜单项的 <code>createIterator()</code> 方法呢？有两种选择：</p><ul><li><p>选择一：返回 null</p><p>我们可以让 <code>createIterator()</code> 方法返回 null，但是如果这么做，我们的客户代码就需要条件语句来判断返回值是否为 null。</p></li><li><p>选择二：返回一个迭代器，而这个迭代器的 <code>hasNext()</code> 永远返回 false</p><p>这似乎是一个更好的方案。我们依然可以返回一个迭代器，客户不用再担心返回值是否为 null。我们等于是创建了一个迭代器，其作用是“没作用”。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NullIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="给我素食菜单">给我素食菜单</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Waitress</span> </span>&#123;</span><br><span class="line">    MenuComponent allMenus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printVegetarianMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterator iterator = allMenus.createIterator();</span><br><span class="line">        System.out.println(<span class="string">"\nVEGETARIAN MENU\n----"</span>);</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            MenuComponent menuComponent = (MenuComponent)iterator.next();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (menuComponent.isVegetarian()) &#123;</span><br><span class="line">                    menuComponent.print();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnsupportedOperationException e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>printVegetarianMenu()</code> 方法内使用了 try/catch 来处理那些不支持 <code>isVegetarian()</code> 方法的菜单的逻辑。</p><p>try/catch 是一种错误处理的方法，而不是程序逻辑的方法。如果不这么做，我们还有哪些选择呢？<strong>我们可以在调用 <code>isVegetarian()</code> 方法之前，用 instanceof 来检查菜单组件的运行时类型，以确定它是菜单项。但是这么做，我们就会因为无法统一处理菜单和菜单项而失去透明性</strong>。</p><p>我们也可以改写 Menu 的 <code>isVegetarian()</code> 方法，让它返回 false。这提供了一个简单的解决方案，同时也保持了透明性。</p><p>我们的解决方案是为了要清楚地表示我们的想法。<strong>我们真正想要传达的是：<code>isVegetarian()</code> 是 Menu 没有支持的操作（这和说 <code>isVegetarian()</code> 是 false 意义不等同）。这样的做法也允许后来人为 Menu 实现一个合理的 <code>isVegetarian()</code> 方法，而我们不必为此在修改这里的代码了</strong>。</p><h1 id="要点">要点</h1><ul><li>迭代器允许访问聚合的元素，而不需要暴露它的内部结构。</li><li>迭代器将遍历聚合的工作封装进一个对象中。</li><li>当使用迭代器的时候，我们依赖聚合提供遍历。（这很合理，避免我们去拷贝聚合的内容，节省了空间。但是我们是不是没有在 UML 类图中加上 ConcreateIterator 指向 Iterator 的依赖箭头？）</li><li>迭代器提供了一个通用的接口，让我们遍历聚合的项，当我们编码使用聚合的项时，就可以使用多态机制。</li><li>我们应该努力让一个类只分配一个责任。</li><li>组合模式提供一个结构，可同时包容个别对象和组合对象。</li><li>组合模式允许客户对个别对象以及组合对象一视同仁。</li><li>组合结构内的任意对象称为组件，组件可以是组合，也可以是叶节点。</li><li>在实现组合模式时，有许多设计上的折衷。你要根据需要平衡透明性（一个类两个责任）和安全性（组件同时实现组合的接口和叶节点的接口）。</li></ul></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/python/str-title-function/" rel="prev" title="str.title 方法"><i class="fa fa-chevron-left"></i> str.title 方法</a></div><div class="post-nav-item"> <a href="/leetcode/validate-binary-search-tree/" rel="next" title="98. Validate Binary Search Tree">98. Validate Binary Search Tree<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#迭代器模式封装遍历"><span class="nav-number">1.</span> <span class="nav-text">迭代器模式：封装遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#导入餐厅和煎饼屋合并了"><span class="nav-number">1.1.</span> <span class="nav-text">导入：餐厅和煎饼屋合并了</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用迭代器模式"><span class="nav-number">1.2.</span> <span class="nav-text">应用迭代器模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#做一些改良"><span class="nav-number">1.3.</span> <span class="nav-text">做一些改良</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定义迭代器模式"><span class="nav-number">1.4.</span> <span class="nav-text">定义迭代器模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#问答"><span class="nav-number">1.5.</span> <span class="nav-text">问答</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#单一责任和内聚"><span class="nav-number">2.</span> <span class="nav-text">单一责任和内聚</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#组合模式迎接新的菜单"><span class="nav-number">3.</span> <span class="nav-text">组合模式：迎接新的菜单</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#将菜单打包进-arraylist"><span class="nav-number">3.1.</span> <span class="nav-text">将菜单打包进 ArrayList</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定义组合模式"><span class="nav-number">3.2.</span> <span class="nav-text">定义组合模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#利用组合设计菜单"><span class="nav-number">3.3.</span> <span class="nav-text">利用组合设计菜单</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现菜单项和菜单"><span class="nav-number">3.4.</span> <span class="nav-text">实现菜单项和菜单</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#单一责任和组合模式"><span class="nav-number">4.</span> <span class="nav-text">单一责任和组合模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#组合迭代器遍历组合菜单"><span class="nav-number">5.</span> <span class="nav-text">组合迭代器：遍历组合菜单</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#空迭代器"><span class="nav-number">5.1.</span> <span class="nav-text">空迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#给我素食菜单"><span class="nav-number">5.2.</span> <span class="nav-text">给我素食菜单</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#要点"><span class="nav-number">6.</span> <span class="nav-text">要点</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="菜农陈文生" src="/uploads/avatar/nekosensei.png"><p class="site-author-name" itemprop="name">菜农陈文生</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">295</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">28</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">116</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/cncws" title="GitHub → https://github.com/cncws" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:1031616423@qq.com" title="E-Mail → mailto:1031616423@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span></div><div class="cc-license motion-element" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">菜农陈文生</span></div><script src="//cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="//cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script><script src="/js/aplayer-el.js"></script><script src="//unpkg.com/video.js/dist/video.min.js"></script><script src="/js/videojs-bilibili.js"></script><script src="/js/videojs-bilibili-el.js"></script></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script><script src="/js/local-search.js"></script><div id="pjax"><script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Axl15EIRi5o5AatKaxXxV4Oq-gzGzoHsz',
      appKey     : 'E0qm04UjsP0qQN1l8ME3GQ25',
      placeholder: "Just go go",
      avatar     : 'identicon',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script></div></body></html>