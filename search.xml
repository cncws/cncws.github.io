<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>单件模式</title>
      <link href="/notes/head-first-design-patterns/singleton-pattern/"/>
      <url>/notes/head-first-design-patterns/singleton-pattern/</url>
      
        <content type="html"><![CDATA[<p>有一些对象其实我们只需要一个，比方说：线程池（threadpool）、缓存（cache）、对话框、处理偏好设置和注册表（registry）的对象、日志对象，充当打印机、显卡等设备的驱动程序的对象。事实上，这类对象只能有一个实例，如果制造出多个实例，就会导致许多问题产生，例如：程序的行为异常、资源使用过量，或者是不一致的结果。</p><p>单件模式是经得起时间考验的方法，可以确保只有一个实例会被创建。单件模式也给了我们一个全局访问点，和全局变量一样方便，有没有全局变量的缺点。什么缺点？举例来说：如果将对象赋值给一个全局变量，那么你必须在程序已开始就创建好对象（这其实和实现有关。有些 JVM 的实现是：在用到的时候才创建对象），对吧？万一这个对象非常耗费资源，而程序在这次的执行过程中又一直没用到它，不就形成浪费了吗？</p><h1 id="定义单件模式">定义单件模式</h1><blockquote><p><strong>单件模式</strong>确保一个类只有一个实例，并提供一个全局访问点。</p></blockquote><img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYoW2996SM9UUaSYNd91ONAmHdvgNdf9RavobKSoae51HbbYMMf2A9bkPb5fQcUkOLboJc9QU2b9GcvMGcAm3v9K0AeJ0zjGIcIaCJgAuwDxKa8p-bLa5VN-5fwxOdkwSzcxRpsUQfNBLS24swTWWJ0000"><h1 id="经典的单件模式实现">经典的单件模式实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个版本有一个问题。有多个线程要执行 <code>Singleton.getInstance()</code> 时，可能会产生不同的对象。</p><table><thead><tr class="header"><th>线程一</th><th>线程二</th><th>uniqueInstance</th></tr></thead><tbody><tr class="odd"><td><code>public static Singleton getInstance() {</code></td><td></td><td><code>null</code></td></tr><tr class="even"><td></td><td><code>public static Singleton getInstance() {</code></td><td><code>null</code></td></tr><tr class="odd"><td><code>if (uniqueInstance == null) {</code></td><td></td><td><code>null</code></td></tr><tr class="even"><td></td><td><code>if (uniqueInstance == null) {</code></td><td><code>null</code></td></tr><tr class="odd"><td><code>uniqueInstance = new Singleton();</code></td><td></td><td><code>&lt;object1&gt;</code></td></tr><tr class="even"><td><code>return uniqueInstance;</code></td><td></td><td><code>&lt;object1&gt;</code></td></tr><tr class="odd"><td></td><td><code>uniqueInstance = new Singleton();</code></td><td><code>&lt;object2&gt;</code></td></tr><tr class="even"><td></td><td><code>return uniqueInstance;</code></td><td><code>&lt;object2&gt;</code></td></tr></tbody></table><a id="more"></a><h1 id="处理多线程">处理多线程</h1><p>只要把 <code>getInstance()</code> 变成同步（synchronized）方法，多线程灾难几乎就可以轻易地解决了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样可以解决问题，但是同步会降低性能。更严重的是：只有第一次执行此方法时，才真正需要同步。换句话说，一旦设置好 <code>uniqueInstance</code> 变量，就不再需要同步这个方法了。之后每次调用这个方法，同步都是一种累赘。</p><h1 id="改善多线程">改善多线程</h1><h2 id="用回经典的单件模式">用回经典的单件模式</h2><p>没错，如果你的应用程序可以接受 <code>getInstance()</code> 造成的额外负担，就忘了这件事吧。</p><h2 id="使用急切创建实例">使用“急切”创建实例</h2><p>如果应用程序总是创建并使用单件模式，或者在创建和运行时方面的负担不太繁重，你可能要想急切（eagerly）创建此单件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用这个做法，我们依赖 JVM 在加载这个类时马上创建此唯一的单件示例。JVM 保证在任何线程访问 <code>uniqueInstance</code> 静态变量之前，一定先创建此实例。</p><h2 id="双重检查加锁">双重检查加锁</h2><p>利用双重检查加锁（doule-checked locking），首先检查是否实例已经创建了，如果尚未创建，”才“进行同步。这样一来，只有第一次会同步，这正是我们想要的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// volatile 关键词确保，当uniqueInstance变量被初始化成实例时，</span></span><br><span class="line">    <span class="comment">// 多个线程正确地处理uniqueInstance变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;  <span class="comment">// 进入区块后，再检查一次</span></span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果性能是你关心的终点，那么这个做法可以帮你大大地减少 <code>getInstance()</code> 的时间耗费。</p><h2 id="iodh">IoDH</h2><p>一种被称为 Initialization Demand Holder（IoDH）的技术同样可以帮助我们达到双重锁定的效果。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HolderClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HolderClass.uniqueInstance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>加载 <code>Singleton</code> 时，由于 <code>uniqueInstance</code> 不是其成员变量，因此不会实例化。只有第一次调用 <code>getInstance</code> 时，才会加载内部类 <code>HolderClass</code>。其内部有一个 static 修饰的成员变量 <code>uniqueInstance</code>，此时会初始化这个成员变量，由 JVM 负责其线程安全性。</p><h1 id="问答">问答</h1><p><strong>问：</strong>难道我不能创建一个类，把所有的方法和变量都定义为静态的，把类直接当做一个单件？</p><p><strong>答：</strong>如果你的类自给自足，而且不依赖于复杂的初始化，那么你可以这么做。但是，因为静态初始化的控制权是在 Java 手上，这么做有可能导致混乱，特别是当有许多类牵涉其中的时候。这么做常常会造成一些微妙的、不容易发现的和初始化有关的 bug。<strong>除非你有绝对的必要使用类的单件，否则还是建议使用对象的单件，比较保险。</strong></p><p><strong>问：</strong>听说两个类加载器（class loader）可能有机会各自创建自己的单件实例。</p><p><strong>答：</strong>是的。每个类加载器都定义了一个命名空间，如果有两个以上的类加载器，不同的类加载器可能会加载同一个类，从整个程序来看，同一个类会被加载多次。如果这样的事情发生在单件上，就会产生多个单件并存的怪异现象。所以，<strong>如果你的程序有多个类加载器又同时使用了单件模式，请小心。有一个解决办法：自行指定类加载器，并指定同一个类加载器。</strong></p><p><strong>问：</strong>单件有没有违反“一个类，一个责任”的原则呢？</p><p><strong>答：</strong>是违反了。单件类不只负责管理自己的实例，还在应用程序中担当角色，所以也可以被视为两个责任。尽管如此，由类管理自己的实例的做法并不少见。这可以让整体设计更简单。更何况，许多开发人员都已经熟悉了单件模式的这种做法。</p><h1 id="要点">要点</h1><ul><li>单件模式确保程序中一个类最多只有一个实例。</li><li>单件模式也提供访问这个实例的全局点。</li><li>在 Java 中实现单件模式需要私有的构造器、一个静态方法和一个静态变量。</li><li>确定在性能和资源上的限制，然后小心地选择适当的方法来实现单件，以解决多线程问题（我们必须认定所有的程序都是多线程的）。</li><li>小心，你如果使用多个类加载器，可能导致单件失效而产生多个实例。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Head First Design Patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式</title>
      <link href="/notes/head-first-design-patterns/factory-pattern/"/>
      <url>/notes/head-first-design-patterns/factory-pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="导入比萨店">导入：比萨店</h1><p>身为比萨店的主人，你的代码可能这么写：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Pizza <span class="title">orderPizza</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Pizza pizza = <span class="keyword">new</span> Pizza();</span><br><span class="line"></span><br><span class="line">    pizza.prepare();</span><br><span class="line">    pizza.bake();</span><br><span class="line">    pizza.cut();</span><br><span class="line">    pizza.box();</span><br><span class="line">    <span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="当看到-new就会想到具体">当看到 &quot;new&quot;，就会想到具体</h2><p>是的，当使用 &quot;new&quot; 时，你的确是在实例化一个具体类，所以用的的确是实现，而不是接口。</p><p>当你需要更多比萨类型时，通常会写出这样的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Pizza <span class="title">orderPizza</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">    Pizza pizza;</span><br><span class="line">    <span class="comment">// 这是变化的部分，随着时间过去，比萨菜单改变，这里必须一改再改</span></span><br><span class="line">    <span class="keyword">if</span> (type.equals(<span class="string">"cheese"</span>)) &#123;</span><br><span class="line">        pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"greek"</span>)) &#123;</span><br><span class="line">        pizza = <span class="keyword">new</span> GreekPizza();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"pepperoni"</span>)) &#123;</span><br><span class="line">        pizza = <span class="keyword">new</span> PepperoniPizza();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里是不变的部分</span></span><br><span class="line">    pizza.prepare();</span><br><span class="line">    pizza.bake();</span><br><span class="line">    pizza.cut();</span><br><span class="line">    pizza.box();</span><br><span class="line">    <span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当代码使用大量的具体类时，等于是自找麻烦，因为一旦加入新的具体类，就必须修改代码。也就是说，你的代码并非“对修改关闭”。</p><a id="more"></a><h2 id="简单工厂">简单工厂</h2><img src="http://www.plantuml.com/plantuml/svg/RO_13e8m44Jl_Oezwe4_C5vCz4fYuhsK4HgeD4jD1FNVBPJ49U7Kvitix6njIn2S3mCvk0AiweaOowQ5CgtkUyhjEEfhw1ZqLaHNwtoB6PwrYNYWUtgZs749dhNTNdsNW8s9ASWmTC3Vh8i-SDJJmjdY6LupeanKw2Pzp3CaqBt4abCDz2bj8JTKbLsH2mED13cy1tSFcw2uD3jkr5ORbqIZ6AR39yjMNGIMXGGMhGHTL_i1"><p><strong>问</strong>：这样做有什么好处？似乎只是把问题搬到另一个对象罢了，问题依然存在。</p><p><strong>答</strong>：<code>SimplePizzaFactory</code> 可以有许多的客户。虽然目前只看到 <code>orderPizza()</code> 方法是它的客户。我们也正把具体实例化的过程，从客户的代码中删除。当以后实现改变时，只需修改这个工厂类即可。</p><p><strong>问</strong>：我曾看过一个类似的设计方式，把工厂定义成一个静态的方法，这有何差别？</p><p><strong>答</strong>：利用静态方法定义一个简单的工厂，这是很常见的技巧，常被称为静态工厂。但请记住，这也有缺点，不能通过继承来改变创建方法的行为。</p><p><strong>简单工厂其实不是一个设计模式，反而比较像是一种编程习惯。</strong>有些开发人员的确是把这个编程习惯误认为是“工厂模式”（Factory Pattern）。</p><h1 id="加盟比萨店">加盟比萨店</h1><p>身为加盟公司经营者，你希望确保加盟店营运的质量，所以希望这些店都是用你那些经过时间考验的代码（<code>PizzaStore</code>）。</p><p>但是区域的差异呢？每家加盟店都可能想要提供不同风味的比萨（比如说纽约、芝加哥、加州），这受到了开店地点及该地区比萨美食家口味的影响。</p><h2 id="多个简单工厂">多个简单工厂</h2><p>如果利用 <code>SimplePizzaFactory</code>，写出三种不同的工厂，分别是 <code>NYPizzaFactory</code>、<code>ChicagoPizzaFactory</code>、<code>CaliforniaPizzaFactory</code>，那么各地加盟店都有合适的工厂可以使用，这是一种做法。</p><img src="http://www.plantuml.com/plantuml/svg/ZLAzRi8m4Dxz53VIWLTWGUfOLMBgU357OzMkeukH-2dlZeaXiPshO4hq_UdkyxLcIq2k2qTmv1fYrTuGRLXRKjfYtyEdEPrm4pmJd1N0nhZEqW2-euxm4NRf6qdFM-A1MxofoptWuwjGtq8q4mQgXUlMQFpshwhHcftdNuDF3TZqWIEVTXaa7LE7J946QF0d_UXzI80_5FElMw8-vKsOHPSZz-7dqWTHwyVn1Sl4ZQxi6PRBLLLgpGfDpYHYVQfODWh_LgaqbMsSm_Er9LPqIWNy8v3yrLcbKl8kPS5Og7HjMNTvqZFfb2dVPDbtaVoIuP5_1G00"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NYPizzaFactory nyFactory = <span class="keyword">new</span> NYPizzaFactory();  <span class="comment">// 创建一个工厂</span></span><br><span class="line">PizzaStore nyStore = <span class="keyword">new</span> PizzaStore(nyFactory);   <span class="comment">// 建立一个比萨店，将纽约工厂的引用作为参数</span></span><br><span class="line">nyStore.orderPizza(<span class="string">"Cheese"</span>);  <span class="comment">// 制造纽约风味的比萨</span></span><br></pre></td></tr></table></figure><h2 id="更具弹性的设计">更具弹性的设计</h2><p>在推广 <code>SimpleFactory</code> 时，你发现加盟店的确是采用你的工厂创建比萨，但是其他部分，却开始采用他们自创的流程：烘烤的做法有些差异、不要切片、使用其他厂商的盒子。你希望能够给建立一个框架，把加盟店和创建比萨捆绑在一起的同时又保持一定的弹性。</p><p>我们先解决第一个问题：让你的加盟店可以采用各自的流程。很简单，提取出一个抽象比萨店即可。</p><img src="http://www.plantuml.com/plantuml/svg/ZP6z3i8m38HtFuL76Fe6Y0M94I5rOdI3eH6DKhb1eloyEst3Jqg2O6frzyNodKkzPMHJknODcu85obvHMbJ5G4NZX9J3jJwVANTM62-0c6jJLpo8oywsqkBEVplJofPby2PJk86gg6bmjSbT-tZodfD45wLMjBT_ywlDQ96UKyBa-ClWd_GuzO3KmZK9TpPYGGV_euxE2_OqMcTHCZT-tbkho8JAOvSOVHelFgXWTisokCc8I1S8yGcoRFxH7dmfloSJzS4eR4TTvxuq21A7SXmxvQPUVbpPhnxMbmPUDQQE7wGA9_r2dpFl"><p>解决我们的第二个问题：把加盟店和创建比萨捆绑在一起。做法是在比萨店中使用一个抽象的方法代替原来的工厂对象。</p><img src="http://www.plantuml.com/plantuml/svg/fL513e8m4Bpt5NlKGtzWk7Wt9fuyBdKZn1B8KXD1-RkK0bPQ4usNjZixdSvEi_n4G4Lb6YYeI8b5PX6Liz8aCAqDepAmpziM3wPaWhi0Lq9brxug-KGyGAjrNzwdMnqe9ZJqQbLC5J8DvnGlxg2knW7bhTyxeJJMDUoE1zDe-kNXvMjEU1BSPhd2S_ctwkYxMuGp2FqqtpOZgftm2zDO-CXeEgHEZPdlZRHvI1dc5p3YWOWtOo3b8t432i-T3uSMOztOpV2BfKmMmNpap8D_-5TBYwJt1JiMgUqFvHC0"><p><code>NYStylePizzaStore</code> 的工厂方法应该像这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">    Pizza pizza;</span><br><span class="line">    <span class="keyword">if</span> (type.equals(<span class="string">"cheese"</span>)) &#123;</span><br><span class="line">        pizza = <span class="keyword">new</span> NYCheesePizza();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"clam"</span>)) &#123;</span><br><span class="line">        pizza = <span class="keyword">new</span> NYClamPizza();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义工厂方法">定义工厂方法</h2><blockquote><p><strong>工厂方法模式</strong>定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。</p></blockquote><p>所谓的“决定”，并不是指模式允许子类本身在运行时做决定（工厂子类能生产的产品在编写时就已经固定了），而是指在编写创建者 <code>Creator</code> 类时，不需要知道实际创建的产品是哪一个。选择了使用哪个子类，自然就决定了实际创建的产品是什么。</p><img src="http://www.plantuml.com/plantuml/svg/POux3i8m38RtdC8Z3Br1jyu8hk0wHedK99LZXghaxYrIWo1TBFdx7xRpbe73h0i43YEBSHz2NcXYWsDMGL9uIB8lKaCJvWn3YYIiNEdNDWYZ9e7L0AoL5dZkCyboOtN9NgwxYF4-iw3w5FUzDBs_DMsscECgzE-kExrIet_Y0KrZXlvasG00"><p><strong>问</strong>：当只有一个 <code>ConcreteCreator</code> 的时候，工厂方法模式有什么优点？</p><p><strong>答</strong>：尽管只有一个具体创建者，工厂方法模式依然很有用，因为它<strong>帮助我们将产品的“实现”从“使用”中解耦</strong>。如果增加产品或者改变产品的实现，<code>Creator</code> 并不会受到影响（因为 <code>Creator</code> 与任何 <code>ConcreteCreator</code> 之间都不是紧耦合）。</p><p><strong>问</strong>：如果说纽约和芝加哥的商店是利用简单工厂创建的，这样的说法是否正确？看起来倒是很像。</p><p><strong>答</strong>：他们很类似，但用法不同。<strong>在工厂方法中，工厂是一个抽象的方法，由每个子类自行负责方法的行为。在简单工厂中，工厂是另一个对象。</strong></p><h1 id="一个很依赖的比萨店">一个很依赖的比萨店</h1><p>假设你从未听过 OO 工厂。下面是一个不使用工厂模式的比萨店版本。数一数，这个类所以来的具体比萨对象有几种。如果又加了一种加州风味比萨到这个比萨店中，那么届时又会依赖几个对象？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependentPizzaStore</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String style, String type)</span> </span>&#123;</span><br><span class="line">        Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (style.equals(<span class="string">"NY"</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (type.equals(<span class="string">"cheese"</span>)) &#123;</span><br><span class="line">                pizza = <span class="keyword">new</span> NYCheesePizza();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"veggie"</span>)) &#123;</span><br><span class="line">                pizza = <span class="keyword">new</span> NYVeggiePizza();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (style.equals(<span class="string">"Chicago"</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (type.equals(<span class="string">"cheese"</span>)) &#123;</span><br><span class="line">                pizza = <span class="keyword">new</span> ChicagoCheesePizza();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"veggie"</span>)) &#123;</span><br><span class="line">                pizza = <span class="keyword">new</span> ChicagoVeggiePizza();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Error: invalid type of pizza"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你直接实例化一个对象时，就是在依赖它的具体类。如果把这个版本的比萨店和它依赖的对象画成一张图，看起来是这样的：</p><img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYoW2996SM9UUaSYNd91ONAmHaLbKbSkNbbwGg56McPvHOAJpPD_V5rcbFTlKzwsnuDgVp-QoMP-kdl9YmukdwdIysBdo_foScx-di1Kzsx7gwhldvx2tF-fO-xPZzTFUk5_jdFjar6rdjuuOcBh3v2hgwTWf-aSuPgQd5gH0RaSN3KjFJCp74dJCoanFJyx5hWaeYwGG0"><h2 id="依赖倒置原则">依赖倒置原则</h2><blockquote><p>要依赖抽象，不要依赖具体类。</p></blockquote><p>首先，这个原则听起来很像是“针对接口编程，不针对实现编程”，不是吗？的确很相似，然而<strong>这里更强调“抽象”。</strong>这个原则说明了：不能让高层组件依赖低层组件，而且，不管高层或低层组件，“两者”都应该依赖于抽象。</p><p><code>PizzaStore</code> 是“高层组件”，而比萨实现是“低层组件”。非常依赖比萨店的主要问题在于：它依赖每个比萨类型。因为它是在自己的 <code>orderPizza()</code> 方法中，实例化这些具体类型的。</p><p>虽然我们创建了一个抽象，也就是 <code>Pizza</code>，但我们仍然在代码中，实际地创建了具体的 Pizza，所以，这个抽象没什么影响力。</p><p>如何在 <code>orderPizza()</code> 方法中，将这些实例化对象的代码独立出来？工厂方法刚好能派上用场。</p><img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYoW2996SM9UUaSYKc5PSK9IQNA0HaLbKb1fVa5wLovUMNf2eKPQPdb5WfFDatzyNMQKzsD3pPiUfPrzuN6nS-txWRJHSNGg-2hguTig22JOskhe9Vf7D6QcfnAZQ9dCHS367dZCpanFHy79fWiZ2T0000"><p>在应用工厂方法之后，高层组件（<code>PizzaStore</code>）和低层组件（也就是这些比萨）都依赖了 <code>Pizza</code> 抽象。想要遵循依赖倒置原则，工厂方法并非是唯一的技巧，但却是最有威力的技巧之一。</p><h2 id="指导方针">指导方针</h2><p>下面的指导方针，能帮你避免在 OO 设计中违反依赖倒置原则：</p><ul><li>变量不可以持有具体类的引用。如果使用 <code>new</code>，就会持有具体类的引用。你可以改用工厂方法来避开这样的做法。</li><li>不要让类派生自具体类。如果派生自具体类，你就会依赖具体类。请派生自一个抽象（接口或抽象类）。</li><li>不要覆盖基类中已实现的方法。如果覆盖基类已实现的方法，那么你的基类就不是一个真正适合被继承的抽象。基类中已实现的方法，应该由所有的子类共享。</li></ul><p>要完全遵守这些指导方针不太可能，正如同我们的许多原则一样，应该尽量达到这个原则，而不是随时都要遵循这个原则。</p><p>如果你深入体验这些方针，将这些方针化成你思考的一部分，那么在设计时，你将知道何时有足够的理由违反这样的原则。比方说，如果有一个不像是会改变的类，那么在代码中直接实例化具体类也就没什么大碍。想想看，我们平常还不是在程序中不假思索地就实例化字符串对象吗？就没有违反这个原则？当然有！可以这么做吗？可以！为什么？因为字符串不可能改变。</p><p>另一方面，如果有个类可能改变，你可以采用一些好技巧（例如工厂方法）来封装改变。</p><h1 id="确保原料的一致">确保原料的一致</h1><p>比萨店成功的关键在于新鲜、高质量的原料，而且通过导入新的框架，加盟店将遵循你的流程，但是有一些加盟店，使用低价原料来增加利润。你必须采取一些手段，以免长此以往毁掉了比萨店的品牌。</p><p>你打算建造一家生产原料的工厂，并将原料运送到各家加盟店。对于这个做法，现在还剩下了一个问题：加盟店坐落在不同的区域，纽约的红酱料和芝加哥的红酱料是不一样的。</p><h2 id="原料家族">原料家族</h2><p>纽约使用一组原料，而芝加哥使用另一组原料。可能不久之后加州就有加盟店了，到时候又需要运送另一组区域的原料。想要行得通，必须先清楚如何处理原料家族。</p><img src="http://www.plantuml.com/plantuml/svg/RP8zJWCn48NxFSLSm3T0D45qaH2aGnGJPxIsuf_8zXOiuG9fgP5eu12HE4uKZW74krcFeTmte_dUUrwbLmHaD-aHBDabXKRzAb87QQZ1PKm1POAPGHkdppliP36zybshYcL55AdPe5nZIt3SVnxt7_3K04Y3CS9reAZonL6QOz0E0-R3exfGsir25rC6ZF8jjQr6vmVEyvdqjNizxDuEB-yCvdjod7PZEhlm5fF_mvFhVu1pt_SOo1Wy8qy7uM8hH1c7gHFtHCao3reCQa-L5n1YUpaKpMif9xoPF1airndOS8e0ulxd1rYHUn1r_SnwkLUzHv6ykiRAhGANgxNNRm00"><h2 id="建造原料工厂">建造原料工厂</h2><p>我们要建造一个工厂来生产原料，这个工厂将负责创建原来家族中的每一种原料。也就是说，工厂将需要生产面团、酱料、芝士等。开始先为工厂定义一个接口，这个接口负责创建所有的原料。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PizzaIngredientFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dough <span class="title">createDough</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sauce <span class="title">createSauce</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cheese <span class="title">createCheese</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Clams <span class="title">createClam</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span> Veggies[] createVeggies();    <span class="comment">// 这里还有新的原料</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pepperoni <span class="title">createPepperoni</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来要做的事情是：</p><ol type="1"><li>为每个区域建造一个工厂。你需要创建一个继承自 <code>PizzaIngredientFactory</code> 的子类来实现每一个创建方法。</li><li>实现一组原料类功工厂使用。这些类可以在合适的区域间共享。</li><li>然后你仍然需要将这一切组织起来，将新的原料工厂整合进旧的 <code>PizzaStore</code> 代码中。</li></ol><img src="http://www.plantuml.com/plantuml/svg/dLJFI-D05BxFN_7mf8TKzggo5sN1mow2NiJTmvYEJTXc8fFfGMj1PRMu-6F18ee7MN2t8EoXfzPMxHzZ9gad_mMJcOZfR9E5FOMyzxtllU_BHooxI80uwtm37EAi4eQik6BQp2mJX5Szph39OH5NpDJhd5ifMSWiOy-3ZvZP53Ei8AgsPDbqbbKydWOkb2lEakjWxcfGysiAQrDEs1es2IpOcvjudfOOATg4yW_HOfTjG1K1L5ylgO792EP4pevFZ6h9PL6hbYpyj2o9H_BgPACPPgEJSSdzVvetMwCH8aSonAwfPmIGR52K7e7w7k197qTebcpZ4r25oKa86otnvqVOwWr-xuUNPr3JBunWoPx2K7qw1KsE_mkQr6De3MM8c36Kq2aGpKPmS2xQlyJnRjYuyhjDSNmLd5qWPOHXl4-YzVQkigBqpcmPXfQtL4FFbt9CjlIG3RVIKSsIi5KeP2Ld2i9UCpZe1z_l1wsVIbmkJrv-K5OyOo-qM_EWGov55qgp_SvssFiczjh-_Mdi_UaEoiroJAIx-iy1tMlgSW9ZVgVxjDCNUqVYya5StmpwzQ3TzczRptU7d-cWV_5KFnGdDs6Z9-fTlxllTwx3vf4An-FsxXXW3-Wxf7538Ivcsi3iaiLNelzPaT0lHhxj-R8qfdJqz9uyx0K0"><h2 id="定义抽象工厂">定义抽象工厂</h2><blockquote><p><strong>抽象工厂模式</strong>提供一个接口，用于创建相关或依赖对象的<strong>家族</strong>，而不需要明确指定具体类。</p></blockquote><p>抽象工厂允许客户使用抽象的接口来创建一组相关的产品，而不需要知道实际产出的具体产品是什么。这样一来，客户就从具体的产品中被解耦。</p><img src="http://www.plantuml.com/plantuml/svg/bLEzJiCm4Dxz53V2a4Zs25Mak18pEs98dIk9b9_ACKELHW89dg3iZ3m22CJRfEfh4DeaJMCdb26oxZv_ttVdkmIXZu3nGYqXndY6aWI_6H5A4I7nPfcIdb1mBLF_NYWN9fCmKIZdda37qN3UmqNaPLbBPiSnfpsy5tD6MYrmQwUhwalbyjW7SWAGDyKK82Hw2XlPi_CHb5TeKVjEqwJ25DOUT2Thq3fLWFr3e7t9QHHYedRCVi_p_MdGXBm1xJvq2ON1SOZ0zuI2QEzjrPMHka3BSjf16N8kEQpCoh8wEs3EKt9OeKwUiu4yrIjSsROsmfDkCQ9DljiT7OLTUW7RbzVoywtyUDX-FMsUtyllTHLkrez4MuWkaOt2t5IL3Ey2TLFzeJucjzQVVJ2DeKzdu0R_0G00"><h2 id="工厂方法潜伏在抽象工厂里面">工厂方法潜伏在抽象工厂里面</h2><p>是的，抽象工厂的方法经常以工厂方法的方式实现。抽象工厂的任务是定义一个负责<strong>创建一组产品的接口</strong>（<code>createProductA</code>、<code>createProductB</code>）。这个接口内的<strong>每个方法</strong>都负责创建一个具体产品，同时我们利用抽象工厂的子类来提供这些具体的做法。所以，在抽象工厂中利用工厂方法实现生产方法是相当自然的做法。</p><h1 id="要点">要点</h1><ul><li>所有的工厂都是用来封装对象的创建。</li><li>简单工厂，虽然不是真正的设计模式，但仍不失为一个简单的方法，可以将客户程序从具体类中解耦。</li><li><strong>工厂方法使用继承：把对象的创建委托给子类，子类实现工厂方法来创建对象。</strong></li><li><strong>抽象工厂使用对象组合：对象的创建被是现在工厂接口所暴露出来的方法中。</strong></li><li>工厂方法允许类将实例化延迟到子类进行。</li><li>抽象工厂创建相关的对象家族，而不需要依赖它们的具体类。</li><li>依赖倒置原则，知道我们避免依赖具体类型，而要尽量依赖抽象类型。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Head First Design Patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰者模式</title>
      <link href="/notes/head-first-design-patterns/decorator-pattern/"/>
      <url>/notes/head-first-design-patterns/decorator-pattern/</url>
      
        <content type="html"><![CDATA[<p>本章可以成为 <strong>“给爱用继承的人一个全新的设计眼界”。</strong>我们即将再度探讨典型的继承滥用问题。你将在本章学到如何使用对象组合的方式，做到在运行时装饰类。一旦你熟悉了装饰的技巧，你将能够在不修改任何底层代码的情况下，给你的（或别人的）对象赋予新的职责。</p><h1 id="导入星巴兹咖啡">导入：星巴兹咖啡</h1><p>星巴兹（Starbuzz）是以扩张速度最快而闻名的咖啡连锁店。因为扩张速度实在太快了，他们准备更新订单系统，以合乎他们的饮料供应系统。他们原先的类设计是这样的……</p><img src="http://www.plantuml.com/plantuml/svg/ROyn2i90403xUyMMMaW-O1KYMFk3osKrmSGBjwSWCM2XXRrQYBNO2uBu6z7a6oPgeeR0DZV3xR2kvo1W4Eef11ZOg9YR4-4fuIFZDcd5XGOJ9wZu025Y00wIK5weFJdANWFKrXSqcXcAYdyn24dwpGBKhdHYC0nuBC_twpRPhzBrCTqjakqbEMrkyqCsB6R2vqJGbMD2qyUHysf-zXJMuchOavnqhKJ1-tMYGw528ldlojlQirRhfriHPRBAyrg55Q4d"><p>购买咖啡时，也可以要求在其中加入各种调料，例如：蒸奶（Steamed Milk）、豆浆（Soy）、摩卡（Mocha，也就是巧克力风味或覆盖奶泡（Whip）。星巴兹会根据所加入的调料收取不同的费用。所以订单系统必须考虑到这些调料部分。</p><p>利用实例变量和继承，追踪这些调料。</p><img src="http://www.plantuml.com/plantuml/svg/RL5DIyD04BtdLyonHThYiUYfLF3YHG-Ujvkn2KswOMUhb1WGr4EleX75YpTFHH4KwT-fIVqNJbgprk1fvhqt7szsFTz5m30oOmWnxA5sl8AHlfO1Eg97HWjfe8F7g4KV8NO0N2If_SZuQiWez8C11rBZ0YZf2OuddXznwAFf_XRNwan9HQPMXnXQBLXC7_FfRJOvonucY-VpBBtBxo_ci_UlgnT872xs1Etn-6KZeR4vymTgND9bMbGN-ssv1QmSigDI-CaPn24QJxb9uURpycq-IzbAVlt4FhBq8tkzSH971e88TjM8i1FWq5s-mUeCgtQ57kmhGMPDv1ircf4UmcQptOODe564khaIj_X0sunI7FqtTOSYZKJghsR_OlkqqLZpLH6ifIfVRAjmvQ9l"><p>当哪些需求或因素改变时会影响这个设计？</p><ul><li>调料价钱的改变会使我们更改现有代码。（这个比较好解决，增加设置调料价格的 <code>setter</code> 方法即可）</li><li>一旦出现新的调料，我们就需要加上新的方法，并改变超类中的 <code>cost()</code> 方法。（无解）</li><li>以后可能会开发处新饮料，对这些饮料而言（例如，冰茶），某些调料可能并不合适，但是在这个设计方式中，Tea 子类仍将继承哪些不适合的方法，例如：<code>hasWhip()</code>。</li><li>万一顾客想要双倍摩卡咖啡，怎么办？（这个也比较好解决，将 <code>soy</code> 的类型设置为 <code>int</code>）</li></ul><a id="more"></a><h1 id="开放-关闭原则">开放-关闭原则</h1><blockquote><p>类应该对扩展开放，对修改关闭。</p></blockquote><p>我们的目标是允许类容易扩展，在不修改现有代码的情况下，就可搭配新的行为。如果实现这样的目标，有什么好处呢？这样的设计具有弹性可以应对改变，可以接受新的功能来应对改变的需求。</p><p><strong>问</strong>：我如何让设计的每个部分都遵循开放-关闭原则？</p><p><strong>答</strong>：通常，你办不到。遵循开放-关闭原则，通常会引入新的抽象层次，增加代码的复杂度。你需要把注意力集中在设计中最有可能改变的地方，然后应用开放-关闭原则。</p><h1 id="装饰者模式">装饰者模式</h1><blockquote><p><strong>装饰者模式</strong>动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p></blockquote><p>装饰者模式完全遵循开放-关闭原则：我们以饮料为主体，然后在运行时以调料来”装饰“（decorate）饮料。比方说，如果顾客想要摩卡和奶泡深焙咖啡，那么，要做的是：</p><ol type="1"><li>拿一个深焙咖啡（DarkRoast）对象</li><li>以摩卡（Mocha）对象装饰它</li><li>以奶泡（Whip）对象装饰它</li><li>调用 <code>cost()</code> 方法，并依赖委托（delegate）将调料的价钱加上去</li></ol><h2 id="装饰我们的饮料">装饰我们的饮料</h2><img src="http://www.plantuml.com/plantuml/svg/fLAxJiD04Epz5Li6eJX05nvD218D3HJKv_CIdsBxhBiBKcJS1Gaw2aY1-01w92IKto7ER-2pOplnGqZGsJEpktEpwp0R0Rr0JS53pq9XE1gXJ50N3M999GXLCC1R56I441e0DaegMA0OzvE_4QfX2NHs4YZCwoAWNAeCyr0vt8wWruFb_UVtOXw_FQwUtrUlitZ-5N-y6951NI8bdFE9n86BlfrEMtV8sI4HuqjEfDeW8GI1QY9ys3Vx_IE8IZLISjFKvam60gNasrpntbFksyn3FtaQvO8eBb9X4OEr_aYmkhHJohIrN0idO6blM_dKqiiDNZ1tt3gpIBMzd5E7_59VncOUxC5k8J0pElFQEk6AJ__XxzfXmP_A2_tnNRUxSIiLeZYJAguFeeBbjr21wulT43JoXx1Qp9PF3qR3-QGjzLBRIRsoLZQ9kvNJOVu0"><p>如果有一张单子点的是：“双倍摩卡豆浆奶泡拿铁咖啡”，它的价钱是？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">beverage = <span class="keyword">new</span> HouseBlend();</span><br><span class="line">beverage = <span class="keyword">new</span> Mocha(beverage); <span class="comment">// 用摩卡装饰</span></span><br><span class="line">beverage = <span class="keyword">new</span> Mocha(beverage); <span class="comment">// 用第二个摩卡装饰</span></span><br><span class="line">beverage = <span class="keyword">new</span> Soy(beverage);   <span class="comment">// 用豆浆装饰</span></span><br><span class="line">beverage = <span class="keyword">new</span> Whip(beverage);  <span class="comment">// 用奶泡装饰</span></span><br><span class="line">System.out.println(<span class="string">"$"</span> + beverage.cost());  <span class="comment">// 饮料的价格</span></span><br></pre></td></tr></table></figure><p><code>CondimentDecorator</code> 扩展自 <code>Beverage</code> 类，这用到了继承。这么做的终点在于，<strong>装饰者和被装饰者必须是一样的类型</strong>，也就是有共同的超类，这相当关键的地方，因为装饰者必须能取代被装饰者。在这里，我们利用继承达到“类型匹配”，而不是利用继承获得“行为”。行为来自装饰者和基础组件，或与其他装饰者之间的组合关系。正是因为使用对象组合，可以把所有饮料和调料有弹性地加以混合。</p><h1 id="真实世界的装饰者java-io">真实世界的装饰者：Java I/O</h1><img src="http://www.plantuml.com/plantuml/svg/TPAnJiCm48PtFuNLFPNeY10I5KAgL24aHiJW99V6Qc8gsnaYCJ2GXPKdG8WT5XYglas1y1OaSHIvyNcB__y_t_dBfJm62lb6bpI7F0H9qbQ9k8mo82nKMh98quNO5FfQIs0v4NSQQ0Q9FgO_Jxlwu-Lt-xZVVf8eOqhH2vw1dJPgS-1YDI-I1AJhpaiDPrAoqhQ6tisD-h2gcq3oLJgCKBzMVs_lzKFLttXLg3HaqHhfrSq0iUkSCyrSTSa5N1Oj6Tkplkd9VH0uptO2FW9E48M1zHj1SHGJn4XueXWQJtJCoXF3uOrOqU2csRaOnEsfbv97jqjHRfXe5tbsQ_9TVUrtpsQn9vGfAeuEd67VZ3bptZITjYM-iOsB3jTRxg_ed1aPaUzL57Jl8HjWd7y0"><p>和星巴兹的设计相比，<code>java.io</code> 其实没有多大的差异。你会发现“输出”流的设计也是一样的。你可能还会发现 Reader/Writter 流（作为基于字符数据的输入和输出）和输入流/输出流的类相当类似（虽然有一些小差异和不一致之处，但是相当雷同，所以你应该可以了解这些类）。</p><p>Java I/O 也引出装饰者模式的一个“缺点”：利用装饰者模式，常常造成设计中有大量的小类，数量实在太多，可能会造成使用此 API 程序员的困扰。但是，现在你已经了解了装饰者的工作原理，以后当使用别人的大量装饰的 API 时，就可以很容易地辨别出他们的装饰者类是如何组织的，以方便用包装方式取得想要的行为。</p><h2 id="编写自己的-java-io-装饰者">编写自己的 Java I/O 装饰者</h2><p>编写一个装饰者，把输入流内的所有大写字符转成小写。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先，扩展FilterInputStream</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LowerCaseInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LowerCaseInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 针对字节的 read() 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="keyword">super</span>.read();</span><br><span class="line">        <span class="keyword">return</span> (c == -<span class="number">1</span> ? c : Character.toLowerCase((<span class="keyword">char</span>) c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 针对字节数组的 read() 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> offset, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="keyword">super</span>.read(b, offset, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = offset; i &lt; offset + result; i++) &#123;</span><br><span class="line">            b[i] = (<span class="keyword">byte</span>)Character.toLowerCase((<span class="keyword">char</span>)b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream in =</span><br><span class="line">                <span class="keyword">new</span> LowerCaseInputStream(</span><br><span class="line">                    <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>)));</span><br><span class="line">            <span class="keyword">while</span> ((c = in.read()) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println((<span class="keyword">char</span>)c);</span><br><span class="line">            &#125;</span><br><span class="line">            in.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="要点">要点</h1><ul><li>继承属于扩展形式之一，但不见得是达到弹性设计的最佳方案。</li><li>组合和委托可用于在运行时动态地加上新的行为。</li><li>装饰者模式意味着一群装饰者类，这些类用来包装具体组件。</li><li>装饰者类反映出被装饰的组件类型（事实上，他们具有相同的类型，都经过接口或继承实现）。</li><li>装饰者可以在被装饰者的行为前面与/或后面加上自己的行为，甚至将被装饰者的行为整个取代掉，而达到特定的目的。</li><li>可以用无数个装饰者包装一个组件。</li><li>装饰者一般对组件的客户是透明的，除非客户依赖于组件的具体类型。</li><li>装饰者会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Head First Design Patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式</title>
      <link href="/notes/head-first-design-patterns/observer-pattern/"/>
      <url>/notes/head-first-design-patterns/observer-pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="导入internet气象观测站">导入：Internet气象观测站</h1><p>气象站建立在 <code>WeatherData</code> 对象上，由 <code>WeatherData</code> 对象负责追踪目前的天气状况（温度、湿度、气压）。我们希望能建立一个应用，有三种布告板，分别显示目前的状况、气象统计以及简单的预报。当 <code>WeatherData</code> 对象获得最新的测量数据时，三种布告板必须实时更新。</p><p>而且，这是一个可以扩展的气象站，我们希望公布一组 API，好让其他开发人员可以写出自己的布告板，并插入此应用中。</p><img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYoW2996SM9UUaSYNd91ONAuId9fPaf1Qv99OaAbHpAIYafvQ40BMa5YMMb1QbQcX2X3nASpDJCaigOVo0ejJYOfXyRceYY9sRcbTIx9oHc9UUcgAXgL2jeA-ly6H7mxFfovvjcF9Yuy9dMxjVjlS_cxtbsRGDx_VqF5kxvDcqdSysJtsoPzQBHQjVR6X-FcM5GYrNBG00"><h2 id="错误示范">错误示范</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 实例变量声明</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measurementsChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">float</span> temp = getTemperature();</span><br><span class="line">      <span class="keyword">float</span> humidity = getHumidity();</span><br><span class="line">      <span class="keyword">float</span> pressure = getPressure();</span><br><span class="line"></span><br><span class="line">      currentConditionsDisplay.update(temp, humidity, pressure);</span><br><span class="line">      statisticsDisplay.update(temp, humidity, pressure);</span><br><span class="line">      forecastDisplay.update(temp, humidity, pressure);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他WeatherData方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个实现中，下列哪种说法正确？（多选）</p><ul><li>[x] A. 我们是针对具体实现编程，而非针对接口。（三个布告板都是实现）</li><li>[x] B. 对于每个新的布告板，我们都得修改代码。</li><li>[x] C. 我们无法在运行时动态地增加（或删除）布告板。</li><li>[ ] D. 布告板没有实现一个共同的接口。（<code>update(temp, humidity, pressure)</code>看恰里像是一个统一的接口）</li><li>[x] E. 我们尚未封装改变的部分。（<code>display.update</code>是会改变的部分）</li><li>[ ] F. 我们侵犯了 <code>WeatherData</code> 类的封装。</li></ul><a id="more"></a><h1 id="观察者模式">观察者模式</h1><p>我们看看报纸和杂志的订阅是怎么回事：</p><ol type="1"><li>报社的业务就是出版报纸。</li><li>向某家报社订阅报纸，只要他们有新报纸出版，就会给你送来。只要你是他们的订户，你就会一直收到新报纸。</li><li>当你不想再看报纸的时候，取消订阅，他们就不会再送新报纸来。</li><li>只要报社还在运营，就会一直有人（或单位）向他们订阅报纸或取消订阅报纸。</li></ol><p>出版者 + 订阅者 = 观察者模式</p><p>只要你了解报纸的订阅是怎么回事，其实就知道观察者模式是怎么回事，只是名称不太一样：出版者改称为“主题”（Subject），订阅者改称为“观察者”（Observer）。</p><h2 id="定义">定义</h2><blockquote><p><strong>观察者模式</strong>定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖着都会收到通知并自动更新。</p></blockquote><img src="http://www.plantuml.com/plantuml/svg/fP31IiD048Rl-nHpr4FQUmcv-00U-WJ9PfAiPBDbTzfIQa74F85Of1T116zw4BHIV9kanhSmjcJRHcyUvvj__lbd4X4Ye1pG12JA03LBVWWNcgV8H4Qe8vyZz8V16N82rxNCys3A03J6mjJeD32eHwYFZZTGgX4Ue4oHY2PxQBPdt-0__8U3q2VSw7dg6mCdAkCQ2Pj8_mfHinYfJziL06PNjFVPZ0Uf0AOIAL7X3BfTAFFNOZMl7Y_Bvxlg8lzSN9NvM_5nlPw_hrzkQiicjAD5d93ZsSjxK3qjouU5dRLIzxmJgd7MQH_ETazhAveEQ__ATLACoFabx46nN7tTttu3"><h2 id="松耦合的威力">松耦合的威力</h2><p><strong>当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节。</strong>观察者模式提供了一种对象设计，让主题和观察者之间松耦合。改变主题或观察者其中一方，并不会影响另一方。因为两者是松耦合的，所以只要他们之间的接口仍被遵守（观察者实现了 <code>Observer</code> 接口），我们就可以自由地改变他们。</p><blockquote><p>为了交互对象之间的松耦合设计而努力。</p></blockquote><p><strong>松耦合的设计之所以能让我们建立有弹性的 OO 系统，能够应对变化，是因为对象之间的互相依赖降到了最低。</strong></p><h2 id="设计气象站">设计气象站</h2><img src="http://www.plantuml.com/plantuml/svg/jLJBJjj05DtxAqQisaM2sA8eKWMjkgXK992wQBkOs9TugjYEnXCgYoAbb8120tr5LLf0K9G8bKL36xKu3-1Zy3XXrL_ev67Nv26wI7VscJFdt7FljLMY008joIoaWHO3AgbjH2PKJe14T0Pq4Sk0vbEnPo0p58duM3IAbYM4xb2AhGV4PCY8cK2NW9e2fH0N4D27FUpMxGwe6Kjm3T8DHXQj0BGICFNW8QvUFSzLO2hGMSomG5D91JFeKvabPZA1hRi9q40Vba3f4ZhNv0GsJVJeh-h_o2YmEB05qNQWcAKeT6W2kf_IY4AOvRtFKJ1Dxrm3t7vkXp1dLAp7GGcKF9EYL9pC6BeG88PkzcB_IxS2BK3BQ78IkONpPh76ppxmx5RhQDNz-Pgd6sZ5Dvjdc8deH1w3YxkRvYTlBjClURN2zpRu-rmRAHurFwyDirvG2LNcC6NM60BkrvpQjkyY77dcbrF_oDSp_5irO7hFe21Zaut1ilZLFSbV7QwvcwMEWISJeYIkib3KN_ff90hZvVrMEYC5zp6SIePVH3rxQUJSUpnFxaRYzS_4hoiI2etShMdasFMhmy9exT1ZyJjHG7yQ7TmPQN2B0lI1EKk3am_G-oOaYMyEq4JhufDZPntxcDkl-BjDT--2r_AjSicnjqULp3EdxcwskMFpjxdEGbIQbVfbUlM9xfojkuNoxqPEgFB60TyvTtzyQNFpTRvH4w1xSEhV43IdNkAPBLuyTghVXS04mYRIfoHz2eN3GxhHnGTZT_6-V7y0"><h1 id="java-内置的观察者模式">Java 内置的观察者模式</h1><p><code>java.util</code> 包内包含最基本的 <code>Observer</code> 接口与 <code>Observable</code> 类，这和我们的 <code>Observer</code> 接口与 <code>Subject</code> 接口很相似。 <code>Observer</code> 接口与 <code>Observable</code> 类使用上更方便，因为许多功能都已经事先准备好了。你甚至可以用“推”（push）或“拉”（pull）的方式传送数据，稍后就会看到这样的例子。</p><img src="http://www.plantuml.com/plantuml/svg/hLDDJnD16BxlhvXmQXEtX2lM9gPeF9ZKH1CFwc6w-z9TizrjPcOr3P1Kf1Am-Db35OX8sX2v56qCIrlWnx2pBIV_WhDTMXRQeWTkCy_xplCyxyTekWe8iZcMHrd8fe58ceyeEb4Ca1G3KufIQGha1KuRWEOaX6uJWlFtTSgGrGi0eGB5gfewkqQYugw20GmkGAR5zDby7wAHLFevA0nXal6Z55XImsO6r4WKpI4bEADRY14RRg85QK7IJGPa5Yk0-YGe7X-0YKJFNiZjImsO1cG6Com2Tax532AXk7K3XJs41MPqcZDm_eu1MJ3P21arI8Zupu8sFJvNkw9F6M2FHB-1O6OJwFL5GFVihAxgBD-_Fo10QH3lqoTjGeILf6MAHDqowPd5_oew6dOikZivYRpAKQVQv8UV-SfQTsVH-_sM5zgzDWTw3nbcmhokN8-Gjr7WU-zF2g_uGODlBlDF9H-fxdI-BerIlsiHK31brrDazOUtLpxTNl9MQpsD49DCz8p6vCHWfQQHyCFhtxg5eXGUgMpdvFb4o8GqTY8nEnURFsVyP-B5PGkxYylosC5F8zTfdMvNfC5da9-8pwk2-Mo8Sgo3q9EXWKl3An1AlpGXIVnkG1FTuo-kKtMTNUwyvXzNlSrZtYntwpNNUJVE0o_kUnihdNM7VoY9RU35HgVHEYaiFZNTmpTUfVwdNHAilBt5ru-yNz_zt7ABBpS5w6tj3rw8DBTLuyKrNjrr3tuAWWc4AJAd97CAnM8ZoWlmItNy1G00"><p>Java 内置的观察者模式运作方式，和我们在气象站中的实现类似，但有一点小差异。最明显的差异是 <code>WeatherData</code> （也就是我们的主题）现在<strong>扩展</strong>自 <code>Observable</code> 类，并继承到一些增加、删除、通知观察者的方法（以及其他方法）。</p><h2 id="可观察者如何送出通知">可观察者如何送出通知</h2><ol type="1"><li>先调用 <code>setChanged()</code> 方法，标记状态已经改变的事实。</li><li>然后调用 <code>notifyObservers()</code> 或 <code>notifyObservers(Object arg)</code>。后者可以传送任何的数据对象给每一个观察者。</li></ol><h2 id="观察者如何接受通知">观察者如何接受通知</h2><p>观察者实现了更新的方法，但是方法的签名不太一样：<code>update(Observable o, Object arg)</code>。主题本身 <code>o</code> 当作第一个变量，好让观察者知道是哪个主题通知它的。<code>arg</code> 正是传入 <code>notifyObservers()</code> 的数据对象，如果没有说明则为空。</p><p>如果你想“推”（push）数据给观察者，你可以把数据当作对象传送给 <code>notifyObservers(arg)</code> 方法。否则，观察者就必须从可观察者对象中“拉”（pull）数据。</p><h2 id="setchanged-是怎么一回事"><code>setChanged()</code> 是怎么一回事</h2><p><code>setChanged()</code> 方法用来标记状态已经改变的事实，好让 <code>notifyObservers()</code> 知道当它被调用时应该通知观察者。让我们看看 <code>Observable</code> 内部，以了解这一切。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setChanged() &#123;</span><br><span class="line">    changed = <span class="keyword">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">notifyObservers(Object arg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">        <span class="keyword">for</span> every observer on the list &#123;</span><br><span class="line">            <span class="function">call <span class="title">update</span> <span class="params">(<span class="keyword">this</span>, arg)</span></span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">        changed </span>= <span class="keyword">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">notifyObservers() &#123;</span><br><span class="line">    notifyObservers(<span class="keyword">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做有其必要性。<code>setChanged()</code> 方法可以让你在通知观察者时，有更多的弹性。比方说，如果没有 <code>setChanged()</code> 方法，我们的气象站测量是如此敏锐，以致于温度计读数每十分之一度就会更新，这会造成 <code>WeatherData</code> 对象持续不断地通知观察者，我们并不希望看到这样的事情发生。如果我们希望半度以上才更新，就可以在温度差距达到半度时，调用 <code>setChanged()</code>，进行有效的更新。你也许不会经常用到此功能，但是把这样的功能准备好，当需要时马上就可以使用。</p><h2 id="java.util.observable-的黑暗面"><code>java.util.Observable</code> 的黑暗面</h2><p>可观察者是一个“类”而不是一个“接口”，更糟的是，它甚至没有实现一个接口。不幸的是，<code>java.util.Observable</code> 的实现有许多问题，限制了它的使用和复用。</p><ul><li><p><code>Observable</code> 是一个类</p><p>首先，因为 <code>Observable</code> 是一个“类”，你必须设计一个类继承它。如果某类相同时具有 <code>Observable</code> 类和另一个超类的行为，就会陷入两难，毕竟 Java 不支持多重继承。再者，因为没有 <code>Observable</code> 接口，所以你无法建立自己的实现，和 Java 内置的 Observer API 搭配使用，也无法将 <code>java.util</code> 的实现换成另一套做法的实现。</p></li><li><p><code>Observable</code> 将关键的方法保护起来</p><p><code>setChanged()</code> 方法被保护起来了（被定义成 <code>protected</code>）。这意味着：除非你继承自 <code>Observable</code>，否则你无法创建 <code>Observable</code> 实例并组合到你的对象中来。这个设计违反了“多用组合，少用继承”的设计原则。</p></li></ul><h1 id="jdk-中的观察者模式">JDK 中的观察者模式</h1><p>在 JDK 中，并非只有在 <code>java.util</code> 中才能找到观察者模式，其实在 JavaBeans 和 Swing 中，也都实现了观察者模式。让我们看看一个简单的 Swing API：JButton。如果你观察一下 JButton 的超类 AbstractButton，你会看到许多增加与删除倾听者（listener）的方法，这些方法可以让观察者感应到 Swing 组建的不同类型事件。比方说：<code>ActionListener</code> 让你“倾听”可能发生在按钮上的动作，例如按下按钮。你可以在 Swing API 中找到许多不同类型的倾听者。</p><h2 id="一个小的改变生活的程序">一个小的、改变生活的程序</h2><p>我们的程序很简单，你有一个按钮，上面写着 &quot;Should I do it?&quot;。当你按下按钮，倾听者（观察者）必须回答此问题。我们实现了两个倾听者，一个是天使（<code>AngelListener</code>），一个是恶魔（<code>DevilListener</code>）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwingObserverExample</span> </span>&#123;</span><br><span class="line">    JFrame frame;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SwingObserverExample example = <span class="keyword">new</span> SwingObserverExample();</span><br><span class="line">        example.go();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        frame = <span class="keyword">new</span> JFrame();</span><br><span class="line"></span><br><span class="line">        JButton button = <span class="keyword">new</span> JButton(<span class="string">"Should I do it?"</span>);</span><br><span class="line">        button.addActionListener(<span class="keyword">new</span> AngelListener());</span><br><span class="line">        button.addActionListener(<span class="keyword">new</span> DevilListener());</span><br><span class="line">        frame.getContentPane().add(BorderLayout.CENTER, button);</span><br><span class="line">        <span class="comment">// 在这里设置frame属性</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AngelListener</span> <span class="keyword">implements</span> <span class="title">ActionListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Dont't do it, you might regret it!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DevilListener</span> <span class="keyword">implements</span> <span class="title">ActionListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Come on, do it!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="要点">要点</h1><ul><li>观察者定义了对象之间一对多的关系。</li><li>主题（也就是可观察者）用一个共同的接口来更新观察者。</li><li>观察者和可观察者之间用松耦合（loosecoupling）方式结合，可观察者不知道观察者的细节，只知道观察者实现了观察者接口。</li><li>使用此模式时，你可从被观察者处推或拉数据。</li><li>有多个观察者时，不可以依赖特定的通知次序。如果我们的代码依赖这样的次序，就是错的。因为一旦观察者/可观察者的实现有所改变（比如为不同的观察者赋予优先级，按优先级大小次序推送），通知次序就会改变，很可能就会产生错误的结果。这绝对不是我们所认为的松耦合。</li><li>Java 有多种观察者模式的实现，包括了通用的 <code>java.util.Observable</code>。</li><li>要注意 <code>java.util.Observable</code> 实现上所带来的一些问题。</li><li>如果有必要的话，可以实现自己的 <code>Observable</code>，这并不难，不要害怕。</li><li>Swing 大量使用观察者模式，许多 GUI 框架也是如此。</li><li>此模式也被应用在许多地方，例如：JavaBeans、RMI。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Head First Design Patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略模式</title>
      <link href="/notes/head-first-design-patterns/strategy-pattern/"/>
      <url>/notes/head-first-design-patterns/strategy-pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="导入鸭子游戏">导入：鸭子游戏</h1><p>鸭子游戏：游戏中会出现各种鸭子，一边游泳戏水，一边呱呱叫。</p><img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYoW2996SM9UUaSYKc5PSK9IQNABYK9cShL7CfA1IM9YPdQsW2MSNbcRbWHZLCLQr2IcPnGKvY9KGuDxKa8p-bLa5VN-7bZhLFrqvuFglbQUks9xkdFPksyzdcgLorNCavYSN52hw9EJc9HIbmE-2cA5I3D3zTCkt5ygPdCzO_txt_wP8j2hLmZK6fAHcfYKHetBK8fX6irgP6LnVPLYHH92C1"><p>现在我们让鸭子会飞。只需要在 <code>Duck</code> 类中加上 <code>fly()</code> 方法，然后所有鸭子都会继承 <code>fly()</code>。</p><img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYoW2996SM9UUaSYKc5PSK9IQNABYK9cShL7CfA1IM9YPdQsW2MSNbcRbWHZLCLQr2IcPnGKvY9LXOIoij1yZIqW8foKqjoSXFgLNGrrTukMFjqxKJdizgUTgwxSdkQS-cxNosUIfNBLToJc9niO9lOavEOb4At3wuYGhL8CrFbqnxiRpfsOprptVlVxfaYq8jN6DGQaf6QY8H6dSjGjDOcWJqDhe78RfUB6jxFdlQiuu9JoTi1A7-rK2DkCr-jdBXyrdhW1u46mysqgP6LnVPKqYYI2v65eKx1m00"><p>但是，可怕的问题发生了，有很多“橡皮鸭子”飞来飞去。在超类中加上 <code>fly()</code>，就会导致所有的子类都具备 <code>fly()</code>，连那些不该具备 <code>fly()</code> 的子类也无法免除。</p><p><strong>当涉及“维护”时，为了“复用”（reuse）目的而使用继承，结局并不完美。</strong></p><a id="more"></a><h2 id="利用继承">利用继承</h2><img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYoW2996SM9UUaSYKc5PSK9IQNABYK9cShL7CfA1IM9YPdQsW2MSNbcRbWXfPMMawbXgQM5f1T3TDHgv2IMLoGarW9LbATcrgIaPzIgw2lh_1onzgdQoSydzNoj7NRaztJdatR-MppLAvQhkISnE9Y1T_4d9p4eXIuVN1J5Af1cfykcVPYUTEp6UkVxzx_TCaMXLgung3Kb8pKH28qxbg4fh4q2UXjT0z2TBrOrlPyzhHd7HEUJjW8GlshWHfnc_rivSBdizO1FGXM1GuLP7FUx-bvihlXoSwE9xkwNpRlVRAZzsdZB2INkAGcvrVYSmWk0p1Sz6BznfTBjvBX4B3jDZMwkiWHWIIA5Ch8el0WH1A4-mO0"><p>鸭子的行为在子类里不断地改变，并且让所有的子类都有这些行为是不恰当的。例子，橡皮鸭子不会飞，假鸭子不会飞也不会叫。每当有新的鸭子类出现，都要被迫检查并可能需要覆盖 <code>fly()</code> 和 <code>quark()</code>。</p><p>利用继承来提供 <code>Duck</code> 的行为，这会导致下列哪些缺点？（多选）</p><ul><li>[x] A. 代码在多个子类中重复。（<code>RubberDuck</code> 和 <code>DecoyDuck</code> 都不会飞）</li><li>[x] B. 运行时的行为不容易改变。（除非修改代码）</li><li>[ ] C. 我们不能让鸭子跳舞。（可以，就如我们让鸭子会“飞”）</li><li>[x] D. 很难知道所有鸭子的全部行为。（唐老鸭：我想说句话）</li><li>[ ] E. 鸭子不能同时又飞又叫。（<code>MallardDuck</code> 和 <code>RedheadDuck</code> 可以又飞又叫）</li><li>[x] F. 改变会牵一发动全身，造成其他鸭子不想要的改变。（橡皮鸭：我本不想飞）</li></ul><h2 id="利用接口">利用接口</h2><img src="http://www.plantuml.com/plantuml/svg/bL3B3W4n5DttA-wI1Nx0Kkmi-8CxxPLfj1vj9p9XTknjMFW7AuaGl-CHVy6C6FM8nAuzhtjoGYa8IFTT39fqG8Q5ASAbuOeO1jOPv0vg4U_0Y07OeTI5ukqnUd0926dx2kCxhCc5FP50fGANxUgucfsNa-DqSzWlJelTQJrd2PDTHwQDdA2kOWmKPSbjbIRuR3D2tidvGVhB55oXjT10fT28l9dVufxrwMcH20d_z4J1RPQlbdTfZNWl_g9CM0PMnwMINzj3lM8-cf_smFm8UwnN7PVBBxalX1_zNFJ3yqRzS3rRNG40"><p><code>Flyable</code> 与 <code>Quackable</code> 接口一开始似乎还挺不错，解决了问题（只有会飞的鸭子才继承 <code>Flyable</code>），<strong>但是 Java 接口不具有实现代码，所以继承接口无法达到代码的复用。</strong>这意味着：无论何时你需要修改某个行为，你必须得往下追踪并在每一个定义此行为的类中修改它，一不小心，可能会造成新的错误。</p><h1 id="封装变化">封装变化</h1><blockquote><p>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</p></blockquote><p>我们知道 <code>Duck</code> 类内的 <code>fly()</code> 和 <code>quack()</code> 会随着鸭子的不同而改变。为了要把这两个行为从 <code>Duck</code> 类中分开，我们将把它们从 <code>Duck</code> 类中取出来，建立一组新类来代表每个行为。</p><img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYoW2996SM9UUaSYNd91ONAxZbL8PdbcI4P-Qb5ojKSoaefELKLjSgL2lewoiyNJVlUT-6bplMFbqxuUNYUIyMzYZKSjKYDFhbXoTMmZHfQ48qFTdTy6HdnylclKzsz3vjdFL-Jm-GyMJFBA01IBe3InEJiy5Q2q4icEQd4pU2KFzg9AN1XQMfYLZKFbkvyFciTH3NFPsm4OHGzFcMbgJYi0QN6w460000"><h1 id="针对接口编程">针对接口编程</h1><p>我们希望一切能有弹性，毕竟，正是因为一开始鸭子行为没有弹性，才让我们走上现在这条路。我们还想能够“指定”行为到鸭子实例。比方说，我们想要生产一个新的绿头鸭实例，并指定特定“类型”的飞行行为给它。干脆顺便让鸭子的行为可以动态地改变好了。换句话说，我们应该在鸭子类中包含设计行为的方法，这样就可以在“运行时”动态地“改变”绿头鸭的飞行行为。</p><blockquote><p>针对接口编程，而不是针对实现编程。</p></blockquote><p>“针对接口编程“真正的意思是”针对超类型（supertype）编程“。”针对接口编程“，关键就在于多态。利用多态，程序可以针对超类型编程，执行时会根据实际情况执行到真正的行为，不会被绑死在超类型的行为上。</p><p>我们利用接口代表每个行为，比方说，<code>FlyBehavior</code> 与 <code>QuackBehavior</code> 而行为的每个实现都将实现其中一个接口。</p><img src="http://www.plantuml.com/plantuml/svg/VL4zRi8m5DvzYZU60JW0b05Lx1p1SLuKYvWaZW55KJROMSh07PYG45MlmuzwYpfEIkqCtUplvttFdoCU8A18LG42XO-IH3N2k6Gn4hvKA4FA46PnCSM8hdaYOJn-uPC9b0GWZ0klHofBFrzHjlZ7aTMyyL0_Lv8o1UyhjZ2SdHN-dJNZJiticsRp3HTw943vExE2WETfJ0i3vwYiqPuJu_UWjCFWJMCZg1gRa-jrjZ1MPnTjpbfpgb-TI35ldjiL3jeQ7EsiBjFTPc0ARbIbG1KbGGN38NnVJ_VJ_ddStdUNszVXSVXyd3zqfvts-trJBd4-iGL_0000"><p>这样的做法迥异于以往，以前的做法是：行为来自 <code>Duck</code> 超类的具体实现，或是继承某个接口并由子类自行实现而来。这两种做法都是依赖于”实现“，我们被实现绑得死死的，没办法更改行为（除非写更多代码）。</p><p>在我们的新设计中，鸭子的子类将使用接口所表示的行为，所以实际的“实现”不会被绑死在鸭子的子类中。特定的具体行为编写在实现了 <code>FlyBehavior</code> 与 <code>QuackBehavior</code> 的类中。</p><h1 id="实现鸭子的行为">实现鸭子的行为</h1><p>在此，我们有两个接口，<code>FlyBehavior</code> 和 <code>QuackBehavior</code>，还有它们对应的类，负载实现具体的行为。</p><img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYoW2996SM9UUaScNcbQGMfIKcfoguvLGwfMOabcNc5odOsC35xUmKghaK5D9oAZKqkMgvadCIYuj1QiCpIpB2C_FIYs7IrRKArGhw-WfFryrxthVXvOwrJzTEUBbutek5FGgro1hzyiCJAn5cGZGzsTtmP6V7o-QzJtRqFcsSzNvF3v3nPCyie05WtGXd1fOc9cVZSMWXI1x9gM3ro39GLqxS24Bzgv4S5rnOcfg8HUspbGkVpre7yT7J2Hj124MVRsb9AWvhSFaBPW1AeDVewQ64B5PPSF1neOK2I0uiX4q2uYriCd270m00"><p>这样的设计，可以让飞行和呱呱叫的动作被其他的对象复用，因为这些行为已经与鸭子类无关了。</p><p>而我们可以新增一些行为，不会影响到既有的行为类，也不会影响“使用”到飞行行为的鸭子类。</p><p><strong>问</strong>：用一个类代表一个行为，感觉似乎有点奇怪。类不是应该代表某种“东西”吗？类不是应该同时具备状态“与”行为吗？</p><p><strong>答</strong>：在 OO 系统中，是的类代表的东西一般都是既有状态（实例变量）又有方法。只是在本例中，碰巧“东西”是个行为。但是即使是行为，也仍然可以有状态和方法，例如，飞行的行为可以具有实例变量，记录飞行行为的属性（每秒翅膀拍动几下，最大高度和速度等）。</p><h1 id="整体格局">整体格局</h1><img src="http://www.plantuml.com/plantuml/svg/ZLFBJjj05DtxA-woNHX-8CgYGkn0AbraFR5luX5ZdDZZLbQmL0H8BA251IooG09MLPKe2Aa4alwDdP1LVw7sEB5dWYEG9f9pphtdFkQCHKq4j5iy01ljEhgQbI86TGs6MeiOkwI940yENkwEPtVNBpUdoOc6pz3H0EWUHxT138HD5dn2YtobZWkLIevNgo8EeC623n-Jhp3v6OnuNffHezogqRscLmHrGkZ0-Zh4_UlfZy5is8jxvrbPaQgaRpir4iZwMMeq-XuzdSmE_qR3i_YW-s-Sj7iMZRk9p5mZBERgtqvE7eK6gNlS9GQ73T_OdQlAKpMARy5zzXEDd6tB_mJlVQEs61cWiz0EmQHUYv5WJhIIBJckBQHKQ9CjOZpaKXi5gDHV5BAHMuuPfcl8TZVj7iN7VwBHrUJgQV9mgQnmYp16N5EQL-wkYDj1qqBoZZY_dlZdpR0DD9nWPLIuvBduuZuzFt-NsawzX3BZjVFT5Xs8B9MVksvHRCbiNze-ajACoQ-RQRUVxJe-lq_Fg-mjd-FAaglSMiY4clAuzjVMbBTJoegdeIrj9-K4L4Pa8vOnUVkQkBJAlgxBrf5GoIWocjj20dCJgEth31jSXo9OTsdJudfLlUd_"><h1 id="多用组合少用继承">多用组合，少用继承</h1><p>每一鸭子都有一个 <code>FlyBehavior</code> 和一个 <code>QuackBehavior</code>，好将飞行和呱呱叫委托给它们代为处理。这就是组合（composition）。这种做法和“继承”不同的地方在于，鸭子的行为不是继承来的，而是和适当的行为对象“组合”来的。这是一个很重要的技巧。</p><blockquote><p>多用组合，少用继承。</p></blockquote><p>使用组合建立系统具有很大的弹性，不仅可将算法族封装成类，更可以“在运行时动态地改变行为”，只要组合的行为对象符合正确的接口标准即可。</p><h1 id="认识策略模式">认识策略模式</h1><blockquote><p><strong>策略模式</strong>定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p></blockquote><img src="http://www.plantuml.com/plantuml/svg/bOuz3i8m34RtdC9ZEuGBW90e5q3Y16amj5928oTBrERkfD2QdmuLc_NvVVPhsWi2MXSYMBGracZ6HBUa3GfL-q1A1pWXNJkoID0BW7CE0zuY-6d8cNiHHGaznnlbd8b5kOKaaj16UG_7xgu90_vnCNTPXC6nrSznWkdJuitC7vw5DQhweTwIkq7AfVi78FVi9bZogyKgA_lg0G00"><h1 id="要点">要点</h1><ul><li>知道 OO 基础（即<strong>抽象、封装、多态和继承</strong>），并不足以让你设计出良好的 OO 系统。</li><li>良好的 OO 设计必须具备<strong>可复用、可扩充、可维护</strong>三个特性。</li><li>模式可以让我们建造出具有良好 OO 设计质量的系统。</li><li>模式被认为是历经验证的 OO 设计经验。</li><li>模式不是代码，而是针对设计问题的通用解决方案。你可以把它们应用到特定的应用中。</li><li>大多数的模式和原则，都着眼于软件变化的主题。</li><li>大多数的模式都允许系统局部改变独立于其他部分。</li><li>我们常把系统中会变化的部分抽出来封装。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Head First Design Patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Range Sum Query</title>
      <link href="/programming/leetcode/range-sum-query/"/>
      <url>/programming/leetcode/range-sum-query/</url>
      
        <content type="html"><![CDATA[<h1 id="range-sum-query---immutable">Range Sum Query - Immutable</h1><p>Given an integer array <em>nums</em>, find the sum of the elements between indices <em>i</em> and <em>j (i ≤ j)</em>, inclusive.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums = [-2, 0, 3, -5, 2, -1]</span><br><span class="line"></span><br><span class="line">sumRange(0, 2) -&gt; 1</span><br><span class="line">sumRange(2, 5) -&gt; -1</span><br><span class="line">sumRange(0, 5) -&gt; -3</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol type="1"><li>You may assume that the array does not change.</li><li>There are many calls to <em>sumRange</em> function.</li></ol><h2 id="caching-on2-space">Caching: O(n^2) Space</h2><p>Imagine that <em>sumRange</em> is called one thousand times with the exact same arguments. How could we speed that up?</p><p>We could trade in extra space for speed. By pre-computing all range sum possibilities and store its results in a hash table, we can speed up the query to constant time.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2) time pre-computing + O(1) time per query</span></span><br><span class="line"><span class="comment"># Space: O(n^2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums: list)</span>:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        self.data = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            s = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):</span><br><span class="line">                s += nums[j]</span><br><span class="line">                self.data[i, j] = s</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span><span class="params">(self, i: int, j: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.data[i, j]</span><br></pre></td></tr></table></figure><h2 id="caching-on-space">Caching: O(n) Space</h2><p>Imagine that we pre-compute the cummulative sum from index <code>0</code> to <code>k</code>. Could we use this information to derive <code>sumRange(i, j)</code>?</p><p>Let us define <code>sum[k]</code> as the cumulative sum for <code>nums[0 .. k-1]</code>: <code>sumRange(i, j) = sum[j + 1] - sum[i]</code>.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n) time pre-computing and O(1) time per query</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums: list)</span>:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        self.sum = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">            self.sum[k + <span class="number">1</span>] = self.sum[k] + nums[k]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span><span class="params">(self, i: int, j: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.sum[j + <span class="number">1</span>] - self.sum[i]</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="range-sum-query-2d---immutable">Range Sum Query 2D - Immutable</h1><p>Given a 2D matrix <em>matrix</em>, find the sum of the elements inside the rectangle defined by its upper left corner <em>(row1, col1)</em> and lower right corner <em>(row2, col2)</em>.</p><p><img src="/uploads/image/leetcode/range_sum_query_2d.png"></p><p>The above rectangle (with the red border) is defined by (row1, col1) = <strong>(2, 1)</strong> and (row2, col2) = <strong>(4, 3)</strong>, which contains sum = <strong>8</strong>.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given matrix = [</span><br><span class="line">  [3, 0, 1, 4, 2],</span><br><span class="line">  [5, 6, 3, 2, 1],</span><br><span class="line">  [1, 2, 0, 1, 5],</span><br><span class="line">  [4, 1, 0, 1, 7],</span><br><span class="line">  [1, 0, 3, 0, 5]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">sumRegion(2, 1, 4, 3) -&gt; 8</span><br><span class="line">sumRegion(1, 1, 2, 2) -&gt; 11</span><br><span class="line">sumRegion(1, 2, 2, 4) -&gt; 12</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol type="1"><li>You may assume that the matrix does not change.</li><li>There are many calls to <em>sumRegion</em> function.</li><li>You may assume that <em>row1 ≤ row2</em> and <em>col1 ≤ col2</em>.</li></ol><h2 id="caching-rows">Caching Rows</h2><p>Remember from the 1D version, try to see the 2D matrix as <em>m</em> rows of 1D arrays. To find the region sum, we just accumulate the sum in the region row by row.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn) time pre-computing + O(m) time per query</span></span><br><span class="line"><span class="comment"># Space: O(mn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, matrix: list)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            m, n = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                self.dp[i][j + <span class="number">1</span>] = self.dp[i][j] + matrix[i][j]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRegion</span><span class="params">(self, row1: int, col1: int, row2: int, col2: int)</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row1, row2 + <span class="number">1</span>):</span><br><span class="line">            res += self.dp[i][col2 + <span class="number">1</span>] - self.dp[i][col1]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="caching-smarter">Caching Smarter</h2><p>We used a cumulative sum array in the 1D version. We notice that the cumulative sum is computed with respect to the origin at index 0. Extending this analogy to the 2D case, we could pre-compute a cumulative region sum with respect to the origin at (0, 0).</p><p><img src="/uploads/image/leetcode/sum_od.png"> <img src="/uploads/image/leetcode/sum_ob.png"> <img src="/uploads/image/leetcode/sum_oc.png"> <img src="/uploads/image/leetcode/sum_oa.png"></p><p><code>sum(A, D) = sum(O, D) - sum(O, B) - sum(O, C) + sum(O, A)</code></p><p>Let us define <code>dp[i][j] = sumRegion(0, 0, i - 1, j - 1)</code>, the sum of region that has upper left corner <code>(0, 0)</code> and lower right corner <code>(i - 1, j - 1)</code>.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn) time pre-computing and O(1) time per query</span></span><br><span class="line"><span class="comment"># Space: O(mn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, matrix: list)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            m, n = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                self.dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = self.dp[i + <span class="number">1</span>][j] + self.dp[i][j + <span class="number">1</span>] \</span><br><span class="line">                                        + matrix[i][j] - self.dp[i][j]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRegion</span><span class="params">(self, row1: int, col1: int, row2: int, col2: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.dp[row2 + <span class="number">1</span>][col2 + <span class="number">1</span>] - self.dp[row2 + <span class="number">1</span>][col1] \</span><br><span class="line">               - self.dp[row1][col2 + <span class="number">1</span>] + self.dp[row1][col1]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Longest Increasing Subsequence</title>
      <link href="/programming/leetcode/longest-increasing-subsequence/"/>
      <url>/programming/leetcode/longest-increasing-subsequence/</url>
      
        <content type="html"><![CDATA[<p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [10,9,2,5,3,7,101,18]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest increasing subsequence is [2,3,7,101], therefore the lenght is 4.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li>There may be more than on LIS combination, it is only necessary for you to return the length.</li><li>Your algorithm shoud run in O(n^2) complexity.</li></ul><p><strong>Follow up:</strong> Could you improve it to O(nlog(n)) time complexity?</p><h1 id="recursion">Recursion</h1><p>Define a function <code>helper(i)</code> returns the length of LIS that ends at <code>i</code>. Then answer of an input shoule be <code>max([helper(i) | 0 &lt;= i &lt; n])</code>.</p><p>To calculate <code>helper(i)</code>, we use a variable <code>res</code> which initialized to 1 to store the result. Then we find every number <code>nums[j] &lt; nums[i], 0 &lt;= j &lt; i</code>, let <code>res = max(res, helper(j) + 1)</code>.</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(2^n), every num is checked twice: included and not included.</span></span><br><span class="line"><span class="comment"># Space: O(n^2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: list)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(self.helper(nums, i) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, nums, i)</span>:</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &lt; nums[i]:</span><br><span class="line">                res = max(res, self.helper(nums, j) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="dynamic-programming">Dynamic Programming</h1><p>Taking the same idea, we rewrite it using DP as bellow.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: list)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n, res = len(nums), <span class="number">1</span></span><br><span class="line">        dp = [<span class="number">1</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt; nums[i]:</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">            res = max(res, dp[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="dynamic-programming-with-binary-search">Dynamic Programming with Binary Search</h1><p>In this approach, <code>dp</code> array stores the current longest increasing &quot;subsequence&quot;, and length of <code>dp</code> is 0 at the beginning. We scan the array from left to right, finding the correct position <code>i</code> for current item by binary search:</p><ul><li>If it happens to be the end of <code>dp</code> array (<code>i == len(dp)</code>), then we append it to then end of <code>dp</code> and increase our result <code>res</code> by 1, because we find a longer &quot;subsequence&quot;.</li><li>If not, just set current item to <code>dp[i]</code>, don't increase the <code>res</code>.</li></ul><p>Consider the example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [0, 8, 4, 12, 2, 13]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: LIS is [0, 4, 12, 13]</span><br><span class="line"></span><br><span class="line">dp: [0]</span><br><span class="line">dp: [0, 8]</span><br><span class="line">dp: [0, 4]  # dp is not a subsequnce,</span><br><span class="line">            # but length of dp results in length of LIS [0, 8]</span><br><span class="line">dp: [0, 4, 12]</span><br><span class="line">dp: [0, 2, 12]</span><br><span class="line">dp: [0, 2, 12, 13]  # dp is not a subsequence again</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(nlog(n))</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: list)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span>] * len(nums)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">from</span> bisect <span class="keyword">import</span> bisect</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            i = bisect(dp, num, <span class="number">0</span>, res)</span><br><span class="line">            dp[i] = num</span><br><span class="line">            <span class="keyword">if</span> i == res:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> recursion </tag>
            
            <tag> leetcode </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Perfect Squares</title>
      <link href="/programming/leetcode/perfect-squares/"/>
      <url>/programming/leetcode/perfect-squares/</url>
      
        <content type="html"><![CDATA[<p>Given a positive integer <em>n</em>, find the least number of perfect square numbers (for example, <code>1, 4, 9, 16, ...</code>) which sum to <em>n</em>.</p><p>Example 1:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Input: n = <span class="number">12</span></span><br><span class="line">Output: <span class="number">3</span></span><br><span class="line">Explanation: <span class="number">12</span> = <span class="number">4</span> + <span class="number">4</span> + <span class="number">4.</span></span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Input: n = <span class="number">13</span></span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line">Explanation: <span class="number">13</span> = <span class="number">4</span> + <span class="number">9.</span></span><br></pre></td></tr></table></figure><h1 id="dynamic-programming">Dynamic Programming</h1><p>Let <code>dp[i]</code> denotes the least number of perfect square numbers which sum to <code>i</code>.</p><p>We can't find the largest square number <code>j &lt;= i</code>, then let <code>dp[i] = dp[i - j] + 1</code>. See example 1, the correct answer is <code>dp[12] = 3</code>. If we let <code>j = 9</code>, then <code>dp[12] = 1 + dp[12 - 9] = 1 + 3 = 4</code>, which is wrong. We should check every <code>j &lt;= i</code> like below.</p><p>If <code>1 &lt;= j &lt;= i</code> and <code>j</code> is a square number, then <code>i</code> can be summed by <code>j</code> and <code>i - j</code>, there are <code>1 + dp[i - j]</code> numbers.</p><a id="more"></a><p>Base case: <code>dp[0] = 0, dp[1] = 1</code>.</p><p>Induction rule: <code>dp[i] = min(dp[i - j] + 1 | 1 &lt;= j &lt;= i)</code>.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            j, res = <span class="number">1</span>, i</span><br><span class="line">            <span class="keyword">while</span> j * j &lt;= i:</span><br><span class="line">                res = min(res, dp[i - j * j] + <span class="number">1</span>)</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            dp.append(res)</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ugly Number</title>
      <link href="/programming/leetcode/ugly-number/"/>
      <url>/programming/leetcode/ugly-number/</url>
      
        <content type="html"><![CDATA[<h1 id="ugly-number-i">Ugly Number I</h1><p>Write a program to check whether a given number is an ugly number.</p><p>Ugly numbers are <strong>positive numbers</strong> whose prime factors only include <code>2, 3, 5</code>.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 6</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 6 = 2 * 3</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 8</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 8 = 2 * 2 * 2</span><br></pre></td></tr></table></figure><p>Example 3:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 14</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol type="1"><li><code>1</code> is typically treated as ugly number.</li><li>Input is within the 32-bit signed integer range: <code>[-2^31, 2^31 - 1]</code>.</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isUgly</span><span class="params">(self, num: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>):</span><br><span class="line">            <span class="keyword">while</span> num % x == <span class="number">0</span> &lt; num:</span><br><span class="line">                num /= x</span><br><span class="line">        <span class="keyword">return</span> num == <span class="number">1</span></span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="ugly-number-ii">Ugly Number II</h1><p>Write a program to find the <code>n</code>-th ugly number.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n = 10</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol type="1"><li><code>1</code> is typically treated as an ugly number.</li><li><code>n</code> <strong>does not exceed 1690.</strong></li></ol><h2 id="dynamic-programming">Dynamic Programming</h2><p>The first ugly number is 1. New ugly number can be computed by known ugly numbers.</p><p>For example, once we get a new ugly number <code>x</code>, then we add <code>x*2, x*3, x*5</code> to candidate set. And then pick the minimum number as the next ugly number, replace the procedure.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ugly_num, candidates = <span class="number">-1</span>, &#123;<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">    ugly_num = min(candidates)</span><br><span class="line">    candidates.remove(ugly_num)</span><br><span class="line">    candidates.update([ugly_num * <span class="number">2</span>, ugly_num * <span class="number">3</span>, ugly_num * <span class="number">5</span>])</span><br><span class="line"><span class="keyword">return</span> ugly_num</span><br></pre></td></tr></table></figure><p>If <code>n</code> is large, the <code>candidates</code> can be very large. We can see the candidates are <code>x * 2, y * 3, z * 5</code> where <code>x, y, z</code> are all ugly numbers. <code>x = y = z = 1</code> at the beginning. Once a candidate (say <code>2</code>) is chosen, we replace the corresponding ugly number (<code>x=1</code>) by the next ugly number (<code>x=2</code>, <code>2</code> is the succeed ugly number of <code>1</code>).</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        ugly = [<span class="number">1</span>] * n</span><br><span class="line">        ind2, ind3, ind5 = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        can2, can3, can5 = <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            ugly[i] = min(can2, can3, can5)</span><br><span class="line">            <span class="keyword">if</span> can2 == ugly[i]:</span><br><span class="line">                ind2 += <span class="number">1</span></span><br><span class="line">                can2 = ugly[ind2] * <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> can3 == ugly[i]:</span><br><span class="line">                ind3 += <span class="number">1</span></span><br><span class="line">                can3 = ugly[ind3] * <span class="number">3</span></span><br><span class="line">            <span class="keyword">if</span> can5 == ugly[i]:</span><br><span class="line">                ind5 += <span class="number">1</span></span><br><span class="line">                can5 = ugly[ind5] * <span class="number">5</span></span><br><span class="line">        <span class="keyword">return</span> ugly[n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        ugly = [<span class="number">1</span>] * n</span><br><span class="line">        ind, fac = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], (<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">        can = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            ugly[i] = min(can)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(fac)):</span><br><span class="line">                <span class="keyword">if</span> can[j] == ugly[i]:</span><br><span class="line">                    ind[j] += <span class="number">1</span></span><br><span class="line">                    can[j] = ugly[ind[j]] * fac[j]</span><br><span class="line">        <span class="keyword">return</span> ugly[n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dungeon Game</title>
      <link href="/programming/leetcode/dungeon-game/"/>
      <url>/programming/leetcode/dungeon-game/</url>
      
        <content type="html"><![CDATA[<p>The demons had captured the princess (<strong>P</strong>) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists M x N rooms laid out in a 2D grid. Our valiant knight (<strong>K</strong>) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.</p><p>The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.</p><p>Some of the rooms are guarded by demons, so the knight loses health (<em>negative</em> integers) upon entering these rooms; other rooms are either empty (<em>0's</em>) or contain magic orbs that increase the knight's health (<em>positive</em> integers).</p><p>In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.</p><p><strong>Write a function to determine the knight's minimum initial health so that he is able to rescue the princess.</strong></p><p>For example, given the dungeon below, the initial health of the knight must be at least <strong>7</strong> if he follows the optimal path <code>RIGHT -&gt; RIGHT -&gt; DOWN -&gt; DOWN</code>.</p><table style="width: auto; text-align: center;"><tbody style="border-style: solid;"><tr><td>-2(K)</td><td>-3</td><td>3</td></tr><tr><td>-5</td><td>-10</td><td>1</td></tr><tr><td>10</td><td>30</td><td>-5(P)</td></tr></tbody></table><p><strong>Note:</strong></p><ul><li>The knight's health has no upper bound.</li><li>Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.</li></ul><h1 id="recursion">Recursion</h1><p>We use two variables <code>curr</code> and <code>init</code> to represent the current and minimum health. Define a function <code>helper(i, j, init, curr)</code> which returns the minimum health so that the knight can move from <code>(i, j)</code> to <code>(m, n)</code>.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculateMinimumHP</span><span class="params">(self, dungeon: list)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(dungeon, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, dungeon, i, j, init, curr)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i == len(dungeon) <span class="keyword">or</span> j == len(dungeon[i]):</span><br><span class="line">            <span class="keyword">return</span> float(<span class="string">'inf'</span>)</span><br><span class="line">        curr = curr + dungeon[i][j]  <span class="comment"># fight demons</span></span><br><span class="line">        <span class="keyword">if</span> curr &lt;= <span class="number">0</span>:                <span class="comment"># initial health is not sufficient</span></span><br><span class="line">            init = init - curr + <span class="number">1</span></span><br><span class="line">            curr = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i == len(dungeon) - <span class="number">1</span> <span class="keyword">and</span> j == len(dungeon[i]) - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> init</span><br><span class="line">        <span class="keyword">return</span> min(self.helper(dungeon, i + <span class="number">1</span>, j, init, curr),</span><br><span class="line">                   self.helper(dungeon, i, j + <span class="number">1</span>, init, curr))</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="dynamic-programming">Dynamic Programming</h1><p>Denote <code>dp[i][j]</code> as the minimum health needed at room <code>(i, j)</code>.</p><p>Base cases: <code>dp[m][j] = dp[i][n] = inf</code>, but <code>dp[m][n - 1] = dp[m - 1][n] = 1</code>.</p><table><thead><tr class="header"><th></th><th><strong>0</strong></th><th><strong>1</strong></th><th><strong>2</strong></th><th><strong>3</strong></th></tr></thead><tbody><tr class="odd"><td><strong>0</strong></td><td><em>-2</em></td><td><em>-3</em></td><td><em>3</em></td><td><strong>inf</strong></td></tr><tr class="even"><td><strong>1</strong></td><td><em>-5</em></td><td><em>-10</em></td><td><em>1</em></td><td><strong>inf</strong></td></tr><tr class="odd"><td><strong>2</strong></td><td><em>10</em></td><td><em>30</em></td><td><em>-5</em></td><td><strong>1</strong></td></tr><tr class="even"><td><strong>3</strong></td><td><strong>inf</strong></td><td><strong>inf</strong></td><td><strong>1</strong></td><td><strong>inf</strong></td></tr></tbody></table><p>Induction rule: <code>dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j])</code>.</p><p>The <code>min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j])</code> is the health point needed so that after entering room <code>(i, j)</code> the left health is <code>min(dp[i + 1][j], dp[i][j + 1])</code>. The point is the knight need at least 1 health point to be alive.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(mn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculateMinimumHP</span><span class="params">(self, dungeon: list)</span> -&gt; int:</span></span><br><span class="line">        m, n = len(dungeon), len(dungeon[<span class="number">0</span>])</span><br><span class="line">        dp = [[float(<span class="string">'inf'</span>)] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">        dp[m][n - <span class="number">1</span>] = dp[m - <span class="number">1</span>][n] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                before = min(dp[i + <span class="number">1</span>][j], dp[i][j + <span class="number">1</span>]) - dungeon[i][j]</span><br><span class="line">                dp[i][j] = max(before, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculateMinimumHP</span><span class="params">(self, dungeon: list)</span> -&gt; int:</span></span><br><span class="line">        m, n = len(dungeon), len(dungeon[<span class="number">0</span>])</span><br><span class="line">        dp = [float(<span class="string">'inf'</span>)] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[n - <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                before = min(dp[j], dp[j + <span class="number">1</span>]) - dungeon[i][j]</span><br><span class="line">                dp[j] = max(before, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> recursion </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Palindrome Partitioning</title>
      <link href="/programming/leetcode/palindrome-partitioning/"/>
      <url>/programming/leetcode/palindrome-partitioning/</url>
      
        <content type="html"><![CDATA[<h1 id="palindrome-partitioning-i">Palindrome Partitioning I</h1><p>Given a string <em>s</em>, partition <em>s</em> such that every substring of the partition is a palindrome.</p><p>Return all possible palindrome partitioning of <em>s</em>.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;aab&quot;</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [&quot;aa&quot;, &quot;b&quot;],</span><br><span class="line">  [&quot;a&quot;, &quot;a&quot;, &quot;b&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="backtracking">Backtracking</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(2^n * n^2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, s: str)</span> -&gt; list:</span></span><br><span class="line">        res = []</span><br><span class="line">        self.helper(s, <span class="number">0</span>, res, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, s, i, res, cur)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i == len(s):</span><br><span class="line">            res.append(cur[:])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(s)):  <span class="comment"># O(n)</span></span><br><span class="line">            <span class="keyword">if</span> self.is_palindrome(s, i, j):  <span class="comment"># O(n)</span></span><br><span class="line">                cur.append(s[i:j + <span class="number">1</span>])</span><br><span class="line">                self.helper(s, j + <span class="number">1</span>, res, cur)</span><br><span class="line">                cur.pop()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_palindrome</span><span class="params">(s: str, l: int, r: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> l == r:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            <span class="keyword">if</span> s[l] != s[r]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            l, r = l + <span class="number">1</span>, r - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="dynamic-programming">Dynamic Programming</h2><p>Instead of checking <code>s[l .. r]</code> is a palindrome or not, we using dynamic programming to compute the result for each pair <code>(l, r)</code>. See <a href="/programming/leetcode/longest-palindromic-substring/" title="Longest Palindromic Substring">Longest Palindromic Substring</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, s: str)</span> -&gt; list:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> range(r + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[l] == s[r] <span class="keyword">and</span> (r - l &lt;= <span class="number">2</span> <span class="keyword">or</span> dp[l + <span class="number">1</span>][r - <span class="number">1</span>]):</span><br><span class="line">                    dp[l][r] = <span class="literal">True</span></span><br><span class="line">        res = []</span><br><span class="line">        self.helper(s, <span class="number">0</span>, dp, res, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, s, i, dp, res, cur)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i == len(s):</span><br><span class="line">            res.append(cur[:])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(s)):  <span class="comment"># O(n)</span></span><br><span class="line">            <span class="keyword">if</span> dp[i][j]:  <span class="comment"># O(1)</span></span><br><span class="line">                cur.append(s[i:j + <span class="number">1</span>])</span><br><span class="line">                self.helper(s, j + <span class="number">1</span>, dp, res, cur)</span><br><span class="line">                cur.pop()</span><br></pre></td></tr></table></figure><h1 id="palindrome-partitioning-ii">Palindrome Partitioning II</h1><p>Given a string <em>s</em>, partition <em>s</em> such that every substring of the partition is a palindrome.</p><p>Return the minimum cuts needed for a palindrome partitioning of <em>s</em>.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;aab&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><h2 id="dynamic-programming-1">Dynamic Programming</h2><p>Let <code>cut[i]</code> be the minimum cuts needed for substring <code>s[0 .. i]</code>.</p><p>Base case: <code>cut[i] = i - 1</code>. At most <code>i - 1</code> cuts needed for substring <code>s[0 .. i]</code>.</p><p>Induction rule: <code>cut[i] = min(cut[i], cut[j - 1] | 0 &lt;= j &lt;= i where s[j .. i] is a palindrome) + 1</code>.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0   1   2   3   4   5   6</span><br><span class="line">a   a   a   a   b   a   a</span><br><span class="line"></span><br><span class="line">cut[6] = min(cut[6], cut[1] + 1, cut[4] + 1)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2)</span></span><br><span class="line"><span class="comment"># Space: O(n^2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCut</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        cut = list(range(n))  <span class="comment"># initial, at most i-1 cuts for s[:i]</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> range(r + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[l] == s[r] <span class="keyword">and</span> (r - l &lt;= <span class="number">2</span> <span class="keyword">or</span> dp[l + <span class="number">1</span>][r - <span class="number">1</span>]):</span><br><span class="line">                    dp[l][r] = <span class="literal">True</span></span><br><span class="line">                    cut[r] = <span class="number">0</span> <span class="keyword">if</span> l == <span class="number">0</span> <span class="keyword">else</span> min(cut[r], cut[l - <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> cut[n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>If we let <code>cut[i]</code> be the minimum cuts needed for substring <code>s[0 .. i)</code> (<code>i</code> not included), and let <code>cut[0] = -1</code>, we can tackle with the boundary ingeniously.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2)</span></span><br><span class="line"><span class="comment"># Space: O(n^2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCut</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        cut = list(range(<span class="number">-1</span>, n))  <span class="comment"># tiny change</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> range(r + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[l] == s[r] <span class="keyword">and</span> (r - l &lt;= <span class="number">2</span> <span class="keyword">or</span> dp[l + <span class="number">1</span>][r - <span class="number">1</span>]):</span><br><span class="line">                    dp[l][r] = <span class="literal">True</span></span><br><span class="line">                    cut[r + <span class="number">1</span>] = min(cut[r + <span class="number">1</span>], cut[l] + <span class="number">1</span>)  <span class="comment"># tiny change</span></span><br><span class="line">        <span class="keyword">return</span> cut[n]  <span class="comment"># tiny change</span></span><br></pre></td></tr></table></figure><h2 id="using-on-space">Using O(n) space</h2><p>Let <code>cut[i]</code> be the minimum cuts needed for substring <code>s[0 .. i)</code>.</p><p>For each <code>0 &lt;= i &lt; n</code> we find every palindrome that centered at <code>i</code>. (See <a href="/programming/leetcode/longest-palindromic-substring/" title="Longest Palindromic Substring">Longest Palindromic Substring</a>: Expand Around Center)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    l     m     h</span><br><span class="line">... a  a  b  a  a ...</span><br><span class="line">    |&lt;--  y  --&gt;|</span><br><span class="line">|&lt;--    x    --&gt;|</span><br><span class="line"></span><br><span class="line">Say y is a palindrome around m.</span><br><span class="line">The minimum cuts needed for substring x is:</span><br><span class="line">cut[h + 1] = min(cut[h + 1], cut[l] + 1)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCut</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        cut = list(range(<span class="number">-1</span>, n))</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> l, h <span class="keyword">in</span> (m, m), (m - <span class="number">1</span>, m):</span><br><span class="line">                <span class="keyword">while</span> l &gt;= <span class="number">0</span> <span class="keyword">and</span> h &lt; n <span class="keyword">and</span> s[l] == s[h]:</span><br><span class="line">                    cut[h + <span class="number">1</span>] = min(cut[h + <span class="number">1</span>], cut[l] + <span class="number">1</span>)</span><br><span class="line">                    l, h = l - <span class="number">1</span>, h + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cut[n]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> recursion </tag>
            
            <tag> leetcode </tag>
            
            <tag> palindrome </tag>
            
            <tag> backtracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maximum Square</title>
      <link href="/programming/leetcode/maximum-square/"/>
      <url>/programming/leetcode/maximum-square/</url>
      
        <content type="html"><![CDATA[<p>Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [&apos;1&apos;, &apos;0&apos;, &apos;1&apos;, &apos;0&apos;, &apos;0&apos;],</span><br><span class="line">  [&apos;1&apos;, &apos;0&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;],</span><br><span class="line">  [&apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;],</span><br><span class="line">  [&apos;1&apos;, &apos;0&apos;, &apos;0&apos;, &apos;1&apos;, &apos;0&apos;]</span><br><span class="line">]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><h1 id="broute-force">Broute Force</h1><p>We use a variable to contain the size of the largest square found so far and another variable to store the size of the current, both initialized to 0.</p><p>Starting from the left uppermost point in the matrix, we search for a 1. No operation needs to be done for a 0.</p><p>Whenever a 1 is found, we try to find out the largest square that can be formed including that 1. For this, we move diagonally (right and downwards), i.e. we increment the row index and column index temporarily and then check whether all the elements of that row and column are 1 or not.</p><p>If all the elements happen to be 1, we move diagonally further as previously. If even one element turns out to be 0, we stop this diagonal movement and update the size of the largest square.</p><p>Now we, continue the traversal of the matrix from the element next to the initial 1 found, till all the elements of the matrix have been traversed.</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O((mn)^2)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span><span class="params">(self, matrix: list)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            m, n = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        max_sq = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] != <span class="string">'1'</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                sq, flag = <span class="number">1</span>, <span class="literal">True</span></span><br><span class="line">                <span class="keyword">while</span> sq + i &lt; m <span class="keyword">and</span> sq + j &lt; n <span class="keyword">and</span> flag:</span><br><span class="line">                    flag = all(matrix[sq + i][k] == <span class="string">'1'</span>  <span class="comment"># sq+i column</span></span><br><span class="line">                               <span class="keyword">for</span> k <span class="keyword">in</span> range(j, sq + j + <span class="number">1</span>)) <span class="keyword">and</span> \</span><br><span class="line">                           all(matrix[k][sq + j] == <span class="string">'1'</span>  <span class="comment"># sq+j row</span></span><br><span class="line">                               <span class="keyword">for</span> k <span class="keyword">in</span> range(i, sq + i + <span class="number">1</span>))</span><br><span class="line">                    <span class="keyword">if</span> flag:</span><br><span class="line">                        sq += <span class="number">1</span></span><br><span class="line">                max_sq = max(max_sq, sq)</span><br><span class="line">        <span class="keyword">return</span> max_sq ** <span class="number">2</span></span><br></pre></td></tr></table></figure><!-- more --><h1 id="dynamic-programming">Dynamic Programming</h1><p>We initialize another matrix (dp) with the same dimensions as the original one initialized with all 0's.</p><p><code>dp[i][j]</code> represents the side length of the maximum square whose bottom right corner is the cell with index <code>(i, j)</code> in the original matrix.</p><p>Starting from index <code>(0, 0)</code>, for every 1 found in the original matrix, we update the value of the current element as <code>dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1], dp[i][j - 1]) + 1</code>.</p><p>We also remember the size of the largest square found so far. In this way, we traverse the original matrix once and find out the required maximum size.</p><p>To understand how this solution works, see the figure below.</p><p><img src="/uploads/image/leetcode/maximal_square.png"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(mn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span><span class="params">(self, matrix: list)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            m, n = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">        max_sq = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="string">'1'</span>:</span><br><span class="line">                    dp[i][j] = min(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">                    max_sq = max(max_sq, dp[i][j])</span><br><span class="line">        <span class="keyword">return</span> max_sq ** <span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span><span class="params">(self, matrix: list)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            m, n = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        max_sq = prev = <span class="number">0</span>  <span class="comment"># prev = dp[i - 1][j - 1]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                temp = dp[j]</span><br><span class="line">                <span class="keyword">if</span> matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="string">'1'</span>:</span><br><span class="line">                    dp[j] = min(dp[j - <span class="number">1</span>], dp[j], prev) + <span class="number">1</span></span><br><span class="line">                    max_sq = max(max_sq, dp[j])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[j] = <span class="number">0</span></span><br><span class="line">                prev = temp</span><br><span class="line">        <span class="keyword">return</span> max_sq ** <span class="number">2</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>House Robber</title>
      <link href="/programming/leetcode/house-robber/"/>
      <url>/programming/leetcode/house-robber/</url>
      
        <content type="html"><![CDATA[<h1 id="house-robber-i">House Robber I</h1><p>You are a professional robber planning to rob houses along a streat. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have securtiy system connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night.</strong></p><p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police.</strong></p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3,1]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,7,9,3,1]</span><br><span class="line">Output: 12</span><br></pre></td></tr></table></figure><h2 id="dynamic-programming">Dynamic Programming</h2><p>Let <code>dp[i]</code> denotes the maximum amount money you can rob from <code>nums[0 .. i]</code>.</p><p>The action you can do is,</p><ul><li>Rob <code>nums[i]</code>, then <code>dp[i] = dp[i - 2] + nums[i]</code>.</li><li>Don't rob, then <code>dp[i] = dp[i - 1]</code>.</li></ul><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: list)</span> -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            dp.append(max(dp[<span class="number">-2</span>] + x, dp[<span class="number">-1</span>]))</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: list)</span> -&gt; int:</span></span><br><span class="line">        prev2 = prev1 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            temp = prev1</span><br><span class="line">            prev1 = max(prev2 + x, prev1)</span><br><span class="line">            prev2 = temp</span><br><span class="line">        <span class="keyword">return</span> prev1</span><br></pre></td></tr></table></figure><h1 id="house-robber-ii">House Robber II</h1><p>All houses at this place are <strong>arranged in a circle.</strong> That means the first house is the neighbor of the last one.</p><p>Determine the maximum amount of money you can rob tonight <strong>without alerting the police.</strong></p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,3,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3,1]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><h2 id="two-pass">Two Pass</h2><p>There are two cases: rob <code>nums[0]</code> or rob <code>nums[n - 1]</code>. So we can utilize the method of House Robber I, the maximum amount should be <code>max(rob(nums[:n-1], rob(nums[1:]))</code>.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: list)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> max(self.helper(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>),</span><br><span class="line">                   self.helper(nums, <span class="number">1</span>, len(nums)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, nums, start, stop)</span>:</span></span><br><span class="line">        prev2 = prev1 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start, stop):</span><br><span class="line">            temp = prev1</span><br><span class="line">            prev1 = max(prev2 + nums[i], prev1)</span><br><span class="line">            prev2 = temp</span><br><span class="line">        <span class="keyword">return</span> prev1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maximum Product Subarray</title>
      <link href="/programming/leetcode/maximum-product-subarray/"/>
      <url>/programming/leetcode/maximum-product-subarray/</url>
      
        <content type="html"><![CDATA[<p>Given an integer array <code>nums</code>, find the contiguous subarray within an array (contaning at least one number) which has the largest product.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,3,-2,4]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [-2,0,-1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><h1 id="dynamic-programming">Dynamic Programming</h1><p>Let <code>dp_max[i]</code> be the maximum product of subarray and <code>dp_min[i]</code> be the minimum product of subarray that ends with <code>nums[i]</code>. The maximum value of array <code>dp_max</code> is the answer.</p><p>Base case: <code>dp_max[0] = dp_min[0] = nums[0]</code>.</p><p>Induction rules:</p><ul><li>If <code>nums[i] &gt;= 0</code>, <code>dp_max[i] = max(dp_max[i - 1] * nums[i], nums[i])</code>, <code>dp_min[i] = min(dp_min[i - 1] * nums[i], nums[i])</code>.</li><li>If <code>nums[i] &lt; 0</code>, <code>dp_max[i] = max(dp_min[i - 1] * nums[i], nums[i])</code>, <code>dp_min[i] = min(dp_max[i - 1] * nums[i], nums[i])</code>.</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums: list)</span> -&gt; int:</span></span><br><span class="line">        imax = imin = res = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; <span class="number">0</span>:</span><br><span class="line">                imax, imin = imin, imax</span><br><span class="line">            imax = max(imax * nums[i], nums[i])</span><br><span class="line">            imin = min(imin * nums[i], nums[i])</span><br><span class="line">            res = max(res, imax)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Word Break</title>
      <link href="/programming/leetcode/word-break/"/>
      <url>/programming/leetcode/word-break/</url>
      
        <content type="html"><![CDATA[<h1 id="word-break-i">Word Break I</h1><p>Given a <strong>non-empty</strong> string <em>s</em> and a dictionary <em>wordDict</em> containing a list of <strong>non-empty</strong> words, determine if <em>s</em> can be segmented into a space-separated sequence of one or more dictionary words.</p><p><strong>Note:</strong></p><ul><li>The same word in the dictionary may be reused multiple times in the segmentation.</li><li>You may assume the dictionary does not contain duplicate words.</li></ul><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>Example 3:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><h2 id="dynamic-programming">Dynamic Programming</h2><p>Let <code>dp[i]</code> denotes whether <code>s[0 .. i)</code> can be segmented into a space-separated sequence of one or more dictionary words.</p><a id="more"></a><p>Base case: <code>dp[0] = true</code>.</p><p>Induction rule:</p><p>For filling in the entry of <code>dp[i]</code>, if there exist any <code>j &lt; i</code> where <code>dp[j] = true</code> and <code>s[j .. i)</code> is contained in <code>wordDict</code>, then <code>dp[i] = true</code>.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s: str, wordDict: list)</span> -&gt; bool:</span></span><br><span class="line">        n, wordDict = len(s), set(wordDict)</span><br><span class="line">        dp = [<span class="literal">True</span>] + [<span class="literal">False</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = any(dp[j] <span class="keyword">and</span> s[j:i] <span class="keyword">in</span> wordDict</span><br><span class="line">                        <span class="keyword">for</span> j <span class="keyword">in</span> reversed(range(i)))  <span class="comment"># backward may improve performace a little bit</span></span><br><span class="line">            <span class="comment"># This is equivalent to:</span></span><br><span class="line">            <span class="string">'''</span></span><br><span class="line"><span class="string">            for j in reversed(range(i)):</span></span><br><span class="line"><span class="string">                if dp[j] and s[j:i] in wordDict:</span></span><br><span class="line"><span class="string">                    dp[i] = True</span></span><br><span class="line"><span class="string">                    break</span></span><br><span class="line"><span class="string">            '''</span></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><h1 id="word-break-ii">Word Break II</h1><p>Given a <strong>non-empty</strong> string <em>s</em> and a dictionary <em>wordDict</em> containing a list of <strong>non-empty</strong> words, add spaces in <em>s</em> to construct a sentence where each word is valid dictionary word. Return all such possible sentences.</p><p><strong>Note:</strong></p><ul><li>The same word in the dictionary may be reused multiple times in the segmentation.</li><li>You may assume the dictionary does not contain duplicate words.</li></ul><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;catsanddog&quot;</span><br><span class="line">wordDict = [&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  &quot;cats and dog&quot;,</span><br><span class="line">  &quot;cat sand dog&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;pineapplepenapple&quot;</span><br><span class="line">wordDict = [&quot;apple&quot;, &quot;pen&quot;, &quot;applepen&quot;, &quot;pine&quot;, &quot;pineapple&quot;]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  &quot;pine apple pen apple&quot;,</span><br><span class="line">  &quot;pineapple pen apple&quot;,</span><br><span class="line">  &quot;pine applepen apple&quot;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">```text</span><br><span class="line">Input:</span><br><span class="line">s = &quot;catsandog&quot;</span><br><span class="line">wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">Output:</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><h2 id="dynamic-programming-1">Dynamic Programming</h2><p>Just let <code>dp[i]</code> be the all such possible sentences of <code>s[0 .. i)</code>. The induction rule is absolutely the same with Word Break I.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s: str, wordDict: list)</span> -&gt; list:</span></span><br><span class="line">        n, wordDict = len(s), set(wordDict)</span><br><span class="line">        dp = [[<span class="string">""</span>]] + [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> dp[j] <span class="keyword">and</span> s[j:i] <span class="keyword">in</span> wordDict:</span><br><span class="line">                    dp[i].extend((x + <span class="string">' '</span> + s[j:i]).lstrip()</span><br><span class="line">                                 <span class="keyword">for</span> x <span class="keyword">in</span> dp[j])</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Best Time to Buy and Sell Stock</title>
      <link href="/programming/leetcode/best-time-to-buy-and-sell-stock/"/>
      <url>/programming/leetcode/best-time-to-buy-and-sell-stock/</url>
      
        <content type="html"><![CDATA[<h1 id="at-most-1-transaction">At most 1 transaction</h1><p>Say you have an array for which the <code>i</code>-th element is the price of a given stock on day <code>i</code>.</p><p>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p><p>Not that you cannnot sell a stock before you buy one.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [7,1,5,3,6,4]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><h2 id="broute-force">Broute Force</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: list)</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> sell <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            <span class="comment"># range(sell + 1) also works.</span></span><br><span class="line">            <span class="comment"># prices[sell] is the minimum price by far,</span></span><br><span class="line">            <span class="comment"># prices[sell] - prices[min_price] = 0,</span></span><br><span class="line">            <span class="comment"># hence, res = max(res, 0)</span></span><br><span class="line">            min_price = min(prices[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(sell))</span><br><span class="line">            res = max(res, prices[sell] - prices[min_price])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>We can use a variable to save the minimum price by far instead of computing repetitively.</p><a id="more"></a><h2 id="one-pass">One Pass</h2><p>Say the given array is <code>[7,1,5,3,6,4]</code>. If we plot the numbers of the given array on a graph, we get:</p><p><img src="/uploads/image/leetcode/maximum_profit_graph.png"></p><p><strong>The points of interest are the peaks and valleys in the given graph. We need to find the largest peak following the smallest valley.</strong> We can maintain two variables - <code>minprice</code> and <code>maxprofit</code> corresponding to the smallest valley and maximum profit obtained so far respectively.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: list)</span> -&gt; int:</span></span><br><span class="line">        min_price, max_profit = float(<span class="string">'inf'</span>), <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> prices:</span><br><span class="line">            min_price = min(min_price, p)</span><br><span class="line">            max_profit = max(max_profit, p - min_price)</span><br><span class="line">        <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure><h2 id="maximum-subarray">Maximum Subarray</h2><p>We can transform the problem to the Maximum Subarray problem. Here gives the Dynamic Programming solution of the Maximum Subarray problem, see <a href="/programming/leetcode/maximum-subarray/" title="Maximum Subarray">Maximum Subarray</a> for other solutions.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: list)</span> -&gt; int:</span></span><br><span class="line">        cur = res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            cur = max(cur, <span class="number">0</span>) + prices[i] - prices[i - <span class="number">1</span>]</span><br><span class="line">            res = max(res, cur)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="at-most-2-transactions">At most 2 transactions</h1><p>Design an algorithm to find the maximum profit. You may complete at most two transactions.</p><p><strong>Note:</strong> You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,3,5,0,0,3,1,4]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3,4,5]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p>Example 3:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><h2 id="one-pass-1">One Pass</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Variation 1</span></span><br><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: list)</span> -&gt; int:</span></span><br><span class="line">        profit1 = profit2 = <span class="number">0</span></span><br><span class="line">        min_price1 = min_price2 = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> prices:</span><br><span class="line">            profit2 = max(profit2, p - min_price2)</span><br><span class="line">            min_price2 = min(min_price2, p - profit1)</span><br><span class="line">            profit1 = max(profit1, p - min_price1)</span><br><span class="line">            min_price1 = min(min_price1, p)</span><br><span class="line">        <span class="keyword">return</span> profit2</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Variation 2</span></span><br><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: list)</span> -&gt; int:</span></span><br><span class="line">        profit1 = profit2 = <span class="number">0</span></span><br><span class="line">        min_price1 = min_price2 = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> prices:</span><br><span class="line">            min_price1 = min(min_price1, p)</span><br><span class="line">            profit1 = max(profit1, p - min_price1)</span><br><span class="line">            <span class="comment"># considering how much we can earned if we have `profit1`</span></span><br><span class="line">            min_price2 = min(min_price2, p - profit1)</span><br><span class="line">            profit2 = max(profit2, p - min_price2)</span><br><span class="line">        <span class="keyword">return</span> profit2</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e.g. prices = [1, 2, 0, 3, 1, 2, 0, 4]</span><br><span class="line">                     ^  ^        ^  ^</span><br><span class="line"></span><br><span class="line"> p                 1   2   0   3   1   2   0   4</span><br><span class="line">m1=min(m1, p)      1   1   0   0   0   0   0   0  &lt;- minimum price by far</span><br><span class="line">p1=max(p1, p-m1)   0   1   1   3   3   3   3   4  &lt;- maximum profit by far</span><br><span class="line">           p-p1    1   1  -1   0  -2  -1  -3   0  &lt;- the price we buy a stock if we&apos;ve earned p1</span><br><span class="line">m2=min(m2, p-p1)   1   1  -1  -1  -2  -2  -3  -3  &lt;- minimum price if we&apos;ve earned p1</span><br><span class="line">p2=max(p2, p-m2)   0   1   1   4   4   4   4   7  &lt;- total profit</span><br></pre></td></tr></table></figure><h1 id="at-most-k-transactions">At most k transactions</h1><p>Design an algorithm to find the maximum profit. You may complete at most <strong>k</strong> transactions.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,4,1], k = 2</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,2,6,5,0,3], k = 2</span><br><span class="line">Output: 7</span><br></pre></td></tr></table></figure><h2 id="dynamic-programming">Dynamic Programming</h2><p>Let <code>dp[k][n]</code> be the maximum profit completing at most <code>k</code> transactions on <code>n</code>-th day. <code>n</code> start from 1. Hence, <code>n</code>-th day's price is <code>prices[n - 1]</code>.</p><p>Base case: <code>dp[0][n] = dp[k][0] =  0</code>. Say <code>prices = [1,2,0,3]</code>, the base case is:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">prices      1   2   0   3</span><br><span class="line">       d0  d1  d2  d3  d4</span><br><span class="line">   t0   0   0   0   0   0</span><br><span class="line">   t1   0</span><br><span class="line">   t2   0</span><br></pre></td></tr></table></figure><p>Induction rules:</p><p>For filling in the entry of <code>dp[i][j]</code>,</p><ul><li>If we don't sell a stock on <code>j</code>-th day, <code>dp[i][j] = dp[i][j - 1]</code>.</li><li>If we sell a stock on <code>j</code>-th day, we must buy a stock on <code>x</code>-th day where <code>1 &lt;= x &lt; j</code>, <code>dp[i][j] = max(dp[i - 1][x - 1] - prices[x - 1] + prices[j - 1] | 1 &lt;= x &lt; j)</code>. <strong>If <code>x = j</code>, means we buy and sell a stock on one day, which is effectively trading nothing.</strong> So, <code>1 &lt;= x &lt;= j</code> also works well. This helps when we reduce the time complexity later.</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][j] = max(dp[i][j - 1],</span><br><span class="line">               max(dp[i - 1][x - 1] - prices[x - 1] | 1 &lt;= x &lt;= j) + prices[j - 1])</span><br><span class="line">                                      ^ buy on x-th day              ^ sell on j-th day</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(kn^2)</span></span><br><span class="line"><span class="comment"># Space: O(kn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, k: int, prices: list)</span> -&gt; int:</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(k + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, k + <span class="number">1</span>):  <span class="comment"># O(k), add an outer loop, dealing with transactions</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):  <span class="comment"># O(n)</span></span><br><span class="line">                val = max(dp[i - <span class="number">1</span>][x] - prices[x] <span class="keyword">for</span> x <span class="keyword">in</span> range(j))  <span class="comment"># O(n), 0 &lt;= x &lt;= j - 1</span></span><br><span class="line">                dp[i][j] = max(dp[i][j - <span class="number">1</span>], val + prices[j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[k][n]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(kn)</span></span><br><span class="line"><span class="comment"># Space: O(kn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, k: int, prices: list)</span> -&gt; int:</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(k + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, k + <span class="number">1</span>):  <span class="comment"># O(k)</span></span><br><span class="line">            val = float(<span class="string">'-inf'</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):  <span class="comment"># O(n)</span></span><br><span class="line">                val = max(val, dp[i - <span class="number">1</span>][j - <span class="number">1</span>] - prices[j - <span class="number">1</span>])  <span class="comment"># O(1)</span></span><br><span class="line">                dp[i][j] = max(dp[i][j - <span class="number">1</span>], val + prices[j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[k][n]</span><br></pre></td></tr></table></figure><h1 id="from-dp-to-one-pass">From DP to One Pass</h1><ul><li>Exchange the two <code>for</code> loop. <code>val</code> is different with different <code>i</code>, so we need a vector to store values separately.</li><li>Transpose array <code>dp</code>.</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(kn)</span></span><br><span class="line"><span class="comment"># Space: O(kn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: list)</span> -&gt; int:</span></span><br><span class="line">        n, k = len(prices), <span class="number">2</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (k + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)]  <span class="comment"># transposed</span></span><br><span class="line">        val = [float(<span class="string">'-inf'</span>)] * (k + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):  <span class="comment"># on j-th day</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, k + <span class="number">1</span>):</span><br><span class="line">                val[i] = max(val[i], dp[j - <span class="number">1</span>][i - <span class="number">1</span>] - prices[j - <span class="number">1</span>])</span><br><span class="line">                dp[j][i] = max(dp[j - <span class="number">1</span>][i], val[i] + prices[j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[n][k]</span><br></pre></td></tr></table></figure><h2 id="loop-backward">Loop backward</h2><p>It seems like <code>dp[j][i]</code> is dependent on <code>dp[j - 1][i]</code> and <code>dp[j - 1][i - 1]</code>. So, if we want to use a vector to instead array, we need to loop backwards from <code>k</code> to 1.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(kn)</span></span><br><span class="line"><span class="comment"># Space: O(k)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: list)</span> -&gt; int:</span></span><br><span class="line">        n, k = len(prices), <span class="number">2</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (k + <span class="number">1</span>)  <span class="comment"># using vector</span></span><br><span class="line">        val = [float(<span class="string">'-inf'</span>)] * (k + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(k, <span class="number">0</span>, <span class="number">-1</span>):  <span class="comment"># backward</span></span><br><span class="line">                val[i] = max(val[i], dp[i - <span class="number">1</span>] - prices[j - <span class="number">1</span>])</span><br><span class="line">                dp[i] = max(dp[i], val[i] + prices[j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[k]</span><br></pre></td></tr></table></figure><p>Let <code>dp = [sell_0, sell_1, sell_2]</code> and <code>val = [buy_0, buy_1, buy_2]</code>, we can reduce the space complexity further.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: list)</span> -&gt; int:</span></span><br><span class="line">        buy_1 = buy_2 = float(<span class="string">'-inf'</span>)</span><br><span class="line">        sell_1 = sell_2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> prices:</span><br><span class="line">            buy_2 = max(buy_2, sell_1 - p)  <span class="comment"># buy_2 &lt;- val[2]</span></span><br><span class="line">            sell_2 = max(sell_2, buy_2 + p)</span><br><span class="line">            buy_1 = max(buy_1, -p)</span><br><span class="line">            sell_1 = max(sell_1, buy_1 + p)</span><br><span class="line">        <span class="keyword">return</span> sell_2</span><br></pre></td></tr></table></figure><h2 id="loop-forward">Loop forward</h2><p>Actually, loop forwards from 1 to k is also feasible. <strong>Because even if <code>dp[j - 1][i - 1]</code> is updated to <code>dp[j][i - 1]</code>, <code>var[i]</code> has the same value.</strong></p><p><code>dp[j][i - 1]</code> can be larger than or equal to <code>dp[j - 1][i - 1]</code>.</p><ul><li>If <code>dp[j][i - 1] = dp[j - 1][i - 1]</code>, obviously <code>var[i]</code> won't change.</li><li>If <code>dp[j][i - 1] &gt; dp[j - 1][i - 1]</code>, means we have sold a stock on <code>j</code>-th day. Since <code>var[i] = max(var[i], dp[j][i - 1] - price[j - 1])</code>, buy and sell a stock on one day is effectively trading noting.</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: list)</span> -&gt; int:</span></span><br><span class="line">        buy_1 = buy_2 = float(<span class="string">'-inf'</span>)</span><br><span class="line">        sell_1 = sell_2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> prices:</span><br><span class="line">            buy_1 = max(buy_1, -p)</span><br><span class="line">            sell_1 = max(sell_1, buy_1 + p)</span><br><span class="line">            buy_2 = max(buy_2, sell_1 - p)</span><br><span class="line">            sell_2 = max(sell_2, buy_2 + p)</span><br><span class="line">        <span class="keyword">return</span> sell_2</span><br></pre></td></tr></table></figure><h1 id="with-cooldown">with Cooldown</h1><p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:</p><ul><li>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</li><li>After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)</li></ul><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3,0,2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: transactions = [buy, sell, cooldown, buy, sell]</span><br></pre></td></tr></table></figure><h2 id="one-pass-2">One Pass</h2><p>Let <code>dp[i]</code> represents the maximum profit on the <code>i</code>-th day.</p><p>Base case: <code>dp[0] = 0</code>.</p><p>Induction rules:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i] = max(dp[i - 1],</span><br><span class="line">            max(dp[j - 2] - prices[j - 1] | 1 &lt;= j &lt;= i) + prices[i - 1])</span><br><span class="line">                ^           ^ buy on j-th day                     ^ sell on i-th day</span><br><span class="line">       max profit on (j-2)-th day</span><br></pre></td></tr></table></figure><p>When <code>j = 1</code>, <code>dp[j - 2] = dp[-1]</code> should be 0.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: list)</span> -&gt; int:</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)  <span class="comment"># dp[-1] = dp[n] = 0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            val = max(dp[j - <span class="number">1</span>] - prices[j] <span class="keyword">for</span> j <span class="keyword">in</span> range(i))</span><br><span class="line">            dp[i] = max(dp[i - <span class="number">1</span>], val + prices[i - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: list)</span> -&gt; int:</span></span><br><span class="line">        prev1 = prev2 = <span class="number">0</span>  <span class="comment"># maximum profits</span></span><br><span class="line">        val = float(<span class="string">'-inf'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> prices:</span><br><span class="line">            val = max(val, prev2 - p)</span><br><span class="line">            prev2 = prev1</span><br><span class="line">            prev1 = max(prev1, val + p)</span><br><span class="line">        <span class="keyword">return</span> prev1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Triangle</title>
      <link href="/programming/leetcode/triangle/"/>
      <url>/programming/leetcode/triangle/</url>
      
        <content type="html"><![CDATA[<p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p><p>For example, given the follwing triangle</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).</p><h1 id="dynamic-programming">Dynamic Programming</h1><p>Let <code>dp[i][j]</code> denotes the sum of minimum path that end at <code>triangle[i][j]</code>.</p><p>Base case: <code>dp[m - 1][j] = triangle[m - 1][j]</code>. Where <code>m</code> is the length of <code>triangle</code>.</p><p>Induction rule: <code>dp[i][j] = triangle[i][j] + min(dp[i + 1][j], dp[i + 1][j + 1])</code>.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn), where n is the length of last row in triangle.</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle: list)</span> -&gt; int:</span></span><br><span class="line">        m, dp = len(triangle), triangle[<span class="number">-1</span>][:]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(triangle[i])):</span><br><span class="line">                dp[j] = triangle[i][j] + min(dp[j], dp[j + <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Distinct Subsequences</title>
      <link href="/programming/leetcode/distinct-subsequences/"/>
      <url>/programming/leetcode/distinct-subsequences/</url>
      
        <content type="html"><![CDATA[<p>Given a string <strong>S</strong> and a string <strong>T</strong>, count the number of distinct subsequences of <strong>S</strong> which equals <strong>T</strong>.</p><p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, &quot;ACE&quot; is a subsequence of &quot;ABCDE&quot; while &quot;AEC&quot; is not).</p><p>It's guaranteed the answer fits on a 32-bit signed integer.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: S = &quot;rabbbit&quot;, T = &quot;rabbit&quot;</span><br><span class="line">Ouput: 3</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: S = &quot;babgbag&quot;, T = &quot;bag&quot;</span><br><span class="line">Ouput: 5</span><br></pre></td></tr></table></figure><h1 id="dynamic-programming">Dynamic Programming</h1><p>Let <code>dp[i][j]</code> denotes the number of distinct subsequences of <code>s[0 .. i - 1]</code> which equals <code>t[0 .. j - 1]</code>.</p><p>Base cases:</p><ul><li>If <code>j == 0</code>, <code>dp[i][0] = 1</code>. An empty string is a subsequences of any strings.</li><li>If <code>i == 0</code>, <code>dp[0][j] = 0</code>. A non-empty string is not a subsequences of an empty string. Specially, <code>dp[0][0] = 1</code>.</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e.g. s = &apos;baag&apos;, t = &apos;bag&apos;</span><br><span class="line"></span><br><span class="line">  s 0  1  2  3  4</span><br><span class="line">t   +--+--+--+--+</span><br><span class="line">0   1  1  1  1  1</span><br><span class="line">1   0</span><br><span class="line">2   0</span><br><span class="line">3   0</span><br></pre></td></tr></table></figure><a id="more"></a><p>Induction rules:</p><p>For filling in the entry of <code>dp[i][j]</code>,</p><ul><li>If <code>s[i - 1] != t[j - 1]</code>, then we have the same number of distinct subsequences as we had without the new character. <code>dp[i][j] = dp[i - 1][j]</code>.</li><li>If <code>s[i - 1] == t[j - 1]</code>, <code>dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]</code>. The number of distinct subsequences is the number when character <code>s[i - 1]</code> is chosen <strong>plus</strong> when it's not.</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(mn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDistinct</span><span class="params">(self, s: str, t: str)</span> -&gt; int:</span></span><br><span class="line">        m, n = len(s), len(t)</span><br><span class="line">        <span class="keyword">if</span> m &lt; n:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> m == n:</span><br><span class="line">            <span class="keyword">return</span> s == t</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDistinct</span><span class="params">(self, s: str, t: str)</span> -&gt; int:</span></span><br><span class="line">        m, n = len(s), len(t)</span><br><span class="line">        <span class="keyword">if</span> m &lt; n:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> m == n:</span><br><span class="line">            <span class="keyword">return</span> s == t</span><br><span class="line">        dp = [<span class="number">1</span>] + [<span class="number">0</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            cur = dp[:]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]:</span><br><span class="line">                    cur[j] = dp[j - <span class="number">1</span>] + dp[j]</span><br><span class="line">            dp = cur</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interleaving String</title>
      <link href="/programming/leetcode/interleaving-string/"/>
      <url>/programming/leetcode/interleaving-string/</url>
      
        <content type="html"><![CDATA[<p>Given <em>s1, s2, s3</em>, find whether <em>s3</em> is formed by the interleaving of <em>s1</em> and <em>s2</em>.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbaccc&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><h1 id="brute-force">Brute Force</h1><p>The most basic idea is to find every string possible by all interleavings of the two given strings <code>s1</code> and <code>s2</code>. <code>m</code> is the length of <code>s1</code>, <code>n</code> is the length of <code>s2</code>.</p><p>If <code>s3[0 .. i + j - 1]</code> is formed by the interleaving of <code>s1[0 .. i - 1]</code> and <code>s2[0 .. j - 1]</code>,</p><ul><li>If <code>s3[i + j] == s1[i]</code>, then check if <code>s3[i + j + 1 .. m + n - 1]</code> can be obtained by <code>s1[i + 1 .. m - 1]</code> and <code>s2[j .. n - 1]</code>.</li><li>If <code>s3[i + j] == s2[j]</code>, then check if <code>s3[i + j + 1 .. m + n - 1]</code> can be obtained by <code>s1[i .. m - 1]</code> and <code>s2[j + 1 .. n - 1]</code>.</li><li>Else, return false.</li></ul><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(2^(m + n))</span></span><br><span class="line"><span class="comment"># Space: O(m + n). The size of stack for recursive calls can go upto m + n.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isInterleave</span><span class="params">(self, s1: str, s2: str, s3: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(s1) + len(s2) != len(s3):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.is_interleave(s1, <span class="number">0</span>, s2, <span class="number">0</span>, s3)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_interleave</span><span class="params">(self, s1, i, s2, j, s3)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i == len(s1):</span><br><span class="line">            <span class="keyword">return</span> s2[j:] == s3[i + j:]</span><br><span class="line">        <span class="keyword">if</span> j == len(s2):</span><br><span class="line">            <span class="keyword">return</span> s1[i:] == s3[i + j:]</span><br><span class="line">        res = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> s1[i] == s3[i + j]:</span><br><span class="line">            res |= self.is_interleave(s1, i + <span class="number">1</span>, s2, j, s3)</span><br><span class="line">        <span class="keyword">if</span> s2[j] == s3[i + j]:</span><br><span class="line">            res |= self.is_interleave(s1, i, s2, j + <span class="number">1</span>, s3)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="recursion-with-memoization">Recursion with memoization</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn). Each (i, j) combination is computed only once.</span></span><br><span class="line"><span class="comment"># Space: O(mn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isInterleave</span><span class="params">(self, s1: str, s2: str, s3: str)</span> -&gt; bool:</span></span><br><span class="line">        m, n = len(s1), len(s2)</span><br><span class="line">        <span class="keyword">if</span> m + n != len(s3):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        memo = [[<span class="literal">None</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">return</span> self.is_interleave(s1, <span class="number">0</span>, s2, <span class="number">0</span>, s3, memo)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_interleave</span><span class="params">(self, s1, i, s2, j, s3, memo)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> memo[i][j] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> memo[i][j]</span><br><span class="line">        res = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> i == len(s1):</span><br><span class="line">            res = s2[j:] == s3[i + j:]</span><br><span class="line">        <span class="keyword">elif</span> j == len(s2):</span><br><span class="line">            res = s1[i:] == s3[i + j:]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> s1[i] == s3[i + j]:</span><br><span class="line">                res |= self.is_interleave(s1, i + <span class="number">1</span>, s2, j, s3, memo)</span><br><span class="line">            <span class="keyword">if</span> s2[j] == s3[i + j]:</span><br><span class="line">                res |= self.is_interleave(s1, i, s2, j + <span class="number">1</span>, s3, memo)</span><br><span class="line">        memo[i][j] = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="dynamic-programming">Dynamic Programming</h1><p><code>dp[i][j] = true</code> if it is possible to obtain a substring <code>s3[0 .. i + j - 1]</code> by some interleaving of substring <code>s1[0 .. i - 1]</code> and <code>s2[0 .. j - 1]</code>.</p><p>Base case: <code>dp[0][0] = true</code>.</p><p>Induction rules:</p><p>For filling in the entry of <code>dp[i][j]</code>, we need to consider three cases:</p><ul><li>If <code>s3[i + j - 1] == s1[i - 1]</code>, the <code>s3[0 .. i + j - 2]</code> may formed by <code>s1[0 .. i - 2]</code> and <code>s2[0 .. j - 1]</code>. i.e. <code>dp[i][j] = dp[i - 1][j]</code>.</li><li>If <code>s3[i + j - 1] == s2[j - 1]</code>, similarily, <code>dp[i][j] = dp[i][j - 1]</code>.</li><li>If either, <code>s3[0 .. i + j - 1]</code> can't be formed by <code>s1[0 .. i - 1]</code> and <code>s2[0 .. j - 1]</code>. i.e. <code>dp[i][j] = false</code>.</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(mn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isInterleave</span><span class="params">(self, s1: str, s2: str, s3: str)</span> -&gt; bool:</span></span><br><span class="line">        m, n = len(s1), len(s2)</span><br><span class="line">        <span class="keyword">if</span> m + n != len(s3):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        dp = [[<span class="literal">False</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i == j == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">elif</span> i == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>] <span class="keyword">and</span> s2[j - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">elif</span> j == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] <span class="keyword">and</span> s1[i - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = (dp[i][j - <span class="number">1</span>] <span class="keyword">and</span> s2[j - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>]) <span class="keyword">or</span> \</span><br><span class="line">                               (dp[i - <span class="number">1</span>][j] <span class="keyword">and</span> s1[i - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isInterleave</span><span class="params">(self, s1: str, s2: str, s3: str)</span> -&gt; bool:</span></span><br><span class="line">        m, n = len(s1), len(s2)</span><br><span class="line">        <span class="keyword">if</span> m + n != len(s3):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        dp = [<span class="literal">False</span>] * (n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i == j == <span class="number">0</span>:</span><br><span class="line">                    dp[j] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">elif</span> i == <span class="number">0</span>:</span><br><span class="line">                    dp[j] = dp[j - <span class="number">1</span>] <span class="keyword">and</span> s2[j - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">elif</span> j == <span class="number">0</span>:</span><br><span class="line">                    dp[j] = dp[j] <span class="keyword">and</span> s1[i - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[j] = (dp[j - <span class="number">1</span>] <span class="keyword">and</span> s2[j - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>]) <span class="keyword">or</span> \</span><br><span class="line">                            (dp[j] <span class="keyword">and</span> s1[i - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> recursion </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unique Binary Search Trees</title>
      <link href="/programming/leetcode/unique-binary-search-trees/"/>
      <url>/programming/leetcode/unique-binary-search-trees/</url>
      
        <content type="html"><![CDATA[<h1 id="unique-binary-search-tree">Unique Binary Search Tree</h1><p>Given <em>n</em>, how many structurally unique <strong>BST's</strong> (binary search trees) that store values <em>1 ... n</em>?</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><h2 id="dynamic-programming">Dynamic Programming</h2><p>Let <code>dp[n]</code> denotes the number of unique BST's that store values <code>1 .. n</code>.</p><p>Base case: <code>dp[1] = 1</code>.</p><p>Induction rules:</p><p>Let <code>i</code> be the root node of a BST that store values <code>1 .. n</code>. For <code>i = 1 .. n</code>,</p><ul><li>In left subtree, values <code>1 .. i - 1</code> are stored, have <code>dp[i - 1]</code> unique structures.</li><li>In right subtree, values <code>i + 1 .. n</code> are stored. Number of unique structures is equal to <code>dp[n - i]</code>.</li></ul><a id="more"></a><p>So, we have <code>dp[i - 1] * dp[n - i]</code> unique BST's when <code>i</code> is root node. In particular, we let <code>dp[0] = 1</code>.</p><p>Therefore,</p><p><span class="math display">\[dp[n]=\sum_{i=1}^n \big(dp[i-1]*dp[n-i]\big)\]</span></p><p>e.g.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n = 1, dp[1] = 1</span><br><span class="line">n = 2,</span><br><span class="line">    If 1 is root, we have dp[0] * dp[1] = 1 unique BST.</span><br><span class="line">    If 2 is root, we have dp[1] * dp[0] = 1 unique BST.</span><br><span class="line">n = 3,</span><br><span class="line">    If 1 is root, we have dp[0] * dp[2] = 2 unique BST&apos;s.</span><br><span class="line">    If 2 is root, we have dp[1] * dp[1] = 1 unique BST.</span><br><span class="line">    If 3 is root, we have dp[2] * dp[0] = 2 unique BST&apos;s.</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> nn <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, nn + <span class="number">1</span>):</span><br><span class="line">                dp[nn] += dp[i - <span class="number">1</span>] * dp[nn - i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><h1 id="unique-binary-search-tree-ii">Unique Binary Search Tree II</h1><p>Given an integer <em>n</em>, generate all structurally unique <strong>BST's</strong> (binary search trees) that store values <em>1 ... n</em>.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  1         3     3     2     1</span><br><span class="line">   \       /     /     / \     \</span><br><span class="line">    3     2     1     1   3     2</span><br><span class="line">   /     /       \               \</span><br><span class="line">  2     1         2               3</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="dynamic-programming-1">Dynamic Programming</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n: int)</span> -&gt; list:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        dp = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>].append(<span class="literal">None</span>)</span><br><span class="line">        dp[<span class="number">1</span>].append(TreeNode(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> nn <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, nn + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> left <span class="keyword">in</span> dp[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">for</span> right <span class="keyword">in</span> dp[nn - i]:</span><br><span class="line">                        dp[nn].append(TreeNode(i, left, self.clone_tree(right, i)))</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clone_tree</span><span class="params">(self, node, sift)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        clone = TreeNode(node.val + sift)</span><br><span class="line">        clone.left = self.clone_tree(node.left, sift)</span><br><span class="line">        clone.right = self.clone_tree(node.right, sift)</span><br><span class="line">        <span class="keyword">return</span> clone</span><br></pre></td></tr></table></figure><h2 id="divide-and-conquer">Divide and Conquer</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n: int)</span> -&gt; list:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> self.generateSubtrees(<span class="number">1</span>, n)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateSubtrees</span><span class="params">(self, s, e)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> s &gt; e:</span><br><span class="line">            <span class="keyword">return</span> [<span class="literal">None</span>]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(s, e + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> left <span class="keyword">in</span> self.generateSubtrees(s, i - <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> right <span class="keyword">in</span> self.generateSubtrees(i + <span class="number">1</span>, e):</span><br><span class="line">                    res.append(TreeNode(i, left, right))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> divide and conquer </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Decode Ways</title>
      <link href="/programming/leetcode/decode-ways/"/>
      <url>/programming/leetcode/decode-ways/</url>
      
        <content type="html"><![CDATA[<p>A message containing letters from <code>A-Z</code> is being encoded to numbers using the follwing mapping:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;A&apos; -&gt; 1</span><br><span class="line">&apos;B&apos; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&apos;Z&apos; -&gt; 26</span><br></pre></td></tr></table></figure><p>Given a <strong>non-empty</strong> string containing only digits, determine the total number of ways to decode it.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;12&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;226&quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p>Example 3:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;606&quot;</span><br><span class="line">Ouput: 0</span><br></pre></td></tr></table></figure><h1 id="dynamic-programming">Dynamic Programming</h1><p>Let <code>dp[i]</code> denotes the number of ways to decode the first <code>i</code> chars.</p><a id="more"></a><p>Base cases:</p><ul><li>If <code>s[0] != '0'</code>, then we have one decode way, <code>dp[1] = 1</code>.</li><li>If <code>s[0] == '0'</code>, <code>dp[1] = 0</code>.</li></ul><p>Induction rules:</p><p>Let <code>t1</code> be the digital number of <code>s[i - 1]</code> and <code>t2</code> be the digital number of <code>s[i - 2]s[i - 1]</code>.</p><p>Let <code>d1 = 1 &lt;= t1 &lt;= 9</code>, <code>d2 = 10 &lt;= t2 &lt;= 26</code>.</p><ul><li>If <code>d1 == True and d2 == False</code>, we can decode <code>s[i - 1]</code> as one letter, <code>dp[i] = dp[i - 1]</code>. e.g. <code>s = 35</code>.</li><li>If <code>d1 == False and d2 == True</code>, we can decode <code>s[i - 2]s[i - 1]</code> as one letter, <code>dp[i] = dp[i - 2]</code>. e.g. <code>s = 10</code>.</li><li>If <code>d1 == True and d2 == True</code>, <code>dp[i] = dp[i - 2] + dp[i - 1]</code>. e.g. <code>s = 24</code>.</li><li>If <code>d1 == False and d2 == False</code>, <code>dp[i] = 0</code>. e.g. <code>s = 30</code>.</li></ul><p><code>dp[0]</code> is used when <code>i == 2</code>, let <code>dp[0] = 1</code> is a good idea. Or, we give the base cases of <code>i = 1, 2</code>, and let the iteration start from <code>i = 3</code>.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="number">1</span>, int(s[<span class="number">0</span>] != <span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="number">1</span> &lt;= int(s[i - <span class="number">1</span>]) &lt;= <span class="number">9</span>:</span><br><span class="line">                dp[i] += dp[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="number">10</span> &lt;= int(s[i - <span class="number">2</span>: i]) &lt;= <span class="number">26</span>:</span><br><span class="line">                dp[i] += dp[i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        pre, res = <span class="number">1</span>, int(s[<span class="number">0</span>] != <span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            nxt = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">1</span> &lt;= int(s[i - <span class="number">1</span>]) &lt;= <span class="number">9</span>:</span><br><span class="line">                nxt += res</span><br><span class="line">            <span class="keyword">if</span> <span class="number">10</span> &lt;= int(s[i - <span class="number">2</span>: i]) &lt;= <span class="number">26</span>:</span><br><span class="line">                nxt += pre</span><br><span class="line">            pre = res</span><br><span class="line">            res = nxt</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网格搜索</title>
      <link href="/notes/introduction-to-ml-with-python/grid-search/"/>
      <url>/notes/introduction-to-ml-with-python/grid-search/</url>
      
        <content type="html"><![CDATA[<p>找到一个模型的重要参数（提供最佳泛化性能的参数）的取值是一项棘手的任务，但对于几乎所有模型和数据集来说都是必要的。由于这项任务如此常见，所以 scikit-learn 中有一些标准方法可以帮你完成。最常见的就是<strong>网格搜索</strong>（grid search），它主要指尝试我们关心的参数的所有可能组合。</p><p>考虑一个具有 RBF（径向基函数）核的核 SVM 的例子，它在 SVC 类中实现。它有 2 个重要参数：核宽度 gamma 核正则化参数 C。假设我们希望尝试 C 的取值为 0.001、0.01、0.1、1、10 和 100，gamma 也取这 6 个值，所以总共有 36 种参数组合。</p><a id="more"></a><h1 id="简单网格搜索">简单网格搜索</h1><p>我们可以实现一个简单的网格搜索，在 2 个参数上使用 for 循环，对每种参数组合分别训练并评估一个分类器。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 简单的网格搜索实现</span></span><br><span class="line">iris = load_iris()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">    iris.data, iris.target, random_state=<span class="number">0</span>)</span><br><span class="line">print(<span class="string">'Size of training set: &#123;&#125;  size of test set: &#123;&#125;'</span>.format(</span><br><span class="line">    X_train.shape[<span class="number">0</span>], X_test.shape[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">best_score = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> gamma <span class="keyword">in</span> [<span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>]:</span><br><span class="line">    <span class="keyword">for</span> C <span class="keyword">in</span> [<span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>]:</span><br><span class="line">        <span class="comment"># 对每种参数组合都训练一个SVC</span></span><br><span class="line">        svm = SVC(gamma=gamma, C=C)</span><br><span class="line">        svm.fit(X_train, y_train)</span><br><span class="line">        <span class="comment"># 在测试集上评估SVC</span></span><br><span class="line">        score = svm.score(X_test, y_test)</span><br><span class="line">        <span class="keyword">if</span> score &gt; best_score:</span><br><span class="line">            best_score = score</span><br><span class="line">            best_parameters = &#123;<span class="string">'C'</span>: C, <span class="string">'gamma'</span>: gamma&#125;</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Best score: &#123;:.2f&#125;'</span>.format(best_score))</span><br><span class="line">print(<span class="string">'Best parameters: &#123;&#125;'</span>.format(best_parameters))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Size of training set: 112  size of test set: 38</span><br><span class="line">Best score: 0.97</span><br><span class="line">Best parameters: &#123;&apos;C&apos;: 100, &apos;gamma&apos;: 0.001&#125;</span><br></pre></td></tr></table></figure><h1 id="参数过拟合的风险与验证集">参数过拟合的风险与验证集</h1><p>看到这个结果，我们可能忍不住要报告，我们找到了一个在数据集上精度达到 97% 的模型。然而，这种说法可能过于乐观了（或者就是错误的），其原因如下：我们尝试了许多不同的参数，并选择了在测试集上精度最高的那个，但这个精度不一定能推广到新数据上。<strong>由于我们使用测试数据进行调参，所以不能再用它来评估模型的好坏。</strong>我们最开始需要将数据划分为训练集和测试集也是因为这个原因。<strong>我们需要一个独立的数据集来进行评估，一个在创建模型时没有用到的数据集。</strong></p><p>为了解决这个问题，一种方法是再次划分数据，这样我们得到了 3 个数据集：用于构建模型的训练集，用于选择模型的验证集（开发集），用于评估所选参数性能的测试集。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_threefold_split()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/threefold-split.png"></p><p><strong>利用验证集选定最佳参数之后，我们可以找到的参数设置重新构建一个模型，但是要同时在训练数据和验证数据上进行训练。</strong>这样我们可以利用尽可能多的数据来构建模型。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将数据划分为训练+验证集与测试集</span></span><br><span class="line">X_trainval, X_test, y_trainval, y_test = train_test_split(</span><br><span class="line">    iris.data, iris.target, random_state=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 将训练+验证集划分为训练集和验证集</span></span><br><span class="line">X_train, X_valid, y_train, y_valid = train_test_split(</span><br><span class="line">    X_trainval, y_trainval, random_state=<span class="number">1</span>)</span><br><span class="line">print(<span class="string">'Size of training set: &#123;&#125;  size of validation set: &#123;&#125;  size of test set: &#123;&#125;'</span>.format(</span><br><span class="line">    X_train.shape[<span class="number">0</span>], X_valid.shape[<span class="number">0</span>], X_test.shape[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">best_score = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> gamma <span class="keyword">in</span> [<span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>]:</span><br><span class="line">    <span class="keyword">for</span> C <span class="keyword">in</span> [<span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>]:</span><br><span class="line">        <span class="comment"># 对每种参数组合都训练一个SVC</span></span><br><span class="line">        svm = SVC(gamma=gamma, C=C)</span><br><span class="line">        svm.fit(X_train, y_train)</span><br><span class="line">        <span class="comment"># 在测试集上评估SVC</span></span><br><span class="line">        score = svm.score(X_valid, y_valid)</span><br><span class="line">        <span class="keyword">if</span> score &gt; best_score:</span><br><span class="line">            best_score = score</span><br><span class="line">            best_parameters = &#123;<span class="string">'C'</span>: C, <span class="string">'gamma'</span>: gamma&#125;</span><br><span class="line"><span class="comment"># 在训练+验证集上重新构建一个模型，并在测试集上进行评估</span></span><br><span class="line">svm = SVC(**best_parameters)</span><br><span class="line">svm.fit(X_trainval, y_trainval)</span><br><span class="line">test_score = svm.score(X_test, y_test)</span><br><span class="line">print(<span class="string">'Best score on validation set: &#123;:.2f&#125;'</span>.format(best_score))</span><br><span class="line">print(<span class="string">'Best parameters: &#123;&#125;'</span>.format(best_parameters))</span><br><span class="line">print(<span class="string">'Test set score with best parameters: &#123;:.2f&#125;'</span>.format(test_score))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Size of training set: 84  size of validation set: 28  size of test set: 38</span><br><span class="line">Best score on validation set: 0.96</span><br><span class="line">Best parameters: &#123;&apos;C&apos;: 10, &apos;gamma&apos;: 0.001&#125;</span><br><span class="line">Test set score with best parameters: 0.92</span><br></pre></td></tr></table></figure><p>验证集上的最高分数是 96%，这比之前略低，可能是因为我们使用了更少的数据来训练模型。测试集上的分数更低，为 92%。因此，我们只能声称对 92% 的新数据正确分类，而不是我们之前认为的 97%。</p><p>训练集、验证集和测试集之间的区别对于在实践中应用机器学习方法至关重要。任何根据测试集精度所做的选择都会将测试集的信息“泄漏”（leak）到模型中。因此，<strong>保留一个单独的测试集是很重要的，它仅用于最终评估。</strong>严格来说，在测试集上对不止一个模型进行评估并选择更好的那个，将会导致对模型精度过于乐观的估计。</p><h1 id="带交叉验证的网格搜索">带交叉验证的网格搜索</h1><p>虽然将数据划分为训练集、验证集和测试集的方法是可行的，也相对常用，但这种方法对数据的划分方法相当敏感。为了得到对泛化性能的更好估计，我们可以使用交叉验证来评估每种参数组合的性能，而不是仅将数据单次划分为训练集与验证集。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> gamma <span class="keyword">in</span> [<span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>]:</span><br><span class="line">    <span class="keyword">for</span> C <span class="keyword">in</span> [<span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>]:</span><br><span class="line">        <span class="comment"># 对每种参数组合都训练一个SVC</span></span><br><span class="line">        svm = SVC(gamma=gamma, C=C)</span><br><span class="line">        svm.fit(X_train, y_train)</span><br><span class="line">        <span class="comment"># 执行交叉验证</span></span><br><span class="line">        scores = cross_val_score(svm, X_trainval, y_trainval, cv=<span class="number">5</span>)</span><br><span class="line">        <span class="comment"># 计算交叉验证的平均精度</span></span><br><span class="line">        score = np.mean(scores)</span><br><span class="line">        <span class="keyword">if</span> score &gt; best_score:</span><br><span class="line">            best_score = score</span><br><span class="line">            best_parameters = &#123;<span class="string">'C'</span>: C, <span class="string">'gamma'</span>: gamma&#125;</span><br><span class="line"><span class="comment"># 在训练+验证集上重新构建一个模型，并在测试集上进行评估</span></span><br><span class="line">svm = SVC(**best_parameters)</span><br><span class="line">svm.fit(X_trainval, y_trainval)</span><br></pre></td></tr></table></figure><p>要想使用 5 折交叉验证对 C 和 gamma 特定取值的 SVM 的精度进行评估，需要训练 36 x 5 = 180 个模型。你可以想象，使用交叉验证的主要缺点就是训练所有这些模型所需花费的时间。</p><p>下面的可视化说明了上述代码如何选择最佳参数设置。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_cross_val_selection()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/cross-val-grid-search.png"></p><p>对于每种参数设置（图中仅显示了一部分），需要计算 5 个精度值，交叉验证的每次划分都要计算一个精度值。然后，对每种参数设置计算平均验证精度。最后，选择平均验证精度最高的参数，用圆圈标记。</p><blockquote><p>交叉验证是在特定数据集上对给定模型进行评估的一种方法。但它通常与网格搜索等参数搜索方法结合使用。因此，许多人使用<strong>交叉验证</strong>（cross-validation）这一术语来通俗地指代带交叉验证的网格搜索。</p></blockquote><p>由于带交叉验证的网格搜索是一种常用的调参方法，因此 scikit-learn 提供了 GridSearchCV 类，它以估计器（estimator）的形式实现了这种方法。要使用 GridSearchCV 类，你首先需要用一个字典指定要搜索的参数。然后 GridSearchCV 会执行所有必要的模型拟合。字典的键是我们要调节的参数名称，字典的值是我们想要尝试的参数设置。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果 C 和 gamma 想要尝试的取值为 0.001、0.01、0.1、1、10 和 100</span></span><br><span class="line"><span class="comment"># 可以将其转化为下面这个字典</span></span><br><span class="line">param_grid = &#123;<span class="string">'C'</span>: [<span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>],</span><br><span class="line">              <span class="string">'gamma'</span>: [<span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="comment"># 将 GridSearchCV 实例化</span></span><br><span class="line">grid_search = GridSearchCV(SVC(), param_grid, cv=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># GridSearchCV 将使用交叉验证来代替之前的划分训练集和验证集方法</span></span><br><span class="line"><span class="comment"># 但是，我们仍需要将数据划分为训练集和测试集，以避免参数过拟合</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">    iris.data, iris.target, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建的 grid_search 对象的行为就像一个分类器</span></span><br><span class="line"><span class="comment"># 我们可以对它调用标准的 fit、predict 和 score 方法</span></span><br><span class="line"><span class="comment"># 但我们在调用 fit 时，它会对 param_grid 指定的每种参数组合都运行交叉验证</span></span><br><span class="line">grid_search.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拟合 GridSearchCV 对象不仅会搜索最佳参数，还会利用得到的最佳参数在整个</span></span><br><span class="line"><span class="comment"># 训练数据集上自动拟合一个新模型</span></span><br><span class="line"><span class="comment"># GridSearchCV 类提供了非常方便的接口，可以用 predict 和 score 方法来访问</span></span><br><span class="line"><span class="comment"># 重新训练过的模型</span></span><br><span class="line"><span class="comment"># 为了评估找到的最佳参数的泛化能力，我们可以在测试集上调用 score</span></span><br><span class="line">print(<span class="string">'Test set score: &#123;:.2f&#125;'</span>.format(grid_search.score(X_test, y_test)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们找到的参数保存在 best_params_ 属性中，而交叉验证最佳精度保存在 best_score_ 中</span></span><br><span class="line">print(<span class="string">'Best parameters: &#123;&#125;'</span>.format(grid_search.best_params_))</span><br><span class="line">print(<span class="string">'Best cross-validation score: &#123;:.2f&#125;'</span>.format(grid_search.best_score_))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 能够访问实际找到的模型，这有时是很有帮助的，比如查看系数或特征重要性</span></span><br><span class="line"><span class="comment"># 你可以用 best_estimator_ 属性来访问最佳参数对应的模型</span></span><br><span class="line"><span class="comment"># 由于 grid_search 本身具有 predict 和 score 方法</span></span><br><span class="line"><span class="comment"># 所以不需要使用 best_estimator_ 来进行预测和评估模型</span></span><br><span class="line">print(<span class="string">'Best estimator:\n&#123;&#125;'</span>.format(grid_search.best_estimator_))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test set score: 0.97</span><br><span class="line">Best parameters: &#123;&apos;C&apos;: 100, &apos;gamma&apos;: 0.01&#125;</span><br><span class="line">Best cross-validation score: 0.97</span><br><span class="line">Best estimator:</span><br><span class="line">SVC(C=100, cache_size=200, class_weight=None, coef0=0.0,</span><br><span class="line">    decision_function_shape=&apos;ovr&apos;, degree=3, gamma=0.01, kernel=&apos;rbf&apos;,</span><br><span class="line">    max_iter=-1, probability=False, random_state=None, shrinking=True,</span><br><span class="line">    tol=0.001, verbose=False)</span><br></pre></td></tr></table></figure><p>利用交叉验证选择参数，我们实际上找到了一个在测试集上精度为 97% 的模型。重要的是，我们<strong>没有使用测试集</strong>在选择参数。</p><p>注意不要将 <code>best_score_</code> 与 模型在测试集上调用 <code>score</code> 方法计算得到的泛化性能弄混。使用 <code>score</code> 方法（或者对 <code>predict</code> 方法的输出结果进行评估）采用的是<strong>在整个训练集上</strong>训练的模型。而 <code>best_score_</code> 属性保存的是交叉验证的平均精度，是<strong>在训练集上进行交叉验证</strong>得到的。</p><h2 id="分析交叉验证的结果">分析交叉验证的结果</h2><p>将交叉验证的结果可视化通常有助于理解模型泛化能力对所搜索参数的依赖关系。由于运行网格搜索的计算成本相当高，所以通常最好从相对比较稀疏且较小的网格开始搜索。然后我们可以检查交叉验证网格搜索的结果，可能也会扩展搜索范围。网格搜索的结果可以在 <code>cv_results_</code> 属性中找到，它是一个字典，其中保存了搜索的所有内容。它里面包含许多细节，最好将其转换成 pandas 数据框后查看：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">results = pd.DataFrame(grid_search.cv_results_)</span><br><span class="line"><span class="comment"># 显示前 5 行</span></span><br><span class="line">display(results.head())</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   mean_fit_time  std_fit_time  ...  std_test_score  rank_test_score</span><br><span class="line">0       0.000551      0.000136  ...        0.011371               22</span><br><span class="line">1       0.000453      0.000039  ...        0.011371               22</span><br><span class="line">2       0.000471      0.000039  ...        0.011371               22</span><br><span class="line">3       0.000438      0.000004  ...        0.011371               22</span><br><span class="line">4       0.000459      0.000028  ...        0.011371               22</span><br><span class="line"></span><br><span class="line">[5 rows x 15 columns]</span><br></pre></td></tr></table></figure><p>results 中每一行对应一种特定的参数设置。对于每种参数设置，交叉验证所有划分的结果都被记录下来，所有划分的平均值和标准差也被记录下来。由于我们搜索的是一个二维参数网格（C 和 gamma），所以最适合用热图可视化。我们首先提取平均验证分数，然后改变分数数组的形状，使其坐标轴分别对应于 C 和 gamma：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scores = np.array(results.mean_test_score).reshape(<span class="number">6</span>, <span class="number">6</span>)</span><br><span class="line"><span class="comment"># 对交叉验证平均分数作图</span></span><br><span class="line">mglearn.tools.heatmap(scores, xlabel=<span class="string">'gamma'</span>, xticklabels=param_grid[<span class="string">'gamma'</span>],</span><br><span class="line">    ylabel=<span class="string">'C'</span>, yticklabels=param_grid[<span class="string">'C'</span>], cmap=<span class="string">'viridis'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/grid-search-heatmap.png"></p><p>你可以看到，SVC 对参数设置非常敏感。对于许多种参数设置，精度都在 40% 左右，这是非常糟糕的；对于其他参数设置，精度约为 96%。我们可以从这张图中看出以下几点。首先，我们调节的参数对于获得良好的性能<strong>非常重要</strong>。这两个参数 都很重要，因为调节它们可以将精度从 40% 提高到 96%。此外，在我们选择的参数范围中也可以看到输出发生了显著的变化。同样重要的是要注意，参数的范围要足够大：每个参数的最佳取值不能位于图像的边界上。</p><p>下面我们来看几张图，其结果不那么理想，因为选择的搜索范围不合适。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">fig, axes = plt.subplots(<span class="number">1</span>, <span class="number">3</span>, figsize=(<span class="number">13</span>, <span class="number">5</span>))</span><br><span class="line">param_grid_linear = &#123;<span class="string">'C'</span>: np.linspace(<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>),</span><br><span class="line">                     <span class="string">'gamma'</span>: np.linspace(<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>)&#125;</span><br><span class="line"></span><br><span class="line">param_grid_one_log = &#123;<span class="string">'C'</span>: np.linspace(<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>),</span><br><span class="line">                     <span class="string">'gamma'</span>: np.logspace(<span class="number">-3</span>, <span class="number">2</span>, <span class="number">6</span>)&#125;</span><br><span class="line"></span><br><span class="line">param_grid_range = &#123;<span class="string">'C'</span>: np.logspace(<span class="number">-3</span>, <span class="number">2</span>, <span class="number">6</span>),</span><br><span class="line">                     <span class="string">'gamma'</span>: np.logspace(<span class="number">-7</span>, <span class="number">-2</span>, <span class="number">6</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> param_grid, ax <span class="keyword">in</span> zip([param_grid_linear, param_grid_one_log, </span><br><span class="line">                           param_grid_range], axes):</span><br><span class="line">    grid_search = GridSearchCV(SVC(), param_grid, cv=<span class="number">5</span>)</span><br><span class="line">    grid_search.fit(X_train, y_train)</span><br><span class="line">    scores = grid_search.cv_results_[<span class="string">'mean_test_score'</span>].reshape(<span class="number">6</span>, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    scores_image = mglearn.tools.heatmap(scores, xlabel=<span class="string">'gamma'</span>,</span><br><span class="line">        ylabel=<span class="string">'C'</span>, xticklabels=param_grid[<span class="string">'gamma'</span>],</span><br><span class="line">        yticklabels=param_grid[<span class="string">'C'</span>], cmap=<span class="string">'viridis'</span>, ax=ax)</span><br><span class="line"></span><br><span class="line">plt.colorbar(scores_image, ax=axes.tolist())</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/grid-search-heatmaps.png"></p><p>第一张图没有显示任何变化。在这种情况下，这是由参数 C 和 gamma 不正确的缩放以及不正确的范围造成的。但如果对于不同的参数设置都看不到精度的变化，也可能是因为这个参数根本不重要。<strong>通常最好在开始时尝试非常极端的值，以观察改变参数是否会导致精度发生变化。</strong></p><p>第二张图显示的是垂直条形模式。这表示只有 gamma 的设置对精度有影响。这可能意味着 gamma 参数的搜索范围是我们所关心的，而 C 参数并不是——也可能意味着 C 参数并不重要。</p><p>第三张图中 C 和 gamma 对应的精度都有变化。但可以看到，在图像的整个左下角都没有发生什么有趣的事情。我们在后面的网格搜索中可以不考虑非常小的值。最佳参数设置出现在右上角。由于最佳参数位于图像的边界，所以我们可以认为，在这个边界之外可能还有更好的取值，我们可能希望改变搜索范围以包含这一区域内的更多参数。</p><p>基于交叉验证分数来调节参数网格是非常好的，也是探索不同参数的重要性的好方法。但是，你不应该在最终测试集上测试不同的参数范围（在验证集上进行调参）——只有确切知道了想要使用的模型，才能对测试集进行评估（在测试集上进行评估）。</p><h2 id="在非网格的空间中搜索">在非网格的空间中搜索</h2><p>在某些情况下，尝试所有参数的所有可能组合并不是一个好主意。例如，SVC 有一个 kernel 参数，根据所选择的 kernel（内核），其他参数也是与之相关的。如果 <code>kernel='linear'</code>，那么模型是线性的，只会用到 C 参数。如果 <code>kernel='rbf'</code>，则需要使用 C 和 gamma 两个参数（但用不到类似 degree 的其他参数）。在这种情况下，搜索 C、gamma 和 kernel 所有可能的组合没有意义：如果 <code>kernel='linear'</code>，那么 gamma 是用不到的，尝试 gamma 的不同取值将会浪费时间。为了处理这种“条件”（conditional）参数，GridSearchCV 的 <code>param_grid</code> 可以是字典组成的列表。列表中每个字典可扩展为一个独立的网格。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">param_grid = [&#123;<span class="string">'kernel'</span>: [<span class="string">'rbf'</span>],  <span class="comment"># kernel 是一个长度为 1 的列表</span></span><br><span class="line">               <span class="string">'C'</span>: [<span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>],</span><br><span class="line">               <span class="string">'gamma'</span>: [<span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>]&#125;,</span><br><span class="line">              &#123;<span class="string">'kernel'</span>: [<span class="string">'linear'</span>],</span><br><span class="line">               <span class="string">'C'</span>: [<span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>]&#125;]</span><br><span class="line">grid_search = GridSearchCV(SVC(), param_grid, cv=<span class="number">5</span>)</span><br><span class="line">grid_search.fit(X_train, y_train)</span><br><span class="line">print(<span class="string">'Best parameters: &#123;&#125;'</span>.format(grid_search.best_params_))</span><br><span class="line">print(<span class="string">'Best cross-validation score: &#123;:.2f&#125;'</span>.format(grid_search.best_score_))</span><br><span class="line"></span><br><span class="line">results = pd.DataFrame(grid_search.cv_results_)</span><br><span class="line"><span class="comment"># 再次查看 cv_results_，如果 kernel='linear'，那么只有 C 是变化的</span></span><br><span class="line">display(results.T)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Best parameters: &#123;&apos;C&apos;: 100, &apos;gamma&apos;: 0.01, &apos;kernel&apos;: &apos;rbf&apos;&#125;</span><br><span class="line">Best cross-validation score: 0.97</span><br><span class="line">                                                               0  ...                              41</span><br><span class="line">mean_fit_time                                        0.000518799  ...                     0.000275612</span><br><span class="line">std_fit_time                                         8.65673e-05  ...                     1.92715e-05</span><br><span class="line">mean_score_time                                      0.000243187  ...                     0.000154543</span><br><span class="line">std_score_time                                       5.89067e-05  ...                     1.61281e-06</span><br><span class="line">param_C                                                    0.001  ...                             100</span><br><span class="line">param_gamma                                                0.001  ...                             NaN</span><br><span class="line">param_kernel                                                 rbf  ...                          linear</span><br><span class="line">params             &#123;&apos;C&apos;: 0.001, &apos;gamma&apos;: 0.001, &apos;kernel&apos;: &apos;rbf&apos;&#125;  ...  &#123;&apos;C&apos;: 100, &apos;kernel&apos;: &apos;linear&apos;&#125;</span><br><span class="line">split0_test_score                                          0.375  ...                        0.958333</span><br><span class="line">split1_test_score                                       0.347826  ...                               1</span><br><span class="line">split2_test_score                                       0.363636  ...                               1</span><br><span class="line">split3_test_score                                       0.363636  ...                        0.909091</span><br><span class="line">split4_test_score                                       0.380952  ...                        0.952381</span><br><span class="line">mean_test_score                                         0.366071  ...                        0.964286</span><br><span class="line">std_test_score                                         0.0113708  ...                       0.0338387</span><br><span class="line">rank_test_score                                               27  ...                               3</span><br><span class="line"></span><br><span class="line">[16 rows x 42 columns]</span><br></pre></td></tr></table></figure><h2 id="使用不同的交叉验证策略进行网格搜索">使用不同的交叉验证策略进行网格搜索</h2><p>与 <code>cross_val_score</code> 类似，GridSearchCV 对分类问题默认使用分层 <span class="math inline">\(k\)</span> 折交叉验证，对回归问题默认使用 <span class="math inline">\(k\)</span> 折交叉验证。但是，你可以传入任何交叉验证分离器作为 GridSearchCV 的 cv 参数。特别地，如果只想将数据单词划分为训练集和验证集，你可以使用 ShuffleSplit 或 StratifiedShuffleSplit，并设置 <code>n_iter=1</code>。这对于非常大的数据集或非常慢的模型可能会有帮助。</p><h3 id="嵌套交叉验证">嵌套交叉验证</h3><p>前面在使用 GridSearchCV 时，我们仍然将数据单次划分为训练集和测试集，这可能会导致结果不稳定，也让我们过于依赖数据的此次划分。我们可以再深入一点，不是只将原始数据一次划分为训练集和测试集，而是使用交叉验证进行多次划分，这就是所谓的<strong>嵌套交叉验证</strong>（nested cross-validation）。在嵌套交叉验证中，有一个外层循环，遍历将数据划分为训练集和测试集的所有划分。对于每种划分都运行一次网格搜索（对于外层循环的每种划分可能会得到不同的最佳参数）。然后，对于每种外层划分，利用最佳参数设置计算得到测试集分数。</p><p>这一过程的结果是由分数组成的列表——不是一个模型，也不是一种参数设置。这些分数告诉我们在网格找到的最佳参数下模型的泛化能力好坏。<strong>由于嵌套交叉验证不提供可用于新数据的模型，所以在寻找可用于未来数据的预测模型时很少用到它。</strong>但是，它对于评估给定模型在特定数据集上的效果很有用。</p><p>在 scikit-learn 中实现嵌套交叉验证很简单。我们调用 <code>cross_val_score</code>，并用 GridSearchCV 的一个实例作为模型：</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.model_selection.parametergrid#sklearn.model_selection.ParameterGrid" target="_blank" rel="noopener"><code>class sklearn.model_selection.ParameterGrid(param_grid)</code></a></p><p>Grid of parameters with a discrete number of values for each.</p><p>Can be used to iterate over parameter value combinations with the Python built-in function iter.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> ParameterGrid</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>param_grid = &#123;<span class="string">'a'</span>: [<span class="number">1</span>, <span class="number">2</span>], <span class="string">'b'</span>: [<span class="literal">True</span>, <span class="literal">False</span>]&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(ParameterGrid(param_grid)) == (</span><br><span class="line"><span class="meta">... </span>   [&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="literal">True</span>&#125;, &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="literal">False</span>&#125;,</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">'a'</span>: <span class="number">2</span>, <span class="string">'b'</span>: <span class="literal">True</span>&#125;, &#123;<span class="string">'a'</span>: <span class="number">2</span>, <span class="string">'b'</span>: <span class="literal">False</span>&#125;])</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">param_grid = &#123;<span class="string">'C'</span>: [<span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>],</span><br><span class="line">              <span class="string">'gamma'</span>: [<span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>]&#125;</span><br><span class="line"></span><br><span class="line">scores = cross_val_score(GridSearchCV(SVC(), param_grid, cv=<span class="number">5</span>),</span><br><span class="line">                         iris.data, iris.target, cv=<span class="number">5</span>)</span><br><span class="line">print(<span class="string">'Cross-validation scores:'</span>, scores)</span><br><span class="line">print(<span class="string">'Mean cross-validation score:'</span>, scores.mean())</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cross-validation scores: [0.96666667 1.         0.96666667 0.96666667 1.        ]</span><br><span class="line">Mean cross-validation score: 0.9800000000000001</span><br></pre></td></tr></table></figure><p>嵌套交叉验证的结果可以总结为 “SVC 在 iris 数据集上的交叉验证平均精度为 98%”——不多也不少（与上一个结果大致相同）。</p><p>这里我们在内层循环和外层循环中都使用了分层 5 折交叉验证。由于 <code>param_grid</code> 包含 36 中参数组合，所以需要构建 36 x 5 x 5 = 900 个模型，导致嵌套交叉验证过程的代价很高。这里我们在内层循环和外层循环中使用相同的交叉验证分离器，但这不是必需的，你可以在内层循环和外层循环中使用交叉验证策略的任意组合。理解上面单行代码的内容可能有点困难，将其展开为 for 循环可能会有所帮助，正如我么在下面这个简化的实现中所做的那样：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> StratifiedKFold, ParameterGrid</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nested_cv</span><span class="params">(X, y, inner_cv, outer_cv, Classifier, parameter_grid)</span>:</span></span><br><span class="line">    outer_scores = []</span><br><span class="line">    <span class="comment"># 对于外层交叉验证的每次数据划分，split方法返回索引值</span></span><br><span class="line">    <span class="keyword">for</span> training_samples, test_samples <span class="keyword">in</span> outer_cv.split(X, y):</span><br><span class="line">        <span class="comment"># 利用内层交叉验证找到最佳参数</span></span><br><span class="line">        best_params = &#123;&#125;</span><br><span class="line">        best_score = -np.inf</span><br><span class="line">        <span class="comment"># 遍历参数</span></span><br><span class="line">        <span class="keyword">for</span> parameters <span class="keyword">in</span> parameter_grid:</span><br><span class="line">            <span class="comment"># 在内层划分中累加分数</span></span><br><span class="line">            cv_scores = []</span><br><span class="line">            <span class="comment"># 遍历内层交叉验证</span></span><br><span class="line">            <span class="keyword">for</span> inner_train, inner_test <span class="keyword">in</span> inner_cv.split(X[training_samples], y[training_samples]):</span><br><span class="line">                <span class="comment"># 对于给定的参数和训练数据来构建分类器</span></span><br><span class="line">                clf = Classifier(**parameters)</span><br><span class="line">                clf.fit(X[inner_train], y[inner_train])</span><br><span class="line">                <span class="comment"># 在内层测试集上进行评估</span></span><br><span class="line">                score = clf.score(X[inner_test], y[inner_test])</span><br><span class="line">                cv_scores.append(score)</span><br><span class="line">            <span class="comment"># 计算内层交叉验证的平均分数</span></span><br><span class="line">            mean_score = np.mean(cv_scores)</span><br><span class="line">            <span class="keyword">if</span> mean_score &gt; best_score:</span><br><span class="line">                best_score = mean_score</span><br><span class="line">                best_params = parameters</span><br><span class="line">        <span class="comment"># 利用外层训练集和最佳参数来构建模型</span></span><br><span class="line">        clf = Classifier(**best_params)</span><br><span class="line">        clf.fit(X[training_samples], y[training_samples])</span><br><span class="line">        <span class="comment"># 评估模型</span></span><br><span class="line">        outer_scores.append(clf.score(X[test_samples], y[test_samples]))</span><br><span class="line">    <span class="keyword">return</span> np.array(outer_scores)</span><br><span class="line"></span><br><span class="line">scores = nested_cv(iris.data, iris.target, StratifiedKFold(<span class="number">5</span>),</span><br><span class="line">    StratifiedKFold(<span class="number">5</span>), SVC, ParameterGrid(param_grid))</span><br><span class="line">print(<span class="string">'Cross-validation scores:'</span>, scores)</span><br><span class="line">print(<span class="string">'Mean cross-validation score:'</span>, scores.mean())</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cross-validation scores: [0.96666667 1.         0.96666667 0.96666667 1.        ]</span><br><span class="line">Mean cross-validation score: 0.9800000000000001</span><br></pre></td></tr></table></figure><h3 id="交叉验证与网格搜索并行">交叉验证与网格搜索并行</h3><p>虽然在许多参数上运行网格搜索和在大型数据集上运行网格搜索的计算量可能很大，但令人尴尬的是，这些计算都是<strong>并行的</strong>（parallel）。这也就是说，在一种交叉验证划分下使用特定参数设置来构建一个模型，与利用其他参数的模型是完全独立的。这使得网格搜索与交叉验证成为多个 CPU 内核或集群上并行化的理想选择。你可以将 <code>n_jobs</code> 参数设置为你想使用的 CPU 内核数量，从而在 GridSearchCV 和 <code>cross_val_score</code> 中使用多个内核。你可以设置 <code>n_jobs=-1</code> 来使用所有可用的内核。</p><p>你应该知道，<strong>scikit-learn 不允许并行操作的嵌套</strong>。因此，如果你在模型（比如随机森林）中使用了 <code>n_jobs</code> 选项，那么就不能在 GridSearchCV 使用它来搜索这个模型。如果你的数据集和模型都非常大，那么使用多个内核可能会占用大量内存，你应该在并行构建大型模型时监视内存的使用情况。</p><p>还可以在集群内的多台机器上并行运行网格搜索和交叉验证。对于 Spark 用户，可以使用 spark-sklearn 包，它允许在已经建立好的 Spark 集群上运行网格搜索。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Machine Learning with Python </tag>
            
            <tag> grid search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scramble String</title>
      <link href="/programming/leetcode/scramble-string/"/>
      <url>/programming/leetcode/scramble-string/</url>
      
        <content type="html"><![CDATA[<p>Given a string <code>s1</code>, we may represent it as a binary tree by partitioning it to <strong>two non-empty substrings</strong> recursively.</p><p>Below is one possible representation of <code>s1 = great</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    great</span><br><span class="line">   /     \</span><br><span class="line">  gr     eat</span><br><span class="line"> / \     /  \</span><br><span class="line">g   r   e   at</span><br><span class="line">           /  \</span><br><span class="line">          a    t</span><br></pre></td></tr></table></figure><p>To scramble the string, we may choose any non-leaf node and swap its two children.</p><p>For example, if we choose the node <code>&quot;gr&quot;</code> and swap its two children, it produces a scrambled string <code>&quot;rgeat&quot;</code>.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    rgeat</span><br><span class="line">   /     \</span><br><span class="line">  rg     eat</span><br><span class="line"> / \     /  \</span><br><span class="line">r   g   e   at</span><br><span class="line">           /  \</span><br><span class="line">          a    t</span><br></pre></td></tr></table></figure><p>We say that <code>&quot;rgeat&quot;</code> is a scrambled string of <code>&quot;great&quot;</code>.</p><a id="more"></a><p>Similarly, if we continue to swap the children of nodes <code>&quot;eat&quot;</code> and <code>&quot;at&quot;</code>, it produces a scrambled string <code>&quot;rgtae&quot;</code>.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    rgtae</span><br><span class="line">   /     \</span><br><span class="line">  rg     tae</span><br><span class="line"> / \     /  \</span><br><span class="line">r   g   ta   e</span><br><span class="line">       /  \</span><br><span class="line">      t    a</span><br></pre></td></tr></table></figure><p>We say that <code>&quot;rgtae&quot;</code> is a scrambled string of <code>&quot;great&quot;</code>.</p><p>Given two strings <code>s1</code> and <code>s2</code> of the same length, determine if <code>s2</code> is a scrambled string of <code>s1</code>.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s1 = &quot;great&quot;, s2 = &quot;rgeat&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s1 = &quot;abcde&quot;, s2 = &quot;caebd&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> String can be partitioned at ANY position. But can only be partitioned (maybe) once.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e.g. s1 = &quot;abcde&quot;, s2 = &quot;bcade&quot;, s3 = &quot;bcead&quot;</span><br><span class="line"></span><br><span class="line">s2 is a scramble of s1</span><br><span class="line"></span><br><span class="line">        abcde</span><br><span class="line">       /     \</span><br><span class="line">      abc     de</span><br><span class="line">     /  \    /  \</span><br><span class="line">    a   bc  d    e</span><br><span class="line">       /  \</span><br><span class="line">      b    c</span><br><span class="line"></span><br><span class="line">    swap &quot;a&quot; and &quot;bc&quot;</span><br><span class="line"></span><br><span class="line">          bcade</span><br><span class="line">         /     \</span><br><span class="line">        bca     de</span><br><span class="line">       /  \    /  \</span><br><span class="line">      bc   a  d    e</span><br><span class="line">     /  \</span><br><span class="line">    b    c</span><br><span class="line"></span><br><span class="line">s3 is a scramble of s2</span><br><span class="line"></span><br><span class="line">        bcade</span><br><span class="line">       /     \</span><br><span class="line">      bc     ade</span><br><span class="line">     / \     / \</span><br><span class="line">    b   c   ad  e</span><br><span class="line">           / \</span><br><span class="line">          a   d</span><br><span class="line"></span><br><span class="line">    swap &quot;ad&quot; and &quot;e&quot;</span><br><span class="line"></span><br><span class="line">        bcead</span><br><span class="line">       /     \</span><br><span class="line">      bc     ead</span><br><span class="line">     / \     / \</span><br><span class="line">    b   c   e  ad</span><br><span class="line">               / \</span><br><span class="line">              a   d</span><br><span class="line"></span><br><span class="line">But s3 is NOT a scramble of s1</span><br><span class="line"></span><br><span class="line">s1 ---&gt; s2</span><br><span class="line">s2 ---&gt; s3</span><br><span class="line">s1 -x-&gt; s3</span><br></pre></td></tr></table></figure><h1 id="recursive-approach">Recursive Approach</h1><p>Let <code>m</code> denotes the lenght of <code>s1</code>, and <code>n</code> denotes the length of <code>s2</code>.</p><p>Base cases:</p><ul><li>If <code>m != n</code>, <code>isScramble(s1, s2) = False</code>.</li><li>If <code>m == n == 1</code>, which means <code>s1</code> and <code>s2</code> are leaf nodes, <code>isScramble(s1, s2) = s1 == s2</code>.</li></ul><p>Recursion:</p><p>If there exist <code>1 &lt;= i &lt;= m-1</code>, where</p><ul><li><code>s1[0:i]</code> is a scramble of <code>s2[0:i]</code> and <code>s1[i:m]</code> is a scramble of <code>s2[i:n]</code>. Or,</li><li><code>s1[0:i]</code> is a scramble of <code>s2[n-i:n]</code> and <code>s1[i:m]</code> is a scramble of <code>s2[0:m-i]</code>.</li></ul><p>Then, <code>isScramble(s1, s2) = True</code>.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isScramble</span><span class="params">(self, s1: str, s2: str)</span> -&gt; bool:</span></span><br><span class="line">        m, n = len(s1), len(s2)</span><br><span class="line">        <span class="keyword">if</span> m != n:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> m == n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s1 == s2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> self.isScramble(s1[:i], s2[:i]) <span class="keyword">and</span> self.isScramble(s1[i:], s2[i:]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> self.isScramble(s1[:i], s2[-i:]) <span class="keyword">and</span> self.isScramble(s1[i:], s2[:n - i]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="dynamic-programming">Dynamic Programming</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Let F(i, j, k) denotes wheter the substring s1[i..i + k - 1] is a scramble of s2[j..j + k - 1].</span><br><span class="line">Since each of these substrings is a potential node in the tree, we need to check for all possible cuts.</span><br><span class="line"></span><br><span class="line">If s1 is a scrible of s2, let q be the length of a cut (hence, q &lt; k),</span><br><span class="line">then we are in the folloing situation:</span><br><span class="line"></span><br><span class="line">s1  [     x1     |       x2       ]</span><br><span class="line">    i            i + q            i + k - 1</span><br><span class="line"></span><br><span class="line">here, s2 has two possibilities:</span><br><span class="line"></span><br><span class="line">s2  [     y1     |       y2       ]</span><br><span class="line">    j            j + q            j + k - 1</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">s2  [       y1       |     y2     ]</span><br><span class="line">    j                j + k - q    j + k - 1</span><br><span class="line"></span><br><span class="line">which in terms of F means:</span><br><span class="line"></span><br><span class="line">F(i, j, k) = for some 1 &lt;= q &lt; k we have:</span><br><span class="line">    (F(i, j, q) AND F(i + q, j + q, k - q)) OR</span><br><span class="line">    (F(i, j + k - q, q) AND F(i + q, j, k - q))</span><br><span class="line"></span><br><span class="line">Base case is k = 1, where we simply need to check for s1[i] == s2[j]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isScramble</span><span class="params">(self, s1: str, s2: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(s1) != len(s2):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        n = len(s1)</span><br><span class="line">        dp = [[[<span class="literal">False</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n - k + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(n - k + <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">                        dp[i][j][k] = s1[i] == s2[j]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j][k] = any(</span><br><span class="line">                            (dp[i][j][q] <span class="keyword">and</span> dp[i + q][j + q][k - q]) <span class="keyword">or</span></span><br><span class="line">                            (dp[i][j + k - q][q] <span class="keyword">and</span> dp[i + q][j][k - q])</span><br><span class="line">                            <span class="keyword">for</span> q <span class="keyword">in</span> range(<span class="number">1</span>, k)</span><br><span class="line">                        )</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>][n]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> recursion </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maximal Rectangle</title>
      <link href="/programming/leetcode/maximal-rectangle/"/>
      <url>/programming/leetcode/maximal-rectangle/</url>
      
        <content type="html"><![CDATA[<p>Given an 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [&apos;1&apos;, &apos;0&apos;, &apos;1&apos;, &apos;0&apos;, &apos;0&apos;],</span><br><span class="line">  [&apos;1&apos;, &apos;0&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;],</span><br><span class="line">  [&apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;],</span><br><span class="line">  [&apos;1&apos;, &apos;0&apos;, &apos;0&apos;, &apos;1&apos;, &apos;0&apos;]</span><br><span class="line">]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure><h1 id="dynamic-programming">Dynamic Programming</h1><p>In this approach, we use three DP arrays, <code>left</code>, <code>right</code> and <code>height</code>. The DP solution proceeds row by row, starting from the first row. Let the maximal rectangle area at row <code>i</code> and column <code>j</code> be computed by <code>(right[i][j] - left[i][j]) * height[i][j]</code>.</p><p>Let <code>m</code> denotes the height of matrix and <code>n</code> denotes the width of matrix. Define <code>lm</code> and <code>rm</code> as follows.</p><ul><li><code>lm</code>: the leftmost index of consecutive 1's ending at current cell. <code>lm</code> can be updated during a left to right scan.</li><li><code>rm</code>: 1 + the rightmost index of consecutive 1's starting from current cell. <code>rm</code> can be updated during a right to left scan.</li></ul><p>The meaning of <code>left</code>, <code>right</code> and <code>height</code>:</p><ul><li><code>height[i][j]</code>: the height of consecutive 1's above <code>matrix[i][j]</code>.</li><li><code>left[i][j]</code>: the leftmost of consecutive 1's with height <code>height[i][j]</code>.</li><li><code>right[i][j]</code>: the rightmost of consecutive 1's with height <code>height[i][j]</code>.</li></ul><p>First rows are given by:</p><ul><li><code>left[0][j] = max(0, lm) if matrix[0][j] == '1' else 0</code></li><li><code>right[0][j] = min(n, rm) if matrix[0][j] == '1' else n</code></li><li><code>height[0][j] = 1 if matrix[0][j] == '1' else 0</code></li></ul><p>The transition equations are:</p><ul><li><code>left[i][j] = max(left[i - 1][j], lm) if matrix[i][j] == '1' else 0</code></li><li><code>right[i][j] = min(right[i - 1][j], rm) if matrix[i][j] == '1' else n</code></li><li><code>height[i][j] = height[i - 1][j] + 1 if matrix[i][j] == '1' else 0</code></li></ul><a id="more"></a><p>e.g.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">matrix:</span><br><span class="line">0  1  0</span><br><span class="line">1  1  1</span><br><span class="line"></span><br><span class="line">height:   height array is easier to understand</span><br><span class="line">0  1  0</span><br><span class="line">1  2  1</span><br><span class="line"></span><br><span class="line">left:</span><br><span class="line">0  1  0</span><br><span class="line">0  1  0</span><br><span class="line"></span><br><span class="line">left[1][1] = 1, because rectangle with height 2 can&apos;t expand left anymore</span><br><span class="line">left[1][2] = 0, because rectangle with height 1 can expand left to 0</span><br><span class="line"></span><br><span class="line">right:</span><br><span class="line">3  2  3</span><br><span class="line">3  2  3</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalRectangle</span><span class="params">(self, matrix: list)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            m, n = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left, right, height = [<span class="number">0</span>] * n, [n] * n, [<span class="number">0</span>] * n  <span class="comment"># using vector replace the matrix</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            rm = n</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> reversed(range(n)):  <span class="comment"># right to left scan</span></span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="string">'1'</span>:</span><br><span class="line">                    right[j] = min(right[j], rm)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right[j] = n</span><br><span class="line">                    rm = j</span><br><span class="line">            lm = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):  <span class="comment"># left to right scan</span></span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="string">'1'</span>:</span><br><span class="line">                    left[j] = max(left[j], lm)</span><br><span class="line">                    height[j] = height[j] + <span class="number">1</span></span><br><span class="line">                    res = max(res, (right[j] - left[j]) * height[j])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left[j] = <span class="number">0</span></span><br><span class="line">                    height[j] = <span class="number">0</span></span><br><span class="line">                    lm = j + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Climbing Stairs</title>
      <link href="/programming/leetcode/climbing-stairs/"/>
      <url>/programming/leetcode/climbing-stairs/</url>
      
        <content type="html"><![CDATA[<p>You are climbnig a stair case. It takes <em>n</em> steps to reach the top.</p><p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p><p>Note: Given <em>n</em> will be a positive integer.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><h1 id="dynamic-programming">Dynamic Programming</h1><p>Let <code>dp[i]</code> denotes the number of ways to reach on <code>i</code>-th step.</p><p>Base cases:</p><ul><li><code>dp[1] = 1</code>.</li><li><code>dp[2] = 2</code>.</li></ul><p>One can reach <code>i</code>-th step in one of the two ways:</p><ol type="1"><li>Taking a single step from <code>(i - 1)</code>-th step.</li><li>Taking a step of 2 from <code>(i - 2)</code>-th step.</li></ol><p>So, the total number of ways to reach <code>i</code>-th is equal to sum of ways of reaching <code>(i - 1)</code>-th step and ways of reach <code>(i - 2)</code>-th step. i.e. <code>dp[n] = dp[n - 1] + dp[n - 2]</code>.</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dp = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">            dp.append(dp[<span class="number">-1</span>] + dp[<span class="number">-2</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="fibonacci-number">Fibonacci Number</h1><p>In the above approach we have used <code>dp</code> array where <code>dp[i] = dp[i - 1] + dp[i - 2]</code>. It can be easily analysed that <code>dp[i]</code> is nothing but <code>i</code>-th fibonacci number.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        first, second = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">            third = first + second</span><br><span class="line">            first, second = second, third</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> second</span><br></pre></td></tr></table></figure><h1 id="binets-method">Binets Method</h1><p>This is an interesting solution which uses matrix multiplication to obtain the <code>n</code>-th Fibonacci Number. The matrix takes the following form: <span class="math inline">\(\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}\)</span>.</p><p>Let's say <span class="math inline">\(Q^n=\begin{bmatrix}F_n&amp;F_{n-1}\\F_{n-1}&amp;F_{n-2}\end{bmatrix}\)</span>, the <code>n</code>-th Fibonacci Number is given by <span class="math inline">\(Q^n[0][0]\)</span>.</p><p>In particular, we denote <span class="math inline">\(Q^1=\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}\)</span>, where <span class="math inline">\(F_1=Q^1[0][0]=1\)</span>.</p><p>We can prove this method using Mathematical Induction.</p><p><span class="math inline">\(Q^2=Q^1\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}=\begin{bmatrix}2&amp;1\\1&amp;1\end{bmatrix} \quad F_2=Q^2[0][0]=2\)</span> holds.</p><p><span class="math inline">\(Q^3=Q^2\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}=\begin{bmatrix}3&amp;2\\2&amp;1\end{bmatrix} \quad F_3=Q^3[0][0]=3\)</span> holds.</p><p>Thus, the base case holds.</p><p>Assume that this method holds for finding the <code>n</code>-th Fibonacci Number, i.e. <span class="math inline">\(F_n = Q^n[0][0]\)</span>, where, <span class="math inline">\(Q^n=\begin{bmatrix}F_n&amp;F_{n-1}\\F_{n-1}&amp;F_{n-2}\end{bmatrix}\)</span>.</p><p>Now, we need to prove that with the above two conditions holding true, the method is valid for finding the <code>(n + 1)</code>-th Fibonacci Number, i.e. <span class="math inline">\(F_{n+1} = Q^{n+1}[0][0]\)</span>.</p><p>Proof: <span class="math inline">\(Q^{n+1}=\begin{bmatrix}F_n&amp;F_{n-1}\\F_{n-1}&amp;F_{n-2}\end{bmatrix}\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}=\begin{bmatrix}F_n+F_{n-1}&amp;F_n\\F_{n-1}+F_{n-2}&amp;F_{n-1}\end{bmatrix} = \begin{bmatrix}F_{n+1}&amp;F_n\\F_n&amp;F_{n-1}\end{bmatrix}\)</span>.</p><p>Thus, <span class="math inline">\(F_{n+1} = Q^{n+1}[0][0]\)</span>. This completes the proof of this method.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(log n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        q = [[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>]]</span><br><span class="line">        res = self.pow(q, n)</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pow</span><span class="params">(self, a, n)</span>:</span></span><br><span class="line">        ret = [[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span> == <span class="number">1</span>:  <span class="comment"># when n is odd</span></span><br><span class="line">                ret = self.multiply(ret, a)</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>         <span class="comment"># n = n // 2</span></span><br><span class="line">            a = self.multiply(a, a)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(a, b)</span>:</span></span><br><span class="line">        c = [[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">                c[i][j] = a[i][<span class="number">0</span>] * b[<span class="number">0</span>][j] + a[i][<span class="number">1</span>] * b[<span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure><p>Proof of time complexity:</p><p>Suppose, <span class="math inline">\(n\)</span> is the power of 2. To calculate <span class="math inline">\(Q^n\)</span> matrix, we should calculate <span class="math inline">\(Q^{n/2}\)</span> matrix and multiply it by itself. To calculate <span class="math inline">\(Q^{n/2}\)</span> we should have to do the same with <span class="math inline">\(Q^{n/4}\)</span> and so on. Meaning that: <span class="math inline">\(Q^{n}=Q^{n/2}\cdot Q^{n/2}=\dots=\prod_1^n Q^1\)</span>.</p><p>e.g. <span class="math inline">\(Q^8=(Q^4)^2=((Q^2)^2)^2=(((Q^1)^2)^2)^2\)</span>.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">         Q^n</span><br><span class="line">      /       \</span><br><span class="line">  Q^&#123;n/2&#125;   Q^&#123;n/2&#125;</span><br><span class="line">   ...        ...</span><br><span class="line">  /   \      /   \</span><br><span class="line">Q^1   Q^1  Q^1   Q^1</span><br></pre></td></tr></table></figure><p>Obviously, the tree height is <span class="math inline">\(\log_2 n\)</span>.</p><p>In case, the number <span class="math inline">\(n\)</span> is not a power of 2, we can <strong>break it in terms of powers of 2</strong> using its binary representation: <span class="math inline">\(n=\sum_{p\in P}2^p\)</span>, where <span class="math inline">\(P\subset \N\)</span>.</p><p>Thus, we can obtain the final result using: <span class="math inline">\(Q^n=\prod_{p\in P}Q^{2^p}\)</span>.</p><p>e.g. <span class="math inline">\(Q^7=Q^4\cdot Q^2 \cdot Q^1\)</span>.</p><p>This is the method we've used in implementation. Again, the complexity remains <span class="math inline">\(O(\log_2 n)\)</span> as we have limited the number of multiplications to <span class="math inline">\(O(\log_2 n)\)</span>.</p><h1 id="fibonacci-formula">Fibonacci Formula</h1><p>We can find <code>n</code>-th fibonacci number using this formula: <span class="math inline">\(F_n=1/\sqrt 5\Big[\Big(\frac{1+\sqrt 5}{2}\Big)^n-\Big(\frac{1-\sqrt 5}{2}\Big)^n\Big]\)</span>.</p><p>For the given problem, the Fibonacci sequence is defined by <span class="math inline">\(F_0=1, F_1=1, F_2=2, F_{n+2}=F_{n+1}+F_n\)</span>.</p><p>A standard method of trying to sovle such recursion formulas is assume <span class="math inline">\(F_n\)</span> of the form <span class="math inline">\(F_n=a^n\)</span>.</p><p>Then, of cource, <span class="math inline">\(F_{n+1}=a^{n+1}\)</span> and <span class="math inline">\(F_{n+2}=a^{n+2}\)</span> so the equation becomes <span class="math inline">\(a^{n+2}=a^{n+1}+a^n\)</span>. If we divide the entire equation by <span class="math inline">\(a^n\)</span> we arrive at <span class="math inline">\(a^2=a+1\)</span>.</p><p>Solving this by the quadratic formula, we get: <span class="math inline">\(a=1/\sqrt 5\Big(\frac{1\pm\sqrt 5}{2}\Big)\)</span>.</p><p>The general solution, thus takes the form: <span class="math inline">\(F_n=A\Big(\frac{1+\sqrt 5}{2}\Big)^n+B\Big(\frac{1-\sqrt 5}{2}\Big)^n\)</span>.</p><p>For <span class="math inline">\(n=0\)</span>, we get <span class="math inline">\(A+B=1\)</span>. For <span class="math inline">\(n=1\)</span>, we get <span class="math inline">\(A\Big(\frac{1+\sqrt 5}{2}\Big)+B\Big(\frac{1-\sqrt 5}{2}\Big)=1\)</span>. Solving the above equations, we get <span class="math inline">\(A=\Big(\frac{1+\sqrt 5}{2\sqrt 5}\Big), B=\Big(\frac{1-\sqrt 5}{2\sqrt 5}\Big)\)</span>.</p><p>Putting these values of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> in the above general solution equation, we get:</p><p><span class="math inline">\(F_n=1/\sqrt 5\Big[\Big(\frac{1+\sqrt 5}{2}\Big)^n-\Big(\frac{1-\sqrt 5}{2}\Big)^n\Big]\)</span></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(log n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">import</span> math</span><br><span class="line">        sqrt5 = math.sqrt(<span class="number">5</span>)</span><br><span class="line">        fibn = math.pow((<span class="number">1</span> + sqrt5) / <span class="number">2</span>, n + <span class="number">1</span>) - math.pow((<span class="number">1</span> - sqrt5) / <span class="number">2</span>, n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> int(fibn / sqrt5)</span><br></pre></td></tr></table></figure><p><em>zhoubowei</em> commented on leetcode that Fibonacci Formula would be invalid while the answer is larger than 10^15.</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
            <tag> fibonacci </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Minimum Path Sum</title>
      <link href="/programming/leetcode/minimum-path-sum/"/>
      <url>/programming/leetcode/minimum-path-sum/</url>
      
        <content type="html"><![CDATA[<p>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which <em>minimizes</em> the sum of all numbers along its path.</p><p><strong>Note:</strong> You can only move either down or right at any point in time.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">Output: 7</span><br></pre></td></tr></table></figure><h1 id="dynamic-programming">Dynamic Programming</h1><p><code>dp[i][j]</code> denotes the minimum sum of all numbers along the path that start from <code>(1, 1)</code> to <code>(i, j)</code>. Indices start from 1.</p><ul><li><code>dp[i][1] = dp[i - 1][1] + grid[i][1]</code>. Any cell in the first column can only be reached from the cell above it.</li><li><code>dp[1][j] = dp[1][j - 1] + grid[1][j]</code>. Any cell in the first row can only be reached from the cell left to it.</li><li><code>dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]</code>. Cell <code>(i, j)</code> can be reached from the cell above it or the left to it.</li></ul><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid: list)</span> -&gt; int:</span></span><br><span class="line">        m, n = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            grid[i][<span class="number">0</span>] = grid[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            grid[<span class="number">0</span>][j] = grid[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                grid[i][j] = min(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>]) + grid[i][j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> grid[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="dijkstra">Dijkstra</h1><p>For more details, see <a href="/notes/introduction-to-algorithms/single-source-shortest-paths/" title="Single Source Shortest Paths">Single Source Shortest Paths</a>.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid: list)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">        m, n = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">        heap = [(grid[<span class="number">0</span>][<span class="number">0</span>], (<span class="number">0</span>, <span class="number">0</span>))]</span><br><span class="line">        visited = set()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> heap:</span><br><span class="line">            curr, (i, j) = heapq.heappop(heap)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i, j) == (m - <span class="number">1</span>, n - <span class="number">1</span>):  <span class="comment"># got the result</span></span><br><span class="line">                <span class="keyword">return</span> curr</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i, j) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                visited.add((i, j))</span><br><span class="line">                <span class="keyword">for</span> x, y <span class="keyword">in</span> &#123;(i + <span class="number">1</span>, j), (i, j + <span class="number">1</span>)&#125;:  <span class="comment"># relax neighbor</span></span><br><span class="line">                    <span class="keyword">if</span> x &lt; m <span class="keyword">and</span> y &lt; n <span class="keyword">and</span> (x, y) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        heapq.heappush(heap, (curr + grid[x][y], (x, y)))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
            <tag> shortest path </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unique Paths</title>
      <link href="/programming/leetcode/unique-paths/"/>
      <url>/programming/leetcode/unique-paths/</url>
      
        <content type="html"><![CDATA[<h1 id="unique-paths">Unique Paths</h1><p>A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).</p><p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).</p><p><img src="/uploads/image/leetcode/robot_maze.png"></p><p>How many possible unique paths are there?</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: m = 3, n = 2</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: m = 7, n = 3</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure><p>Constraints:</p><ul><li><code>1 &lt;= m, n &lt;= 100</code>.</li><li>It's guaranteed that the answer will be less than or equal to <code>2 * 10 ^ 9</code>.</li></ul><h2 id="dynamic-programming">Dynamic Programming</h2><p><code>dp[i][j]</code> denotes the number of possible unique paths that from <code>(i, j)</code> to <code>(m, n)</code>. Indices start from 1 here.</p><ul><li><code>i = m</code>, robot can only move right. So, <code>dp[m][j] = 1</code>.</li><li><code>j = n</code>, robot can only move down. So, <code>dp[i][n] = 1</code>.</li><li><code>i &lt; m and j &lt; n</code>, robot can move down or right. When move right, robot has <code>dp[i][j + 1]</code> unique paths. When move down, robot has <code>dp[i + 1][j]</code> unique paths. So, <code>dp[i][j] = dp[i][j + 1] + dp[i + 1][j]</code>.</li></ul><p>Also, you can denote <code>dp[i][j]</code> as the number of possible unique paths that from <code>(1, 1)</code> to <code>(i, j)</code>. Then,</p><ul><li><code>dp[1][j] = dp[i][1] = 1</code>.</li><li><code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>.</li><li><code>dp[m][n]</code> is the answer of problem.</li></ul><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(mn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [[<span class="number">1</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(m - <span class="number">1</span>)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> reversed(range(n - <span class="number">1</span>)):</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j] + dp[i][j + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">1</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> reversed(range(m - <span class="number">1</span>)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> reversed(range(n - <span class="number">1</span>)):</span><br><span class="line">                dp[j] = dp[j] + dp[j + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h1 id="unique-paths-ii">Unique Paths II</h1><p>Now consider if some obstacles are aded to the grids. How many unique paths would there be?</p><p>An obstale and empty space is marked as <code>1</code> and <code>0</code> respectively in the grid.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><h2 id="dynamic-programming-1">Dynamic Programming</h2><p>Base cases:</p><ul><li>If <code>grid[i][j] == 1</code>, which means a obstacle, <code>dp[i][j] = 0</code>.</li><li><code>i = m</code>, robot can move right only if <code>grid[i][j + 1] == 0</code>. So, <code>dp[i][j] = dp[i][j + 1]</code>.</li><li><code>j = n</code>, robot can move down only if <code>grid[i + 1][j] == 0</code>. So, <code>dp[i][j] = dp[i + 1][j]</code>.</li></ul><p>Induction rules:</p><ul><li>If <code>grid[i][j] == 1</code>, <code>dp[i][j] = 0</code>.</li><li>If <code>grid[i][j] == 0</code>, <code>dp[i][j] = dp[i + 1][j] + dp[i][j + 1]</code>.</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(1). We are utilizing the `obstacleGrid` as the DP array. Hence, no extra space.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid: list)</span> -&gt; int:</span></span><br><span class="line">        m, n = len(obstacleGrid), len(obstacleGrid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># If the start or finish cell has an obstacle</span></span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] + obstacleGrid[<span class="number">-1</span>][<span class="number">-1</span>] &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Utilizing input obstacleGrid as dp</span></span><br><span class="line">        obstacleGrid[<span class="number">-1</span>][<span class="number">-1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(m - <span class="number">1</span>)):</span><br><span class="line">            obstacleGrid[i][- <span class="number">1</span>] = int(obstacleGrid[i][<span class="number">-1</span>] == <span class="number">0</span> <span class="keyword">and</span> obstacleGrid[i + <span class="number">1</span>][<span class="number">-1</span>] == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> reversed(range(n - <span class="number">1</span>)):</span><br><span class="line">            obstacleGrid[<span class="number">-1</span>][j] = int(obstacleGrid[<span class="number">-1</span>][j] == <span class="number">0</span> <span class="keyword">and</span> obstacleGrid[<span class="number">-1</span>][j + <span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(m - <span class="number">1</span>)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> reversed(range(n - <span class="number">1</span>)):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">0</span>:</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i + <span class="number">1</span>][j] + obstacleGrid[i][j + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    obstacleGrid[i][j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wildcard Matching</title>
      <link href="/programming/leetcode/wildcard-matching/"/>
      <url>/programming/leetcode/wildcard-matching/</url>
      
        <content type="html"><![CDATA[<p>Given an input string (<code>s</code>) and a pattern (<code>p</code>), implement wildcard pattern matching with support for <code>'?'</code> and <code>'*'</code>.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;?&apos; Matches any single character.</span><br><span class="line">&apos;*&apos; Matches any sequence of characters (including the empty sequence).</span><br></pre></td></tr></table></figure><p>The matching should cover the <strong>entire</strong> input string (not partial).</p><p><strong>Note:</strong></p><ul><li><code>s</code> could be empty and contains only lowercase latters <code>a-z</code>.</li><li><code>p</code> could be empty and contains only lowercase latters <code>a-z</code>, and characters like <code>?</code> or <code>*</code>.</li></ul><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;aa&quot;, p = &quot;a&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;aa&quot;, p = &quot;*&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>Example 3:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;cb&quot;, p = &quot;?a&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p>Example 4:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;adceb&quot;, p = &quot;*a*b&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>Example 5:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;acdcb&quot;, p = &quot;a*c?b&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><h1 id="dynamic-programming">Dynamic Programming</h1><p>Similar to the problem <a href="/programming/leetcode/regular-expression-matching/" title="Regular Expression Matching">Regular Expression Matching</a>.</p><p><code>dp[i][j]</code> denotes whether <code>s[i..m)</code> matches <code>p[j..n)</code>. Index of strings start from 0.</p><p>Assuming <code>m</code> is the length of string <code>s</code>, <code>n</code> is the length of pattern <code>p</code>.</p><p>Base cases:</p><ul><li>origin: <code>dp[m][n] = true</code>. <code>s[m:] == p[n:] == ''</code>, they do match.</li><li>last row: <code>dp[m][j]</code>, expect for string <code>p</code> is <code>*</code>, which can match empty sequence, otherwise all false.</li><li>last column: <code>dp[i][n] = false</code>. <code>s[i:] != ''</code> but <code>p[n:] == ''</code>, they can't match.</li></ul><p>Induction rules:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if s[i] == p[j] or p[j] == &apos;?&apos;:   # the matches are single to single.</span><br><span class="line">    dp[i][j] = dp[i + 1][j + 1]   # the result depends on whether the last characters are match.</span><br><span class="line"></span><br><span class="line">elif p[j] == &apos;*&apos;:</span><br><span class="line">    dp[i][j] = dp[i][j + 1] or dp[i + 1][j]  # if * matches empty sequence, dp[i][j] = dp[i][j + 1]</span><br><span class="line">                                             # if * matches any not empty sequence, dp[i][j] = dp[i + 1][j]</span><br><span class="line">else:</span><br><span class="line">    dp[i][j] = False              # can&apos;t match</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(mn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        m, n = len(s), len(p)</span><br><span class="line"></span><br><span class="line">        dp = [[<span class="literal">False</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">-1</span>][<span class="number">-1</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> p[j] == <span class="string">'*'</span>:</span><br><span class="line">                dp[m][j] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="comment"># first, check if s[i] and p[j] is single to single match</span></span><br><span class="line">                <span class="keyword">if</span> p[j] == s[i] <span class="keyword">or</span> p[j] == <span class="string">'?'</span>:</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j + <span class="number">1</span>]</span><br><span class="line">                <span class="comment"># then, deal with *</span></span><br><span class="line">                <span class="keyword">elif</span> p[j] == <span class="string">'*'</span>:</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j] <span class="keyword">or</span> dp[i][j + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>There also exists another variation, where <code>dp[i][j]</code> denotes whether <code>s[0..i-1]</code> matches <code>p[0..j-1]</code>. It's similar to the solution above, but be careful about the indices.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        m, n = len(s), len(p)</span><br><span class="line"></span><br><span class="line">        dp = [[<span class="literal">False</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> p[j - <span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> p[j - <span class="number">1</span>] == s[i - <span class="number">1</span>] <span class="keyword">or</span> p[j - <span class="number">1</span>] == <span class="string">'?'</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">elif</span> p[j - <span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] <span class="keyword">or</span> dp[i][j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure><h1 id="another-approach">Another approach</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If s[i] == p[j] or p[j] == &apos;?&apos;, which means this is a match,</span><br><span class="line">    goes to next element, i++, j++.</span><br><span class="line"></span><br><span class="line">If p[j] == &apos;*&apos;, this is also a match, but zero or many chars may be available,</span><br><span class="line">    save this * position and the matched s position ii.</span><br><span class="line"></span><br><span class="line">If not match, then we check if there was a * previously showd up,</span><br><span class="line">    if there is no *, return false;</span><br><span class="line">    if there is a *, we set current j to the next element of *, and set current i to the next saved ii position.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">e.g. s=&apos;abed&apos;, p=&apos;?b*d**&apos;</span><br><span class="line"></span><br><span class="line">a = ?, go on, i++, j++</span><br><span class="line">b = b, go on, i++, j++</span><br><span class="line">e = *, save * position, star = 3, save s position, ii = 3, j++</span><br><span class="line">e != d, check if there was a *, yes, j = star + 1, ii++, i = ii</span><br><span class="line">d = d, go on, i++, j++, i meet the end</span><br><span class="line">check the rest element in p, if all are *, return true, else false</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        i = j = match = <span class="number">0</span></span><br><span class="line">        star = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> j &lt; len(p) <span class="keyword">and</span> (p[j] == <span class="string">'?'</span> <span class="keyword">or</span> s[i] == p[j]):</span><br><span class="line">                i = i + <span class="number">1</span></span><br><span class="line">                j = j + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> j &lt; len(p) <span class="keyword">and</span> p[j] == <span class="string">'*'</span>:</span><br><span class="line">                match = i   <span class="comment"># the character to match * if there exist not match latter</span></span><br><span class="line">                star = j    <span class="comment"># save star position</span></span><br><span class="line">                j = j + <span class="number">1</span>   <span class="comment"># only move j</span></span><br><span class="line">            <span class="keyword">elif</span> star != <span class="number">-1</span>:       <span class="comment"># not match happend, check if there was a *</span></span><br><span class="line">                j = star + <span class="number">1</span>       <span class="comment"># move j to the next of *</span></span><br><span class="line">                match = match + <span class="number">1</span>  <span class="comment"># let s[match] to match *</span></span><br><span class="line">                i = match          <span class="comment"># move i</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> j &lt; len(p) <span class="keyword">and</span> p[j] == <span class="string">'*'</span>:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> j == len(p)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
            <tag> matching </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>交叉验证</title>
      <link href="/notes/introduction-to-ml-with-python/cross-validation/"/>
      <url>/notes/introduction-to-ml-with-python/cross-validation/</url>
      
        <content type="html"><![CDATA[<p>交叉验证（cross-validation）是一种评估泛化性能的统计学方法，它比单次划分训练集和测试集的方法更加稳定、全面。在交叉验证中，数据被多次划分，并且需要训练多个模型。最常用的交叉验证是 <strong><span class="math inline">\(k\)</span> 折交叉验证</strong>（ <span class="math inline">\(k\)</span>-fold cross-validation），其中 <span class="math inline">\(k\)</span> 是由用户指定的数字，通常取 5 或 10。在执行 5 折交叉验证时，首先将数据划分为（大致）相等的 5 部分，每一部分叫作<strong>折</strong>（fold）。接下来训练一系列模型。使用第 1 折作为测试集，其他折（2-5）作为训练集来训练第一个模型。之后构建另一个模型，这次使用第 2 折作为测试集，其他折作为训练集……对于将数据划分为训练集和测试集的这 5 次划分，每一次都要计算精度。最后我们得到了 5 个精度值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_cross_validation()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/cross-validation.png"></p><a id="more"></a><h1 id="scikit-learn-中的交叉验证">scikit-learn 中的交叉验证</h1><p>scikit-learn 是利用 <code>model_selection</code> 模块中的 <code>cross_val_score</code> 函数来实现交叉验证的。<code>cross_val_score</code> 函数的参数是我们想要评估的模型、训练数据与真实标签。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.model_selection.cross_val_score#sklearn.model_selection.cross_val_score" target="_blank" rel="noopener"><code>sklearn.model_selection.cross_val_score(estimator, X, y=None, groups=None, scoring=None, cv=’warn’, n_jobs=None, verbose=0, fit_params=None, pre_dispatch=‘2*n_jobs’, error_score=’raise-deprecating’)</code></a></p><p>Evaluate a score by cross-validation</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"></span><br><span class="line">iris = load_iris()</span><br><span class="line">logreg = LogisticRegression()</span><br><span class="line"></span><br><span class="line">scores = cross_val_score(logreg, iris.data, iris.target)  <span class="comment"># 默认执行 3 折交叉验证</span></span><br><span class="line">print(<span class="string">'Cross-validation scores:'</span>, scores)</span><br><span class="line"></span><br><span class="line">scores = cross_val_score(logreg, iris.data, iris.target, cv=<span class="number">5</span>)</span><br><span class="line">print(<span class="string">'Cross-validation scores:'</span>, scores)</span><br><span class="line"><span class="comment"># 总结交叉验证精度的一种常用方法是计算平均值</span></span><br><span class="line">print(<span class="string">'Average cross-validation score: &#123;:.2f&#125;'</span>.format(scores.mean()))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cross-validation scores: [0.96078431 0.92156863 0.95833333]</span><br><span class="line">Cross-validation scores: [1.         0.96666667 0.93333333 0.9        1.        ]</span><br><span class="line">Average cross-validation score: 0.96</span><br></pre></td></tr></table></figure><p>模型的平均精度约为 96%。观察 5 折交叉验证得到的所有 5 个精度值，还可以发现，折与折之间的精度有较大的变化，范围从 100% 精度到 90% 精度。这可能意味着模型强烈依赖于将某个折用于训练，但也可能只是因为数据集的数据量太小。</p><h1 id="交叉验证的优缺点">交叉验证的优缺点</h1><p>使用交叉验证而不是将数据单次划分为训练集和测试集，这种做法具有下列优点。首先，<code>train_test_split</code> 对数据进行随机划分。想象一下，在随机划分数据时我们很“幸运”，所有难以分类的样例都在训练集中。在这种情况下，测试集将仅包含“容易分类的”样例，并且测试集精度会高得不切实际。相反，如果我们“不够幸运”，则可能随机地将所有难以分类的样例都放在测试集中，因此得到一个不切实际的低分数。但如果使用交叉验证，每个样例都会刚好在测试集中出现一次：每个样例位于一个折中，而每个折都在测试集中出现一次。因此，模型需要对数据集中所有样本的泛化能力都很好，才能让所有的交叉验证得分（及其平均值）都很高。</p><p>对数据进行多次划分，还可以提供我们的模型对训练集选择的敏感性信息。对于 iris 数据集，我们观察到精度在 90% 到 100% 之间。这是一个不小的范围，它告诉我们将模型应用于新数据时在最坏情况和最好情况下的可能表现。</p><p>与数据的单词划分相比，交叉验证的另一个优点是我们对数据的使用更加高效。在使用 <code>train_test_split</code> 时，我们通常将 75% 的数据用于训练，25% 的数据用于评估。在使用 5 折交叉验证时，在每次迭代中我们可以使用 4/5（80%）的数据来拟合模型。在使用 10 折交叉验证时，我们可以使用 9/10（90%）的数据来拟合模型。更多的数据通常可以得到更为精确的模型。</p><p>交叉验证的主要缺点是增加了计算成本。现在我们要训练 <span class="math inline">\(k\)</span> 个模型而不是单个模型，所以交叉验证的速度要比数据的单次划分大约慢 <span class="math inline">\(k\)</span> 倍。</p><h1 id="分层-k-折交叉验证和其他策略">分层 <span class="math inline">\(k\)</span> 折交叉验证和其他策略</h1><p>将数据集划分为 <span class="math inline">\(k\)</span> 折时，从数据的前 <span class="math inline">\(k\)</span> 分之一开始划分（正如上一节所述），这可能并不总是一个好主意。例如，我们来看一下 iris 数据集。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'Iris labels:\n&#123;&#125;'</span>.format(iris.target))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Iris labels:</span><br><span class="line">[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br><span class="line"> 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</span><br><span class="line"> 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2</span><br><span class="line"> 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2</span><br><span class="line"> 2 2]</span><br></pre></td></tr></table></figure><p>如你所见，数据的前三分之一是类别 0，中间三分之一是类别 1，最后三分之一是类别 2。想象一下在这个数据集上进行 3 折交叉验证。第 1 折将只包含类别 0，所以在数据的第一次划分中，测试集将只包含类别 0，而训练集只包含类别 1 和 2。由于在 3 次划分中训练集和测试集中的类别都不相同，因此这个数据集上的 3 折交叉验证精度为 0。这没什么帮助，因为我们在 iris 上可以的得到比 0% 好得多的精度。</p><p>由于简单的 <span class="math inline">\(k\)</span> 折策略在这里失效了，所以 scikit-learn 在分类问题中不使用这种策略，而是使用<strong>分层 <span class="math inline">\(k\)</span> 折交叉验证</strong>（stratified <span class="math inline">\(k\)</span>-fold cross-validation）。在分层交叉验证中，我们划分数据，使每个折中类别之间的比例与整个数据集中的比例相同。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'Iris labels:\n&#123;&#125;'</span>.format(iris.target))</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/stratified-cross-validation.png"></p><p>举个例子，如果 90% 的样本属于类别 A 而 10% 的样本属于类别 B，那么分层交叉验证可以确保，在每个折中 90% 的样本属于类别 A 而 10% 的样本属于类别 B。</p><p>使用分层 <span class="math inline">\(k\)</span> 折交叉验证而不是 <span class="math inline">\(k\)</span> 折交叉验证来评估一个分类器，这通常是一个好主意，因为它可以对泛化性能做出更可靠的估计。在只有 10% 的样本属于类别 B 的情况下，如果使用标准 <span class="math inline">\(k\)</span> 折交叉验证，很可能某个折中只包含类别 A 的样本。利用这个折作为测试集的话，无法给出分类器整体性能的信息。</p><p>对于回归问题，scikit-learn 默认使用标准 <span class="math inline">\(k\)</span> 折交叉验证。也可以尝试让每个折表示回归目标的不同取值，但这并不是一种常用的策略，也会让大多数用户感到以外。</p><h2 id="对交叉验证的更多控制">对交叉验证的更多控制</h2><p>我们之前看到，可以利用 cv 参数来调节 <code>cross_val_score</code> 所使用的折数。但 scikit-learn 允许提供一个<strong>交叉验证分离器</strong>（cross-validation spliter）作为 cv 参数，来对数据划分过程进行更精确的控制。对于大多数使用场景而言，回归问题默认的 <span class="math inline">\(k\)</span> 折交叉验证与分类问题的分层 <span class="math inline">\(k\)</span> 折交叉验证的表现都很好，但有些情况下你可能希望使用不同的策略。比如说，我们想要在一个分类数据集上使用标准 <span class="math inline">\(k\)</span> 折交叉验证来重现别人的结果。为了实现这一点，我们首先必须从 <code>model_selection</code> 模块中导入 <code>KFold</code> 分离器类，并用我们想要使用的折数来将其实例化。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold</span><br><span class="line"></span><br><span class="line">kfold = KFold(n_splits=<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 将kfold分离器对象作为cv参数传入cross_val_score</span></span><br><span class="line">print(<span class="string">'Cross-validation scores:\n&#123;&#125;\n'</span>.format(</span><br><span class="line">    cross_val_score(logreg, iris.data, iris.target, cv=kfold)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们可以验证，在iris数据集上使用标准 3 折交叉验证确实是一个非常糟糕的注意</span></span><br><span class="line">kfold = KFold(n_splits=<span class="number">3</span>)</span><br><span class="line">print(<span class="string">'Cross-validation scores:\n&#123;&#125;\n'</span>.format(</span><br><span class="line">    cross_val_score(logreg, iris.data, iris.target, cv=kfold)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决这种问题的另一个方法是将数据打乱来代替分层</span></span><br><span class="line">kfold = KFold(n_splits=<span class="number">3</span>, shuffle=<span class="literal">True</span>, random_state=<span class="number">0</span>)</span><br><span class="line">print(<span class="string">'Cross-validation scores:\n&#123;&#125;'</span>.format(</span><br><span class="line">    cross_val_score(logreg, iris.data, iris.target, cv=kfold)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cross-validation scores:</span><br><span class="line">[1.         0.93333333 0.43333333 0.96666667 0.43333333]</span><br><span class="line"></span><br><span class="line">Cross-validation scores:</span><br><span class="line">[0. 0. 0.]</span><br><span class="line"></span><br><span class="line">Cross-validation scores:</span><br><span class="line">[0.9  0.96 0.96]</span><br></pre></td></tr></table></figure><h2 id="留一法交叉验证">留一法交叉验证</h2><p>另一种常用的交叉验证方法是<strong>留一法</strong>（leave-one-out）。你可以将留一法交叉验证看作是每折只包含单个样本的 <span class="math inline">\(k\)</span> 折交叉验证。对于每次划分，选择单个数据点作为测试集。这种方法可能非常耗时，特别是对于大型数据集来说，但在小型数据集上有时可以给出更好的估计结果。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.model_selection.leaveoneout" target="_blank" rel="noopener"><code>class sklearn.model_selection.LeaveOneOut</code></a></p><p>Leave-One-Out cross-validator</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> LeaveOneOut</span><br><span class="line"></span><br><span class="line">loo = LeaveOneOut()</span><br><span class="line">scores = cross_val_score(logreg, iris.data, iris.target, cv=loo)</span><br><span class="line">print(<span class="string">'Number of cv iterations:'</span>, len(scores))</span><br><span class="line">print(<span class="string">'Mean accuracy: &#123;:.2f&#125;'</span>.format(scores.mean()))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Number of cv iterations: 150</span><br><span class="line">Mean accuracy: 0.95</span><br></pre></td></tr></table></figure><h2 id="打乱划分交叉验证">打乱划分交叉验证</h2><p>另一种非常灵活的交叉验证策略是<strong>打乱划分交叉验证</strong>（shuffle-split cross-validation）。在打乱划分交叉验证中，每次划分为训练集取样 <code>train_size</code> 个点，为测试集取样 <code>test_size</code> 个（不相交的）点。将这一划分方法重复 <code>n_iter</code> 次。下图显示的是对包含 10 个点的数据集进行 4 次迭代划分，每次的训练集包含 5 个点，测试集包含 2 个点（你可以将 <code>train_size</code> 和 <code>test_size</code> 设为整数来表示这两个集合的绝对大小，也可以设为浮点数来表示占整个数据集的比例）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_shuffle_split()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/shuffle-split.png"></p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.model_selection.shufflesplit" target="_blank" rel="noopener"><code>class sklearn.model_selection.ShuffleSplit(n_splits=10, test_size=’default’, train_size=None, random_state=None)</code></a></p><p>Random permutation cross-validator</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> ShuffleSplit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分为 50% 的训练集和 50% 的测试集，共运行 10 次迭代</span></span><br><span class="line">shuffle_split = ShuffleSplit(test_size=<span class="number">.5</span>, train_size=<span class="number">.5</span>, n_splits=<span class="number">10</span>, random_state=<span class="number">0</span>)</span><br><span class="line">scores = cross_val_score(logreg, iris.data, iris.target, cv=shuffle_split)</span><br><span class="line">print(<span class="string">'Cross-validation scores:\n&#123;&#125;'</span>.format(scores))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cross-validation scores:</span><br><span class="line">[0.84       0.93333333 0.90666667 1.         0.90666667 0.93333333</span><br><span class="line"> 0.94666667 1.         0.90666667 0.88      ]</span><br></pre></td></tr></table></figure><p>打乱划分交叉验证可以在训练集和测试集大小之外独立控制迭代次数，这有时是很有帮助的。它还允许在每次迭代中仅使用部分数据。用这种方法对数据进行二次采样可能对大型数据集上的试验很有帮助。</p><p><code>ShuufleSplit</code> 还有一种分层的形式，，其名称为 <code>StratifiedShuffleSplit</code>，它可以为分类任务提供更可靠的结果。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.model_selection.stratifiedshufflesplit" target="_blank" rel="noopener"><code>class sklearn.model_selection.StratifiedShuffleSplit(n_splits=10, test_size=’default’, train_size=None, random_state=None)</code></a></p><p>Stratified ShuffleSplit cross-validator</p></blockquote><h2 id="分组交叉验证">分组交叉验证</h2><p>另一种非常常见的交叉验证适用于<strong>数据中的分组高度相关</strong>时。比如你想构建一个从人脸图片中识别情感的系统，并且收集了 100 个人的照片的数据集，其中每个人都进行了多次拍摄，分别展示了不同的情感。我们的目标是构建一个分类器，能够正确识别未包含在数据集中的人的情感。</p><p>你可以使用默认的分层交叉验证来度量分类器的性能。但是这样的话，同一个人的照片可能会同时出现在训练集和测试集中。对于分类器而言，检测训练集中出现过的人脸情感比全新的人脸要容易得多。因此，为了准确评估模型对新的人脸的泛化能力，我们必须确保训练集和测试集中包含不同人的图像。</p><p>为了实现这一点，我们可以使用 <code>GroupKFold</code>，它以 <code>groups</code> 数组作为参数，可以用来说明照片中对应的是哪个人。这里的 <code>groups</code> 数组表示数据中的分组，在创建训练集和测试集的时候不应该将其分开，也不应该与类别标签弄混。</p><p>数据分组的这种例子常见于医疗应用，你可能用来来自同一名病人的多个样本，但想要将其泛化到新的病人。同样，在语音识别领域，你的数据集中可能包含同一名发言人的多条记录，但你希望能够识别新的发言人的讲话。</p><p>下面这个示例用到了一个由 <code>groups</code> 数组指定分组的模拟数据集。这个数据集包含 12 个数据点，且对于每个数据点，<code>groups</code> 指定了该点所属的分组。一共分成 4 个组，前 3 个样本属于第一组，接下来的 4 个样本属于第二组，以此类推。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.model_selection.groupkfold" target="_blank" rel="noopener"><code>class sklearn.model_selection.GroupKFold(n_splits=’warn’)</code></a></p><p>K-fold iterator variant with non-overlapping groups.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GroupKFold</span><br><span class="line"></span><br><span class="line">X, y = make_blobs(n_samples=<span class="number">12</span>, random_state=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 样本不需要按分组进行排序，这么做只是为了便于说明</span></span><br><span class="line">groups = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line">scores = cross_val_score(logreg, X, y, groups, cv=GroupKFold(n_splits=<span class="number">3</span>))</span><br><span class="line">print(<span class="string">'Cross-validation scores:\n&#123;&#125;'</span>.format(scores))</span><br></pre></td></tr></table></figure><p>基于这些标签计算得到的划分如图所示。对于每次划分，每个分组都是整体出现在训练集或测试集中。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_group_kfold()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/group-kfold.png"></p><p>scikit-learn 中还有很多交叉验证的划分策略，适用于更多的使用场景。标准的 <code>KFold</code>、<code>StratifiedKFold</code> 和 <code>GroupKFold</code> 是目前最常用的集中。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Machine Learning with Python </tag>
            
            <tag> cross-validation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maximum Subarray</title>
      <link href="/programming/leetcode/maximum-subarray/"/>
      <url>/programming/leetcode/maximum-subarray/</url>
      
        <content type="html"><![CDATA[<p>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure><h1 id="dynamic-programming">Dynamic Programming</h1><p>Let <code>dp[j]</code> denotes the largest sum of the subarray ending at j-th index.</p><ul><li>When <code>j = 0</code>, <code>dp[j] = A[j]</code>.</li><li>When <code>j &gt; 0</code>, since subarray must ending at j-th index <code>dp[j]</code>, there are two cases: <code>A[i..j]</code> (more than one element) or <code>A[j]</code> (just the last one element). Thus, <code>dp[j] = max(dp[j - 1] + A[j], A[j])</code>.</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubarray</span><span class="params">(self, nums: list)</span> -&gt; int:</span></span><br><span class="line">        curr = res = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            curr = max(curr, <span class="number">0</span>) + nums[i]</span><br><span class="line">            res = max(res, curr)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>Save the start and end index of the maximum subarray.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubarray</span><span class="params">(self, nums: list)</span> -&gt; tuple:</span></span><br><span class="line">        curr = res = nums[<span class="number">0</span>]</span><br><span class="line">        start = end = <span class="number">0</span></span><br><span class="line">        temp = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> curr &lt; <span class="number">0</span>:</span><br><span class="line">                curr, temp = <span class="number">0</span>, i</span><br><span class="line">            curr = curr + nums[i]</span><br><span class="line">            <span class="keyword">if</span> res &lt; curr:</span><br><span class="line">                res = curr</span><br><span class="line">                start, end = temp, i</span><br><span class="line">        <span class="keyword">return</span> start, end, res</span><br></pre></td></tr></table></figure><h1 id="divide-and-conquer">Divide and Conquer</h1><a href="/notes/introduction-to-algorithms/maximum-subarray-problems/" title="最大子数组问题">最大子数组问题</a>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> divide and conquer </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Edit Distance</title>
      <link href="/programming/leetcode/edit-distance/"/>
      <url>/programming/leetcode/edit-distance/</url>
      
        <content type="html"><![CDATA[<p>Given two words <em>word1</em> and <em>word2</em>, find the minimum number of operations required to convert <em>word1</em> to <em>word2</em>.</p><p>You have the following 3 operations permitted on a word:</p><ol type="1"><li>Insert a character</li><li>Delete a character</li><li>Replace a character</li></ol><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><h1 id="dynamic-programming">Dynamic Programming</h1><p><code>dp[i][j]</code> denotes minimum number of operations required to convert <code>word1[0..i)</code> to <code>word2[0..j)</code>。</p><p>Base cases:</p><p><code>m</code> is the length of <code>word1</code>, <code>n</code> is the length of <code>word2</code>.</p><ul><li><code>dp[i][0] = i</code>, convert <code>word1[0..i)</code> to <code>''</code>.</li><li><code>dp[0][j] = j</code>, convert <code>''</code> to <code>word2[0..j]</code>.</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp   0   1   2   ...   n</span><br><span class="line"> 0   0   1   2   ...   n</span><br><span class="line"> 1   1</span><br><span class="line"> 2   2</span><br><span class="line">... ...</span><br><span class="line"> m   m</span><br></pre></td></tr></table></figure><p>Induction rules:</p><ul><li>If <code>word1[i - 1] == word2[j - 1]</code>, then <code>dp[i][j] = dp[i - 1][j - 1]</code>. Since we need do nothing after we converted <code>word1[0..i - 1)</code> to <code>word2[0..j - 1)</code>.</li><li>If <code>word1[i - 1] != word2[j - 1]</code>, we have three cases to complete this convertion:<ul><li>Convert <code>word1[0..i - 1)</code> to <code>word2[0..j - 1)</code>, then replace <code>word1[i - 1]</code> by <code>word2[j - 1]</code>. So, <code>dp[i][j] = dp[i - 1][j - 1] + 1</code>.</li><li>Convert <code>word1[0..i)</code> to <code>word2[0..j - 1)</code>, then insert <code>word2[j - 1]</code>. So, <code>dp[i][j] = dp[i][j - 1] + 1</code>.</li><li>Delete <code>word1[i - 1]</code>. Then convert <code>word1[0..i - 1)</code> to <code>word2[0..j)</code>. So, <code>dp[i][j] = dp[i - 1][j] + 1</code>.</li></ul></li></ul><a id="more"></a><h2 id="bottom-up-variation">Bottom-Up Variation</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(mn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">        m, n = len(word1), len(word2)</span><br><span class="line">        dp = [[<span class="number">-1</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n + <span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = j</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">        m, n = len(word1), len(word2)</span><br><span class="line">        pre = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            curr = [i] * (n + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                curr[j] = min(pre[j] + <span class="number">1</span>,</span><br><span class="line">                              curr[j - <span class="number">1</span>] + <span class="number">1</span>,</span><br><span class="line">                              pre[j - <span class="number">1</span>] + (word1[i - <span class="number">1</span>] != word2[j - <span class="number">1</span>]))</span><br><span class="line">            pre = curr</span><br><span class="line">        <span class="keyword">return</span> pre[n]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">        m, n = len(word1), len(word2)</span><br><span class="line">        curr = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            pre = curr[<span class="number">0</span>]</span><br><span class="line">            curr[<span class="number">0</span>] = i</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                temp = curr[j]              <span class="comment"># curr[j] is not updated yet, curr[j] == dp[i - 1][j - 1]</span></span><br><span class="line">                curr[j] = min(curr[j] + <span class="number">1</span>,  <span class="comment"># update curr[j]</span></span><br><span class="line">                              curr[j - <span class="number">1</span>] + <span class="number">1</span>,</span><br><span class="line">                              pre + (word1[i - <span class="number">1</span>] != word2[j - <span class="number">1</span>]))</span><br><span class="line">                pre = temp                  <span class="comment"># save dp[i - 1][j - 1] to pre</span></span><br><span class="line">        <span class="keyword">return</span> curr[n]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Binary Tree Traversal</title>
      <link href="/programming/leetcode/binary-tree-traversal/"/>
      <url>/programming/leetcode/binary-tree-traversal/</url>
      
        <content type="html"><![CDATA[<p>Given a binary tree, return the <em>preorder/inorder/postorder</em> traversal of its nodes' values.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure><h1 id="recursive-approach">Recursive Approach</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root, res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                res.append(root.val)</span><br><span class="line">                helper(root.left, res)</span><br><span class="line">                helper(root.right, res)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        helper(root, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root, res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                helper(root.left, res)</span><br><span class="line">                res.append(root.val)</span><br><span class="line">                helper(root.right, res)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        helper(root, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root, res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                helper(root.left, res)</span><br><span class="line">                helper(root.right, res)</span><br><span class="line">                res.append(root.val)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        helper(root, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="iterating-method-using-stack">Iterating method using stack</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        res, stack = [], [root]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            curr = stack.pop()          <span class="comment"># first, visit</span></span><br><span class="line">            res.append(curr.val)</span><br><span class="line">            <span class="keyword">if</span> curr.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment"># then, push right child</span></span><br><span class="line">                stack.append(curr.right)</span><br><span class="line">            <span class="keyword">if</span> curr.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:   <span class="comment"># last, push left child</span></span><br><span class="line">                stack.append(curr.left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        res, stack = [], []</span><br><span class="line">        curr = root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curr <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> curr <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                stack.append(curr)</span><br><span class="line">                curr = curr.left</span><br><span class="line">            curr = stack.pop()    <span class="comment"># visit only when left child is null</span></span><br><span class="line">            res.append(curr.val)</span><br><span class="line">            curr = curr.right     <span class="comment"># move to right child, then same procedure is applied</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        res, stack = [], []</span><br><span class="line">        curr, last_visit = root, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curr <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> curr <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                stack.append(curr)</span><br><span class="line">                curr = curr.left</span><br><span class="line">            peek = stack[<span class="number">-1</span>]    <span class="comment"># not pop, because right child may not visited yet</span></span><br><span class="line">            <span class="keyword">if</span> peek.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> peek.right != last_visit:</span><br><span class="line">                curr = peek.right</span><br><span class="line">            <span class="keyword">else</span>:               <span class="comment"># right child is None or has been visited</span></span><br><span class="line">                last_visit = stack.pop()</span><br><span class="line">                res.append(last_visit.val)  <span class="comment"># visit node</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="morris-traversal-inorder-traversal">Morris Traversal (Inorder Traversal)</h1><p>In this method, we have to use a new data structure -- Threaded Binary Tree, and the strategy is as follows:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. Initialize current as root</span><br><span class="line">2. While current is not None</span><br><span class="line">    2.1 If current does not have left child</span><br><span class="line">        a. Add current&apos;s data</span><br><span class="line">        b. Go to the right, i.e. current = current.right</span><br><span class="line">    2.2 Else</span><br><span class="line">        a. In current&apos;s left subtree, make current the right child of the rightmost node</span><br><span class="line">        b. Go to this left child, i.e. current = current.left</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     1       curr = 1, has left child 2, go to 2.2</span><br><span class="line">   /   \</span><br><span class="line">  2     3       a. make 1 as the right child of 5 (5 is the rightmost node in left subtree)</span><br><span class="line"> / \   /        b. curr = 2</span><br><span class="line">4   5 6  </span><br><span class="line"></span><br><span class="line">  2          go to 2.2</span><br><span class="line"> / \            a. make 2 as the right child of 4</span><br><span class="line">4   5           b. curr = 4</span><br><span class="line">     \</span><br><span class="line">      1</span><br><span class="line">       \</span><br><span class="line">        3</span><br><span class="line">       /</span><br><span class="line">      6</span><br><span class="line"></span><br><span class="line">4.          go to 2.1</span><br><span class="line"> \              a. add node 4 (visited nodes are marked by .)</span><br><span class="line">  2.            b. curr = 2</span><br><span class="line">   \</span><br><span class="line">    5.      repeat 2.1 until curr = 3</span><br><span class="line">     \</span><br><span class="line">      1.</span><br><span class="line">       \    go to 2.1</span><br><span class="line">        3       a. make 3 as the right child of 6</span><br><span class="line">       /        b. curr = 6</span><br><span class="line">      6</span><br><span class="line"></span><br><span class="line">4.</span><br><span class="line"> \</span><br><span class="line">  2.</span><br><span class="line">   \</span><br><span class="line">    5.</span><br><span class="line">     \</span><br><span class="line">      1.</span><br><span class="line">       \    right child of 1 is also 3,</span><br><span class="line">        3   but have no influence on the result</span><br><span class="line"></span><br><span class="line">      6      curr = 6, repeat 2.1 until end.</span><br><span class="line">       \</span><br><span class="line">        3</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        res = []</span><br><span class="line">        curr, pre = root, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curr <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> curr.left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                res.append(curr.val)</span><br><span class="line">                curr = curr.right  <span class="comment"># move to next right node</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = curr.left</span><br><span class="line">                <span class="keyword">while</span> pre.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment"># find rightmost</span></span><br><span class="line">                    pre = pre.right</span><br><span class="line">                pre.right = curr   <span class="comment"># put curr after the pre node</span></span><br><span class="line">                temp = curr</span><br><span class="line">                curr = curr.left   <span class="comment"># move curr to the top of the new tree</span></span><br><span class="line">                temp.left = <span class="literal">None</span>   <span class="comment"># avoid infinite loops</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stack </tag>
            
            <tag> recursion </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Longest Valid Parentheses</title>
      <link href="/programming/leetcode/longest-valid-parentheses/"/>
      <url>/programming/leetcode/longest-valid-parentheses/</url>
      
        <content type="html"><![CDATA[<p>Given a string <code>s</code> containing just the characters <code>(</code> and <code>)</code>, find the length of the longest valid (well-formed) parentheses substring.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;(()&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;)()())&quot;</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><h1 id="dynamic-programming">Dynamic Programming</h1><p><code>dp[i]</code> denotes length of the longest valid substring ending at ith index.</p><p>Induction rules:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if s[i] == &apos;(&apos;:        # valid parentheses never end with &apos;(&apos;</span><br><span class="line">    dp[i] = 0</span><br><span class="line"></span><br><span class="line">if s[i] == &apos;)&apos;:</span><br><span class="line">    if s[i - 1] == &apos;(&apos;:                   # &apos;x()&apos;</span><br><span class="line">        # dp[i - 2] is the length of &apos;x&apos;, 2 is the length of &apos;()&apos;</span><br><span class="line">        dp[i] = dp[i - 2] + 2</span><br><span class="line"></span><br><span class="line">    # dp[i - 1] is the length of &apos;x&apos;</span><br><span class="line">    elif s[i - dp[i - 1] - 1] == &apos;(&apos;:     # &apos;y(x)&apos;</span><br><span class="line">        # dp[i - dp[i - 1] - 2] is the length of &apos;y&apos;</span><br><span class="line">        dp[i] = dp[i - dp[i - 1] - 2] + dp[i - 1] + 2</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        maxans = <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span>] * len(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">')'</span>:</span><br><span class="line">                <span class="keyword">if</span> s[i - <span class="number">1</span>] == <span class="string">'('</span>:</span><br><span class="line">                    dp[i] = dp[i - <span class="number">2</span>] + <span class="number">2</span></span><br><span class="line">                <span class="keyword">elif</span> i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> s[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">'('</span>:</span><br><span class="line">                    dp[i] = dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] + dp[i - <span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">            maxans = max(maxans, dp[i])</span><br><span class="line">        <span class="keyword">return</span> maxans</span><br></pre></td></tr></table></figure><h1 id="using-stack">Using Stack</h1><p>Initial, push -1 onto stack.</p><p>For every <code>'('</code> encountered, push its index onto the stack.</p><p>For every <code>')'</code> encountered, pop the topmost element and substract the current element's index from the new top element of the stack, which gives the length of the currently encountered valid string of parentheses. If while popping the element, the stack becomes empty, we push the current element's index onto the stack.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        maxans = <span class="number">0</span></span><br><span class="line">        stack = [<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'('</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">                <span class="keyword">if</span> stack:</span><br><span class="line">                    maxans = max(maxans, i - stack[<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> maxans</span><br></pre></td></tr></table></figure><h1 id="without-extra-space">Without extra space</h1><p>In this approach, we make use of two counters <code>left</code> and <code>right</code>.</p><p>First, we start traversing the string from the left towards the right and for every <code>'('</code> encountered, we increment the <code>left</code> counter and for every <code>')'</code> encountered, we increment the <code>right</code> counter. Whenever <code>left</code> becomes equal to <code>right</code>, we calculate the length of the current valid string and keep track of maximum length substring found so far. If <code>right</code> becomes greater than <code>left</code> we reset <code>left</code> and <code>right</code> to 0.</p><p>Next, we start traversing the string from right to left and similar procedure is applied.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        maxans = left = right = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:            <span class="comment"># left to right scan</span></span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">'('</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left == right:</span><br><span class="line">                maxans = max(maxans, <span class="number">2</span> * left)</span><br><span class="line">            <span class="keyword">elif</span> right &gt; left:</span><br><span class="line">                left = right = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> reversed(s):  <span class="comment"># right to left scan</span></span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">'('</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left == right:</span><br><span class="line">                maxans = max(maxans, <span class="number">2</span> * left)</span><br><span class="line">            <span class="keyword">elif</span> right &gt; left:</span><br><span class="line">                left = right = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> stack </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Longest Palindromic Substring</title>
      <link href="/programming/leetcode/longest-palindromic-substring/"/>
      <url>/programming/leetcode/longest-palindromic-substring/</url>
      
        <content type="html"><![CDATA[<p>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000。</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;cbbd&quot;</span><br><span class="line">Output: &quot;bb&quot;</span><br></pre></td></tr></table></figure><h1 id="dynamic-progromming">Dynamic Progromming</h1><p><code>dp[i][j]</code> denotes whether the substring <code>s[i..j]</code> is a palindrome.</p><p>Base cases:</p><ul><li><p><code>dp[i][i] = true</code>.</p></li><li><p><code>dp[i][i + 1] = s[i] == s[i + 1]</code>.</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s=&quot;xabaa&quot;</span><br><span class="line"></span><br><span class="line">dp  0  1  2  3  4</span><br><span class="line"> 0  T  F</span><br><span class="line"> 1     T  F</span><br><span class="line"> 2        T  F</span><br><span class="line"> 3           T  T</span><br><span class="line"> 4              T</span><br></pre></td></tr></table></figure><p>Induction rule:</p><p>If <code>s[i] == s[j]</code>, then <code>dp[i][j] = dp[i + 1][j - 1]</code>. i.e. <code>dp[i][j] = dp[i + 1][j - 1] and s[i] == s[j]</code>.</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2)</span></span><br><span class="line"><span class="comment"># Space: O(n^2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        n, start, stop = len(s), <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        dp = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> left <span class="keyword">in</span> range(right + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[left] == s[right] <span class="keyword">and</span> \</span><br><span class="line">                        (right - left &lt;= <span class="number">2</span> <span class="keyword">or</span> dp[left + <span class="number">1</span>][right - <span class="number">1</span>]):</span><br><span class="line">                    dp[left][right] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">if</span> stop - start &lt; right - left + <span class="number">1</span>:</span><br><span class="line">                        start, stop = left, right + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[start:stop]</span><br></pre></td></tr></table></figure><h1 id="expand-around-center">Expand Around Center</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line"></span><br><span class="line">        start, end = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            len1 = self.expandAroundCenter(s, i, i)      <span class="comment"># length is odd</span></span><br><span class="line">            len2 = self.expandAroundCenter(s, i, i + <span class="number">1</span>)  <span class="comment"># length is even</span></span><br><span class="line">            len_max = max(len1, len2)</span><br><span class="line">            <span class="keyword">if</span> len_max &gt; end - start:  <span class="comment"># calculate the start and end of palindromic string</span></span><br><span class="line">                <span class="comment"># what a smart way</span></span><br><span class="line">                start = i - (len_max - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">                end = i + len_max // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> s[start:end + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expandAroundCenter</span><span class="params">(self, s: str, left: int, right: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; len(s) <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">            left, right = left - <span class="number">1</span>, right + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>  <span class="comment"># length of palindromic string</span></span><br></pre></td></tr></table></figure><h1 id="manachers-algorithm">Manacher's Algorithm</h1><p>// TODO //</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
            <tag> palindrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Regular Expression Matching</title>
      <link href="/programming/leetcode/regular-expression-matching/"/>
      <url>/programming/leetcode/regular-expression-matching/</url>
      
        <content type="html"><![CDATA[<p>Given an input string (<code>s</code>) and a pattern (<code>p</code>), implement regular expression matching with support for <code>'.'</code> and <code>'*'</code>.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;.&apos; Matches any single character.</span><br><span class="line">&apos;*&apos; Matches zero or more of the preceding element.</span><br></pre></td></tr></table></figure><p>The matching should cover the <strong>entire</strong> input string (not partial).</p><p><strong>Note:</strong></p><ul><li><code>s</code> could be empty and contains only lowercase letters <code>a-z</code>.</li><li><code>p</code> could be empty and contains only lowercase letters <code>a-z</code>, and characters like <code>.</code> or <code>*</code>.</li></ul><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;aa&quot;, p = &quot;a&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;aa&quot;, p = &quot;a*&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>Example 3:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;ab&quot;, p = &quot;.*&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>Example 4:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;aab&quot;, p = &quot;c*a*b&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>Example 5:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;mississippi&quot;, p = &quot;mis*is*p*&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><h1 id="recursive-approach">Recursive Approach</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, text: str, pattern: str)</span> -&gt; bool:</span></span><br><span class="line">        first_match = bool(text) <span class="keyword">and</span> pattern[<span class="number">0</span>] <span class="keyword">in</span> &#123;text[<span class="number">0</span>], <span class="string">'.'</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(pattern) &gt;= <span class="number">2</span> <span class="keyword">and</span> pattern[<span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">            <span class="keyword">return</span> (self.isMatch(text, pattern[<span class="number">2</span>:]) <span class="keyword">or</span>                  <span class="comment"># pattern[0:2] matches empty sequence</span></span><br><span class="line">                    first_match <span class="keyword">and</span> self.isMatch(text[<span class="number">1</span>:], pattern))    <span class="comment"># pattern[0:2] matches one character</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> first_match <span class="keyword">and</span> self.isMatch(text[<span class="number">1</span>:], pattern[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure><p>Time complexity: <span class="math inline">\(O((m+n)2^{m+\frac{n}{2}})\)</span>, where <code>m</code> is the length of text and <code>n</code> is the length of pattern.</p><p>Space complexity: <span class="math inline">\(O((m+n)2^{m+\frac{n}{2}})\)</span>.</p><a id="more"></a><h1 id="dynamic-programming">Dynamic Programming</h1><p><code>dp[i][j]</code> denotes wether <code>text[i..m]</code> matches <code>pattern[j..n]</code>. Indices start from 0.</p><p>Base cases:</p><ul><li><p><code>dp[i][n] = False</code>. when <code>i = 0, 1, ..., m-1</code>. Because <code>text[i:] != ''</code> but <code>pattern[n:] == ''</code>.</p></li><li><p><code>dp[m][n] = True</code>. Because <code>text[m:] == ''</code> and <code>pattern[n:] == ''</code>.</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp  0  1  2  ... n</span><br><span class="line"> 0               F</span><br><span class="line"> 1               F</span><br><span class="line"> 2               F</span><br><span class="line">...              F</span><br><span class="line"> m               T</span><br></pre></td></tr></table></figure><p>Induction rules:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If p[j + 1] == &apos;*&apos;:                 # p[j]p[j + 1] may match zero or many chars in text</span><br><span class="line">    dp[i][j] = dp[i][j + 2] or      # when match zero char, s[i] != p[j] is also acceptable</span><br><span class="line">               dp[i + 1][j] and (s[i] == p[j] or p[j] == &apos;.&apos;)  # or match one char</span><br><span class="line"></span><br><span class="line">if p[j + 1] != &apos;*&apos;:             # s[i] must match p[j] and s[i+1:] must match p[j+1:]</span><br><span class="line">    dp[i][j] = (s[i] == p[j] or p[j] == &apos;.&apos;) and dp[i + 1][j + 1]</span><br></pre></td></tr></table></figure><h2 id="top-down-variation">Top-Down Variation</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(mn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, text: str, pattern: str)</span> -&gt; bool:</span></span><br><span class="line">        memo = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> (i, j) <span class="keyword">not</span> <span class="keyword">in</span> memo:</span><br><span class="line">                <span class="keyword">if</span> j == len(pattern):</span><br><span class="line">                    ans = i == len(text)  <span class="comment"># dp(m, n) is true, otherwise false</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    first_match = i &lt; len(text) <span class="keyword">and</span> pattern[j] <span class="keyword">in</span> &#123;text[i], <span class="string">'.'</span>&#125;</span><br><span class="line">                    <span class="keyword">if</span> j + <span class="number">1</span> &lt; len(pattern) <span class="keyword">and</span> pattern[j + <span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                        ans = dp(i, j + <span class="number">2</span>) <span class="keyword">or</span> first_match <span class="keyword">and</span> dp(i + <span class="number">1</span>, j)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        ans = first_match <span class="keyword">and</span> dp(i + <span class="number">1</span>, j + <span class="number">1</span>)</span><br><span class="line">                memo[i, j] = ans</span><br><span class="line">            <span class="keyword">return</span> memo[i, j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp(<span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="bottom-up-variation">Bottom-Up Variation</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(mn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, text: str, pattern: str)</span> -&gt; bool:</span></span><br><span class="line">        dp = [[<span class="literal">False</span>] * (len(pattern) + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(text) + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">-1</span>][<span class="number">-1</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(text), <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(pattern) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                first_match = i &lt; len(text) <span class="keyword">and</span> pattern[j] <span class="keyword">in</span> &#123;text[i], <span class="string">'.'</span>&#125;</span><br><span class="line">                <span class="keyword">if</span> j + <span class="number">1</span> &lt; len(pattern) <span class="keyword">and</span> pattern[j + <span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                    dp[i][j] = dp[i][j + <span class="number">2</span>] <span class="keyword">or</span> first_match <span class="keyword">and</span> dp[i + <span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = first_match <span class="keyword">and</span> dp[i + <span class="number">1</span>][j + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
            <tag> matching </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据表示与特征工程</title>
      <link href="/notes/introduction-to-ml-with-python/representing-data-and-engineering-features/"/>
      <url>/notes/introduction-to-ml-with-python/representing-data-and-engineering-features/</url>
      
        <content type="html"><![CDATA[<p>到目前为止，我们一直假设数据是由浮点数组成的二维数组，其中每一列是描述数据点的<strong>连续特征</strong>（continuous feature）。对于许多应用而言，数据的收集方式并不是这样。一种常见的特征类型就是<strong>分类特征</strong>（categorical feature），也叫<strong>离散特征</strong>（discrete feature）。分类特征的例子包括产品的品牌、产品的颜色或产品的销售部门。这些都是描述一件产品的属性，但它们不以连续的方式变化。</p><p>无论数据包含哪种类型的特征，数据表示方式都会对机器学习模型的性能产生巨大影响。数据缩放非常重要。如果你没有缩放数据（比如，缩放到单位方差），那么你用厘米还是英寸表示测量数据的结果将会不同。用额外的特征<strong>扩充</strong>（augment）数据也很有帮助，比如添加特征的交互项（乘积）或更一般的多项式。</p><p>对于某个特定应用来说，如何找到最佳数据表示，这个问题被称为<strong>特征工程</strong>（feature engineering），它是数据科学家和机器学习从业者在尝试解决现实世界问题时主要任务之一。用正确的方式表示数据，对监督模型性能的影响比所选择的精确参数还要大。</p><a id="more"></a><h1 id="分类变量">分类变量</h1><p>作为例子，我们将使用美国成年人收入的数据集。adult数据集的任务是预测一名工人的收入是高于50 000美元还是低于50 000美元。这个数据集的特征包括工人的年龄、雇佣方式、教育水平、性别、每周工作时长、职业，等等。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> display</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件中没有包含列名称的表头，因此我们传入header=None</span></span><br><span class="line"><span class="comment"># 然后在"names"中显式地提供名称</span></span><br><span class="line">data = pd.read_csv(os.path.join(mglearn.datasets.DATA_PATH, <span class="string">"adult.data"</span>),</span><br><span class="line">    header=<span class="literal">None</span>, index_col=<span class="literal">False</span>,</span><br><span class="line">    names=[<span class="string">'age'</span>, <span class="string">'workclass'</span>, <span class="string">'fnlwgt'</span>, <span class="string">'education'</span>, <span class="string">'education-num'</span>,</span><br><span class="line">           <span class="string">'marital-status'</span>, <span class="string">'occupation'</span>, <span class="string">'relationship'</span>, <span class="string">'race'</span>, <span class="string">'gender'</span>,</span><br><span class="line">           <span class="string">'capital-gain'</span>, <span class="string">'capital-loss'</span>, <span class="string">'hours-per-week'</span>, <span class="string">'native-country'</span>,</span><br><span class="line">           <span class="string">'income'</span>])</span><br><span class="line"><span class="comment"># 只选其中几列</span></span><br><span class="line">data = data[[<span class="string">'age'</span>, <span class="string">'workclass'</span>, <span class="string">'education'</span>, <span class="string">'gender'</span>, <span class="string">'hours-per-week'</span>,</span><br><span class="line">             <span class="string">'occupation'</span>, <span class="string">'income'</span>]]</span><br><span class="line"></span><br><span class="line">display(data.head())</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   age          workclass  ...          occupation  income</span><br><span class="line">0   39          State-gov  ...        Adm-clerical   &lt;=50K</span><br><span class="line">1   50   Self-emp-not-inc  ...     Exec-managerial   &lt;=50K</span><br><span class="line">2   38            Private  ...   Handlers-cleaners   &lt;=50K</span><br><span class="line">3   53            Private  ...   Handlers-cleaners   &lt;=50K</span><br><span class="line">4   28            Private  ...      Prof-specialty   &lt;=50K</span><br><span class="line"></span><br><span class="line">[5 rows x 7 columns]</span><br></pre></td></tr></table></figure><p>在这个数据集中，age（年龄）和hours-per-week（每周工作时长）是连续特征。但workclass（工作类型）、education（教育程度）、gender（性别）、occupation（职业）都是分类特征，它们都来自一系列固定的可能取值（而不是一个范围），表示的是定性属性（而不是数量）。</p><p>假设我们想要在这个数据上学习一个Logistic回归分类器。Logistic回归利用下列公式进行预测：</p><p><span class="math display">\[\hat y=w[0]*x[0]+w[1]*x[1]+\dots+w[p]*x[p]+b&gt;0\]</span></p><p>其中 <span class="math inline">\(w[i]\)</span> 和 <span class="math inline">\(b\)</span> 是从训练集中学到的系数，<span class="math inline">\(x[i]\)</span> 是输入特征。当 <span class="math inline">\(x[i]\)</span> 是数字时这个公式才有意义，但如果 <span class="math inline">\(x[2]\)</span> 是 &quot;Masters&quot; 或 &quot;Bachelors&quot; 的话，这个公式则没有意义。显然，在应用Logistic回归时，我们需要换一种方式来表示数据。</p><h2 id="one-hot编码虚拟变量">One-Hot编码（虚拟变量）</h2><p>表示分类变量最常用的方法就是使用 <strong>one-hot编码</strong>（one-hot-encoding）或 <strong>N取一编码</strong>（one-out-of-N encoding），也叫<strong>虚拟变量</strong>（dummy variable）。虚拟变量背后的思想是将一个分类变量替换为一个或多个新特征，新特征取值为 0 和 1。对于线性二分类（以及 scikit-learn 中其他所有模型）的公式而言，0 和 1 这两个值是有意义的，我们可以对每个类别引入一个新特征，从而表示任意数量的类别。</p><p>比如说 workclass 特征的可能取值包括 &quot;Government Employee&quot;、&quot;Private Employee&quot;、&quot;Self Employed&quot; 和 &quot;Self Employed Incorporated&quot;。为了编码这4个可能的取值，我们创建了4个新特征，分别叫作 &quot;Government Employee&quot;、&quot;Private Employee&quot;、&quot;Self Employed&quot; 和 &quot;Self Employed Incorporated&quot;。如果一个人的 workclass 取某个值，那么对应的特征取值为 1，其他特征均取值为 0。因此，对每个数据点来说，4个新特征中只有一个的取值为 1。这就是它叫作 one-hot 编码或 N取一编码的原因。</p><blockquote><p>我们使用的 one-hot 编码与统计学中使用的虚拟编码（dummy encoding）非常相似，但并不完全相同。在统计学中，通常将具有 k 个可能取值的分类特征编码为 k-1 个特征（都等于零表示最后一个可能取值）。这么做是为了简化分析（更专业的说法是，这可以避免使数据矩阵秩亏）。</p></blockquote><p>将数据转换为分类变量的 one-hot 编码有两种方法：一种是使用 pandas，一种是使用 scikit-learn。</p><h3 id="检查字符串编码的分类数据">检查字符串编码的分类数据</h3><p>读取完数据集之后，最好先检查每一列是否包含有意义的分类数据。在处理人工（比如网站用户）输入的数据时，可能没有固定的类别，拼写和大小写也存在差异，因此可能需要预处理。检查列的内容有一个好方法，就是使用 pandas Series（Series 是 DataFrame 中单列对应的数据类型）的 values_counts 函数，以显示唯一值及其出现次数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(data.gender.value_counts())</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> Male      21790</span><br><span class="line"> Female    10771</span><br><span class="line">Name: gender, dtype: int64</span><br></pre></td></tr></table></figure><p>在这个数据集中性别刚好有两个值：Male 和 Female，这说明数据格式已经很好，可以用 one-hot 编码来表示。在实际的应用中，你应该检查所有列的值。</p><p>用 pandas 编码数据有一种非常简单的方法，就是使用 get_dummies 函数。get_dummies 函数自动变换所有具有对象类型（比如字符串）的列或所有分类的列（这是 pandas 中的一个特殊概念，还没有讲到）。</p><blockquote><p><a href="https://devdocs.io/pandas~0.25/reference/api/pandas.get_dummies" target="_blank" rel="noopener"><code>pandas.get_dummies(data, prefix=None, prefix_sep='_', dummy_na=False, columns=None, sparse=False, drop_first=False, dtype=None)</code></a></p><p>Convert categorical variable into dummy/indicator variables.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"Original features:\n"</span>, list(data.columns), <span class="string">"\n"</span>)</span><br><span class="line">data_dummies = pd.get_dummies(data)</span><br><span class="line">print(<span class="string">'Features after get_dummies:\n'</span>, list(data_dummies.columns))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Original features:</span><br><span class="line"> [&apos;age&apos;, &apos;workclass&apos;, &apos;education&apos;, &apos;gender&apos;, &apos;hours-per-week&apos;, &apos;occupation&apos;, &apos;income&apos;]</span><br><span class="line"></span><br><span class="line">Features after get_dummies:</span><br><span class="line"> [&apos;age&apos;, &apos;hours-per-week&apos;, &apos;workclass_ ?&apos;, &apos;workclass_ Federal-gov&apos;, &apos;workclass_ Local-gov&apos;, &apos;workclass_ Never-worked&apos;, &apos;workclass_ Private&apos;, &apos;workclass_ Self-emp-inc&apos;, &apos;workclass_ Self-emp-not-inc&apos;, &apos;workclass_ State-gov&apos;, &apos;workclass_ Without-pay&apos;, &apos;education_ 10th&apos;, &apos;education_ 11th&apos;, &apos;education_ 12th&apos;, &apos;education_ 1st-4th&apos;, &apos;education_ 5th-6th&apos;, &apos;education_ 7th-8th&apos;, &apos;education_ 9th&apos;, &apos;education_ Assoc-acdm&apos;, &apos;education_ Assoc-voc&apos;, &apos;education_ Bachelors&apos;, &apos;education_ Doctorate&apos;, &apos;education_ HS-grad&apos;, &apos;education_ Masters&apos;, &apos;education_ Preschool&apos;, &apos;education_ Prof-school&apos;, &apos;education_ Some-college&apos;, &apos;gender_ Female&apos;, &apos;gender_ Male&apos;, &apos;occupation_ ?&apos;, &apos;occupation_ Adm-clerical&apos;, &apos;occupation_ Armed-Forces&apos;, &apos;occupation_ Craft-repair&apos;, &apos;occupation_ Exec-managerial&apos;, &apos;occupation_ Farming-fishing&apos;, &apos;occupation_ Handlers-cleaners&apos;, &apos;occupation_ Machine-op-inspct&apos;, &apos;occupation_ Other-service&apos;, &apos;occupation_ Priv-house-serv&apos;, &apos;occupation_ Prof-specialty&apos;, &apos;occupation_ Protective-serv&apos;, &apos;occupation_ Sales&apos;, &apos;occupation_ Tech-support&apos;, &apos;occupation_ Transport-moving&apos;, &apos;income_ &lt;=50K&apos;, &apos;income_ &gt;50K&apos;]</span><br></pre></td></tr></table></figure><p>可以看到，连续特征 age 和 hours-per-week 没有发生变化，而分类特征的每个可能取值都被扩展为一个新特征。</p><p>下面我们可以使用 values 属性将 data_dummies 数据框（DataFrame）转换为 NumPy 数组，然后在其上训练一个机器学习模型。在训练模型之前，注意要把目标变量（现在被编码为两个 income 列）从数据中分离出来。</p><blockquote><p>注意：andas 中的列索引包括范围的结尾，因此 'age':'occupation_ Transport-moving' 中包括 occupation_ Transport-moving。这与 NumPy数组的切片不同，后者不包括范围的末尾，例如 <code>np.arange(11)[0:10]</code>不包括索引编号为 10 的元素。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">features = data_dummies.ix[:, <span class="string">'age'</span>:<span class="string">'occupation_ Transport-moving'</span>]</span><br><span class="line"><span class="comment"># 提取NumPy数组</span></span><br><span class="line">X = features.values</span><br><span class="line">y = data_dummies[<span class="string">'income_ &gt;50K'</span>].values</span><br><span class="line">print(<span class="string">'X.shape: &#123;&#125;  y.shape: &#123;&#125;'</span>.format(X.shape, y.shape))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X.shape: (32561, 44)  y.shape: (32561,)</span><br></pre></td></tr></table></figure><p>现在数据的表示方式可以被 scikit-learn 处理。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=<span class="number">0</span>)</span><br><span class="line">logreg = LogisticRegression()</span><br><span class="line">logreg.fit(X_train, y_train)</span><br><span class="line">print(<span class="string">'Test score: &#123;:.2f&#125;'</span>.format(logreg.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test score: 0.81</span><br></pre></td></tr></table></figure><p>在这个例子中，我们对同时包含训练数据和测试数据的数据框调用 get_dummies。这一点很重要，可以确保训练集和测试集中分类变量的表示方式相同。</p><p>假设我们的训练集和测试集位于两个不同的数据框中。如果 workclass 特征的 &quot;Private Employee&quot; 取值没有出现在测试集中，那么 pandas 会认为这个特征只有3个可能的取值，因此只会创建 3 个新的虚拟特征。现在训练集和测试集的特征个数不相同，我们就无法将在训练集上学到的模型应用到测试集上。</p><p>更糟糕的是，假设 workclass 特征在训练集中有 &quot;Government Employee&quot; 和 &quot;Private Employee&quot; 两个值，而在测试集中有 &quot;Self Employed&quot; 和 &quot;Self Employed Incorporated&quot; 两个值。在两种情况下，pandas 都会创建两个新的虚拟特征，所有编码后的数据框的特征个数相同。但在训练集和测试集中的两个虚拟特征含义完全不同。如果我们在这个数据上构建机器学习模型，那么它的表现会很差。要想避免这个问题，可以在同时包含训练数据点和测试数据点的数据框上调用 get_dummies，确保调用 get_dummies后训练集和测试集的列名称相同，保证它们具有相同的语义。</p><h2 id="数字可以编码分类变量">数字可以编码分类变量</h2><p>在 adult 数据集的例子中，分类变量被编码为字符串。一方面，可能会有拼写错误；但另一方面，它明确地将一个变量标记为分类变量。（然而）无论是为了便于存储还是因为数据的收集方式，分类变量通常被编码为整数。例如，假设 adult 数据集中的人口普查数据是利用问卷收集的，workclass 的回答被记录为 0（在第一个框打勾）、1、2，等等。现在该列包含数字 0 到 8，而不是像 &quot;Private&quot; 这样的字符串。如果有人观察表示数据集的表格，很难一眼看出这个变量应该被视为连续变量还是分类变量。但是，如果知道这些数字表示的是就业状况，那么很明显它们是不同的状态，不应该用单个连续变量来建模。</p><blockquote><p>分类特征通常用整数进行编码。它们是数字并不意味着它们必须被视为连续特征。一个整数特征应该被视为连续的还是离散的，有时并不明确。如果在被编码的语义之间没有顺序关系（比如 workclass 的例子），那么特征必须被视为离散特征。对于其他情况（比如五星评分），哪种编码更好取决于具体的任务和数据，以及使用哪种机器学习算法。</p></blockquote><p>pandas的 get_dummies 函数将所有数字看作是连续的，不会为其创建虚拟变量。为了解决这个问题，你可以使用 scikit-learn 的 OneHotEncoder，指定哪些变量是连续的、哪些变量是离散的，你也可以将数据框中的数值列转换为字符串。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个DataFrame，包含一个整数特征和一个分类字符串特征</span></span><br><span class="line">demo_df = pd.DataFrame(&#123;<span class="string">'Integer Feature'</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">                        <span class="string">'Categorical Feature'</span>: [<span class="string">'socks'</span>, <span class="string">'fox'</span>, <span class="string">'socks'</span>, <span class="string">'box'</span>]&#125;)</span><br><span class="line">display(demo_df)</span><br><span class="line"><span class="comment"># 使用 get_dummies 只会编码字符串特征，不会改变整数特征</span></span><br><span class="line">display(pd.get_dummies(demo_df))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   Integer Feature Categorical Feature</span><br><span class="line">0                0               socks</span><br><span class="line">1                1                 fox</span><br><span class="line">2                2               socks</span><br><span class="line">3                1                 box</span><br><span class="line">   Integer Feature  ...  Categorical Feature_socks</span><br><span class="line">0                0  ...                          1</span><br><span class="line">1                1  ...                          0</span><br><span class="line">2                2  ...                          1</span><br><span class="line">3                1  ...                          0</span><br><span class="line"></span><br><span class="line">[4 rows x 4 columns]</span><br></pre></td></tr></table></figure><p>如果你想为 &quot;Integer Feature&quot; 这一列创建虚拟变量，可以使用 columns 参数显示地给出想要编码的列。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">demo_df[<span class="string">'Integer Feature'</span>] = demo_df[<span class="string">'Integer Feature'</span>].astype(str)</span><br><span class="line">display(pd.get_dummies(demo_df, columns=[<span class="string">'Integer Feature'</span>, <span class="string">'Categorical Feature'</span>]))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   Integer Feature_0  ...  Categorical Feature_socks</span><br><span class="line">0                  1  ...                          1</span><br><span class="line">1                  0  ...                          0</span><br><span class="line">2                  0  ...                          1</span><br><span class="line">3                  0  ...                          0</span><br><span class="line"></span><br><span class="line">[4 rows x 6 columns]</span><br></pre></td></tr></table></figure><h1 id="分箱离散化线性模型与树">分箱、离散化、线性模型与树</h1><p>数据表示的最佳方法不仅取决于数据的语义，还取决于所使用的模型种类。线性模型与基于树的模型（比如决策树、梯度提升树和随机森林）是两种成员很多同时又非常常用的模型，它们在处理不同的特征表示时就具有非常不同的性质。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X, y = mglearn.datasets.make_wave(n_samples=<span class="number">100</span>)</span><br><span class="line">line = np.linspace(<span class="number">-3</span>, <span class="number">3</span>, <span class="number">1000</span>, endpoint=<span class="literal">False</span>).reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">reg = DecisionTreeRegressor(min_samples_split=<span class="number">3</span>).fit(X, y)</span><br><span class="line">plt.plot(line, reg.predict(line), label=<span class="string">"decision tree"</span>)</span><br><span class="line"></span><br><span class="line">reg = LinearRegression().fit(X, y)</span><br><span class="line">plt.plot(line, reg.predict(line), label=<span class="string">"linear regression"</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(X[:, <span class="number">0</span>], y, <span class="string">'o'</span>, c=<span class="string">'k'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Regression output'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Input feature'</span>)</span><br><span class="line">plt.legend(loc=<span class="string">'best'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/difference-between-tree-and-linear.png"></p><p>线性模型只能对线性关系建模，对于单个特征的情况就是直线。决策树可以构建更为复杂的数据模型，但这强烈依赖于数据表示。有一种方法可以让线性模型在连续数据上变得更加强大，就是使用特征<strong>分箱</strong>（binning，也叫<strong>离散化</strong>，即 discretization）将其划分为多个特征。</p><p>我们假设将特征的输入范围划分成固定个数的<strong>箱子</strong>（bin），比如 10 个，那么数据点就可以用它所在的箱子来表示。为了确定这一点，我们首先需要定义箱子。在这个例子中，我们在 -3 和 3 之间定义 10 个均匀分布的箱子。我们用 np.linspace 函数创建 11 个元素，从而创建 10 个箱子，即两个连续边界之间的空间。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bins = np.linspace(<span class="number">-3</span>, <span class="number">3</span>, <span class="number">11</span>)</span><br><span class="line">print(<span class="string">'bins: &#123;&#125;'</span>.format(bins))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bins: [-3.  -2.4 -1.8 -1.2 -0.6  0.   0.6  1.2  1.8  2.4  3. ]</span><br></pre></td></tr></table></figure><p>接下来，我们记录每个数据点所属的箱子。这可以用 np.digitize 函数轻松计算出来。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">which_bin = np.digitize(X, bins=bins)</span><br><span class="line">print(<span class="string">'Data points:\n'</span>, X[:<span class="number">5</span>])</span><br><span class="line">print(<span class="string">'\nBin membership for data points:\n'</span>, which_bin[:<span class="number">5</span>])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Data points:</span><br><span class="line"> [[-0.75275929]</span><br><span class="line"> [ 2.70428584]</span><br><span class="line"> [ 1.39196365]</span><br><span class="line"> [ 0.59195091]</span><br><span class="line"> [-2.06388816]]</span><br><span class="line"></span><br><span class="line">Bin membership for data points:</span><br><span class="line"> [[ 4]</span><br><span class="line"> [10]</span><br><span class="line"> [ 8]</span><br><span class="line"> [ 6]</span><br><span class="line"> [ 2]]</span><br></pre></td></tr></table></figure><p>我们在这里做的是将 wave 数据集中单个连续输入特征变换为一个分类特征，用于表示数据点所在的箱子。要想在这个数据上使用 scikit-learn 模型，我们利用 preprocessing 模块的 OneHotEncoder 将这个离散特征变换为 one-hot 编码。 OneHotEncoder 实现的编码与 pandas.get_dummies 相同，但目前它只适用于值为整数的分类变量。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.preprocessing.onehotencoder#sklearn.preprocessing.OneHotEncoder" target="_blank" rel="noopener"><code>class sklearn.preprocessing.OneHotEncoder(n_values=None, categorical_features=None, categories=None, sparse=True, dtype=&lt;class ‘numpy.float64’&gt;, handle_unknown=’error’)</code></a></p><p>Encode categorical integer features as a one-hot numeric array.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用OneHotEncoder进行变换</span></span><br><span class="line">encoder = OneHotEncoder(sparse=<span class="literal">False</span>)</span><br><span class="line">encoder.fit(which_bin)</span><br><span class="line">X_binned = encoder.transform(which_bin)</span><br><span class="line">print(X_binned[:<span class="number">5</span>])</span><br><span class="line"><span class="comment"># 由于我们指定了 10 个箱子，所以变换后的 X_binned 数据集现在包含 10 个特征</span></span><br><span class="line">print(<span class="string">'X_binned.shape: &#123;&#125;'</span>.format(X_binned.shape))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[0. 0. 0. 1. 0. 0. 0. 0. 0. 0.]</span><br><span class="line"> [0. 0. 0. 0. 0. 0. 0. 0. 0. 1.]</span><br><span class="line"> [0. 0. 0. 0. 0. 0. 0. 1. 0. 0.]</span><br><span class="line"> [0. 0. 0. 0. 0. 1. 0. 0. 0. 0.]</span><br><span class="line"> [0. 1. 0. 0. 0. 0. 0. 0. 0. 0.]]</span><br><span class="line">X_binned.shape: (100, 10)</span><br></pre></td></tr></table></figure><p>下面我们在 one-hot 编码后的数据上构建新的线性模型和新的决策树模型。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">line_binned = encoder.transform(np.digitize(line, bins=bins))</span><br><span class="line"></span><br><span class="line">reg = LinearRegression().fit(X_binned, y)</span><br><span class="line">plt.plot(line, reg.predict(line_binned), label=<span class="string">'linear regression binned'</span>)</span><br><span class="line"></span><br><span class="line">reg = DecisionTreeRegressor(min_samples_split=<span class="number">3</span>).fit(X_binned, y)</span><br><span class="line">plt.plot(line, reg.predict(line_binned), label=<span class="string">'decision tree binned'</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(X[:, <span class="number">0</span>], y, <span class="string">'o'</span>, c=<span class="string">'k'</span>)</span><br><span class="line">plt.vlines(bins, <span class="number">-3</span>, <span class="number">3</span>, linewidth=<span class="number">1</span>, alpha=<span class="number">.2</span>)</span><br><span class="line">plt.legend(loc=<span class="string">'best'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Regresson output'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Input feature'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/linear-and-tree-on-binned-data.png"></p><p>虚线和实线完全重合，说明线性回归模型和决策树模型做出了完全相同的预测。对于每个箱子，二者都预测一个常数值。因为每个箱子内的特征是不变的，所以对于一个箱子内的所有点，任何模型都会预测相同的值。</p><p>比较对特征进行分箱前后模型学到的内容，我们发现，线性模型变得更加灵活了，因为现在它对每个箱子具有不同的取值，而决策树模型的灵活性降低了。分箱特征对基于树的模型通常不会产生更好的效果，因为这种模型可以学习在任何位置划分数据。从某种意义上来看，决策树可以学习如何分箱对预测这些数据最为有用。此外，决策树可以同时查看多个特征，而分箱通常针对的是单个特征。不过，线性模型的表现力在数据变换后得到了极大的提高。</p><p><strong>对于特定的数据集，如果有充分的理由使用线性模型——比如数据集很大、维度很高，但有些特征与输出的关系是非线性的——那么分箱是提高建模能力的好方法。</strong></p><h1 id="交互特征与多项式特征">交互特征与多项式特征</h1><p>想要丰富特征表示，特别是对于线性模型而言，另一种方法是添加原始数据的<strong>交互特征</strong>（interaction feature）和<strong>多项式特征</strong>（polynomial feature）。这种特征工程通常用于统计建模，但也常用于许多实际的机器学习应用中。</p><p>线性模型对 wave 数据集中的每个箱子都学到一个常数值。但我们知道，线性模型不仅可以学习偏移，还可以学习斜率。想要向分箱数据上的线性模型添加斜率，一种方法是重新加入原始特征。这样会得到 11 维的数据集。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_combined = np.hstack([X, X_binned])</span><br><span class="line">print(<span class="string">'X_combined.shape: &#123;&#125;'</span>.format(X_combined.shape))</span><br><span class="line"></span><br><span class="line">line_combined = np.hstack([line, line_binned])</span><br><span class="line">reg = LinearRegression().fit(X_combined, y)</span><br><span class="line">plt.plot(line, reg.predict(line_combined), label=<span class="string">'linear regression combined'</span>)</span><br><span class="line">plt.plot(X[:, <span class="number">0</span>], y, <span class="string">'o'</span>, c=<span class="string">'k'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> bin <span class="keyword">in</span> bins:</span><br><span class="line">    plt.plot([bin, bin], [<span class="number">-3</span>, <span class="number">3</span>], <span class="string">':'</span>, c=<span class="string">'k'</span>)</span><br><span class="line">plt.legend(loc=<span class="string">'best'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Regresson output'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Input feature'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X_combined.shape: (100, 11)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/linear-regression-combined-on-binned-data.png"></p><p>在这个例子中，模型在每个箱子中都学到一个偏移，还学到一个斜率。学到的斜率在所有箱子中都相同——只有一个 x 轴特征，也就只有一个斜率。因为斜率在所有箱子中是相同的，所以它似乎不是很有用。我们更希望每个箱子都有一个不同的斜率。为了实现这一点，我们可以添加交互特征或乘积特征，用来表示数据点所在箱子以及数据点在 x 轴上的位置。这个特征是箱子指示符与原始特征的乘积。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_product = np.hstack([X_binned, X * X_binned])</span><br><span class="line">print(<span class="string">'X_product.shape: &#123;&#125;'</span>.format(X_product.shape))</span><br><span class="line"></span><br><span class="line">line_product = np.hstack([line_binned, line * line_binned])</span><br><span class="line"></span><br><span class="line">reg = LinearRegression().fit(X_product, y)</span><br><span class="line">plt.plot(line, reg.predict(line_product), label=<span class="string">'linear regression product'</span>)</span><br><span class="line">plt.plot(X[:, <span class="number">0</span>], y, <span class="string">'o'</span>, c=<span class="string">'k'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> bin <span class="keyword">in</span> bins:</span><br><span class="line">    plt.plot([bin, bin], [<span class="number">-3</span>, <span class="number">3</span>], <span class="string">':'</span>, c=<span class="string">'k'</span>)</span><br><span class="line">plt.legend(loc=<span class="string">'best'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Regresson output'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Input feature'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X_product.shape: (100, 20)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/linear-regression-product-on-binned-data.png"></p><p>这个数据集有20个特征：数据点所在箱子的指示符（10 个特征）与原始特征和箱子指示符的乘积（10 个特征）。你可以将乘积特征看作每个箱子 x 轴特征的单独副本。它在箱子内等于原始特征，在其他位置等于零。现在这个模型中，每个箱子都有自己的偏移和斜率。</p><p>使用分箱是扩展连续特征的一种方法。另一种方法是使用原始特征的<strong>多项式</strong>（polynomial）。对于给定特征 x，我们可以考虑 x ** 2、x ** 3、x ** 4，等等。这在 preprocessing 模块的 PolynomialFeatures 中实现。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.preprocessing.polynomialfeatures#sklearn.preprocessing.PolynomialFeatures" target="_blank" rel="noopener"><code>class sklearn.preprocessing.PolynomialFeatures(degree=2, interaction_only=False, include_bias=True)</code></a></p><p>Generate polynomial and interaction features.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 包含直到x ** 10的多项式</span></span><br><span class="line"><span class="comment"># 默认的"include_bias=True"添加恒等于1的常数特征</span></span><br><span class="line">poly = PolynomialFeatures(degree=<span class="number">10</span>, include_bias=<span class="literal">False</span>)</span><br><span class="line">poly.fit(X)</span><br><span class="line">X_poly = poly.transform(X)</span><br><span class="line">print(<span class="string">"X_poly.shape: &#123;&#125;"</span>.format(X_poly.shape))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较X_poly和X的元素</span></span><br><span class="line">print(<span class="string">'Entries of X:\n'</span>, X[:<span class="number">5</span>])</span><br><span class="line">print(<span class="string">'Entries of X_poly:\n'</span>, X_poly[:<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以通过调用get_feature_names方法来获取特征的语义，给出每个特征的指数</span></span><br><span class="line">print(<span class="string">'Polynomial feature names:\n'</span>, poly.get_feature_names())</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X_poly.shape: (100, 10)</span><br><span class="line">Entries of X:</span><br><span class="line"> [[-0.75275929]</span><br><span class="line"> [ 2.70428584]</span><br><span class="line"> [ 1.39196365]</span><br><span class="line"> [ 0.59195091]</span><br><span class="line"> [-2.06388816]]</span><br><span class="line">Entries of X_poly:</span><br><span class="line"> [[-7.52759287e-01  5.66646544e-01 -4.26548448e-01  3.21088306e-01</span><br><span class="line">  -2.41702204e-01  1.81943579e-01 -1.36959719e-01  1.03097700e-01</span><br><span class="line">  -7.76077513e-02  5.84199555e-02]</span><br><span class="line"> [ 2.70428584e+00  7.31316190e+00  1.97768801e+01  5.34823369e+01</span><br><span class="line">   1.44631526e+02  3.91124988e+02  1.05771377e+03  2.86036036e+03</span><br><span class="line">   7.73523202e+03  2.09182784e+04]</span><br><span class="line"> [ 1.39196365e+00  1.93756281e+00  2.69701700e+00  3.75414962e+00</span><br><span class="line">   5.22563982e+00  7.27390068e+00  1.01250053e+01  1.40936394e+01</span><br><span class="line">   1.96178338e+01  2.73073115e+01]</span><br><span class="line"> [ 5.91950905e-01  3.50405874e-01  2.07423074e-01  1.22784277e-01</span><br><span class="line">   7.26822637e-02  4.30243318e-02  2.54682921e-02  1.50759786e-02</span><br><span class="line">   8.92423917e-03  5.28271146e-03]</span><br><span class="line"> [-2.06388816e+00  4.25963433e+00 -8.79140884e+00  1.81444846e+01</span><br><span class="line">  -3.74481869e+01  7.72888694e+01 -1.59515582e+02  3.29222321e+02</span><br><span class="line">  -6.79478050e+02  1.40236670e+03]]</span><br><span class="line">Polynomial feature names:</span><br><span class="line"> [&apos;x0&apos;, &apos;x0^2&apos;, &apos;x0^3&apos;, &apos;x0^4&apos;, &apos;x0^5&apos;, &apos;x0^6&apos;, &apos;x0^7&apos;, &apos;x0^8&apos;, &apos;x0^9&apos;, &apos;x0^10&apos;]</span><br></pre></td></tr></table></figure><p>X_poly 的第一列与 X 完全对应，而其他列则是第一列的幂。将多项式特征与线性回归模型一起使用，可以得到经典的<strong>多项式回归</strong>（polynomial regression）模型。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">line_poly = poly.transform(line)</span><br><span class="line"></span><br><span class="line">reg = LinearRegression().fit(X_poly, y)</span><br><span class="line">plt.plot(line, reg.predict(line_poly), label=<span class="string">'polynomial linear regression'</span>)</span><br><span class="line">plt.plot(X[:, <span class="number">0</span>], y, <span class="string">'o'</span>, c=<span class="string">'k'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Regression output'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Input feature'</span>)</span><br><span class="line">plt.legend(loc=<span class="string">'best'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/polynomial-linear-regression.png"></p><p>多项式特征在这个一维数据上得到了非常平滑的拟合。但高次多项式在边界上或数据很少的区域可能有极端的表现。作为对比，下面是在原始数据上学到的核 SVM 模型，没有做任何变换。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVR</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> gamma <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">10</span>]:</span><br><span class="line">    svr = SVR(gamma=gamma).fit(X, y)</span><br><span class="line">    plt.plot(line, svr.predict(line), label=<span class="string">'SVR gamma=&#123;&#125;'</span>.format(gamma))</span><br><span class="line"></span><br><span class="line">plt.plot(X[:, <span class="number">0</span>], y, <span class="string">'o'</span>, c=<span class="string">'k'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Regression output'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Input feature'</span>)</span><br><span class="line">plt.legend(loc=<span class="string">'best'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/svr-on-source-data.png"></p><p>使用更复杂的模型（即核 SVM），我们能够学到一个与多项式回归的复杂度类似的预测结果，且不需要进行显示的特征变换。</p><p>我们再次观察波士顿房价数据集，作为对交互特征和多项式特征更加实际的应用。现在来看一下这些特征的构造方式，以及多项式特征的帮助有多大。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">boston = load_boston()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">    boston.data, boston.target, random_state=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 缩放数据</span></span><br><span class="line">scaler = MinMaxScaler()</span><br><span class="line">X_train_scaled = scaler.fit_transform(X_train)</span><br><span class="line">X_test_scaled = scaler.fit_transform(X_test)</span><br><span class="line"><span class="comment"># 提取多项式特征和交互特征，次数最高为 2</span></span><br><span class="line">poly = PolynomialFeatures(degree=<span class="number">2</span>).fit(X_train_scaled)</span><br><span class="line">X_train_poly = poly.transform(X_train_scaled)</span><br><span class="line">X_test_poly = poly.transform(X_test_scaled)</span><br><span class="line">print(<span class="string">'X_train.shape: &#123;&#125;'</span>.format(X_train.shape))</span><br><span class="line">print(<span class="string">'X_train_poly.shape: &#123;&#125;'</span>.format(X_train_poly.shape))</span><br><span class="line"><span class="comment"># 利用get_feature_names得到输入特征和输出特征之间的确切关系</span></span><br><span class="line">print(<span class="string">'Polynomial feature names:\n'</span>, poly.get_feature_names())</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X_train.shape: (379, 13)</span><br><span class="line">X_train_poly.shape: (379, 105)</span><br><span class="line">Polynomial feature names:</span><br><span class="line"> [&apos;1&apos;, &apos;x0&apos;, &apos;x1&apos;, &apos;x2&apos;, &apos;x3&apos;, &apos;x4&apos;, &apos;x5&apos;, &apos;x6&apos;, &apos;x7&apos;, &apos;x8&apos;, &apos;x9&apos;, &apos;x10&apos;, &apos;x11&apos;, &apos;x12&apos;, &apos;x0^2&apos;, &apos;x0 x1&apos;, &apos;x0 x2&apos;, &apos;x0 x3&apos;, &apos;x0 x4&apos;, &apos;x0 x5&apos;, &apos;x0 x6&apos;, &apos;x0 x7&apos;, &apos;x0 x8&apos;, &apos;x0 x9&apos;, &apos;x0 x10&apos;, &apos;x0 x11&apos;, &apos;x0 x12&apos;, &apos;x1^2&apos;, &apos;x1 x2&apos;, &apos;x1 x3&apos;, &apos;x1 x4&apos;, &apos;x1 x5&apos;, &apos;x1 x6&apos;, &apos;x1 x7&apos;, &apos;x1 x8&apos;, &apos;x1 x9&apos;, &apos;x1 x10&apos;, &apos;x1 x11&apos;, &apos;x1 x12&apos;, &apos;x2^2&apos;, &apos;x2 x3&apos;, &apos;x2 x4&apos;, &apos;x2 x5&apos;, &apos;x2 x6&apos;, &apos;x2 x7&apos;, &apos;x2 x8&apos;, &apos;x2 x9&apos;, &apos;x2 x10&apos;, &apos;x2 x11&apos;, &apos;x2 x12&apos;, &apos;x3^2&apos;, &apos;x3 x4&apos;, &apos;x3 x5&apos;, &apos;x3 x6&apos;, &apos;x3 x7&apos;, &apos;x3 x8&apos;, &apos;x3 x9&apos;, &apos;x3 x10&apos;, &apos;x3 x11&apos;, &apos;x3 x12&apos;, &apos;x4^2&apos;, &apos;x4 x5&apos;, &apos;x4 x6&apos;, &apos;x4 x7&apos;, &apos;x4 x8&apos;, &apos;x4 x9&apos;, &apos;x4 x10&apos;, &apos;x4 x11&apos;, &apos;x4 x12&apos;, &apos;x5^2&apos;, &apos;x5 x6&apos;, &apos;x5 x7&apos;, &apos;x5 x8&apos;, &apos;x5 x9&apos;, &apos;x5 x10&apos;, &apos;x5 x11&apos;, &apos;x5 x12&apos;, &apos;x6^2&apos;, &apos;x6 x7&apos;, &apos;x6 x8&apos;, &apos;x6 x9&apos;, &apos;x6 x10&apos;, &apos;x6 x11&apos;, &apos;x6 x12&apos;, &apos;x7^2&apos;, &apos;x7 x8&apos;, &apos;x7 x9&apos;, &apos;x7 x10&apos;, &apos;x7 x11&apos;, &apos;x7 x12&apos;, &apos;x8^2&apos;, &apos;x8 x9&apos;, &apos;x8 x10&apos;, &apos;x8 x11&apos;, &apos;x8 x12&apos;, &apos;x9^2&apos;, &apos;x9 x10&apos;, &apos;x9 x11&apos;, &apos;x9 x12&apos;, &apos;x10^2&apos;, &apos;x10 x11&apos;, &apos;x10 x12&apos;, &apos;x11^2&apos;, &apos;x11 x12&apos;, &apos;x12^2&apos;]</span><br></pre></td></tr></table></figure><p>原始数据有 13 个特征，现在被扩展到 105 个交互特征。这些新特征表示两个不同的原始特征之间所有可能的交互项，以及每个原始特征的平方。第一个新特征是常数特征，这里的名称是 &quot;1&quot;。接下来的 13 个特征是原始特征（&quot;x0&quot; 到 &quot;x12&quot;）。然后是第一个特征的平方（&quot;x0^2&quot;）以及它与其他特征的组合。</p><p>我们对 Ridge 在有交互特征的数据集上和没有交互特征的数据集上的性能进行比较。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ridge = Ridge().fit(X_train_scaled, y_train)</span><br><span class="line">print(<span class="string">'Score without interactions: &#123;:.3f&#125;'</span>.format(ridge.score(X_test_scaled, y_test)))</span><br><span class="line">ridge = Ridge().fit(X_train_poly, y_train)</span><br><span class="line">print(<span class="string">'Score with interactions: &#123;:.3f&#125;'</span>.format(ridge.score(X_test_poly, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Score without interactions: 0.577</span><br><span class="line">Score with interactions: 0.741</span><br></pre></td></tr></table></figure><p>显然，在使用 Ridge 时，交互特征和多项式特征对性能有很大的提升。但如果使用更加复杂的模型（比如随机森林），情况会稍有不同。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rf = RandomForestRegressor(n_estimators=<span class="number">100</span>).fit(X_train_scaled, y_train)</span><br><span class="line">print(<span class="string">'Score without interactions: &#123;:.3f&#125;'</span>.format(rf.score(X_test_scaled, y_test)))</span><br><span class="line">rf = RandomForestRegressor(n_estimators=<span class="number">100</span>).fit(X_train_poly, y_train)</span><br><span class="line">print(<span class="string">'Score with interactions: &#123;:.3f&#125;'</span>.format(rf.score(X_test_poly, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Score without interactions: 0.780</span><br><span class="line">Score with interactions: 0.755</span><br></pre></td></tr></table></figure><p>你可以看到，即使没有额外的特征，随机森林的性能也要优于 Ridge。添加交互特征和多项式特征实际上会略微降低其性能。</p><h1 id="单变量非线性变换">单变量非线性变换</h1><p>我们刚刚看到，<strong>添加特征的平方或立方可以改进线性回归模型</strong>。其他变换通常也对变换某些特征有用，特别是应用数学函数，比如 log、exp 或 sin。虽然基于树的模型只关注特征的顺序，但线性模型和神经网络依赖于每个特征的尺度和分布。如果在特征和目标之间存在非线性关系，那么建模就变得非常困难，特别是对于回归问题。log 和 exp 函数可以帮助调节数据的相对比例，从而改进线性模型或神经网络的学习效果。我们在第 2 章中对内存价格数据应用过这种函数。在处理具有周期性模式的数据时，sin 和 cos 函数非常有用。</p><p>大部分模型都在每个特征（在回归问题中还包括目标值）大致遵循高斯分布时表现最好，也就是说，每个特征的直方图应该具有类似于“钟形曲线”的形状。使用诸如 log 和 exp 之类的变换并不稀奇，却却是实现这一点的简单又有效的方法。在一种特别常见的情况下，这样的变换非常有用，就是处理整数计数数据时。计数数据是指类似“用户A多长时间登陆一次？”这样的特征。计数不可能取负值，并且通常遵循特定的统计模式。特征全都是整数值，而响应是连续的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rnd = np.random.RandomState(<span class="number">0</span>)</span><br><span class="line">X_org = rnd.normal(size=(<span class="number">1000</span>, <span class="number">3</span>))</span><br><span class="line">w = rnd.normal(size=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">X = rnd.poisson(<span class="number">10</span> * np.exp(X_org))</span><br><span class="line">y = np.dot(X_org, w)</span><br><span class="line"></span><br><span class="line">print(X[:<span class="number">10</span>, <span class="number">0</span>])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ 56  81  25  20  27  18  12  21 109   7]</span><br></pre></td></tr></table></figure><p>第一个特征的前 10 个元素都是正整数，但除此之外很难找出特定的模式。如果我们计算每个值的出现次数，那么数值的分布将变得更清楚。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'Number of feature appearances:\n'</span>, np.bincount(X[:, <span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">bins = np.bincount(X[:, <span class="number">0</span>])</span><br><span class="line">plt.bar(range(len(bins)), bins, color=<span class="string">'gray'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Number of appearances'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Value'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Number of feature appearances:</span><br><span class="line"> [28 38 68 48 61 59 45 56 37 40 35 34 36 26 23 26 27 21 23 23 18 21 10  9</span><br><span class="line"> 17  9  7 14 12  7  3  8  4  5  5  3  4  2  4  1  1  3  2  5  3  8  2  5</span><br><span class="line">  2  1  2  3  3  2  2  3  3  0  1  2  1  0  0  3  1  0  0  0  1  3  0  1</span><br><span class="line">  0  2  0  1  1  0  0  0  0  1  0  0  2  2  0  1  1  0  0  0  0  1  1  0</span><br><span class="line">  0  0  0  0  0  0  1  0  0  0  0  0  1  1  0  0  1  0  0  0  0  0  0  0</span><br><span class="line">  1  0  0  0  0  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1]</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/appearances-count-of-poisson.png"></p><p>特征 <code>X[:, 1]</code> 和 <code>X[:, 2]</code> 具有类似的性质。这种类型的数值分布（泊松分布）在实践中非常常见。但多数线性模型无法很好地处理这种数据。我们尝试拟合一个岭回归模型。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=<span class="number">0</span>)</span><br><span class="line">score = Ridge().fit(X_train, y_train).score(X_test, y_test)</span><br><span class="line">print(<span class="string">'Test score: &#123;:.3f&#125;'</span>.format(score))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test score: 0.622</span><br></pre></td></tr></table></figure><p>从相对较小的分数中可以看出，Ridge 无法真正捕捉到 X 和 y 之间的关系。不过应用对数变换可能有用。由于数据取值中包括 0（对数在 0 处没有定义），所以我们不能直接应用 log，而是要计算 log(X + 1)。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_train_log = np.log(X_train + <span class="number">1</span>)</span><br><span class="line">X_test_log = np.log(X_test + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">plt.hist(X_train_log[:, <span class="number">0</span>], bins=<span class="number">25</span>, color=<span class="string">'gray'</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Number of apperances"</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Value"</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/appearances-count-of-log-poisson.png"></p><p>在新数据上构建一个岭回归模型，可以得到更好地拟合。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">score = Ridge().fit(X_train_log, y_train).score(X_test_log, y_test)</span><br><span class="line">print(<span class="string">'Test score: &#123;:.3f&#125;'</span>.format(score))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test score: 0.875</span><br></pre></td></tr></table></figure><p>在这个例子中，所有特征都具有相同的性质，这在实践中是非常少见的情况。通常来说，只有一部分特征应该进行变换，有时每个特征的变换方式也各不相同。前面提到过，<strong>对基于树的模型而言，这种变换并不重要，但对线性模型来说可能至关重要。</strong>最回归的目标变量 y 进行变换有时也是一个好主意。尝试预计计数（比如订单数量）是一项相当常见的任务，而且使用 log(y + 1) 变换也往往有用。</p><p>分箱、多项式和交互项都对模型在给定数据集上的性能有很大影响，对于复杂度低的模型更是这样，比如线性模型和朴素贝叶斯模型。与之相反，基于树的模型通常能够自己发现重要的交互项，大多数情况下不需要显示地变换数据。其他模型，比如 SVM、最近邻和神经网络，有时可能会从分箱、交互项或多项式中受益，但其效果通常不如线性模型那么明显。</p><h1 id="自动化特征选择">自动化特征选择</h1><p>有了这么多种创建新特征的方法，你可能会想要增大数据的维度，使其远大于原始特征的数量。但是，添加更多特征会使所有模型变得更加复杂，从而增大过拟合的可能性。在添加新特征或处理一般的高纬度数据集时，最好将特征的数量减少到只包含最有用的那些特征，并删除其余特征。这样会得到泛化能力更好、更简单的模型。但你如何判断每个特征的作用有多大呢？有三种基本的策略：<strong>单变量统计</strong>（univariate statistics）、<strong>基于模型的选择</strong>（model-based selection）和<strong>迭代选择</strong>（iterative selection）。所有这些方法都是监督方法，即它们需要目标值来拟合模型。</p><h2 id="单变量统计">单变量统计</h2><p>在单变量统计中，我们计算每个特征和目标值之间的关系是否存在统计显著性，然后选择具有最高置信度的特征。对于分类问题，这也被称为<strong>方差分析</strong>（analysis of variance，ANOVA）。这些测试的一个关键性质就是它们是<strong>单变量的</strong>（univariate），即它们只单独考虑每个特征。因此，如果一个特征只有在与另一个特征合并时才具有信息量，那么这个特征将被舍弃。单变量测试的计算速度通常很快，并且不需要构建模型。另一方面，它们完全独立于你可能想要在特征选择之后应用的模型。</p><p>想要在 scikit-learn 中使用单变量特征选择，你需要选择一项测试——对分类问题通常是 f_classif（默认值），对回归问题通常是 f_regression——然后基于测试中确定的 p 值来选择一种舍弃特征的方法。所有舍弃参数的方法都使用阈值来舍弃所有 p 值过大的特征（意味着它们不可能与目标值相关）。计算阈值的方法各有不同，最简单的是 SelectKBest 和 SelectPercentile，前者选择固定数量的 k 个特征，后者选择固定百分比的特征。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.feature_selection.selectkbest#sklearn.feature_selection.SelectKBest" target="_blank" rel="noopener"><code>class sklearn.feature_selection.SelectKBest(score_func=&lt;function f_classif&gt;, k=10)</code></a></p><p>Select features according to the k highest scores.</p><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.feature_selection.selectpercentile#sklearn.feature_selection.SelectPercentile" target="_blank" rel="noopener"><code>class sklearn.feature_selection.SelectPercentile(score_func=&lt;function f_classif&gt;, percentile=10)</code></a></p><p>Select features according to a percentile of the highest scores.</p></blockquote><p>我们将分类的特征选择应用于 cancer 数据集。为了使任务更难一点，我们将向数据中添加一些没有信息量的噪声特征。我们期望特征选择能够识别没有信息量的特征并删除它们。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectPercentile</span><br><span class="line"></span><br><span class="line">cancer = load_breast_cancer()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得确定性的随机数</span></span><br><span class="line">rng = np.random.RandomState(<span class="number">42</span>)</span><br><span class="line">noise = rng.normal(size=(len(cancer.data), <span class="number">50</span>))</span><br><span class="line"><span class="comment"># 向数据中添加噪声特征</span></span><br><span class="line"><span class="comment"># 前30个特征来自数据集，后50个是噪声</span></span><br><span class="line">X_w_noise = np.hstack([cancer.data, noise])</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">    X_w_noise, cancer.target, random_state=<span class="number">0</span>, test_size=<span class="number">.5</span>)</span><br><span class="line"><span class="comment"># 使用f_classif（默认值）和SelectPercentile来选择50%的特征</span></span><br><span class="line">select = SelectPercentile(percentile=<span class="number">50</span>)</span><br><span class="line">select.fit(X_train, y_train)</span><br><span class="line"><span class="comment"># 对训练集进行变换</span></span><br><span class="line">X_train_selected = select.transform(X_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'X_train.shape:'</span>, X_train.shape)</span><br><span class="line">print(<span class="string">'X_train_selected.shape:'</span>, X_train_selected.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用get_support方法来查看那哪些特征被选中，它会返回所选特征的布尔遮罩（mask）</span></span><br><span class="line">mask = select.get_support()</span><br><span class="line">print(mask)</span><br><span class="line"><span class="comment"># 将遮罩可视化——黑色为True，白色为False</span></span><br><span class="line">plt.matshow(mask.reshape(<span class="number">1</span>, <span class="number">-1</span>), cmap=<span class="string">'gray_r'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Sample index'</span>)</span><br><span class="line">plt.yticks([<span class="number">0</span>])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X_train.shape: (284, 80)</span><br><span class="line">X_train_selected.shape: (284, 40)</span><br><span class="line">[ True  True  True  True  True  True  True  True  True False  True False</span><br><span class="line">  True  True  True  True  True  True False False  True  True  True  True</span><br><span class="line">  True  True  True  True  True  True False False False  True False  True</span><br><span class="line"> False False  True False False False False  True False False  True False</span><br><span class="line"> False  True False  True False False False False False False  True False</span><br><span class="line">  True False False False False  True False  True False False False False</span><br><span class="line">  True  True False  True False False False False]</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/features-selected-by-selectpercentile.png"></p><p>从遮罩层的可视化中可以看出，大多数所选择的特征都是原始特征，并且大多数噪声特征都已被删除。但原始特征的还原并不完美。我们来比较 Logistic 回归在所有特征上的性能与仅使用所选特征时的性能。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对测试集进行变换</span></span><br><span class="line">X_test_selected = select.transform(X_test)</span><br><span class="line"></span><br><span class="line">lr = LogisticRegression()</span><br><span class="line">lr.fit(X_train, y_train)</span><br><span class="line">print(<span class="string">'Score with all features: &#123;:.3f&#125;'</span>.format(lr.score(X_test, y_test)))</span><br><span class="line"></span><br><span class="line">lr.fit(X_train_selected, y_train)</span><br><span class="line">print(<span class="string">'Score with only selected features: &#123;:.3f&#125;'</span>.format(lr.score(X_test_selected, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Score with all features: 0.930</span><br><span class="line">Score with only selected features: 0.940</span><br></pre></td></tr></table></figure><p>在这个例子中，删除噪声特征可以提高性能，即使丢失了某些原始特征。这是一个非常简单的假想示例，在真实数据上的结果要更加复杂。不过，如果特征量太大以至于无法构建模型，或者你怀疑许多特征完全没有信息量，那么单变量特征选择还是非常有用的。</p><h2 id="基于模型的特征选择">基于模型的特征选择</h2><p>基于模型的特征选择使用一个监督机器学习模型来判断每个特征的重要性，并且仅保留最重要的特征。用于特征选择的监督模型不需要与用于最终监督检模型的模型相同。特征选择模型需要为每个特征提供某种重要性度量，以便用这个度量对特征进行排序。决策树和基于决策树的模型提供了 feature_importances_ 属性，可以直接编码每个特征的重要性。线性模型系数的绝对值也可以用于表示特征重要性。L1 惩罚的线性模型学到的是稀疏系数，它只用到了特征的一个很小的子集。这可以被视为模型本身的一种特征选择形式，但也可以用作另一个模型选择特征的预处理步骤。与单变量选择不同，基于模型的选择同时考虑所有特征，因此可以获取交互项（如果模型能够获取它们的话）。要想使用基于模型的特征选择，我们需要使用 SelectFromModel 变换器。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.feature_selection.selectfrommodel#sklearn.feature_selection.SelectFromModel" target="_blank" rel="noopener"><code>class sklearn.feature_selection.SelectFromModel(estimator, threshold=None, prefit=False, norm_order=1, max_features=None)</code></a></p><p>Meta-transformer for selecting features based on importance weights.</p></blockquote><p>SelectFromModel类选出重要性度量（由监督模型提供）大于给定阈值的所有特征。我们用包含 100 棵树的随机森林分类器来计算特征重要性。这是一个相当复杂的模型，也比单变量测试要强大得多。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectFromModel</span><br><span class="line"></span><br><span class="line">select = SelectFromModel(</span><br><span class="line">    RandomForestClassifier(n_estimators=<span class="number">100</span>, random_state=<span class="number">42</span>),</span><br><span class="line">    threshold=<span class="string">'median'</span>)</span><br><span class="line"></span><br><span class="line">select.fit(X_train, y_train)</span><br><span class="line">X_train_l1 = select.transform(X_train)</span><br><span class="line">print(<span class="string">'X_train.shape:'</span>, X_train.shape)</span><br><span class="line">print(<span class="string">'X_train_l1.shape:'</span>, X_train_l1.shape)</span><br><span class="line"></span><br><span class="line">X_test_l1 = select.transform(X_test)</span><br><span class="line">score = LogisticRegression().fit(X_train_l1, y_train).score(X_test_l1, y_test)</span><br><span class="line">print(<span class="string">'Test score: &#123;:.3f&#125;'</span>.format(score))</span><br><span class="line"></span><br><span class="line">mask = select.get_support()</span><br><span class="line">plt.matshow(mask.reshape(<span class="number">1</span>, <span class="number">-1</span>), cmap=<span class="string">'gray_r'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Sample index'</span>)</span><br><span class="line">plt.yticks([<span class="number">0</span>])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X_train.shape: (284, 80)</span><br><span class="line">X_train_l1.shape: (284, 40)</span><br><span class="line">Test score: 0.951</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/features-selected-by-selectfrommodel.png"></p><h2 id="迭代特征选择">迭代特征选择</h2><p>在单变量测试中，我们没有使用模型，而在基于模型的选择中，我们使用了单个模型来选择特征。在迭代特征选择中，将会构建一系列模型，每个模型都使用不同数量的特征。有两种基本方法：开始时没有特征，然后逐个添加特征，直到满足某个终止条件；或者从所有特征开始，然后逐个删除特征，直到满足某个终止条件。由于构建了一系列模型，所以这些方法的计算成本要比前面的方法更高。其中一种特殊的方法是<strong>递归特征消除</strong>（recursive feature elimination，RFE），它从所有特征开始构建模型，并根据模型舍弃最不重要的特征，然后使用剩余特征来构建一个新模型，如此继续，直到仅剩下预设数量的特征。为了让这种方法能够运行，用于选择的模型需要提供某种确定特征重要性的方法，正如基于模型的选择所做的那样。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.feature_selection.rfe#sklearn.feature_selection.RFE" target="_blank" rel="noopener"><code>class sklearn.feature_selection.RFE(estimator, n_features_to_select=None, step=1, verbose=0)</code></a></p><p>Feature ranking with recursive feature elimination.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> RFE</span><br><span class="line"></span><br><span class="line">select = RFE(RandomForestClassifier(n_estimators=<span class="number">100</span>, random_state=<span class="number">42</span>),</span><br><span class="line">    n_features_to_select=<span class="number">40</span>)</span><br><span class="line">select.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">mask = select.get_support()</span><br><span class="line">plt.matshow(mask.reshape(<span class="number">1</span>, <span class="number">-1</span>), cmap=<span class="string">'gray_r'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Sample index'</span>)</span><br><span class="line">plt.yticks([<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/features-selected-by-rfe.png"></p><p>与单变量选择和基于模型的选择相比，迭代特征选择的结果更好，但仍然漏掉了一个特征。运行上述代码需要的时间也比基于模型的选择要长得多，因为对一个随机森林模型训练了 40 次，每运行一次删除一个特含。我们来测试一下使用 RFE 做特征选择时 Logistic 回归模型的精度。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">score = LogisticRegression().fit(X_train_rfe, y_train).score(X_test_rfe, y_test)</span><br><span class="line">print(<span class="string">'Test score: &#123;:.3f&#125;'</span>.format(score))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test score: 0.951</span><br></pre></td></tr></table></figure><p>我们还可以利用在 RFE 内使用的模型来进行预测。这仅使用被选择的特征集。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'Test score: &#123;:.3f&#125;'</span>.format(select.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test score: 0.951</span><br></pre></td></tr></table></figure><p>这里，在 RFE 内部使用的随机森林的性能，与在所选特征上训练一个 Logistic 回归模型得到的性能相同。换句话说，只要我们选择了正确的特征，线性模型的表现就与随机森林一样好。</p><p>如果你不确定何时选择使用哪些特征作为机器学习算法的输入，那么自动化特征选择可能特别有用。它还有助于减少所需要的特征数量，加快预测速度，或允许可解释性更强的模型。在大多数现实情况下，使用特征选择不太可能大幅提升性能，但它仍是特征工程工具箱中一个非常有价值的工具。</p><h1 id="利用专家知识">利用专家知识</h1><p>对于特定应用来说，在特征工程中通常可以利用<strong>专家知识</strong>（expert knowledge）。虽然在许多情况下，机器学习的目的是避免创建一组专家设计的规则，但这并不意味着应该舍弃该应用或该领域的先验知识。通常来说，领域专家可以帮助找出有用的特征，其信息量比数据原始表示要大得多。</p><p>下面我们来看一个利用专家知识的特例。任务是预测在 Andreas 家门口的自行车出租。我们想要解决的任务是，对于给定的日期和时间，预测有多少人将会在 Andreas 的家门口租一辆自行车——这样他就知道是否还有自行车留给他。</p><p>我们首先将 2015 年 8 月的数据加载为一个 pandas 数据框。我们将数据重新采样为每 3 个小时一个数据，以得到每一天的主要趋势：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">citibike = mglearn.datasets.load_citibike()</span><br><span class="line">print(<span class="string">'Citi Bike data:\n'</span>, citibike.head())</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">3</span>))</span><br><span class="line">xticks = pd.date_range(start=citibike.index.min(), end=citibike.index.max(), freq=<span class="string">'D'</span>)</span><br><span class="line">plt.xticks(xticks, xticks.strftime(<span class="string">'%a %m-%d'</span>), rotation=<span class="number">90</span>, ha=<span class="string">'left'</span>)</span><br><span class="line">plt.plot(citibike, linewidth=<span class="number">1</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Data'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Rentals'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Citi Bike data:</span><br><span class="line"> starttime</span><br><span class="line">2015-08-01 00:00:00     3</span><br><span class="line">2015-08-01 03:00:00     0</span><br><span class="line">2015-08-01 06:00:00     9</span><br><span class="line">2015-08-01 09:00:00    41</span><br><span class="line">2015-08-01 12:00:00    39</span><br><span class="line">Freq: 3H, Name: one, dtype: int64</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/datasets-citibike.png"></p><p>观察此数据，我们可以清楚地区分每 24 小时中的白天和夜间。工作日和周末的模式似乎也有很大不同。在对这种时间序列上的预测任务进行评估时，我们通常希望<strong>从过去学习</strong>并<strong>预测未来</strong>。也就是说，在划分训练集和测试集的时候，我们希望使用某个特定日期之前的所有数据作为训练集，该日期之后的所有数据作为测试集。我们将使用前 184 个数据点（对应前 23 天）作为训练集，剩余的 64 个数据点（对应剩余的 8 天）作为测试集。</p><p>在我们的预测任务中，我们使用的唯一特征就是某一租车数量对应的日期和时间。因此输入特征是日期和时间，比如 2014-08-01 00:00:00，而输出是在接下来 3 小时内的租车数量（在这个例子中是 3）。</p><p>在计算机上存储日期的常用方式是使用 POSIX 时间，它是从 1970 年 1 月 1 日 00:00:00（也就是 Unix 时间的起点）起至现在的总秒数。首先，我们可以尝试使用这个单一整数特征作为数据表示。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提取目标值</span></span><br><span class="line">y = citibike.values</span><br><span class="line"><span class="comment"># 利用"%s"将时间转换为POSIX时间</span></span><br><span class="line">X = np.reshape(citibike.index.strftime(<span class="string">"%s"</span>).astype(<span class="string">"int"</span>), (<span class="number">-1</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，它可以将数据划分为训练集和测试集，构建模型并将结果可视化</span></span><br><span class="line">n_train = <span class="number">184</span>  <span class="comment"># 使用前184个数据点用于训练，剩余的数据点用于测试</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对给定特征集上的回归进行评估和作图的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval_on_features</span><span class="params">(features, target, regressor)</span>:</span></span><br><span class="line">    <span class="comment"># 将给定特征划分为训练集和测试集</span></span><br><span class="line">    X_train, X_test = features[:n_train], features[n_train:]</span><br><span class="line">    <span class="comment"># 同样划分目标数组</span></span><br><span class="line">    y_train, y_test = target[:n_train], target[n_train:]</span><br><span class="line">    regressor.fit(X_train, y_train)</span><br><span class="line">    print(<span class="string">'Test-set R^2: &#123;:.2f&#125;'</span>.format(regressor.score(X_test, y_test)))</span><br><span class="line"></span><br><span class="line">    y_pred = regressor.predict(X_test)</span><br><span class="line">    y_pred_train = regressor.predict(X_train)</span><br><span class="line">    plt.figure(figsize=(<span class="number">10</span>, <span class="number">3</span>))</span><br><span class="line">    plt.xticks(range(<span class="number">0</span>, len(X), <span class="number">8</span>), xticks.strftime(<span class="string">'%a %m-%d'</span>), rotation=<span class="number">90</span>, ha=<span class="string">'left'</span>)</span><br><span class="line">    plt.plot(range(n_train), y_train, label=<span class="string">'train'</span>)</span><br><span class="line">    plt.plot(range(n_train, len(y_test) + n_train), y_test, <span class="string">'-'</span>, label=<span class="string">'test'</span>)</span><br><span class="line"></span><br><span class="line">    plt.plot(range(n_train), y_pred_train, <span class="string">'--'</span>, label=<span class="string">'prediction train'</span>)</span><br><span class="line">    plt.plot(range(n_train, len(y_test) + n_train), y_pred, <span class="string">'--'</span>, label=<span class="string">'prediction test'</span>)</span><br><span class="line">    plt.legend(loc=(<span class="number">1.01</span>, <span class="number">0</span>))</span><br><span class="line">    plt.xlabel(<span class="string">'Date'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'Rentals'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用随机森林回归</span></span><br><span class="line">regressor = RandomForestRegressor(n_estimators=<span class="number">100</span>, random_state=<span class="number">0</span>)</span><br><span class="line">eval_on_features(X, y, regressor)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test-set R^2: -0.04</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/random-forest-on-citibike.png"></p><p>在训练集上的预测结果相当好，这符合随机森林通常的表现。但对于测试集来说，预测结果是一条常数直线。<span class="math inline">\(R^2\)</span>为 -0.04，说明我们什么都没有学到。发生了什么？</p><p>问题在于特征和随机森林的组合。测试集中 POSIX 时间特征的值超出了训练集中特征取值的范围：测试集中数据点的时间戳要晚于训练集中的所有数据点。树以及随机森林无法<strong>外推</strong>（extrapolate）到训练集之外的特征范围。结果就是模型只能预测训练集中最近数据点的目标值，即最后一次观测到数据的时间。</p><p>显然，我们可以做到更好。这就是我们的“专家知识”的用武之地。通过观察训练数据中的租车数量图像，我们发现两个因素似乎非常重要：一天内的时间与一周的星期几。因此我们来添加这两个特征。我们从 POSIX 时间中学不到任何东西，所以删掉这个特征。首先，我们仅使用每天的时刻。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_hour = np.reshape(citibike.index.hour, (<span class="number">-1</span>, <span class="number">1</span>))</span><br><span class="line">eval_on_features(X_hour, y, regressor)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test-set R^2: 0.60</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/random-forest-on-citibike-hour.png"></p><p><span class="math inline">\(R^2\)</span> 已经好多了，但预测结果显然没有抓住每周的模式，现在的预测结果对一周内的每天都具有相同的模式。下面我们添加一周的星期几作为特征。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_hour_week = np.hstack([np.reshape(citibike.index.dayofweek, (<span class="number">-1</span>, <span class="number">1</span>)),</span><br><span class="line">                          np.reshape(citibike.index.hour, (<span class="number">-1</span>, <span class="number">1</span>))])</span><br><span class="line">eval_on_features(X_hour_week, y, regressor)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test-set R^2: 0.84</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/random-forest-on-citibike-hour-week.png"></p><p>现在我们的模型通过考虑一周的星期几和一天内的时间捕捉到了周期性的行为。它的 <span class="math inline">\(R^2\)</span> 为 0.84，预测性能相当好。模型学到的内容可能是 8 月前 23 天中星期几与时刻每种组合的平均租车数量。这实际上不需要像随机森林这样复杂的模型，所以我们尝试一个更简单的模型——LinearRegression。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">eval_on_features(X_hour_week, y, LinearRegression())</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test-set R^2: 0.13</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/linear-regression-on-citibike.png"></p><p><strong>LinearRegression 的效果差得多，而且周期性模式看起来很奇怪。其原因在于我们用整数编码一周的星期几和一天内的时间，它们被解释为连续变量。</strong>因此，线性模型只能学到关于每天时间的线性函数——它学到的是，时间越晚，租车数量越多。但实际模式比这要复杂得多。我们可以通过将整数解释为分类变量（用 OneHotEncoder 进行变换）来获得这种模式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">enc = OneHotEncoder()</span><br><span class="line">X_hour_week_onehot = enc.fit_transform(X_hour_week).toarray()</span><br><span class="line">eval_on_features(X_hour_week_onehot, y, Ridge())</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test-set R^2: 0.62</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/ridge-on-citibike.png"></p><p>它给出了比连续特征编码好得多的匹配。现在线性模型为一周内的每天都学到了一个系数，为一天内的每个时刻都学到了一个系数。也就是说，一周七天共享“一天内每个时刻”的模式。</p><p>利用交互特征，我们可以让模型为星期几和时刻的每一种组合都学到一个系数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">poly_transformer = PolynomialFeatures(degree=<span class="number">2</span>, interaction_only=<span class="literal">True</span>, include_bias=<span class="literal">False</span>)</span><br><span class="line">X_hour_week_onehot_poly = poly_transformer.fit_transform(X_hour_week_onehot)</span><br><span class="line">lr = Ridge()</span><br><span class="line">eval_on_features(X_hour_week_onehot_poly, y, lr)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test-set R^2: 0.85</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/ridge-on-citibike-poly.png"></p><p>这一变换最终得到一个性能与随机森林类似的模型。这个模型的一大优点是，可以很清楚地看到学到的内容：对每个星期几和时刻的交互项学到了一个系数。我们可以将模型学到的系数作图，而这对于随机森林来说是不可能的（随机森林也有关于特征重要性的参数 <code>feature_importances_</code>，为何不可能？）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为时刻和星期几创建名称</span></span><br><span class="line">hour = [<span class="string">'%02d:00'</span> % i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">24</span>, <span class="number">3</span>)]</span><br><span class="line">day = [<span class="string">'Mon'</span>, <span class="string">'Tue'</span>, <span class="string">'Wed'</span>, <span class="string">'Thu'</span>, <span class="string">'Fri'</span>, <span class="string">'Sat'</span>, <span class="string">'Sun'</span>]</span><br><span class="line">features = day + hour</span><br><span class="line"><span class="comment"># 利用 get_feature_names 方法对 PolynomialFeatures 提取的所有交互特征进行命名</span></span><br><span class="line">features_poly = poly_transformer.get_feature_names(features)</span><br><span class="line">features_nonzero = np.array(features_poly)[lr.coef_ != <span class="number">0</span>]</span><br><span class="line">coef_nonzero = lr.coef_[lr.coef_ != <span class="number">0</span>]</span><br><span class="line"><span class="comment"># 将线性模型学到的系数可视化</span></span><br><span class="line">plt.figure(figsize=(<span class="number">15</span>, <span class="number">2</span>))</span><br><span class="line">plt.plot(coef_nonzero, <span class="string">'o'</span>)</span><br><span class="line">plt.xticks(np.arange(len(coef_nonzero)), features_nonzero, rotation=<span class="number">90</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Feature name'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature magnitude'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/coef-of-linear-regression-on-citibike.png"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Machine Learning with Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Useful Mac Apps</title>
      <link href="/mac/useful-mac-apps/"/>
      <url>/mac/useful-mac-apps/</url>
      
        <content type="html"><![CDATA[<h1 id="装机必备">装机必备</h1><table><thead><tr class="header"><th>名称</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a></td><td>最好用的软件包管理工具</td></tr><tr class="even"><td><a href="https://theunarchiver.com/" target="_blank" rel="noopener">The Unarchiver</a></td><td>最好用的解压缩工具</td></tr><tr class="odd"><td><a href="https://freemacsoft.net/appcleaner/" target="_blank" rel="noopener">AppCleaner</a></td><td>完全卸载应用</td></tr><tr class="even"><td><a href="https://mounty.app/" target="_blank" rel="noopener">Mounty for NTFS</a></td><td>读/写NTFS格式的卷</td></tr><tr class="odd"><td><a href="https://pock.dev/" target="_blank" rel="noopener">Pock</a></td><td>自定义Touch Bar</td></tr></tbody></table><a id="more"></a><h1 id="开发工具">开发工具</h1><table><thead><tr class="header"><th>名称</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><a href="https://www.jetbrains.com/toolbox-app/" target="_blank" rel="noopener">Jetbrains Toolbox</a></td><td>轻松管理Jetbrains开发工具</td></tr><tr class="even"><td><a href="https://devdocs.io/" target="_blank" rel="noopener">devdocs</a> / <a href="https://devdocs.egoist.moe/" target="_blank" rel="noopener">DevDocs Desktop</a></td><td>免费、开源的API文档</td></tr></tbody></table><h1 id="下载工具">下载工具</h1><table><thead><tr class="header"><th>名称</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><a href="https://github.com/ytdl-org/youtube-dl" target="_blank" rel="noopener">youtube-dl</a></td><td>下载油管上的视频，命令行工具</td></tr><tr class="even"><td><a href="https://www.jihosoft.cn/tubeget/" target="_blank" rel="noopener">Gihosoft TubeGet</a></td><td>下载油管上的视频，app</td></tr><tr class="odd"><td><a href="https://www.freedownloadmanager.org/zh/" target="_blank" rel="noopener">Free Download Manager(FDM)</a></td><td>IDM的优秀替代</td></tr></tbody></table><h1 id="谷歌浏览器扩展">谷歌浏览器扩展</h1><table><thead><tr class="header"><th>名称</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><a href="https://chrome.google.com/webstore/detail/free-download-manager/ahmpjcflkgiildlgicmcieglgoilbfdp" target="_blank" rel="noopener">Free Download Manager</a></td><td>搭配FDM使用</td></tr><tr class="even"><td><a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo" target="_blank" rel="noopener">Tampermonkey</a></td><td>管理用户脚本</td></tr><tr class="odd"><td></td><td><a href="https://greasyfork.org/zh-CN/scripts/25718-%E8%A7%A3%E9%99%A4b%E7%AB%99%E5%8C%BA%E5%9F%9F%E9%99%90%E5%88%B6" target="_blank" rel="noopener">解除B站区域限制</a></td></tr><tr class="even"><td></td><td><a href="https://greasyfork.org/zh-CN/scripts/1682-google-hit-hider-by-domain-search-filter-block-sites" target="_blank" rel="noopener">Google Hit Hider by Domain (Search Filter / Block Sites)</a></td></tr><tr class="odd"><td><a href="https://chrome.google.com/webstore/detail/neteasemusicworld%2B/pjcgkmiglhiambjngnljkdpoggonlnfe" target="_blank" rel="noopener">NetEaseMusicWorld+</a></td><td>解锁网易云音乐的海外播放</td></tr><tr class="even"><td><a href="https://chrome.google.com/webstore/detail/%E5%B9%BF%E5%91%8A%E7%BB%88%E7%BB%93%E8%80%85/fpdnjdlbdmifoocedhkighhlbchbiikl" target="_blank" rel="noopener">广告终结者</a></td><td>清除网页上的所有广告</td></tr></tbody></table><h1 id="音乐视频">音乐视频</h1><table><thead><tr class="header"><th>名称</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><a href="https://iina.io/" target="_blank" rel="noopener">IINA</a></td><td>（最）好用的视频播放器</td></tr><tr class="even"><td><a href="http://deadbeatsw.com/thetagger/" target="_blank" rel="noopener">The Tagger</a></td><td>修改MP3和AAC的标签</td></tr></tbody></table><h1 id="社交">社交</h1><table><thead><tr class="header"><th>名称</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><a href="https://weiboformac.sinaapp.com/" target="_blank" rel="noopener">Maipo for Weibo</a></td><td>新浪微博的非官方客户端</td></tr><tr class="even"><td><a href="https://sparkmailapp.com/zh" target="_blank" rel="noopener">Spark</a></td><td>简单易用的邮件客户端</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> app </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>No Xcode or CLT version detected</title>
      <link href="/programming/no-xcode-or-clt-version-detected/"/>
      <url>/programming/no-xcode-or-clt-version-detected/</url>
      
        <content type="html"><![CDATA[<p>If your Mac has been upgraded to macOS Catalina (10.15), please read <a href="https://github.com/nodejs/node-gyp/blob/master/macOS_Catalina.md" target="_blank" rel="noopener">macOS_Catalina.md</a>.</p><p>解决方法：</p><p>安装所需的编译器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure><p>或重新安装</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm -rf $(xcode-select -print-path)</span><br><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sklearn bunch</title>
      <link href="/source-code/sklearn-bunch/"/>
      <url>/source-code/sklearn-bunch/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><figcaption><span>utils.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bunch</span><span class="params">(dict)</span>:</span></span><br><span class="line">    <span class="string">"""Container object for datasets</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Dictionary-like object that exposes its keys as attributes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; b = Bunch(a=1, b=2)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; b['b']</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; b.b</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; b.a = 3</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; b['a']</span></span><br><span class="line"><span class="string">    3</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; b.c = 6</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; b['c']</span></span><br><span class="line"><span class="string">    6</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        super().__init__(kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        self[key] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__dir__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.keys()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self[key]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(key)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sklearn </tag>
            
            <tag> special method </tag>
            
            <tag> dict </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cplex cutting stock</title>
      <link href="/source-code/cplex-cutting-stock/"/>
      <url>/source-code/cplex-cutting-stock/</url>
      
        <content type="html"><![CDATA[<h1 id="源码">源码</h1><figure class="highlight python"><figcaption><span>cutstock.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># File: cutstock.py</span></span><br><span class="line"><span class="comment"># Version 12.9.0</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Licensed Materials - Property of IBM</span></span><br><span class="line"><span class="comment"># 5725-A06 5725-A29 5724-Y48 5724-Y49 5724-Y54 5724-Y55 5655-Y21</span></span><br><span class="line"><span class="comment"># Copyright IBM Corporation 2009, 2019. All Rights Reserved.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># US Government Users Restricted Rights - Use, duplication or</span></span><br><span class="line"><span class="comment"># disclosure restricted by GSA ADP Schedule Contract with</span></span><br><span class="line"><span class="comment"># IBM Corp.</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Using column generation</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Problem Description:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">The cutting stock problem in this example is sometimes known in math</span></span><br><span class="line"><span class="string">programming terms as a knapsack problem with reduced costs in the</span></span><br><span class="line"><span class="string">objective function. Generally, a cutting stock problem begins with a</span></span><br><span class="line"><span class="string">supply of rolls of material of fixed length (the stock). Strips are cut</span></span><br><span class="line"><span class="string">from these rolls. All the strips cut from one roll are known together as</span></span><br><span class="line"><span class="string">a pattern. The point of this example is to use as few rolls of stock as</span></span><br><span class="line"><span class="string">possible to satisfy some specified demand of strips. By convention, it is</span></span><br><span class="line"><span class="string">assumed that only one pattern is laid out across the stock; consequently,</span></span><br><span class="line"><span class="string">only one dimension (the width) of each roll of stock is important.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">To run from the command line, use</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   python cutstock.py</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cplex</span><br><span class="line"><span class="keyword">from</span> cplex.exceptions <span class="keyword">import</span> CplexSolverError</span><br><span class="line"><span class="keyword">from</span> cplex <span class="keyword">import</span> SparsePair</span><br><span class="line"><span class="keyword">from</span> cplex.six.moves <span class="keyword">import</span> zip</span><br><span class="line"><span class="keyword">from</span> inputdata <span class="keyword">import</span> read_dat_file</span><br><span class="line"></span><br><span class="line">RC_EPS = <span class="number">1.0e-6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">report1</span><span class="params">(cut)</span>:</span></span><br><span class="line">    <span class="string">"""Print a report about the current solution in the cutting</span></span><br><span class="line"><span class="string">    optimization problem given by the cut argument.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    print()</span><br><span class="line">    print(<span class="string">"Using "</span> + str(cut.solution.get_objective_value()) + <span class="string">" rolls"</span>)</span><br><span class="line">    print()</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> range(cut.variables.get_num()):</span><br><span class="line">        print(<span class="string">"  Cut"</span> + str(v) + <span class="string">" = "</span> + str(cut.solution.get_values(v)))</span><br><span class="line">    print()</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> range(cut.linear_constraints.get_num()):</span><br><span class="line">        print(<span class="string">"  Fill"</span> + str(c) + <span class="string">" = "</span> + str(cut.solution.get_dual_values(c)))</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">report2</span><span class="params">(pat, use)</span>:</span></span><br><span class="line">    <span class="string">"""Print a report about the current solution in the pattern generation</span></span><br><span class="line"><span class="string">    problem given by the pat argument. The use argument specifies the indices</span></span><br><span class="line"><span class="string">    of variables that shall appear in the report.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print()</span><br><span class="line">    print(<span class="string">"Reduced cost is "</span> + str(pat.solution.get_objective_value()))</span><br><span class="line">    print()</span><br><span class="line">    <span class="keyword">if</span> pat.solution.get_objective_value() &lt;= -RC_EPS:</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> use:</span><br><span class="line">            print(<span class="string">"  Use"</span> + str(v) + <span class="string">" = "</span> + str(pat.solution.get_values(v)))</span><br><span class="line">        print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">report3</span><span class="params">(cut)</span>:</span></span><br><span class="line">    <span class="string">"""Print the final report for the current solution in the cutting</span></span><br><span class="line"><span class="string">    optimization problem given by the cut argument.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print()</span><br><span class="line">    print(<span class="string">"Best integer solution uses "</span> +</span><br><span class="line">          str(cut.solution.get_objective_value()) + <span class="string">" rolls"</span>)</span><br><span class="line">    print()</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> range(cut.variables.get_num()):</span><br><span class="line">        print(<span class="string">"  Cut"</span> + str(v) + <span class="string">" = "</span> + str(cut.solution.get_values(v)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cutstock</span><span class="params">(datafile)</span>:</span></span><br><span class="line">    <span class="comment"># Input data. If no file is given on the command line then use a</span></span><br><span class="line">    <span class="comment"># default file name. The data read is</span></span><br><span class="line">    <span class="comment"># width  - the width of the the roll,</span></span><br><span class="line">    <span class="comment"># size   - the sie of each strip,</span></span><br><span class="line">    <span class="comment"># amount - the demand for each strip.</span></span><br><span class="line">    width, size, amount = read_dat_file(datafile)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Setup cutting optimization (master) problem.</span></span><br><span class="line">    <span class="comment"># This is the problem to which columns will be added in the loop</span></span><br><span class="line">    <span class="comment"># below.</span></span><br><span class="line">    cut = cplex.Cplex()</span><br><span class="line">    cut.set_results_stream(<span class="literal">None</span>)</span><br><span class="line">    cutcons = list(range(len(amount)))   <span class="comment"># constraint indices</span></span><br><span class="line">    cutvars = list(range(len(size)))     <span class="comment"># variable indices</span></span><br><span class="line">    cut.variables.add(obj=[<span class="number">1</span>] * len(cutvars))</span><br><span class="line">    <span class="comment"># Add constraints. They have empty left-hand side initially. The</span></span><br><span class="line">    <span class="comment"># left-hand side is filled in the next loop.</span></span><br><span class="line">    cut.linear_constraints.add(lin_expr=[SparsePair()] * len(cutcons),</span><br><span class="line">                               senses=[<span class="string">"G"</span>] * len(cutcons),</span><br><span class="line">                               rhs=amount)</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> cutvars:</span><br><span class="line">        cut.linear_constraints.set_coefficients(v, v, int(width / size[v]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Setup pattern generation (worker) problem.</span></span><br><span class="line">    <span class="comment"># The constraints and variables in this problem always stay the same</span></span><br><span class="line">    <span class="comment"># but the objective function will change during the column generation</span></span><br><span class="line">    <span class="comment"># loop.</span></span><br><span class="line">    pat = cplex.Cplex()</span><br><span class="line">    pat.set_results_stream(<span class="literal">None</span>)</span><br><span class="line">    use = list(range(len(size)))         <span class="comment"># variable indices</span></span><br><span class="line">    pat.variables.add(types=[pat.variables.type.integer] * len(use))</span><br><span class="line">    <span class="comment"># Add a constant 1 to the objective.</span></span><br><span class="line">    pat.variables.add(obj=[<span class="number">1</span>], lb=[<span class="number">1</span>], ub=[<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># Single constraint: total size must not exceed the width.</span></span><br><span class="line">    totalsize = SparsePair(ind=use, val=size)</span><br><span class="line">    pat.linear_constraints.add(lin_expr=[totalsize],</span><br><span class="line">                               senses=[<span class="string">"L"</span>],</span><br><span class="line">                               rhs=[width])</span><br><span class="line">    pat.objective.set_sense(pat.objective.sense.minimize)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Column generation procedure</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Optimize over current patterns</span></span><br><span class="line">        cut.solve()</span><br><span class="line">        report1(cut)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Find and add new pattern. The objective function of the</span></span><br><span class="line">        <span class="comment"># worker problem is constructed from the dual values of the</span></span><br><span class="line">        <span class="comment"># constraints of the master problem.</span></span><br><span class="line">        price = [-d <span class="keyword">for</span> d <span class="keyword">in</span> cut.solution.get_dual_values(cutcons)]</span><br><span class="line">        pat.objective.set_linear(list(zip(use, price)))</span><br><span class="line">        pat.solve()</span><br><span class="line">        report2(pat, use)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># If reduced cost (worker problem objective function value) is</span></span><br><span class="line">        <span class="comment"># non-negative we are optimal. Otherwise we found a new column</span></span><br><span class="line">        <span class="comment"># to be added. Coefficients of the new column are given by the</span></span><br><span class="line">        <span class="comment"># optimal solution vector to the worker problem.</span></span><br><span class="line">        <span class="keyword">if</span> pat.solution.get_objective_value() &gt; -RC_EPS:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        newpat = pat.solution.get_values(use)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># The new pattern constitutes a new variable in the cutting</span></span><br><span class="line">        <span class="comment"># optimization problem. Create that variable and add it to all</span></span><br><span class="line">        <span class="comment"># constraints with the coefficients read from the optimal solution</span></span><br><span class="line">        <span class="comment"># of the pattern generation problem.</span></span><br><span class="line">        idx = cut.variables.get_num()</span><br><span class="line">        cut.variables.add(obj=[<span class="number">1.0</span>])</span><br><span class="line">        cut.linear_constraints.set_coefficients(list(zip(cutcons,</span><br><span class="line">                                                         [idx] * len(use),</span><br><span class="line">                                                         newpat)))</span><br><span class="line">        cutvars.append(idx)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Perform a final solve on the cutting optimization problem.</span></span><br><span class="line">    <span class="comment"># Turn all variables into integers before doing that.</span></span><br><span class="line">    cut.variables.set_types(</span><br><span class="line">        list(zip(cutvars, [cut.variables.type.integer] * len(cutvars))))</span><br><span class="line">    cut.solve()</span><br><span class="line">    report3(cut)</span><br><span class="line">    print(<span class="string">"Solution status = "</span>, cut.solution.get_status())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    datafile = <span class="string">"../../../examples/data/cutstock.dat"</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) &lt; <span class="number">2</span>:</span><br><span class="line">        print(<span class="string">"Default data file : "</span> + datafile)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        datafile = sys.argv[<span class="number">1</span>]</span><br><span class="line">    cutstock(datafile)</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="读取问题">读取问题</h1><figure class="highlight python"><figcaption><span>inputdata.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># File: inputdata.py</span></span><br><span class="line"><span class="comment"># Version 12.9.0</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Licensed Materials - Property of IBM</span></span><br><span class="line"><span class="comment"># 5725-A06 5725-A29 5724-Y48 5724-Y49 5724-Y54 5724-Y55 5655-Y21</span></span><br><span class="line"><span class="comment"># Copyright IBM Corporation 2009, 2019. All Rights Reserved.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># US Government Users Restricted Rights - Use, duplication or</span></span><br><span class="line"><span class="comment"># disclosure restricted by GSA ADP Schedule Contract with</span></span><br><span class="line"><span class="comment"># IBM Corp.</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="string">"""Utility for reading data from .dat files in examples/data/."""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_words</span><span class="params">(line)</span>:</span></span><br><span class="line">    <span class="string">"""Return a list of the tokens in line."""</span></span><br><span class="line">    line = line.replace(<span class="string">"\t"</span>, <span class="string">" "</span>)</span><br><span class="line">    line = line.replace(<span class="string">"\v"</span>, <span class="string">" "</span>)</span><br><span class="line">    line = line.replace(<span class="string">"\r"</span>, <span class="string">" "</span>)</span><br><span class="line">    line = line.replace(<span class="string">"\n"</span>, <span class="string">" "</span>)</span><br><span class="line">    <span class="keyword">while</span> line.count(<span class="string">"  "</span>):</span><br><span class="line">        line = line.replace(<span class="string">"  "</span>, <span class="string">" "</span>)</span><br><span class="line">    line = line.strip()</span><br><span class="line">    <span class="keyword">return</span> [word + <span class="string">" "</span> <span class="keyword">for</span> word <span class="keyword">in</span> line.split(<span class="string">" "</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_dat_file</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="string">"""Return a list containing the data stored in the dat file.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Single integers or floats are stored as their natural type.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    1-d arrays are stored as lists</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    2-d arrays are stored as lists of lists.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    NOTE: the 2-d arrays are not in the list-of-lists matrix format</span></span><br><span class="line"><span class="string">    that the python methods take as input for constraints.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    ret = []</span><br><span class="line">    continuation = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> get_words(line):</span><br><span class="line">                <span class="keyword">if</span> continuation:</span><br><span class="line">                    entity = <span class="string">""</span>.join([entity, word])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    entity = word</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    ret.append(eval(entity))</span><br><span class="line">                    continuation = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">except</span> SyntaxError:</span><br><span class="line">                    continuation = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><h1 id="示例问题">示例问题</h1><figure class="highlight plain"><figcaption><span>cutstock.dat</span></figcaption><table><tr><td class="code"><pre><span class="line">115</span><br><span class="line">[25, 40, 50, 55, 70]</span><br><span class="line">[50, 36, 24, 8, 30]</span><br></pre></td></tr></table></figure><h1 id="示例运行结果">示例运行结果</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python cutstock.py</span><br><span class="line">Default data file : ../../../examples/data/cutstock.dat</span><br><span class="line"></span><br><span class="line">Using 76.5 rolls</span><br><span class="line"></span><br><span class="line">  Cut0 = 12.5</span><br><span class="line">  Cut1 = 18.0</span><br><span class="line">  Cut2 = 12.0</span><br><span class="line">  Cut3 = 4.0</span><br><span class="line">  Cut4 = 30.0</span><br><span class="line"></span><br><span class="line">  Fill0 = 0.25</span><br><span class="line">  Fill1 = 0.5</span><br><span class="line">  Fill2 = 0.5</span><br><span class="line">  Fill3 = 0.5</span><br><span class="line">  Fill4 = 1.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Reduced cost is -0.5</span><br><span class="line"></span><br><span class="line">  Use0 = 0.0</span><br><span class="line">  Use1 = 1.0</span><br><span class="line">  Use2 = 0.0</span><br><span class="line">  Use3 = 0.0</span><br><span class="line">  Use4 = 1.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Using 61.5 rolls</span><br><span class="line"></span><br><span class="line">  Cut0 = 12.5</span><br><span class="line">  Cut1 = 3.0</span><br><span class="line">  Cut2 = 12.0</span><br><span class="line">  Cut3 = 4.0</span><br><span class="line">  Cut4 = 0.0</span><br><span class="line">  Cut5 = 30.0</span><br><span class="line"></span><br><span class="line">  Fill0 = 0.25</span><br><span class="line">  Fill1 = 0.5</span><br><span class="line">  Fill2 = 0.5</span><br><span class="line">  Fill3 = 0.5</span><br><span class="line">  Fill4 = 0.5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Reduced cost is -0.25</span><br><span class="line"></span><br><span class="line">  Use0 = 1.0</span><br><span class="line">  Use1 = 2.0</span><br><span class="line">  Use2 = 0.0</span><br><span class="line">  Use3 = 0.0</span><br><span class="line">  Use4 = 0.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Using 60.75 rolls</span><br><span class="line"></span><br><span class="line">  Cut0 = 11.75</span><br><span class="line">  Cut1 = 0.0</span><br><span class="line">  Cut2 = 12.0</span><br><span class="line">  Cut3 = 4.0</span><br><span class="line">  Cut4 = 0.0</span><br><span class="line">  Cut5 = 30.0</span><br><span class="line">  Cut6 = 3.0</span><br><span class="line"></span><br><span class="line">  Fill0 = 0.25</span><br><span class="line">  Fill1 = 0.375</span><br><span class="line">  Fill2 = 0.5</span><br><span class="line">  Fill3 = 0.5</span><br><span class="line">  Fill4 = 0.625</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Reduced cost is -0.125</span><br><span class="line"></span><br><span class="line">  Use0 = 3.0</span><br><span class="line">  Use1 = 1.0</span><br><span class="line">  Use2 = 0.0</span><br><span class="line">  Use3 = -0.0</span><br><span class="line">  Use4 = -0.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Using 60.0 rolls</span><br><span class="line"></span><br><span class="line">  Cut0 = 8.0</span><br><span class="line">  Cut1 = 0.0</span><br><span class="line">  Cut2 = 12.0</span><br><span class="line">  Cut3 = 4.0</span><br><span class="line">  Cut4 = 0.0</span><br><span class="line">  Cut5 = 30.0</span><br><span class="line">  Cut6 = 0.0</span><br><span class="line">  Cut7 = 6.0</span><br><span class="line"></span><br><span class="line">  Fill0 = 0.25</span><br><span class="line">  Fill1 = 0.25</span><br><span class="line">  Fill2 = 0.5</span><br><span class="line">  Fill3 = 0.5</span><br><span class="line">  Fill4 = 0.75</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Reduced cost is 0.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Best integer solution uses 60.0 rolls</span><br><span class="line"></span><br><span class="line">  Cut0 = 8.0</span><br><span class="line">  Cut1 = -0.0</span><br><span class="line">  Cut2 = 12.0</span><br><span class="line">  Cut3 = 4.0</span><br><span class="line">  Cut4 = -0.0</span><br><span class="line">  Cut5 = 30.0</span><br><span class="line">  Cut6 = -0.0</span><br><span class="line">  Cut7 = 6.0</span><br><span class="line">Solution status =  101</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> column generation </tag>
            
            <tag> cplex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聚类</title>
      <link href="/notes/introduction-to-ml-with-python/clustering/"/>
      <url>/notes/introduction-to-ml-with-python/clustering/</url>
      
        <content type="html"><![CDATA[<p>聚类（clustering）是将数据集划分成组的任务，这些组叫作簇（cluster）。其目标是划分数据，使得一个簇内的数据点非常相似且不同簇内的数据点非常不同。与分类算法类似，聚类算法为每个数据点分配（或预测）一个数字，表示这个点属于哪个簇。</p><h1 id="k均值聚类">k均值聚类</h1><p>k均值聚类是最简单也最常用的聚类算法之一。它试图找到代表数据特定区域的<strong>簇中心</strong>（cluster center）。算法交替执行以下两个步骤：将每个数据点分配给最近的簇中心，然后将每个簇中心设置为所分配的所有数据点的平均值。如果簇的分配不再发生变化，那么算法结束。下面的例子在一个模拟数据集上对这一算法进行说明。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_kmeans_algorithm()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/kmeans-algorithm.png"></p><a id="more"></a><p>簇中心用三角形表示，而数据点用圆形表示。颜色表示簇成员。我们指定要寻找三个簇，所以通过声明三个随机数据点为簇中心来将算法初始化。然后开始迭代算法。首先每个数据点被分配给距离最近的簇中心。接下来，将簇中心修改为所分配点的平均值。然后将这一过程再重复两次。在第三次迭代之后，为簇中心分配的数据点保持不变，因此算法结束。</p><p>给定新的数据点，k均值会将其分配给最近的簇中心。下一例子展示了学到的簇中心的边界。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_kmeans_boundaries()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/kmeans-boundaries.png"></p><p>用<code>scikit-learn</code>应用k均值相当简单。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.cluster.kmeans" target="_blank" rel="noopener"><code>class sklearn.cluster.KMeans(n_clusters=8, init=’k-means++’, n_init=10, max_iter=300, tol=0.0001, precompute_distances=’auto’, verbose=0, random_state=None, copy_x=True, n_jobs=None, algorithm=’auto’)</code></a></p><p>K-Means clustering</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成模拟的二维数据</span></span><br><span class="line">X, y = make_blobs(random_state=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 构建聚类模型</span></span><br><span class="line">kmeans = KMeans(n_clusters=<span class="number">3</span>)</span><br><span class="line">kmeans.fit(X)</span><br><span class="line">print(<span class="string">'Cluster memberships:\n&#123;&#125;'</span>.format(kmeans.labels_))</span><br><span class="line"><span class="comment"># 对训练集运行predict会返回与labels_相同的结果</span></span><br><span class="line">print(kmeans.predict(X))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cluster memberships:</span><br><span class="line">[0 2 2 2 1 1 1 2 0 0 2 2 1 0 1 1 1 0 2 2 1 2 1 0 2 1 1 0 0 1 0 0 1 0 2 1 2</span><br><span class="line"> 2 2 1 1 2 0 2 2 1 0 0 0 0 2 1 1 1 0 1 2 2 0 0 2 1 1 2 2 1 0 1 0 2 2 2 1 0</span><br><span class="line"> 0 2 1 1 0 2 0 2 2 1 0 0 0 0 2 0 1 0 0 2 2 1 1 0 1 0]</span><br><span class="line">[0 2 2 2 1 1 1 2 0 0 2 2 1 0 1 1 1 0 2 2 1 2 1 0 2 1 1 0 0 1 0 0 1 0 2 1 2</span><br><span class="line"> 2 2 1 1 2 0 2 2 1 0 0 0 0 2 1 1 1 0 1 2 2 0 0 2 1 1 2 2 1 0 1 0 2 2 2 1 0</span><br><span class="line"> 0 2 1 1 0 2 0 2 2 1 0 0 0 0 2 0 1 0 0 2 2 1 1 0 1 0]</span><br></pre></td></tr></table></figure><p>因为要们要找的是3个簇，所有簇的编号是0到2。你也可以用predict方法为新数据点分配标签。预测时会将最近的簇中心分配个每个新数据点，但现有模型不会改变（即不会更新簇中心的位置）。</p><p>与分类算法类似，聚类算法的每个元素也有一个标签。但并不存在真实的标签，因此标签本身并没有<strong>先验</strong>意义。回到人脸图像聚类的例子。聚类的结果可能是，算法找到的第3个簇仅包含你朋友Bela的面孔。但只有在查看图片之后才能知道这一点，而且数字3是任意的。算法给你的唯一信息就是所有标签为3的人脸都是相似的。</p><p>对于我们刚刚在二维玩具数据集上运行的聚类算法，这意味着我们不应该为其中一组的标签是0、另一组的标签是1这一事实赋予任何意义。再次运行该算法可能会导致不同的簇编号，原因在于初始化的随机性质。</p><p>下面又给出了这个数据的图像。簇中心被保存在<code>cluster_centers_</code>属性中，我们用三角形表示它们。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.discrete_scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], kmeans.labels_, markers=<span class="string">'o'</span>)</span><br><span class="line">mglearn.discrete_scatter(kmeans.cluster_centers_[:, <span class="number">0</span>],</span><br><span class="line">    kmeans.cluster_centers_[:, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], markers=<span class="string">'^'</span>, markeredgewidth=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/kmeans-cluster-centers.png"></p><p>我们也可以使用更多或更少的簇中心。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, axes = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment"># 使用2个簇中心</span></span><br><span class="line">kmeans = KMeans(n_clusters=<span class="number">2</span>)</span><br><span class="line">kmeans.fit(X)</span><br><span class="line">assignments = kmeans.labels_</span><br><span class="line">mglearn.discrete_scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], assignments, ax=axes[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 使用5个簇中心</span></span><br><span class="line">kmeans = KMeans(n_clusters=<span class="number">5</span>)</span><br><span class="line">kmeans.fit(X)</span><br><span class="line">assignments = kmeans.labels_</span><br><span class="line">mglearn.discrete_scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], assignments, ax=axes[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/kmeans-more-or-less-cluster-centers.png"></p><h2 id="k均值的失败案例">k均值的失败案例</h2><p>即使你知道给定数据集中簇的“正确”个数，k均值可能也不是总能找到它们。<strong>每个簇仅有其中心定义，这意味着每个簇都是凸形（convex）。因此，k均值只能找到相对简单的形状。</strong>k均值还假设所有簇在某种程度上具有相同的“直径”，它总是将簇之间的边界刚好画在簇中心的中间位置。有时这会导致令人惊讶的结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_varied, y_varied = make_blobs(n_samples=<span class="number">200</span>, cluster_std=[<span class="number">1.0</span>, <span class="number">2.5</span>, <span class="number">0.5</span>],</span><br><span class="line">    random_state=<span class="number">170</span>)</span><br><span class="line">y_pred = KMeans(n_clusters=<span class="number">3</span>, random_state=<span class="number">0</span>).fit_predict(X_varied)</span><br><span class="line"></span><br><span class="line">mglearn.discrete_scatter(X_varied[:, <span class="number">0</span>], X_varied[:, <span class="number">1</span>], y_pred)</span><br><span class="line">plt.legend([<span class="string">'cluster 0'</span>, <span class="string">'cluster 1'</span>, <span class="string">'cluster 2'</span>], loc=<span class="string">'best'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature 1'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/kmeans-different-density.png"></p><p>你可能会认为，左下方的密集区域是第一个簇，右上方的密集区域是第二个，中间密度较小的区域是第三个。但事实上，簇0和簇1都包含一些远离簇中其他点的点。</p><p>k均值还假设所有方向对每个簇都同等重要。下图显示了一个二维数据集，数据中包含明确分开的三部分。但是这三部分被沿着对角线方向拉长。由于k均值仅考虑到最近簇中心的距离，所以它无法处理这种类型的数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成一些随机分组数据</span></span><br><span class="line">X, y = make_blobs(random_state=<span class="number">170</span>, n_samples=<span class="number">600</span>)</span><br><span class="line">rng = np.random.RandomState(<span class="number">74</span>)</span><br><span class="line"><span class="comment"># 变换数据使其拉长</span></span><br><span class="line">transformation = rng.normal(size=(<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line">X = np.dot(X, transformation)</span><br><span class="line"><span class="comment"># 将数据聚类成3个簇</span></span><br><span class="line">kmeans = KMeans(n_clusters=<span class="number">3</span>)</span><br><span class="line">kmeans.fit(X)</span><br><span class="line">y_pred = kmeans.predict(X)</span><br><span class="line"><span class="comment"># 画出簇分配和簇中心</span></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y_pred, cmap=mglearn.cm3)</span><br><span class="line">plt.scatter(kmeans.cluster_centers_[:, <span class="number">0</span>], kmeans.cluster_centers_[:, <span class="number">1</span>],</span><br><span class="line">    marker=<span class="string">'^'</span>, c=[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], s=<span class="number">100</span>, linewidth=<span class="number">2</span>, cmap=mglearn.cm3)</span><br><span class="line">plt.xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature 1'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/kmeans-aspherical.png"></p><p>如果簇的形状更加复杂，那么k均值的表现也很差。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成模拟的two_moons数据</span></span><br><span class="line">X, y = make_moons(n_samples=<span class="number">200</span>, noise=<span class="number">0.05</span>, random_state=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 将数据聚类成2个簇</span></span><br><span class="line">kmeans = KMeans(n_clusters=<span class="number">2</span>)</span><br><span class="line">kmeans.fit(X)</span><br><span class="line">y_pred = kmeans.predict(X)</span><br><span class="line"><span class="comment"># 画出簇分配和簇中心</span></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y_pred, cmap=mglearn.cm3, s=<span class="number">60</span>)</span><br><span class="line">plt.scatter(kmeans.cluster_centers_[:, <span class="number">0</span>], kmeans.cluster_centers_[:, <span class="number">1</span>],</span><br><span class="line">    marker=<span class="string">'^'</span>, c=[mglearn.cm2(<span class="number">0</span>), mglearn.cm2(<span class="number">1</span>)], s=<span class="number">100</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature 1'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/kmeans-on-two-moons.png"></p><p>这里我们希望聚类算法能够发现两个半月形。但利用k均值算法是不可能做到这一点的。</p><h2 id="矢量量化或者将k均值看作分解">矢量量化，或者将k均值看作分解</h2><p>虽然k均值是一种聚类算法，但在k均值和分解方法（比如PCA和NMF）之间存在一些有趣的相似之处。PCA试图找到数据中方差最大的方向，而NMF试图找到累加的分量，这通常对应于数据的“极值”或“部分”。两种方法都试图将数据点表示为一些分量之和。与之相反，k均值则尝试利用簇中心来表示每个数据点。你可以将其看作仅用一个分量来表示每个数据点，该分量由簇中心给出。这种观点将k均值看作是一种分解方法，其中每个点用单一分量来表示，这种观点被称为<strong>矢量量化</strong>（vector quantization）。</p><p>我们来并排比较PCA、NMF和k均值，分别显示提取的分量，以及利用100个分量对测试集中人脸的重建。对于k均值，重建就是在训练集中找到最近的簇中心。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">    X_people, y_people, stratify=y_people, random_state=<span class="number">0</span>)</span><br><span class="line">nmf = NMF(n_components=<span class="number">100</span>, random_state=<span class="number">0</span>)</span><br><span class="line">nmf.fit(X_train)</span><br><span class="line">pca = PCA(n_components=<span class="number">100</span>, random_state=<span class="number">0</span>)</span><br><span class="line">pca.fit(X_train)</span><br><span class="line">kmeans = KMeans(n_clusters=<span class="number">100</span>, random_state=<span class="number">0</span>)</span><br><span class="line">kmeans.fit(X_train)</span><br><span class="line"></span><br><span class="line">X_reconstructed_pca = pca.inverse_transform(pca.transform(X_test))</span><br><span class="line">X_reconstructed_nmf = np.dot(nmf.transform(X_test), nmf.components_)</span><br><span class="line">X_reconstructed_kmeans = kmeans.cluster_centers_[kmeans.predict(X_test)]</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(<span class="number">3</span>, <span class="number">5</span>, figsize=(<span class="number">8</span>, <span class="number">8</span>),</span><br><span class="line">    subplot_kw=&#123;<span class="string">'xticks'</span>: (), <span class="string">'yticks'</span>: ()&#125;)</span><br><span class="line">fig.suptitle(<span class="string">'Extracted Components'</span>)</span><br><span class="line"><span class="keyword">for</span> ax, comp_kmeans, comp_pca, comp_nmf <span class="keyword">in</span> zip(</span><br><span class="line">    axes.T, kmeans.cluster_centers_, pca.components_, nmf.components_):</span><br><span class="line">    ax[<span class="number">0</span>].imshow(comp_kmeans.reshape(image_shape))</span><br><span class="line">    ax[<span class="number">1</span>].imshow(comp_pca.reshape(image_shape), cmap=<span class="string">'viridis'</span>)</span><br><span class="line">    ax[<span class="number">2</span>].imshow(comp_nmf.reshape(image_shape))</span><br><span class="line">axes[<span class="number">0</span>, <span class="number">0</span>].set_ylabel(<span class="string">'kmeas'</span>)</span><br><span class="line">axes[<span class="number">1</span>, <span class="number">0</span>].set_ylabel(<span class="string">'pca'</span>)</span><br><span class="line">axes[<span class="number">2</span>, <span class="number">0</span>].set_ylabel(<span class="string">'nmf'</span>)</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(<span class="number">4</span>, <span class="number">5</span>, figsize=(<span class="number">8</span>, <span class="number">8</span>),</span><br><span class="line">    subplot_kw=&#123;<span class="string">'xticks'</span>: (), <span class="string">'yticks'</span>: ()&#125;)</span><br><span class="line">fig.suptitle(<span class="string">'Reconstructions'</span>)</span><br><span class="line"><span class="keyword">for</span> ax, org, rec_kmeans, rec_pca, rec_nmf <span class="keyword">in</span> zip(axes.T, X_test,</span><br><span class="line">    X_reconstructed_kmeans, X_reconstructed_pca, X_reconstructed_nmf):</span><br><span class="line">    ax[<span class="number">0</span>].imshow(org.reshape(image_shape))</span><br><span class="line">    ax[<span class="number">1</span>].imshow(rec_kmeans.reshape(image_shape))</span><br><span class="line">    ax[<span class="number">2</span>].imshow(rec_pca.reshape(image_shape))</span><br><span class="line">    ax[<span class="number">3</span>].imshow(rec_nmf.reshape(image_shape))</span><br><span class="line">axes[<span class="number">0</span>, <span class="number">0</span>].set_ylabel(<span class="string">'original'</span>)</span><br><span class="line">axes[<span class="number">1</span>, <span class="number">0</span>].set_ylabel(<span class="string">'kmeas'</span>)</span><br><span class="line">axes[<span class="number">2</span>, <span class="number">0</span>].set_ylabel(<span class="string">'pca'</span>)</span><br><span class="line">axes[<span class="number">3</span>, <span class="number">0</span>].set_ylabel(<span class="string">'nmf'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/kmeans-pca-nmf-extract-components.png"></p><p><img src="/uploads/image/introduction-to-ml-with-python/kmeans-pca-nmf-reconstructions.png"></p><p><strong>利用k均值做矢量量化的一个有趣之处在于，可以用比输入维度更多的簇来对数据进行编码</strong>让我们回到<code>two_moons</code>数据。利用PCA或NMF，我们对这个数据无能为力，因为它只有两个维度。使用PCA或NMF将其降到一维，将会完全破坏数据的结构。但通过使用更多的簇中心，我们可以用k均值找到一种更具表现力的表示。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X, y = make_moons(n_samples=<span class="number">200</span>, noise=<span class="number">0.05</span>, random_state=<span class="number">0</span>)</span><br><span class="line">kmeans = KMeans(n_clusters=<span class="number">10</span>, random_state=<span class="number">0</span>)</span><br><span class="line">kmeans.fit(X)</span><br><span class="line">y_pred = kmeans.predict(X)</span><br><span class="line"></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y_pred, s=<span class="number">60</span>, cmap=<span class="string">'Paired'</span>)</span><br><span class="line">plt.scatter(kmeans.cluster_centers_[:, <span class="number">0</span>], kmeans.cluster_centers_[:, <span class="number">1</span>],</span><br><span class="line">    s=<span class="number">60</span>, marker=<span class="string">'^'</span>, c=range(kmeans.n_clusters), linewidth=<span class="number">2</span>, cmap=<span class="string">'Paired'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature 1'</span>)</span><br><span class="line">print(<span class="string">'Cluster memberships:\n&#123;&#125;'</span>.format(y_pred))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cluster memberships:</span><br><span class="line">[9 2 5 4 2 7 9 6 9 6 1 0 2 6 1 9 3 0 3 1 7 6 8 6 8 5 2 7 5 8 9 8 6 5 3 7 0</span><br><span class="line"> 9 4 5 0 1 3 5 2 8 9 1 5 6 1 0 7 4 6 3 3 6 3 8 0 4 2 9 6 4 8 2 8 4 0 4 0 5</span><br><span class="line"> 6 4 5 9 3 0 7 8 0 7 5 8 9 8 0 7 3 9 7 1 7 2 2 0 4 5 6 7 8 9 4 5 4 1 2 3 1</span><br><span class="line"> 8 8 4 9 2 3 7 0 9 9 1 5 8 5 1 9 5 6 7 9 1 4 0 6 2 6 4 7 9 5 5 3 8 1 9 5 6</span><br><span class="line"> 3 5 0 2 9 3 0 8 6 0 3 3 5 6 3 2 0 2 3 0 2 6 3 4 4 1 5 6 7 1 1 3 2 4 7 2 7</span><br><span class="line"> 3 8 6 4 1 4 3 9 9 5 1 7 5 8 2]</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/kmeans-on-two-moons-10-centers.png"></p><p>我们使用了10个簇中心，也就是说，现在每个点都被分配了0到9之间的一个数字。我们可以将其看作10个分量表示的数据（我们有是10个新特征），只有表示该点对应的簇中心的那个特征不为0，其他特征均为0。利用这个10维表示，现在可以用线性模型来划分两个半月形，而利用原始的两个特征是不可能做到这一点的。将到每个簇中心的距离作为特征，还可以得到一种表现力更强的数据表示。可以利用kmeans的transform方法来完成这一点。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">distance_features = kmeans.transform(X)</span><br><span class="line">print(<span class="string">'Distance feature shape: &#123;&#125;'</span>.format(distance_features.shape))</span><br><span class="line">print(<span class="string">'Distance features:\n&#123;&#125;'</span>.format(distance_features))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Distance feature shape: (200, 10)</span><br><span class="line">Distance features:</span><br><span class="line">[[0.9220768  1.46553151 1.13956805 ... 1.16559918 1.03852189 0.23340263]</span><br><span class="line"> [1.14159679 2.51721597 0.1199124  ... 0.70700803 2.20414144 0.98271691]</span><br><span class="line"> [0.78786246 0.77354687 1.74914157 ... 1.97061341 0.71561277 0.94399739]</span><br><span class="line"> ...</span><br><span class="line"> [0.44639122 1.10631579 1.48991975 ... 1.79125448 1.03195812 0.81205971]</span><br><span class="line"> [1.38951924 0.79790385 1.98056306 ... 1.97788956 0.23892095 1.05774337]</span><br><span class="line"> [1.14920754 2.4536383  0.04506731 ... 0.57163262 2.11331394 0.88166689]]</span><br></pre></td></tr></table></figure><p>k均值是非常流行的聚类算法，因为它不仅相对容易理解和实现，而且运行速度也相对较快。k均值可以轻松扩展到大型数据集，<code>scikit-learn</code>甚至在<code>MiniBatchKMeans</code>类中包含了一种更具扩展性的变体，可以处理非常大的数据集。</p><p>k均值的缺点之一在于，它依赖于随机初始化，也就是说，算法的输出依赖于随机种子。默认情况下，<code>scikit-learn</code>用10种不同的随机初始化将算法运行10次，并返回最佳（簇的方差之和最小）结果。k均值还有一个缺点，就是对簇形状的假设的约束性较强，而且还要求指定所要寻找的簇的个数（在现实世界的应用中可能并不知道这个数字）。</p><p>接下来，我们将学习另外两种聚类算法，它们都在某些方面对这些性质做了改进。</p><h1 id="凝聚聚类">凝聚聚类</h1><p>凝聚聚类（agglomerative clustering）指的是许多基于相同原则构建的聚类算法，这一原则是：算法首先声明每个点是自己的簇，然后合并两个最相似的簇，直到满足某种停止准则为止。<code>scikit-learn</code>中实现的停止准则是簇的个数，因此相似的簇被合并，直到仅剩下指定个数的簇。还有一些链接（linkage）准则，规定如何度量“最相似的簇”。这种度量总是定义在两个现有的簇之间。</p><p><code>scikit-learn</code>中实现了以下三种选项。</p><ul><li><p>ward</p><p>默认选项。ward挑选两个簇来合并，使得所有簇中的方差增加最小。这通常会得到大小差不多相等的簇。</p></li><li><p>average</p><p>average链接将簇中所有点之间平均距离最小的两个簇合并。</p></li><li><p>complete</p><p>complete链接（也称为最大链接）将簇中点之间最大距离最小的两个簇合并。</p></li></ul><p>ward适用于大多数数据集，在我们的例子中将使用它。如果簇中的成员个数非常不同（比如其中一个比其他所有都大得多），那么average或complete可能效果更好。</p><p>下图给出了在一个二维数据集上的凝聚聚类过程，要寻找三个簇。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_agglomerative_algorithm()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/agglomerative-algorithm.png"></p><p>我们来看一下凝聚聚类对简单三簇数据的效果如何。由于算法的工作原理，凝聚算法不能对新数据点作出预测。因此<code>AgglomerativeClustering</code>没有predict方法。为了构造模型并得到训练集上簇的成员表示，可以改用<code>fit_predict</code>方法，或使用<code>labels_</code>属性。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.cluster.agglomerativeclustering" target="_blank" rel="noopener"><code>class sklearn.cluster.AgglomerativeClustering(n_clusters=2, affinity=’euclidean’, memory=None, connectivity=None, compute_full_tree=’auto’, linkage=’ward’, pooling_func=’deprecated’)</code></a></p><p>Agglomerative Clustering</p><p>Recursively merges the pair of clusters that minimally increases a given linkage distance.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> AgglomerativeClustering</span><br><span class="line"></span><br><span class="line">X, y = make_blobs(random_state=<span class="number">1</span>)</span><br><span class="line">agg = AgglomerativeClustering(n_clusters=<span class="number">3</span>)</span><br><span class="line">assignment = agg.fit_predict(X)</span><br><span class="line"></span><br><span class="line">mglearn.discrete_scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], assignment)</span><br><span class="line">plt.legend([<span class="string">'Cluster 0'</span>, <span class="string">'Cluster 1'</span>, <span class="string">'Cluster 1'</span>], loc=<span class="number">2</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature 1'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/agglomerative-clustering-on-blobs.png"></p><p>正如缩小，算法完美地完成了聚类。虽然凝聚聚类的<code>scikit-learn</code>实现需要你指定希望算法找到的簇的个数，但凝聚聚类方法为选择正确的个数提供了一些帮助，我们将在下面讨论。</p><h2 id="层次聚类与树状图">层次聚类与树状图</h2><p>凝聚聚类生成了所谓的层次聚类（hierarchical clustering）。聚类过程迭代进行，每个点都从一个单点簇变为属于最终的某个簇。每个中间步骤都提供了数据的一种聚类（簇的个数也不相同）。有时候，同时查看所有可能的聚类是有帮助的。下一个例子叠加显示了所有可能的聚类，有助于深入了解每个簇如何分解为较小的簇。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_agglomerative()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/agglomerative-hierarchical-clustering.png"></p><p>虽然这种可视化为层次聚类提供了非常详细的试图，但它依赖于数据的二维性质，因此不能用于具有两个以上特征的数据集。但还有另一个将层次聚类可视化的工具，叫作树状图（dendrogram），它可以处理多维数据集。</p><p>不幸的是，目前<code>scikit-learn</code>没有绘制树状图的功能。但你可以利用SciPy轻松生成树状图。SciPy的聚类算法接口与<code>scikit-learn</code>的聚类算法稍有不同。SciPy提供了一个函数，接受数据数组X并计算出一个链接数据（linkage array），它对层次聚类的相似度进行编码。然后我们可以将这个链接数据提供给scipy的dendrogram函数来绘制树状图。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从SciPy中导入dendrogram函数和ward聚类函数</span></span><br><span class="line"><span class="keyword">from</span> scipy.cluster.hierarchy <span class="keyword">import</span> dendrogram, ward</span><br><span class="line"></span><br><span class="line">X, y = make_blobs(random_state=<span class="number">0</span>, n_samples=<span class="number">12</span>)</span><br><span class="line"><span class="comment"># 将ward聚类应用于数据数组X</span></span><br><span class="line"><span class="comment"># SciPy的ward函数返回一个数组，指定执行凝聚聚类时跨越的距离</span></span><br><span class="line">linkage_array = ward(X)</span><br><span class="line"><span class="comment"># 现在为包含簇之间距离的linkage_array绘制树状图</span></span><br><span class="line">dendrogram(linkage_array)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在树中标记划分成两个簇或三个簇的位置</span></span><br><span class="line">ax = plt.gca()</span><br><span class="line">bounds = ax.get_xbound()</span><br><span class="line">ax.plot(bounds, [<span class="number">7.25</span>, <span class="number">7.25</span>], <span class="string">'--'</span>, c=<span class="string">'k'</span>)</span><br><span class="line">ax.plot(bounds, [<span class="number">4</span>, <span class="number">4</span>], <span class="string">'--'</span>, c=<span class="string">'k'</span>)</span><br><span class="line"></span><br><span class="line">ax.text(bounds[<span class="number">1</span>], <span class="number">7.25</span>, <span class="string">' two clusters'</span>, va=<span class="string">'center'</span>, fontdict=&#123;<span class="string">'size'</span>: <span class="number">15</span>&#125;)</span><br><span class="line">ax.text(bounds[<span class="number">1</span>], <span class="number">4</span>, <span class="string">' three clusters'</span>, va=<span class="string">'center'</span>, fontdict=&#123;<span class="string">'size'</span>: <span class="number">15</span>&#125;)</span><br><span class="line">plt.xlabel(<span class="string">'Sample index'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Cluster distance'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/agglomerative-clustering-dendrogram.png"></p><p>树状图在底部显示数据点（编号从0到11）。然后以这些点（表示单点簇）作为叶节点绘制一棵树，每合并两个簇就添加一个新的父节点。</p><p>从下往上看，数据点1和4首先被合并。接下来，点6和9被合并为一个簇，以此类推。在顶层有两个分支，一个由点11、0、5、10、7、6和9组成，另一个由点1、4、3、2和8组成。这对应于图中两个最大的簇。</p><p>树状图的y轴不仅说明凝聚算法中两个簇何时合并，每个分支的长度还表示被合并的簇之间的距离。在这张树状图中，最长的分支是标记为“three clusters”的虚线表示的三条线。它们是最长的分支，这表示从三个簇到两个簇的过程中合并了一些距离非常远的点。将剩下的两个簇合并为一个簇也需要跨越相对较大的距离。</p><p>不幸的是，凝聚算法仍然无法分离像<code>two_moons</code>数据集这样复杂的形状。但我们要学习的下一个算法DBSCAN可以解决这个问题。</p><h1 id="dbscan">DBSCAN</h1><p>另一个非常有用的聚类算法是DBSCAN（density-based spatial clustering of applications with noise，即“具有噪声的基于密度的空间聚类应用”）。DBSCAN的主要优点是它不需要用户先验地设置簇的个数，可以划分具有复杂形状的簇，还可以找出不属于任何簇的点。DBSCAN比凝聚聚类和k均值稍慢，但仍可以扩展到相对较大的数据集。</p><p>DBSCAN的原理是识别特征空间的“拥挤”区域中的点，在这些区域中许多数据点靠近在一起。这些区域被称为特征空间中的密集（dense）区域。DBSCAN背后的思想是，簇形成数据的密集区域，并由相对较空的区域分隔开。</p><p>在密集区域内的点被称为<strong>核心样本</strong>（core sample，或核心点），它们的定义如下。DBSCAN有两个参数：<code>min_samples</code>和<code>eps</code>。如果距一个给定数据点<code>eps</code>的距离至少有<code>min_samples</code>个数据点，那么这个数据点就是核心样本。DBSCAN将彼此距离小于<code>eps</code>的核心样本放到同一个簇中。</p><p>算法首先任意选取一个点，然后找到这个点的距离小于等于eps的所有的点。如果距起始点的距离在eps之内的数据点个数小于<code>min_samples</code>，那么这个点被标记为<strong>噪声</strong>（noise），也就是说它不属于任何簇。如果距离在eps之内的数据点个数大于<code>min_samples</code>，则这个点被标记为核心样本，并被分配一个新的簇标签。然后访问该点的所有邻居（在距离eps之内）。如果它们还没有被分配一个簇，那么就将刚刚创建的新的簇标签分配给它们。如果它们是核心样本，那么就依次访问其邻居，以此类推。簇逐渐增大，直到在簇的eps距离内没有更多的核心样本为止。然后选取另一个尚未被访问过的点，并重复相同的过程。</p><p><strong>最后，一共有三种类型的点：核心点，与核心点的距离在eps之内的点（叫作边界点，boundary point）和噪声。如果DBSCAN算法在特定数据集上多次运行，那么核心点的聚类始终相同，同样的点也始终被标记为噪声。但边界点可能与不止一个簇的核心样本相邻。因此，边界点所属的簇依赖于数据点的访问顺序。一般来说只有很少的边界点，这种对访问顺序的轻度依赖并不重要。</strong></p><p>我们将DBSCAN应用于演示凝聚聚类的模拟数据集。与凝聚聚类类似，DBSCAN也不允许对新的测试数据进行预测，所以我们将使用<code>fit_predict</code>方法来执行聚类并返回簇标签。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.cluster.dbscan" target="_blank" rel="noopener"><code>class sklearn.cluster.DBSCAN(eps=0.5, min_samples=5, metric=’euclidean’, metric_params=None, algorithm=’auto’, leaf_size=30, p=None, n_jobs=None)</code></a></p><p>Perform DBSCAN clustering from vector array or distance matrix.</p><p>DBSCAN - Density-Based Spatial Clustering of Applications with Noise. Finds core samples of high density and expands clusters from them. Good for data which contains clusters of similar density.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> DBSCAN</span><br><span class="line"></span><br><span class="line">X, y = make_blobs(random_state=<span class="number">0</span>, n_samples=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">dbscan = DBSCAN()</span><br><span class="line">clusters = dbscan.fit_predict(X)</span><br><span class="line">print(<span class="string">'Cluster memberships:\n&#123;&#125;'</span>.format(clusters))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cluster memberships:</span><br><span class="line">[-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1]</span><br></pre></td></tr></table></figure><p>所有数据点都被分配了标签-1，这代表噪声。这是eps和<code>min_samples</code>默认参数设置的结果，对于小型的玩具数据集并没有调节这些参数。<code>min_samples</code>和eps取不同值时的簇分类如下所示。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_dbscan()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">min_samples: 2 eps: 1.000000  cluster: [-1  0  0 -1  0 -1  1  1  0  1 -1 -1]</span><br><span class="line">min_samples: 2 eps: 1.500000  cluster: [0 1 1 1 1 0 2 2 1 2 2 0]</span><br><span class="line">min_samples: 2 eps: 2.000000  cluster: [0 1 1 1 1 0 0 0 1 0 0 0]</span><br><span class="line">min_samples: 2 eps: 3.000000  cluster: [0 0 0 0 0 0 0 0 0 0 0 0]</span><br><span class="line">min_samples: 3 eps: 1.000000  cluster: [-1  0  0 -1  0 -1  1  1  0  1 -1 -1]</span><br><span class="line">min_samples: 3 eps: 1.500000  cluster: [0 1 1 1 1 0 2 2 1 2 2 0]</span><br><span class="line">min_samples: 3 eps: 2.000000  cluster: [0 1 1 1 1 0 0 0 1 0 0 0]</span><br><span class="line">min_samples: 3 eps: 3.000000  cluster: [0 0 0 0 0 0 0 0 0 0 0 0]</span><br><span class="line">min_samples: 5 eps: 1.000000  cluster: [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1]</span><br><span class="line">min_samples: 5 eps: 1.500000  cluster: [-1  0  0  0  0 -1 -1 -1  0 -1 -1 -1]</span><br><span class="line">min_samples: 5 eps: 2.000000  cluster: [-1  0  0  0  0 -1 -1 -1  0 -1 -1 -1]</span><br><span class="line">min_samples: 5 eps: 3.000000  cluster: [0 0 0 0 0 0 0 0 0 0 0 0]</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/dbscan-different-parameters.png"></p><p>在这张图中，属于簇的点是实心的，而噪声点则显示为空心的。核心样本显示为较大的标记，而边界点则显示为较小的标记。增大eps（在图中从左到右），更多的点会被包含在一个簇中。这让簇变大，但可能也会导致多个簇合并成一个。增大<code>min_samples</code>（在图中从上到下），核心点会变得更少，更多的点被标记为噪声。</p><p>参数eps在某种程度上更加重要，因为它决定了点与点之间“接近”的含义。将eps设置的非常小，意味着没有点是核心样本，可能会导致所有点都被标记为噪声。将eps设置的非常大，可能会导致所有点形成单个簇。</p><p>设置<code>min_samples</code>主要是为了判断稀疏区域内的点被标记为异常值还是形成自己的簇。如果增大<code>min_samples</code>，任何一个包含少于<code>min_samples</code>个样本的簇现在将被标记为噪声。因此，<strong><code>min_samples</code>决定簇的最小尺寸。</strong>在上图中你可以清楚地看到这一点。</p><p><strong>虽然DBSCAN不需要显式地设置簇的个数，但设置eps可以隐式地控制找到的簇的个数。</strong>使用StandardScaler或MinMaxScaler对数据进行缩放之后，有时会更容易找到eps的较好取值，因为使用这些缩放技术将确保所有特征具有相似的范围。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X, y = make_moons(n_samples=<span class="number">200</span>, noise=<span class="number">0.05</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据缩放成平均值为0、方差为1</span></span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">scaler.fit(X)</span><br><span class="line">X_scaled = scaler.transform(X)</span><br><span class="line"></span><br><span class="line">dbscan = DBSCAN()</span><br><span class="line">clusters = dbscan.fit_predict(X_scaled)</span><br><span class="line"><span class="comment"># 绘制簇分配</span></span><br><span class="line">plt.scatter(X_scaled[:, <span class="number">0</span>], X_scaled[:, <span class="number">1</span>], c=clusters,</span><br><span class="line">    cmap=mglearn.cm2, s=<span class="number">60</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature 1'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/dbscan-on-moons.png"></p><p>由于算法找到了我们想要的簇的个数（2个），因此参数设置的效果似乎很好。如果将eps减小到0.2（默认值为0.5），我们将会得到8个簇，这显然太多了。将eps增大到0.7则会导致只有一个簇。</p><p>在使用DBSCAN时，你需要谨慎处理返回的簇分配。如果使用簇标签对另一个数据进行索引，那么使用-1表示噪声可能会产生意料之外的结果。</p><h1 id="聚类算法的对比与评估">聚类算法的对比与评估</h1><p>在应用聚类算法时，其挑战之一就是很难评估一个算法的效果好坏，也很难比较不同算法的结果。</p><h2 id="用真实值评估聚类">用真实值评估聚类</h2><p>有一些指标可用于评估聚类算法相对于真实聚类的结果，其中最重要的是<strong>调整rand指数</strong>（adjusted rand index，ARI）和<strong>归一化互信息</strong>（normalized mutual information，NMI），二者都给出了定量的度量，其最佳值为1，0表示不相关的聚类（虽然ARI可以取负值）。</p><p>下面我们使用ARI来比较k均值、凝聚聚类和DBSCAN算法。对了对比，我们还添加了将点随机分配到两个簇中的图像。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.metrics.adjusted_rand_score" target="_blank" rel="noopener"><code>sklearn.metrics.adjusted_rand_score(labels_true, labels_pred)</code></a></p><p>Rand index adjusted for chance.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics.cluster <span class="keyword">import</span> adjusted_rand_score</span><br><span class="line"></span><br><span class="line">X, y = make_moons(n_samples=<span class="number">200</span>, noise=<span class="number">0.05</span>, random_state=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 将数据缩放成平均值为0、方差为1</span></span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">scaler.fit(X)</span><br><span class="line">X_scaled = scaler.transform(X)</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(<span class="number">1</span>, <span class="number">4</span>, figsize=(<span class="number">15</span>, <span class="number">3</span>),</span><br><span class="line">    subplot_kw=&#123;<span class="string">'xticks'</span>: (), <span class="string">'yticks'</span>: ()&#125;)</span><br><span class="line"><span class="comment"># 要使用的算法</span></span><br><span class="line">algorithms = [KMeans(n_clusters=<span class="number">2</span>), AgglomerativeClustering(n_clusters=<span class="number">2</span>),</span><br><span class="line">    DBSCAN() ]</span><br><span class="line"><span class="comment"># 创建一个随机的簇分配，作为参考</span></span><br><span class="line">random_state = np.random.RandomState(seed=<span class="number">0</span>)</span><br><span class="line">random_clusters = random_state.randint(low=<span class="number">0</span>, high=<span class="number">2</span>, size=len(X))</span><br><span class="line"><span class="comment"># 绘制随机分配</span></span><br><span class="line">axes[<span class="number">0</span>].scatter(X_scaled[:, <span class="number">0</span>], X_scaled[:, <span class="number">1</span>], c=random_clusters,</span><br><span class="line">    cmap=mglearn.cm3, s=<span class="number">60</span>)</span><br><span class="line">axes[<span class="number">0</span>].set_title(<span class="string">'Random assignment - ARI: &#123;:.2f&#125;'</span>.format(</span><br><span class="line">    adjusted_rand_score(y, random_clusters)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax, algorithm <span class="keyword">in</span> zip(axes[<span class="number">1</span>:], algorithms):</span><br><span class="line">    clusters = algorithm.fit_predict(X_scaled)</span><br><span class="line">    ax.scatter(X_scaled[:, <span class="number">0</span>], X_scaled[:, <span class="number">1</span>], c=clusters,</span><br><span class="line">    cmap=mglearn.cm3, s=<span class="number">60</span>)</span><br><span class="line">    ax.set_title(<span class="string">'&#123;&#125; - ARI: &#123;:.2f&#125;'</span>.format(</span><br><span class="line">        algorithm.__class__.__name__, adjusted_rand_score(y, clusters)))</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/ari-of-kmeans-agglomerative-clustering-and-dbscan.png"></p><p>ARI给出了符合直觉的结果，随机簇分配的分数为0，而DBSCAN（完美地找到了期望中的簇）的分数为1。</p><p>用这种方式评估聚类时，一个常见的错误是使用<code>accuracy_score</code>而不是<code>adjusted_rand_score</code>、<code>normalized_mutual_info_score</code>或其他聚类指标。<strong>使用精度的问题在于，它要求分配的簇标签与真实值完全匹配。但簇标签本身毫无意义——唯一重要的是哪些点位于同一个簇中。</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这两种点标签对应于相同的聚类</span></span><br><span class="line">clusters1 = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">clusters2 = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Accuracy: &#123;:.2f&#125;'</span>.format(accuracy_score(clusters1, clusters2)))</span><br><span class="line">print(<span class="string">'ARI: &#123;:.2f&#125;'</span>.format(adjusted_rand_score(clusters1, clusters2)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accuracy: 0.00</span><br><span class="line">ARI: 1.00</span><br></pre></td></tr></table></figure><h2 id="在没有真实值的情况下评估聚类">在没有真实值的情况下评估聚类</h2><p>在实践中，使用诸如ARI之类的指标有一个很大的问题。<strong>在应用聚类算法时，通常没有真实值来比较结果。</strong>如果我们知道了数据的正确聚类，那么可以使用这一信息构建一个监督模型（比如分类器）。因此，使用类似ARI和NMI的指标通常仅有助于开发算法，但对评估应用是否成功没有帮助。</p><p>有一些聚类的评分指标不需要真实值，比如<strong>轮廓系数</strong>（silhouette coefficient）。但它们在实践中的效果并不好。轮廓分数计算一个簇的紧致度，其值越大越好，最高分数为1。<strong>虽然紧致的簇很好，但紧致度不允许复杂的形状。</strong></p><p>下面是一个例子，利用轮廓分数在<code>two_moons</code>数据集上比较k均值、凝聚聚类和DBSCAN。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.metrics.silhouette_score" target="_blank" rel="noopener"><code>sklearn.metrics.silhouette_score(X, labels, metric=’euclidean’, sample_size=None, random_state=None, **kwds)</code></a></p><p>Compute the mean Silhouette Coefficient of all samples.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics.cluster <span class="keyword">import</span> silhouette_score</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(<span class="number">1</span>, <span class="number">4</span>, figsize=(<span class="number">15</span>, <span class="number">3</span>),</span><br><span class="line">    subplot_kw=&#123;<span class="string">'xticks'</span>: (), <span class="string">'yticks'</span>: ()&#125;)</span><br><span class="line"><span class="comment"># 绘制随机分配</span></span><br><span class="line">axes[<span class="number">0</span>].scatter(X_scaled[:, <span class="number">0</span>], X_scaled[:, <span class="number">1</span>], c=random_clusters,</span><br><span class="line">    cmap=mglearn.cm3, s=<span class="number">60</span>)</span><br><span class="line">axes[<span class="number">0</span>].set_title(<span class="string">'Random assignment: &#123;:.2f&#125;'</span>.format(</span><br><span class="line">    silhouette_score(X_scaled, random_clusters)))</span><br><span class="line"><span class="keyword">for</span> ax, algorithm <span class="keyword">in</span> zip(axes[<span class="number">1</span>:], algorithms):</span><br><span class="line">    clusters = algorithm.fit_predict(X_scaled)</span><br><span class="line">    ax.scatter(X_scaled[:, <span class="number">0</span>], X_scaled[:, <span class="number">1</span>], c=clusters,</span><br><span class="line">    cmap=mglearn.cm3, s=<span class="number">60</span>)</span><br><span class="line">    ax.set_title(<span class="string">'&#123;&#125;: &#123;:.2f&#125;'</span>.format(</span><br><span class="line">        algorithm.__class__.__name__, silhouette_score(X_scaled, clusters)))</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/silhouette-score-of-kmeans-agglomerative-clustering-and-dbscan.png"></p><p>k均值的轮廓分数最高，尽管我们可能更喜欢DBSCAN的结果。对于评估聚类，稍好的策略是使用<strong>基于鲁棒性的</strong>（robustness-based）聚类指标。这种指标优先向数据中添加一些噪声，或者使用不同的参数设定，然后运行算法，并对结果进行比较。其思想是，如果许多算法参数和许多数据扰动返回相同的结果，那么它很可能是可信的。不幸的是，<code>scikit-learn</code>还没有实现这一策略。</p><p>即使我们得到一个鲁棒性很好的聚类或者非常高的轮廓分数，但仍然不知道聚类中是否有任何语义含义，或者聚类是否反映了数据中我们感兴趣的某个方面。回到人脸图像的例子。我们希望找到类似人脸的分组，比如男人和女人、老人和年轻人，或者有胡子的人和没胡子的人。假设我们将数据分为两个簇，关于哪些点应该被聚类在一起，所有算法的结果一致。我们仍不知道找到的簇是否以某种方式对应我们感兴趣的概念。算法找到的可能是侧视图和正面视图、夜间拍摄的照片和白天拍摄的照片，或者iPhone拍摄的照片和安卓手机拍摄的照片。要想知道聚类是否对应于我们感兴趣的内容，唯一的办法就是对簇进行人工分析。</p><h2 id="在人脸数据集上比较算法">在人脸数据集上比较算法</h2><h3 id="用dbscan分析">用DBSCAN分析</h3><p>将k均值、DBSCAN和凝聚聚类算法应用于人脸数据集，并查看它们是否找到了有趣的结构。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从数据中提取特征脸，并对数组进行变换</span></span><br><span class="line">pca = PCA(n_components=<span class="number">100</span>, whiten=<span class="literal">True</span>, random_state=<span class="number">0</span>)</span><br><span class="line">X_pca = pca.fit_transform(X_people)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用默认参数的DBSCAN</span></span><br><span class="line">dbscan = DBSCAN()</span><br><span class="line">labels = dbscan.fit_predict(X_pca)</span><br><span class="line">print(<span class="string">'Unique labels: &#123;&#125;'</span>.format(np.unique(labels)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Unique labels: [-1]</span><br></pre></td></tr></table></figure><p>所有返回的标签都是-1，因此所有数据都被标记为“噪声”。我们可以改变两个参数来改进这一点：第一，我们可以增大eps，从而扩展每个点的邻域；第二，我们可以减小<code>min_samples</code>，从而将更小的点组视为簇。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 尝试改变min_samples</span></span><br><span class="line">dbscan = DBSCAN(min_samples=<span class="number">3</span>)</span><br><span class="line">labels = dbscan.fit_predict(X_pca)</span><br><span class="line">print(<span class="string">'Unique labels: &#123;&#125;'</span>.format(np.unique(labels)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Unique labels: [-1]</span><br></pre></td></tr></table></figure><p>即使仅考虑由三个点构成的组，所有点也都被标记为噪声。因此我们需要增大eps。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dbscan = DBSCAN(min_samples=<span class="number">3</span>, eps=<span class="number">15</span>)</span><br><span class="line">labels = dbscan.fit_predict(X_pca)</span><br><span class="line">print(<span class="string">'Unique labels: &#123;&#125;'</span>.format(np.unique(labels)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Unique labels: [-1  0]</span><br></pre></td></tr></table></figure><p>使用更大的eps，我们得到了单一簇和噪声点。我们可以利用这一结果找出“噪声”相对于其他数据的形状。为了进一步理解发生的事情，我们查看有多少点是噪声，有多少点在簇内。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算所有簇中的点数和噪声中的点数</span></span><br><span class="line"><span class="comment"># bincount不允许负值，所以我们需要加1</span></span><br><span class="line"><span class="comment"># 结果中的第一个数字对应于噪声点</span></span><br><span class="line">print(<span class="string">'Number of points per cluster: &#123;&#125;'</span>.format(np.bincount(labels + <span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line">noise = X_people[labels == <span class="number">-1</span>]</span><br><span class="line">fig, axes = plt.subplots(<span class="number">3</span>, <span class="number">11</span>, figsize=(<span class="number">12</span>, <span class="number">4</span>),</span><br><span class="line">    subplot_kw=&#123;<span class="string">'xticks'</span>: (), <span class="string">'yticks'</span>: (), <span class="string">'frameon'</span>: <span class="literal">False</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> image, ax <span class="keyword">in</span> zip(noise, axes.ravel()):</span><br><span class="line">    ax.imshow(image.reshape(image_shape), vmin=<span class="number">0</span>, vmax=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Number of points per cluster: [  32 2031]</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/noise-in-dbscan.png"></p><p>我们可以猜测它们被标记为噪声的原因：第2行第3张图像显示一个人正在用玻璃杯喝水，还有人戴帽子，人脸前面有一只手的图像。其他图像都包含奇怪的角度，或者太近或太宽的剪切。这种类型的分析——尝试找出“奇怪的哪一个”——被称为<strong>异常值检测</strong>（outlier detection）。如果这是一个真实的应用，那么我们可能会尝试更好地裁切图像，以得到更加均匀的数据。对于照片中的人有时戴着帽子、喝水或在面前举着某物，我们能做的事情很少。但需要知道它们是数据中存在的问题，我们应用任何算法都需要解决这些问题。</p><p>如果我们想要找到更有趣的簇，而不是一个非常大的簇，那么需要将eps设置的很小，取值在15和0.5（默认值）之间。我们来看一下eps不同取值对应的结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> eps <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>]:</span><br><span class="line">    print(<span class="string">'\neps=&#123;&#125;'</span>.format(eps))</span><br><span class="line">    dbscan = DBSCAN(eps=eps, min_samples=<span class="number">3</span>)</span><br><span class="line">    labels = dbscan.fit_predict(X_pca)</span><br><span class="line">    print(<span class="string">'Clusters present: &#123;&#125;'</span>.format(np.unique(labels)))</span><br><span class="line">    print(<span class="string">'Cluster sizes: &#123;&#125;'</span>.format(np.bincount(labels + <span class="number">1</span>)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eps=1</span><br><span class="line">Clusters present: [-1]</span><br><span class="line">Cluster sizes: [2063]</span><br><span class="line"></span><br><span class="line">eps=3</span><br><span class="line">Clusters present: [-1]</span><br><span class="line">Cluster sizes: [2063]</span><br><span class="line"></span><br><span class="line">eps=5</span><br><span class="line">Clusters present: [-1]</span><br><span class="line">Cluster sizes: [2063]</span><br><span class="line"></span><br><span class="line">eps=7</span><br><span class="line">Clusters present: [-1  0  1  2  3  4  5  6  7  8  9 10 11 12]</span><br><span class="line">Cluster sizes: [2004    3   14    7    4    3    3    4    4    3    3    5    3    3]</span><br><span class="line"></span><br><span class="line">eps=9</span><br><span class="line">Clusters present: [-1  0  1  2]</span><br><span class="line">Cluster sizes: [1307  750    3    3]</span><br><span class="line"></span><br><span class="line">eps=11</span><br><span class="line">Clusters present: [-1  0]</span><br><span class="line">Cluster sizes: [ 413 1650]</span><br><span class="line"></span><br><span class="line">eps=13</span><br><span class="line">Clusters present: [-1  0]</span><br><span class="line">Cluster sizes: [ 120 1943]</span><br></pre></td></tr></table></figure><p>对于较小的eps，所有点都被标记为噪声。eps=7时，我们得到许多噪声点和许多较小的簇。eps=9时，我们仍得到许多噪声点，但我们得到了一个较大的簇和一些较小的簇。从eps=11开始，我们仅得到一个较大的簇和噪声。</p><p>有趣的是，<strong>较大的簇从来没有超过一个。最多有一个较大的簇包含大多数点，还有一些较小的簇。这表示数据中没有两类或三类非常不同的人脸图像，而是所有图像或多或少地都与其他图像具有相同的相似度（或不相似度）。</strong></p><p>eps=7的结果看起来最有趣，它有许多较小的簇。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dbscan = DBSCAN(min_samples=<span class="number">3</span>, eps=<span class="number">7</span>)</span><br><span class="line">labels = dbscan.fit_predict(X_pca)</span><br><span class="line"></span><br><span class="line">n_clusters = max(labels) + <span class="number">1</span></span><br><span class="line">masks = [labels == i <span class="keyword">for</span> i <span class="keyword">in</span> range(n_clusters)]</span><br><span class="line">n_cols = max(np.sum(mask) <span class="keyword">for</span> mask <span class="keyword">in</span> masks)</span><br><span class="line"></span><br><span class="line">content = []</span><br><span class="line">i = j = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> mask <span class="keyword">in</span> masks:</span><br><span class="line">    <span class="keyword">if</span> n_cols - j - <span class="number">1</span> &lt; np.sum(mask):</span><br><span class="line">        i, j = i + <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> image, label <span class="keyword">in</span> zip(X_people[mask], y_people[mask]):</span><br><span class="line">        content.append((image, label, i, j))</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">n_rows = i + <span class="number">1</span></span><br><span class="line">fig, axes = plt.subplots(n_rows, n_cols,</span><br><span class="line">    figsize=(n_cols * <span class="number">1.5</span>, n_rows * <span class="number">2</span>),</span><br><span class="line">    subplot_kw=&#123;<span class="string">'xticks'</span>: (), <span class="string">'yticks'</span>: (), <span class="string">'frameon'</span>: <span class="literal">False</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> image, label, i, j <span class="keyword">in</span> content:</span><br><span class="line">    ax = axes[i, j]</span><br><span class="line">    ax.imshow(image.reshape(image_shape), vmin=<span class="number">0</span>, vmax=<span class="number">1</span>)</span><br><span class="line">    ax.set_title(people.target_names[label].split()[<span class="number">-1</span>])</span><br><span class="line">plt.tight_layout()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/clusters-of-7-eps-dbscan.png"></p><p>有一些簇对应于数据集中脸部非常不同的人，比如Sharon（沙龙）或Koizumi（小泉）。在每个簇中，人脸方向和面部表情也是固定的。有些簇中包含多个人的面孔，但他们的表情和方向都相似。</p><p>这就是将DBSCAN算法应用于人脸数据集的分析结论。如你所见，我们这里进行了人工分析，不同于监督学习中基于<span class="math inline">\(R^2\)</span>分数或精度的更为自动化的方法。</p><h3 id="用k均值分析">用k均值分析</h3><p>我们看到，利用DBSCAN无法创建多于一个较大的簇。凝聚聚类和k均值更可能创建君悦大小的簇，但我们需要设置簇的目标个数。我们可以将簇的数量设置为数据集中的已知人数，虽然无监督聚类算法不太可能完全找到它们。相反，我们可以首先设置一个比较小的簇的数量，比如10个，这样我们可以分析每个簇。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用k均值提取簇</span></span><br><span class="line">km = KMeans(n_clusters=<span class="number">10</span>, random_state=<span class="number">0</span>)</span><br><span class="line">labels_km = km.fit_predict(X_pca)</span><br><span class="line">print(<span class="string">'Cluster sizes k-means: &#123;&#125;'</span>.format(np.bincount(labels_km)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cluster sizes k-means: [155 175 238  75 358 257  91 219 323 172]</span><br></pre></td></tr></table></figure><p>k均值聚类将数据划分成大小相似的簇，其大小在75和358之间。这与DBSCAN的结果非常不同。我们可以通过将簇中心可视化来进一步分析k均值的结果。由于我们是在PCA生成的表示中进行聚类，因此我们需要使用<code>pca.inverse_transform</code>将簇中心旋转回到原始空间并可视化。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">5</span>, figsize=(<span class="number">12</span>, <span class="number">4</span>),</span><br><span class="line">    subplot_kw=&#123;<span class="string">'xticks'</span>: (), <span class="string">'yticks'</span>: ()&#125;)</span><br><span class="line"><span class="keyword">for</span> center, ax <span class="keyword">in</span> zip(km.cluster_centers_, axes.ravel()):</span><br><span class="line">    ax.imshow(pca.inverse_transform(center).reshape(image_shape),</span><br><span class="line">        vmin=<span class="number">0</span>, vmax=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/cluster-centers-of-kmeans-faces.png"></p><p>k均值找到的簇中心是非常平滑的人脸。这并不奇怪，因为每个簇中心都是许多张人脸图像的平均。使用降维的PCA表示，可以增加图像的平滑度（对比利用100个PCA维度重建的人物图像）。聚类似乎捕捉到人脸的不同方向（下图的第7个簇）、不同表情（下图的第4个簇）。下图给出了更详细的视图，我们对每个簇中心给出了簇中5张最典型的图像（该簇中与簇中心距离最近的图像）与5张最不典型的图像（该簇中与簇中心距离最远的图像）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_kmeans_faces(km, pca, X_pca, X_people, y_people,</span><br><span class="line">    people.target_names)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/kmeans-faces-close-and-far.png"></p><p>“非典型的”点与簇中心不太相似，而且它们的分配似乎有些随意。这可以归因于以下事实：k均值对所有数据点进行划分，不像DBSCAN那样具有“噪声”点的概念。利用更多数量的簇，算法可以找到更细微的区别。但添加更多的簇会使得人工检查更加困难。</p><h3 id="用凝聚聚类分析">用凝聚聚类分析</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用ward凝聚聚类提取簇</span></span><br><span class="line">agglomerative = AgglomerativeClustering(n_clusters=<span class="number">10</span>)</span><br><span class="line">labels_agg = agglomerative.fit_predict(X_pca)</span><br><span class="line">print(<span class="string">'Cluster sizes agglomerative clustering: &#123;&#125;'</span>.format(</span><br><span class="line">    np.bincount(labels_agg)))</span><br><span class="line"><span class="comment"># 通过计算ARI来度量凝聚聚类和k均值给出的两种数据划分是否相似</span></span><br><span class="line">print(<span class="string">'ARI: &#123;:.2f&#125;'</span>.format(adjusted_rand_score(labels_agg, labels_km)))</span><br><span class="line"><span class="comment"># 绘制树状图，限制了树的深度，因为如果分支到2063个数据点，图像将密密麻麻无法阅读</span></span><br><span class="line">linkage_array = ward(X_pca)</span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>, <span class="number">5</span>))</span><br><span class="line">dendrogram(linkage_array, p=<span class="number">7</span>, truncate_mode=<span class="string">'level'</span>, no_labels=<span class="literal">True</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Sample index'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Cluster distance'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cluster sizes agglomerative clustering: [169 660 144 329 217  85  18 261  31 149]</span><br><span class="line">ARI: 0.09</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/agglomerative-clustering-dendrogram-on-faces.png"></p><p>凝聚聚类生成的簇大小在18和660之间。这比k均值生成的簇更不均匀，但比DBSCAN生成的簇要更均匀。ARI只有0.09，说明<code>labels_agg</code>和<code>labels_km</code>这两种聚类的共同点很少。这不奇怪，原因在于以下事实：对于k均值，远离簇中心的点似乎没有什么共同点。</p><p>要想创建10个簇，我们在顶部有10条竖线的位置将树横切。在图示的玩具数据的树状图中，你可以从分支长度中看出，两个或三个簇就可以很好地划分数据。对于人脸数据而言，似乎没有非常自然的切割点。有一些分支代表更为不同的组，但似乎没有一个特别合适的簇的数量。这并不奇怪，因为DBSCAN（原书可能有错误，此处应该是凝聚聚类）的结果是视图将所有点都聚类在一起。</p><p>我们将10个簇可视化，正如之前对k均值所做的那样。在凝聚聚类中没有簇中心的概念（虽然我们计算平均值），我们只是给出了每个簇的前几个点。我们在第一张图的左侧给出了每个簇中的点的数量。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n_clusters = <span class="number">10</span></span><br><span class="line">flg, axes = plt.subplots(n_clusters, <span class="number">10</span>, figsize=(<span class="number">15</span>, <span class="number">2</span> * n_clusters),</span><br><span class="line">    subplot_kw=&#123;<span class="string">'xticks'</span>: (), <span class="string">'yticks'</span>: ()&#125;)</span><br><span class="line"><span class="keyword">for</span> cluster <span class="keyword">in</span> range(n_clusters):</span><br><span class="line">    mask = labels_agg == cluster</span><br><span class="line">    axes[cluster, <span class="number">0</span>].set_ylabel(np.sum(mask))</span><br><span class="line">    <span class="keyword">for</span> image, label, asdf, ax <span class="keyword">in</span> zip(X_people[mask],</span><br><span class="line">            y_people[mask], labels_agg[mask], axes[cluster]):</span><br><span class="line">        ax.imshow(image.reshape(image_shape), vmin=<span class="number">0</span>, vmax=<span class="number">1</span>)</span><br><span class="line">        ax.set_title(people.target_names[label].split()[<span class="number">-1</span>],</span><br><span class="line">            fontdict=&#123;<span class="string">'fontsize'</span>: <span class="number">9</span>&#125;)</span><br><span class="line">plt.tight_layout()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/clusters-of-agglomerative-clustering.png"></p><p>虽然某些簇似乎具有语义上的主题，但许多簇都太大而实际上很难是均匀的。</p><h3 id="聚类方法小结">聚类方法小结</h3><p>聚类的应用与评估是一个非常定性的过程，通常在数据分析的探索阶段很有帮助。我们学习了三种聚类算法：k均值、DBSCAN和凝聚聚类。这三种算法都可以控制聚类的粒度（granularity）。k均值和凝聚聚类允许你指定想要的簇的数量，而DBSCAN允许你用eps参数定义接近程度，从而间接影响簇的大小。</p><p>每种算法的优点稍有不同。k均值可以用簇的平均值来表示簇。它还可以被看作一种分解方法，每个数据点都由其簇中心表示。DBSCAN可以检测到没有分配任何簇的“噪声点”，还可以帮助自动判断簇的数量。与其他两种方法不同，它允许簇具有复杂的形状。DBSCAN有时会生成大小差别很大的簇，这可能是它的优点，也可能是缺点。凝聚聚类可以提供数据的可能划分的整个层次结构，可以通过树状图轻松查看。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Machine Learning with Python </tag>
            
            <tag> unsupervised </tag>
            
            <tag> clustering </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>降维、特征提取与流形学习</title>
      <link href="/notes/introduction-to-ml-with-python/dimensionality-reduction-feature-extraction-and-manifold-learning/"/>
      <url>/notes/introduction-to-ml-with-python/dimensionality-reduction-feature-extraction-and-manifold-learning/</url>
      
        <content type="html"><![CDATA[<p>利用无监督学习进行数据变换可能有很多种目的。最常见的目的就是可视化、压缩数据，以及寻找信息量更大的数据表示以用于进一步的处理。</p><p>为了实现这些目的，最简单也最常用的一种算法就是主成分分析。我们也将学习另外两种算法：非负矩阵分解（NMF）和t-SNE，前者通常用于特征提取，后者通常用于二维散点的可视化。</p><h1 id="主成分分析">主成分分析</h1><p>主成分分析（principal component analysis，PCA）是一种旋转数据集的方法，旋转后的特征在统计上不相关。在做完这种旋转之后，通常是根据新特征对解释数据的重要性来选择它的一个子集。下面的例子展示了PCA对一个模拟二维数据集的作用。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.decomposition.pca" target="_blank" rel="noopener"><code>class sklearn.decomposition.PCA(n_components=None, copy=True, whiten=False, svd_solver=’auto’, tol=0.0, iterated_power=’auto’, random_state=None)</code></a></p><p>Principal component analysis (PCA)</p></blockquote><a id="more"></a><h2 id="将pca应用于模拟数据">将PCA应用于模拟数据</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 函数源码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_pca_illustration</span><span class="params">()</span>:</span></span><br><span class="line">    rnd = np.random.RandomState(<span class="number">5</span>)</span><br><span class="line">    X_ = rnd.normal(size=(<span class="number">300</span>, <span class="number">2</span>))</span><br><span class="line">    X_blob = np.dot(X_, rnd.normal(size=(<span class="number">2</span>, <span class="number">2</span>))) + rnd.normal(size=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    pca = PCA()</span><br><span class="line">    pca.fit(X_blob)</span><br><span class="line">    X_pca = pca.transform(X_blob)</span><br><span class="line"></span><br><span class="line">    S = X_pca.std(axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">    axes = axes.ravel()</span><br><span class="line"></span><br><span class="line">    axes[<span class="number">0</span>].set_title(<span class="string">"Original data"</span>)</span><br><span class="line">    axes[<span class="number">0</span>].scatter(X_blob[:, <span class="number">0</span>], X_blob[:, <span class="number">1</span>], c=X_pca[:, <span class="number">0</span>], linewidths=<span class="number">0</span>,</span><br><span class="line">                    s=<span class="number">60</span>, cmap=<span class="string">'viridis'</span>)</span><br><span class="line">    axes[<span class="number">0</span>].set_xlabel(<span class="string">"feature 1"</span>)</span><br><span class="line">    axes[<span class="number">0</span>].set_ylabel(<span class="string">"feature 2"</span>)</span><br><span class="line">    axes[<span class="number">0</span>].arrow(pca.mean_[<span class="number">0</span>], pca.mean_[<span class="number">1</span>], S[<span class="number">0</span>] * pca.components_[<span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                  S[<span class="number">0</span>] * pca.components_[<span class="number">0</span>, <span class="number">1</span>], width=<span class="number">.1</span>, head_width=<span class="number">.3</span>,</span><br><span class="line">                  color=<span class="string">'k'</span>)</span><br><span class="line">    axes[<span class="number">0</span>].arrow(pca.mean_[<span class="number">0</span>], pca.mean_[<span class="number">1</span>], S[<span class="number">1</span>] * pca.components_[<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">                  S[<span class="number">1</span>] * pca.components_[<span class="number">1</span>, <span class="number">1</span>], width=<span class="number">.1</span>, head_width=<span class="number">.3</span>,</span><br><span class="line">                  color=<span class="string">'k'</span>)</span><br><span class="line">    axes[<span class="number">0</span>].text(<span class="number">-1.5</span>, <span class="number">-.5</span>, <span class="string">"Component 2"</span>, size=<span class="number">14</span>)</span><br><span class="line">    axes[<span class="number">0</span>].text(<span class="number">-4</span>, <span class="number">-4</span>, <span class="string">"Component 1"</span>, size=<span class="number">14</span>)</span><br><span class="line">    axes[<span class="number">0</span>].set_aspect(<span class="string">'equal'</span>)</span><br><span class="line"></span><br><span class="line">    axes[<span class="number">1</span>].set_title(<span class="string">"Transformed data"</span>)</span><br><span class="line">    axes[<span class="number">1</span>].scatter(X_pca[:, <span class="number">0</span>], X_pca[:, <span class="number">1</span>], c=X_pca[:, <span class="number">0</span>], linewidths=<span class="number">0</span>,</span><br><span class="line">                    s=<span class="number">60</span>, cmap=<span class="string">'viridis'</span>)</span><br><span class="line">    axes[<span class="number">1</span>].set_xlabel(<span class="string">"First principal component"</span>)</span><br><span class="line">    axes[<span class="number">1</span>].set_ylabel(<span class="string">"Second principal component"</span>)</span><br><span class="line">    axes[<span class="number">1</span>].set_aspect(<span class="string">'equal'</span>)</span><br><span class="line">    axes[<span class="number">1</span>].set_ylim(<span class="number">-8</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    pca = PCA(n_components=<span class="number">1</span>)</span><br><span class="line">    pca.fit(X_blob)</span><br><span class="line">    X_inverse = pca.inverse_transform(pca.transform(X_blob))</span><br><span class="line"></span><br><span class="line">    axes[<span class="number">2</span>].set_title(<span class="string">"Transformed data w/ second component dropped"</span>)</span><br><span class="line">    axes[<span class="number">2</span>].scatter(X_pca[:, <span class="number">0</span>], np.zeros(X_pca.shape[<span class="number">0</span>]), c=X_pca[:, <span class="number">0</span>],</span><br><span class="line">                    linewidths=<span class="number">0</span>, s=<span class="number">60</span>, cmap=<span class="string">'viridis'</span>)</span><br><span class="line">    axes[<span class="number">2</span>].set_xlabel(<span class="string">"First principal component"</span>)</span><br><span class="line">    axes[<span class="number">2</span>].set_aspect(<span class="string">'equal'</span>)</span><br><span class="line">    axes[<span class="number">2</span>].set_ylim(<span class="number">-8</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    axes[<span class="number">3</span>].set_title(<span class="string">"Back-rotation using only first component"</span>)</span><br><span class="line">    axes[<span class="number">3</span>].scatter(X_inverse[:, <span class="number">0</span>], X_inverse[:, <span class="number">1</span>], c=X_pca[:, <span class="number">0</span>],</span><br><span class="line">                    linewidths=<span class="number">0</span>, s=<span class="number">60</span>, cmap=<span class="string">'viridis'</span>)</span><br><span class="line">    axes[<span class="number">3</span>].set_xlabel(<span class="string">"feature 1"</span>)</span><br><span class="line">    axes[<span class="number">3</span>].set_ylabel(<span class="string">"feature 2"</span>)</span><br><span class="line">    axes[<span class="number">3</span>].set_aspect(<span class="string">'equal'</span>)</span><br><span class="line">    axes[<span class="number">3</span>].set_xlim(<span class="number">-8</span>, <span class="number">4</span>)</span><br><span class="line">    axes[<span class="number">3</span>].set_ylim(<span class="number">-8</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">mglearn.plots.plot_pca_illustration()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/pca.png"></p><p>算法首先找到方法最大的方向，将其标记为“成分1”（Component 1）。这是数据中包含最多信息的方向（或向量），换句话说，沿着这个方向的特征之间最为相关。然后，算法找到与第一个方向正交（成直角）且包含最多信息的方向。在二维空间中，只有一个成直角的方向，但在更高维的空间中会有（无穷）多的正交方向。虽然这两个成分都画成箭头，但其头尾的位置并不重要。我们也可以将第一个成分化成从中心指向左上，而不是右下。利用这一过程找到的方向被称为主成分，因为它们是数据方差的主要方向。一般来说，主成分的个数与原始特征相同。</p><p>第二张图（右上）显示的是同样的数据，但现在将其旋转，使得第一主成分与x轴平行且第二主成分与y轴平行。在旋转之前，从数据中减去平均值，使得变换后的数据以零为中心。在PCA找到的旋转表示中，两个坐标轴是不相关的，也就是说，对于这种数据表示，除了对角线，相关矩阵全部为零。</p><p>我们可以通过仅保留一部分主成分来使用PCA进行降维。在这个例子中，我们可以仅保留第一主成分，正如第三张图（左下）所示。这将数据从二维数据集降为一维数据集。但要注意，我们没有保留原始特征之一，而是找到了最有趣的方向（第一张图中从左上到右下）并保留这一方向，即第一主成分。</p><p>最后，我们可以反向旋转并将平均值重新加到数据集中。这样会得到最后一张图中的数据。这些数据点位于原始特征空间中，但我们仅保留了第一主成分中包含的信息。这种变换有时用于去除数据中的噪声影响，或者将主成分中保留的那部分信息可视化。</p><h2 id="将pca应用于cancer数据集并可视化">将PCA应用于cancer数据集并可视化</h2><p>PCA最常见的应用之一就是将高维数据可视化。对于有两个以上特征的数据，很难绘制散点图。对于Iris（鸢尾花）数据集，我们可以创建散点图矩阵，通过展示特征所有可能的两两组和来展示数据的局部图像。但如果我们想要查看乳腺癌数据集，即便用散点图矩阵也很困难。这个数据集包含30个特征，这就导致需要绘制<code>30*14=420</code>张散点图！我们永远不可能仔细观察所有这些图像，更不用说试图理解它们了。</p><p>不过我们可以使用一种更简单的可视化方法——对每个特征分别计算两个类别（良性肿瘤和恶性肿瘤）的直方图。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, axes = plt.subplots(<span class="number">15</span>, <span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">20</span>))</span><br><span class="line">malignant = cancer.data[cancer.target == <span class="number">0</span>]</span><br><span class="line">benign = cancer.data[cancer.target == <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">ax = axes.ravel()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">    _, bins = np.histogram(cancer.data[:, i], bins=<span class="number">50</span>)</span><br><span class="line">    ax[i].hist(malignant[:, i], bins=bins, color=mglearn.cm3(<span class="number">0</span>), alpha=<span class="number">.5</span>)</span><br><span class="line">    ax[i].hist(benign[:, i], bins=bins, color=mglearn.cm3(<span class="number">2</span>), alpha=<span class="number">.5</span>)</span><br><span class="line">    ax[i].set_title(cancer.feature_names[i])</span><br><span class="line">    ax[i].set_yticks(())</span><br><span class="line"></span><br><span class="line">ax[<span class="number">0</span>].set_xlabel(<span class="string">'Feature magnitude'</span>)</span><br><span class="line">ax[<span class="number">0</span>].set_ylabel(<span class="string">'Frequency'</span>)</span><br><span class="line">ax[<span class="number">0</span>].legend([<span class="string">'malignant'</span>, <span class="string">'benign'</span>], loc=<span class="string">'best'</span>)</span><br><span class="line">fig.tight_layout()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/feature-hist.png"></p><p>这里我们为每个特征创建一个直方图，计算具有某一特征的数据点在特定范围内（叫作bin）的出现频率。每张图都包含两个直方图，一个是良性类别的所有点（蓝色），一个是恶性类别的所有点（红色）。这样我们可以了解每个特征在两个类别中的分布情况，也可以猜测哪些特征能够更好地区分良性样本和恶性样本。例如，“smoothness error”特征似乎没有什么信息量，因为两个直方图大部分都重叠在一起，而“worst concave points”特征看起来信息量相当大，因为两个直方图的交集很小。</p><p>但是，这种图无法向我们展示变量之间的相互作用以及这种相互作用与类别之间的关系。<strong>利用PCA，我们可以获取到主要的相互作用，并得到稍为完整的图像。</strong>我们可以找到前两个主成分，并在这个新的二维空间中用散点图将数据可视化。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在应用PCA之前，利用StandardScaler缩放数据，使每个特征的方差均为1</span></span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">scaler.fit(cancer.data)</span><br><span class="line">X_scaled = scaler.transform(cancer.data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留数据的前两个主要成分</span></span><br><span class="line">pca = PCA(n_components=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 对乳腺癌数据拟合PCA模型</span></span><br><span class="line">pca.fit(X_scaled)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据变换到前两个主要成分上</span></span><br><span class="line">X_pca = pca.transform(X_scaled)</span><br><span class="line">print(<span class="string">'Original shape: &#123;&#125;'</span>.format(str(X_scaled.shape)))</span><br><span class="line">print(<span class="string">'Reduced shape: &#123;&#125;'</span>.format(str(X_pca.shape)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对第一个和第二个主成分作图，按类别着色</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">mglearn.discrete_scatter(X_pca[:, <span class="number">0</span>], X_pca[:, <span class="number">1</span>], cancer.target)</span><br><span class="line">plt.legend(cancer.target_names, loc=<span class="string">'best'</span>)</span><br><span class="line">plt.gca().set_aspect(<span class="string">'equal'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'First principal component'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Second principal component'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Original shape: (569, 30)</span><br><span class="line">Reduced shape: (569, 2)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/pca-on-cancer.png"></p><p>重要的是要注意，PCA是一种无监督方法，在寻找旋转方向时没有用到任何类别信息。它只是观察数据中的相关性。对于这里所示的散点图，我们绘制了第一主成分和第二主成分之间的关系，然后利用类别信息对数据点进行着色。你可以看到，在这个二维空间中两个类别被很好的分离。这让我们相信，即使是线性分类器（在这个空间中学习一条直线）也可以在区分这两个类别时表现得相当不错。我们还可以看到，恶性点比良性点更加分散，这一点也可以在直方图中看出来。</p><p>PCA的一个缺点在于，通常不容易对图中的两个轴做出解释。主成分对应于原始数据中的方向，所以它们是原始特征的组合。但这些组合往往非常复杂，这一点我们很快就会看到。在拟合过程中，主成分被保存在PCA对象的<code>components_</code>属性中。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'PCA component shape: &#123;&#125;'</span>.format(pca.components_.shape))</span><br><span class="line">print(<span class="string">'PCA components:\n&#123;&#125;'</span>.format(pca.components_))</span><br><span class="line"><span class="comment"># 用热图将系数可视化</span></span><br><span class="line">plt.matshow(pca.components_, cmap=<span class="string">'viridis'</span>)</span><br><span class="line">plt.yticks([<span class="number">0</span>, <span class="number">1</span>], [<span class="string">'First component'</span>, <span class="string">'Second component'</span>])</span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.xticks(range(len(cancer.feature_names)),</span><br><span class="line">    cancer.feature_names, rotation=<span class="number">60</span>, ha=<span class="string">'left'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Feature'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Principal components'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PCA component shape: (2, 30)</span><br><span class="line">PCA components:</span><br><span class="line">[[ 0.21890244  0.10372458  0.22753729  0.22099499  0.14258969  0.23928535</span><br><span class="line">   0.25840048  0.26085376  0.13816696  0.06436335  0.20597878  0.01742803</span><br><span class="line">   0.21132592  0.20286964  0.01453145  0.17039345  0.15358979  0.1834174</span><br><span class="line">   0.04249842  0.10256832  0.22799663  0.10446933  0.23663968  0.22487053</span><br><span class="line">   0.12795256  0.21009588  0.22876753  0.25088597  0.12290456  0.13178394]</span><br><span class="line"> [-0.23385713 -0.05970609 -0.21518136 -0.23107671  0.18611302  0.15189161</span><br><span class="line">   0.06016536 -0.0347675   0.19034877  0.36657547 -0.10555215  0.08997968</span><br><span class="line">  -0.08945723 -0.15229263  0.20443045  0.2327159   0.19720728  0.13032156</span><br><span class="line">   0.183848    0.28009203 -0.21986638 -0.0454673  -0.19987843 -0.21935186</span><br><span class="line">   0.17230435  0.14359317  0.09796411 -0.00825724  0.14188335  0.27533947]]</span><br></pre></td></tr></table></figure><p><code>components_</code>中的每一行对应于一个主成分，它们按重要性排序（第一主成分排在首位，以此类推）。列对应于PCA的原始特征属性。</p><p><img src="/uploads/image/introduction-to-ml-with-python/2-principal-components-of-cancer.png"></p><p>在第一个主成分中，<strong>所有特征的符号相同（均为正，但前面我们提到过，箭头指向哪个方向无关紧要）。这意味着在所有特征之间存在普遍的相关性。</strong>如果一个测量值较大的话，其他的测量值可能也较大。第二个主成分的符号有正有负，而且两个主成分都包含30个特征。这种所有特征的混合使得解释上图中的坐标轴变得十分困难。</p><h2 id="特征提取的特征脸">特征提取的特征脸</h2><p>PCA的另一个应用是特征提取。特征提取背后的思想是，可以找到一种数据表示，比给定的原始表示更适合于分析。特征提取很有用，它的一个很好的应用实例就是图像。图像由像素组成，通常存储为红绿蓝（RGB）强度。图像中的对象通常由千万个像素组成，它们只有放在一起才有意义。</p><p>我们将给出用PCA对图像做特征提取的一个简单应用，即处理Wild数据集Labeled Faces中的人脸图像。这一数据集包含从互联网下载的名人脸部图像，它包含从21世纪初开始的政治家、歌手、演员和运动员的人脸图像。我们使用这些图像的灰度版本，并将它们按比例缩小以加快处理速度。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_lfw_people</span><br><span class="line"></span><br><span class="line">people = fetch_lfw_people(min_faces_per_person=<span class="number">20</span>, resize=<span class="number">.7</span>)</span><br><span class="line">image_shape = people.images[<span class="number">0</span>].shape</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">5</span>, figsize=(<span class="number">15</span>, <span class="number">8</span>),</span><br><span class="line">    subplot_kw=&#123;<span class="string">'xticks'</span>: (), <span class="string">'yticks'</span>: ()&#125;)</span><br><span class="line"><span class="keyword">for</span> target, image, ax <span class="keyword">in</span> zip(people.target, people.images, axes.ravel()):</span><br><span class="line">    ax.imshow(image, cmap=plt.cm.gray_r)</span><br><span class="line">    ax.set_title(people.target_names[target])</span><br><span class="line"></span><br><span class="line">print(<span class="string">'people.images.shape: &#123;&#125;'</span>.format(people.images.shape))</span><br><span class="line">print(<span class="string">'Number of classes: &#123;&#125;'</span>.format(len(people.target_names)))</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/datasets-lfw-people.png"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">people.images.shape: (3023, 87, 65)  # 一共有3023张图像，每张大小为87像素x65像素</span><br><span class="line">Number of classes: 62  # 分别属于62个不同的人</span><br></pre></td></tr></table></figure><p>这个数据集有些偏斜，其中包含George W. Bush（小布什）和Colin Powell（科林·鲍威尔）的大量图像。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算每个目标出现的次数</span></span><br><span class="line">counts = np.bincount(people.target)</span><br><span class="line"><span class="comment"># 将次数与目标名称一起打印出来</span></span><br><span class="line"><span class="keyword">for</span> i, (count, name) <span class="keyword">in</span> enumerate(zip(counts, people.target_names)):</span><br><span class="line">    print(<span class="string">'&#123;0:25&#125; &#123;1:3&#125;'</span>.format(name, count), end=<span class="string">'    '</span>)</span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">        print()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alejandro Toledo           39    Alvaro Uribe               35    Amelie Mauresmo            21</span><br><span class="line">Andre Agassi               36    Angelina Jolie             20    Ariel Sharon               77</span><br><span class="line">Arnold Schwarzenegger      42    Atal Bihari Vajpayee       24    Bill Clinton               29</span><br><span class="line">Carlos Menem               21    Colin Powell              236    David Beckham              31</span><br><span class="line">Donald Rumsfeld           121    George Robertson           22    George W Bush             530</span><br><span class="line">Gerhard Schroeder         109    Gloria Macapagal Arroyo    44    Gray Davis                 26</span><br><span class="line">Guillermo Coria            30    Hamid Karzai               22    Hans Blix                  39</span><br><span class="line">Hugo Chavez                71    Igor Ivanov                20    Jack Straw                 28</span><br><span class="line">Jacques Chirac             52    Jean Chretien              55    Jennifer Aniston           21</span><br><span class="line">Jennifer Capriati          42    Jennifer Lopez             21    Jeremy Greenstock          24</span><br><span class="line">Jiang Zemin                20    John Ashcroft              53    John Negroponte            31</span><br><span class="line">Jose Maria Aznar           23    Juan Carlos Ferrero        28    Junichiro Koizumi          60</span><br><span class="line">Kofi Annan                 32    Laura Bush                 41    Lindsay Davenport          22</span><br><span class="line">Lleyton Hewitt             41    Luiz Inacio Lula da Silva  48    Mahmoud Abbas              29</span><br><span class="line">Megawati Sukarnoputri      33    Michael Bloomberg          20    Naomi Watts                22</span><br><span class="line">Nestor Kirchner            37    Paul Bremer                20    Pete Sampras               22</span><br><span class="line">Recep Tayyip Erdogan       30    Ricardo Lagos              27    Roh Moo-hyun               32</span><br><span class="line">Rudolph Giuliani           26    Saddam Hussein             23    Serena Williams            52</span><br><span class="line">Silvio Berlusconi          33    Tiger Woods                23    Tom Daschle                25</span><br><span class="line">Tom Ridge                  33    Tony Blair                144    Vicente Fox                32</span><br><span class="line">Vladimir Putin             49    Winona Ryder               24</span><br></pre></td></tr></table></figure><p>为了降低数据偏斜，我们对每个人最多只取50张图像（否则，特征提取将会被George w. Bush影响的可能性大大增加）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mask = np.zeros(people.target.shape, dtype=np.bool)</span><br><span class="line"><span class="keyword">for</span> target <span class="keyword">in</span> np.unique(people.target):</span><br><span class="line">    mask[np.where(people.target == target)[<span class="number">0</span>][:<span class="number">50</span>]] = <span class="number">1</span>  <span class="comment"># 各取前50个</span></span><br><span class="line"></span><br><span class="line">X_people = people.data[mask]</span><br><span class="line">y_people = people.target[mask]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将灰度值缩放到0到1之间，而不是在0到255之间</span></span><br><span class="line"><span class="comment"># 以得到更好的数据稳定性</span></span><br><span class="line">X_people = X_people / <span class="number">255</span></span><br></pre></td></tr></table></figure><p>人脸识别的一个常见任务就是看某个前所未见的人脸是否属于数据库中某个已知人物。这在照片收集、社交媒体和安全应用中都有应用。<strong>解决这个问题的方法之一就是构建一个分类器，每个人都是一个单独的类别。但人脸数据库中通常有许多不同的人，而同一个人的图像很少（也就是说，每个类别的训练样例很少）。这使得大多数分类器的训练都很困难。另外，通常你还想要能够轻松添加新的人物，不需要重新训练一个大型模型。</strong></p><p><strong>一种简单的解决方法是使用单一最近邻分类器，寻找与你要分类的人脸最为相似的人脸。这个分类器原则上可以处理每个类别只有一个训练样例的情况。</strong>下面看一下<code>KNeighborsClassifier</code>的表现如何。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将数据划分为训练集和测试集</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">    X_people, y_people, stratify=y_people, random_state=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 使用一个邻居构建</span></span><br><span class="line">knn = KNeighborsClassifier(n_neighbors=<span class="number">1</span>)</span><br><span class="line">knn.fit(X_train, y_train)</span><br><span class="line">print(<span class="string">'Test set score of 1-nn: &#123;:.2f&#125;'</span>.format(knn.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test set score of 1-nn: 0.23</span><br></pre></td></tr></table></figure><p>我们得到的精度为23%。对于包含62个类别的分类问题来说，这实际上不算太差，但也不算好。</p><p>这里就可以用到PCA。<strong>想要度量人脸的相似度，计算原始像素空间中的距离是一种相当糟糕的方法。用像素表示来比较两张图时，我们比较的是每个像素的灰度值与另一张图像对应位置的像素灰度值。这种表示与人们对人脸图像的解释方式有很大不同，使用这种原始表示很难获取到面部特征。例如，如果使用像素距离，那么将人脸向右移动一个像素将会发生巨大的变化，得到一个完全不同的表示。</strong>我们希望，使用沿着主成分方向的距离可以提高精度。这里我们启动PCA的<strong>白化</strong>（whitening）选项，它将主成分缩放到相同的尺度。变换后的结果与使用<code>StandardScaler</code>相同。白化不仅对应于旋转数据，还对应于缩放数据使其形状是圆形而不是椭圆。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_pca_whitening()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/pca-whitening.png"></p><p>我们对训练数据拟合PCA对象，并提取前100个主成分。然后对训练数据和测试数据进行变换。再对新表示使用单一最近邻分类器来将图像分类。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pca = PCA(n_components=<span class="number">100</span>, whiten=<span class="literal">True</span>, random_state=<span class="number">0</span>).fit(X_train)</span><br><span class="line">X_train_pca = pca.transform(X_train)</span><br><span class="line">X_test_pca = pca.transform(X_test)</span><br><span class="line">print(<span class="string">'X_train_pca.shape: &#123;&#125;'</span>.format(X_train_pca.shape))</span><br><span class="line"></span><br><span class="line">knn = KNeighborsClassifier(n_neighbors=<span class="number">1</span>)</span><br><span class="line">knn.fit(X_train_pca, y_train)</span><br><span class="line">print(<span class="string">'Test set accuracy: &#123;:.2f&#125;'</span>.format(knn.score(X_test_pca, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test set accuracy: 0.31</span><br></pre></td></tr></table></figure><p>我们的精度有了相当显著的提高，这证实了我们的直觉，即<strong>主成分可能提供了一种更好的数据表示。</strong></p><p><strong>对于图像数据，我们还可以很容易地将找到的主成分可视化。请记住，成分对应于输入空间里的方向。</strong>这里的输入空间是87像素x65像素的灰度图像，所以在这个空间中的方向也是87像素x65像素的灰度图像。我们来看一下前几个主成分。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'pca.components_.shape: &#123;&#125;'</span>.format(pca.components_.shape))</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(<span class="number">3</span>, <span class="number">5</span>, figsize=(<span class="number">15</span>, <span class="number">12</span>),</span><br><span class="line">    subplot_kw=&#123;<span class="string">'xticks'</span>: (), <span class="string">'yticks'</span>: ()&#125;)</span><br><span class="line"><span class="keyword">for</span> i, (component, ax) <span class="keyword">in</span> enumerate(zip(pca.components_, axes.ravel())):</span><br><span class="line">    ax.imshow(component.reshape(image_shape), cmap=<span class="string">'viridis'</span>)</span><br><span class="line">    ax.set_title(<span class="string">"&#123;&#125;. component"</span>.format(i + <span class="number">1</span>))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pca.components_.shape: (100, 5655)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/visualization-of-image-pca.png"></p><p>虽然我们肯定无法理解这些成分的所有内容，但可以猜测一些主成分捕捉到了人脸图像的哪些方面。第一个主成分似乎主要编码的是人脸与背景的对比，第二个主成分编码的是人脸左半部分和右半部分的明暗程度差异，如此等等。虽然这种表示比原始像素值的语义稍强，但它仍与人们感知人脸的方式相去甚远。<strong>由于PCA模型是基于像素的，因此人脸的相对位置（眼睛、下巴和鼻子的位置）和明暗程度都对两张图像在像素表示中的相似程度有很大印象。但人脸的相对位置和明暗程度可能并不是人们首先感知的内容。</strong>在要求人们评价人脸的相似度时，他们更可能会使用年龄、性别、面部表情和发型等属性，而这些属性很难从像素强度中推断出来。重要的是要记住，算法对数据（特别是视觉数据，比如人们非常熟悉的图像）的解释通常与人类的解释方式有很大不同。</p><p>不过让我们回到PCA的具体案例。我们对PCA变换的介绍是：先旋转数据，然后删除方差较小的成分。另一种有用的解释是尝试找到一些数字（PCA旋转后的新特征值），使我们可以将测试点表示为主成分的加权求和。</p><p><img src="/uploads/image/introduction-to-ml-with-python/break-down-image-to-weighted-summation-of-pca.png"></p><p>这里<span class="math inline">\(x_0、x_1\)</span>等是这个数据点的主成分的系数，换句话说，它们是图像在旋转后的空间中的表示。</p><p>我们还可以用另一种方法来理解PCA模型。就是仅使用一些成分对原始数据进行重建。在<code>plot_pca_illustration</code>函数中，去掉第二个主成分，再反向旋转并加上平均值，这样就在原始空间中获得去掉第二个成分的新数据点。我们可以对人脸做类似的变换，将数据降维到只包含一些主成分，然后反向旋转回到原始空间。回到原始特征空间可以通过<code>inverse_transform(X)</code>方法来实现。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.decomposition.pca#sklearn.decomposition.PCA.inverse_transform" target="_blank" rel="noopener"><code>inverse_transform(X)</code></a></p><p>Transform data back to its original space.</p><p>In other words, return an input X_original whose transform would be X.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.rcParams[<span class="string">'image.cmap'</span>] = <span class="string">'gray'</span></span><br><span class="line"><span class="comment"># 分别利用10个、50个、100个和500个成分对一些人脸进行重建并将其可视化</span></span><br><span class="line">mglearn.plots.plot_pca_faces(X_train, X_test, image_shape)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/pca-faces.png"></p><p>可以看到，在仅使用前10个主成分时，仅捕捉到了图片的基本特点，比如人脸方向和明暗程度。随着使用的主成分越来越多，图像中也保留了越来越多的细节。这对应于前一幅图的求和中包含越来越多的项。如果使用的成分个数与像素个数相等，意味着我们在旋转后不会丢弃任何信息，可以完美重建图像。</p><p>我们还可以尝试使用PCA的前两个主成分，将数据集中的所有人脸在散点图中可视化，其类别在图中给出。这与我们对cancer数据集所做的类似。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.discrete_scatter(X_train_pca[:, <span class="number">0</span>], X_train_pca[:, <span class="number">1</span>], y_train)</span><br><span class="line">plt.xlabel(<span class="string">'First principal component'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Second principal component'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/pca-faces-scatter.png"></p><p>如你所见，如果我们只使用前两个主成分，整个数据只是一大团，看不到类别之间的分界。这并不意外，因为即使有10个成分，PCA也仅捕捉到人脸非常粗略的特征。</p><h1 id="非负矩阵分解">非负矩阵分解</h1><p>非负矩阵分解（non-negative matrix factorization，NMF）是另一种无监督学习算法，其目的在于提取有用的特征。它的工作原理类似PCA，也可以用于降维。与PCA相同，我们试图将每个数据点写成一些分量的加权求和。但在PCA中，我们想要的是正交分量，并且能够解释尽可能多的数据方差；而在NMF中，我们希望分量和系数均为非负。因此，这种方法只能应用于每个特征都是非负的数据，因为非负分量的非负求和不可能变为负值。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.decomposition.nmf" target="_blank" rel="noopener"><code>class sklearn.decomposition.NMF(n_components=None, init=None, solver=’cd’, beta_loss=’frobenius’, tol=0.0001, max_iter=200, random_state=None, alpha=0.0, l1_ratio=0.0, verbose=0, shuffle=False)</code></a></p><p>Non-Negative Matrix Factorization (NMF)</p></blockquote><p>将数据分解成非负加权求和的这个过程，对由多个独立源相加（或叠加）创建而成的数据特别有用，比如多人说话的音轨或包含多种乐器的音乐。在这种情况下，NMF可以识别出组合合成数据的原始分量。总的来说，与PCA相比，NMF得到的分量更容易理解，因为负的分量和系数可能会导致难以理解的抵消效应（cancellation effect）。</p><h2 id="将nmf应用于模拟数据">将NMF应用于模拟数据</h2><p>与使用PCA不同，我们需要保证数据是正的，NMF能够对数据进行操作。这说明数据相对于原点(0, 0)的位置实际上对NMF很重要。因此，你可以将提取出来的非负分量看作是从(0, 0)到数据的方向。下面的例子给出了NMF在二维玩具数据上的结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_nmf_illustration()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/nmf.png"></p><p>对于两个分量的NMF（左图），显然所有数据点都可以写成这两个分量的正数组合。如果有足够多的分量能够完美地重建数据（分量个数与特征个数相同），那么算法会选择指向数据极值的方向。</p><p>如果我们仅使用一个分量，那么NMF会创建一个指向平均值的分量，因为指向这里可以对数据做出最好的解释。<strong>与PCA不同，减少分量个数不仅会删除一些方向，而且会创建一组完全不同的分量！NMF的分量也没有按任何特定方法排序，所以不存在“第一非负分量”：所有分量的地位平等。</strong></p><p>NMF使用了随机初始化，根据随机种子的不同可能会产生不同的结果。在相对简单的情况下（比如两个分量的模拟数据），所有数据都可以被完美地解释，那么随机性的影响很小（虽然可能会影响分量的顺序或尺度）。在更加复杂的情况下，影响可能会很大。</p><h2 id="将nmf应用于人脸图像">将NMF应用于人脸图像</h2><p>NMF的主要参数是我们想要提取的分量个数。通常来说，这个数字要小于输入特征的个数（否则的话，将每个像素作为单独的分量就可以对数据进行解释）。</p><p>首先，我们来观察分量个数如何影响NMF重建数据的好坏。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_nmf_faces(X_train, X_test, image_shape)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/nmf-faces.png"></p><p><strong>反向变换的数据质量与使用PCA时类似，但要稍差一些。这是符合预期的，因为PCA找到的是重建的最佳方向。NMF通常并不用于对数据进行重建或者编码，而是用于在数据中寻找有趣的模式。</strong></p><p>我们尝试仅提取一部分分量，初步观察一下数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> NMF</span><br><span class="line"></span><br><span class="line">nmf = NMF(n_components=<span class="number">15</span>, random_state=<span class="number">0</span>)</span><br><span class="line">nmf.fit(X_train)</span><br><span class="line">X_train_nmf = nmf.transform(X_train)</span><br><span class="line">X_test_nmf = nmf.transform(X_test)</span><br><span class="line"></span><br><span class="line">fix, axes = plt.subplots(<span class="number">3</span>, <span class="number">5</span>, figsize=(<span class="number">15</span>, <span class="number">12</span>),</span><br><span class="line">    subplot_kw=&#123;<span class="string">'xticks'</span>: (), <span class="string">'yticks'</span>: ()&#125;)</span><br><span class="line"><span class="keyword">for</span> i, (component, ax) <span class="keyword">in</span> enumerate(zip(nmf.components_, axes.ravel())):</span><br><span class="line">    ax.imshow(component.reshape(image_shape))</span><br><span class="line">    ax.set_title(<span class="string">'&#123;&#125;. component'</span>.format(i))</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/nmf-components.png"></p><p>这些分量都是正的，因此比PCA分量更像人脸模型。例如，你可以看到，分量3显示了稍微向右转动的人脸，而分量7则显示了稍微向左转动的人脸。我们来看一下这两个分量特别大的那些图像。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> compn <span class="keyword">in</span> (<span class="number">3</span>, <span class="number">7</span>):</span><br><span class="line">    inds = np.argsort(X_train_nmf[:, compn])[::<span class="number">-1</span>]</span><br><span class="line">    fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">5</span>, figsize=(<span class="number">15</span>, <span class="number">8</span>),</span><br><span class="line">        subplot_kw=&#123;<span class="string">'xticks'</span>: (), <span class="string">'yticks'</span>: ()&#125;)</span><br><span class="line">    <span class="keyword">for</span> i, (ind, ax) <span class="keyword">in</span> enumerate(zip(inds, axes.ravel())):</span><br><span class="line">        ax.imshow(X_train[ind].reshape(image_shape))</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/nmf-components-argsort-3.png"></p><p><img src="/uploads/image/introduction-to-ml-with-python/nmf-components-argsort-7.png"></p><p>正如所料，分量3系数较大的人脸都是向右看的人脸，而分量7系数较大的人脸都向左看。<strong>提取这样的模式最适合于具有叠加结构的数据，包括音频、基因表达和文本数据。</strong></p><p>我们通过一个模拟数据的例子来看一下这种用法。加入我们对一个信号感兴趣，它是三个不同信号源合成的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = mglearn.datasets.make_signals()</span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">1</span>))</span><br><span class="line">plt.plot(S, <span class="string">'-'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Time'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Signal'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/datasets-signals.png"></p><p>不幸的是，我们无法观测到原始信号，只能观测到三个信号的叠加混合。我们想要将混合信号分解成原始分量。假设我们有许多种不同的方法来观测信号（比如有100台测量装置），每种方法都为我们提供了一些列观测结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将数据混合成100维的状态</span></span><br><span class="line">A = np.random.RandomState(<span class="number">0</span>).uniform(size=(<span class="number">100</span>, <span class="number">3</span>))</span><br><span class="line">X = np.dot(S, A.T)</span><br><span class="line">print(<span class="string">'Shape of measurements: &#123;&#125;'</span>.format(X.shape))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用NMF来还原这三个信号</span></span><br><span class="line">nmf = NMF(n_components=<span class="number">3</span>, random_state=<span class="number">42</span>)</span><br><span class="line">S_ = nmf.fit_transform(X)</span><br><span class="line">print(<span class="string">'Recovered signal shape: &#123;&#125;'</span>.format(S_.shape))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了对比，应用PCA</span></span><br><span class="line">pca = PCA(n_components=<span class="number">3</span>)</span><br><span class="line">H = pca.fit_transform(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给出NMF和PCA发现的信号活动</span></span><br><span class="line">models = [X, S, S_, H]</span><br><span class="line">names = [<span class="string">'Observations (first three measurements)'</span>, <span class="string">'True sources'</span>,</span><br><span class="line">    <span class="string">'NMF recovered signals'</span>, <span class="string">'PCA recovered signals'</span>]</span><br><span class="line">fig, axes = plt.subplots(<span class="number">4</span>, figsize=(<span class="number">8</span>, <span class="number">4</span>), gridspec_kw=&#123;<span class="string">'hspace'</span>: <span class="number">.5</span>&#125;,</span><br><span class="line">    subplot_kw=&#123;<span class="string">'xticks'</span>: (), <span class="string">'yticks'</span>: ()&#125;)</span><br><span class="line"><span class="keyword">for</span> model, name, ax <span class="keyword">in</span> zip(models, names, axes):</span><br><span class="line">    ax.set_title(name)</span><br><span class="line">    ax.plot(model[:, :<span class="number">3</span>], <span class="string">'-'</span>)  <span class="comment"># 绘制X时，仅包含100次中的前3次测量</span></span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/nmf-and-pca-on-signals.png"></p><p>可以看到，NMF在发现原始信号源时得到了不错的结果，而PCA则失败了，仅使用第一个成分来解释数据中的大部分变化。<strong>要记住，NMF生成的分量是没有顺序的。在这个例子中，NMF分量的顺序与原始信号完全相同（参见三条曲线的颜色），但这纯属偶然。</strong></p><p>还有许多其他算法可用于将每个数据点分解成一系列固定分量的加权求和，正如PCA和NMF所做的那样。如果你对这种类型的模式提取感兴趣，我们推荐你学习<code>scikit-learn</code>用户指南中关于独立成分分析（ICA）、因子分析（FA）和稀疏编码（字典学习）等的内容，所有这些内容都可以在关于分解方法的页面中找到（<a href="http://scikit-learn.org/stable/modules/decomposition.html" class="uri" target="_blank" rel="noopener">http://scikit-learn.org/stable/modules/decomposition.html</a>）。</p><h1 id="用t-sne进行流形学习">用t-SNE进行流形学习</h1><p>虽然PCA通常是用于变换数据的首选方法，使你能够用散点图将其可视化，但这一方法的性质（先旋转然后减少方向）限制了其有效性。有一类用于可视化的算法叫作<strong>流形学习算法</strong>（manifold learning algorithm），它允许进行更复杂的映射，通常也可以给出更好的可视化。其中特别有用的一个就是t-SNE（t-distributed Stochastic Neighbor Embedding）算法。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.manifold.tsne" target="_blank" rel="noopener"><code>class sklearn.manifold.TSNE(n_components=2, perplexity=30.0, early_exaggeration=12.0, learning_rate=200.0, n_iter=1000, n_iter_without_progress=300, min_grad_norm=1e-07, metric=’euclidean’, init=’random’, verbose=0, random_state=None, method=’barnes_hut’, angle=0.5)</code></a></p><p>t-distributed Stochastic Neighbor Embedding.</p></blockquote><p><strong>流形学习算法主要用于可视化，因此很少用来生成两个以上的新特征。其中一些算法（包括t-SNE）计算训练数据的一种新表示，但不允许变换新数据。这意味着这些算法不能用于测试集：更确切地说，它们只能变换用于训练的数据。</strong>流形学习对探索性数据分析是很有用的，但如果最终目标是监督学习的话，则很少使用。t-SNE背后的思想是找到数据的一个二维表示，尽可能地保持数据点之间的距离。t-SNE首先给出每个数据点的随机二维表示，然后尝试让在原始特征空间中距离较近的点更加靠近，原始特征空间中相距较远的点更加远离。t-SNE重点关注距离较近的点，而不是保持距离较远的点之间的距离。换句话说，它试图保存那些表示哪些点比较靠近的信息。</p><p>我们将对<code>scikit-learn</code>包含的一个手写数字数据集应用t-SNE流形学习算法。在这个数据集中，每个数据点都是0到9之间手写数字的一张8x8灰度图像。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_digits</span><br><span class="line"></span><br><span class="line">digits = load_digits()</span><br><span class="line">fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">5</span>, figsize=(<span class="number">10</span>, <span class="number">5</span>),</span><br><span class="line">    subplot_kw=&#123;<span class="string">'xticks'</span>: (), <span class="string">'yticks'</span>: ()&#125;)</span><br><span class="line"><span class="keyword">for</span> ax, img <span class="keyword">in</span> zip(axes.ravel(), digits.images):</span><br><span class="line">    ax.imshow(img)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/datasets-digits.png"></p><p>我们用PCA将降到二维的数据可视化。对前两个主成分作图，并按类别对数据点着色。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pca = PCA(n_components=<span class="number">2</span>)</span><br><span class="line">pca.fit(digits.data)</span><br><span class="line">digits_pca = pca.transform(digits.data)</span><br><span class="line">colors = [<span class="string">"#476A2A"</span>, <span class="string">"#7851B8"</span>, <span class="string">"#BD3430"</span>, <span class="string">"#4A2D4E"</span>, <span class="string">"#875525"</span>,</span><br><span class="line">          <span class="string">"#A83683"</span>, <span class="string">"#4E655E"</span>, <span class="string">"#853541"</span>, <span class="string">"#3A3120"</span>, <span class="string">"#535D8E"</span>]</span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">plt.xlim(digits_pca[:, <span class="number">0</span>].min(), digits_pca[:, <span class="number">0</span>].max())</span><br><span class="line">plt.ylim(digits_pca[:, <span class="number">1</span>].min(), digits_pca[:, <span class="number">1</span>].max())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(digits.data)):</span><br><span class="line">    <span class="comment"># 用每个类别对应的数字分别作为符号来显示每个类别的位置</span></span><br><span class="line">    plt.text(digits_pca[i, <span class="number">0</span>], digits_pca[i, <span class="number">1</span>], str(digits.target[i]),</span><br><span class="line">        color=colors[digits.target[i]], fontdict=&#123;<span class="string">'weight'</span>: <span class="string">'bold'</span>, <span class="string">'size'</span>: <span class="number">9</span>&#125;)</span><br><span class="line">plt.xlabel(<span class="string">'First principal component'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Second principal component'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/pca-digits.png"></p><p>利用前两个主成分可以将数字0、6和4相对较好地分开，尽管仍有重叠。大部分其他数字都大量重叠在一起。</p><p>我们将t-SNE应用于同一个数据集，并对结果进行比较。由于t-SNE不支持变换新数据，所以<code>TSNE</code>类没有transform方法。我们可以调用<code>fit_transform</code>方来来代替，它会构建模型并立即返回变换后的数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.manifold <span class="keyword">import</span> TSNE</span><br><span class="line"></span><br><span class="line">tsne = TSNE(random_state=<span class="number">42</span>)</span><br><span class="line">digits_tsne = tsne.fit_transform(digits.data)</span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">plt.xlim(digits_tsne[:, <span class="number">0</span>].min(), digits_tsne[:, <span class="number">0</span>].max() + <span class="number">1</span>)</span><br><span class="line">plt.ylim(digits_tsne[:, <span class="number">1</span>].min(), digits_tsne[:, <span class="number">1</span>].max() + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(digits.data)):</span><br><span class="line">    plt.text(digits_tsne[i, <span class="number">0</span>], digits_tsne[i, <span class="number">1</span>], str(digits.target[i]),</span><br><span class="line">        color=colors[digits.target[i]], fontdict=&#123;<span class="string">'weight'</span>: <span class="string">'bold'</span>, <span class="string">'size'</span>: <span class="number">9</span>&#125;)</span><br><span class="line">plt.xlabel(<span class="string">'t-SNE feature 0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'t-SNE feature 1'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/t-sne-digits.png"></p><p>t-SNE的结果非常棒。所有类别都被明确分开。数字1和9被分成几块，但大多数类别都形成以一个密集的组。<strong>要记住，这种方法并不知道类别标签：它完全是无监督的。但它能够找到数据的一种二维表示，仅根据原始空间中数据点之间的靠近程度就能够将各个类别明确分开。</strong></p><p>t-SNE算法还有一些调节参数，虽然默认参数的效果通常就很好。你可以尝试修改<code>perplexity</code>和<code>early_exaggeration</code>，但作用一般很小。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Machine Learning with Python </tag>
            
            <tag> unsupervised </tag>
            
            <tag> preprocessing </tag>
            
            <tag> PCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>预处理与缩放</title>
      <link href="/notes/introduction-to-ml-with-python/preprocess-and-scaling/"/>
      <url>/notes/introduction-to-ml-with-python/preprocess-and-scaling/</url>
      
        <content type="html"><![CDATA[<p>一些算法（如神经网络和SVM）对数据缩放非常敏感。因此，通常的做法是对特征进行调节，使数据表示更适合于这些算法。通常来说，这是对数据的一种简单的按特征的缩放和移动。下图给出了一个简单的例子。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_scaling()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/scaling.png"></p><a id="more"></a><h1 id="不同类型的预处理">不同类型的预处理</h1><p>上图中，左图显示的是一个模拟的有两个特征的二分类数据集。第一个特征（x轴）位于10到15之间。第二个特征（y轴）大约位于1到9之间。</p><p>接下来的4张图展示了4种数据变换方法，都生成了更加标准的范围。<code>scikit-learn</code>中的<code>StandardScaler</code>确保每个特征的平均值为0、方差为1，使所有特征都位于同一量级。但这种缩放不能保证特征任何特定的最大值和最小值。<code>RobustScaler</code>的工作原理与<code>StandardScaler</code>类似，确保每个特征的统计属性都位于统一范围。但<code>RobustScaler</code>使用的是中位数和四分位数，而不是平均值和方差。这样<code>RobustScaler</code>会忽略与其他点有很大不同的数据点（比如测量误差）。这些与众不同的数据点也叫<strong>异常值</strong>（outlier），可能会给其他缩放方法造成麻烦。</p><p>与之相反，<code>MinMaxScaler</code>移动数据，使所有特征都刚好位于0到1之间。对于二维数据集来说，所有的数据都包含在x轴0到1与y轴0到1组成的矩形中。</p><p>最后，<code>Normalizer</code>用到一种完全不同的缩放方法。它对每个数据点进行缩放，使得特征向量的欧式长度等于1。换句话说，它将每一个数据点投射到半径为1的圆上（对于更高维度的情况，是球面）。这意味着每个数据点的缩放比例都不相同（乘以其长度的倒数）。如果只有数据的方向（或角度）是重要的，而特征向量的长度无关紧要，那么通常会使用这种归一化。</p><h1 id="应用数据变换">应用数据变换</h1><p>通常在应用监督学习算法之前使用预处理方法（比如缩放）。举个例子，比如我们想要将核SVM应用在cancer数据集上，并使用MinMaxScaler来预处理数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_breast_cancer</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">cancer = load_breast_cancer()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">    cancer.data, cancer.target, random_state=<span class="number">1</span>)</span><br><span class="line">print(X_train.shape)</span><br><span class="line">print(X_test.shape)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(426, 30)</span><br><span class="line">(143, 30)</span><br></pre></td></tr></table></figure><p>与构建监督模型一样，首先导入实现预处理的类，然后将其实例化。然后，使用fit方法拟合缩放器（scaler），并将其应用于训练数据。对于<code>MinMaxScaler</code>来说，fit方法计算训练集中每个特征的最大值和最小值。与分类器和回归器不同，在对缩放器调用fit时只提供<code>X_train</code>，而不用<code>y_train</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"></span><br><span class="line">scaler = MinMaxScaler()</span><br><span class="line">scaler.fit(X_train)</span><br><span class="line"><span class="comment"># 变换数据</span></span><br><span class="line">X_train_scaled = scaler.transform(X_train)</span><br><span class="line"><span class="comment"># 在缩放之前和之后分别打印数据集属性</span></span><br><span class="line">print(<span class="string">"Transformed shape: &#123;&#125;"</span>.format(X_train_scaled.shape))</span><br><span class="line">print(<span class="string">'per-feature minimum before scaling:\n&#123;&#125;'</span>.format(X_train.min(axis=<span class="number">0</span>)))</span><br><span class="line">print(<span class="string">'per-feature maximum before scaling:\n&#123;&#125;'</span>.format(X_train.max(axis=<span class="number">0</span>)))</span><br><span class="line">print(<span class="string">'per-feature minimum after scaling:\n&#123;&#125;'</span>.format(X_train_scaled.min(axis=<span class="number">0</span>)))</span><br><span class="line">print(<span class="string">'per-feature maximum after scaling:\n&#123;&#125;'</span>.format(X_train_scaled.max(axis=<span class="number">0</span>)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Transformed shape: (426, 30)</span><br><span class="line">per-feature minimum before scaling:</span><br><span class="line">[6.981e+00 9.710e+00 4.379e+01 1.435e+02 5.263e-02 1.938e-02 0.000e+00</span><br><span class="line"> 0.000e+00 1.060e-01 5.024e-02 1.153e-01 3.602e-01 7.570e-01 6.802e+00</span><br><span class="line"> 1.713e-03 2.252e-03 0.000e+00 0.000e+00 9.539e-03 8.948e-04 7.930e+00</span><br><span class="line"> 1.202e+01 5.041e+01 1.852e+02 7.117e-02 2.729e-02 0.000e+00 0.000e+00</span><br><span class="line"> 1.566e-01 5.521e-02]</span><br><span class="line">per-feature maximum before scaling:</span><br><span class="line">[2.811e+01 3.928e+01 1.885e+02 2.501e+03 1.634e-01 2.867e-01 4.268e-01</span><br><span class="line"> 2.012e-01 3.040e-01 9.575e-02 2.873e+00 4.885e+00 2.198e+01 5.422e+02</span><br><span class="line"> 3.113e-02 1.354e-01 3.960e-01 5.279e-02 6.146e-02 2.984e-02 3.604e+01</span><br><span class="line"> 4.954e+01 2.512e+02 4.254e+03 2.226e-01 9.379e-01 1.170e+00 2.910e-01</span><br><span class="line"> 5.774e-01 1.486e-01]</span><br><span class="line">per-feature minimum after scaling:</span><br><span class="line">[0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.</span><br><span class="line"> 0. 0. 0. 0. 0. 0.]</span><br><span class="line">per-feature maximum after scaling:</span><br><span class="line">[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.</span><br><span class="line"> 1. 1. 1. 1. 1. 1.]</span><br></pre></td></tr></table></figure><p>变换后的数据形状与原始数据相同，特征只是发生了移动和缩放。为了将SVM应用到缩放后的数据上，还需要对测试集进行变换。这可以通过对<code>X_test</code>调用transform方法来完成。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对测试数据进行变换</span></span><br><span class="line">X_test_scaled = scaler.transform(X_test)</span><br><span class="line"><span class="comment"># 在缩放之后打印测试数据的属性</span></span><br><span class="line">print(<span class="string">'per-feature minimum after scaling:\n&#123;&#125;'</span>.format(X_test_scaled.min(axis=<span class="number">0</span>)))</span><br><span class="line">print(<span class="string">'per-feature maximum after scaling:\n&#123;&#125;'</span>.format(X_test_scaled.max(axis=<span class="number">0</span>)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">per-feature minimum after scaling:</span><br><span class="line">[ 0.0336031   0.0226581   0.03144219  0.01141039  0.14128374  0.04406704</span><br><span class="line">  0.          0.          0.1540404  -0.00615249 -0.00137796  0.00594501</span><br><span class="line">  0.00430665  0.00079567  0.03919502  0.0112206   0.          0.</span><br><span class="line"> -0.03191387  0.00664013  0.02660975  0.05810235  0.02031974  0.00943767</span><br><span class="line">  0.1094235   0.02637792  0.          0.         -0.00023764 -0.00182032]</span><br><span class="line">per-feature maximum after scaling:</span><br><span class="line">[0.9578778  0.81501522 0.95577362 0.89353128 0.81132075 1.21958701</span><br><span class="line"> 0.87956888 0.9333996  0.93232323 1.0371347  0.42669616 0.49765736</span><br><span class="line"> 0.44117231 0.28371044 0.48703131 0.73863671 0.76717172 0.62928585</span><br><span class="line"> 1.33685792 0.39057253 0.89612238 0.79317697 0.84859804 0.74488793</span><br><span class="line"> 0.9154725  1.13188961 1.07008547 0.92371134 1.20532319 1.63068851]</span><br></pre></td></tr></table></figure><p>你可以发现，对测试集缩放后的最大值和最小值不是1和0，这或许有些出乎意料。有些特征甚至在0～1之外！<strong>对此的解释是，<code>MinMaxScaler</code>（以及其他所有缩放器）总是对训练集和测试集应用完全相同的变换。也就是说，transform方法总是减去训练集的最小值，然后处理训练集范围，而这两个值可能与测试集的最小值和范围并不相同。</strong></p><h1 id="对训练数据和测试数据进行相同的缩放">对训练数据和测试数据进行相同的缩放</h1><p><strong>为了让监督模型能够在测试集上运行，对训练集和测试集应用完全相同的变换是很重要的。</strong>如果我们使用测试集的最小值和范围，下面这个例子展示了会发生什么。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造数据</span></span><br><span class="line">X, _ = make_blobs(n_samples=<span class="number">50</span>, centers=<span class="number">5</span>, random_state=<span class="number">4</span>, cluster_std=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 将其划分为训练集和测试集</span></span><br><span class="line">X_train, X_test = train_test_split(X, random_state=<span class="number">5</span>, test_size=<span class="number">.1</span>)</span><br><span class="line"><span class="comment"># 绘制训练集和测试集</span></span><br><span class="line">fig, axes = plt.subplots(<span class="number">1</span>, <span class="number">3</span>, figsize=(<span class="number">13</span>, <span class="number">4</span>))</span><br><span class="line">axes[<span class="number">0</span>].scatter(X_train[:, <span class="number">0</span>], X_train[:, <span class="number">1</span>],</span><br><span class="line">    c=mglearn.cm2(<span class="number">0</span>), label=<span class="string">'Training set'</span>, s=<span class="number">60</span>)</span><br><span class="line">axes[<span class="number">0</span>].scatter(X_test[:, <span class="number">0</span>], X_test[:, <span class="number">1</span>], marker=<span class="string">'^'</span>,</span><br><span class="line">    c=mglearn.cm2(<span class="number">1</span>), label=<span class="string">'Test set'</span>, s=<span class="number">60</span>)</span><br><span class="line">axes[<span class="number">0</span>].legend(loc=<span class="string">'upper left'</span>)</span><br><span class="line">axes[<span class="number">0</span>].set_title(<span class="string">'Original Data'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用MinMaxScaler缩放数据</span></span><br><span class="line">scaler = MinMaxScaler()</span><br><span class="line">scaler.fit(X_train)</span><br><span class="line">X_train_scaled = scaler.transform(X_train)</span><br><span class="line">X_test_scaled = scaler.transform(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将正确缩放的数据可视化</span></span><br><span class="line">axes[<span class="number">1</span>].scatter(X_train_scaled[:, <span class="number">0</span>], X_train_scaled[:, <span class="number">1</span>],</span><br><span class="line">    c=mglearn.cm2(<span class="number">0</span>), label=<span class="string">'Training set'</span>, s=<span class="number">60</span>)</span><br><span class="line">axes[<span class="number">1</span>].scatter(X_test_scaled[:, <span class="number">0</span>], X_test_scaled[:, <span class="number">1</span>], marker=<span class="string">'^'</span>,</span><br><span class="line">    c=mglearn.cm2(<span class="number">1</span>), label=<span class="string">'Test set'</span>, s=<span class="number">60</span>)</span><br><span class="line">axes[<span class="number">1</span>].set_title(<span class="string">'Scaled Data'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单独对测试集进行缩放</span></span><br><span class="line"><span class="comment"># 使得测试集的最小值为0，最大值为1</span></span><br><span class="line"><span class="comment"># 千万不要这么做！这里只是为了举例</span></span><br><span class="line">test_scaler = MinMaxScaler()</span><br><span class="line">test_scaler.fit(X_test)</span><br><span class="line">X_test_scaled_badly = test_scaler.transform(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将错误缩放的数据可视化</span></span><br><span class="line">axes[<span class="number">2</span>].scatter(X_train_scaled[:, <span class="number">0</span>], X_train_scaled[:, <span class="number">1</span>],</span><br><span class="line">    c=mglearn.cm2(<span class="number">0</span>), label=<span class="string">'Training set'</span>, s=<span class="number">60</span>)</span><br><span class="line">axes[<span class="number">2</span>].scatter(X_test_scaled_badly[:, <span class="number">0</span>], X_test_scaled_badly[:, <span class="number">1</span>],</span><br><span class="line">    marker=<span class="string">'^'</span>, c=mglearn.cm2(<span class="number">1</span>), label=<span class="string">'Test set'</span>, s=<span class="number">60</span>)</span><br><span class="line">axes[<span class="number">2</span>].set_title(<span class="string">'Improperly Scaled Data'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax <span class="keyword">in</span> axes:</span><br><span class="line">    ax.set_xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">'Feature 1'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/minmaxscaling-of-blobs.png"></p><p>你可以发现，第二张图中的数据集看起来与第一张图中的完全相同，只是坐标轴刻度发生了变化。现在所有特征都位于0到1之间。你还可以发现，测试数据的特征最大值和最小值并不是1和0。第三张图展示了如果我们对训练集和测试集分别进行缩放会发生什么。在这种情况下，对训练集和测试集而言，特征的最大值和最小值都是1和0。但现在数据集看起来不一样。测试集相对训练集的移动不一致，因为它们分别做了不同的缩放。我们随意改变了数据的排列。这显然不是我们想要做的事。</p><p>通常来所，你想要在某个数据集上fit一个模型，然后再将其transform。这是一个非常常见的任务。</p><ul><li><p>快捷方式：使用方法链。例如，<code>X_scaled = scaler.fit(X).transform(X)</code>。</p></li><li><p>高效的替代方法：使用<code>fit_transform</code>方法。例如，<code>X_scaled = scaler.fit_transform(X)</code>。</p></li></ul><p>所有具有<code>transform</code>方法的模型，也都具有一个<code>fit_transform</code>方法。虽然<code>fit_transform</code>不一定对所有模型都更加高效，但在尝试变换训练集时，使用这一方法仍然是很好的做法。</p><h1 id="预处理对监督学习的作用">预处理对监督学习的作用</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"></span><br><span class="line">cancer = load_breast_cancer()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">    cancer.data, cancer.target, random_state=<span class="number">1</span>)</span><br><span class="line">svm = SVC(C=<span class="number">100</span>)</span><br><span class="line">svm.fit(X_train, y_train)</span><br><span class="line">print(<span class="string">'Test set accuracy: &#123;:.2f&#125;'</span>.format(svm.score(X_test, y_test)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用0-1缩放进行预处理</span></span><br><span class="line">scaler = MinMaxScaler()</span><br><span class="line">scaler.fit(X_train)</span><br><span class="line">X_train_scaled = scaler.transform(X_train)</span><br><span class="line">X_test_scaled = scaler.transform(X_test)</span><br><span class="line"><span class="comment"># 在缩放后的训练数据上学习SVM</span></span><br><span class="line">svm.fit(X_train_scaled, y_train)</span><br><span class="line"><span class="comment"># 在缩放后的测试集上计算分数</span></span><br><span class="line">print(<span class="string">'Scaled test set accuracy: &#123;:.2f&#125;'</span>.format(</span><br><span class="line">    svm.score(X_test_scaled, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test set accuracy: 0.62</span><br><span class="line">Scaled test set accuracy: 0.97</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Machine Learning with Python </tag>
            
            <tag> unsupervised </tag>
            
            <tag> preprocessing </tag>
            
            <tag> scaling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无监督学习与预处理</title>
      <link href="/notes/introduction-to-ml-with-python/unsupervised-learning-and-preprocessing/"/>
      <url>/notes/introduction-to-ml-with-python/unsupervised-learning-and-preprocessing/</url>
      
        <content type="html"><![CDATA[<h1 id="无监督学习的类型">无监督学习的类型</h1><p>本章将研究两种类型的无监督学习：数据集变换与聚类。</p><p>数据集的<strong>无监督变换</strong>（unsupervised transformation）是创建数据新的表示的算法，与数据的原始表示相比，新的表示可能更容易被人或其他机器学习算法所理解。无监督变换的一个常见应用是<strong>降维</strong>（dimensionality reduction），它接受包含许多特征的数据的高维表示，并找到表示该数据的一种新方法，用较少的特征就可以概括其特性。降维的一个常见应用是为了可视化将数据降为二维。</p><p>无监督变换的另一个应用是找到“构成”数据的各个组成部分。这方面的一个例子就是对文本文档集合进行主题提取。这里的任务是找到每个文档中讨论的未知主题，并学习每个文档中出现了哪些主题。这可以用于追踪社交媒体上的话题讨论，比如选举、枪支管制或流行歌手等话题。</p><p>与之相反，<strong>聚类算法</strong>（clustering algorithm）将数据划分成不同的组，每组包含相似的物项。思考向社交媒体网站上传照片的例子。为了方便你整理照片，网站可能想要将同一个人的照片分在一组。但网站并不知道每张照片是谁，也不知道你的照片集中出现了多少个人。明智的做法是提取所有的人脸，并将看起来相似的人脸分在一组。但愿这些人脸对应同一个人，这样照片的分组也就完成了。</p><a id="more"></a><h1 id="无监督学习的挑战">无监督学习的挑战</h1><p>无监督学习的一个主要挑战就是评估算法是否学到了有用的东西。无监督学习算法一般用于不包含任何标签信息的数据，所以我们不知道正确的输出应该是什么。因此很难判断一个模型是否“表现很好”。例如，假设我们的聚类算法已经将所有的侧脸照片和所有的正面照片进行分组。这肯定是人脸照片集合的一种可能的划分方法，但并不是我们想要的那种方法。然而，我们没有办法“告诉”算法我们要的是什么，通常来说，评估无监督算法结果的唯一方法就是人工检查。</p><p>因此，如果数据科学家想要更好地理解数据，那么无监督算法通常可用于探索的目的，而不是作为大型自动化系统的一部分。无监督算法的另一个常见应用是作为监督算法的预处理步骤。学习数据的一种新的表示，有时可以提高监督算法的精度，或者可以减少内存占用和时间开销。</p><p>在开始学习“真正的”无监督算法之前，我们先简要讨论几种简单又常用的预处理方法。虽然预处理和缩放通常与监督学习算法一起使用，但缩放方法并没有用到与“监督”有关的信息，所以它是无监督的。</p><h1 id="预处理与缩放">预处理与缩放</h1><a href="/notes/introduction-to-ml-with-python/preprocess-and-scaling/" title="前往文章">前往文章</a><h1 id="降维特征提取与流形学习">降维、特征提取与流形学习</h1><a href="/notes/introduction-to-ml-with-python/dimensionality-reduction-feature-extraction-and-manifold-learning/" title="前往文章">前往文章</a><h1 id="聚类">聚类</h1><a href="/notes/introduction-to-ml-with-python/clustering/" title="前往文章">前往文章</a><h1 id="小结">小结</h1><p>本章介绍了一系列无监督学习算法，可用于探索性数据分析和预处理。找到数据的正确表示对于监督学习和无监督学习的成功通常都至关重要，预处理和分解方法在数据准备中具有重要作用。</p><p>分解、流形学习和聚类都是加深数据理解的重要工具，在没有监督信息的情况下，也是理解数据的仅有方法。即使在监督学习中，探索性工具对于更好地理解数据性质也很重要。通常来说，很难量化无监督算法的有用性，但这不应该妨碍你使用它们来深入理解数据。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Machine Learning with Python </tag>
            
            <tag> unsupervised </tag>
            
            <tag> preprocessing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络（深度学习）</title>
      <link href="/notes/introduction-to-ml-with-python/neural-networks-deep-learning/"/>
      <url>/notes/introduction-to-ml-with-python/neural-networks-deep-learning/</url>
      
        <content type="html"><![CDATA[<p>一类被称为神经网络的算法最近以“深度学习“的名字再度流行。虽然深度学习在许多机器学习应用中都有巨大的潜力，但深度学习算法往往经过精确调整，只适用于特定的使用场景。这里只讨论一些相对简单的方法，即用于分类和回归的<strong>多层感知机</strong>（multilayer perceptron，MLP），它可以作为研究更复杂的深度学习方法的起点。MLP也被称为（普通）前馈神经网络，有时也简称为神经网络。</p><h1 id="神经网络模型">神经网络模型</h1><p>MLP可以被视为广义的线性模型，执行多层处理后得到结论。</p><p>线性回归的预测公式为：</p><p><span class="math display">\[\hat y=w[0]*x[0]+w[1]*x[1]+\dots+w[p]*x[p]+b\]</span></p><p>简单来说，<span class="math inline">\(\hat y\)</span>是输入特征<span class="math inline">\(x[0]\)</span>到<span class="math inline">\(x[p]\)</span>的加权求和，权重为学到的系数<span class="math inline">\(w[0]\)</span>到<span class="math inline">\(w[p]\)</span>。我们可以将这个公式可视化。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = mglearn.plots.plot_logistic_regression_graph()</span><br><span class="line">g.render(filename=<span class="string">'visualization-of-logistic-regression'</span>,</span><br><span class="line">    view=<span class="literal">True</span>, format=<span class="string">'svg'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/visualization-of-logistic-regression.svg"></p><a id="more"></a><p>图中，左边的每个结点代表一个输入特征，连线代表学到的系数，右边的结点代表输出，是输入的加权求和。</p><p>在MLP中，多次重复这个计算加权求和的过程，首先计算代表中间过程的<strong>隐单元</strong>（hidden unit），然后再计算这些隐单元的加权求和并得到最终结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = mglearn.plots.plot_single_hidden_layer_graph()</span><br><span class="line">g.render(filename=<span class="string">'single-hidden-layer-mlp'</span>, format=<span class="string">'svg'</span>, view=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/visualization-of-single-hidden-layer-mlp.svg"></p><p>这个模型需要学习更多的系数（也叫作权重）：在每个输入与每个隐单元（隐单元组成了<strong>隐层</strong>）之间有一个系数，在每个隐单元与输出之间也有一个系数。</p><p>从数学的角度看，计算一系列加权求和与只计算一个加权求和是完全相同的，因此，为了让这个模型真正比线性模型更为强大，我们还需要一个技巧。在计算完每个隐单元的加权求和之后，对结果再应用一个非线性函数——通常是<strong>校正非线性</strong>（rectifying nonlinearity，也叫校正线性单元或relu）或<strong>正切双曲线</strong>（tangens hyperbolicus，tanh）。然后将这个函数的结果用于加权求和，计算得到输出<span class="math inline">\(\hat y\)</span>。这两个函数的可视化效果如图。relu截断小于0的值，而tanh在输出值较小时接近-1，在输出值较大时接近+1。有了这两种非线性函数，神经网络可以学习比线性模型复杂得多的函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">line = np.linspace(<span class="number">-3</span>, <span class="number">3</span>, <span class="number">100</span>)</span><br><span class="line">plt.plot(line, np.tanh(line), label=<span class="string">'tanh'</span>)</span><br><span class="line">plt.plot(line, np.maximum(line, <span class="number">0</span>), label=<span class="string">'relu'</span>)</span><br><span class="line">plt.legend(loc=<span class="string">'best'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'x'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'relu(x), tanh(x)'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/visualization-of-relu-and-tanh.png"></p><p>例如对上述的单隐层感知机，计算回归问题的<span class="math inline">\(\hat y\)</span>的完整公式如下：</p><p><span class="math display">\[\begin{aligned}h[0] &amp;= tanh(w[0, 0]*x[0]+w[1, 0]*x[1]+w[2, 0]*x[2]+w[3, 0]*x[3]+b[0])\\h[1] &amp;= tanh(w[0, 1]*x[0]+w[1, 1]*x[1]+w[2, 1]*x[2]+w[3, 1]*x[3]+b[1])\\h[2] &amp;= tanh(w[0, 2]*x[0]+w[1, 2]*x[1]+w[2, 2]*x[2]+w[3, 2]*x[3]+b[2])\\\hat y &amp;= v[0]*h[0]+v[1]*h[1]+v[2]*h[2]+b\end{aligned}\]</span></p><p>其中，<span class="math inline">\(w\)</span>是输入<span class="math inline">\(x\)</span>与隐层<span class="math inline">\(h\)</span>之间的权重，<span class="math inline">\(v\)</span>是隐层<span class="math inline">\(h\)</span>与输出<span class="math inline">\(\hat y\)</span>之间的权重。权重<span class="math inline">\(w\)</span>和<span class="math inline">\(v\)</span>要从数据中学习得到，<span class="math inline">\(x\)</span>是输入特征，<span class="math inline">\(\hat y\)</span>是计算得到的输出，<span class="math inline">\(h\)</span>是计算的中间结果。需要用户设置的一个重要参数是隐层中的结点个数。对于非常小或非常简单的数据集，这个值可以小到10；对于非常复杂的数据，这个值可以大到10000.也可以添加多个隐层。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = mglearn.plots.plot_two_hidden_layer_graph()</span><br><span class="line">g.render(filename=<span class="string">'visualization-of-two-hidden-layer-mlp'</span>,</span><br><span class="line">    view=<span class="literal">True</span>, format=<span class="string">'svg'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/visualization-of-two-hidden-layer-mlp.svg"></p><p>这些由许多计算层组成的大型神经网络，正是术语“深度学习”的灵感来源。</p><h1 id="神经网络调参">神经网络调参</h1><p>我们将MLPClassifier应用到two_moons数据集上，以此研究MLP的工作原理。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.neural_network.mlpclassifier" target="_blank" rel="noopener"><code>class sklearn.neural_network.MLPClassifier(hidden_layer_sizes=(100, ), activation=’relu’, solver=’adam’, alpha=0.0001, batch_size=’auto’, learning_rate=’constant’, learning_rate_init=0.001, power_t=0.5, max_iter=200, shuffle=True, random_state=None, tol=0.0001, verbose=False, warm_start=False, momentum=0.9, nesterovs_momentum=True, early_stopping=False, validation_fraction=0.1, beta_1=0.9, beta_2=0.999, epsilon=1e-08, n_iter_no_change=10)</code></a></p><p>Multi-layer Perceptron classifier.</p><p>This model optimizes the log-loss function using LBFGS or stochastic gradient descent.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X, y = make_moons(n_samples=<span class="number">100</span>, noise=<span class="number">0.25</span>, random_state=<span class="number">3</span>)</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">    X, y, stratify=y, random_state=<span class="number">42</span>)</span><br><span class="line">mlp = MLPClassifier(solver=<span class="string">'lbfgs'</span>, random_state=<span class="number">0</span>).fit(X_train, y_train)</span><br><span class="line">mglearn.plots.plot_2d_separator(mlp, X_train, fill=<span class="literal">True</span>, alpha=<span class="number">.3</span>)</span><br><span class="line">mglearn.discrete_scatter(X_train[:, <span class="number">0</span>], X_train[:, <span class="number">1</span>], y_train)</span><br><span class="line">plt.xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature 1'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-of-100-hidden-nodes-mlp.png"></p><p>如你所见，神经网络学到的决策边界完全是非线性的，但相对平滑。</p><p>默认情况下，MLP使用100个隐结点，这对于这个小型数据集来说已经相当多了。我们可以减少其数量（从而降低了模型复杂度），但仍然得到很好的结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mlp = MLPClassifier(solver=<span class="string">'lbfgs'</span>, random_state=<span class="number">0</span>, hidden_layer_sizes=[<span class="number">10</span>])</span><br><span class="line">mlp.fit(X_train, y_train)</span><br><span class="line">mglearn.plots.plot_2d_separator(mlp, X_train, fill=<span class="literal">True</span>, alpha=<span class="number">.3</span>)</span><br><span class="line">mglearn.discrete_scatter(X_train[:, <span class="number">0</span>], X_train[:, <span class="number">1</span>], y_train)</span><br><span class="line">plt.xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature 1'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-of-10-hidden-nodes-mlp.png"></p><p>只有10个隐单元时，决策边界看起来更加参差不齐。默认的非线性是relu。如果使用单隐层，那么决策函数将由10个直线段组成。如果想得到更加平滑的决策边界，可以添加更多的隐单元、添加第二个隐层或者使用tanh非线性。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用2个隐层，每个包含10个单元</span></span><br><span class="line">mlp = MLPClassifier(solver=<span class="string">'lbfgs'</span>, random_state=<span class="number">0</span>, hidden_layer_sizes=[<span class="number">10</span>, <span class="number">10</span>])</span><br><span class="line">mlp.fit(X_train, y_train)</span><br><span class="line">mglearn.plots.plot_2d_separator(mlp, X_train, fill=<span class="literal">True</span>, alpha=<span class="number">.3</span>)</span><br><span class="line">mglearn.discrete_scatter(X_train[:, <span class="number">0</span>], X_train[:, <span class="number">1</span>], y_train)</span><br><span class="line">plt.xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature 1'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-of-10-10-hidden-nodes-mlp.png"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用2个隐层，每个包含10个单元，这次使用tanh非线性</span></span><br><span class="line">mlp = MLPClassifier(solver=<span class="string">'lbfgs'</span>, activation=<span class="string">'tanh'</span>,</span><br><span class="line">    random_state=<span class="number">0</span>, hidden_layer_sizes=[<span class="number">10</span>, <span class="number">10</span>])</span><br><span class="line">mlp.fit(X_train, y_train)</span><br><span class="line">mglearn.plots.plot_2d_separator(mlp, X_train, fill=<span class="literal">True</span>, alpha=<span class="number">.3</span>)</span><br><span class="line">mglearn.discrete_scatter(X_train[:, <span class="number">0</span>], X_train[:, <span class="number">1</span>], y_train)</span><br><span class="line">plt.xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature 1'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-of-10-10-hidden-nodes-mlp-tanh.png"></p><p>最后，我们还可以利用L2惩罚使权重趋向于0，从而控制神经网络的复杂度，正如我们在岭回归和线性分类器中所做的那样。MLPClassifier中调节L2惩罚的参数是alpha（与线性回归模型中的相同），它的默认值很小（弱正则化）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">4</span>, figsize=(<span class="number">20</span>, <span class="number">8</span>))</span><br><span class="line"><span class="keyword">for</span> axx, n_hidden_nodes <span class="keyword">in</span> zip(axes, [<span class="number">10</span>, <span class="number">100</span>]):</span><br><span class="line">    <span class="keyword">for</span> ax, alpha <span class="keyword">in</span> zip(axx, [<span class="number">0.0001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>]):</span><br><span class="line">        mlp = MLPClassifier(solver=<span class="string">'lbfgs'</span>, random_state=<span class="number">0</span>, alpha=alpha,</span><br><span class="line">            hidden_layer_sizes=[n_hidden_nodes, n_hidden_nodes])</span><br><span class="line">        mlp.fit(X_train, y_train)</span><br><span class="line">        mglearn.plots.plot_2d_separator(mlp, X_train, fill=<span class="literal">True</span>, alpha=<span class="number">.3</span>, ax=ax)</span><br><span class="line">        mglearn.discrete_scatter(X_train[:, <span class="number">0</span>], X_train[:, <span class="number">1</span>], y_train, ax=ax)</span><br><span class="line">        ax.set_title(<span class="string">'n_hidden=[&#123;&#125;, &#123;&#125;]\nalpha=&#123;:.4f&#125;'</span>.format(</span><br><span class="line">            n_hidden_nodes, n_hidden_nodes, alpha))</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-of-mlp-for-different-parameters.png"></p><p>现在你可能已经认识到了，控制神经网络复杂度的方法有很多种：隐层的个数、每个隐层中的单元个数和正则化（alpha）。实际上还有更多，但这里不再过多介绍。</p><p><strong>神经网络的一个重要性质是，在开始学习之前其权重是随机设置的，这种随机初始化会影响学到的模型。</strong>也就是说，即使使用完全相同的参数，如果随机种子不同的话，我们也可能得到非常不一样的模型。<strong>如果网络很大，并且复杂度选择合理的话，那么这应该不会对精度有太大影响，但应该记住这一点（特别是对于较小的网络）</strong>。下图显示了几个模型的图像，所有模型都使用相同的参数设置（随机种子不同）进行学习。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">4</span>, figsize=(<span class="number">20</span>, <span class="number">8</span>))</span><br><span class="line"><span class="keyword">for</span> i, ax <span class="keyword">in</span> enumerate(axes.ravel()):</span><br><span class="line">    mlp = MLPClassifier(solver=<span class="string">'lbfgs'</span>, random_state=i,</span><br><span class="line">        hidden_layer_sizes=[<span class="number">100</span>, <span class="number">100</span>])</span><br><span class="line">    mlp.fit(X_train, y_train)</span><br><span class="line">    mglearn.plots.plot_2d_separator(mlp, X_train, fill=<span class="literal">True</span>, alpha=<span class="number">.3</span>, ax=ax)</span><br><span class="line">    mglearn.discrete_scatter(X_train[:, <span class="number">0</span>], X_train[:, <span class="number">1</span>], y_train, ax=ax)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-of-mlp-for-different-random-states.png"></p><h1 id="将神经网络应用于现实数据">将神经网络应用于现实数据</h1><p>为了在现实世界的数据上进一步理解神经网络，我们将MLPClassifier应用在乳腺癌数据集上，首先使用默认参数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'Cancer data per-feature maxima:\n&#123;&#125;'</span>.format(cancer.data.max(axis=<span class="number">0</span>)))</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">    cancer.data, cancer.target, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">mlp = MLPClassifier(random_state=<span class="number">42</span>)</span><br><span class="line">mlp.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Accuracy on training set: &#123;:.2f&#125;'</span>.format(mlp.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Accuracy on test set: &#123;:.2f&#125;'</span>.format(mlp.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cancer data per-feature maxima:</span><br><span class="line">[2.811e+01 3.928e+01 1.885e+02 2.501e+03 1.634e-01 3.454e-01 4.268e-01</span><br><span class="line"> 2.012e-01 3.040e-01 9.744e-02 2.873e+00 4.885e+00 2.198e+01 5.422e+02</span><br><span class="line"> 3.113e-02 1.354e-01 3.960e-01 5.279e-02 7.895e-02 2.984e-02 3.604e+01</span><br><span class="line"> 4.954e+01 2.512e+02 4.254e+03 2.226e-01 1.058e+00 1.252e+00 2.910e-01</span><br><span class="line"> 6.638e-01 2.075e-01]</span><br><span class="line">Accuracy on training set: 0.94</span><br><span class="line">Accuracy on test set: 0.92</span><br></pre></td></tr></table></figure><p>MLP的精度相当好，但没有其他模型好。与较早的SVC例子相同，原因可能在于数据的缩放。<strong>神经网络也要求所有输入特征的变化范围相似，最理想的情况均值为0、方差为1。</strong>我们必须对数据进行缩放以满足这些要求。这里将人工完成。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算训练集中每个特征的平均值</span></span><br><span class="line">mean_on_train = X_train.mean(axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 计算训练集中每个特征的标准差</span></span><br><span class="line">std_on_train = X_train.std(axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 减去平均值，然后乘以标准差的倒数</span></span><br><span class="line"><span class="comment"># 如此运算之后，mean=0，std=1</span></span><br><span class="line">X_train_scaled = (X_train - mean_on_train) / std_on_train</span><br><span class="line"><span class="comment"># 对测试集做相同的变换</span></span><br><span class="line">X_test_scaled = (X_test - mean_on_train) / std_on_train</span><br><span class="line"></span><br><span class="line">mlp = MLPClassifier(random_state=<span class="number">42</span>)</span><br><span class="line">mlp.fit(X_train_scaled, y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Accuracy on training set: &#123;:.2f&#125;'</span>.format(mlp.score(X_train_scaled, y_train)))</span><br><span class="line">print(<span class="string">'Accuracy on test set: &#123;:.2f&#125;'</span>.format(mlp.score(X_test_scaled, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ConvergenceWarning: Stochastic Optimizer: Maximum iterations (200) reached and the optimization hasn&apos;t converged yet.</span><br><span class="line">  % self.max_iter, ConvergenceWarning)</span><br><span class="line">Accuracy on training set: 0.99</span><br><span class="line">Accuracy on test set: 0.97</span><br></pre></td></tr></table></figure><p>缩放后的结果要好得多，而且也相当有竞争力。不过模型给出了一个警告，告诉我们已经达到了最大迭代次数，但还没有收束。这是用于学习模型的adam算法的一部分，告诉我们应该增加迭代次数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mlp = MLPClassifier(max_iter=<span class="number">1000</span>, random_state=<span class="number">42</span>)</span><br><span class="line">mlp.fit(X_train_scaled, y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Accuracy on training set: &#123;:.2f&#125;'</span>.format(mlp.score(X_train_scaled, y_train)))</span><br><span class="line">print(<span class="string">'Accuracy on test set: &#123;:.2f&#125;'</span>.format(mlp.score(X_test_scaled, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accuracy on training set: 1.00</span><br><span class="line">Accuracy on test set: 0.97</span><br></pre></td></tr></table></figure><p>增加迭代次数仅提高了训练集性能，但没有提高泛化性能。不过模型的表现相当不错。由于训练性能和测试性能之间仍有一些差距，所以我们可以尝试降低模型复杂度来得到更好的泛化性能。这里我们选择增大alpha参数（从默认的0.0001增大到1），以此向权重添加更强的正则化。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mlp = MLPClassifier(max_iter=<span class="number">1000</span>, alpha=<span class="number">1</span>, random_state=<span class="number">42</span>)</span><br><span class="line">mlp.fit(X_train_scaled, y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Accuracy on training set: &#123;:.2f&#125;'</span>.format(mlp.score(X_train_scaled, y_train)))</span><br><span class="line">print(<span class="string">'Accuracy on test set: &#123;:.2f&#125;'</span>.format(mlp.score(X_test_scaled, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accuracy on training set: 0.99</span><br><span class="line">Accuracy on test set: 0.98</span><br></pre></td></tr></table></figure><p>虽然可以分析神经网络学到了什么，但这通常比分析线性模型或基于树的模型更为复杂。要想观察模型学到了什么，一种方法是查看模型的权重。你可以在<code>scikit-learn</code>示例库中查看这样的一个<a href="https://scikit-learn.org/stable/auto_examples/neural_networks/plot_mnist_filters.html" target="_blank" rel="noopener">示例</a>。对于乳腺癌数据集，这可能有点难以理解。下面这张图显示了连接输入和第一个隐层之间的权重。图中的行对应30个输入特征，列对应100个隐单元。浅色代表较大的正值，而深色代表负值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">20</span>, <span class="number">5</span>))</span><br><span class="line">plt.imshow(mlp.coefs_[<span class="number">0</span>], interpolation=<span class="string">'none'</span>, cmap=<span class="string">'viridis'</span>)</span><br><span class="line">plt.yticks(range(<span class="number">30</span>), cancer.feature_names)</span><br><span class="line">plt.xlabel(<span class="string">'Columns in weight matrix'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Input feature'</span>)</span><br><span class="line">plt.colorbar()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/weights-of-first-hidden-layer-in-mlp.png"></p><p>我们可以推断，如果某个特征对所有隐单元的权重都很小，那么这个特征对模型来说就“不太重要”。与其他特征相比，“mean smoothness” “mean compactness”以及“smoothness error”和“fractal dimension error”之间的特征的权重都相对较小。这可能说明这些特征不太重要，也可能是我们没有用神经网络可以使用的方式来表示这些特征。</p><p>我们还可以将连接隐层和输出层的权重可视化，但它们更加难以理解。</p><p>虽然MLPClassifier和MLPRegressor为最常见的神经网络结构提供了易于使用的接口，但它们只包含神经网络潜在应用的一部分。对于Python用户来说，最为完善的是<code>keras</code>、<code>lasagna</code>和<code>tensor-flow</code>。<code>lasagna</code>是基于<code>theano</code>库构建的，而<code>keras</code>既可以用<code>tensor-flow</code>也可以用<code>theano</code>。这些库提供了更为灵活的接口，可以用来构建神经网络并跟踪深度学习研究的快速发展。所有流行的深度学习库也都允许使用高性能的图形处理单元（GPU），而<code>scikit-learn</code>不支持GPU。使用GPU可以将计算速度加快10到100倍，GPU对于将深度学习方法应用到大型数据集上至关重要。</p><h1 id="优点缺点和参数">优点、缺点和参数</h1><p>在机器学习的许多应用中，神经网络再次成为最先进的模型。它的主要优点之一是能够获取大量数据中包含的信息，并构建无比复杂的模型。给定足够的计算时间和数据，并且仔细调节参数，神经网络通常可以打败其他机器学习算法（无论是分类任务还是回归任务）。</p><p>神经网络——特别是功能强大的大型神经网络——通常需要很长的训练时间。它还需要仔细地预处理数据。与SVM类似，神经网络在“均匀”数据上的性能最好，其中“均匀”是指所有特征都具有相似的含义。如果数据包含不同种类的特征，那么基于树的模型可能表现得更好。神经网络调参本身也是一门艺术。调节神经网络模型和训练模型的方法有很多种，我们只是蜻蜓点水地尝试了几种而已。</p><h1 id="估计神经网络的复杂度">估计神经网络的复杂度</h1><p>最重要的参数是层数和每层的隐单元个数。你应该首先设置1个或2个隐层，然后可以逐步增加。每个隐层的结点个数通常与输入特征个数相近，但在几千个结点时很少会多于特征个数。</p><p>在考虑神经网络的模型复杂度时，一个有用的度量是学到的权重（或系数）的个数。如果你有一个包含100个特征的二分类数据集，模型有100个隐单元，那么输入层和第一个隐层之间就有<code>100*100=10000</code>个权重。在隐层和输出层之间还有<code>100*1=100</code>个权重，总共约10100个权重。</p><p><strong>神经网络调参的常用方法是，首先创建一个大到足以过拟合的网络，确保这个网络可以对任务进行学习。知道训练数据可以被学习之后，要么缩小网络，要么增大alpha来增强正则化，这可以提高泛化性能。</strong></p><p>在我们的实验中，主要关注模型的定义：层数、每层的结点个数、正则化和非线性。这些内容定义了我们想要学习的模型。还有一个问题是，<strong>如何</strong>学习模型或用来学习参数的算法，这一点由solver参数设定。solver参数有两个好用的选项。默认选项是'adam'，在大多数情况下效果都很好，但对数据的缩放相当敏感（因此，始终将数据缩放为均值为0、方差为1是很重要的）。另一个选项是'lbfgs'，其鲁棒性相当好，但在大型模型或大型数据集上的时间会比较长。还有更高级的'sgd'选项，许多深度学习研究人员都会用到。'sgd'选项还有许多其他参数需要调节，以便获得最佳结果。当你开始使用MLP时，我们建议使用'adam'和'lbfgs'。</p><p><em>fit会重置模型。<code>scikit-learn</code>模型的一个重要性质就是，调用fit总会重置模型之前学到的所有内容。你可以对一个模型多次调用fit，其结果与在“新“模型上调用fit是完全相同的。</em></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Machine Learning with Python </tag>
            
            <tag> classification </tag>
            
            <tag> neural network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>核支持向量机</title>
      <link href="/notes/introduction-to-ml-with-python/kernelized-support-vector-machine/"/>
      <url>/notes/introduction-to-ml-with-python/kernelized-support-vector-machine/</url>
      
        <content type="html"><![CDATA[<p>核支持向量机（通常简称为SVM）是可以推广到更复杂模型的扩展，这些模型无法被输入空间的超平面定义。虽然支持向量机可以同时用于分类和回归，但我们只会介绍用于分类的情况，它在SVC中实现。类似的概念也适用于支持向量回归，在SVR中实现。</p><h1 id="线性模型与非线性特征">线性模型与非线性特征</h1><p>线性模型在低维空间中可能非常受限，因为线和平面的灵活性有限。有一种方法可以让线性模型更加灵活，就是添加更多的特征——举个例子，添加输入特征的交互项或多项式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X, y = make_blobs(centers=<span class="number">4</span>, random_state=<span class="number">8</span>)</span><br><span class="line">y %= <span class="number">2</span></span><br><span class="line"></span><br><span class="line">mglearn.discrete_scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], y)</span><br><span class="line">plt.xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature 1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> LinearSVC</span><br><span class="line">linear_svm = LinearSVC().fit(X, y)</span><br><span class="line"></span><br><span class="line">mglearn.plots.plot_2d_separator(linear_svm, X)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/linear-svc-on-make-blobs.png"></p><a id="more"></a><p>用于分类的线性模型只能用一条直线来划分数据点，对这个数据集无法给出较好的结果。</p><p>现在我们对输入特征进行扩展，比如说添加第二个特征的平方（<code>feature1 ** 2</code>）作为一个新特征。现在我们将每个数据点表示为三维点<code>(feature0, feature1, feature1 ** 2)</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加第二个特征的平方，作为一个新特征</span></span><br><span class="line">X_new = np.hstack([X, X[:, <span class="number">1</span>:] ** <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D, axes3d</span><br><span class="line">figure = plt.figure()</span><br><span class="line"><span class="comment"># 3D可视化</span></span><br><span class="line">ax = Axes3D(figure, elev=<span class="number">-152</span>, azim=<span class="number">-26</span>)</span><br><span class="line"><span class="comment"># 首先画出所有y == 0的点，然后画出所有y == 1的点</span></span><br><span class="line">mask = y == <span class="number">0</span></span><br><span class="line">ax.scatter(X_new[mask, <span class="number">0</span>], X_new[mask, <span class="number">1</span>], X_new[mask, <span class="number">2</span>], c=<span class="string">'b'</span>,</span><br><span class="line">           cmap=mglearn.cm2, s=<span class="number">60</span>, edgecolor=<span class="string">'k'</span>)</span><br><span class="line">ax.scatter(X_new[~mask, <span class="number">0</span>], X_new[~mask, <span class="number">1</span>], X_new[~mask, <span class="number">2</span>], c=<span class="string">'r'</span>, marker=<span class="string">'^'</span>,</span><br><span class="line">           cmap=mglearn.cm2, s=<span class="number">60</span>, edgecolor=<span class="string">'k'</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">"feature0"</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">"feature1"</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">"feature1 ** 2"</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/datasets-blobs-3d.png"></p><p>在数据的新表示中，现在可以用线性模型（三维空间中的平面）将这两个类别分开。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">linear_svm_3d = LinearSVC().fit(X_new, y)</span><br><span class="line"><span class="comment"># ravel方法将数组展开</span></span><br><span class="line">coef, intercept = linear_svm_3d.coef_.ravel(), linear_svm_3d.intercept_</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示线性决策边界</span></span><br><span class="line">figure = plt.figure()</span><br><span class="line">ax = Axes3D(figure, elev=<span class="number">-152</span>, azim=<span class="number">-26</span>)</span><br><span class="line">xx = np.linspace(X_new[:, <span class="number">0</span>].min() - <span class="number">2</span>, X_new[:, <span class="number">0</span>].max() + <span class="number">2</span>, <span class="number">50</span>)</span><br><span class="line">yy = np.linspace(X_new[:, <span class="number">1</span>].min() - <span class="number">2</span>, X_new[:, <span class="number">1</span>].max() + <span class="number">2</span>, <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">XX, YY = np.meshgrid(xx, yy)</span><br><span class="line"><span class="comment"># model: y = x[0] * coef[0] + x[1] * coef[1] + x[2] * coef[3] + intercept</span></span><br><span class="line"><span class="comment"># boundary: 0 = x[0] * coef[0] + x[1] * coef[1] + x[2] * coef[3] + intercept</span></span><br><span class="line"><span class="comment"># 边界上的x[2] = (x[0] * coef[0] + x[1] * coef[1] + intercept) / -coef[2]</span></span><br><span class="line">ZZ = (coef[<span class="number">0</span>] * XX + coef[<span class="number">1</span>] * YY + intercept) / -coef[<span class="number">2</span>]</span><br><span class="line">ax.plot_surface(XX, YY, ZZ, rstride=<span class="number">8</span>, cstride=<span class="number">8</span>, alpha=<span class="number">0.3</span>)</span><br><span class="line">ax.scatter(X_new[mask, <span class="number">0</span>], X_new[mask, <span class="number">1</span>], X_new[mask, <span class="number">2</span>], c=<span class="string">'b'</span>,</span><br><span class="line">    cmap=mglearn.cm2, s=<span class="number">60</span>)</span><br><span class="line">ax.scatter(X_new[~mask, <span class="number">0</span>], X_new[~mask, <span class="number">1</span>], X_new[~mask, <span class="number">2</span>], c=<span class="string">'r'</span>,</span><br><span class="line">    cmap=mglearn.cm2, s=<span class="number">60</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">'feature0'</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">'feature1'</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">'feature1 ** 2'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-of-linear-svc-on-blobs-3d.png"></p><p>如果将线性SVM模型看作原始特征的函数，即<code>y = coef[0] * x[0] + coef[1] * x[1] + coef[2] * x[1] ** 2</code>，那么它实际上已经不是线性的了。它不是一条直线，而是一个椭圆。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.svm.linearsvc#sklearsn.svm.LinearSVC.decision_function" target="_blank" rel="noopener"><code>decision_function(X)</code></a></p><p>Predict confidence scores for samples. The confidence score for a sample is the signed distance of that sample to the hyperplane.</p></blockquote><blockquote><p><a href="https://devdocs.io/numpy~1.17/generated/numpy.c_" target="_blank" rel="noopener"><code>numpy.c_ = &lt;numpy.lib.index_tricks.CClass object&gt;</code></a></p><p>Translates slice objects to concatenation along the second axis.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.c_[np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]), np.array([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])]</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">6</span>]])</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ZZ = YY ** <span class="number">2</span>  <span class="comment"># 第三特征</span></span><br><span class="line"><span class="comment"># 预测(XX, YY, ZZ)</span></span><br><span class="line">dec = linear_svm_3d.decision_function(np.c_[XX.ravel(), YY.ravel(), ZZ.ravel()])</span><br><span class="line"><span class="comment"># 画出预测结果以边界(0)的位置</span></span><br><span class="line">plt.contour(XX, YY, dec.reshape(XX.shape), levels=[dec.min(), <span class="number">0</span>, dec.max()],</span><br><span class="line">    cmap=mglearn.cm2, alpha=<span class="number">0.5</span>)</span><br><span class="line">mglearn.discrete_scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], y)</span><br><span class="line">plt.xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature 1'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-of-linear-svc-on-blobs-2d.png"></p><h1 id="核技巧">核技巧</h1><p>这里需要记住的是，向数据表示中添加非线性特征，可以让线性模型变得更加强大。但是，通常来说我们并不知道要添加哪些特征，而且添加许多特征（比如100维特征空间所有可能的交互项）的计算开销可能会很大。<strong>幸运的是，有一种巧妙的数学技巧，让我们可以在更高维空间中学习分类器，而不用实际计算可能非常大的新数据表示。这种技巧叫作核技巧（kernel trick），它的原理是直接计算扩展特征表示中数据点之间的距离（更准确地说是内积），而不用实际对扩展进行计算</strong>。</p><p>对于支持向量机，将数据映射到更高维空间中有两种常用的方法：一种是<strong>多项式核</strong>，在一定阶数内计算原始特征所有可能的多项式（比如<code>feature1 ** 2 * feature2 ** 5</code>）；另一种是<strong>径向基函数（radial basis function，RBF）核</strong>，也叫高斯核。高斯核有点难以解释，因为它对应无限维的特征空间。一种对高斯核的解释是它考虑所有阶数的所有可能的多项式，但阶数越高，特征的重要性越小。</p><p>不过在实践中，核SVM背后的数学细节并不是很重要，可以简单地总结出使用RBF核SVM进行预测的方法——我们将在下一节介绍这方面的内容。</p><h1 id="理解svm">理解SVM</h1><p>在训练过程中，SVM学习每个训练数据点对于表示两个类别之间的决策边界的重要性。通常只有一部分训练数据点对于定义决策边界很重要：位于类别之间边界上的那些点。这些点叫作<strong>支持向量</strong>（support vector），支持向量机正是由此得名。</p><p>想要对新样本点进行预测，需要测量它与每个支持向量之间的距离。分类决策是基于它与支持向量之间的距离以及在训练过程中学到的支持向量重要性（保存在SVC的<code>dual_coef_</code>属性中）来做出的。</p><p>数据点之间的距离由高斯核给出：</p><p><span class="math display">\[k_{rbf}(x_1,x_2)=exp(-\gamma\left\| x_1-x_2\right\|^2)\]</span></p><p>这里<span class="math inline">\(x_1\)</span>和<span class="math inline">\(x_2\)</span>是数据点，<span class="math inline">\(\left\| x_1-x_2\right\|\)</span>表示欧式距离，<span class="math inline">\(\gamma\)</span>（gamma）是控制高斯核宽度的参数。</p><p>在forge数据集上训练SVM。决策边界用黑色表示，支持向量是尺寸较大的点。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.svm.svc" target="_blank" rel="noopener"><code>class sklearn.svm.SVC(C=1.0, kernel=’rbf’, degree=3, gamma=’auto_deprecated’, coef0=0.0, shrinking=True, probability=False, tol=0.001, cache_size=200, class_weight=None, verbose=False, max_iter=-1, decision_function_shape=’ovr’, random_state=None)</code></a></p><p>C-Support Vector Classification.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line">X, y = mglearn.tools.make_handcrafted_dataset()</span><br><span class="line">svm = SVC(kernel=<span class="string">'rbf'</span>, C=<span class="number">10</span>, gamma=<span class="number">0.1</span>).fit(X, y)</span><br><span class="line">mglearn.plots.plot_2d_separator(svm, X, eps=<span class="number">.5</span>)</span><br><span class="line">mglearn.discrete_scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], y)</span><br><span class="line"><span class="comment"># 画出支持向量</span></span><br><span class="line">sv = svm.support_vectors_</span><br><span class="line"><span class="comment"># 支持向量的类别标签由dual_coef_的正负号给出</span></span><br><span class="line">sv_labels = svm.dual_coef_.ravel() &gt; <span class="number">0</span></span><br><span class="line">mglearn.discrete_scatter(sv[:, <span class="number">0</span>], sv[:, <span class="number">1</span>], sv_labels, s=<span class="number">15</span>, markeredgewidth=<span class="number">3</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature 1'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-of-svm.png"></p><p>在这个例子中，SVM给出了非常平滑且非线性（不是直线）的边界。</p><h1 id="svm调参">SVM调参</h1><p>gamma参数是上一节给出的公式中的参数，用于控制高斯核的宽度。它决定了点与点之间“靠近”是指多大的距离。C参数是正则化参数，与线性模型中用到的类似。它限制每个点的重要性（或者更确切地说，每个点的<code>dual_coef_</code>）。</p><p>我们来看一下，改变这些参数时会发生什么。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, axes = plt.subplots(<span class="number">3</span>, <span class="number">3</span>, figsize=(<span class="number">15</span>, <span class="number">10</span>))</span><br><span class="line"><span class="keyword">for</span> ax, C <span class="keyword">in</span> zip(axes, [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">3</span>]):</span><br><span class="line">    <span class="keyword">for</span> a, gamma <span class="keyword">in</span> zip(ax, range(<span class="number">-1</span>, <span class="number">2</span>)):</span><br><span class="line">        mglearn.plots.plot_svm(log_C=C, log_gamma=gamma, ax=a)</span><br><span class="line">axes[<span class="number">0</span>, <span class="number">0</span>].legend([<span class="string">'class 0'</span>, <span class="string">'class 1'</span>, <span class="string">'sv class 0'</span>, <span class="string">'sv class 1'</span>],</span><br><span class="line">    ncol=<span class="number">4</span>, loc=(<span class="number">.9</span>, <span class="number">1.2</span>))</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-of-svm-for-different-parameters.png"></p><p>从左到右，我们将gamma的值从0.1增加到10。<strong>gamma较小，说明高斯核半径较大，许多点都被看作比较靠近。</strong>这一点可以在图中看出：左侧的图决策边界非常平滑，越向右的图决策边界更关注单个点。小的gamma值表示决策边界变化很慢，生成的事复杂度较低的模型，而大的gamma值则会生成更为复杂的模型。</p><p>从上到下，我们将参数C的值从0.1增加到1000。<strong>与线性模型相同，C值很小，说明模型非常受限，每个数据点的影响范围都有限。</strong>你可以看到，左上图的图中，决策边界看起来几乎是线性的，误分类的点对边界几乎没有任何影响。再看左下角的图，增大C之后这些点对模型的影响变大，使得决策边界发生弯曲来将这些点正确分类。</p><p>我们将RBF核SVM应用到乳腺癌数据集上。默认情况下，<code>C=1, gamma=1/n_features</code>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">    cancer.data, cancer.target, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">svc = SVC()</span><br><span class="line">svc.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Accuracy on training set: &#123;:.2f&#125;'</span>.format(svc.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Accuracy on test set: &#123;:.2f&#125;'</span>.format(svc.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accuracy on training set: 1.00</span><br><span class="line">Accuracy on test set: 0.63</span><br></pre></td></tr></table></figure><p>这个模型在训练集上的分数十分完美，但在测试集上的精度只有63%，存在相当严重的过拟合。<strong>虽然SVM的表现通常都很好，但它对参数的设定和数据的缩放非常敏感。特别地，它要求所有特征有相似的变化范围。</strong>我们来看一下每个特征的最小值和最大值，它们绘制在对数坐标上。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(X_train.min(axis=<span class="number">0</span>), <span class="string">'o'</span>, label=<span class="string">'min'</span>)</span><br><span class="line">plt.plot(X_train.max(axis=<span class="number">0</span>), <span class="string">'^'</span>, label=<span class="string">'max'</span>)</span><br><span class="line">plt.legend(loc=<span class="number">4</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Feature index'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature magnitude'</span>)</span><br><span class="line">plt.yscale(<span class="string">'log'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/features-magnitude-of-cancer.png"></p><p>从这张图中，我们可以确定乳腺癌数据集的特征具有完全不同的量级。这对其他模型来说（比如线性模型）可能是小问题，但对核SVM却有极大影响。我们来研究处理这个问题的几种方法： 。</p><h1 id="为svm预处理数据">为SVM预处理数据</h1><p>解决这个问题的一种方法就是对每个特征进行缩放，使其大致都位于同一范围。核SVM常用的缩放方法就是将所有特征缩放到0和1之间。现在我们来“人工”处理。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算训练集中每个特征的最小值</span></span><br><span class="line">min_on_training = X_train.min(axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 计算训练集中每个特征的范围（最大值-最小值）</span></span><br><span class="line">range_on_training = (X_train - min_on_training).max(axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 减去最小值，然后除以范围</span></span><br><span class="line"><span class="comment"># 这样每个特征都是min=0和max=1</span></span><br><span class="line">X_train_scaled = (X_train - min_on_training) / range_on_training</span><br><span class="line">print(<span class="string">'Minimum for each feature\n&#123;&#125;'</span>.format(X_train_scaled.min(axis=<span class="number">0</span>)))</span><br><span class="line">print(<span class="string">'Maximum for each feature\n&#123;&#125;'</span>.format(X_train_scaled.max(axis=<span class="number">0</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对测试集做相同的变换</span></span><br><span class="line">X_test_scaled = (X_test - min_on_training) / range_on_training</span><br><span class="line"></span><br><span class="line">svc = SVC()</span><br><span class="line">svc.fit(X_train_scaled, y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Accuracy on training set: &#123;:.3f&#125;'</span>.format(svc.score(X_train_scaled, y_train)))</span><br><span class="line">print(<span class="string">'Accuracy on test set: &#123;:.3f&#125;'</span>.format(svc.score(X_test_scaled, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Minimum for each feature</span><br><span class="line">[0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.</span><br><span class="line"> 0. 0. 0. 0. 0. 0.]</span><br><span class="line">Maximum for each feature</span><br><span class="line">[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.</span><br><span class="line"> 1. 1. 1. 1. 1. 1.]</span><br><span class="line">Accuracy on training set: 0.948</span><br><span class="line">Accuracy on test set: 0.951</span><br></pre></td></tr></table></figure><p>数据缩放的作用很大！<strong>实际上模型现在处于欠拟合的状态，因为训练集和测试集的性能非常接近，但还没有接近100%的精度。</strong>从这里开始，我们可以尝试增大C或gamma来拟合更为复杂的模型。例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">svc = SVC(C=<span class="number">1000</span>)</span><br><span class="line">svc.fit(X_train_scaled, y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Accuracy on training set: &#123;:.3f&#125;'</span>.format(svc.score(X_train_scaled, y_train)))</span><br><span class="line">print(<span class="string">'Accuracy on test set: &#123;:.3f&#125;'</span>.format(svc.score(X_test_scaled, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accuracy on training set: 0.988</span><br><span class="line">Accuracy on test set: 0.972</span><br></pre></td></tr></table></figure><p>在这个例子中，增大C可以显著改善模型，得到97.2%的精度。</p><h1 id="优点缺点和参数">优点、缺点和参数</h1><p>核支持向量机是非常强大的模型，在各种数据集上的表现都很好。SVM允许决策边界很复杂，即使数据只有几个特征。它在低维数据和高维数据（即很少特征和很多特征）上的表现都很好，但对样本个数的缩放表现不好。在有多达10000个样本的数据上运行SVM可能表现良好，但如果数据量达到100000甚至更大，在运行时间和内存使用方法可能会面临挑战。</p><p>SVM的另一个缺点是，预处理数据和调参都需要非常小心。这也是为什么如今很多应用中用的都是基于树的模型，比如随机森林或梯度提升（需要很少的预处理，甚至不需要预处理）。此外SVM模型很难检查，可能很难理解为什么会这么预测，而且也难以将模型向非专家进行解释。</p><p>不过SVM仍然是值得尝试的，特别是所有特征的测量单位相似（比如都是像素密度）而且范围也差不多时，</p><p>核SVM的重要参数是正则化参数C、核的选择以及与核相关的参数。RBF核只有一个参数gamma，它是高斯核宽度的倒数。gamma和C控制的都是模型复杂度，较大的值都对应更为复杂的模型。因此，这两个参数的设定通常是强烈相关的，应该同时调节。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Machine Learning with Python </tag>
            
            <tag> supervised </tag>
            
            <tag> classification </tag>
            
            <tag> SVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>决策树集成</title>
      <link href="/notes/introduction-to-ml-with-python/decision-tree-ensemble/"/>
      <url>/notes/introduction-to-ml-with-python/decision-tree-ensemble/</url>
      
        <content type="html"><![CDATA[<p><strong>集成</strong>（ensemble）是合并多个机器学习模型来构建更强大模型的方法。在机器学习文献中有很多模型都属于这一类，但已证明有两种集成模型对大量分类和回归的数据集都是有效的，二者都以决策树为基础，分别是随机森林（random forest）和梯度提升决策树（gradient boosted decision tree）。</p><h1 id="随机森林">随机森林</h1><p>决策树的一个主要缺点在于经常对训练数据过拟合。随机森林是解决这个问题的一种方法。随机森林本质上是许多决策树的集合，其中每棵树都和其他树略有不同。随机森林背后的思想是，每棵树的预测可能都相对较好，但可能对部分数据过拟合。如果构造很多树，并且每棵树的预测都很好，但都以不同的方式过拟合，那么我们可以对这些树的结果取平均值来降低过拟合。既能减少过拟合又能保持树的预测能力，这可以在数学上严格证明。</p><p>为了实现这一策略，我们需要构造许多决策树。每棵树都应该对目标值做出可以接受的预测，还应该与其他树不同。随机森林的名字来自于将随机性添加到树的构造过程中，以确保每棵树都各不相同。<strong>随机森林中树的随机化方法有两种：一种是通过选择用于构造树的数据点，另一种是通过选择每次划分测试的特征。</strong></p><a id="more"></a><h2 id="构造随机森林">构造随机森林</h2><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.ensemble.randomforestclassifier" target="_blank" rel="noopener"><code>class sklearn.ensemble.RandomForestClassifier(n_estimators=’warn’, criterion=’gini’, max_depth=None, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_features=’auto’, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, bootstrap=True, oob_score=False, n_jobs=None, random_state=None, verbose=0, warm_start=False, class_weight=None)</code></a></p></blockquote><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.ensemble.randomforestregressor" target="_blank" rel="noopener"><code>class sklearn.ensemble.RandomForestRegressor(n_estimators=’warn’, criterion=’mse’, max_depth=None, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_features=’auto’, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, bootstrap=True, oob_score=False, n_jobs=None, random_state=None, verbose=0, warm_start=False)</code></a></p></blockquote><p>想要构造一个随机森林模型，你需要确定用于构造的树的个数（<code>n_estimators</code>参数）。比如我们想要构造10棵树。这些树在构造时彼此完全独立，算法对每棵树进行不同的随机选择，以确保树和树之间是有区别的。想要构造一棵树，首先要对数据进行<strong>自助采样</strong>（bootstrap sample）。也就是说，从<code>n_samples</code>个数据点中有放回地重复随机抽取一个样本，共抽取<code>n_samples</code>次。这样会创建一个与原始数据集大小相同的数据集，但有些数据点会缺失（大约三分之一），有些会重复。</p><p>举例说明，比如我们想要创建列表['a', 'b', 'c', 'd']的自助采样。一种可能的自助采样是['b', 'd', 'd', 'c']，另一种可能的采样为['d', 'a', 'd', 'a']。</p><p>接下来，基于这个新创建的数据集来构造决策树。但是，要对我们在介绍决策树时描述的算法稍作修改。在每个结点处，算法随机选择特征的一个子集，并对其中一个特征寻找最佳测试，而不是对每个结点都寻找最佳测试。选择的特征个数由<code>max_features</code>参数来控制。每个结点中特征子集的选择是相互独立的，这样树的每个结点可以使用特征的不同子集来做出决策。</p><p>由于使用了自助采样，随机森林中构造每棵决策树的数据集都是略有不同的。由于每个结点的特征选择，每棵树中的每次划分都是基于特征的不同子集。这两种方法共同保证随机森林中所有树都不相同。</p><p>在这个过程中的一个关键参数是<code>max_features</code>。如果我们设置<code>max_features</code>等于<code>n_features</code>，那么每次划分都要考虑数据集的所有特征，在特征选择的过程中没有添加随机性（不过自助采样依然存在随机性））。如果设置<code>max_features</code>等于1，那么在划分时将无法选择对哪个特征进行测试，只能对随机选择的某个特征搜索不同的阈值。因此，如果<code>max_features</code>较大，那么随机森林中的树将会十分相似，利用最独特的特征可以轻松拟合数据。如果<code>max_features</code>较小，那么随机森林中的树将会差异很大，为了很好地拟合数据，每棵树的深度都要很大。</p><p>想要利用随机森林进行预测，算法首先对森林中的每棵树进行预测。对于回归问题，我们可以对这些结果取平均值作为最终预测。对于分类问题，则用到了“软投票”（soft voting）策略。也就是说，每棵树做出“软“预测，给出每个可能的输出标签的概率。对所有树的预测概率取平均值，然后将概率最大的类别作为预测结果。</p><h2 id="分析随机森林">分析随机森林</h2><p>下面将由5棵树组成的随机森林应用到前面研究过的<code>two_moons</code>数据集上：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_moons</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"></span><br><span class="line">X, y = make_moons(n_samples=<span class="number">100</span>, noise=<span class="number">0.25</span>, random_state=<span class="number">3</span>)</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, stratify=y, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">forest = RandomForestClassifier(n_estimators=<span class="number">5</span>, random_state=<span class="number">2</span>)</span><br><span class="line">forest.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">3</span>, figsize=(<span class="number">20</span>, <span class="number">10</span>))</span><br><span class="line"><span class="keyword">for</span> i, (ax, tree) <span class="keyword">in</span> enumerate(zip(axes.ravel(), forest.estimators_)):  <span class="comment"># 树被保存在estimator_属性中</span></span><br><span class="line">    ax.set_title(<span class="string">'Tree &#123;&#125;'</span>.format(i))</span><br><span class="line">    mglearn.plots.plot_tree_partition(X_train, y_train, tree, ax=ax)</span><br><span class="line"></span><br><span class="line">mglearn.plots.plot_2d_separator(forest, X_train, fill=<span class="literal">True</span>, ax=axes[<span class="number">-1</span>, <span class="number">-1</span>])</span><br><span class="line">axes[<span class="number">-1</span>, <span class="number">-1</span>].set_title(<span class="string">'Random Forest'</span>)</span><br><span class="line">mglearn.discrete_scatter(X_train[:, <span class="number">0</span>], X_train[:, <span class="number">1</span>], y_train)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-of-random-forest.png"></p><p>你可以清楚地看到，这5棵树学到的决策边界大不相同。每棵树都犯了一些错误，因为这里画出的一些训练点实际上并没有包含在树的训练集中，原因在于自助采样。</p><p>随机森林比单独每一棵树的过拟合都要小，给出的决策边界也更符合直觉。在任何实际应用中，我们会用到更多棵树（通常是几百或上千），从而得到更平滑的边界。</p><p>再举一个例子，我们将包含100棵树的随机森林应用在乳腺癌数据集上：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cancer = load_breast_cancer()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">    cancer.data, cancer.target, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">forest = RandomForestClassifier(n_estimators=<span class="number">100</span>, random_state=<span class="number">0</span>)</span><br><span class="line">forest.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Accuracy on training set: &#123;:.3f&#125;'</span>.format(forest.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Accuracy on test set: &#123;:.3f&#125;'</span>.format(forest.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accuracy on training set: 1.000</span><br><span class="line">Accuracy on test set: 0.972</span><br></pre></td></tr></table></figure><p>在没有调节任何参数的情况下，随机森林的精度为97%，比线性模型或单棵决策树都要好。我们可以调节<code>max_featues</code>参数，或者像单棵决策树那样进行预剪枝。但是，随机森林的默认参数通常就已经可以给出很好的结果。</p><p>与决策树类似，随机森林也可以给出特征重要性，计算方法是将森林中所有树的特征重要性求和并取平均。一般来说，随机森林给出的特征重要性要比单棵树给出的更为可靠。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plot_feature_importances_cancer(forest)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/feature-importances-of-random-forest.png"></p><p>如你所见，与单棵树相比，随机森林中有更多特征的重要性不为零。与单棵决策树类似，随机森林也给出了&quot;worst radius&quot;（最大半径）特征很大的重要性，但从总体来看，它实际上却选择&quot;worst perimeter&quot;（最大周长）作为信息量最大的特征。由于构造随机森林过程中的随机性，算法需要考虑多种可能的解释，结果就是随机森林比单棵树更能从总体把握数据的特征。</p><h2 id="优点缺点和参数">优点、缺点和参数</h2><p>用于回归和分类的随机森林是目前应用最广泛的机器学习方法之一。这种方法非常强大，通常不需要反复调节参数就可以给出很好的结果，也不需要对数据进行缩放。</p><p>从本质上看，随机森林拥有决策树的所有优点，同时弥补了决策树的一些缺陷。仍然使用决策树的一个原因是需要决策过程的紧凑表示。基本上不可能对几十棵甚至上百棵树做出详细解释，随机森林中树的深度往往比决策树还要大（因为用到了特征子集）。因此，如果你需要以可视化的方式向非专家总结预测过程，那么选择单棵决策树可能更好。虽然在大型数据集上构建随机森林可能比较费时间，但在一台计算机的多个CPU内核上并行计算也很容易。如果你用的是多核处理器，你可以用<code>n_jobs</code>参数来调节使用的内核个数。使用更多的CPU内核，可以让速度线性增加，但设置<code>n_jobs</code>大于内核个数是没有用的。你可以设置<code>n_jobs=-1</code>来使用计算机的所有内核。</p><p>你应该记住，随机森林本质上是随机的，设置不同的随机状态（或者不设置<code>random_state</code>参数）可以彻底改变构建的模型。森林中的树越多，它对随机状态选择的鲁棒性就越好。如果你希望结果可以重现，固定<code>random_state</code>是很重要的。</p><p>对于维度非常高的稀疏数据（比如文本数据），随机森林的表现往往不是很好。对于这种数据，使用线性模型可能更为合适。即使是非常大的数据集，随机森林的表现也通常也很好，训练过程很容易并行在功能强大的计算机的多个CPU内核上。不过，随机森林需要更大的内存，训练和预测的速度也比线性模型要慢。对一个应用来说，如果时间和内存很重要的话，那么换用线性模型可能更为明智。</p><p>需要调节的重要参数有<code>n_estimators</code>和<code>max_features</code>，可能还包括预剪枝选项（如<code>max_depth</code>）。<strong><code>n_estimators</code>总是越大越好。</strong>对更多的树取平均可以降低过拟合，从而得到鲁棒性更好的集成。不过收益是递减的，而且树越多需要的内存也越多，训练时间也越长。<strong>常用的经验法则就是“在你的时间/内存允许的情况下尽量多”。</strong></p><p>前面说过，<code>max_features</code>决定每棵树的随机性大小，较小的<code>max_features</code>可以降低过拟合。<strong>一般来说，好的经验就是使用默认值：对于分类，默认值是<code>max_features=sqrt(n_features)</code>；对于回归，默认值是<code>max_features=n_features</code>。</strong>增大<code>max_features</code>或<code>max_leaf_nodes</code>有时也可以提高性能。它还可以大大降低用于训练和预测的时间和空间要求。</p><h1 id="梯度提升回归树">梯度提升回归树</h1><p>梯度提升回归树是另一种集成方法，通过合并多个决策树来构建一个更为强大的模型。虽然名字中含有“回归”，但这个模型既可以用于回归也可以用于分类。与随机森林方法不同，梯度提升采用连续的方式构造树，每棵树都试图纠正前一棵树的错误。默认情况下，梯度提升回归树中没有随机化，而是用到了强预剪枝。梯度提升树通常使用深度很小（1到5之间）的树，这样模型占用的内存更少，预测速度也更快。</p><p>梯度提升背后的主要思想是合并许多简单的模型（在这个语境中叫作<strong>弱学习器</strong>），比如深度较小的树。每棵树只能对部分数据做出好的预测，因此，添加的树越来越多，可以不断迭代提高性能。</p><p>梯度提升树经常是机器学习竞赛的优胜者，并且广泛应用于业界。与随机森林相比，它通常对参数设置更为敏感，但如果参数设置正确的话，模型精度更高。</p><p>除了预剪枝与集成中树的数量之外，梯度提升的另一个重要参数是<code>learning_rate</code>（学习率），用于控制每棵树纠正前一棵树的错误的强度。较高的学习率意味着每棵树都可以做出较强的修正，这样模型更为复杂。通过增大<code>n_estimators</code>来向集成中添加更多树，也可以增加模型复杂度，因为模型有更多机会纠正训练集上的错误。</p><p>下面是在乳腺癌数据集上应用GradientBoostingClassifier的示例。默认使用100棵树，最大深度是3，学习率是0.1。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.ensemble.gradientboostingclassifier" target="_blank" rel="noopener"><code>class sklearn.ensemble.GradientBoostingClassifier(loss=’deviance’, learning_rate=0.1, n_estimators=100, subsample=1.0, criterion=’friedman_mse’, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_depth=3, min_impurity_decrease=0.0, min_impurity_split=None, init=None, random_state=None, max_features=None, verbose=0, max_leaf_nodes=None, warm_start=False, presort=’auto’, validation_fraction=0.1, n_iter_no_change=None, tol=0.0001)</code></a></p></blockquote><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.ensemble.gradientboostingregressor" target="_blank" rel="noopener"><code>class sklearn.ensemble.GradientBoostingRegressor(loss=’ls’, learning_rate=0.1, n_estimators=100, subsample=1.0, criterion=’friedman_mse’, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_depth=3, min_impurity_decrease=0.0, min_impurity_split=None, init=None, random_state=None, max_features=None, alpha=0.9, verbose=0, max_leaf_nodes=None, warm_start=False, presort=’auto’, validation_fraction=0.1, n_iter_no_change=None, tol=0.0001)</code></a></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> GradientBoostingClassifier</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">    cancer.data, cancer.target, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">gbrt = GradientBoostingClassifier(random_state=<span class="number">0</span>)</span><br><span class="line">gbrt.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Accuracy on training set: &#123;:.3f&#125;'</span>.format(gbrt.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Accuracy on test set: &#123;:.3f&#125;'</span>.format(gbrt.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accuracy on training set: 1.000</span><br><span class="line">Accuracy on test set: 0.965</span><br></pre></td></tr></table></figure><p>由于训练集进度达到100%，所以很可能存在过拟合。为了降低过拟合，我们可以限制最大深度来加强预剪枝，也可以降低学习率。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gbrt = GradientBoostingClassifier(random_state=<span class="number">0</span>, max_depth=<span class="number">1</span>)  <span class="comment"># 限制最大深度</span></span><br><span class="line">gbrt.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Accuracy on training set: &#123;:.3f&#125;'</span>.format(gbrt.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Accuracy on test set: &#123;:.3f&#125;'</span>.format(gbrt.score(X_test, y_test)))</span><br><span class="line"></span><br><span class="line">gbrt = GradientBoostingClassifier(random_state=<span class="number">0</span>, learning_rate=<span class="number">0.01</span>)  <span class="comment"># 降低学习率</span></span><br><span class="line">gbrt.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Accuracy on training set: &#123;:.3f&#125;'</span>.format(gbrt.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Accuracy on test set: &#123;:.3f&#125;'</span>.format(gbrt.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accuracy on training set: 0.991</span><br><span class="line">Accuracy on test set: 0.972</span><br><span class="line">Accuracy on training set: 0.988</span><br><span class="line">Accuracy on test set: 0.965</span><br></pre></td></tr></table></figure><p>降低模型复杂度的两种方法都降低了训练集精度，这和预期相同。在这个例子中，减小树的最大深度显著提升了模型性能。</p><p>对于其他基于决策树的模型，我们也可以将特征重要性可视化，以便更好地理解模型。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gbrt = GradientBoostingClassifier(random_state=<span class="number">0</span>, max_depth=<span class="number">1</span>)</span><br><span class="line">gbrt.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">plot_feature_importances_cancer(gbrt)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/feature-importances-of-gbrt.png"></p><p>可以看到，梯度体征树的特征重要性与随机森林的特征重要性有些类似，不过梯度提升完全忽略了某些特征。</p><p><strong>由于梯度提升和随机森林两种方法在类似的数据上表现得都很好，因此一种常用的方法就是先尝试随机森林，它的鲁棒性很好。如果随机森林效果很好，但预测时间太长，或者机器学习模型精度小数点后第二位的提高也很重要，那么切换成梯度提升通常会有用。</strong></p><h2 id="优点缺点和参数-1">优点、缺点和参数</h2><p>梯度提升决策树是监督学习中最强大也最常用的模型之一。其主要缺点是需要仔细调参，而且训练时间可能会比较长。与其他基于树的模型类似，这一算法不需要对数据进行缩放就可以表现得很好，而且也适用于二元特征与连续特征同时存在的数据集。<strong>与其他基于树的模型相同，它也通常不适用于高维稀疏数据。</strong></p><p>梯度提升树模型的主要参数包括树的数量<code>n_estimators</code>和学习率<code>learning_rate</code>，后者用于控制每棵树对前一棵树的错误的纠正强度。这两个参数高度相关，因为<code>learning_rate</code>越低，就需要更多的树来构建具有相似复杂度的模型。随机森林的<code>n_estimators</code>值总是越大越好，但梯度提升不同，增大<code>n_estimators</code>会导致模型更加复杂，进而可能导致过拟合。通常的做法是根据时间和内存的预算选择合适的<code>n_estimators</code>，然后对不同的<code>learning_rate</code>进行遍历。</p><p>另一个重要参数是<code>max_depth</code>（或<code>max_leaf_nodes</code>），用于降低每棵树的复杂度。梯度提升模型的<code>max_depth</code>通常都设置的很小，一般不超过5。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Machine Learning with Python </tag>
            
            <tag> supervised </tag>
            
            <tag> regression </tag>
            
            <tag> classification </tag>
            
            <tag> decision tree </tag>
            
            <tag> ensemble </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>决策树</title>
      <link href="/notes/introduction-to-ml-with-python/decision-trees/"/>
      <url>/notes/introduction-to-ml-with-python/decision-trees/</url>
      
        <content type="html"><![CDATA[<p>决策树是广泛用于分类和回归任务的模型。本质上，它是从一层层的if/else问题中进行学习，并得出结论。想象一下，你想要区分下面四种动物：熊、鹰、企鹅和海豚。你的目标是通过尽可能少的if/else问题来得到正确答案。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> graphviz</span><br><span class="line"></span><br><span class="line">mygraph = graphviz.Digraph(node_attr=&#123;<span class="string">'shape'</span>: <span class="string">'box'</span>&#125;,</span><br><span class="line">                           edge_attr=&#123;<span class="string">'labeldistance'</span>: <span class="string">"10.5"</span>&#125;,</span><br><span class="line">                           format=<span class="string">"svg"</span>)</span><br><span class="line">mygraph.node(<span class="string">"0"</span>, <span class="string">"有没有羽毛？"</span>)</span><br><span class="line">mygraph.node(<span class="string">"1"</span>, <span class="string">"会不会飞？"</span>)</span><br><span class="line">mygraph.node(<span class="string">"2"</span>, <span class="string">"有没有鳍？"</span>)</span><br><span class="line">mygraph.node(<span class="string">"3"</span>, <span class="string">"鹰"</span>)</span><br><span class="line">mygraph.node(<span class="string">"4"</span>, <span class="string">"企鹅"</span>)</span><br><span class="line">mygraph.node(<span class="string">"5"</span>, <span class="string">"海豚"</span>)</span><br><span class="line">mygraph.node(<span class="string">"6"</span>, <span class="string">"熊"</span>)</span><br><span class="line">mygraph.edge(<span class="string">"0"</span>, <span class="string">"1"</span>, label=<span class="string">"有"</span>)</span><br><span class="line">mygraph.edge(<span class="string">"0"</span>, <span class="string">"2"</span>, label=<span class="string">"没有"</span>)</span><br><span class="line">mygraph.edge(<span class="string">"1"</span>, <span class="string">"3"</span>, label=<span class="string">"会"</span>)</span><br><span class="line">mygraph.edge(<span class="string">"1"</span>, <span class="string">"4"</span>, label=<span class="string">"不会"</span>)</span><br><span class="line">mygraph.edge(<span class="string">"2"</span>, <span class="string">"5"</span>, label=<span class="string">"有"</span>)</span><br><span class="line">mygraph.edge(<span class="string">"2"</span>, <span class="string">"6"</span>, label=<span class="string">"没有"</span>)</span><br><span class="line">mygraph.render(view=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-tree-on-animal.svg"></p><p>用机器学习的语言来说就是，为了区分四类动物，我们利用三个特征（“有没有羽毛” “会不会飞”和“有没有鳍”）来构建一个模型。我们可以利用监督学习从数据中学习模型，而无需人为构建模型。</p><a id="more"></a><h1 id="构造决策树">构造决策树</h1><p>我们在一个二维分类数据集<code>two_moons</code>上构造决策树。这个数据集由2个半月形组成，每个类别都包含50个数据点。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_tree_progressive()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/datasets-two-moons.png"></p><p>学习决策树，就是学习一系列if/else问题，使我们能够以最快的速度得到正确答案。在机器学习中，这些问题叫作测试。数据通常并不是像动物的例子那样具有二元特征（是/否）的形式，而是表示为连续特征。用于连续数据的测试形式是：”特征i的值是否大于a？“</p><p>为了构造决策树，算法搜遍所有可能的测试，找出对目标变量来说信息量最大的那一个。下图展示了选出的第一个测试。</p><p><img src="/uploads/image/introduction-to-ml-with-python/depth-1-decision-tree-on-two-moons.png"></p><p>将数据集在x[1]=0.0596处垂直划分可以得到最多的信息，它在最大程度上将类别0中的点与类别1中的点进行区分。顶结点（也叫根结点）表示整个数据集。通过测试x[1]&lt;=0.0596的真假来对数据集进行划分，在图中表示为一条黑线。如果测试结果为真，那么将这个点分配给左结点，左结点里包含属于类别0的2个点和属于类别1的32个点。否则将这个点分配给右结点。这两个结点对应图中的顶部区域和底部区域。尽管第一次划分已经对两个类别做了很好的区分，但底部区域仍包含属于类别0的点，顶部区域也仍包含属于类别1的点。我们可以在两个区域中重复寻找最佳测试的过程，从而构建出更准确的模型。下图展示了信息量最大的下一次划分，这次划分是基于x[0]做出的，分为左右两个区域。</p><p><img src="/uploads/image/introduction-to-ml-with-python/depth-2-decision-tree-on-two-moons.png"></p><p>这一递归过程生成一棵二元决策树，其中每个结点都包含一个测试。由于每个测试仅关注一个特征，所以划分后的区域边界始终与坐标轴平行。</p><p>对数据反复进行递归划分，直到划分后的每个区域（决策树的每个叶结点）只包含单一目标值（单一类别或单一回归值）。如果树中某个叶结点所包含数据点的目标值都相同，那么这个叶结点就是纯的（pure）。这个数据集的最终划分如下图。想要对新数据点进行预测，首先要查看这个点位于特征空间划分的哪个区域，然后将该区域的多数目标值作为预测结果。</p><p><img src="/uploads/image/introduction-to-ml-with-python/depth-9-decision-tree-on-two-moons.png"></p><p>决策树也可以用于回归任务，使用的方法完全相同。预测的方法是，基于每个结点的测试对树进行遍历，最终找到新数据点所属的叶结点。这一数据点的输出即为此叶结点中所有训练点的平均目标值。</p><h1 id="控制决策树的复杂度">控制决策树的复杂度</h1><p>通常来说，构造决策树直到所有叶结点都是纯的叶结点，这会导致模型非常复杂，并且对训练数据高度过拟合。纯叶结点的存在说明这棵树在训练集上的精度是100%。训练集中的每个数据点都位于分类正确的叶结点中。在上图中可以看出过拟合，在所有属于类别0的点中有一块属于类别1的区域。另一方面，有一小条属于类别0的区域，包围着最右侧属于类别0的那个点。这并不是人们想象中决策边界的样子，这个决策边界过于关注远离同类别其他点的单个异常点。</p><p>防止过拟合有两种常见策略：一种是及早停止树的生长，也叫<strong>预剪枝</strong>（pre-pruning）；另一种是先构造树，但随后删除或折叠信息量很少的结点，也叫<strong>后剪枝</strong>（post-pruning）或<strong>剪枝</strong>（pruning）。预剪枝的限制条件可能包含限制树的最大深度、限制叶结点的最大数目，或者规定一个结点中数据点的最小数目来防止继续划分。</p><p>我们在乳腺癌数据集上更详细地看一下预剪枝的效果。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.tree.decisiontreeclassifier" target="_blank" rel="noopener"><code>class sklearn.tree.DecisionTreeClassifier(criterion=’gini’, splitter=’best’, max_depth=None, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_features=None, random_state=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, class_weight=None, presort=False)</code></a></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"></span><br><span class="line">cancer = load_breast_cancer()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(cancer.data,</span><br><span class="line">    cancer.target, stratify=cancer.target, random_state=<span class="number">42</span>)</span><br><span class="line">tree = DecisionTreeClassifier(random_state=<span class="number">0</span>)  <span class="comment"># 默认将树完全展开（所有叶结点都是纯的）</span></span><br><span class="line">tree.fit(X_train, y_train)</span><br><span class="line">print(<span class="string">'Accuracy on training set: &#123;:.3f&#125;'</span>.format(tree.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Accuracy on test set: &#123;:.3f&#125;'</span>.format(tree.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accuracy on training set: 1.000</span><br><span class="line">Accuracy on test set: 0.937</span><br></pre></td></tr></table></figure><p>不出所料，训练集上的精度是100%，这是因为叶结点都是纯的，树的深度很大，足以完美地记住训练数据的所有标签。测试集精度比线性模型略低，线性模型的精度约为95%。</p><p>如果我们不限制决策树的深度，它的深度和复杂度都可以变得特别大。因此，未剪枝的树容易过拟合，对新数据的泛化能力不佳。现在我们将预剪枝应用在决策树上，这可以在完美拟合训练数据之前阻止树的展开。一种选择是在到达一定深度后停止树的展开。这里我们设置<code>max_depth=4</code>，这意味着只可以连续问4个问题。限制树的深度可以减少过拟合。这会降低训练集的精度，但可以提高测试集的精度。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tree = DecisionTreeClassifier(max_depth=<span class="number">4</span>, random_state=<span class="number">0</span>)</span><br><span class="line">tree.fit(X_train, y_train)</span><br><span class="line">print(<span class="string">'Accuracy on training set: &#123;:.3f&#125;'</span>.format(tree.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Accuracy on test set: &#123;:.3f&#125;'</span>.format(tree.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accuracy on training set: 0.988</span><br><span class="line">Accuracy on test set: 0.951</span><br></pre></td></tr></table></figure><h1 id="分析决策树">分析决策树</h1><p>我们可以利用tree模块的export_graphviz函数来将树可视化。这个函数会生成一个.dot格式的文件，这是一种用于保存图形的文本文件格式。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.tree.export_graphviz#sklearn.tree.export_graphviz" target="_blank" rel="noopener"><code>sklearn.tree.export_graphviz(decision_tree, out_file=None, max_depth=None, feature_names=None, class_names=None, label=’all’, filled=False, leaves_parallel=False, impurity=True, node_ids=False, proportion=False, rotate=False, rounded=False, special_characters=False, precision=3)</code></a></p><p>Export a decision tree in DOT format.</p><p>This function generates a GraphViz representation of the decision tree, which is then written into <code>out_file</code>. Once exported, graphical renderings can be generated using, for example:</p><p><code>$ dot -Tps tree.dot -o tree.ps      (PostScript format)</code></p><p><code>$ dot -Tpng tree.dot -o tree.png    (PNG format)</code></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> export_graphviz</span><br><span class="line">export_graphviz(tree, out_file=<span class="string">'tree.dot'</span>, class_names=[<span class="string">'malignant'</span>, <span class="string">'benign'</span>],</span><br><span class="line">    feature_names=cancer.feature_names, impurity=<span class="literal">False</span>, filled=<span class="literal">True</span>)</span><br><span class="line">t = graphviz.render(engine=<span class="string">'dot'</span>, format=<span class="string">'svg'</span>, filepath=<span class="string">'tree.dot'</span>)</span><br><span class="line">graphviz.view(t)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-tree-on-breast-cancer.svg"></p><p>树的可视化有助于深入理解算法是如何进行预测的，也是易于向非专家解释的机器学习算法的优秀示例。不过，即使这里树的深度只有4层，也有点太大了。深度更大的树（深度为10并不罕见）更加难以理解。一种观察树的方法可能有用，就是找出大部分数据的实际路径。上图中每个结点的samples给出了该结点中的样本个数，values给出的是每个类别的样本个数。观察根结点右侧的子结点，我们发现它只包含8个良性样本，但有134个恶性样本。树的这一侧的其余分支只是利用一些更精细的区别将这8个良性样本分离出来。</p><p>再来看一下根结点左侧子结点，我们得到25个恶性样本和259个良性样本。几乎所有的良性样本（259个中的245个）最终都进入左侧第二个叶结点中，大部分其他叶结点都只包含很少的样本。</p><h1 id="树的特征重要性">树的特征重要性</h1><p>查看整个树可能非常费劲，除此之外，我们还可以利用一些有用的属性来总结树的工作原理。其中最常用的是<strong>特征重要性</strong>（feature importance），它为每个特征对树的决策的重要性进行排序。对于每个特征来说，它都是一个介于0和1之间的数字，其中0表示”根本没用到“，1表示”完美预测目标值“。特征重要性的求和始终为1:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'Feature importrances:\n&#123;&#125;'</span>.format(tree.feature_importances_))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_feature_importances_cancer</span><span class="params">(model)</span>:</span></span><br><span class="line">    n_features = cancer.data.shape[<span class="number">1</span>]</span><br><span class="line">    plt.barh(range(n_features), model.feature_importances_, align=<span class="string">'center'</span>)</span><br><span class="line">    plt.yticks(np.arange(n_features), cancer.feature_names)</span><br><span class="line">    plt.xlabel(<span class="string">'Feature importance'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'Feature'</span>)</span><br><span class="line"></span><br><span class="line">plot_feature_importances_cancer(tree)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Feature importrances:</span><br><span class="line">[0.         0.         0.         0.         0.         0.</span><br><span class="line"> 0.         0.         0.         0.         0.01019737 0.04839825</span><br><span class="line"> 0.         0.         0.0024156  0.         0.         0.</span><br><span class="line"> 0.         0.         0.72682851 0.0458159  0.         0.</span><br><span class="line"> 0.0141577  0.         0.018188   0.1221132  0.01188548 0.        ]</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/feature-importances-of-tree.png"></p><p>这里我们看到，顶部划分用到的特征（&quot;worst radius&quot;）是最重要的特征。这也证实了我们在分析树时的观察结论，即第一层划分已经将两个类别区分得很好。</p><p>但是，如果某个特征的feature_importances_很小，并不能说明这个特征没有提供任何信息。这只能说明该特征没有被树选中，可能是因为另一个特征也包含了同样的信息。</p><p>与线性模型的系数不同，特征的重要性始终为正数，也不能说明该特征对应哪个类别。特征重要性告诉我们&quot;worst radius&quot;（最大半径）特征很重要，但并没有告诉我们半径大表示样本是良性还是恶性。事实上，在特例和类别之间可能没有这样的简单关系，你可以在下面的例子中看出这一点。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tree = mglearn.plots.plot_tree_not_monotone()  <span class="comment"># 会生成mytree.dot文件</span></span><br></pre></td></tr></table></figure><p><code>$ dot -Tpng mytree.dot -o tree-not-monotone.png</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Feature importances: [0. 1.]</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/datasets-not-monotone.png"></p><p><img src="/uploads/image/introduction-to-ml-with-python/tree-not-monotone.png"></p><p>该图显示的是有两个特征和两个类别的数据集。这里所有信息都包含在x[1]中，没有用到x[0]。但x[1]和输出类别之间并不是单调关系，即我们不能这么说：“较大的x[1]对应类别0，较小的x[1]对应类别1“（反之亦然）。</p><h1 id="用于回归的决策树">用于回归的决策树</h1><p>虽然我们主要讨论的是用于分类的决策树，但对用于回归的决策树来说，所有内容都是类似的，在DecisionTreeRegressor中实现。回归树的用法和分析与分类树非常类似。但在将基于树的模型用于回归时，我们想要指出它的一个特殊性质。DecisionTreeRegressor（以及其他所有基于树的回归模型）不能<strong>外推</strong>（extrapolate），也不能在训练数据范围之外进行预测。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.tree.decisiontreeregressor" target="_blank" rel="noopener"><code>class sklearn.tree.DecisionTreeRegressor(criterion=’mse’, splitter=’best’, max_depth=None, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_features=None, random_state=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, presort=False)</code></a></p></blockquote><p>我们利用计算机内存（RAM）历史价格的数据集来更详细地研究这一点。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">ram_prices = pd.read_csv(os.path.join(mglearn.datasets.DATA_PATH, <span class="string">"ram_price.csv"</span>))</span><br><span class="line"></span><br><span class="line">plt.semilogy(ram_prices.date, ram_prices.price)</span><br><span class="line">plt.xlabel(<span class="string">"Year"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Price in $/Mbyte"</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/ram-price.png"></p><p>注意y轴的对数刻度。在用对数坐标轴绘图时，二者的线性关系看起来非常好，所以预测应该相对比较容易，除了一些不平滑之处之外。</p><p>我们将利用2000年前的历史数据来预测2000年后的价格，只用日期作为特征。我们将对比两个简单的模型：DecisionTreeRegressor和LinearRegression。我们对价格取对数，使得二者关系的线性相对更好。这对DecisionTreeRegressor不会产生什么影响，但对LinearRegression的影响却很大。训练模型并作出预测之后，我们应用指数映射来做对数变换的你运算。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor</span><br><span class="line"><span class="comment"># 利用历史数据预测2000年后的价格</span></span><br><span class="line">data_train = ram_prices[ram_prices.date &lt; <span class="number">2000</span>]</span><br><span class="line">data_test = ram_prices[ram_prices.date &gt;= <span class="number">2000</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于日期来预测价格</span></span><br><span class="line">X_train = data_train.date[:, np.newaxis]</span><br><span class="line"><span class="comment"># we use a log-transform to get a simpler relationship of data to target</span></span><br><span class="line">y_train = np.log(data_train.price)</span><br><span class="line"></span><br><span class="line">tree = DecisionTreeRegressor(max_depth=<span class="number">3</span>).fit(X_train, y_train)</span><br><span class="line">linear_reg = LinearRegression().fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对所有数据进行预测</span></span><br><span class="line">X_all = ram_prices.date[:, np.newaxis]</span><br><span class="line"></span><br><span class="line">pred_tree = tree.predict(X_all)</span><br><span class="line">pred_lr = linear_reg.predict(X_all)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数变换逆运算</span></span><br><span class="line">price_tree = np.exp(pred_tree)</span><br><span class="line">price_lr = np.exp(pred_lr)</span><br><span class="line"></span><br><span class="line">plt.semilogy(data_train.date, data_train.price, label=<span class="string">"Training data"</span>)</span><br><span class="line">plt.semilogy(data_test.date, data_test.price, label=<span class="string">"Test data"</span>)</span><br><span class="line">plt.semilogy(ram_prices.date, price_tree, label=<span class="string">"Tree prediction"</span>)</span><br><span class="line">plt.semilogy(ram_prices.date, price_lr, label=<span class="string">"Linear prediction"</span>)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/linear-regression-and-decision-tree-on-ram-price.png"></p><p>两个模型之间的差异非常明显。线性模型用一条直线对数据做近似，这是我们所知道的。这条线对测试数据给出了相当好的预测，不过忽略了训练数据和测试数据中一些更细微的变化。与之相反，树模型完美预测了训练数据。由于我们没有限制树的复杂度，因此它记住了整个数据集。但是一旦输入超出了模型训练数据的范围（新的预期价格比历史最低价格更低），模型就只能持续预测最后一个已知数据点。树不能在训练数据的范围之外生成“新的”响应，所有基于树的模型都有这个缺点。（实际上，利用基于树的模型可以做出非常好的预测，比如试图预测价格会上涨还是下跌）。这个例子的目的并不是要说明对时间序列来说树是一个不好的模型，而是为了说明树在预测方式上的特殊性质。）</p><h1 id="优点缺点和参数">优点、缺点和参数</h1><p>控制决策树模型复杂度的参数是预剪枝参数，它在树完全展开之前停止树的构造。通常来说，选择一种预剪枝策略（设置<code>max_depth</code>、<code>max_leaf_nodes</code>或<code>min_samples_leaf</code>）足以防止过拟合。</p><p>决策树有两个优点：一是得到的模型很容易可视化，非专家也很容易理解（至少对于较小的树而言）；二是算法完全不受数据缩放的影响。由于每个特征被单独处理，而且数据的划分也不依赖于缩放，因此决策树算法不需要特征预处理，比如归一化或标准化。特别是特征的尺度完全不一样时或二元特征和连续特征同时存在时，决策树的效果很好。</p><p>决策树的主要缺点在于：即使做了预剪枝，它也经常会过拟合，泛化性能很差。因此，在大多数应用中，往往使用集成方法来代替单棵决策树。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Machine Learning with Python </tag>
            
            <tag> supervised </tag>
            
            <tag> regression </tag>
            
            <tag> classification </tag>
            
            <tag> decision tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>朴素贝叶斯分类器</title>
      <link href="/notes/introduction-to-ml-with-python/naive-bayes-classifiers/"/>
      <url>/notes/introduction-to-ml-with-python/naive-bayes-classifiers/</url>
      
        <content type="html"><![CDATA[<h1 id="朴素贝叶斯分类器">朴素贝叶斯分类器</h1><p>朴素贝叶斯分类器是与线性模型非常相似的一种分类器，但它的训练速度往往更快。这种高效率所付出的代价是，朴素贝叶斯模型的泛化能力要比线性分类器稍差。</p><p>朴素贝叶斯模型如此搞笑的原因在于，它通过单独查看每个特征来学习参数，并从每个特征中收集简单的类别统计数据。scikit-learn中实现了三种朴素贝叶斯分类器：GaussianNB、BernoulliNB和MultinomialNB。GaussianNB可应用于任意连续数据，而BernoulliNB假定输入数据为二分类数据，MultinomialNB假定输入数据为计数数据（即每个特征代表某个对象的整数计数，比如一个单词在句子里出现的次数）。BernoulliNB和MultinomialNB主要用于文本数据分类。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.naive_bayes.gaussiannb" target="_blank" rel="noopener"><code>class sklearn.naive_bayes.GaussianNB(priors=None, var_smoothing=1e-09)</code></a></p></blockquote><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.naive_bayes.bernoullinb" target="_blank" rel="noopener"><code>class sklearn.naive_bayes.BernoulliNB(alpha=1.0, binarize=0.0, fit_prior=True, class_prior=None)</code></a></p></blockquote><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.naive_bayes.multinomialnb" target="_blank" rel="noopener"><code>class sklearn.naive_bayes.MultinomialNB(alpha=1.0, fit_prior=True, class_prior=None)</code></a></p></blockquote><a id="more"></a><p>BernoulliNB分类器计算每个类别中每个特征不为0的元素个数。用一个例子来说明会很容易理解：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],  <span class="comment"># 第1、3行数据的类别为0</span></span><br><span class="line">              [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>],    <span class="comment"># 类别为0的数据，第1个特征的值为1的个数为0，第2个...</span></span><br><span class="line">              [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],  <span class="comment"># 第2、4行数据的类别为1</span></span><br><span class="line">              [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">y = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">counts = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> label <span class="keyword">in</span> np.unique(y):  <span class="comment"># 对每个类进行遍历</span></span><br><span class="line">    <span class="comment"># 计算每个特征中1的个数</span></span><br><span class="line">    counts[label] = X[y == label].sum(axis=<span class="number">0</span>)</span><br><span class="line">print(<span class="string">'Feature counts:\n&#123;&#125;'</span>.format(counts))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Feature counts:</span><br><span class="line">&#123;0: array([0, 1, 0, 2]), 1: array([2, 0, 2, 1])&#125;</span><br></pre></td></tr></table></figure><p>另外两种朴素贝叶斯分类器计算的统计数据类型略有不同。MultinomialNB计算每个类别中每个特征的平均值，而GaussianNB会保存每个类别中每个特征的平均值和标准差。</p><p><strong>要想做出预测，需要将数据点与每个类别的统计数据进行比较，并将最匹配的类别作为预测结果。有趣的是，MultinomialNB和BernoulliNB预测公式的形式都与线性模型完全相同。</strong>不幸的是，朴素贝叶斯模型<code>coef_</code>的含义与线性模型稍有不同，因为<code>coef_</code>不同于<span class="math inline">\(w\)</span>。</p><h1 id="优点缺点和参数">优点、缺点和参数</h1><p>MultinomialNB和BernoulliNB都只有一个参数alpha，用于控制模型复杂度。alpha的工作原理是，算法向数据中添加alpha这么多的虚拟数据点，这些点对所有特征都取正值。这可以将统计数据“平滑化”（smoothing）。<strong>alpha越大，平滑化越强，模型复杂度就越低。算法性能对alpha值的鲁棒性相对较好，也就是说，alpha值对模型性能并不重要。但调整这个参数通常都会使精度略有提高。</strong></p><p>GaussianNB主要用于高维数据，而另外两种朴素贝叶斯模型则广泛用于稀疏计数数据，比如文本。MultinomialNB的性能通常要优于BernoulliNB，特别是在包含很多非零特征的数据集（即大型文档）上。</p><p>朴素贝叶斯模型的许多优点和缺点都与线性模型相同。它的训练和预测速度都很快，训练过程也很容易理解。该模型对高维稀疏数据的效果很好，对参数的鲁棒性也相对较好。朴素贝叶斯模型是很好的基准模型，常用于非常大的数据集，在这些数据集上即使训练线性模型可能也要花费大量时间。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Machine Learning with Python </tag>
            
            <tag> supervised </tag>
            
            <tag> classification </tag>
            
            <tag> naive bayes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性模型</title>
      <link href="/notes/introduction-to-ml-with-python/linear-models/"/>
      <url>/notes/introduction-to-ml-with-python/linear-models/</url>
      
        <content type="html"><![CDATA[<p>线性模型利用输入特征的<strong>线性函数</strong>（linear function）进行预测。</p><h1 id="用于回归的线性模型">用于回归的线性模型</h1><p>对于回归问题，线性模型预测的一般公式如下：</p><p><span class="math display">\[\hat y=w[0]*x[0]+w[1]*x[1]+\dots+w[p]*x[p]+b\]</span></p><p><span class="math inline">\(x[0]\)</span> 到 <span class="math inline">\(x[p]\)</span> 表示单个数据点的特征，<span class="math inline">\(w\)</span> 和 <span class="math inline">\(b\)</span> 是学习模型的参数，<span class="math inline">\(\hat y\)</span> 是模型的预测结果。对于单一特征的数据集，公式如下：</p><p><span class="math display">\[\hat y=w[0]*x[0]+b\]</span></p><p>这就是高中数学里的直线方程。这里 <span class="math inline">\(w[0]\)</span> 是斜率，<span class="math inline">\(b\)</span> 是y轴偏移。对于有更多特征的数据集，<span class="math inline">\(w\)</span> 包含沿每个特征坐标轴的斜率。或者，你也可以将预测的响应值看作输入特征的加权求和，权重（可以取负值）由 <span class="math inline">\(w\)</span> 的元素给出。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_linear_regression_wave()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">w[0]: 0.393906  b: -0.031804</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/linear-regression-on-wave.png"></p><p>用于回归的线性模型可以表示为这样的回归模型：对单一特征的预测结果是一条直线，两个特征时是一个平面，在更高维度时是一个超平面。</p><p>如果将直线的预测结果与KNeighborsRegressor的预测结果进行比较，你会发现直线的预测能力非常受限。似乎数据的所有细节都丢失了。从某种意义上来说，这种说法是正确的假设目标 <span class="math inline">\(y\)</span> 是特征的线性组合，这是一个非常强的（也有点不现实的）假设。<strong>观察一维数据得出的观点有些片面。对于有多个特征的数据集而言，线性模型可以非常强大。特别地，如果特征数量大于训练数据点的数量，任何目标 <span class="math inline">\(y\)</span> 都可以（在训练集上）用线性函数完美拟合（线性代数知识）。</strong></p><p>有许多不同的线性回归模型。这些模型之间的区别在于如何从训练数据中学习参数 <span class="math inline">\(w\)</span> 和 <span class="math inline">\(b\)</span>，以及如何控制模型复杂度。</p><h1 id="线性回归又名普通最小二乘法">线性回归（又名普通最小二乘法）</h1><p>线性回归，或者普通最小二乘法（ordinary least qsquarees, OLS），是回归问题最简单也最经典的线性方法。线性回归寻找参数 <span class="math inline">\(w\)</span> 和 <span class="math inline">\(b\)</span>，使得对训练集的预测值与真实的回归目标值 <span class="math inline">\(y\)</span> 之间的<strong>均方误差</strong>最小。均方误差（mean squared error）是预测值与真实值之差的平方和除以样本数。<strong>线性回归没有参数，这是一个优点，但也因此无法控制模型的复杂度。</strong></p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.linear_model.linearregression" target="_blank" rel="noopener"><code>class sklearn.linear_model.LinearRegression(fit_intercept=True, normalize=False, copy_X=True, n_jobs=None)</code></a></p><p>Ordinary least squares Linear Regression.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line">X, y = mglearn.datasets.make_wave(n_samples=<span class="number">60</span>)</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">lr = LinearRegression().fit(X_train, y_train)</span><br><span class="line"><span class="comment"># scikit-learn总是将从训练数据中得出的值保存在以下划线结尾的属性中，将其与用户设置的参数区分开</span></span><br><span class="line">print(<span class="string">'lr.coef_: &#123;&#125;'</span>.format(lr.coef_))  <span class="comment"># “斜率”w被保存在coef_属性中</span></span><br><span class="line">print(<span class="string">'lr.intercept_: &#123;&#125;'</span>.format(lr.intercept_))  <span class="comment"># “截距”b被保存在intercept_属性中</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'Training set score: &#123;:.2f&#125;'</span>.format(lr.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Test set score: &#123;:.2f&#125;'</span>.format(lr.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lr.coef_: [0.39390555]</span><br><span class="line">lr.intercept_: -0.031804343026759746</span><br><span class="line">Training set score: 0.67</span><br><span class="line">Test set score: 0.66</span><br></pre></td></tr></table></figure><p><span class="math inline">\(R^2\)</span> 约为 0.66，这个结果不是很好，但我们可以看到，训练集和测试集上的分数非常接近。这说明可能存在欠拟合，而不是过拟合（过拟合的特征是在训练集上的分数非常高，而在测试集上的分数非常低）。对于这个一维数据集来说，过拟合的风险很小，因为模型非常简单（或受限）。然而，对于更高维的数据集（即有大量特征的数据集），线性模型将变得更加强大，过拟合的可能性也会变大。</p><p>我们来看一下 LinearRegression 在更复杂的数据集上的表现，比如波士顿房价数据集。这个数据集有 506 个样本和 105 个导出特征。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X, y = mglearn.datasets.load_extended_boston()</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=<span class="number">0</span>)</span><br><span class="line">lr = LinearRegression().fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Train set score: &#123;:.2f&#125;'</span>.format(lr.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Test set score: &#123;:.2f&#125;'</span>.format(lr.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Train set score: 0.95</span><br><span class="line">Test set score: 0.61</span><br></pre></td></tr></table></figure><p>训练集和测试集之间的性能差异是过拟合的明显标志，因此我们应该试图找到一个可以控制复杂度的模型。标准线性回归最常用的替代方法之一就是<strong>岭回归</strong>（ridge regression）。</p><h1 id="岭回归">岭回归</h1><p>岭回归也是一种用于回归的线性模型，因此它的预测公式与普通最小二乘法相同。<strong>但在岭回归中，对系数 <span class="math inline">\(w\)</span> 的选择不仅要在训练数据上得到好的预测结果，而且还要拟合附加约束。我们还希望系数尽量小。</strong>换句话说，<span class="math inline">\(w\)</span> 的所有元素都应接近于 0。直观上来看，这意味着每个特征对输出的影响应尽可能小（即斜率很小），同时仍给出很好的预测结果。这种约束是所谓<strong>正则化</strong>（regularization）的一个例子。正则化是指对模型做显式约束，以避免过拟合。岭回归用到的这种被称为<strong>L2正则化</strong>。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.linear_model.ridge#sklearn.linear_model.Ridge" target="_blank" rel="noopener"><code>sklearn.linear_model.Ridge class sklearn.linear_model.Ridge(alpha=1.0, fit_intercept=True, normalize=False, copy_X=True, max_iter=None, tol=0.001, solver=’auto’, random_state=None)</code></a></p><p>Linear least squares with l2 regularization.</p><p>Minimizes the objective function:</p><p><span class="math inline">\(||y - Xw||^2_2 + alpha * ||w||^2_2\)</span>（从数学的观点来看，Ridge 惩罚了系数的 L2 范数或 <span class="math inline">\(w\)</span> 的欧式长度 <span class="math inline">\(||w||^2_2\)</span>）</p><p>This model solves a regression model where the loss function is the linear least squares function and regularization is given by the l2-norm.</p></blockquote><p>岭回归在 linear_model.Ridge 中实现。来看一下它对扩展的波士顿房价数据集的效果如何：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Ridge</span><br><span class="line"></span><br><span class="line">ridge = Ridge().fit(X_train, y_train)</span><br><span class="line">print(<span class="string">'Train set score: &#123;:.2f&#125;'</span>.format(ridge.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Test set score: &#123;:.2f&#125;'</span>.format(ridge.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Train set score: 0.89</span><br><span class="line">Test set score: 0.75</span><br></pre></td></tr></table></figure><p>Ridge 在训练集上的分数要低于 LinearRegression，但在测试集上的分数更高。这和我们的预期一致。线性回归对数据存在过拟合。Ridge 是一种约束更强的模型，所以更不容易过拟合。复杂度更小的模型意味着在训练集上的性能更差，但泛化性能更好。由于我们只对泛化性能感兴趣，所以应该选择 Ridge 模型而不是 LinearRegression 模型。</p><p>Ridge 模型在模型的简单性（系数都接近于 0）与训练集性能之间做出权衡。简单性和训练集性能二者对于模型的重要程度可以由用户通过设置 alpha 参数来指定。alpha 的最佳设定值取决于用到的具体数据集。增大 alpha 会使得系数更加趋向于 0，从而降低训练集性能，但可能会提高泛化性能。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ridge10 = Ridge(alpha=<span class="number">10</span>).fit(X_train, y_train)</span><br><span class="line">print(<span class="string">'Train set score: &#123;:.2f&#125;'</span>.format(ridge10.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Test set score: &#123;:.2f&#125;'</span>.format(ridge10.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Train set score: 0.79</span><br><span class="line">Test set score: 0.64</span><br></pre></td></tr></table></figure><p>减小 alpha 可以让系数受到的限制更小。对于非常小的 alpha 值，系数几乎没有受到限制，我们得到一个与 LinearRegression 类似的模型：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ridge01 = Ridge(alpha=<span class="number">0.1</span>).fit(X_train, y_train)</span><br><span class="line">print(<span class="string">'Train set score: &#123;:.2f&#125;'</span>.format(ridge01.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Test set score: &#123;:.2f&#125;'</span>.format(ridge01.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Train set score: 0.93</span><br><span class="line">Test set score: 0.77</span><br></pre></td></tr></table></figure><p>这里 alpha=0.1 似乎效果不错。我们可以尝试进一步减小 alpha 以提高泛化性能。</p><p>我们还可以查看 alpha 取不同值时模型的 <code>coef_</code> 属性，从而更加定性地理解 alpha 参数是如何改变模型的。更大的 alpha 表示约束更强的模型，所以大的 alpha 对应的 <code>coef_</code> 元素比小的 alpha 对应的 <code>coef_</code> 元素要小。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(ridge.coef_, <span class="string">'s'</span>, label=<span class="string">'Ridge alpha=1'</span>)</span><br><span class="line">plt.plot(ridge10.coef_, <span class="string">'^'</span>, label=<span class="string">'Ridge alpha=10'</span>)</span><br><span class="line">plt.plot(ridge01.coef_, <span class="string">'v'</span>, label=<span class="string">'Ridge alpha=0.1'</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(lr.coef_, <span class="string">'o'</span>, label=<span class="string">'LinearRegression'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Coefficient index'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Coefficient magnitude'</span>)</span><br><span class="line">plt.hlines(<span class="number">0</span>, <span class="number">0</span>, len(lr.coef_))</span><br><span class="line">plt.ylim(<span class="number">-25</span>, <span class="number">25</span>)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/coef_-of-ridge-and-linear-regression.png"></p><p>x 轴对应 <code>coef_</code> 的元素，y 轴对应元素的具体数值。对于 alpha=10，系数大多在 -3 和 3 之间。对于 alpha=1 的 Ridge 模型，系数要稍大一点。对于 alpha=0.1，点的范围更大。对于没有做正则化的线性回归（即 alpha=0），点的范围很大，许多点都超出了图像的范围。</p><p>还有一种方法可以用来理解正则化的影响，就是固定 alpha 值，但改变训练数据的量。我们对波士顿房价数据集做二次抽样，并在数据量逐渐增加的子数据集上分别对 LinearRegression 和 Ridge(alpha=1) 两个模型进行评估（将模型性能作为数据大小的函数进行绘图，这样的图像叫做<strong>学习曲线</strong>）。</p><p><img src="/uploads/image/introduction-to-ml-with-python/learning-curve-of-ridge-and-linear-regression.png"></p><p>无论是岭回归还是线性回归，所有数据集大小对应的训练分数都要高于测试分数。由于岭回归是正则化的，因此它的训练分数要整体低于线性回归的训练分数。但岭回归的测试分数要更高，特别是对较小的子数据集。如果少于 400 个数据点，线性回归学不到任何内容。随着模型可用数据越来越多，两个模型的性能都在提升，最终线性回归的性能追上了岭回归。这里要记住的是，<strong>如果有足够多的训练数据，正则化变得不那么重要，并且岭回归和线性回归将具有相同的性能</strong>（在这个例子中，二者相同恰好发生在整个数据集的情况下，这只是一个巧合）。还有一个有趣之处，就是线性回归的训练性能在下降。如果添加更多数据，模型将更加难以过拟合或记住所有的数据。</p><h1 id="lasso">lasso</h1><p>除了 Ridge，还有一种正则化的线性回归是 Lasso。与岭回归相同，使用 lasso 也是约束系数使其接近于 0，但用到的方法不同，叫做 L1 正则化。L1 正则化的结果是，使用 lasso 时某些系数<strong>刚好为 0</strong>。这说明某些特征被模型完全忽略。这可以看作是一种自动化的特征选择。某些系数刚好为 0，这样的模型更容易解释，也可以呈现模型最重要的特征。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.linear_model.lasso" target="_blank" rel="noopener"><code>class sklearn.linear_model.Lasso(alpha=1.0, fit_intercept=True, normalize=False, precompute=False, copy_X=True, max_iter=1000, tol=0.0001, warm_start=False, positive=False, random_state=None, selection=’cyclic’)</code></a></p><p>Linear Model trained with L1 prior as regularizer (aka the Lasso)</p><p>The optimization objective for Lasso is:</p><p><span class="math inline">\((1 / (2 * n\_samples)) * ||y - Xw||^2_2 + alpha * ||w||_1\)</span>（lasso 惩罚系数向量的 L1 范数或系数的绝对值之和 <span class="math inline">\(||w||_1\)</span>）</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Lasso</span><br><span class="line"></span><br><span class="line">lasso = Lasso().fit(X_train, y_train)</span><br><span class="line">print(<span class="string">'Training set score: &#123;:.2f&#125;'</span>.format(lasso.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Test set score: &#123;:.2f&#125;'</span>.format(lasso.score(X_test, y_test)))</span><br><span class="line">print(<span class="string">'Number of features used: &#123;&#125;'</span>.format(np.sum(lasso.coef_ != <span class="number">0</span>)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Training set score: 0.29</span><br><span class="line">Test set score: 0.21</span><br><span class="line">Number of features used: 4</span><br></pre></td></tr></table></figure><p>Lasso 在训练集与测试集上的表现都很差。这表示存在欠拟合，我们发现模型只用到了 105 个特征中的 4 个。与 Ridge 类似，Lasso 也有一个正则化参数 alpha，可以控制系数趋向于0的强度。<strong>为了降低欠拟合，我们尝试减小 alpha。这么做的同时，我们还需要增加 <code>max_iter</code> 的值（运行迭代的最大次数）</strong>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lasso001 = Lasso(alpha=<span class="number">0.01</span>, max_iter=<span class="number">100000</span>).fit(X_train, y_train)</span><br><span class="line">print(<span class="string">'Training set score: &#123;:.2f&#125;'</span>.format(lasso001.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Test set score: &#123;:.2f&#125;'</span>.format(lasso001.score(X_test, y_test)))</span><br><span class="line">print(<span class="string">'Number of features used: &#123;&#125;'</span>.format(np.sum(lasso001.coef_ != <span class="number">0</span>)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Training set score: 0.90</span><br><span class="line">Test set score: 0.77</span><br><span class="line">Number of features used: 33</span><br></pre></td></tr></table></figure><p>alpha 的值变小，我们可以拟合一个更复杂的模型，在训练集和测试集上的表现也更好。模型性能比使用 Ridge 时略好一点，而且我们只用到了 105 个特征中的 33 个。这样模型可能更容易理解。</p><p>但如果把 alpha 设得太小，那么就会消除正则化的效果，并出现过拟合，得到与 LinearRegression 类似的结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lasso00001 = Lasso(alpha=<span class="number">0.0001</span>, max_iter=<span class="number">100000</span>).fit(X_train, y_train)</span><br><span class="line">print(<span class="string">'Training set score: &#123;:.2f&#125;'</span>.format(lasso00001.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Test set score: &#123;:.2f&#125;'</span>.format(lasso00001.score(X_test, y_test)))</span><br><span class="line">print(<span class="string">'Number of features used: &#123;&#125;'</span>.format(np.sum(lasso00001.coef_ != <span class="number">0</span>)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Training set score: 0.95</span><br><span class="line">Test set score: 0.64</span><br><span class="line">Number of features used: 96</span><br></pre></td></tr></table></figure><p>再次对不同模型的系数进行作图。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(lasso.coef_, <span class="string">'s'</span>, label=<span class="string">'Lasso alpha=1'</span>)</span><br><span class="line">plt.plot(lasso001.coef_, <span class="string">'^'</span>, label=<span class="string">'Lasso alpha=0.01'</span>)</span><br><span class="line">plt.plot(lasso00001.coef_, <span class="string">'v'</span>, label=<span class="string">'Lasso alpha=0.0001'</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(ridge01.coef_, <span class="string">'o'</span>, label=<span class="string">'Ridge alpha=0.1'</span>)</span><br><span class="line">plt.legend(ncol=<span class="number">2</span>, loc=(<span class="number">0</span>, <span class="number">1.05</span>))</span><br><span class="line">plt.ylim(<span class="number">-25</span>, <span class="number">25</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Coefficient index'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Coefficient magnitude'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/learning-curve-of-lasso-and-ridge.png"></p><p>在 alpha=1 时，我们发现不仅大部分系数都是 0，而且其他系数也很小。将 alpha 减小至 0.01，大部分特征等于 0。alpha=0.0001 时，我们得到正则化很弱的模型，大部分系数都不为 0，并且还很大。图中用圆形表示 Ridge 的最佳结果。alpha=0.1 的 Ridge 模型的预测性能与 alpha=0.01 的 Lasso 模型类似，但 Ridge 模型的所有系数都不为 0。</p><p>在实践中，在两个模型中一般首选岭回归。但如果特征很多，你认为只有其中几个是重要的，那么选择 Lasso 可能更好。同样，如果你想要一个容易解释的模型，Lasso 可以给出更容易理解的模型，因为他只选择了一部分输入特征。scikit-learn 还提供了 ElasticNet 类，结合了 Lasso 和 Ridge 的惩罚项。在实践中，这种结合的效果最好，不过代价是要调节两个参数：一个用于 L1 正则化，一个用于 L2 正则化。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.linear_model.elasticnet" target="_blank" rel="noopener"><code>class sklearn.linear_model.ElasticNet(alpha=1.0, l1_ratio=0.5, fit_intercept=True, normalize=False, precompute=False, max_iter=1000, copy_X=True, tol=0.0001, warm_start=False, positive=False, random_state=None, selection=’cyclic’)</code></a></p><p>Linear regression with combined L1 and L2 priors as regularizer.</p><p>Minimizes the objective function:</p><p><span class="math display">\[1 / (2 * n\_samples) * ||y - Xw||^2_2+ alpha * l1\_ratio * ||w||_1+ 0.5 * alpha * (1 - l1\_ratio) * ||w||^2_2\]</span></p><p>If you are interested in controlling the L1 and L2 penalty separately, keep in mind that this is equivalent to:</p><p><code>a * L1 + b * L2</code></p><p>where:</p><p><code>alpha = a + b and l1_ratio = a / (a + b)</code></p></blockquote><h1 id="用于分类的线性模型">用于分类的线性模型</h1><p>线性模型也广泛应用于分类问题。我们首先来看二分类。这时可以利用下面的公式进行预测：</p><p><span class="math display">\[\hat y=w[0]*x[0]+w[1]*x[1]+\dots+w[p]*x[p]+b&gt;0\]</span></p><p>这个公式看起来与线性回归的公式非常类似，但我们没有返回特征的加权求和，而是为预测设置了阈值 0。如果函数值小于 0，我们就预测类别 -1；如果函数值大于 0，我们就预测类别 +1.对于所有用于分类的线性模型，这个预测规则都是通用的。同样，有很多种不同的方法来找出系数 <span class="math inline">\(w\)</span> 和截距 <span class="math inline">\(b\)</span>。</p><p>对于用于回归的线性模型，输出 <span class="math inline">\(\hat y\)</span> 是特征的线性函数，是直线、平面或超平面。对于用于分类的线性模型，<strong>决策边界</strong>是输入的线性函数。换句话说，（二元）线性分类器是利用直线、平面或超平面来分开两个类别的分类器。</p><p>学习线性模型有很多种算法。这些算法的区别在于以下两点：</p><ul><li>系数和截距的特定组合对训练数据拟合好坏的度量方法；</li><li>是否使用正则化，以及使用哪种正则化方法。</li></ul><p>不同的算法使用不同的方法来度量“对训练集拟合好坏”。由于数学上的技术原因，不可能调节 <span class="math inline">\(w\)</span> 和 <span class="math inline">\(b\)</span> 是的算法产生的误分类数量最少。对于我们的目的，以及对于许多应用而言，上面第一点（成为<strong>损失函数</strong>）的选择并不重要。</p><p>最常见的两种线性分类算法是 Logistic 回归（logistic regression，虽然名字中含有回归，但它是一种分类算法）和线性支持向量机（linear support vector machine，线性 SVM），前者在 <code>linear_model.LogisticRegression</code> 中实现，后者在 <code>svm.LinearSVC</code>（SVC代表支持向量分类器）中实现。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.linear_model.logisticregression" target="_blank" rel="noopener"><code>class sklearn.linear_model.LogisticRegression(penalty=’l2’, dual=False, tol=0.0001, C=1.0, fit_intercept=True, intercept_scaling=1, class_weight=None, random_state=None, solver=’warn’, max_iter=100, multi_class=’warn’, verbose=0, warm_start=False, n_jobs=None)</code></a></p></blockquote><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.svm.linearsvc" target="_blank" rel="noopener"><code>class sklearn.svm.LinearSVC(penalty=’l2’, loss=’squared_hinge’, dual=True, tol=0.0001, C=1.0, multi_class=’ovr’, fit_intercept=True, intercept_scaling=1, class_weight=None, verbose=0, random_state=None, max_iter=1000)</code></a></p></blockquote><p>我们可以将 LogisticRegression 和 LinearSVC 模型应用到 forge 数据集上，并将线性模型找到的决策边界可视化。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> LinearSVC</span><br><span class="line"></span><br><span class="line">X, y = mglearn.datasets.make_forge()</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">3</span>))</span><br><span class="line"><span class="keyword">for</span> model, ax <span class="keyword">in</span> zip([LinearSVC(), LogisticRegression()], axes):</span><br><span class="line">    clf = model.fit(X, y)</span><br><span class="line">    mglearn.plots.plot_2d_separator(clf, X, fill=<span class="literal">False</span>, eps=<span class="number">0.5</span>, ax=ax, alpha=<span class="number">.7</span>)</span><br><span class="line">    mglearn.discrete_scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], y, ax=ax)</span><br><span class="line">    ax.set_title(<span class="string">'&#123;&#125;'</span>.format(clf.__class__.__name__))</span><br><span class="line">    ax.set_xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">'Feature 1'</span>)</span><br><span class="line">axes[<span class="number">0</span>].legend()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-of-logistic-regression-and-linear-svc.png"></p><p>两个模型得到了相似的决策边界。注意，两个模型中都有两个点的分类是错误的。两个模型都默认使用 L2 正则化，就像 Ridge 对回归所做的那样。</p><p>对于 LogisticRegression 和 LinearSVC，决定正则化强度的权衡参数叫作 C。C 值越大，对应的正则化越弱。换句话说，如果 C 值较大，那么 LogisticRegression 和 LinearSVC 将尽可能将训练集拟合到最好，而如果 C 值较小，那么模型更强调使系数向量 <span class="math inline">\(w\)</span> 接近于0。</p><p>参数 C 的作用还有另一个有趣之处。较小的C值可以让算法尽量适应“大多数”数据点，而较大的 C 值更强调每个数据点都分类正确的重要性。下面是使用 LinearSVC 的图示：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_linear_svc_regularization()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-of-linear-svc.png"></p><p>在左侧的图中，C 值很小，对应强正则化。大部分属于 0 的点都位于底部，大部分属于类别 1 的点都位于顶部。强正则化的模型会选择一条相对水平的线，有两个点分类错误。在中间的图中，C 值稍大，模型更关注两个分类错误的样本，是决策边界的斜率变大。最后，在右侧的图中，模型的 C 值非常大，使得决策边界的斜率也很大，现在这个模型对类别 0 中的所有点的分类都是正确的。类别 1 中仍有 1 个点分类错误，这是因为对这个数据集来说，不可能用一条直线将所有点都分类正确。右侧图中的模型尽量使所有点的分类都正确，但可能无法掌握类别的整体分布。换句话说，这个模型很可能过拟合。</p><p>与回归的情况类似，用于分类的线性模型在低维空间中看起来非常受限，决策边界只能是直线或平面。同样，在高维空间中，用于分类的线性模型变得非常强大，当考虑更多的特征时，避免过拟合变得越来越重要。</p><p>我们在乳腺癌数据集上详细分析 LogisticRegression：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_breast_cancer</span><br><span class="line"></span><br><span class="line">cancer = load_breast_cancer()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(cancer.data,</span><br><span class="line">    cancer.target, stratify=cancer.target, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">logreg = LogisticRegression().fit(X_train, y_train)</span><br><span class="line">print(<span class="string">'Training set score: &#123;:.3f&#125;'</span>.format(logreg.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Test set score: &#123;:.3f&#125;'</span>.format(logreg.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Training set score: 0.955</span><br><span class="line">Test set score: 0.958</span><br></pre></td></tr></table></figure><p>C=1 的默认值给出了相当好的性能，在训练集和测试集上都达到 95% 的精度。<strong>但由于训练集和测试集的性能非常接近，所以模型很可能是欠拟合的。</strong>我们尝试增大 C 来拟合一个更灵活的模型：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logreg100 = LogisticRegression(C=<span class="number">100</span>).fit(X_train, y_train)</span><br><span class="line">print(<span class="string">'Training set score: &#123;:.3f&#125;'</span>.format(logreg100.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Test set score: &#123;:.3f&#125;'</span>.format(logreg100.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Training set score: 0.967</span><br><span class="line">Test set score: 0.965</span><br></pre></td></tr></table></figure><p>使用 C=100 可以得到更高的训练集精度，也得到了稍高的测试集精度，这也证实了我们的直觉，即更复杂的模型应该性能更好。</p><p>我们还可以研究使用正则化强度更强的模型时会发生什么。设置 C=0.01。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logreg001 = LogisticRegression(C=<span class="number">0.01</span>).fit(X_train, y_train)</span><br><span class="line">print(<span class="string">'Training set score: &#123;:.3f&#125;'</span>.format(logreg001.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Test set score: &#123;:.3f&#125;'</span>.format(logreg001.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Training set score: 0.934</span><br><span class="line">Test set score: 0.930</span><br></pre></td></tr></table></figure><p>正如我们所料，在将已经欠拟合的模型（C=1）继续向左移动，训练集和测试集的精度都比采用默认参数时更小。</p><p>最后，来看一下正则化参数 C 取三个不同的值时模型学到的系数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(logreg.coef_.T, <span class="string">'o'</span>, label=<span class="string">'C=1'</span>)</span><br><span class="line">plt.plot(logreg100.coef_.T, <span class="string">'^'</span>, label=<span class="string">'C=100'</span>)</span><br><span class="line">plt.plot(logreg001.coef_.T, <span class="string">'v'</span>, label=<span class="string">'C=0.01'</span>)</span><br><span class="line">plt.xticks(range(cancer.data.shape[<span class="number">1</span>]), cancer.feature_names, rotation=<span class="number">90</span>)</span><br><span class="line">plt.hlines(<span class="number">0</span>, <span class="number">0</span>, cancer.data.shape[<span class="number">1</span>])</span><br><span class="line">plt.ylim(<span class="number">-5</span>, <span class="number">5</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Coefficient index'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Coefficient magnitude'</span>)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/learning-curve-of-logistic-regression-l2.png"></p><p>由于 LogisticRegression 默认应用 L2 正则化，所以其结果与 Ridge 的结果类似。更强的正则化使得系数更趋向于 0，但系数永远不会正好等于 0。</p><p>如果想要一个可解释性更强的模型，使用 L1 正则化可能更好，因为它约束模型只是用少数几个特征。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> C, marker <span class="keyword">in</span> zip([<span class="number">0.001</span>, <span class="number">1</span>, <span class="number">100</span>], [<span class="string">'o'</span>, <span class="string">'^'</span>, <span class="string">'v'</span>]):</span><br><span class="line">    lr_l1 = LogisticRegression(C=C, penalty=<span class="string">'l1'</span>).fit(X_train, y_train)</span><br><span class="line">    print(<span class="string">'Training accuracy of l1 logreg with C=&#123;:.3f&#125;: &#123;:.2f&#125;'</span>.format(</span><br><span class="line">        C, lr_l1.score(X_train, y_train)))</span><br><span class="line">    print(<span class="string">'Test accuracy of l1 logreg with C=&#123;:.3f&#125;: &#123;:.2f&#125;'</span>.format(</span><br><span class="line">        C, lr_l1.score(X_test, y_test)))</span><br><span class="line"></span><br><span class="line">    plt.plot(lr_l1.coef_.T, marker, label=<span class="string">'C=&#123;:.3f&#125;'</span>.format(C))</span><br><span class="line"></span><br><span class="line">plt.xticks(range(cancer.data.shape[<span class="number">1</span>]), cancer.feature_names, rotation=<span class="number">90</span>)</span><br><span class="line">plt.hlines(<span class="number">0</span>, <span class="number">0</span>, cancer.data.shape[<span class="number">1</span>])</span><br><span class="line">plt.xlabel(<span class="string">'Coefficient index'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Coefficient magnitude'</span>)</span><br><span class="line">plt.ylim(<span class="number">-5</span>, <span class="number">5</span>)</span><br><span class="line">plt.legend(loc=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Training accuracy of l1 logreg with C=0.001: 0.91</span><br><span class="line">Test accuracy of l1 logreg with C=0.001: 0.92</span><br><span class="line">Training accuracy of l1 logreg with C=1.000: 0.96</span><br><span class="line">Test accuracy of l1 logreg with C=1.000: 0.96</span><br><span class="line">Training accuracy of l1 logreg with C=100.000: 0.99</span><br><span class="line">Test accuracy of l1 logreg with C=100.000: 0.98</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/learning-curve-of-logistic-regression-l1.png"></p><p>如你所见，使用二分类的线性模型与用于回归的线性模型有许多相似之处。与用于回归的线性模型一样，模型的主要差别在于 penalty 参数，这个参数会影响正则化，也会影响模型是使用所有可用特征还是只选择特征的一个子集。</p><h1 id="用于多分类的线性模型">用于多分类的线性模型</h1><p>许多线性分类模型只适用于二分类问题，不能轻易推广到多类别问题（除了 Logistic 回归）。将二分类算法推广到多分类算法的一种常见方法是”<strong>一对其余</strong>“（one-vs.-rest）方法。在“一对其余”方法中，对每个类别都学习一个二分类模型，将这个类别与所有其他类别尽量分开，这样就生成了与类别个数一样多的二分类模型。在测试点上运行所有二分类器来进行预测。在对应类别上分数最高的分类器“胜出”，将增额类别标签返回作为预测结果。</p><p>每个类别都对应一个二类分类器，这样每个类被也都有一个系数 <span class="math inline">\(w\)</span> 向量和一个截距 <span class="math inline">\(b\)</span>。下面给出的是分类置信方程，其结果中最大值对应的类别即为预测的类别标签：</p><p><span class="math display">\[w[0]*x[0]+w[1]*x[1]+\dots+w[p]*x[p]+b\]</span></p><p>多分类 Logistic 回归背后的数学与“一对其余”方法稍有不同，但它也是对每个类别都有一个系数向量和一个截距，也使用了相同的预测方法。</p><p>我们将“一对其余”方法应用在一个简单的三分类数据集上。我们用到了一个二维数据集，每个列别德数据都是从一个高斯分布中采样得出的。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.datasets.make_blobs#sklearn.datasets.make_blobs" target="_blank" rel="noopener"><code>sklearn.datasets.make_blobs(n_samples=100, n_features=2, centers=None, cluster_std=1.0, center_box=(-10.0, 10.0), shuffle=True, random_state=None)</code></a></p><p>Generate isotropic Gaussian blobs for clustering.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line"></span><br><span class="line">X, y = make_blobs(random_state=<span class="number">42</span>)</span><br><span class="line">mglearn.discrete_scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], y)</span><br><span class="line">plt.xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature 1'</span>)</span><br><span class="line">plt.legend([<span class="string">'Class 0'</span>, <span class="string">'Class 1'</span>, <span class="string">'Class 2'</span>])</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/datasets-blobs.png"></p><p>在这个数据集上训练一个 LinearSVC 分类器：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">linear_svm = LinearSVC().fit(X, y)</span><br><span class="line">print(<span class="string">'Coefficient shape: '</span>, linear_svm.coef_.shape)</span><br><span class="line">print(<span class="string">'Intercept shape: '</span>, linear_svm.intercept_.shape)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Coefficient shape:  (3, 2)  # 每行包括三个类别之一的系数向量，数据有两个特征，因此系数有两个元素</span><br><span class="line">Intercept shape:  (3,)  # 每个类别的截距</span><br></pre></td></tr></table></figure><p>将这 3 个二类分类器给出的直线可视化：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.discrete_scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], y)</span><br><span class="line">line = np.linspace(<span class="number">-15</span>, <span class="number">15</span>)</span><br><span class="line"><span class="keyword">for</span> coef, intercept, color <span class="keyword">in</span> zip(linear_svm.coef_, linear_svm.intercept_,</span><br><span class="line">                                  [<span class="string">'b'</span>, <span class="string">'r'</span>, <span class="string">'g'</span>]):</span><br><span class="line">    <span class="comment"># model: y = coef[0] * x[0] + coef[1] * x[1] + intercept</span></span><br><span class="line">    <span class="comment"># boundary: 0 = coef[0] * x[0] + coef[1] * x[1] + intercept</span></span><br><span class="line">    <span class="comment"># 边界上的x[1] = -(coef[0] * x[0] + intercept) / coef[1]</span></span><br><span class="line">    plt.plot(line, -(line * coef[<span class="number">0</span>] + intercept) / coef[<span class="number">1</span>], c=color)</span><br><span class="line">plt.ylim(<span class="number">-10</span>, <span class="number">15</span>)</span><br><span class="line">plt.xlim(<span class="number">-10</span>, <span class="number">8</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature 1'</span>)</span><br><span class="line">plt.legend([<span class="string">'Class 0'</span>, <span class="string">'Class 1'</span>, <span class="string">'Class 2'</span>, <span class="string">'Line class 0'</span>, <span class="string">'Line class 1'</span>,</span><br><span class="line">            <span class="string">'Line class 2'</span>], loc=(<span class="number">1.01</span>, <span class="number">0.3</span>))</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-one-vs-rest.png"></p><p>图像中间的三角形区域属于哪一个类别呢，3 个二类分类器都将这一区域内的点划为“其余”。这里的点应该划归到哪一个类别呢？答案是分类方程结果最大的那个类别，即最接近的那条线对应的类别。下面的例子给出了二维空间中所有区域的预测结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_2d_classification(linear_svm, X, fill=<span class="literal">True</span>, alpha=<span class="number">.7</span>)</span><br><span class="line"></span><br><span class="line">mglearn.discrete_scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], y)</span><br><span class="line">line = np.linspace(<span class="number">-15</span>, <span class="number">15</span>)</span><br><span class="line"><span class="keyword">for</span> coef, intercept, color <span class="keyword">in</span> zip(linear_svm.coef_, linear_svm.intercept_,</span><br><span class="line">                                  [<span class="string">'b'</span>, <span class="string">'r'</span>, <span class="string">'g'</span>]):</span><br><span class="line">    plt.plot(line, -(line * coef[<span class="number">0</span>] + intercept) / coef[<span class="number">1</span>], c=color)</span><br><span class="line">plt.ylim(<span class="number">-10</span>, <span class="number">15</span>)</span><br><span class="line">plt.xlim(<span class="number">-10</span>, <span class="number">8</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature 1'</span>)</span><br><span class="line">plt.legend([<span class="string">'Class 0'</span>, <span class="string">'Class 1'</span>, <span class="string">'Class 2'</span>, <span class="string">'Line class 0'</span>, <span class="string">'Line class 1'</span>,</span><br><span class="line">            <span class="string">'Line class 2'</span>], loc=(<span class="number">1.01</span>, <span class="number">0.3</span>))</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-one-vs-rest-fill.png"></p><h1 id="优点缺点和参数">优点、缺点和参数</h1><p>线性模型的主要参数是正则化参数，在回归模型中叫作 alpha，在 LinearSVC 和 LogisticRegression 中叫作 C。<strong>alpha 值较大或 C 值较小，说明模型比较简单。特别是对于回归模型而言，调节这些参数非常重要。通常在对数尺度上对 C 和 alpha 进行搜索。你还需要确定的是用 L1 正则化还是 L2 正则化。</strong>如果你假定只有几个特征是真正重要的，那么你应该用 L1 正则化，否则应默认使用 L2 正则化。如果模型的可解释性很重要的话，使用 L1 也会有帮助。由于 L1 只用到几个特征，所以更容易解释哪些特征对模型是重要的，以及这些特征的作用。</p><p>线性模型的训练速度非常快，预测速度也很快。这种模型可以推广到非常大的数据集，对稀疏数据也很有效。如果你的数据包含数十万甚至上百万个样本，你可能需要研究如何使用 LogisticRegression 和 Ridge 模型的 solver='sag' 选项，在处理大型数据时，这一选项比默认值要更快。其他选项还有 SGDClassifier 类和 SGDRegression 类，它们对本节介绍的线性模型实现了可扩展性更强的版本。</p><p>线性模型的另一个优点在于，利用我们之前见过的用于回归和分类的公式，理解如何进行预测是相对比较容易的。不幸的是，往往并不完全清楚系数为什么是这样的。如果你的数据集中包含高度相关的特征，这一问题尤为突出。在这种情况下，可能很难对系数做出解释。</p><p><strong>如果特征数量大于样本数量，线性模型的表现通常都很好。</strong>他也常用于非常大的数据集，只是因为训练其他模型并不可行。但在更低维的空间中，其他模型的泛化性能可能更好。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Machine Learning with Python </tag>
            
            <tag> supervised </tag>
            
            <tag> regression </tag>
            
            <tag> classification </tag>
            
            <tag> ridge </tag>
            
            <tag> lasso </tag>
            
            <tag> linear model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k近邻</title>
      <link href="/notes/introduction-to-ml-with-python/k-nearest-neighbors/"/>
      <url>/notes/introduction-to-ml-with-python/k-nearest-neighbors/</url>
      
        <content type="html"><![CDATA[<p>k-NN算法可以说是最简单的机器学习算法。构建的模型只需要保存训练数据集即可。想要对新数据点做出预测，算法会在训练数据集中找到最近的数据点，也就是它的“最近邻”。</p><h1 id="k近邻分类">k近邻分类</h1><p>k-NN算法最简单的版本只考虑一个最近邻，也就是与我们想要预测的数据点最近的训练数据点。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_knn_classification(n_neighbors=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>单一最近邻模型对forge数据集的预测：</p><p><img src="/uploads/image/introduction-to-ml-with-python/1-nn-classfication-on-forge.png"></p><a id="more"></a><p>除了考虑最近邻，还可以考虑任意个（k个）邻居。这也是k近邻算法名字的来历。在考虑多余一个邻居的情况时，我们用“投票法”（voting）来指定标签。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_knn_classification(n_neighbors=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/3-nn-classfication-on-forge.png"></p><p>现在看一下如何通过scikit-learn来应用k近邻算法。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.neighbors.kneighborsclassifier" target="_blank" rel="noopener"><code>class sklearn.neighbors.KNeighborsClassifier(n_neighbors=5, weights=’uniform’, algorithm=’auto’, leaf_size=30, p=2, metric=’minkowski’, metric_params=None, n_jobs=None, **kwargs)</code></a></p><p>Classifier implementing the k-nearest neighbors vote.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X, y = mglearn.datasets.make_forge()  <span class="comment"># 原始数据集</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=<span class="number">0</span>)  <span class="comment"># 分成训练集和测试集</span></span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line">clf = KNeighborsClassifier(n_neighbors=<span class="number">3</span>)  <span class="comment"># 初始化分类器</span></span><br><span class="line">clf.fit(X_train, y_train)  <span class="comment"># 用训练集对其拟合</span></span><br><span class="line">clf.score(X_test, y_test)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.8571428571428571  # 模型的精度约为86%</span><br></pre></td></tr></table></figure><h1 id="分析kneighborsclassifier">分析KNeighborsClassifier</h1><p>对于二维数据集，我们可以在平面上画出所有可能的测试点的预测结果。根据平面中每个点所属的类别对平面进行着色。这样就可以查看<strong>决策边界</strong>（decision boundary）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, axes = plt.subplots(<span class="number">1</span>, <span class="number">3</span>, figsize=(<span class="number">10</span>, <span class="number">3</span>))</span><br><span class="line"><span class="keyword">for</span> n_neighbors, ax <span class="keyword">in</span> zip([<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>], axes):</span><br><span class="line">    clf = KNeighborsClassifier(n_neighbors=n_neighbors).fit(X, y)</span><br><span class="line">    mglearn.plots.plot_2d_separator(clf, X, fill=<span class="literal">True</span>, eps=<span class="number">0.5</span>, ax=ax, alpha=<span class="number">.4</span>)</span><br><span class="line">    mglearn.discrete_scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], y, ax=ax)</span><br><span class="line">    ax.set_title(<span class="string">'&#123;&#125; neighbor(s)'</span>.format(n_neighbors))</span><br><span class="line">    ax.set_xlabel(<span class="string">'feature 0'</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">'feature 1'</span>)</span><br><span class="line">axes[<span class="number">0</span>].legend(loc=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-of-knn.png"></p><p>从图中可以看出，使用单一邻居绘制的决策边界紧跟着训练数据。随着邻居个数越来越多，决策边界也越来越平滑。更平滑的边界对应更简单的模型。换句话说，使用更少的邻居对应更高的模型复杂度，而使用更多的邻居对应更低的模型复杂度。假如考虑极端情况，即邻居个数等于训练集中所有数据点的个数，那么每个测试点的邻居都完全相同（即所有训练点），所有预测结果也完全相同（即训练集中出现次数最多的类别）。</p><p>在现实世界的乳腺癌数据集上研究模型复杂度和泛化能力之间的关系。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_breast_cancer</span><br><span class="line"></span><br><span class="line">cancer = load_breast_cancer()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">    cancer.data, cancer.target, stratify=cancer.target, random_state=<span class="number">66</span>)</span><br><span class="line"></span><br><span class="line">training_accuracy, test_accuracy = [], []</span><br><span class="line">neighbors_settings = range(<span class="number">1</span>, <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n_neighbors <span class="keyword">in</span> neighbors_settings:</span><br><span class="line">    clf = KNeighborsClassifier(n_neighbors=n_neighbors)</span><br><span class="line">    clf.fit(X_train, y_train)</span><br><span class="line">    training_accuracy.append(clf.score(X_train, y_train))</span><br><span class="line">    test_accuracy.append(clf.score(X_test, y_test))</span><br><span class="line"></span><br><span class="line">plt.plot(neighbors_settings, training_accuracy, label=<span class="string">'training accuracy'</span>)</span><br><span class="line">plt.plot(neighbors_settings, test_accuracy, label=<span class="string">'test accuracy'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Accuracy'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'n_neighbors'</span>)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/k-neighbors-classification-on-breast-cancer.png"></p><p>单一邻居的模型过于复杂。与之相反，当考虑10个邻居时，模型又过于简单，性能甚至变差。最佳性能在中间的某处，邻居个数大约为6。</p><h1 id="k近邻回归">k近邻回归</h1><p>k近邻算法还可以用于回归。还是从单一近邻开始，这次使用wave数据集。利用单一邻居的预测结果就是最近邻的目标值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_knn_regression(n_neighbors=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/1-nn-regression-on-wave.png"></p><p>同样，也可以用多个近邻进行回归，预测结果为这些近邻的平均值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_knn_regression(n_neighbors=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/3-nn-regression-on-wave.png"></p><p>用于回归的k近邻算法在scikit-learn的KNeighborsRegressor类中实现。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.neighbors.kneighborsregressor" target="_blank" rel="noopener"><code>class sklearn.neighbors.KNeighborsRegressor(n_neighbors=5, weights=’uniform’, algorithm=’auto’, leaf_size=30, p=2, metric=’minkowski’, metric_params=None, n_jobs=None, **kwargs)</code></a></p><p>Regression based on k-nearest neighbors.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsRegressor</span><br><span class="line"></span><br><span class="line">X, y = mglearn.datasets.make_wave(n_samples=<span class="number">40</span>)</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">reg = KNeighborsRegressor(n_neighbors=<span class="number">3</span>)</span><br><span class="line">reg.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Test set predictions:\n&#123;&#125;'</span>.format(reg.predict(X_test)))</span><br><span class="line">print(<span class="string">'Test set R^2: &#123;:.2f&#125;'</span>.format(reg.score(X_test, y_test)))  <span class="comment"># 决定系数</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test set predictions:</span><br><span class="line">[-0.05396539  0.35686046  1.13671923 -1.89415682 -1.13881398 -1.63113382</span><br><span class="line">  0.35686046  0.91241374 -0.44680446 -1.13881398]</span><br><span class="line">Test set R^2: 0.83</span><br></pre></td></tr></table></figure><p>我们可以用score方法来评估模型，对于回归问题，这一方法返回的是<span class="math inline">\(R^2\)</span>分数。<span class="math inline">\(R^2\)</span>分数也叫作决定系数，是回归模型预测的优度度量，位于0到1之间。<span class="math inline">\(R^2\)</span>等于1对应完美预测，<span class="math inline">\(R^2\)</span>等于0对应常数模型，即总是预测训练集响应（y_train)的平均值。</p><h1 id="分析kneighborsregression">分析KNeighborsRegression</h1><p>对于wave一维数据集，可以查看所有特征取值对应的预测结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, axes = plt.subplots(<span class="number">1</span>, <span class="number">3</span>, figsize=(<span class="number">15</span>, <span class="number">4</span>))</span><br><span class="line"><span class="comment"># 创建1000个数据点，在-3和3之间均匀分布</span></span><br><span class="line">line = np.linspace(<span class="number">-3</span>, <span class="number">3</span>, <span class="number">1000</span>).reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> n_neighbors, ax <span class="keyword">in</span> zip([<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>], axes):</span><br><span class="line">    reg = KNeighborsRegressor(n_neighbors=n_neighbors)</span><br><span class="line">    reg.fit(X_train, y_train)</span><br><span class="line">    ax.plot(line, reg.predict(line))</span><br><span class="line">    ax.plot(X_train, y_train, <span class="string">'^'</span>, c=mglearn.cm2(<span class="number">0</span>), markersize=<span class="number">8</span>)</span><br><span class="line">    ax.plot(X_test, y_test, <span class="string">'v'</span>, c=mglearn.cm2(<span class="number">1</span>), markersize=<span class="number">8</span>)</span><br><span class="line">    ax.set_title(<span class="string">'&#123;&#125; neighbor(s)\n train score: &#123;:.2f&#125; test score: &#123;:.2f&#125;'</span>.format(</span><br><span class="line">        n_neighbors, reg.score(X_train, y_train), reg.score(X_test, y_test)))</span><br><span class="line">    ax.set_xlabel(<span class="string">'Feature'</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">'Target'</span>)</span><br><span class="line">axes[<span class="number">0</span>].legend([<span class="string">'Model predictions'</span>, <span class="string">'Training data/target'</span>, <span class="string">'Test data/target'</span>],</span><br><span class="line">    loc=<span class="string">'best'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/k-neighbors-regression-on-wave.png"></p><p>从图中可以看出，仅使用单一邻居，训练集中的每个点都对预测结果有显著影响，预测结果的图像经过所有数据点。这导致预测结果非常不稳定。考虑更多的邻居之后，预测结果变得更加平滑，但对训练数据的拟合也不好。</p><h1 id="优点缺点和参数">优点、缺点和参数</h1><p>一般来说，KNeighbors分类器有2个重要参数：邻居个数与数据点之间距离的度量方法。在实践中，使用较小的邻居个数（比如3个或5个）往往可以得到比较好的结果，但你应该调节这个参数。距离使用欧式距离，它在许多情况下的效果都很好。</p><p>k-NN的优点之一就是模型很容易理解，通常不需要过多调节就可以得到不错的性能。在考虑使用更高级的技术之前，尝试此算法是一种很好的基准方法。构建最近邻模型的速度通常很快，但如果训练集很大（特征数很多或者样本数很大），预测速度可能会比较慢。<strong>使用k-NN算法时，对数据进行预处理是很重要的。</strong>这一算法对于有很多特征的数据集往往效果不好，对于大多数特征的大多数取值都为0的数据集（所谓的<strong>稀疏数据集</strong>）来说，这一算法的效果尤为不好。</p><p>虽然k近邻算法很容易理解，但由于预测速度慢且不能处理具有很多特征的数据集，所以在实践中往往不会用到。线性模型就没有这两个缺点。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Machine Learning with Python </tag>
            
            <tag> supervised </tag>
            
            <tag> regression </tag>
            
            <tag> classification </tag>
            
            <tag> knn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>监督学习</title>
      <link href="/notes/introduction-to-ml-with-python/supervised-learning/"/>
      <url>/notes/introduction-to-ml-with-python/supervised-learning/</url>
      
        <content type="html"><![CDATA[<p>每当想要根据给定输入预测某个结果，并且还有输入/输出对的示例时，都应该使用监督学习。这些输入/输出对构成了训练集，我们利用它来构建机器学习模型。我们的目标是对从未见过的新数据做出准确预测。监督学习通常需要人力来构建训练集，但之后的任务本来非常费力甚至无法完成，现在却可以自动完成，通常速度也很快。</p><h1 id="分类和回归">分类和回归</h1><p>监督机器学习问题主要有两种，分别叫做分类（classification）与回归（regression）。</p><p>分类问题的目标是预测类别标签（class label），这些标签来自预定义的可选列表。分类问题有时可分为而分类（binary classification）和多分类（multiclass classification）。</p><p>在二分类问题中，我们通常将其中一个类别称为正类（positive class），另一个类别称为反类（negative class）。而鸢尾花的例子则属于多分类问题。另一个多分类的例子是根据网站上的文本预测网站所用的语言。这里的类别就是预定义的语言列表。</p><p>回归任务的目标是预测一个连续值，编程术语叫做浮点数（floating-point number），数学术语叫做实数（real number）。根据教育水平、年龄和居住地来预测一个人的年收入，这就是回归的一个例子。在预测收入时，预测值是一个金额，可以在给定范围内任意取值。回归任务的另一个例子是，根据上一年的产量、天气和农场员工数等属性来预测农场的产量。同样，产量也可以取任意数值。</p><a id="more"></a><p>区分分类任务和回归任务有一个简单的方法，就是问一个问题：输出是否具有某种连续性。如果在可能的结果之间具有连续性，那么它就是一个回归问题。想想预测年收入的例子，输出具有非常明显的连续性。一年赚40000美元还是40001美元并没有实质差别，即时两者金额不同。如果我们的算法在本应预测40000美元时的预测结果是39990美元或40001美元，不必过分在意。</p><p>与此相反，对于识别网站语言的任务来说，并不存在程度问题。网站使用的要么是这种语言，要么是那种语言。在语言之间不存在连续性，在英语和法语之间不存在其他语言。</p><h1 id="泛化过拟合与欠拟合">泛化、过拟合与欠拟合</h1><p>在监督学习中，我们想要在训练数据上构建模型，然后能够对没见过的新数据（这些新数据与训练集具有相同的特性）做出准确预测。如果一个模型能够对没见过的数据做出准确预测，我们就说它能够从训练集泛化（generalize）到测试集。我们想要构建一个泛化精度尽可能高的模型。</p><p>通常来说，我们构建模型，使其在训练集上能够做出准确预测。如果训练集和测试集足够相似，我们预计模型在测试集上也能做出准确预测。不过在某些情况下这一点并不成立。例如，如果我们可以构建非常复杂的模型，那么在训练集上的精度可以想多高就多高。</p><p>为了说明这一点，我们来看一个虚构的例子。比如有一个新手数据科学家，已知之前船的买家记录和对买船不感兴趣的顾客记录，想要预测某个顾客是否会买船（在现实世界中，这实际上是一个非常复杂的问题。虽然我们知道其他顾客还没有从我们这里买过船，但他们可能已经在其他人那里买过了，或者仍在存钱并打算将来再买）。目标是向可能购买的人发送促销电子邮件，而不去打扰那些不感兴趣的顾客。</p><p>判断一个算法在新数据上表现好坏的唯一度量，就是在测试集上的评估。然而从直觉上看（在数学上也可以证明这一点，奥卡姆剃刀理论），我们认为简单的模型对新数据的泛化能力更好。如果规律是“年龄大于50岁的人想要买船”，并且还可以解释所有顾客的行为，那么我们将更相信这条规律，而不是与年龄、子女和婚姻状况都有关系的那条规律。因此，我们总想找到最简单的模型。构建一个对现有信息量来说过于复杂的模型，这被称之为过拟合（overfitting）。如果你在拟合模型时过分关注训练集的细节，得到了一个在训练集上表现很好、但不能泛化到新数据上的模型，那么就存在过拟合。与之相反，如果你的模型过于简单——比如说，“有房子的人都买船”——那么你可能无法抓住数据的全部内容以及数据中的变化，你的模型甚至在训练集上的表现就很差。选择过于简单的模型被称为欠拟合（underfitting）。</p><p>我们的模型越复杂，在训练数据上的预测结果就越好。但是，如果我们的模型过于复杂，我们开始过多关注训练集中每个单独的数据点，模型就不能很好地泛化到新数据上。二者之间存在一个最佳位置，可以得到最好的泛化性能。这就是我们想要的模型。</p><p><img src="/uploads/image/introduction-to-ml-with-python/trade-off-of-model-complexity-against-training-and-test-accuracy.png"></p><h2 id="模型复杂度与数据集大小的关系">模型复杂度与数据集大小的关系</h2><p>需要注意，模型复杂度与训练数据集中的输入的变化密切相关：数据集中包含的数据点的变化范围越大，在不发生过拟合的前提下你可以使用的模型就越复杂。通常来说，收集更多的数据点可以有更大的变化范围，所以更大的数据集可以用来构建更复杂的模型。但是，仅复制相同的数据点或收集非常相似的数据是无济于事的。</p><p>收集更多数据，适当构建更复杂的模型，对监督学习任务往往特别有用。在现实世界中，你往往能够决定收集多少数据，这可能比模型调参更为有效。永远不要低谷更多数据的力量！</p><h1 id="监督学习算法">监督学习算法</h1><h2 id="一些样本数据集">一些样本数据集</h2><p>用模拟的forge数据集来说明分类算法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> mglearn</span><br><span class="line"></span><br><span class="line">X, y = mglearn.datasets.make_forge()</span><br><span class="line">mglearn.discrete_scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], y)</span><br><span class="line">plt.legend([<span class="string">'Class 0'</span>, <span class="string">'Class 1'</span>], loc=<span class="number">4</span>)</span><br><span class="line">plt.xlabel(<span class="string">'First feature'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Second feature'</span>)</span><br><span class="line">print(X.shape)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(26, 2)  # 26行数据，每个数据有2个特征</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/datasets-forge.png"></p><p>用模拟的wave数据集来说明回归算法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X, y = mglearn.datasets.make_wave(n_samples=<span class="number">40</span>)</span><br><span class="line">plt.plot(X, y, <span class="string">'o'</span>)</span><br><span class="line">plt.ylim(<span class="number">-3</span>, <span class="number">3</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Feature'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Target'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/datasets-wave.png"></p><p><strong>从特征较少的数据集（也叫低维数据集）中得出的结论可能并不适用于特征较多的数据集（也叫高维数据集）。</strong></p><p>分类数据集，乳腺癌数据集。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_breast_cancer</span><br><span class="line">cancer = load_breast_cancer()</span><br><span class="line">print(<span class="string">'Keys:'</span>, cancer.keys())</span><br><span class="line">print(<span class="string">'Shape:'</span>, cancer.data.shape)</span><br><span class="line">print(<span class="string">'Feature names:\n&#123;&#125;'</span>.format(cancer.feature_names))  <span class="comment"># 30个特征的名字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">print(<span class="string">'Counter:'</span>, &#123;n: v <span class="keyword">for</span> n, v <span class="keyword">in</span>  <span class="comment"># 按恶性和良性计数</span></span><br><span class="line">                   zip(cancer.target_names, np.bincount(cancer.target))&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Keys: dict_keys([&apos;data&apos;, &apos;target&apos;, &apos;target_names&apos;, &apos;DESCR&apos;, &apos;feature_names&apos;, &apos;filename&apos;])</span><br><span class="line">Shape: (569, 30)</span><br><span class="line">Feature names:</span><br><span class="line">[&apos;mean radius&apos; &apos;mean texture&apos; &apos;mean perimeter&apos; &apos;mean area&apos;</span><br><span class="line"> &apos;mean smoothness&apos; &apos;mean compactness&apos; &apos;mean concavity&apos;</span><br><span class="line"> &apos;mean concave points&apos; &apos;mean symmetry&apos; &apos;mean fractal dimension&apos;</span><br><span class="line"> &apos;radius error&apos; &apos;texture error&apos; &apos;perimeter error&apos; &apos;area error&apos;</span><br><span class="line"> &apos;smoothness error&apos; &apos;compactness error&apos; &apos;concavity error&apos;</span><br><span class="line"> &apos;concave points error&apos; &apos;symmetry error&apos; &apos;fractal dimension error&apos;</span><br><span class="line"> &apos;worst radius&apos; &apos;worst texture&apos; &apos;worst perimeter&apos; &apos;worst area&apos;</span><br><span class="line"> &apos;worst smoothness&apos; &apos;worst compactness&apos; &apos;worst concavity&apos;</span><br><span class="line"> &apos;worst concave points&apos; &apos;worst symmetry&apos; &apos;worst fractal dimension&apos;]</span><br><span class="line">Counter: &#123;&apos;malignant&apos;: 212, &apos;benign&apos;: 357&#125;</span><br></pre></td></tr></table></figure><p>回归数据集，波士顿房价数据集。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_boston</span><br><span class="line">boston = load_boston()</span><br><span class="line">print(boston.data.shape)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(506, 13)</span><br></pre></td></tr></table></figure><p>对于我们的目的而言，我们需要扩展这个数据集，输入特征不仅包括这13个测量结果，还包括这些特征之间的乘积（也叫交互项）。换句话说，我们不仅将犯罪率和公路可达性作为特征，还将犯罪率和公路可达性的乘积作为特征。这个导出的数据集可以用mglearn.load_extended_boston函数加载。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X, y = mglearn.datasets.load_extended_boston()</span><br><span class="line">print(X.shape)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(506, 104)</span><br></pre></td></tr></table></figure><h2 id="k近邻">k近邻</h2><a href="/notes/introduction-to-ml-with-python/k-nearest-neighbors/" title="前往文章">前往文章</a><h2 id="线性模型">线性模型</h2><a href="/notes/introduction-to-ml-with-python/linear-models/" title="前往文章">前往文章</a><h2 id="朴素贝叶苏分类器">朴素贝叶苏分类器</h2><a href="/notes/introduction-to-ml-with-python/naive-bayes-classifiers/" title="前往文章">前往文章</a><h2 id="决策树">决策树</h2><a href="/notes/introduction-to-ml-with-python/decision-trees/" title="前往文章">前往文章</a><h2 id="决策树集成">决策树集成</h2><a href="/notes/introduction-to-ml-with-python/decision-tree-ensemble/" title="前往文章">前往文章</a><h2 id="核支持向量机">核支持向量机</h2><a href="/notes/introduction-to-ml-with-python/kernelized-support-vector-machine/" title="前往文章">前往文章</a><h2 id="神经网络深度学习">神经网络（深度学习）</h2><a href="/notes/introduction-to-ml-with-python/neural-networks-deep-learning/" title="前往文章">前往文章</a><h1 id="分类器的不确定度估计">分类器的不确定度估计</h1><p>我们还没有谈到<code>scikit-learn</code>接口的另一个有用之处，就是分类器能够给出预测的不正确度估计。一般来说，你感兴趣的不仅是分类器会预测一个测试点属于哪个类别，还包括它对这个预测的置信度。在实践中，不同类型的错误会在现实应用中导致非常不同的结果。想象一个用于测试癌症的医疗应用。假阳性预测可能只会让“患者”接受额外的测试，但假阴性却可能导致重病没有得到治疗。</p><p><code>scikit-learn</code>中有两个函数可用于获取分类器的不确定度估计：<code>decision_function</code>和<code>predict_proba</code>。大多数分类器（但不是全部）都至少有其中一个函数，很多分类器两个都有。我们来构建一个GradientBoostingClassifier分类器（同时拥有<code>decision_function</code>和<code>predict_proba</code>两个方法），看一下这两个函数对一个模拟的二维数据集的作用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_circles</span><br><span class="line">X, y = make_circles(noise=<span class="number">0.25</span>, factor=<span class="number">0.5</span>, random_state=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了便于说明，我们将两个类别重命名为"blue"和"red"</span></span><br><span class="line">y_named = np.array([<span class="string">'blue'</span>, <span class="string">'red'</span>])[y]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们可以对任意个数组调用train_test_split</span></span><br><span class="line"><span class="comment"># 所有数组的划分都是一致的</span></span><br><span class="line">X_train, X_test, y_train_named, y_test_named, y_train, y_test = \</span><br><span class="line">    train_test_split(X, y_named, y, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建梯度提升模型</span></span><br><span class="line">gbrt = GradientBoostingClassifier(random_state=<span class="number">0</span>)</span><br><span class="line">gbrt.fit(X_train, y_train_named)</span><br></pre></td></tr></table></figure><h2 id="决策函数">决策函数</h2><p>对于二分类的情况，<code>decision_function</code>返回值的形状是<code>(n_samples,)</code>，为每个样本都返回一个浮点数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'X_test.shape: &#123;&#125;'</span>.format(X_test.shape))</span><br><span class="line">print(<span class="string">'Decision function shape: &#123;&#125;'</span>.format(</span><br><span class="line">    gbrt.decision_function(X_test).shape))</span><br><span class="line"><span class="comment"># 显示decision_function的前几个元素</span></span><br><span class="line">print(<span class="string">'Decision function:\n&#123;&#125;'</span>.format(gbrt.decision_function(X_test)[:<span class="number">6</span>]))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X_test.shape: (25, 2)</span><br><span class="line">Decision function shape: (25,)</span><br><span class="line">Decision function:</span><br><span class="line">[ 4.13592629 -1.7016989  -3.95106099 -3.62599351  4.28986668  3.66166106]</span><br></pre></td></tr></table></figure><p>这个值表示模型对该数据点属于“正”类的置信程度。正值表示对正类的偏好，负值表示对“反类”（其他类）的偏好。</p><p>我们可以通过仅查看决策函数的正负号来再现预测值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'Thresholded decision function:\n&#123;&#125;'</span>.format(</span><br><span class="line">    gbrt.decision_function(X_test) &gt; <span class="number">0</span>))</span><br><span class="line">print(<span class="string">"Predictions:\n&#123;&#125;"</span>.format(gbrt.predict(X_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thresholded decision function:</span><br><span class="line">[ True False False False  True  True False  True  True  True False  True</span><br><span class="line">  True False  True False False False  True  True  True  True  True False</span><br><span class="line"> False]</span><br><span class="line">Predictions:</span><br><span class="line">[&apos;red&apos; &apos;blue&apos; &apos;blue&apos; &apos;blue&apos; &apos;red&apos; &apos;red&apos; &apos;blue&apos; &apos;red&apos; &apos;red&apos; &apos;red&apos; &apos;blue&apos;</span><br><span class="line"> &apos;red&apos; &apos;red&apos; &apos;blue&apos; &apos;red&apos; &apos;blue&apos; &apos;blue&apos; &apos;blue&apos; &apos;red&apos; &apos;red&apos; &apos;red&apos; &apos;red&apos;</span><br><span class="line"> &apos;red&apos; &apos;blue&apos; &apos;blue&apos;]</span><br></pre></td></tr></table></figure><p>对于二分类问题，“反类”始终是<code>classes_</code>属性的第一个元素，“正”类是<code>classes_</code>的第二个元素。因此，如果你想要完全再现predict的输出，需要利用<code>classes_</code>属性。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将布尔值True/False转换成0和1</span></span><br><span class="line">greater_zero = (gbrt.decision_function(X_test) &gt; <span class="number">0</span>).astype(int)</span><br><span class="line"><span class="comment"># 利用0和1作为classes_的索引</span></span><br><span class="line">pred = gbrt.classes_[greater_zero]</span><br><span class="line"><span class="comment"># pred与gbrt.predict的输出完全相同</span></span><br><span class="line">print(<span class="string">'pred is equal to predictions: &#123;&#125;'</span>.format(</span><br><span class="line">    np.all(pred == gbrt.predict(X_test))))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pred is equal to predictions: True</span><br></pre></td></tr></table></figure><p><code>decision_function</code>可以在任意范围取值，这取决于数据和模型参数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">decision_function = gbrt.decision_function(X_test)</span><br><span class="line">print(<span class="string">"Decision function minimum: &#123;:.2f&#125; maximum: &#123;:.2f&#125;"</span>.format(</span><br><span class="line">    np.min(decision_function), np.max(decision_function)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Decision function minimum: -7.69 maximum: 4.29</span><br></pre></td></tr></table></figure><p>由于可以任意缩放，因此<code>decision_function</code>的输出往往很难解释。</p><p>在下面的例子中，我们利用颜色编码在二维平面中画出所有点的<code>decision_function</code>，还有决策边界。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fit, axes = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">13</span>, <span class="number">5</span>))</span><br><span class="line">mglearn.tools.plot_2d_separator(gbrt, X, ax=axes[<span class="number">0</span>], alpha=<span class="number">.4</span>,</span><br><span class="line">    fill=<span class="literal">True</span>, cm=mglearn.cm2)</span><br><span class="line">scores_image = mglearn.tools.plot_2d_scores(gbrt, X, ax=axes[<span class="number">1</span>],</span><br><span class="line">    alpha=<span class="number">.4</span>, cm=mglearn.ReBl)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax <span class="keyword">in</span> axes:</span><br><span class="line">    <span class="comment"># 画出训练点和测试点</span></span><br><span class="line">    mglearn.discrete_scatter(X_test[:, <span class="number">0</span>], X_test[:, <span class="number">1</span>], y_test,</span><br><span class="line">        markers=<span class="string">'^'</span>, ax=ax)</span><br><span class="line">    mglearn.discrete_scatter(X_train[:, <span class="number">0</span>], X_train[:, <span class="number">1</span>], y_train,</span><br><span class="line">        markers=<span class="string">'o'</span>, ax=ax)</span><br><span class="line">    ax.set_xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">'Feature 1'</span>)</span><br><span class="line">cbar = plt.colorbar(scores_image, ax=axes.tolist())</span><br><span class="line">axes[<span class="number">0</span>].legend([<span class="string">'Test class 0'</span>, <span class="string">'Test class 1'</span>, <span class="string">'Train class 0'</span>,</span><br><span class="line">    <span class="string">'Train class 1'</span>], ncol=<span class="number">4</span>, loc=(<span class="number">.1</span>, <span class="number">1.05</span>))</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-and-decision-function-of-gbrt.png"></p><p>既给出预测结果，又给出分类器的置信程度，这样给出的信息量更大。但在上面的决策函数图像（右）中，很难分辨出两个类别之间的边界。</p><h2 id="预测概率">预测概率</h2><p><code>predict_proba</code>的输出是每个类别的概率，通常比<code>decision_function</code>的输出更容易理解。对于二分类问题，它的形状始终是<code>(n_samples, 2)</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'Shape of probabilities: &#123;&#125;'</span>.format(gbrt.predict_proba(X_test).shape))</span><br><span class="line"><span class="comment"># 显示predict_proba的前几个元素</span></span><br><span class="line">print(<span class="string">'Predicted probabilities:\n&#123;&#125;'</span>.format(</span><br><span class="line">    gbrt.predict_proba(X_test[:<span class="number">6</span>])))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Shape of probabilities: (25, 2)</span><br><span class="line">Predicted probabilities:</span><br><span class="line">[[0.01573626 0.98426374]</span><br><span class="line"> [0.84575649 0.15424351]</span><br><span class="line"> [0.98112869 0.01887131]</span><br><span class="line"> [0.97406775 0.02593225]</span><br><span class="line"> [0.01352142 0.98647858]</span><br><span class="line"> [0.02504637 0.97495363]]</span><br></pre></td></tr></table></figure><p>每行的第一个元素是第一个类别的估计概率，第二个元素是第二个类别的估计概率。由于<code>predict_proba</code>的输出是一个概率，因此总是在0和1之间，两个类别的元素之和始终为1，因此只有一个类别的概率超过50%。这个类别就是模型的预测结果（由于概率是浮点数，所以不太可能两个都等于0.500。但如果出现了这种情况，预测结果是随机选择的）。</p><p>在上一个输出中可以看到，分类器对大部分点的置信程度都是相对较高的。<strong>不确定度大小实际上反映了数据依赖于模型和参数的不确定度。过拟合更强的模型可能会做出置信程度更高的预测，即使可能是错的。复杂度越低的模型通常对预测的不确定度越大。</strong>如果模型给出的不确定度符合实际情况，那么这个模型被称为<strong>校正</strong>（calibrated）模型。在校正模型中，如果预测有70%的确定度，那么它在70%的情况下正确。</p><p>在下面的例子中，我们再次给出该数据集的决策边界，以及类别1的预测概率。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fit, axes = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">13</span>, <span class="number">5</span>))</span><br><span class="line">mglearn.tools.plot_2d_separator(gbrt, X, ax=axes[<span class="number">0</span>], alpha=<span class="number">.4</span>,</span><br><span class="line">    fill=<span class="literal">True</span>, cm=mglearn.cm2)</span><br><span class="line">scores_image = mglearn.tools.plot_2d_scores(gbrt, X, ax=axes[<span class="number">1</span>],</span><br><span class="line">    alpha=<span class="number">.4</span>, cm=mglearn.ReBl, function=<span class="string">'predict_proba'</span>)  <span class="comment"># proba</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax <span class="keyword">in</span> axes:</span><br><span class="line">    <span class="comment"># 画出训练点和测试点</span></span><br><span class="line">    mglearn.discrete_scatter(X_test[:, <span class="number">0</span>], X_test[:, <span class="number">1</span>], y_test,</span><br><span class="line">        markers=<span class="string">'^'</span>, ax=ax)</span><br><span class="line">    mglearn.discrete_scatter(X_train[:, <span class="number">0</span>], X_train[:, <span class="number">1</span>], y_train,</span><br><span class="line">        markers=<span class="string">'o'</span>, ax=ax)</span><br><span class="line">    ax.set_xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">'Feature 1'</span>)</span><br><span class="line">cbar = plt.colorbar(scores_image, ax=axes.tolist())</span><br><span class="line">axes[<span class="number">0</span>].legend([<span class="string">'Test class 0'</span>, <span class="string">'Test class 1'</span>, <span class="string">'Train class 0'</span>,</span><br><span class="line">    <span class="string">'Train class 1'</span>], ncol=<span class="number">4</span>, loc=(<span class="number">.1</span>, <span class="number">1.05</span>))</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-and-predict-proba-of-gbrt.png"></p><p>这张图中的边界更加明确，不确定的小块区域清晰可见。</p><h2 id="多分类问题的不确定度">多分类问题的不确定度</h2><p>到目前为止，我们只讨论了二分类问题中的不确定度估计。但<code>decision_function</code>和<code>predict_proba</code>也适用于多分类问题。我们将这两个函数应用于鸢尾花（Iris）数据集，这是一个三分类数据集。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"></span><br><span class="line">iris = load_iris()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">    iris.data, iris.target, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">gbrt = GradientBoostingClassifier(learning_rate=<span class="number">0.01</span>, random_state=<span class="number">0</span>)</span><br><span class="line">gbrt.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Decision function shape: &#123;&#125;'</span>.format(gbrt.decision_function(X_test).shape))</span><br><span class="line"><span class="comment"># 显示决策函数的前几个元素</span></span><br><span class="line">print(<span class="string">'Decision function:\n&#123;&#125;'</span>.format(gbrt.decision_function(X_test)[:<span class="number">6</span>, :]))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Decision function shape: (38, 3)</span><br><span class="line">Decision function:</span><br><span class="line">[[-1.9957153   0.04758118 -1.92721297]</span><br><span class="line"> [ 0.0614655  -1.90755689 -1.92793177]</span><br><span class="line"> [-1.99058105 -1.87637856  0.09686741]</span><br><span class="line"> [-1.9957153   0.04758118 -1.92721297]</span><br><span class="line"> [-1.99730166 -0.13469231 -1.20341532]</span><br><span class="line"> [ 0.0614655  -1.90755689 -1.92793177]]</span><br></pre></td></tr></table></figure><p>对于多分类的情况，<code>decision_function</code>的形状为<code>(n_samples, n_classes)</code>，每一列对应每个类别的“确定度分数”，分数较高的类别可能性更大，得分较低的类别可能性较小。你可以找出每个数据点的最大元素，从而利用这些分数再现预测结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'Argmax of decision function:\n&#123;&#125;'</span>.format(</span><br><span class="line">    np.argmax(gbrt.decision_function(X_test), axis=<span class="number">1</span>)))</span><br><span class="line">print(<span class="string">'Predictions:\n&#123;&#125;'</span>.format(gbrt.predict(X_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Argmax of decision function:</span><br><span class="line">[1 0 2 1 1 0 1 2 1 1 2 0 0 0 0 1 2 1 1 2 0 2 0 2 2 2 2 2 0 0 0 0 1 0 0 2 1</span><br><span class="line"> 0]</span><br><span class="line">Predictions:</span><br><span class="line">[1 0 2 1 1 0 1 2 1 1 2 0 0 0 0 1 2 1 1 2 0 2 0 2 2 2 2 2 0 0 0 0 1 0 0 2 1</span><br><span class="line"> 0]</span><br></pre></td></tr></table></figure><p><code>predict_proba</code>输出的形状相同，也是<code>(n_samples, n_classes)</code>。同样，每个数据点所有可能类别的概率之和为1。同样可以通过计算<code>predict_proba</code>的argmax来再现预测结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示predict_proba的前几个元素</span></span><br><span class="line">print(<span class="string">'Predicted probabilities:\n&#123;&#125;'</span>.format(gbrt.predict_proba(X_test)[:<span class="number">6</span>]))</span><br><span class="line"><span class="comment"># 显示每行的和都是1</span></span><br><span class="line">print(<span class="string">'Sums: &#123;&#125;'</span>.format(gbrt.predict_proba(X_test)[:<span class="number">6</span>].sum(axis=<span class="number">1</span>)))</span><br><span class="line"><span class="comment"># 通过计算predict_proba的argmax来再现预测结果</span></span><br><span class="line">print(<span class="string">'Argmax of predicted probabilities:\n&#123;&#125;'</span>.format(</span><br><span class="line">    np.argmax(gbrt.predict_proba(X_test), axis=<span class="number">1</span>)))</span><br><span class="line">print(<span class="string">'Predictions:\n&#123;&#125;'</span>.format(gbrt.predict(X_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Predicted probabilities:</span><br><span class="line">[[0.10217734 0.78840063 0.10942203]</span><br><span class="line"> [0.7834712  0.1093673  0.1071615 ]</span><br><span class="line"> [0.09818079 0.11005862 0.79176059]</span><br><span class="line"> [0.10217734 0.78840063 0.10942203]</span><br><span class="line"> [0.10360014 0.66723882 0.22916105]</span><br><span class="line"> [0.7834712  0.1093673  0.1071615 ]]</span><br><span class="line">Sums: [1. 1. 1. 1. 1. 1.]</span><br><span class="line">Argmax of predicted probabilities:</span><br><span class="line">[1 0 2 1 1 0 1 2 1 1 2 0 0 0 0 1 2 1 1 2 0 2 0 2 2 2 2 2 0 0 0 0 1 0 0 2 1</span><br><span class="line"> 0]</span><br><span class="line">Predictions:</span><br><span class="line">[1 0 2 1 1 0 1 2 1 1 2 0 0 0 0 1 2 1 1 2 0 2 0 2 2 2 2 2 0 0 0 0 1 0 0 2 1</span><br><span class="line"> 0]</span><br></pre></td></tr></table></figure><p>总之，<code>predict_proba</code>和<code>decision_function</code>的形状始终相同，都是<code>(n_samples, n_classes)</code>——除了二分类特殊情况下的<code>decision_function</code>。对于二分类的情况，<code>decision_function</code>只有一列，对应“正”类<code>classes_[1]</code>。这主要是由于历史原因。</p><p>如果有<code>n_classes</code>列，你可以通过计算每一列的argmax来再现预测结果。但如果类别是字符串，或者整数，但不是从0开始的连续整数的话，一定要小心。如果你想要对比predict的结果与<code>decision_function</code>或<code>predict_proba</code>的结果，一定要用分类器的<code>classes_</code>属性来获取真实的属性名称。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logreg = LogisticRegression()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用iris数据集的类别名称来表示每一个目标值</span></span><br><span class="line">named_target = iris.target_names[y_train]</span><br><span class="line">logreg.fit(X_train, named_target)</span><br><span class="line">print(<span class="string">'unique classes in training data: &#123;&#125;'</span>.format(logreg.classes_))</span><br><span class="line">print(<span class="string">'predictions: &#123;&#125;'</span>.format(logreg.predict(X_test)[:<span class="number">10</span>]))</span><br><span class="line"></span><br><span class="line">argmax_dec_func = np.argmax(logreg.decision_function(X_test), axis=<span class="number">1</span>)</span><br><span class="line">print(<span class="string">'argmax of decision function: &#123;&#125;'</span>.format(argmax_dec_func[:<span class="number">10</span>]))</span><br><span class="line">print(<span class="string">'argmax combined with classes_: &#123;&#125;'</span>.format(</span><br><span class="line">    logreg.classes_[argmax_dec_func][:<span class="number">10</span>]))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unique classes in training data: [&apos;setosa&apos; &apos;versicolor&apos; &apos;virginica&apos;]</span><br><span class="line">predictions: [&apos;versicolor&apos; &apos;setosa&apos; &apos;virginica&apos; &apos;versicolor&apos; &apos;versicolor&apos; &apos;setosa&apos;</span><br><span class="line"> &apos;versicolor&apos; &apos;virginica&apos; &apos;versicolor&apos; &apos;versicolor&apos;]</span><br><span class="line">argmax of decision function: [1 0 2 1 1 0 1 2 1 1]</span><br><span class="line">argmax combined with classes_: [&apos;versicolor&apos; &apos;setosa&apos; &apos;virginica&apos; &apos;versicolor&apos; &apos;versicolor&apos; &apos;setosa&apos;</span><br><span class="line"> &apos;versicolor&apos; &apos;virginica&apos; &apos;versicolor&apos; &apos;versicolor&apos;]</span><br></pre></td></tr></table></figure><h1 id="小结">小结</h1><p>欠拟合是指一个模型无法获取训练数据中的所有变化；过拟合是指模型过分关注训练数据，但对新数据的泛化性能不好。</p><p>关于何时使用哪种模型，下面是一份快速总结。</p><ul><li><p>最近邻</p><p>适用于小型数据集，是很好的基准模型，很容易理解。</p></li><li><p>线性模型</p><p>非常可靠的首选算法，适用于非常大的数据集，也适用于高维数据。</p></li><li><p>朴素贝叶斯</p><p>只适用于分类问题。比线性模型速度还快，适用于非常大的数据集和高维数据。精度通常要低于线性模型。</p></li><li><p>决策树</p><p>进度很快，不需要数据缩放，可以可视化，很容易理解。</p></li><li><p>随机森林</p><p>几乎总是比单棵决策树的表现要好，鲁棒性很好，非常强大。不需要数据缩放。不适用于高维稀疏数据。</p></li><li><p>梯度提升决策树</p><p>精度通常比随机森林略高。与随机森林相比，训练速度满，但预测速度更快，需要的内存也更少。比随机森林需要更多的参数调节。</p></li><li><p>支持向量机</p><p>对于特征含义相似的中等大小的数据集很强大。需要数据缩放，对参数敏感。</p></li><li><p>神经网络</p><p>可以构建非常复杂的模型，特别是对于大型数据集而言。对数据缩放敏感，对参数选取敏感。大型网络需要很长的训练时间。</p></li></ul><p>面对新数据集，通常最好先从简单模型开始，比如线性模型、朴素贝叶斯或最近邻分类器，看能得到什么样的结果。对数据有了进一步了解之后，你可以考虑用于构建更复杂模型的算法，比如随机森林、梯度提升决策树、SVM或神经网络。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Machine Learning with Python </tag>
            
            <tag> supervised </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类元编程</title>
      <link href="/notes/fluent-python/class-metaprogramming/"/>
      <url>/notes/fluent-python/class-metaprogramming/</url>
      
        <content type="html"><![CDATA[<blockquote><p>（元类）是深奥的知识，99%的用户都无需关注。如果你想知道是否需要使用元类，我告诉你，不需要（真正需要使用元类的人确信他们需要，无需解释原因）。</p><p>——Tim Peters（Timsort算法的发明者，活跃的Python贡献者）</p></blockquote><p>类元编程是指在运行时创建或定制类的技艺。在Python中，类是一等对象，因此任何时候都可以使用函数新建类，而无需使用class关键字。类装饰器也是函数，不过能够审查、修改，甚至把被装饰的类替换成其他类。</p><p>元类是类元编程最高级的工具：使用元类可以创建具有某种特质的全新类种，例如抽象基类。元类功能强大，但是难以掌握。类装饰器能使用更简单的方式解决更多问题。</p><p><strong>除非开发框架，否则不要编写元类</strong>。</p><a id="more"></a><h1 id="类工厂函数">类工厂函数</h1><p>本书多次提高标准库中的一个类工厂函数——collections.namedtuple。我们把一个类名和几个属性名传给这个函数，它会创建一个tuple的子类，其中的元素通过名称获取，还为调试提供了友好的字符串表示形式（<code>__repr__</code>）。</p><p>有时，我觉得应该有类似的工厂函数，用于创建可变对象。假设我在编写一个宠物点应用程序时，我想把狗的数据当作简单的记录处理。编写下面的样板代码让人厌烦：</p><figure class="highlight python"><figcaption><span>dog.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, weight, owner)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.owner = owner</span><br></pre></td></tr></table></figure><p>各个字段名称出现了3次。写了这么多样板代码，甚至字符串表示形式都不友好：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> dog <span class="keyword">import</span> Dog</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rex = Dog(<span class="string">'Rex'</span>, <span class="number">30</span>, <span class="string">'Bob'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rex</span><br><span class="line">&lt;dog.Dog object at <span class="number">0x10dbd3ef0</span>&gt;</span><br></pre></td></tr></table></figure><p>参考collections.namedtuple，下面我们创建一个record_factory函数，即时创建简单的类（如Dog）。</p><figure class="highlight python"><figcaption><span>record_factory.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record_factory</span><span class="params">(cls_name, field_names)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:  <span class="comment"># 体现了鸭子类型：尝试在逗号或空格处拆分field_names</span></span><br><span class="line">        field_names = field_names.replace(<span class="string">','</span>, <span class="string">' '</span>).split()</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        <span class="keyword">pass</span>  <span class="comment"># 如果失败，那么假定field_names本就是可迭代的对象</span></span><br><span class="line">    field_names = tuple(field_names)  <span class="comment"># 一个元素对应一个属性名</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        attrs = dict(zip(self.__slots__, args))  <span class="comment"># 位置参数</span></span><br><span class="line">        attrs.update(kwargs)  <span class="comment"># 关键字参数</span></span><br><span class="line">        <span class="keyword">for</span> name, value <span class="keyword">in</span> attrs.items():</span><br><span class="line">            setattr(self, name, value)  <span class="comment"># 设值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> self.__slots__:</span><br><span class="line">            <span class="keyword">yield</span> getattr(self, name)  <span class="comment"># 按顺序产值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span>  <span class="comment"># 生成友好的字符串表示形式</span></span><br><span class="line">        values = <span class="string">', '</span>.join(<span class="string">'&#123;&#125;=&#123;!r&#125;'</span>.format(*i) <span class="keyword">for</span> i</span><br><span class="line">                            <span class="keyword">in</span> zip(self.__slots__, self))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&#123;&#125;(&#123;&#125;)'</span>.format(self.__class__.__name__, values)</span><br><span class="line"></span><br><span class="line">    cls_attrs = dict(__slots__ = field_names,</span><br><span class="line">                     __init__ = __init__,</span><br><span class="line">                     __iter__ = __iter__,</span><br><span class="line">                     __repr__ = __repr__)</span><br><span class="line">    <span class="comment"># 调用type构造方法，构建新类</span></span><br><span class="line">    <span class="keyword">return</span> type(cls_name, (object,), cls_attrs)</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> record_factory <span class="keyword">import</span> record_factory</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Dog = record_factory(<span class="string">'Dog'</span>, <span class="string">'name weight owner'</span>)  <span class="comment"># 签名与namedtuple类似</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rex = Dog(<span class="string">'Rex'</span>, <span class="number">30</span>, <span class="string">'Bob'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rex  <span class="comment"># 友好的字符串表示形式</span></span><br><span class="line">Dog(name=<span class="string">'Rex'</span>, weight=<span class="number">30</span>, owner=<span class="string">'Bob'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name, weight, owner = rex  <span class="comment"># 便利地拆包</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name, weight</span><br><span class="line">(<span class="string">'Rex'</span>, <span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"&#123;2&#125;'s dog weights &#123;1&#125;kg"</span>.format(*rex)  <span class="comment"># 传给format等函数时也可以拆包</span></span><br><span class="line"><span class="string">"Bob's dog weights 32kg"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rex.weight = <span class="number">32</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rex</span><br><span class="line">Dog(name=<span class="string">'Rex'</span>, weight=<span class="number">32</span>, owner=<span class="string">'Bob'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Dog.__mro__  <span class="comment"># 继承自object，与创建它的工厂函数没有关系</span></span><br><span class="line">(&lt;class 'record_factory.Dog'&gt;, &lt;class 'object'&gt;)</span><br></pre></td></tr></table></figure><p><strong>通常，我们把type视作函数，因为我们像函数那样使用它</strong>，例如，调用type(my_object)获取对象所属的类——作用与<code>my_object.__class__</code>相同。然而，type是一个类。传入三个参数可以新建一个类。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/functions#type" target="_blank" rel="noopener"><code>class type(object)</code></a></p><p><code>class type(name, bases, dict)</code></p><p>With one argument, return the type of an object. The return value is a type object and generally the same object as returned by <code>object.__class__</code>.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MyClass = type(<span class="string">'MyClass'</span>, (MySuperClass, MyMixin), &#123;<span class="string">'x'</span>: <span class="number">42</span>, <span class="string">'x2'</span>: <span class="keyword">lambda</span> self: self.x * <span class="number">2</span>&#125;)</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(MySuperClass, MyMixin)</span>:</span></span><br><span class="line">    x = <span class="number">42</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x2</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.x * <span class="number">2</span></span><br></pre></td></tr></table></figure><p>让人觉得新奇的是，<strong>type的实例是类</strong>。</p><p>总之，<code>record_factory</code>函数的最后一行会构建一个类，类的名称是<code>cls_name</code>参数的值，唯一的直接超类是object，有<code>__slots__</code>、<code>__init__</code>、<code>__iter__</code>和<code>__repr__</code>四个类属性，其中后三个是实例方法。</p><p>把三个参数传给type是动态创建类的常用方式。如果查看namedtuple函数的远吗，你会发现另一个种方式：先声明一个<code>_class_template</code>变量，其值是字符串形式的源码模板；然后在namedtuple函数中调用<code>_class_template.format(...)</code>方法，填充模板里的空白；最后，使用内置的exec函数计算得到的源码字符串。</p><p>在Python中做元编程时，最好不用exec和eval函数。如果接收的字符串（或片段）来自不可信的源，那么这两个函数会带来严重的安全风险。Python提供了充足的内省工具，大多数时候都不需要使用exec和eval函数。然而，Python核心开发者实现namedtuple函数时选择了使用exec函数，这样做是为了让生成的类代码能通过<code>._source</code>属性获取。</p><p>record_factory函数创建的类，其实例有个局限——不能序列化，即不能使用pickle模块里的dump/load函数处理。如果想了解完整的方案，请分析collections.namedtuple函数的源码，搜索“pickling”这个词。</p><h1 id="定制描述符的类装饰器">定制描述符的类装饰器</h1><p>LineItem示例还有个问题没有解决：储存属性的名称不具有描述性，即属性（如weight）的值存储在名为<code>_Quantity#0</code>的实例属性中，这样的名称有点不便于调试。如果储存属性的名称中包含托管属性的名称更好：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>LineItem.weight.storage_name</span><br><span class="line"><span class="string">'_Quantity#weight'</span></span><br></pre></td></tr></table></figure><p>我们不能使用描述性的储存属性名称，因为实例化描述符时无法得知托管属性的名称。可是，一旦组建好整个类，而且把描述符绑定到类属性上之后，我们就可以审查类，并为描述符设值合理的储存属性名称。</p><p>LineItem类的<code>__new__</code>方法可以做到这一点，因此，在<code>__init__</code>方法中使用描述符时，储存属性已经设置了正确的名称。为了解决这个问题而使用<code>__new__</code>方法纯属白费力气：每次新建LineItem实例时都会运行<code>__new__</code>方法中的逻辑，可是，一旦LineItem类构建好了，描述符与托管属性之间的绑定就不会变了。因此，我们要在创建类时设置储存属性的名称。使用类装饰器或元类可以做到这一点。</p><p>类装饰器与函数装饰器非常类似，是参数为类对象的函数，返回原来的类或修改后的类。</p><figure class="highlight python"><figcaption><span>model_v5.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoStorage</span>:</span></span><br><span class="line">    __counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        cls = self.__class__</span><br><span class="line">        prefix = cls.__name__</span><br><span class="line">        index = cls.__counter</span><br><span class="line">        self.storage_name = <span class="string">'_&#123;&#125;#&#123;&#125;'</span>.format(prefix, index)</span><br><span class="line">        cls.__counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> getattr(instance, self.storage_name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        setattr(instance, self.storage_name, value)  <span class="comment"># 无验证</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Validate</span><span class="params">(abc.ABC, AutoStorage)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        value = self.validate(instance, value)  <span class="comment"># 委托validate方法</span></span><br><span class="line">        super().__set__(instance, value)  <span class="comment"># 然后把返回的value传给超类的__set__方法，存储值</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, instance, value)</span>:</span>  <span class="comment"># 抽象方法</span></span><br><span class="line">        <span class="string">"""return validated value or raise ValueError"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span><span class="params">(Validate)</span>:</span></span><br><span class="line">    <span class="string">"""a number greater than zero"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonBlank</span><span class="params">(Validate)</span>:</span></span><br><span class="line">    <span class="string">"""a string with at least one non-space character"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        value = value.strip()</span><br><span class="line">        <span class="keyword">if</span> len(value) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value cannot be empty or blank'</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>model_v6.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> model_v5 <span class="keyword">import</span> Validate, Quantity, NonBlank</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">entity</span><span class="params">(cls)</span>:</span>  <span class="comment"># 参数是一个类</span></span><br><span class="line">    <span class="keyword">for</span> key, attr <span class="keyword">in</span> cls.__dict__.items():</span><br><span class="line">        <span class="keyword">if</span> isinstance(attr, Validate):</span><br><span class="line">            type_name = type(attr).__name__</span><br><span class="line">            <span class="comment"># 使用描述符类的名称和托管属性的名称命名storage_name</span></span><br><span class="line">            attr.storage_name = <span class="string">'_&#123;&#125;#&#123;&#125;'</span>.format(type_name, key)</span><br><span class="line">    <span class="keyword">return</span> cls  <span class="comment"># 返回修改后的类</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>bulkfood_v6.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> model_v6 <span class="keyword">as</span> model</span><br><span class="line"></span><br><span class="line"><span class="meta">@model.entity  # LineItem类唯一的变化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">    description = model.NonBlank()</span><br><span class="line">    weight = model.Quantity()</span><br><span class="line">    price = model.Quantity()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, price)</span>:</span></span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> bulkfood_v6 <span class="keyword">import</span> LineItem</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>raisins = LineItem(<span class="string">'Golden raisins'</span>, <span class="number">10</span>, <span class="number">6.95</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(raisins)[:<span class="number">3</span>]</span><br><span class="line">[<span class="string">'_NonBlank#description'</span>, <span class="string">'_Quantity#price'</span>, <span class="string">'_Quantity#weight'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>LineItem.description.storage_name</span><br><span class="line"><span class="string">'_NonBlank#description'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>raisins.description</span><br><span class="line"><span class="string">'Golden raisins'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(raisins, <span class="string">'_NonBlank#description'</span>)</span><br><span class="line"><span class="string">'Golden raisins'</span></span><br></pre></td></tr></table></figure><p>类装饰器能以比较简单的方式做到以前需要使用元类去做的事情——创建类时定制类。<strong>类装饰器有个重大缺点：只对直接依附的类有效。这意味着，被装饰的类的子类可能继承也可能不继承装饰器所做的改动，具体情况视改动的方式而定。</strong>接下来会探讨这个问题，并给出解决方案。</p><h1 id="导入时和运行时比较">导入时和运行时比较</h1><p>为了正确地做元编程，你必须知道Python解释器什么时候计算各个代码块。Python程序员会区分“导入时”和“运行时”，不过这两个术语没有严格的定义，而且二者之间存在着灰色地带。在导入时，解释器会从上到下一次性解析完模块的源码，然后生成用于执行的字节码。如果句法有错误，就在此时报告。如果本地的文件夹中有<code>__pycache__</code>文件夹中有最新的.pyc文件，解释器会跳过上述步骤，因为已经有运行所需的字节码了。</p><p>编译肯定是导入时的活动，不过那个时期还会做其他事，因为Python中的语句几乎都是可执行的，也就是说语句可能会运行用户代码，修改用户程序的状态。尤其是import语句，它不只是声明（Java中的import语句则只是声明，用于告知编辑器需要特定的包），在进程中首次导入模块时，还会运行所导入模块中的全部顶层代码——以后导入相同的模块则使用缓存，只做名称绑定。哪些顶层代码可以做任何事，包括通常在“运行时”做的事，例如连接数据库（虽然不应该这么做，但是可以做到）。因此，“导入时”和“运行时”之间的界限是模糊的：import语句可以触发任何“运行时”行为。</p><p>导入时会”运行全部顶层代码“，但是”顶层代码”会经过一些加工。导入模块时，解释器会执行顶层的def语句，解释器会编译函数的定义体（首次导入模块时），把函数对象绑定到对应的全局名称上，但是显然解释器不会执行函数的定义体。通常这意味着解释器在导入时定义顶层函数，但是仅当在运行时调用函数时才会执行函数的定义体。</p><p>对类来说，情况就不同了：在导入时，解释器会执行每个类的定义体，甚至会执行嵌套类的定义体。执行类定义体的结果是，定义了类的属性和方法，并构建了类的对象。从这个意义上理解，类的定义体属于”顶层代码“，因为它在导入时运行。</p><p>下面的示例帮助我们理解“导入时”和“运行时”的区别。</p><figure class="highlight python"><figcaption><span>evaltime.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> evalsupport <span class="keyword">import</span> deco_alpha</span><br><span class="line"></span><br><span class="line">print(<span class="string">'&lt;[1]&gt; evaltime module start'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassOne</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[2]&gt; ClassOne body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[3]&gt; ClassOne.__init__'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[4]&gt; ClassOne.__del__'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_x</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[5]&gt; ClassOne.method_x'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ClassTwo</span><span class="params">(object)</span>:</span></span><br><span class="line">            print(<span class="string">'&lt;[6]&gt; ClassTwo body'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@deco_alpha</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassThree</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[7]&gt; ClassThree body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_y</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[8]&gt; ClassThree.method_y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassFour</span><span class="params">(ClassThree)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[9]&gt; ClassFour body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_y</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[10]&gt; ClassFour.method_y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'&lt;[11]&gt; ClassOne tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    one = ClassOne()</span><br><span class="line">    one.method_x()</span><br><span class="line">    print(<span class="string">'&lt;[12]&gt; ClassThree tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    three = ClassThree()</span><br><span class="line">    three.method_y()</span><br><span class="line">    print(<span class="string">'&lt;[13]&gt; ClassFour tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    four = ClassFour()</span><br><span class="line">    four.method_y()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'&lt;[14]&gt; evaltime module end'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>evalsupport.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># evaltime.py导入的模块</span></span><br><span class="line">print(<span class="string">'&lt;[100]&gt; evalsupport module start'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco_alpha</span><span class="params">(cls)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[200]&gt; deco_alpha'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_1</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[300]&gt; deco_alpha:inner_1'</span>)</span><br><span class="line"></span><br><span class="line">    cls.method_y = inner_1</span><br><span class="line">    <span class="keyword">return</span> cls</span><br><span class="line"></span><br><span class="line"><span class="comment"># BEGIN META_ALEPH</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MetaAleph</span><span class="params">(type)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[400]&gt; MetaAleph body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, name, bases, dic)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[500]&gt; MetaAleph.__init__'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner_2</span><span class="params">(self)</span>:</span></span><br><span class="line">            print(<span class="string">'&lt;[600]&gt; MetaAleph.__init__:inner_2'</span>)</span><br><span class="line"></span><br><span class="line">        cls.method_z = inner_2</span><br><span class="line"><span class="comment"># END META_ALEPH</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'&lt;[700]&gt; evalsupport module end'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> evaltime  <span class="comment"># 导入模块</span></span><br><span class="line">&lt;[<span class="number">100</span>]&gt; evalsupport module start  <span class="comment"># evalsupport模块的所有顶层代码在导入时运行</span></span><br><span class="line">&lt;[<span class="number">400</span>]&gt; MetaAleph body</span><br><span class="line">&lt;[<span class="number">700</span>]&gt; evalsupport module end</span><br><span class="line">&lt;[<span class="number">1</span>]&gt; evaltime module start</span><br><span class="line">&lt;[<span class="number">2</span>]&gt; ClassOne body</span><br><span class="line">&lt;[<span class="number">6</span>]&gt; ClassTwo body  <span class="comment"># 嵌套的函数定义体也会执行</span></span><br><span class="line">&lt;[<span class="number">7</span>]&gt; ClassThree body</span><br><span class="line">&lt;[<span class="number">200</span>]&gt; deco_alpha</span><br><span class="line">&lt;[<span class="number">9</span>]&gt; ClassFour body</span><br><span class="line">&lt;[<span class="number">14</span>]&gt; evaltime module end</span><br></pre></td></tr></table></figure><p>对于第一个示例，要注意以下几点：</p><ol type="1"><li>这个场景由简单的import evaltime语句触发。</li><li>解释器会执行所导入模块及其依赖中的每个类定义体。</li><li>解释器先计算类的定义体，然后调用依附在类上的装饰器函数，这是合理的行为，因为必须先构建对象，装饰器才有类对象可处理。</li><li>在这个场景中，只运行了一个用户定义的函数或方法——deco_alpha装饰器。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python evaltime.py</span><br><span class="line">&lt;[<span class="number">100</span>]&gt; evalsupport module start</span><br><span class="line">&lt;[<span class="number">400</span>]&gt; MetaAleph body</span><br><span class="line">&lt;[<span class="number">700</span>]&gt; evalsupport module end</span><br><span class="line">&lt;[<span class="number">1</span>]&gt; evaltime module start</span><br><span class="line">&lt;[<span class="number">2</span>]&gt; ClassOne body</span><br><span class="line">&lt;[<span class="number">6</span>]&gt; ClassTwo body</span><br><span class="line">&lt;[<span class="number">7</span>]&gt; ClassThree body</span><br><span class="line">&lt;[<span class="number">200</span>]&gt; deco_alpha</span><br><span class="line">&lt;[<span class="number">9</span>]&gt; ClassFour body</span><br><span class="line">&lt;[<span class="number">11</span>]&gt; ClassOne tests ..............................</span><br><span class="line">&lt;[<span class="number">3</span>]&gt; ClassOne.__init__</span><br><span class="line">&lt;[<span class="number">5</span>]&gt; ClassOne.method_x</span><br><span class="line">&lt;[<span class="number">12</span>]&gt; ClassThree tests ..............................</span><br><span class="line">&lt;[<span class="number">300</span>]&gt; deco_alpha:inner_1</span><br><span class="line">&lt;[<span class="number">13</span>]&gt; ClassFour tests ..............................</span><br><span class="line">&lt;[<span class="number">10</span>]&gt; ClassFour.method_y</span><br><span class="line">&lt;[<span class="number">14</span>]&gt; evaltime module end</span><br><span class="line">&lt;[<span class="number">4</span>]&gt; ClassOne.__del__  <span class="comment"># 程序结束时，绑定在全局变量one上的ClassOne实例才会被垃圾回收程序回收</span></span><br></pre></td></tr></table></figure><p>第二个示例主要想说明的是，类装饰器可能对子类没有影响。我们把ClassFour定义为ClassThree的子类。ClassThree类上依附的<code>@deco_alpha</code>装饰器把<code>method_y</code>方法替换掉了，但是这对ClassFour类根本没有影响。当然，如果<code>ClassFour.method_y</code>方法使用super调用<code>ClassThree.method_y</code>方法，我们便会看到装饰器起作用，执行<code>inner_1</code>函数。</p><p>与此不同的是，如果想定制整个类层次结构，而不是一次只制定一个类，使用元类更高效。</p><h1 id="元类基础知识">元类基础知识</h1><p>元类是制造类的工厂，不过不是函数，而是类。根据Python对象模型，类是对象，因此类肯定是另外某个类的实例。默认情况下，Python中类是type类的实例。也就是说，type是大多数内置的类和用户定义的类的元类：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'spam'</span>.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">str</span>.<span class="title">__class__</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">type</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">from</span> <span class="title">bulkfood_v6</span> <span class="title">import</span> <span class="title">LineItem</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">LineItem</span>.<span class="title">__class__</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">type</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span>.<span class="title">__class__</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">type</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>注意，我没有说str和LineItem继承自type。我的意思是，str和LineItem是type的实例。这两个类是object的子类。下图可能有助于你理清这个奇怪的现象。</p><img src="http://www.plantuml.com/plantuml/svg/NOn12eCm50Ntdk9TuES09MGlz18nVM9AVnJpDuA7hqGArUKCp4pvHL0Nsw3KWMkNFh5MsBOGtYijDX52rvJ87Z0FRoOxXNVkpWxLrZzwviBUg7WSnrognPA8UJoUPmc_YqYhBk8NVW40"><p>object类和type类之间的关系很独特：object是type的实例，而type是object的子类。这种关系很“神奇”，无法使用Python代码表述，因为定义其中一个之前另一个必须存在。type是自身的实例这一点也很神奇。</p><p>除了type，标准库中还有一些别的元类，例如ABCMeta和Enum。如下所示，Iterable所属的类是ABCMeta。Iterable是抽象类，而ABCMeta不是——不管怎样，Iterable是ABCMeta的实例。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> collections</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>collections.Iterable.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">abc</span>.<span class="title">ABCMeta</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">import</span> <span class="title">abc</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">abc</span>.<span class="title">ABCMeta</span>.<span class="title">__class__</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">type</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">abc</span>.<span class="title">ABCMeta</span>.<span class="title">__mro__</span></span></span><br><span class="line"><span class="class"><span class="params">(&lt;class <span class="string">'abc.ABCMeta'</span>&gt;, &lt;class <span class="string">'type'</span>&gt;, &lt;class <span class="string">'object'</span>&gt;)</span></span></span><br></pre></td></tr></table></figure><p>向上追溯，ABCMeta最终所属的类也是type。所有类都直接或间接地是type的实例，不过只有元类同时也是type的子类。<strong>若想理解元类，一定要知道这种关系：元类（如ABCMeta））从type继承了构建类的能力。</strong></p><img src="http://www.plantuml.com/plantuml/svg/FOmn3eCm40Hxl-8-00-84598bIAFk3CRGOG1-Iu5KXuVOmFbhcPc67iGmceR1GH1T7vYLR9j1JLDW74-sjQng4NsHaz3P9dW2bJNjCW7texzgogwTuzNKkcM6lgLqbpUgLBGGbsX4zzRvvdTSLRZsIExVm00"><p>我们要抓住的重点是，<strong>所有类都是type的实例，但是元类还是type的子类</strong>，因此可以作为制造类的工厂。具体来说，元类可以通过实现<code>__init__</code>方法定制实例。元类的<code>__init__</code>方法可以做到类装饰器能做的任何事情，但是作用更大，如接下来的示例。</p><figure class="highlight python"><figcaption><span>evaltime_meta.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> evalsupport <span class="keyword">import</span> deco_alpha</span><br><span class="line"><span class="keyword">from</span> evalsupport <span class="keyword">import</span> MetaAleph</span><br><span class="line"></span><br><span class="line">print(<span class="string">'&lt;[1]&gt; evaltime_meta module start'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@deco_alpha</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassThree</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[2]&gt; ClassThree body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_y</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[3]&gt; ClassThree.method_y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassFour</span><span class="params">(ClassThree)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[4]&gt; ClassFour body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_y</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[5]&gt; ClassFour.method_y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassFive</span><span class="params">(metaclass=MetaAleph)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[6]&gt; ClassFive body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[7]&gt; ClassFive.__init__'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_z</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[8]&gt; ClassFive.method_y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassSix</span><span class="params">(ClassFive)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[9]&gt; ClassSix body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_z</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[10]&gt; ClassSix.method_y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'&lt;[11]&gt; ClassThree tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    three = ClassThree()</span><br><span class="line">    three.method_y()</span><br><span class="line">    print(<span class="string">'&lt;[12]&gt; ClassFour tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    four = ClassFour()</span><br><span class="line">    four.method_y()</span><br><span class="line">    print(<span class="string">'&lt;[13]&gt; ClassFive tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    five = ClassFive()</span><br><span class="line">    five.method_z()</span><br><span class="line">    print(<span class="string">'&lt;[14]&gt; ClassSix tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    six = ClassSix()</span><br><span class="line">    six.method_z()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'&lt;[15]&gt; evaltime_meta module end'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> evaltime_meta</span><br><span class="line">&lt;[<span class="number">100</span>]&gt; evalsupport module start</span><br><span class="line">&lt;[<span class="number">400</span>]&gt; MetaAleph body</span><br><span class="line">&lt;[<span class="number">700</span>]&gt; evalsupport module end</span><br><span class="line">&lt;[<span class="number">1</span>]&gt; evaltime_meta module start</span><br><span class="line">&lt;[<span class="number">2</span>]&gt; ClassThree body</span><br><span class="line">&lt;[<span class="number">200</span>]&gt; deco_alpha</span><br><span class="line">&lt;[<span class="number">4</span>]&gt; ClassFour body</span><br><span class="line">&lt;[<span class="number">6</span>]&gt; ClassFive body</span><br><span class="line">&lt;[<span class="number">500</span>]&gt; MetaAleph.__init__  <span class="comment"># 创建ClassFive时调用了MetaAleph.__init__方法</span></span><br><span class="line">&lt;[<span class="number">9</span>]&gt; ClassSix body</span><br><span class="line">&lt;[<span class="number">500</span>]&gt; MetaAleph.__init__  <span class="comment"># 创建ClassSix时也调用了</span></span><br><span class="line">&lt;[<span class="number">15</span>]&gt; evaltime_meta module end</span><br></pre></td></tr></table></figure><p>Python解释器计算ClassFive类的定义体时没有调用type构建具体的类定义体，而是调用MetaAleph类。<code>MetaAleph.__init__</code>方法有四个参数。</p><p>self：这是要初始化的类对象。编写元类时，通常会把self参数改为cls，表明要构建的实例是类。</p><p>name、bases、dict：与构建类时传给type的参数一样。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python evaltime_meta.py</span><br><span class="line">&lt;[<span class="number">100</span>]&gt; evalsupport module start</span><br><span class="line">&lt;[<span class="number">400</span>]&gt; MetaAleph body</span><br><span class="line">&lt;[<span class="number">700</span>]&gt; evalsupport module end</span><br><span class="line">&lt;[<span class="number">1</span>]&gt; evaltime_meta module start</span><br><span class="line">&lt;[<span class="number">2</span>]&gt; ClassThree body</span><br><span class="line">&lt;[<span class="number">200</span>]&gt; deco_alpha</span><br><span class="line">&lt;[<span class="number">4</span>]&gt; ClassFour body</span><br><span class="line">&lt;[<span class="number">6</span>]&gt; ClassFive body</span><br><span class="line">&lt;[<span class="number">500</span>]&gt; MetaAleph.__init__</span><br><span class="line">&lt;[<span class="number">9</span>]&gt; ClassSix body</span><br><span class="line">&lt;[<span class="number">500</span>]&gt; MetaAleph.__init__</span><br><span class="line">&lt;[<span class="number">11</span>]&gt; ClassThree tests ..............................</span><br><span class="line">&lt;[<span class="number">300</span>]&gt; deco_alpha:inner_1  <span class="comment"># 装饰器依附到ClassThree类上之后，method_y方法被替换了</span></span><br><span class="line">&lt;[<span class="number">12</span>]&gt; ClassFour tests ..............................</span><br><span class="line">&lt;[<span class="number">5</span>]&gt; ClassFour.method_y  <span class="comment"># 虽然ClassFour是ClassThree的子类，但是没有依附装饰器，不受影响</span></span><br><span class="line">&lt;[<span class="number">13</span>]&gt; ClassFive tests ..............................</span><br><span class="line">&lt;[<span class="number">7</span>]&gt; ClassFive.__init__</span><br><span class="line">&lt;[<span class="number">600</span>]&gt; MetaAleph.__init__:inner_2  <span class="comment"># MetaAleph.__init__方法替换了ClassFive.method_z方法</span></span><br><span class="line">&lt;[<span class="number">14</span>]&gt; ClassSix tests ..............................</span><br><span class="line">&lt;[<span class="number">7</span>]&gt; ClassFive.__init__</span><br><span class="line">&lt;[<span class="number">600</span>]&gt; MetaAleph.__init__:inner_2  <span class="comment"># ClassSix.method_z方法也被替换了</span></span><br><span class="line">&lt;[<span class="number">15</span>]&gt; evaltime_meta module end</span><br></pre></td></tr></table></figure><p>注意，ClassSix类没有直接引用MetaAleph类，但是却受到了影响，因为它是ClassFive的子类，进而也是MetaAleph类的实例，所有由<code>MetaAleph.__init__</code>方法初始化。</p><p>如果想进一步定制类，可以在元类中实现<code>__new__</code>方法。不过，通常情况下实现<code>__init__</code>方法就够了。</p><h1 id="定制描述符的元类">定制描述符的元类</h1><p>现在，我们可以实践这些理论了。我们将创建一个元类，让描述符以最佳的方式自动创建储存属性的名称。</p><figure class="highlight python"><figcaption><span>model_v7.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> model_v5 <span class="keyword">import</span> Validate, Quantity, NonBlank</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EntityMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="string">"""元类，用于创建带有验证字段的业务实体"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, name, bases, attr_dict)</span>:</span></span><br><span class="line">        super().__init__(name, bases, attr_dict)  <span class="comment"># 调用type.__init__方法</span></span><br><span class="line">        <span class="keyword">for</span> key, attr <span class="keyword">in</span> attr_dict.items():  <span class="comment"># 修改storage_name，与@entity装饰器的逻辑一样</span></span><br><span class="line">            <span class="keyword">if</span> isinstance(attr, Validate):</span><br><span class="line">                type_name = type(attr).__name__</span><br><span class="line">                attr.storage_name = <span class="string">'_&#123;&#125;#&#123;&#125;'</span>.format(type_name, key)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span><span class="params">(metaclass=EntityMeta)</span>:</span>  <span class="comment"># 这个类只是为了用起来便利：用户直接继承Entity类即可</span></span><br><span class="line">    <span class="string">"""带有验证字段的业务实体"""</span>         <span class="comment"># 无需关心EntityMeta元类，甚至不需要知道它的存在</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>bulkfood_v7.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> model_v7 <span class="keyword">as</span> model</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span><span class="params">(model.Entity)</span>:</span>  <span class="comment"># 继承Entity类</span></span><br><span class="line">    description = model.NonBlank()</span><br><span class="line">    weight = model.Quantity()</span><br><span class="line">    price = model.Quantity()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, price)</span>:</span></span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br></pre></td></tr></table></figure><img src="http://www.plantuml.com/plantuml/svg/bL71QeGm5BpdAm9xAyr-G16XXHuAtK8fz1go-ggX9X7pR2dgl_TLZRfg2_La9ZFptanodG87K-8NDs3EKB6aKDxpsnhT2xfAPS2ZA0MVLBgaSnppXd7wf4nSRP44FoS_KALL1dgWCO2vIplYQQjHoZMQmGxeUx1ZwkonKWdoLrNeL26a-qjif1TW4smw_Z7waFUGxxbM5ZMb_jjtetjozgvGzft_L_YeBJmWc51VC3e45-tiS1DMEto2pd9SWMMbazyg3hFkU-e9KD6Mn58zlDVQ9BnuxrRCnRF54xH2JCMjyP27pSqASJN7lg5fGo0fh-c_pq6ZfqAtz4KpH9okH5sADXv3icNMut54IHv5sdfKDW7ktkBu6m00"><h1 id="元类的特殊方法__prepare__">元类的特殊方法<code>__prepare__</code></h1><p>在某些应用中，可能需要知道类的属性定义的顺序。例如，对读写CSV文件的库来说，用户定义的类可能想把类中按顺序声明的字段与CSV文件中各列的顺序对应起来。</p><p>type构造方法及元类的<code>__new__</code>和<code>__init__</code>方法都会收到要计算的类的定义体，形式是名称到属性的映像。然而在默认情况下，那个映射是字典；也就是说，元类或装饰器获得映像时，属性在类定义体中的顺序已经丢失了。</p><p>这个问题的解决方法是，使用Python3引入的特殊方法<code>__prepare__</code>。这个特殊方法只在元类中有用，而且必须声明为类方法（即，要使用@classmethod装饰器定义）。解释器调用元类的<code>__new__</code>方法之前会先调用<code>__prepare__</code>方法，使用类定义体中的属性创建映射。<code>__prepare__</code>方法的第一个参数是元类，随后两个参数分别是要构建的类的映射和基类组成的元组，返回值必须是映射。元类构建新类时，<code>__prepare__</code>方法返回的映射会传给<code>__new__</code>方法的最后一个参数，然后再传给<code>__init__</code>方法。</p><p>理论听起来很复杂，但是我见过的<code>__prepare__</code>方法都十分简单。</p><figure class="highlight python"><figcaption><span>model_v8.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> model_v5 <span class="keyword">import</span> Validate, Quantity, NonBlank</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EntityMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="string">"""元类，用于创建带有验证字段的业务实体"""</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__prepare__</span><span class="params">(cls, name, bases)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> collections.OrderedDict()  <span class="comment"># 返回空的OrderDict实例</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, name, bases, attr_dict)</span>:</span>  <span class="comment"># OrderedDict实例会绑定到attr_dict上</span></span><br><span class="line">        super().__init__(name, bases, attr_dict)</span><br><span class="line">        cls._field_names = []  <span class="comment"># 在要构建的类中创建一个_field_names属性</span></span><br><span class="line">        <span class="keyword">for</span> key, attr <span class="keyword">in</span> attr_dict.items():  <span class="comment"># 因此for循环迭代attr_dict时会按添加的顺序迭代</span></span><br><span class="line">            <span class="keyword">if</span> isinstance(attr, Validate):</span><br><span class="line">                type_name = type(attr).__name__</span><br><span class="line">                attr.storage_name = <span class="string">'_&#123;&#125;#&#123;&#125;'</span>.format(type_name, key)</span><br><span class="line">                cls._field_names.append(key)  <span class="comment"># 把各个Validate字段添加到_field_names</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span><span class="params">(metaclass=EntityMeta)</span>:</span></span><br><span class="line">    <span class="string">"""带有验证字段的业务实体"""</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">field_names</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> cls._field_names:</span><br><span class="line">            <span class="keyword">yield</span> name</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>bulkfood_v8.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> model_v8 <span class="keyword">as</span> model  <span class="comment"># 从v8中导入，其他不变</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span><span class="params">(model.Entity)</span>:</span></span><br><span class="line">    description = model.NonBlank()</span><br><span class="line">    weight = model.Quantity()</span><br><span class="line">    price = model.Quantity()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, price)</span>:</span></span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> bulkfood_v8 <span class="keyword">import</span> LineItem</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name <span class="keyword">in</span> LineItem.field_names():</span><br><span class="line"><span class="meta">... </span>    print(name)</span><br><span class="line">...</span><br><span class="line">description</span><br><span class="line">weight</span><br><span class="line">price</span><br></pre></td></tr></table></figure><p>在现实世界中，框架和库会使用元类协助程序员执行很多任务，例如：</p><ul><li>验证属性</li><li>一次把装饰器依附到多个类上</li><li>序列化对象或转换数据</li><li>对象关系映射</li><li>基于对象的持久存储</li><li>动态转换使用其他语言编写的类结构</li></ul><h1 id="类作为对象">类作为对象</h1><p>Python数据模型为每个类定义了很多属性，其中三个属性在本书中已经见过多次：<code>__mro__</code>、<code>__class__</code>和<code>__name__</code>。此外，还有以下属性。</p><ul><li><p><code>cls.__bases__</code></p><p>由类的基类组成的元组。</p></li><li><p><code>cls.__qualname__</code></p><p>Python3.3新引入的属性，其值是类或函数的限定名称，即从模块的全局作用域到类的点分路径。</p></li><li><p><code>cls.__subclasses__()</code></p><p>这个方法返回一个列表，包含类的直接子类。这个方法的实现使用弱引用，防止在超类和子类之间出现循环引用（子类在<code>__bases__</code>属性中存储指向超类的强引用）。这个方法返回的列表中是内存里现存的子类。</p></li><li><p><code>cls.mro()</code></p><p>构建类时，如果需要获取存储在类属性<code>__mro__</code>中的超类元组，解释器会调用这个方法。元类可以覆盖这个方法，定制要构建的类解析方法的顺序。</p></li></ul><p>dir函数不会列出本节提到的任何一个属性。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> metaprogramming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>属性描述符</title>
      <link href="/notes/fluent-python/attribute-descriptors/"/>
      <url>/notes/fluent-python/attribute-descriptors/</url>
      
        <content type="html"><![CDATA[<p>描述符是对多个属性运用相同存取逻辑的一种方式。描述符是实现了特定协议的类，这个协议包括<code>__get__</code>、<code>__set__</code>和<code>__delete__</code>方法。property类实现了完整的描述符协议。通常，可以只实现部分协议。除了特性之外，使用描述符的还有方法及classmethod和staticmethod装饰器。</p><h1 id="描述符示例验证属性">描述符示例：验证属性</h1><h2 id="lineitem类第3版一个简单的描述符">LineItem类第3版：一个简单的描述符</h2><p>实现了<code>__get__</code>、<code>__set__</code>或<code>__delete__</code>方法的类是描述符。描述符的用法是，创建一个实例，作为另一个类的类属性。</p><p>把quantity特性工厂函数重构成Quantity描述符类。LineItem类的UML示意图如下。</p><img src="http://www.plantuml.com/plantuml/svg/XP0zIyD06CVt-nGF7GK3xIWXk-3YNZZEz6mFaal9NH490GSNApPhwH0GGHSvqaryQRzCaylcL_1CsgGKnDkU__rVuETwH0Wudn0kcRm6snvGuOPiB8FGSI12O9um1nbIp8bFAo7ogHm5WnWmPfn9Z0zLGN_56BbL-ndZz5HIVrktMs01h-uhoeOZ2T5s9gx4SSXSUg3zCoic5pAGn3ExF90KEaMIbEjClpxhvSVtvo9NgPvbVTx8-KDIAgKNj-Q_0qG0x-wITtEj7kjOCPss2PLkLlTzdZzbnNosUNitbdoP5ZSl-oqznBjWDL0Hxu7bqKjfDIHG0znoMZmdKAgL_bBrUjtREktZetqhnXKY0-5lHqqMuny0"><p>weight和price是依附在LineItem类上的Quantity类的实例，不过LineItem实例也有自己的weight和price属性，存储着相应的值。即LineItem会有两个weight属性：一个是LineItem的类属性（UML图中的<u>weight</u>和<u>price</u>，他们是描述符Quantity的实例），一个是LineItem对象的实例属性（UML图中的weight {storage}和price {storage}，他们是float值）。</p><a id="more"></a><p>Quantity实例是LineItem类的类属性，这一点一定要理解。下图的涂鸦展示了描述符类、LineItem类以及它们的实例之间的关系。</p><p><img src="/uploads/image/fluent-python/MGN-sketch.png"></p><p>在图中，类被画成了“机器”（有操纵杆和刻度盘的设备），用于生产小怪兽（实例）。小怪兽与生产它的机器具有相同的颜色。在这个示例中，LineItem生产了三个小怪兽，每个小怪兽有3个单元格，表示三个属性（description、weight和price）。Quantity实例是描述符，因此有个放大镜，用于获取值（<code>__get__</code>），以及一个手抓，用于设置值（<code>__set__</code>）。</p><figure class="highlight python"><figcaption><span>bulkfood_v3.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, storage_name)</span>:</span></span><br><span class="line">        self.storage_name = storage_name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span>  <span class="comment"># 基于协议实现</span></span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:  <span class="comment"># 必须直接托管__dict__属性，若使用内置的setattr函数，会再次触发</span></span><br><span class="line">            instance.__dict__[self.storage_name] = value  <span class="comment"># __set__方法，导致无限递归</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">    weight = Quantity(<span class="string">'weight'</span>)  <span class="comment"># 绑定给weight属性，storage_name='weight'</span></span><br><span class="line">    price = Quantity(<span class="string">'price'</span>)  <span class="comment"># 小缺点，重复输入了属性名称</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, price)</span>:</span></span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> bulkfood_v3 <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>truffle = LineItem(<span class="string">'White truffle'</span>, <span class="number">100</span>, <span class="number">0</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"/Users/cws/Desktop/bulkfood_v3.py"</span>, line <span class="number">19</span>, <span class="keyword">in</span> __init__</span><br><span class="line">    self.price = price</span><br><span class="line">  File <span class="string">"/Users/cws/Desktop/bulkfood_v3.py"</span>, line <span class="number">10</span>, <span class="keyword">in</span> __set__</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line">ValueError: value must be &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure><p>你可能想把各个托管属性的值直接存在描述符实例中，但是这种做法是错误的。也就是说，在<code>__set__</code>方法中，应该像下面这样写：<code>instance.__dict__[self.storage_name] = value</code>；而不能试图使用下面这种错误的写法：<code>self.__dict__[self.storage_name] = value</code>。这里，self是描述符实例，它其实是托管类的类属性。同一时刻，内存中可能有几千个LineItem实例，不过只会有两个描述符实例：LineItem.weight和LineItem.price。因此，存储在描述符实例中的数据，其实会变成LineItem类的类属性，从而由全部LineItem实例共享。</p><p>示例有个缺点，在托管类的定义体中实例化描述符时要重复输入属性的名称。如果能像<code>weight = Quantity()</code>这样声明就好了。可问题是，赋值语句右手边的表达式先执行，而此时变量还不存在。Quantity()表达式计算的结果是创建描述符实例，而此时Quantity类中的代码无法猜出要把描述符绑定给哪个变量。</p><h2 id="lineitem类第4版自动获取储存属性的名称">LineItem类第4版：自动获取储存属性的名称</h2><p>本节介绍一个不太优雅但是可行的方案，解决重复输入名称的问题。更好的解决方案是使用类装饰器或元类。</p><p>为了避免在描述符声明语句中重复输入属性名，我们将为每个Quantity实例的storage_name属性生成一个独一无二的字符串。即实例属性weight在<code>__dict__</code>中的键不是'weight'，而是由描述符生成的一个字符串，通过描述符的<code>__set__</code>或<code>__get__</code>方法访问该属性。</p><figure class="highlight python"><figcaption><span>bulkfood_v4.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span>:</span></span><br><span class="line">    __counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        cls = self.__class__</span><br><span class="line">        prefix = cls.__name__</span><br><span class="line">        index = cls.__counter</span><br><span class="line">        self.storage_name = <span class="string">'_&#123;&#125;#&#123;&#125;'</span>.format(prefix, index)  <span class="comment"># index独一无二</span></span><br><span class="line">        cls.__counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> getattr(instance, self.storage_name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:</span><br><span class="line">            setattr(instance, self.storage_name, value)  <span class="comment"># 这里可以使用内置的setattr函数</span></span><br><span class="line">        <span class="keyword">else</span>:                                            <span class="comment"># 因为存储属性的名称不同，不会无限递归</span></span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">    weight = Quantity()</span><br><span class="line">    price = Quantity()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, price)</span>:</span></span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> bulkfood_v4 <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coconuts = LineItem(<span class="string">'Brazilian coconut'</span>, <span class="number">20</span>, <span class="number">17.95</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coconuts.weight, coconuts.price  <span class="comment"># 使用描述符</span></span><br><span class="line">(<span class="number">20</span>, <span class="number">17.95</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(coconuts, <span class="string">'_Quantity#0'</span>)  <span class="comment"># 读取储存属性</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><p>注意，<code>__get__</code>方法有三个参数：self、instance和owner。owner参数是托管类（如LineItem）的引用，通过描述符从托管类中获取属性时用得到。如果使用LineItem.weight从类中获取托管属性，描述符的<code>__get__</code>方法接收到的instance参数值是None。因此，下述控制台会话才会抛出AttributeError异常：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> bulkfood_v4 <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>LineItem.weight</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"/Users/cws/Desktop/bulkfood_v4.py"</span>, line <span class="number">12</span>, <span class="keyword">in</span> __get__</span><br><span class="line">    <span class="keyword">return</span> getattr(instance, self.storage_name)</span><br><span class="line">AttributeError: <span class="string">'NoneType'</span> object has no attribute <span class="string">'_Quantity#0'</span></span><br></pre></td></tr></table></figure><p>抛出AttributeError异常是实现<code>__get__</code>方法的方式之一，如果选择这么做，应该修改错误消息，去掉令人困惑的NoneType和_Quantity#0，这是实现细节。把错误消息改成&quot;'LineItem' class has no such attribute&quot;更好。最好能给出缺少的属性名，但是在这个示例中，描述符不知道托管属性的名称，因此目前只能做到这样。</p><p>此外，为了给用户提供内省和其他元编程技术支持，通过类访问托管属性时，最好让<code>__get__</code>方法返回描述符实例。</p><figure class="highlight python"><figcaption><span>bulkfood_v4.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改后的__get__方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> self  <span class="comment"># 如果不是通过实例调用，返回描述符自身</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> getattr(instance, self.storage_name)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> bulkfood_v4 <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>LineItem.price</span><br><span class="line">&lt;bulkfood_v4.Quantity object at <span class="number">0x10cc31550</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>br_nuts = LineItem(<span class="string">'Brazil nuts'</span>, <span class="number">10</span>, <span class="number">34.95</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>br_nuts.price</span><br><span class="line"><span class="number">34.95</span></span><br></pre></td></tr></table></figure><p>你可能觉得就为了管理几个属性而编写这么多代码不值得，但是要知道，描述符逻辑现在被抽象到单独的代码单元中了。通常，我们不会在使用描述符的模块中定义描述符，而是在一个单独的实用工具模块中定义，以便在整个应用中使用——如果开发的是框架，甚至会在多个应用中使用。</p><h2 id="特性工厂函数和描述符类的比较">特性工厂函数和描述符类的比较</h2><p>特性工厂函数若想实现增强的描述符类并不难。<code>__counter</code>变量的实现方式是个难点，不过我们可以把它定义成工厂函数对象的属性，以便在多次调用之间持续存在。</p><figure class="highlight python"><figcaption><span>bulkfood_v4prop.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quantity</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        quantity.counter += <span class="number">1</span></span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        quantity.counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    storage_name = <span class="string">'_&#123;&#125;:&#123;&#125;'</span>.format(<span class="string">'quantity'</span>, quantity.counter)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qty_getter</span><span class="params">(instance)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> getattr(instance, storage_name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qty_setter</span><span class="params">(instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:</span><br><span class="line">            setattr(instance, storage_name, value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> property(qty_getter, qty_setter)</span><br></pre></td></tr></table></figure><p>你更喜欢哪种方式？我喜欢描述符类那种方式，主要有下列两个原因。</p><ul><li>描述符类可以用子类扩展；若想重用工厂函数中的代码，除了复制粘贴，很难有其他方法。</li><li>与特性工厂函数使用函数属性和闭包保持状态相比，在类属性和实例属性中保持状态更易于理解。</li></ul><p>总之，从某种程度上来讲，特性工厂函数模式较简单，可是描述符类方式更易扩展，而且应用也更广泛。</p><h2 id="lineitem类第5版一种新型描述符">LineItem类第5版：一种新型描述符</h2><p>我们虚构的有机食物网店遇到一个问题：不知怎么回事儿，有个商品的描述信息为空，导致无法下订单。为了避免这个问题，我们要再创建一个描述符，NonBlank。在设计NonBlank的过程中，我们发现，它与Quantity描述符很像，只是验证逻辑不同。</p><p>回想Quantity的功能，我们注意到它做了两件不同的事：管理托管实例中的储存属性，以及验证用于设置那两个属性的值。由此可知，我们可以重构，并创建两个基类。</p><img src="http://www.plantuml.com/plantuml/svg/ZPBVIW915CRlzodc1No14A4U88YWgs2PTYTTMcTZTmn2ZUoFuIBfXOeL61AeIPfBteI5JpCpwrMlqBZZcffGStS-VkUSxvmpcWaT1socYBLBB1l64OX6TUHejd4iubWCf1KWdgfgLWeJP0UH8r4LmoGAX7GIaOIbPmLdO8EewgeQHsj49n2p2hO80YOw91l0l-bIjyFxJLxEquiExTMfrs3dRNv_nKebVppWBotkZVQnFtpqXqyIdrA23K057ZZ4XXe1Uz0qT4YGldwYNpwMn7HO9WjEPdL2exOHJmYdhF1ClUh2ueIjgKltq_UQj5UMBbjv_b0xcxLWjNVsLXNgu99NEdHyFMcEUCMJCEqt-Er0L0ZxpUbWqactwB_clZwAp7NzN54ej5rXXJeVtScM4f-RrOAxxgGW9WOv_MC52oFAl6qBRvaG7u7_9ovzeKpaP_tAmY4oaSZSqweUzlm6"><p>Validate、Quantity和NonBlank三个类之间的关系体现了模板方法设计模式。具体而言，<code>validate.__set__</code>方法正是模板方法的例证：</p><blockquote><p>一个模板方法用一些抽象的操作定义一个算法，而子类将重定义这些操作以提供具体的行为。</p></blockquote><figure class="highlight python"><figcaption><span>model_v5.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoStorage</span>:</span></span><br><span class="line">    __counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        cls = self.__class__</span><br><span class="line">        prefix = cls.__name__</span><br><span class="line">        index = cls.__counter</span><br><span class="line">        self.storage_name = <span class="string">'_&#123;&#125;#&#123;&#125;'</span>.format(prefix, index)</span><br><span class="line">        cls.__counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> getattr(instance, self.storage_name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        setattr(instance, self.storage_name, value)  <span class="comment"># 无验证</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Validate</span><span class="params">(abc.ABC, AutoStorage)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        value = self.validate(instance, value)  <span class="comment"># 委托validate方法</span></span><br><span class="line">        super().__set__(instance, value)  <span class="comment"># 然后把返回的value传给超类的__set__方法，存储值</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, instance, value)</span>:</span>  <span class="comment"># 抽象方法</span></span><br><span class="line">        <span class="string">"""return validated value or raise ValueError"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span><span class="params">(Validate)</span>:</span></span><br><span class="line">    <span class="string">"""a number greater than zero"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonBlank</span><span class="params">(Validate)</span>:</span></span><br><span class="line">    <span class="string">"""a string with at least one non-space character"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        value = value.strip()</span><br><span class="line">        <span class="keyword">if</span> len(value) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value cannot be empty or blank'</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>bulkfood_v5.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> model_v5 <span class="keyword">as</span> model</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">    description = model.NonBlank()  <span class="comment"># 除此之外的其余代码不变</span></span><br><span class="line">    weight = model.Quantity()</span><br><span class="line">    price = model.Quantity()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, price)</span>:</span></span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br></pre></td></tr></table></figure><p>本章演示了<strong>描述符的典型用途——管理数据属性。</strong>这种描述符也叫覆盖型描述符，因为描述符的<code>__set__</code>方法使用托管实例中的同名属性覆盖（即插手接管）了要设置的属性。不过也有非覆盖型描述符。</p><h1 id="覆盖型与非覆盖型描述符对比">覆盖型与非覆盖型描述符对比</h1><p><strong>Python存取属性的方式特别不对等。通过实例读取属性时，通常返回的是实例中定义的属性；但是，如果实例中没有指定的属性，那么会获取类属性。而为实例中的属性赋值时，通常会在实例中创建属性，根本不影响类。</strong></p><p>这种不对等的处理方式对描述符也有影响。其实，根据是否定义<code>__set__</code>方法，描述符可分为两大类。</p><figure class="highlight python"><figcaption><span>descriptorkinds.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">### 辅助函数，仅用于显示 ###</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cls_name</span><span class="params">(obj_or_cls)</span>:</span></span><br><span class="line">    cls = type(obj_or_cls)</span><br><span class="line">    <span class="keyword">if</span> cls <span class="keyword">is</span> type:</span><br><span class="line">        cls = obj_or_cls</span><br><span class="line">    <span class="keyword">return</span> cls.__name__.split(<span class="string">'.'</span>)[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(obj)</span>:</span></span><br><span class="line">    cls = type(obj)</span><br><span class="line">    <span class="keyword">if</span> cls <span class="keyword">is</span> type:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;class &#123;&#125;&gt;'</span>.format(obj.__name__)</span><br><span class="line">    <span class="keyword">elif</span> cls <span class="keyword">in</span> [type(<span class="literal">None</span>), int]:</span><br><span class="line">        <span class="keyword">return</span> repr(obj)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;&#123;&#125; object&gt;'</span>.format(cls_name(obj))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_args</span><span class="params">(name, *args)</span>:</span></span><br><span class="line">    pseudo_args = <span class="string">', '</span>.join(display(x) <span class="keyword">for</span> x <span class="keyword">in</span> args)</span><br><span class="line">    print(<span class="string">'-&gt; &#123;&#125;.__&#123;&#125;__(&#123;&#125;)'</span>.format(cls_name(args[<span class="number">0</span>]), name, pseudo_args))</span><br><span class="line"></span><br><span class="line"><span class="comment">### 对这个示例重要的类 ###</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Overriding</span>:</span></span><br><span class="line">    <span class="string">"""覆盖型描述符，也称数据描述符或强制描述符"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        print_args(<span class="string">'get'</span>, self, instance, owner)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        print_args(<span class="string">'set'</span>, self, instance, value)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OverridingNoGet</span>:</span></span><br><span class="line">    <span class="string">"""没有``__get__``方法的覆盖型描述符"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        print_args(<span class="string">'set'</span>, self, instance, value)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonOverriding</span>:</span>  <span class="comment"># 没有__set__方法</span></span><br><span class="line">    <span class="string">"""非覆盖型描述符，也称非数据描述符或遮盖型描述符"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        print_args(<span class="string">'get'</span>, self, instance, owner)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Managed</span>:</span>  <span class="comment"># 托管类，使用各个描述符类的一个实例</span></span><br><span class="line">    over = Overriding()</span><br><span class="line">    over_no_get = OverridingNoGet()</span><br><span class="line">    non_over = NonOverriding()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self)</span>:</span>  <span class="comment"># 方法也是描述符</span></span><br><span class="line">        print(<span class="string">'-&gt; Managed.spam(&#123;&#125;)'</span>.format(display(self)))</span><br></pre></td></tr></table></figure><h2 id="覆盖型描述符">覆盖型描述符</h2><p>实现<code>__set__</code>方法的描述符属于覆盖型描述符，会覆盖对实例属性的赋值操作。特性也是覆盖型描述符：如果没有提供设值函数，property类中的<code>__set__</code>方法会抛出AttributeError异常，指明那个属性是只读的。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> descriptorkinds <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Managed()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over  <span class="comment"># 触发__get__方法，第二个参数的值是托管实例</span></span><br><span class="line">-&gt; Overriding.__get__(&lt;Overriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Managed.over  <span class="comment"># Managed.over触发的__get__方法，第二个参数的值是None</span></span><br><span class="line">-&gt; Overriding.__get__(&lt;Overriding object&gt;, None, &lt;class Managed&gt;)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over = <span class="number">7</span>  <span class="comment"># 赋值</span></span><br><span class="line">-&gt; Overriding.__set__(&lt;Overriding object&gt;, &lt;Managed object&gt;, 7)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over  <span class="comment"># 读取</span></span><br><span class="line">-&gt; Overriding.__get__(&lt;Overriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.__dict__[<span class="string">'over'</span>] = <span class="number">7</span>  <span class="comment"># 跳过描述符赋值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vars(obj)</span><br><span class="line">&#123;<span class="string">'over'</span>: <span class="number">7</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over  <span class="comment"># 即使有名为over的实例属性，Managed.over描述符仍会覆盖读取obj.over</span></span><br><span class="line">-&gt; Overriding.__get__(&lt;Overriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;)</span><br></pre></td></tr></table></figure><h2 id="没有__get__方法的覆盖型描述符">没有<code>__get__</code>方法的覆盖型描述符</h2><p>描述符可以只实现<code>__set__</code>方法，此时，只有写操作由描述符处理。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over_no_get  <span class="comment"># 因为OverridingNoGet描述符没有__get__方法，读操作返回的是描述符实例</span></span><br><span class="line">&lt;descriptorkinds.OverridingNoGet object at <span class="number">0x10fd71860</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Managed.over_no_get</span><br><span class="line">&lt;descriptorkinds.OverridingNoGet object at <span class="number">0x10fd71860</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over_no_get = <span class="number">7</span>  <span class="comment"># 有__set__方法，赋值时会触发</span></span><br><span class="line">-&gt; OverridingNoGet.__set__(&lt;OverridingNoGet object&gt;, &lt;Managed object&gt;, 7)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over_no_get  <span class="comment"># 由于__set__方法没有存储值，只是打印了消息，此处依然返回实例对象</span></span><br><span class="line">&lt;descriptorkinds.OverridingNoGet object at <span class="number">0x10fd71860</span>&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.__dict__[<span class="string">'over_no_get'</span>] = <span class="number">9</span>  <span class="comment"># 跳过描述符赋值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over_no_get  <span class="comment"># 读值操作，由于没有__get__方法，实例属性遮盖了描述符</span></span><br><span class="line"><span class="number">9</span>                    <span class="comment"># 但是只有读操作是如此</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over_no_get = <span class="number">7</span></span><br><span class="line">-&gt; OverridingNoGet.__set__(&lt;OverridingNoGet object&gt;, &lt;Managed object&gt;, 7)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over_no_get</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><h2 id="非覆盖型描述符">非覆盖型描述符</h2><p>没有实现<code>__set__</code>方法的描述符是非覆盖型描述符。如果设置了同名的实例属性，描述符会被遮盖，致使描述符无法处理那个实例的那个属性。方法是以非覆盖型描述符实现的。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.non_over  <span class="comment"># 触发__get__方法</span></span><br><span class="line">-&gt; NonOverriding.__get__(&lt;NonOverriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.non_over = <span class="number">7</span>  <span class="comment"># 赋值，现在obj有个名为non_over的实例属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.non_over  <span class="comment"># 读值，实例属性遮盖了obj的同名描述符</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Managed.non_over  <span class="comment"># 描述符依然存在</span></span><br><span class="line">-&gt; NonOverriding.__get__(&lt;NonOverriding object&gt;, None, &lt;class Managed&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> obj.non_over  <span class="comment"># 删除实例属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.non_over  <span class="comment"># 能触发__get__方法了</span></span><br><span class="line">-&gt; NonOverriding.__get__(&lt;NonOverriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;)</span><br></pre></td></tr></table></figure><h2 id="在类中覆盖描述符">在类中覆盖描述符</h2><p>依附在<strong>类</strong>上的描述符无法控制为类属性赋值的操作。这意味着为类属性赋值能覆盖描述符属性。</p><p>不管描述符是不是覆盖型，为类属性赋值都能覆盖描述符。这是一种猴子布丁技术。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Managed()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Managed.over = <span class="number">1</span>  <span class="comment"># 覆盖类属性，不会触发__set__方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Managed.over_no_get = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Managed.non_over = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over, obj.over_no_get, obj.non_over</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><strong>示例揭示了读写属性的另一种不对等：读类属性的操作可以由依附在托管类上定义有<code>__get__</code>方法的描述符处理，但是写类属性的操作不会由依附在托管类上定义有<code>__set__</code>方法的描述符处理。</strong></p><p>若想控制设置类属性的操作，要把描述符依附在类的类上，即依附在元类上。默认情况下，对用户定义的类来说，其元类是type，而我们不能为type添加属性。</p><h1 id="方法是描述符">方法是描述符</h1><p>在类中定义的函数属于绑定方法（bound method），因为用户定义的函数都有<code>__get__</code>方法，所以依附到类上时，就相当于描述符。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> descriptorkinds <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Managed()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.spam  <span class="comment"># 获取的是绑定方法对象</span></span><br><span class="line">&lt;bound method Managed.spam of &lt;descriptorkinds.Managed object at <span class="number">0x10251dcf8</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Managed.spam  <span class="comment"># 获取的是函数</span></span><br><span class="line">&lt;function Managed.spam at <span class="number">0x102528158</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.spam = <span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.spam</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><p>函数没有实现<code>__set__</code>方法，因此是非覆盖型描述符。从示例中还可以看出一个重要信息：obj.spam和Managed.spam获取的是不同的对象。与描述符一样，通过托管类访问时，函数的<code>__get__</code>方法会返回自身的引用。但是，通过实例访问时，函数的<code>__get__</code>方法返回的是绑定方法对象：一种可调用的对象，里面包装着函数，并把托管实例（例如obj）绑定给函数的第一个参数（即self），这与functools.partial函数的行为一致。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> collections</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Text</span><span class="params">(collections.UserString)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">'Text(&#123;!r&#125;)'</span>.format(self.data)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> self[::<span class="number">-1</span>]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word = Text(<span class="string">'forward'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word  <span class="comment"># 实例</span></span><br><span class="line">Text(<span class="string">'forward'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word.reverse()  <span class="comment"># 调用实例方法</span></span><br><span class="line">Text(<span class="string">'drawrof'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Text.reverse(Text(<span class="string">'backward'</span>))  <span class="comment"># 在类上调用方法相当于调用函数，传入self参数</span></span><br><span class="line">Text(<span class="string">'drawkcab'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(Text.reverse), type(word.reverse)  <span class="comment"># 类型不同，前者是函数，后者是方法</span></span><br><span class="line">(&lt;class 'function'&gt;, &lt;class 'method'&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(Text.reverse, [<span class="string">'repaid'</span>, (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>), Text(<span class="string">'stressed'</span>)]))  <span class="comment"># 该函数可以处理其他对象</span></span><br><span class="line">[<span class="string">'diaper'</span>, (<span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>), Text(<span class="string">'desserts'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Text.reverse.__get__(word)  <span class="comment"># 调用函数的__get__方法传入实例时，得到的是绑定到那个实例上的方法</span></span><br><span class="line">&lt;bound method Text.reverse of Text(<span class="string">'forward'</span>)&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Text.reverse.__get__(<span class="literal">None</span>, Text)  <span class="comment"># 如果instance的值是None，得到的是函数本身</span></span><br><span class="line">&lt;function Text.reverse at <span class="number">0x1025281e0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word.reverse  <span class="comment"># word.reverse表达式其实会调用Text.reverse.__get__(word)，返回对应的绑定方法</span></span><br><span class="line">&lt;bound method Text.reverse of Text(<span class="string">'forward'</span>)&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word.reverse.__self__  <span class="comment"># 绑定方法对象有个__self__属性，值是调用这个方法的实例引用</span></span><br><span class="line">Text(<span class="string">'forward'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word.reverse.__func__ <span class="keyword">is</span> Text.reverse  <span class="comment"># __func__属性是依附在托管类上那个原始函数的引用</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word.reverse.__call__()  <span class="comment"># __call__方法用于处理真正的调用过程。这个方法会调用__func__属性</span></span><br><span class="line">Text(<span class="string">'drawrof'</span>)              <span class="comment"># 引用的原始函数，把函数的第一个参数设为绑定方法的__self__属性</span></span><br><span class="line">                             <span class="comment"># 这就是形参self的隐式绑定方式</span></span><br></pre></td></tr></table></figure><p>函数会变成绑定方法，这是Python语言底层使用描述符的最好例证。</p><h1 id="描述符用法建议">描述符用法建议</h1><ul><li><p>使用特性以保持简单</p><p>内置的propety类创建的其实是覆盖型描述符，<code>__set__</code>方法和<code>__get__</code>方法都实现了，即便不定义设值方法也是如此。特性的<code>__set__</code>方法默认抛出AttributeError: can't set attribute，因此创建只读属性最简单的方式是使用特性，这能避免下一条所述的问题。</p></li><li><p>只读描述符必须有<code>__set__</code>方法</p><p>如果使用描述符类实现只读属性，要记住，<code>__get__</code>和<code>__set__</code>两个方法必须都定义，否则，实例的同名属性会遮盖描述符。只读属性的<code>__set__</code>方法只需抛出AttributeError异常，并提供合适的错误信息。</p></li><li><p>用于验证的描述符可以只有<code>__set__</code>方法</p><p>对仅用于验证的描述符来说，<code>__set__</code>方法应该检查value参数获得的值，如果有效，使用描述符实例的名称为键，直接在实例的<code>__dict__</code>属性中设置。这样，从实例中读取同名属性的速度很快，因为不用经过<code>__get__</code>方法处理。</p></li><li><p>仅有<code>__get__</code>方法的描述符可以实现高速缓存</p><p>如果只编写了<code>__get__</code>方法，那么创建的是非覆盖型描述符。这种描述符可用于执行某些耗费资源的计算，然后为实例设置同名属性，缓存结果。同名实例属性会遮盖描述符，因此后续访问会直接从实例的<code>__dict__</code>属性中获取值，而不会再触发描述符的<code>__get__</code>方法。</p></li><li><p>非特殊的方法可以被实例属性遮盖</p><p>由于函数和方法只实现了<code>__get__</code>方法，它们不会处理同名实例属性的赋值操作。因此，像<code>my_obj.the_method = 7</code>这样简单赋值之后，后续通过该实例访问the_method得到的是数字7——但是不影响类或其他实例。然而，特殊方法不受这个问题的影响。解释器只会在类中寻找特殊方法，也就是说，repr(x)执行的其实是<code>x.__class__.__repr__(x)</code>，因此x的<code>__repr__</code>属性对repr(x)方法调用没有影响。出于同样的原因，实例的<code>__getattr__</code>属性不会破坏常规的属性访问规则。</p></li></ul><h1 id="描述符的文档字符串和覆盖删除操作">描述符的文档字符串和覆盖删除操作</h1><p>描述符类的文档字符串用于注解托管类中的各个描述符实例。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> bulkfood_v5 <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(LineItem)</span><br><span class="line">Help on <span class="class"><span class="keyword">class</span> <span class="title">LineItem</span> <span class="title">in</span> <span class="title">module</span> <span class="title">bulkfood_v5</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span><span class="params">(builtins.object)</span></span></span><br><span class="line"><span class="class"> |  <span class="title">Methods</span> <span class="title">defined</span> <span class="title">here</span>:</span></span><br><span class="line"> |  </span><br><span class="line"> |  __init__(self, description, weight, price)</span><br><span class="line"> |      Initialize self.  See help(type(self)) <span class="keyword">for</span> accurate signature.</span><br><span class="line"> |  </span><br><span class="line"> |  subtotal(self)</span><br><span class="line"> |  </span><br><span class="line"> |  ----------------------------------------------------------------------</span><br><span class="line"> |  Data descriptors defined here:</span><br><span class="line"> |  </span><br><span class="line"> |  __dict__</span><br><span class="line"> |      dictionary <span class="keyword">for</span> instance variables (<span class="keyword">if</span> defined)</span><br><span class="line"> |  </span><br><span class="line"> |  __weakref__</span><br><span class="line"> |      list of weak references to the object (<span class="keyword">if</span> defined)</span><br><span class="line"> |  </span><br><span class="line"> |  description</span><br><span class="line"> |      a string <span class="keyword">with</span> at least one non-space character</span><br><span class="line"> |  </span><br><span class="line"> |  price</span><br><span class="line"> |      a number greater than zero</span><br><span class="line"> |  </span><br><span class="line"> |  weight</span><br><span class="line"> |      a number greater than zero</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(LineItem.weight)  <span class="comment"># 提示的信息有点不足</span></span><br><span class="line">Help on Quantity <span class="keyword">in</span> module model_v5 object:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span><span class="params">(Validate)</span></span></span><br><span class="line"><span class="class"> |  <span class="title">a</span> <span class="title">number</span> <span class="title">greater</span> <span class="title">than</span> <span class="title">zero</span></span></span><br><span class="line"><span class="class"> |  </span></span><br><span class="line"><span class="class"> |  <span class="title">Method</span> <span class="title">resolution</span> <span class="title">order</span>:</span></span><br><span class="line"> |      Quantity</span><br><span class="line"> |      Validate</span><br><span class="line"> |      abc.ABC</span><br><span class="line"> |      AutoStorage</span><br><span class="line"> |      builtins.object</span><br><span class="line"> |  </span><br><span class="line"> |  Methods defined here:</span><br><span class="line"> |  </span><br><span class="line"> |  validate(self, instance, value)</span><br><span class="line"> |      <span class="keyword">return</span> validated value <span class="keyword">or</span> <span class="keyword">raise</span> ValueError</span><br><span class="line"> |  </span><br><span class="line"> |  ----------------------------------------------------------------------</span><br><span class="line"> |  Data <span class="keyword">and</span> other attributes defined here:</span><br><span class="line"> |  </span><br><span class="line"> |  __abstractmethods__ = frozenset()</span><br><span class="line"> |  </span><br><span class="line"> |  ----------------------------------------------------------------------</span><br><span class="line"> |  Methods inherited <span class="keyword">from</span> Validate:</span><br><span class="line"> |  </span><br><span class="line"> |  __set__(self, instance, value)</span><br><span class="line"> |  </span><br><span class="line"> |  ----------------------------------------------------------------------</span><br><span class="line"> |  Data descriptors inherited <span class="keyword">from</span> abc.ABC:</span><br><span class="line"> |  </span><br><span class="line"> |  __dict__</span><br><span class="line"> |      dictionary <span class="keyword">for</span> instance variables (<span class="keyword">if</span> defined)</span><br><span class="line"> |  </span><br><span class="line"> |  __weakref__</span><br><span class="line"> |      list of weak references to the object (<span class="keyword">if</span> defined)</span><br><span class="line"> |  </span><br><span class="line"> |  ----------------------------------------------------------------------</span><br><span class="line"> |  Methods inherited <span class="keyword">from</span> AutoStorage:</span><br><span class="line"> |  </span><br><span class="line"> |  __get__(self, instance, owner)</span><br><span class="line"> |  </span><br><span class="line"> |  __init__(self)</span><br><span class="line"> |      Initialize self.  See help(type(self)) <span class="keyword">for</span> accurate signature.</span><br></pre></td></tr></table></figure><p>对LineItem类来说，如果能说明weight必须以千克为单位就好了。这对特性来说小菜一碟，因为各个特性只处理特定的托管属性。可是对描述符来说，weight和price使用的都是Quantity描述符类。定制各个描述符实例的帮助文本特别难。有一种方法是为各个描述符实例动态构建包装类。</p><p>对删除托管属性处理时，在描述符类中，实现常规的<code>__get__</code>和（或）<code>__set__</code>方法之外，可以实现<code>__delete__</code>方法，或者只实现<code>__delete__</code>方法。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> attribute descriptors </tag>
            
            <tag> property </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断一个数是否是质数</title>
      <link href="/programming/check-whether-a-number-is-prime-or-not/"/>
      <url>/programming/check-whether-a-number-is-prime-or-not/</url>
      
        <content type="html"><![CDATA[<p>本文内容：</p><ul><li>concurrent.futures.ProcessPoolExecutor文档。</li><li>如何快速判断一个数是否是质数。</li><li>回顾参数化装饰器和协程的用法。</li></ul><h1 id="processpoolexecutor示例">ProcessPoolExecutor示例</h1><p>使用<a href="https://devdocs.io/python~3.6/library/concurrent.futures#concurrent.futures.ProcessPoolExecutor" target="_blank" rel="noopener">concurrent.futures.ProcessPoolExecutor</a>实现并行。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">PRIMES = [</span><br><span class="line">    <span class="number">112272535095293</span>,</span><br><span class="line">    <span class="number">112582705942171</span>,</span><br><span class="line">    <span class="number">112272535095293</span>,</span><br><span class="line">    <span class="number">115280095190773</span>,</span><br><span class="line">    <span class="number">115797848077099</span>,</span><br><span class="line">    <span class="number">1099726899285419</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_prime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:  <span class="comment"># 是否能被2整除</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 不能的话继续检测</span></span><br><span class="line">    sqrt_n = int(math.floor(math.sqrt(n)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, sqrt_n + <span class="number">1</span>, <span class="number">2</span>):  <span class="comment"># 检测能否被 3 5 7 ... floor(sqrt(n))</span></span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:                 <span class="comment"># 因为不能被2整除，所以也不能被2的倍数整除</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ProcessPoolExecutor() <span class="keyword">as</span> executor:</span><br><span class="line">        <span class="keyword">for</span> number, prime <span class="keyword">in</span> zip(PRIMES, executor.map(is_prime, PRIMES)):</span><br><span class="line">            print(<span class="string">'%d is prime: %s'</span> % (number, prime))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="优化is_prime函数">优化is_prime函数</h1><p>示例中用到is_prime函数来检测一个数是否为质数。趁此机会学习了一下is_prime的优化方案。<a href="https://www.geeksforgeeks.org/python-program-to-check-whether-a-number-is-prime-or-not/" target="_blank" rel="noopener">原文</a></p><p>上述is_prime并不通用，因为它没有考虑边界情况（2是质数）。考虑到函数的输入n远远大于2，示例中这样做没什么问题。</p><p>下面单独讨论如何更高效判断一个数是否是质数。根据质数的定义，质数只能被1和自身整除，所以最直白的算法是依次检测能否被2 3 ... n-1整除。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_prime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="comment"># Corner cases</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">3</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Check from 2 to n-1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>优化的做法是排除检测某些不可能整除的值，例如前文见过的跳过所有偶数以及大于<span class="math inline">\(\lfloor \sqrt{n}\rfloor\)</span>的整数。</p><p>更进一步，我们可以利用下述结论：<strong>所有的质数，都是<span class="math inline">\(6k\pm 1\)</span>的形式，除了2和3。</strong>因此，如果一个数不能被2或3整除的话，那么在接下来的检测中，我们只需检测能否被<span class="math inline">\(6k\pm 1\)</span>整除即可。因为所有的整数都能表示为<span class="math inline">\(6k\pm i,\quad i=-1,0,1,2,3,4\)</span>，其中<span class="math inline">\(6k+0\)</span>、<span class="math inline">\(6k+2\)</span>和<span class="math inline">\(6k+4\)</span>能被2整除，<span class="math inline">\(6k+3\)</span>能被3整数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="comment"># Corner cases</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">3</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># This is checked so that we can skip</span></span><br><span class="line">    <span class="comment"># middle five numbers in below loop</span></span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">or</span> n % <span class="number">3</span> == <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">  </span><br><span class="line">    i = <span class="number">5</span></span><br><span class="line">    <span class="keyword">while</span>(i * i &lt;= n):</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span> <span class="keyword">or</span> n % (i + <span class="number">2</span>) == <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        i = i + <span class="number">6</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h1 id="多线程与多进程">多线程与多进程</h1><figure class="highlight python"><figcaption><span>prime.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">PRIMES = [</span><br><span class="line">    <span class="number">112272535095293</span>,</span><br><span class="line">    <span class="number">112582705942171</span>,</span><br><span class="line">    <span class="number">112272535095293</span>,</span><br><span class="line">    <span class="number">115280095190773</span>,</span><br><span class="line">    <span class="number">115797848077099</span>,</span><br><span class="line">    <span class="number">1099726899285419</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_prime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="comment"># Corner cases</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">3</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># This is checked so that we can skip</span></span><br><span class="line">    <span class="comment"># middle five numbers in below loop</span></span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">or</span> n % <span class="number">3</span> == <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">  </span><br><span class="line">    i = <span class="number">5</span></span><br><span class="line">    <span class="keyword">while</span>(i * i &lt;= n):</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span> <span class="keyword">or</span> n % (i + <span class="number">2</span>) == <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        i = i + <span class="number">6</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">()</span>:</span>  <span class="comment"># 利用协程计算平均值</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span> average</span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(n_time=<span class="number">10</span>)</span>:</span>  <span class="comment"># 一个参数化的装饰器，重复运行函数并计算平均耗时</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*args)</span>:</span></span><br><span class="line">            avg = averager()</span><br><span class="line">            next(avg)  <span class="comment"># 预激</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(n_time):</span><br><span class="line">                t = time.time()</span><br><span class="line">                func(*args)</span><br><span class="line">                elapsed = time.time() - t</span><br><span class="line">                means = avg.send(elapsed)</span><br><span class="line">            print(<span class="string">'run &#123;&#125; &#123;&#125; times, average &#123;:.4f&#125; s'</span>.format(func, n_time, means))</span><br><span class="line">        <span class="keyword">return</span> clocked</span><br><span class="line">    <span class="keyword">return</span> decorate</span><br><span class="line"></span><br><span class="line"><span class="meta">@test(5)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main_sequence</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> PRIMES:</span><br><span class="line">        is_prime(number)</span><br><span class="line"></span><br><span class="line"><span class="meta">@test(5)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main_multithread</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor() <span class="keyword">as</span> executor:</span><br><span class="line">        executor.map(is_prime, PRIMES)</span><br><span class="line"></span><br><span class="line"><span class="meta">@test(5)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main_multiprocess</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ProcessPoolExecutor() <span class="keyword">as</span> executor:</span><br><span class="line">        executor.map(is_prime, PRIMES)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main_sequence()</span><br><span class="line">    main_multithread()</span><br><span class="line">    main_multiprocess()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python prime.py</span><br><span class="line">run &lt;function main_sequence at <span class="number">0x10ca98268</span>&gt; <span class="number">5</span> times, average <span class="number">2.1310</span> s</span><br><span class="line">run &lt;function main_multithread at <span class="number">0x10ca98378</span>&gt; <span class="number">5</span> times, average <span class="number">2.1739</span> s</span><br><span class="line">run &lt;function main_multiprocess at <span class="number">0x10ca98488</span>&gt; <span class="number">5</span> times, average <span class="number">0.6985</span> s</span><br></pre></td></tr></table></figure><p>可以看到，对于计算是否是质数这种CPU密集型作业，多线程没有任何优势，甚至比按序计算还慢一点点。而多进程则明显要快很多。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> parallelism </tag>
            
            <tag> prime number </tag>
            
            <tag> concurrent </tag>
            
            <tag> decorators </tag>
            
            <tag> coroutines </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特性</title>
      <link href="/notes/fluent-python/property/"/>
      <url>/notes/fluent-python/property/</url>
      
        <content type="html"><![CDATA[<h1 id="使用特性验证属性">使用特性验证属性</h1><h2 id="lineitem类第1版表示订单中商品的类">LineItem类第1版：表示订单中商品的类</h2><figure class="highlight python"><figcaption><span>bulkfood_v1.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, pricre)</span>:</span></span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight  <span class="comment"># 可能为负值（无效输入）</span></span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br></pre></td></tr></table></figure><p>我们可以修改LineItem类的接口，使用读值方法和设值方法管理weight属性。这是Java采用的方式，这里也完全可行。但是，如果能直接设定商品的weight属性，则显得更自然。此外，系统可能在生产环境中，而其他部分已经直接访问item.weight了。此时，符合Python风格的做法是，把数据属性换成特性。</p><h2 id="lineitem类第2版能验证值的特性">LineItem类第2版：能验证值的特性</h2><figure class="highlight python"><figcaption><span>bulkfood_v2.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, price)</span>:</span></span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight  <span class="comment"># 这里已经使用特性的设值方法了</span></span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weight</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__weight  <span class="comment"># 真正的值存储在私有属性__weight中</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @weight.setter  # 被装饰的读值方法有个setter属性，这个属性也是装饰器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weight</span><span class="params">(self, value)</span>:</span>  <span class="comment"># 这个装饰器把读值方法和设值方法绑定在一起</span></span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:</span><br><span class="line">            self.__weight = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python -i bulkfood_v2.py</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>walnuts = LineItem(<span class="string">'walnuts'</span>, <span class="number">0</span>, <span class="number">100.0</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"bulkfood_v2.py"</span>, line <span class="number">5</span>, <span class="keyword">in</span> __init__</span><br><span class="line">    self.weight = weight  <span class="comment"># 这里已经使用特性的设值方法了</span></span><br><span class="line">  File <span class="string">"bulkfood_v2.py"</span>, line <span class="number">20</span>, <span class="keyword">in</span> weight</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line">ValueError: value must be &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure><p>现在，我们禁止用户为weight属性提供负值或零。我们也可以把price属性变成特性，但是这样我们的代码就存在一些重复。去除重复的方式是抽象。抽象特性的定义有两种方式：使用特性工厂函数，或者使用描述符类。后者更灵活。其实，特性本身就是使用描述符类实现的。</p><h1 id="特性全解析">特性全解析</h1><p>虽然内置的property经常用作装饰器，但它其实是一个类。在Python中函数和类通常可以互换，因为二者都是可调用的对象，而且没有实例化对象的new运算符，所以调用构造方法与调用工厂函数没有区别。此外，只要能返回新的可调用对象，代替被装饰的函数，二者都可以用作装饰器。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/functions#property" target="_blank" rel="noopener"><code>class property(fget=None, fset=None, fdel=None, doc=None)</code></a></p><p>Return a property attribute.</p><p>A typical use is to define a managed attribute <code>x</code>:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._x = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getx</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setx</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._x = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delx</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">del</span> self._x</span><br><span class="line"></span><br><span class="line">    x = property(getx, setx, delx, <span class="string">"I'm the 'x' property."</span>)</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p>在某些情况下，这种经典形式比装饰器句法好，稍后讨论的特性工厂函数就是一例。但是，在方法众多的类定义体中使用装饰器的话，一眼就能看出哪些是读值方法，哪些是设值方法，而不用按照惯例，在方法名的前面加上set和get。</p><h2 id="特性会覆盖实例属性">特性会覆盖实例属性</h2><p>特性都是类属性，但是特性管理的其实是实例属性的存取。如果实例和所属的类有同名数据属性，那么实例属性会覆盖（或称遮盖）类属性——至少通过那个实例读取属性时是这样。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Class</span>:</span></span><br><span class="line"><span class="meta">... </span>    data = <span class="string">'the class data attr'</span>  <span class="comment"># 类属性</span></span><br><span class="line"><span class="meta">... </span>    @property</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">prop</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> <span class="string">'the prop value'</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Class()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vars(obj)  <span class="comment"># 实例属性是空的</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.data  <span class="comment"># 通过实例获取到了类属性</span></span><br><span class="line"><span class="string">'the class data attr'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.data = <span class="string">'bar'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vars(obj)</span><br><span class="line">&#123;<span class="string">'data'</span>: <span class="string">'bar'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.data  <span class="comment"># 普通属性：实例属性覆盖类属性</span></span><br><span class="line"><span class="string">'bar'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Class.data  <span class="comment"># Class.data属性的值完好无损</span></span><br><span class="line"><span class="string">'the class data attr'</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Class.prop  <span class="comment"># 特性是类属性</span></span><br><span class="line">&lt;property object at <span class="number">0x10c59b7c8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.prop</span><br><span class="line"><span class="string">'the prop value'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.prop = <span class="string">'foo'</span>  <span class="comment"># 无法设值prop实例属性</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: can‘t set attribute</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.__dict__[<span class="string">'prop'</span>] = <span class="string">'foo'</span>  <span class="comment"># 可以直接存到字典中</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vars(obj)</span><br><span class="line">&#123;<span class="string">'data'</span>: <span class="string">'bar'</span>, <span class="string">'prop'</span>: <span class="string">'foo'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.prop  <span class="comment"># 仍会运行特性的读值方法，即特性会覆盖实例属性</span></span><br><span class="line"><span class="string">'the prop value'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Class.prop = <span class="string">'baz'</span>  <span class="comment"># 覆盖特性，销毁特性对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.prop</span><br><span class="line"><span class="string">'foo'</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.data  <span class="comment"># 实例属性</span></span><br><span class="line"><span class="string">'bar'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Class.data  <span class="comment"># 类属性</span></span><br><span class="line"><span class="string">'the class data attr'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Class.data = property(<span class="keyword">lambda</span> self: <span class="string">'the "data" prop value'</span>)  <span class="comment"># 覆盖类属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.data  <span class="comment"># 实例属性被特性遮盖了</span></span><br><span class="line"><span class="string">'the "data" prop value'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> Class.data  <span class="comment"># 删除特性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.data</span><br><span class="line"><span class="string">'bar'</span></span><br></pre></td></tr></table></figure><p><strong>对于覆盖性描述符（overriding descriptor，特性其实是覆盖性描述符），obj.attr这样的表达式不会从obj开始寻找attr，而是从<code>obj.__class__</code>开始，而且，仅当类中没有名为attr的特性时，Python才会在obj实例中寻找。</strong></p><h2 id="特性的文档">特性的文档</h2><p>如果使用经典调用句法，为property对象设值文档字符串的方法是传入doc参数。使用装饰器创建property对象时，读值方法（有@property装饰器的方法）的文档字符串作为一个整体，变成特性的文档。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    @property</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>            <span class="string">"""The bar attribute"""</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> self.__dict__[<span class="string">'bar'</span>]</span><br><span class="line"><span class="meta">... </span>    @bar.setter</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self, value)</span>:</span></span><br><span class="line"><span class="meta">... </span>            self.__dict__[<span class="string">'bar'</span>] = value</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(Foo)</span><br><span class="line"></span><br><span class="line">Help on <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="title">in</span> <span class="title">module</span> <span class="title">__main__</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(builtins.object)</span></span></span><br><span class="line"><span class="class"> |  <span class="title">Data</span> <span class="title">descriptors</span> <span class="title">defined</span> <span class="title">here</span>:</span></span><br><span class="line"> |  </span><br><span class="line"> |  __dict__</span><br><span class="line"> |      dictionary <span class="keyword">for</span> instance variables (<span class="keyword">if</span> defined)</span><br><span class="line"> |  </span><br><span class="line"> |  __weakref__</span><br><span class="line"> |      list of weak references to the object (<span class="keyword">if</span> defined)</span><br><span class="line"> |  </span><br><span class="line"> |  bar</span><br><span class="line"> |      The bar attribute</span><br><span class="line">(END)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(Foo.bar)</span><br><span class="line"></span><br><span class="line">Help on property:</span><br><span class="line"></span><br><span class="line">    The bar attribute</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure><h1 id="定义一个特性工厂函数">定义一个特性工厂函数</h1><figure class="highlight python"><figcaption><span>bulkfood_v2prop.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quantity</span><span class="params">(storage_name)</span>:</span>  <span class="comment"># 特性工厂函数</span></span><br><span class="line">    <span class="comment"># storage_name确定特性的数据存储在哪儿，对weight特性来说，存储的名称是'weight'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qty_getter</span><span class="params">(instance)</span>:</span>  <span class="comment"># 参数可以命名为self，但是会有点奇怪，因为它不是类方法</span></span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[storage_name]  <span class="comment"># 跳过特性，直接读取，避免无限递归</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qty_setter</span><span class="params">(instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:  <span class="comment"># 验证</span></span><br><span class="line">            instance.__dict__[storage_name] = value  <span class="comment"># 跳过特性</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> property(qty_getter, qty_setter)  <span class="comment"># 返回特性</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">    weight = quantity(<span class="string">'weight'</span>)  <span class="comment"># 使用特性工厂创建特性</span></span><br><span class="line">    price = quantity(<span class="string">'price'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, price)</span>:</span></span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python -i bulkfood_v2prop.py</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nutmeg = LineItem(<span class="string">'Moluccan nutmeg'</span>, <span class="number">8</span>, <span class="number">13.95</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(vars(nutmeg).items())</span><br><span class="line">[(<span class="string">'description'</span>, <span class="string">'Moluccan nutmeg'</span>), (<span class="string">'price'</span>, <span class="number">13.95</span>), (<span class="string">'weight'</span>, <span class="number">8</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nutmeg.price = <span class="number">0</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"bulkfood_v2prop.py"</span>, line <span class="number">10</span>, <span class="keyword">in</span> qty_setter</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line">ValueError: value must be &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure><h1 id="处理属性删除操作">处理属性删除操作</h1><p>对象的属性可以使用del语句删除。使用Python编程时不常删除属性，通过特性删除属性更少见。但是，Python支持这么做。</p><figure class="highlight python"><figcaption><span>blackknight.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlackKnight</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.members = [<span class="string">'an arm'</span>, <span class="string">'another arm'</span>,</span><br><span class="line">                        <span class="string">'a leg'</span>, <span class="string">'another leg'</span>]</span><br><span class="line">        self.phrases = [<span class="string">"‘Tis but a scratch."</span>,</span><br><span class="line">                        <span class="string">"It‘s just a flesh wound."</span>,</span><br><span class="line">                        <span class="string">"I‘m invincible!"</span>,</span><br><span class="line">                        <span class="string">"All right, we’ll call it a draw."</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">member</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'next member is:'</span>)</span><br><span class="line">        <span class="keyword">return</span> self.members[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @member.deleter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">member</span><span class="params">(self)</span>:</span>  <span class="comment"># 特性一次删除两个属性中的零号元素</span></span><br><span class="line">        text = <span class="string">'BLACK KNIGHT (losed &#123;&#125;)\n-- &#123;&#125;'</span></span><br><span class="line">        print(text.format(self.members.pop(<span class="number">0</span>), self.phrases.pop(<span class="number">0</span>)))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python -i blackknight.py</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>knight = BlackKnight()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>knight.member</span><br><span class="line">next member <span class="keyword">is</span>:</span><br><span class="line"><span class="string">'an arm'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> knight.member</span><br><span class="line">BLACK KNIGHT (losed an arm)</span><br><span class="line">-- ‘Tis but a scratch.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> knight.member</span><br><span class="line">BLACK KNIGHT (losed another arm)</span><br><span class="line">-- It’s just a flesh wound.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> knight.member</span><br><span class="line">BLACK KNIGHT (losed a leg)</span><br><span class="line">-- I‘m invincible!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> knight.member</span><br><span class="line">BLACK KNIGHT (losed another leg)</span><br><span class="line">-- All right, we’ll call it a draw.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> knight.member</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"blackknight.py"</span>, line <span class="number">19</span>, <span class="keyword">in</span> member</span><br><span class="line">    print(text.format(self.members.pop(<span class="number">0</span>), self.phrases.pop(<span class="number">0</span>)))</span><br><span class="line">IndexError: pop <span class="keyword">from</span> empty list</span><br></pre></td></tr></table></figure><p>如果不使用装饰器的经典调用语法，可以在property中设值fdel函数。如果不使用特性，还可以实现低层特殊的<code>__delattr__</code>方法处理删除属性操作。</p><h1 id="处理属性的重要属性和函数">处理属性的重要属性和函数</h1><h2 id="影响属性处理方式的特殊属性">影响属性处理方式的特殊属性</h2><p><code>__class__</code>：对象所属类的引用（即<code>obj.__class__</code>与<code>type(obj)</code>的作用相同）。</p><p><code>__dict__</code>：一个映射，存储对象或类的可写属性。有<code>__dict__</code>属性的对象，任何时候都能随意设置新属性。如果类有<code>__slots__</code>属性，它的实例可能没有<code>__dict__</code>属性。</p><p><code>__slots__</code>：类可以定义这个属性，限制实例能有哪些属性。<code>__slots__</code>属性的值是一个字符串构成的元组，指明允许有的属性。如果<code>__slots__</code>中没有<code>__dict__</code>，那么该类的实例没有<code>__dict__</code>属性，实例只允许有指定名称的属性。（<code>__slots__</code>属性的值虽然可以是一个列表，但是最好始终使用元组，因为处理完类的定义体之后再修改<code>__slots__</code>列表没有任何作用，所以使用可变的序列容易让人误解）</p><h2 id="处理属性的内置函数">处理属性的内置函数</h2><p>下述5个内置函数对对象的属性做读、写和内省操作。</p><ul><li><code>dir([object])</code>：列出对象的大多数属性。dir函数的目的是交互式使用，因此没有提供完整的属性列表，只列出一组“重要的”属性名。dir函数能审查有或没有<code>__dict__</code>属性的对象。dir函数不会列出<code>__dict__</code>属性本身，但会列出其中的键。dir函数也不会列出类的几个特殊属性，例如<code>__mro__</code>、<code>__bases__</code>和<code>__name__</code>。如果没有指定可选的object参数，dir函数会列出当前作用域中的名称。</li><li><code>getattr(object, name[, default])</code>：从object对象中获取name字符串对应的属性。获取的属性可能来自对象所属的类或超类。如果没有指定的属性，getattr函数抛出AttributeError异常，或者返回default参数的值。</li><li><code>hasattr(object, name)</code>：如果object对象中存在指定的属性，或者能以某种方式（例如继承）通过object对象获取指定的属性，返回True。这个函数的实现方式是调用getattr(object, name)函数，看看是否抛出AttributeError异常。</li><li><code>setattr(object, name, value)</code>：把object对象指定属性的值设为value，前提是object对象能接受那个值。这个函数可能会创建一个新属性，或覆盖现有属性。</li><li><code>vars([object])</code>：返回object对象的<code>__dict__</code>属性；如果实例所属的类定义了<code>__slots__</code>属性，实例没有<code>__dict__</code>属性，那么vars函数不能处理那个实例（相反，dir函数能处理这样的实例）。如果没有指定参数，那么vars函数的作用与locals函数一样：返回表示本地作用域的字典。</li></ul><h2 id="处理属性的特殊方法">处理属性的特殊方法</h2><p>在用户自已定义的类中，下述特殊方法用于获取、设置、删除和列出属性。</p><p>使用点号或内置的getattr、hasattr和setattr函数存取属性都会触发下述列表中相应的特殊方法。但是，直接通过实例的<code>__dict__</code>属性读写属性不会触发这些特殊方法——如果需要，通常会使用这种方式跳过特殊方法。</p><p><strong>对用户自己定义的类来说，如果隐式调用特殊方法，仅当特殊方法在对象所属的类型上定义，而不是在对象的实例字典中定义时，才能确保调用成功。也就是说，要假定特殊方法从类上获取，即便操作目标是实例也是如此。因此，特殊方法不会被同名实例属性遮盖。</strong></p><ul><li><code>__delattr__(self, name)</code>：只要使用del语句删除属性，就会调用这个方法。例如,del obj.attr语句触发<code>Class.__delattr__(obj, 'attr')</code>方法。</li><li><code>__dir__(self)</code>：把对象传给dir函数时调用，列出属性。例如，dir(obj)触发<code>Class.__dir__(obj)</code>方法。</li><li><code>__getattr__(self, name)</code>：仅当获取指定的属性失败，搜索过obj、Class和超类之后调用。</li><li><code>__getattribute__(self, name)</code>：尝试获取指定的属性时总会调用这个方法。不过，寻找的属性是特殊属性或特殊方法时除外。点号与getattr和hasattr内置函数会触发这个方法。调用<code>__getattribute__</code>方法且抛出AttributeError异常时，才会调用<code>__getattr__</code>方法。为了在获取obj实例的属性时不导致无限递归，<code>__getattribute__</code>方法的实现要使用<code>super().__getattribute__(obj, name)</code>。</li><li><code>__setattr__(self, name, value)</code>：尝试设置指定的属性时总会调用这个方法。点号和setattr内置函数会触发这个方法。例如，obj.attr和getattr(obj, 'attr', 42)都会触发<code>Class.__setattr__(obj, 'attr', 42)</code>方法。</li></ul><p><strong>特殊方法<code>__getattribute__</code>和<code>__setattr__</code>不管怎样都会调用，几乎会影响每一次属性存取，因此比<code>__getattr__</code>方法（只处理不存在的属性名）更难正确使用。与定义这些特殊方法相比，使用特性或描述符相对不易出错。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> decorators </tag>
            
            <tag> Fluent Python </tag>
            
            <tag> property </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用动态属性转换数据</title>
      <link href="/notes/fluent-python/data-wrangling-with-dynamic-attributes/"/>
      <url>/notes/fluent-python/data-wrangling-with-dynamic-attributes/</url>
      
        <content type="html"><![CDATA[<p>在Python中，数据的属性和处理数据的方法统称属性（attribute）。其实，方式只是可调用的属性。除了这二者之外，我们还可以创建特性（property），在不改变接口的前提下，使用存取方法（即读值方法和设值方法）修改数据属性。这与统一访问原则相符：不管服务是由存储还是计算实现的，一个模块提供的所有服务都应该通过统一的方式使用。</p><p>除了特性，Python还提供了丰富的API，用于控制属性的访问权限，以及实现动态属性。使用点号访问属性时（如obj.attr），Python解释器会调用特殊的方法（如<code>__getattr__</code>和<code>__setattr__</code>）计算属性。用户自己定义的类可以通过<code>__getattr__</code>方法实现“虚拟属性”，当访问不存在的属性时，即时计算属性的值。</p><p>动态创建属性是一种元编程，框架的作者经常这么做。然而，在Python中，相关的基础技术十分简单，任何人都可以使用，甚至在日常的数据转换任务中也能用到。下面以这种任务开启本章的话题。</p><a id="more"></a><h1 id="使用动态属性转换数据">使用动态属性转换数据</h1><figure class="highlight json"><figcaption><span>osconfeed.json</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">"Schedule"</span>:</span><br><span class="line">  &#123; <span class="attr">"conferences"</span>: [&#123;<span class="attr">"serial"</span>: <span class="number">115</span> &#125;],</span><br><span class="line">    <span class="attr">"events"</span>: [</span><br><span class="line">      &#123; <span class="attr">"serial"</span>: <span class="number">34505</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Why Schools Don ́t Use Open Source to Teach Programming"</span>,</span><br><span class="line">        <span class="attr">"event_type"</span>: <span class="string">"40-minute conference session"</span>,</span><br><span class="line">        <span class="attr">"time_start"</span>: <span class="string">"2014-07-23 11:30:00"</span>,</span><br><span class="line">        <span class="attr">"time_stop"</span>: <span class="string">"2014-07-23 12:10:00"</span>,</span><br><span class="line">        <span class="attr">"venue_serial"</span>: <span class="number">1462</span>,</span><br><span class="line">        <span class="attr">"description"</span>: <span class="string">"Aside from the fact that high school programming..."</span>,</span><br><span class="line">        <span class="attr">"website_url"</span>: <span class="string">"http://oscon.com/oscon2014/public/schedule/detail/34505"</span>,</span><br><span class="line">        <span class="attr">"speakers"</span>: [<span class="number">157509</span>],</span><br><span class="line">        <span class="attr">"categories"</span>: [<span class="string">"Education"</span>] &#125;,</span><br><span class="line">      &#123; <span class="attr">"更多条记录"</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"speakers"</span>: [</span><br><span class="line">      &#123; <span class="attr">"serial"</span>: <span class="number">157509</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Robert Lefkowitz"</span>,</span><br><span class="line">        <span class="attr">"photo"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"url"</span>: <span class="string">"http://sharewave.com/"</span>,</span><br><span class="line">        <span class="attr">"position"</span>: <span class="string">"CTO"</span>,</span><br><span class="line">        <span class="attr">"affiliation"</span>: <span class="string">"Sharewave"</span>,</span><br><span class="line">        <span class="attr">"twitter"</span>: <span class="string">"sharewaveteam"</span>,</span><br><span class="line">        <span class="attr">"bio"</span>: <span class="string">"Robert  ́r0ml ́ Lefkowitz is the CTO at Sharewave, a startup..."</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">"更多条记录"</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"venues"</span>: [</span><br><span class="line">      &#123; <span class="attr">"serial"</span>: <span class="number">1462</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"F151"</span>,</span><br><span class="line">        <span class="attr">"category"</span>: <span class="string">"Conference Venues"</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">"更多条记录"</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>osconfeed.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">URL = <span class="string">'http://www.oreilly.com/pub/sc/osconfeed'</span></span><br><span class="line">JSON = <span class="string">'data/osconfeed.json'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(JSON):  <span class="comment"># 如果文件不存在就去下载</span></span><br><span class="line">        msg = <span class="string">'downloading &#123;&#125; to &#123;&#125;'</span>.format(URL, JSON)</span><br><span class="line">        warnings.warn(msg)  <span class="comment"># 发出警告</span></span><br><span class="line">        <span class="comment"># 在with语句中使用两个上下文管理器</span></span><br><span class="line">        <span class="keyword">with</span> urlopen(URL) <span class="keyword">as</span> remote, open(JSON, <span class="string">'wb'</span>) <span class="keyword">as</span> local:</span><br><span class="line">            local.write(remote.read())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(JSON) <span class="keyword">as</span> fp:</span><br><span class="line">        <span class="keyword">return</span> json.load(fp)  <span class="comment"># 返回Python原生对象</span></span><br></pre></td></tr></table></figure><h1 id="使用动态属性访问json类数据">使用动态属性访问JSON类数据</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> osconfeed <span class="keyword">import</span> load</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>feed = load()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(feed[<span class="string">'Schedule'</span>].keys())  <span class="comment"># feed是一个字典，里面嵌套这字典和列表</span></span><br><span class="line">[<span class="string">'conferences'</span>, <span class="string">'events'</span>, <span class="string">'speakers'</span>, <span class="string">'venues'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key, value <span class="keyword">in</span> sorted(feed[<span class="string">'Schedule'</span>].items()):</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'&#123;:3&#125; &#123;&#125;'</span>.format(len(value), key))</span><br><span class="line">...</span><br><span class="line">  <span class="number">1</span> conferences</span><br><span class="line"><span class="number">494</span> events</span><br><span class="line"><span class="number">357</span> speakers</span><br><span class="line"> <span class="number">53</span> venues</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>feed[<span class="string">'Schedule'</span>][<span class="string">'speakers'</span>][<span class="number">-1</span>][<span class="string">'name'</span>]  <span class="comment"># 最后一位演讲者的名字</span></span><br><span class="line"><span class="string">'Carina C. Zona'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>feed[<span class="string">'Schedule'</span>][<span class="string">'speakers'</span>][<span class="number">-1</span>][<span class="string">'serial'</span>]  <span class="comment"># 最后一位演讲者的编号</span></span><br><span class="line"><span class="number">141590</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>feed[<span class="string">'Schedule'</span>][<span class="string">'events'</span>][<span class="number">40</span>][<span class="string">'name'</span>]  <span class="comment"># 事件名称</span></span><br><span class="line"><span class="string">'There *Will* Be Bugs'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>feed[<span class="string">'Schedule'</span>][<span class="string">'events'</span>][<span class="number">40</span>][<span class="string">'speakers'</span>]  <span class="comment"># 事件的演讲者列表</span></span><br><span class="line">[<span class="number">3471</span>, <span class="number">5199</span>]</span><br></pre></td></tr></table></figure><h2 id="使用动态属性访问json类数据-1">使用动态属性访问JSON类数据</h2><p>feed['Schedule']['events'][40]['name']这种句法很冗长。在JavaScript中，可以使用feed.Schedule.events[40].name获取那个值。在Python中，可以实现一个近似字典的类（网上有大量实现，最常提到的一个实现是<a href="https://pypi.python.org/pypi/attrdict" target="_blank" rel="noopener">AttrDict</a>，还有一个实现能快速创建嵌套的映射——<a href="https://pypi.python.org/pypi/addict" target="_blank" rel="noopener">addict</a>），达到同样的效果。</p><figure class="highlight python"><figcaption><span>explore0.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrozenJSON</span>:</span></span><br><span class="line">    <span class="string">"""一个只读接口，使用属性表示法访问JSON类对象</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, mapping)</span>:</span></span><br><span class="line">        self.__data = dict(mapping)  <span class="comment"># 使用mapping创建一个字典副本</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(self.__data, name):  <span class="comment"># name是__data的属性</span></span><br><span class="line">            <span class="keyword">return</span> getattr(self.__data, name)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 从__data中获取name键对应的元素</span></span><br><span class="line">            <span class="keyword">try</span>:  <span class="comment"># 捕获异常的姿势可能不正确</span></span><br><span class="line">                <span class="keyword">return</span> FrozenJSON.build(self.__data[name])</span><br><span class="line">            <span class="keyword">except</span> KeyError:  <span class="comment"># 可能出现KeyError异常</span></span><br><span class="line">                msg = <span class="string">'&#123;!r&#125; object has no attribute &#123;!r&#125;'</span></span><br><span class="line">                <span class="comment"># 属性访问应该抛出AttributeError</span></span><br><span class="line">                <span class="keyword">raise</span> AttributeError(msg.format(type(self).__name__, name))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(cls, obj)</span>:</span>  <span class="comment"># 备选构造方法</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(obj, abc.Mapping):  <span class="comment"># 是映射</span></span><br><span class="line">            <span class="keyword">return</span> cls(obj)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(obj, abc.MutableSequence):  <span class="comment"># 是列表</span></span><br><span class="line">            <span class="keyword">return</span> [cls.build(item) <span class="keyword">for</span> item <span class="keyword">in</span> obj]</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 其他</span></span><br><span class="line">            <span class="keyword">return</span> obj</span><br></pre></td></tr></table></figure><p>我们要记住重要的一点，<strong>仅当无法使用常规的方式获取属性（即在实例、类或超类中找不到指定的属性），解释器才会调用特殊的<code>__getattr__</code>方法。</strong>这个方法首先查看<code>self.__data</code>字典有没有指定名称的属性（不是键），这样FrozenJSON实例便可以处理字典的所有方法，例如把items方法委托给<code>self.__data.items</code>方法。如果<code>self.__data</code>没有指定名称的属性，那么<code>__getattr__</code>方法以那个名称为键，从<code>self.__data</code>中获取一个元素，传给FrozenJSON.build方法。这样就能深入JSON数据的嵌套结构，使用类方法build把每一层嵌套转换成一个FrozenJSON实例。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> osconfeed <span class="keyword">import</span> load</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> explore0 <span class="keyword">import</span> FrozenJSON</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>raw_feed = load()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>feed = FrozenJSON(raw_feed)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(feed.Schedule.speakers)</span><br><span class="line"><span class="number">357</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(feed.Schedule.keys())</span><br><span class="line">[<span class="string">'conferences'</span>, <span class="string">'events'</span>, <span class="string">'speakers'</span>, <span class="string">'venues'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>talk = feed.Schedule.events[<span class="number">40</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(talk)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">explore0</span>.<span class="title">FrozenJSON</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">talk</span>.<span class="title">name</span></span></span><br><span class="line"><span class="class">'<span class="title">There</span> *<span class="title">Will</span>* <span class="title">Be</span> <span class="title">Bugs</span>'</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">talk</span>.<span class="title">flavor</span></span></span><br><span class="line"><span class="class"><span class="title">Traceback</span> <span class="params">(most recent call last)</span>:</span></span><br><span class="line">  File <span class="string">"/Users/cws/Desktop/explore0.py"</span>, line <span class="number">15</span>, <span class="keyword">in</span> __getattr__</span><br><span class="line">    <span class="keyword">return</span> FrozenJSON.build(self.__data[name])</span><br><span class="line">KeyError: <span class="string">'flavor'</span>  <span class="comment"># 这个也出来了？</span></span><br><span class="line"></span><br><span class="line">During handling of the above exception, another exception occurred:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"/Users/cws/Desktop/explore0.py"</span>, line <span class="number">19</span>, <span class="keyword">in</span> __getattr__</span><br><span class="line">    <span class="keyword">raise</span> AttributeError(msg.format(type(self).__name__, name))</span><br><span class="line">AttributeError: <span class="string">'FrozenJSON'</span> object has no attribute <span class="string">'flavor'</span></span><br></pre></td></tr></table></figure><p>注意，我们没有缓存或转换原始数据源。在迭代数据源的过程中，嵌套的数据结构不断被转换成FrozenJSON对象。这么做没问题，因为数据集不大，而且这个脚本只用于访问或转换数据。</p><p>从随机源中生成或仿效动态属性名的脚本都必须处理一个问题：原始数据中的键可能不适合作为属性名。</p><h2 id="处理无效属性名">处理无效属性名</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>grad = FrozenJSON(&#123;<span class="string">'name'</span>: <span class="string">'Jim Bo'</span>, <span class="string">'class'</span>: <span class="number">1982</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grad.<span class="keyword">class</span>  <span class="comment"># 无法读取，因为在Python中class是保留字</span></span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    grad.<span class="keyword">class</span></span><br><span class="line">             ^</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(grad, <span class="string">'class'</span>)  <span class="comment"># 可以这么做，但是不够便利</span></span><br><span class="line"><span class="number">1982</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>explore1.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword  <span class="comment"># 检查关键字</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># FrozenJSON类中修改</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, mapping)</span>:</span></span><br><span class="line">        self.__data = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> mapping.items():  <span class="comment"># 检查每个键名</span></span><br><span class="line">            <span class="keyword">if</span> keyword.iskeyword(key):  <span class="comment"># 在关键字的属性后面加_</span></span><br><span class="line">                key += <span class="string">'_'</span></span><br><span class="line">            self.__data[key] = value</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> osconfeed <span class="keyword">import</span> load</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grad = FrozenJSON(&#123;<span class="string">'name'</span>: <span class="string">'Jim Bo'</span>, <span class="string">'class'</span>: <span class="number">1982</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grad.class_  <span class="comment"># 这样访问</span></span><br></pre></td></tr></table></figure><p>如果JSON对象中的键不是有效的Python标识符，也会遇到类似的问题：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = FrozenJSON(&#123;<span class="string">'2be'</span>:<span class="string">'or not'</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x<span class="number">.2</span>be</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    x<span class="number">.2</span>be</span><br><span class="line">      ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><p>这种有问题的键在Python3中易于检测，因为str类提供的isidentifier方法能根据语言的语法判断s是否为有效的Python标识符。但是，把无效的标识符变成有效的属性名却不容易。对此，有两个简单的解决方法，一个是抛出异常，另一个是把无效的键换成通用名称，例如attr_0、attr_1，等等。</p><p>类方法build把嵌套结构转换成FrozenJSON实例或FrozenJSON实例列表，因为<code>__getattr__</code>方法使用这个方法访问属性时，能为不同的值返回不同类型的对象。除了在类方法中实现这样的逻辑之外，还可以在特殊的<code>__new__</code>方法中实现。</p><h2 id="使用__new__方法以灵活的方式创建对象">使用<code>__new__</code>方法以灵活的方式创建对象</h2><p>我们通常把<code>__init__</code>称为构造方法，这是从其他语言借鉴过来的术语。其实，用于构建实例的是特殊方法<code>__new__</code>：这是个类方法（使用特殊方式处理，因此不必使用@classmethod装饰器），必须返回一个实例。返回的实例会作为第一个参数（即self）传给<code>__init__</code>方法。因为调用<code>__init__</code>方法时要传入实例，而且禁止返回任何值，所以<code>__init__</code>方法其实是“初始化方法”。真正的构造方法是<code>__new__</code>。我们几乎不需要自己编写<code>__new__</code>方法，因为从object类继承的实现已经足够了。</p><p>从<code>__new__</code>方法到<code>__init__</code>方法，是最常见的，但不是唯一的。<code>__new__</code>方法也可以返回其他类的实例，此时，解释器不会调用<code>__init__</code>方法。</p><p>也就是说，Python构建对象的过程可以使用下述伪代码概括：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构建对象的伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object_maker</span><span class="params">(the_class, some_arg)</span>:</span></span><br><span class="line">    new_object = the_class.__new__(some_arg)</span><br><span class="line">    <span class="keyword">if</span> isinstance(new_object, the_class):</span><br><span class="line">        the_class.__init__(new_object, some_arg)</span><br><span class="line">    <span class="keyword">return</span> new_object</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下述两个语句的作用基本等效</span></span><br><span class="line">x = Foo(<span class="string">'bar'</span>)</span><br><span class="line">x = object_maker(Foo, <span class="string">'bar'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>explore2.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrozenJSON</span>:</span></span><br><span class="line">    <span class="string">"""一个只读接口，使用属性表示法访问JSON类对象</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, arg)</span>:</span>  <span class="comment"># 第一个参数是类本身</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(arg, abc.Mapping):</span><br><span class="line">            <span class="keyword">return</span> super().__new__(cls)  <span class="comment"># 默认的行为</span></span><br><span class="line">        <span class="keyword">elif</span> isinstance(arg, abc.MutableSequence):</span><br><span class="line">            <span class="keyword">return</span> [cls(item) <span class="keyword">for</span> item <span class="keyword">in</span> arg]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> arg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, mapping)</span>:</span></span><br><span class="line">        self.__data = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> mapping.items():</span><br><span class="line">            <span class="keyword">if</span> iskeyword(key):</span><br><span class="line">                key += <span class="string">'_'</span></span><br><span class="line">            self.__data[key] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(self.__data, name):</span><br><span class="line">            <span class="keyword">return</span> getattr(self.__data, name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> FrozenJSON(self.__data[name])  <span class="comment"># 直接调用构造方法</span></span><br></pre></td></tr></table></figure><p><code>__new__</code>方法的第一个参数是类，因为创建的对象通常是那个类的实例。所以，在<code>FrozenJSON.__new__</code>方法中，<code>super().__new__(cls)</code>表达式会调用<code>object.__new__(FrozenJSON)</code>，而object类构建的实例其实是FrozenJSON实例，即那个实例的<code>__class__</code>属性存储的是FrozenJSON类的引用。不过，真正的构建操作由解释器调用C语言实现的<code>object.__new__</code>方法执行。</p><p>OSCON的JSON数据源有一个明显的缺点：索引为40的事件，即名为'There *Will* Be Bugs'的那个，有两位演讲者，3471和5199，但却不容易找到他们，因为提供的是编号，而 Schedule.speakers列表没有使用编号建立索引。此外，每条事件记录中都有venue_serial字段，存储的值也是编号，但是如果想找到对应的记录，那就要线性搜索Schedule.venues列表。接下来的任务是，调整数据结构，以便自动获取所链接的记录。</p><h2 id="使用shelve模块调整oscon数据源的结构">使用shelve模块调整OSCON数据源的结构</h2><p>标准库中有个<a href="https://devdocs.io/python~3.6/library/shelve" target="_blank" rel="noopener">shelve</a>（架子）模块，shelve模块提供了pickle（泡菜，Python对象序列化格式的名字）存储方式。</p><p><a href="https://devdocs.io/python~3.6/library/shelve#shelve.open" target="_blank" rel="noopener">shelve.open</a>高阶函数返回一个shelve.Shelf实例，这是简单的键值对象数据库，背后由<a href="https://devdocs.io/python~3.6/library/dbm" target="_blank" rel="noopener">dbm</a>模块支持，具有下述特点：</p><ul><li>shelve.Shelf是abc.MutableMapping的子类，因此提供了处理映射类型的重要方法。</li><li>此外，shelve.Shelf类还提供了几个管理I/O的方法，如sync和close；它也是一个上下文管理器。</li><li>只要把新值赋予键，就会保存键和值。</li><li>键必须是字符串。</li><li>值必须是pickle模块能处理的对象。</li></ul><p>shelve模块为识别OSCON的日程数据提供了一种简单有效的方式。我们将从JSON文件中读取所有记录，将其存在一个shelve.Shelf对象中，键由记录类型和编号组成（例如，'event.33950'或'speaker.3471'），而值是我们即将定义的Record类的实例。</p><figure class="highlight python"><figcaption><span>schedule1.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> osconfeed</span><br><span class="line"></span><br><span class="line">DB_NAME = <span class="string">'data/schedule1_db'</span></span><br><span class="line">CONFERENCE = <span class="string">'conference.115'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Record</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        self.__dict__.update(kwargs)  <span class="comment"># 更新实例的__dict__属性</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_db</span><span class="params">(db)</span>:</span></span><br><span class="line">    raw_data = osconfeed.load()  <span class="comment"># 加载数据</span></span><br><span class="line">    warnings.warn(<span class="string">'loading '</span> + DB_NAME)</span><br><span class="line">    <span class="keyword">for</span> collection, rec_list <span class="keyword">in</span> raw_data[<span class="string">'Schedule'</span>].items():</span><br><span class="line">        record_type = collection[:<span class="number">-1</span>]  <span class="comment"># 去掉尾部's'后的集合名，例如event</span></span><br><span class="line">        <span class="keyword">for</span> record <span class="keyword">in</span> rec_list:</span><br><span class="line">            key = <span class="string">'&#123;&#125;.&#123;&#125;'</span>.format(record_type, record[<span class="string">'serial'</span>])</span><br><span class="line">            record[<span class="string">'serial'</span>] = key  <span class="comment"># 把serial的值设置为完整的键：type.serial</span></span><br><span class="line">            db[key] = Record(**record)  <span class="comment"># 在数据库中存储Record实例</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python -i schedule1.py  <span class="comment"># 启动加载了schedule1模块的控制台</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> shelve</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db = shelve.open(DB_NAME)  <span class="comment"># 打开数据库，或者新建一个</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> CONFERENCE <span class="keyword">not</span> <span class="keyword">in</span> db:  <span class="comment"># 判断数据库是否填充</span></span><br><span class="line"><span class="meta">... </span>    load_db(db)  <span class="comment"># 加载数据库</span></span><br><span class="line">...</span><br><span class="line">schedule1.py:<span class="number">14</span>: UserWarning: loading data/schedule1_db</span><br><span class="line">  warnings.warn(<span class="string">'loading '</span> + DB_NAME)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>speaker = db[<span class="string">'speaker.3471'</span>]  <span class="comment"># 一条speaker记录</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(speaker)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Record</span>'&gt;</span></span><br><span class="line">&gt;&gt;&gt; speaker.name, speaker.twitter  # 在某些应用中，Record类可能要处理不能作为属性名使用的键</span><br><span class="line">(<span class="string">'Anna Ravenscroft'</span>, <span class="string">'annaraven'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db.close()  <span class="comment"># 关闭Shelf对象。如果可以，使用with块确保Shelf对象会关闭</span></span><br></pre></td></tr></table></figure><p>FrozenJSON类要递归转换嵌套的映射和列表；而Record类不需要这么做，因为转换好的数据集中没有嵌套的映射和列表，记录中只有字符串、整数、字符串列表和整数列表。FrozenJSON类要访问内嵌的<code>__data</code>（值是字典）属性，而现在我们不需要这么做了（因为<code>self.__dict__.update(kwargs)</code>已经将传入的键值对保存到实例属性中了）。</p><p>Python标准库中至少有两个与Record类似的类，其实例可以有任意个属性，由传给构造方法的关键字参数构建——<a href="https://devdocs.io/python~3.6/library/multiprocessing#multiprocessing.managers.Namespace" target="_blank" rel="noopener">multiprocessing.managers.Namespace</a>类和<a href="https://devdocs.io/python~3.6/library/argparse#argparse.Namespace" target="_blank" rel="noopener">argparse.Namespace</a>类。之所以自己实现Record，是为了说明一个重要的做法：在<code>__init__</code>方法中更新实例的<code>__dict__</code>属性。</p><h2 id="使用特性获取链接的记录">使用特性获取链接的记录</h2><p>我们可以扩展Record类，让它提供一个有用的服务：自动获取event记录引用的venue和speaker记录，而不是编号。</p><img src="http://www.plantuml.com/plantuml/svg/TOzH3i8W44J_UugzW3VmKo_W1KWBeoLAmMKrQR1t5ojfBAdxHTumkpEzDI2u82Cvk0xSw5iR8vsWFHjA3UL93j9xCv5ITh2YL4rnpsmgraEtDaTfnUhypNHhtw94o7_niY6U8RgdDDyhh8x42FmJwlZ482LHVZv0AR0FO1c_rXZGNi6nvbihIx_zQxUKRPRM7pfVUmC0"><p>Record：<code>__init__</code>方法不变；为了辅助测试，增加了<code>__eq__</code>方法。</p><p>DbRecord：Record类的子类，添加了<code>__db</code>类属性，用于设置和获取<code>__db</code>属性的set_db和get_db静态方法，用于从数据库中获取记录的fetch类方法，以及辅助调试和测试的<code>__repr__</code>实例方法。</p><p>Event：DbRecord类的子类，添加了用于获取所链接记录的venue和speakers属性，以及特殊的<code>__repr__</code>方法。</p><figure class="highlight python"><figcaption><span>schedule2.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> osconfeed</span><br><span class="line"></span><br><span class="line">DB_NAME = <span class="string">'data/schedule2_db'</span></span><br><span class="line">CONFERENCE = <span class="string">'conference.115'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Record</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        self.__dict__.update(kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(other, Record):</span><br><span class="line">            <span class="keyword">return</span> self.__dict__ == other.__dict__</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MissingDatabaseError</span><span class="params">(RuntimeError)</span>:</span>  <span class="comment"># 自定义的异常通常是标志类</span></span><br><span class="line">    <span class="string">"""需要数据库但没有指定数据库时抛出"""</span>   <span class="comment"># 没有定义体，写一个文档字符串</span></span><br><span class="line">                                        <span class="comment"># 说明异常的用途，比pass语句要好</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DbRecord</span><span class="params">(Record)</span>:</span>  <span class="comment"># 扩展Record类</span></span><br><span class="line"></span><br><span class="line">    __db = <span class="literal">None</span>  <span class="comment"># 存储一个打开的Shelf数据库引用</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod  # 静态方法，以此强调不管调用多少次</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_db</span><span class="params">(db)</span>:</span>  <span class="comment"># 效果始终一样</span></span><br><span class="line">        DbRecord.__db = db</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_db</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> DbRecord.__db</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod  # 类方法，在子类中易于定制它的行为</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(cls, ident)</span>:</span></span><br><span class="line">        db = cls.get_db()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> db[ident]  <span class="comment"># 从数据库中获取</span></span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="keyword">if</span> db <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 数据库为空时，抛出自定义异常</span></span><br><span class="line">                msg = <span class="string">"database not set; call '&#123;&#125;.set_db(my_db)'"</span></span><br><span class="line">                <span class="keyword">raise</span> MissingDatabseError(msg.format(cls.__name__))</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 否则重新抛出TypeError，因为我们不知道怎么处理</span></span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(self, <span class="string">'serial'</span>):</span><br><span class="line">            cls_name = self.__class__.__name__</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'&lt;&#123;&#125; serial=&#123;!r&#125;&gt;'</span>.format(cls_name, self.serial)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 调用继承的方法</span></span><br><span class="line">            <span class="keyword">return</span> super().__repr__()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span><span class="params">(DbRecord)</span>:</span>  <span class="comment"># 扩展DbRecord类</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">venue</span><span class="params">(self)</span>:</span>  <span class="comment"># venue特性</span></span><br><span class="line">        key = <span class="string">'venue.&#123;&#125;'</span>.format(self.venue_serial)</span><br><span class="line">        <span class="keyword">return</span> self.__class__.fetch(key)  <span class="comment"># 不直接使用self.fetch(key)</span></span><br><span class="line">        <span class="comment"># 对这个OSCON数据源来说，可以使用后者，因为事件记录都没有'fetch'键</span></span><br><span class="line">        <span class="comment"># 哪怕只有一个事件记录有名为'fetch'的键，那么在那个Event实例中</span></span><br><span class="line">        <span class="comment"># self.fetch获取的是fetch字段的值，而不是继承自DbRecord的fetch类方法</span></span><br><span class="line">        <span class="comment"># 这个缺陷不明显，很容易被测试忽略</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speakers</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">'_speaker_objs'</span>):</span><br><span class="line">            <span class="comment"># 从__dict__实例属性中获取</span></span><br><span class="line">            <span class="comment"># self.speakers会出现无限递归，因为特性的公开名称也是speakers</span></span><br><span class="line">            spkr_serials = self.__dict__[<span class="string">'speakers'</span>]</span><br><span class="line">            fetch = self.__class__.fetch  <span class="comment"># 获取类方法的引用</span></span><br><span class="line">            self._speaker_objs = [fetch(<span class="string">'speaker.&#123;&#125;'</span>.format(key))</span><br><span class="line">                                  <span class="keyword">for</span> key <span class="keyword">in</span> spkr_serials]</span><br><span class="line">        <span class="keyword">return</span> self._speaker_objs</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(self, <span class="string">'name'</span>):</span><br><span class="line">            cls_name = self.__class__.__name__</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'&lt;&#123;&#125; &#123;!r&#125;&gt;'</span>.format(cls_name, self.name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> super().__repr__()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_db</span><span class="params">(db)</span>:</span></span><br><span class="line">    raw_data = osconfeed.load()</span><br><span class="line">    warnings.warn(<span class="string">'loading '</span> + DB_NAME)</span><br><span class="line">    <span class="keyword">for</span> collection, rec_list <span class="keyword">in</span> raw_data[<span class="string">'Schedule'</span>].items():</span><br><span class="line">        record_type = collection[:<span class="number">-1</span>]</span><br><span class="line">        cls_name = record_type.capitalize()  <span class="comment"># 首字母大写，例如Event</span></span><br><span class="line">        <span class="comment"># 从模块的全局作用域中获取对应的对象，默认使用DbRecord</span></span><br><span class="line">        <span class="comment"># 只有事件类型的记录有自定义的类——Event。不过，如果定义了</span></span><br><span class="line">        <span class="comment"># Speaker或Venue类，load_db函数构建和保存记录时会自动使用这两个类</span></span><br><span class="line">        cls = globals().get(cls_name, DbRecord)</span><br><span class="line">        <span class="keyword">if</span> inspect.isclass(cls) <span class="keyword">and</span> issubclass(cls, DbRecord):</span><br><span class="line">            factory = cls</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            factory = DbRecord</span><br><span class="line">        <span class="keyword">for</span> record <span class="keyword">in</span> rec_list:</span><br><span class="line">            key = <span class="string">'&#123;&#125;.&#123;&#125;'</span>.format(record_type, record[<span class="string">'serial'</span>])</span><br><span class="line">            record[<span class="string">'serial'</span>] = key</span><br><span class="line">            db[key] = factory(**record)</span><br></pre></td></tr></table></figure><p><strong>从数据中创建实例属性的名称时有可能会引入缺陷，因为类属性（例如方法）可能被遮盖，或者由于意外覆盖现有的实例属性而丢失数据。这个问题可能是Python字典不能像JavaScript对象那样（obj.key）访问的原因。</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python -i schedule2.py</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> shelve</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db = shelve.open(DB_NAME)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>load_db(db)</span><br><span class="line">schedule2.py:<span class="number">85</span>: UserWarning: loading data/schedule2_db</span><br><span class="line">  warnings.warn(<span class="string">'loading '</span> + DB_NAME)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db[<span class="string">'event.33950'</span>]  <span class="comment"># 现在获取的是记录对象，而不是编号</span></span><br><span class="line">&lt;Event <span class="string">'There *Will* Be Bugs'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>DbRecord.set_db(db)  <span class="comment"># 将数据库放入类中，方便操作</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>event = DbRecord.fetch(<span class="string">'event.33950'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>event.venue  <span class="comment"># 返回记录</span></span><br><span class="line">&lt;DbRecord serial=<span class="string">'venue.1449'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>event.venue.name  <span class="comment"># 找出venue.name更容易了</span></span><br><span class="line"><span class="string">'Portland 251'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> spkr <span class="keyword">in</span> event.speakers:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'&#123;0.serial&#125;: &#123;0.name&#125;'</span>.format(spkr))</span><br><span class="line">...</span><br><span class="line">speaker<span class="number">.3471</span>: Anna Ravenscroft</span><br><span class="line">speaker<span class="number">.5199</span>: Alex Martelli</span><br></pre></td></tr></table></figure><p>特性经常用于把公开的属性变成使用读值方法和设值方法管理的属性，且在不影响代码的前提下实施业务规则。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> attribute </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>让pyplot支持汉字</title>
      <link href="/programming/support-chinese-character-in-pyplot/"/>
      <url>/programming/support-chinese-character-in-pyplot/</url>
      
        <content type="html"><![CDATA[<p><a href="https://devdocs.io/matplotlib~3.1/font_manager_api#matplotlib.font_manager.FontProperties" target="_blank" rel="noopener"><code>class matplotlib.font_manager.FontProperties(family=None, style=None, variant=None, weight=None, stretch=None, size=None, fname=None)</code></a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib.font_manager <span class="keyword">import</span> FontProperties</span><br><span class="line"></span><br><span class="line">font = FontProperties(fname=<span class="string">'/System/Library/Fonts/PingFang.ttc'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># in most functions, key is fontproperties (see valid kwargs in pyplot)</span></span><br><span class="line">plt.text(<span class="number">0</span>, <span class="number">0</span>, <span class="string">'你好！'</span>, fontproperties=font, ha=<span class="string">'center'</span>)</span><br><span class="line">x = np.linspace(-np.pi, np.pi, <span class="number">201</span>)</span><br><span class="line">plt.plot(x, np.sin(x), label=<span class="string">'sin函数'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'x轴'</span>, fontproperties=font)</span><br><span class="line">plt.ylabel(<span class="string">'y轴'</span>, fontproperties=font)</span><br><span class="line"></span><br><span class="line"><span class="comment"># in legend, key is prop</span></span><br><span class="line">plt.legend(prop=font, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="/uploads/image/support-chinese-character.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pyplot中合法的kwargs关键字</title>
      <link href="/documentation/valid-kwargs-in-pyplot/"/>
      <url>/documentation/valid-kwargs-in-pyplot/</url>
      
        <content type="html"><![CDATA[<p><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text" target="_blank" rel="noopener"><code>class matplotlib.text.Text(x=0, y=0, text='', color=None, verticalalignment='baseline', horizontalalignment='left', multialignment=None, fontproperties=None, rotation=None, linespacing=None, rotation_mode=None, usetex=None, wrap=False, **kwargs)</code></a></p><table><colgroup><col style="width: 28%"><col style="width: 71%"></colgroup><thead><tr class="header"><th style="text-align: left;">Property</th><th style="text-align: left;">Description</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_agg_filter#matplotlib.artist.Artist.set_agg_filter" target="_blank" rel="noopener"><code>agg_filter</code></a></td><td style="text-align: left;">a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_alpha#matplotlib.artist.Artist.set_alpha" target="_blank" rel="noopener"><code>alpha</code></a></td><td style="text-align: left;">float</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_animated#matplotlib.artist.Artist.set_animated" target="_blank" rel="noopener"><code>animated</code></a></td><td style="text-align: left;">bool</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_backgroundcolor" target="_blank" rel="noopener"><code>backgroundcolor</code></a></td><td style="text-align: left;">color</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_bbox" target="_blank" rel="noopener"><code>bbox</code></a></td><td style="text-align: left;">dict with properties for <a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.patches.fancybboxpatch#matplotlib.patches.FancyBboxPatch" target="_blank" rel="noopener"><code>patches.FancyBboxPatch</code></a></td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_clip_box" target="_blank" rel="noopener"><code>clip_box</code></a></td><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/transformations#matplotlib.transforms.Bbox" target="_blank" rel="noopener"><code>Bbox</code></a></td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_clip_on" target="_blank" rel="noopener"><code>clip_on</code></a></td><td style="text-align: left;">bool</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_clip_path" target="_blank" rel="noopener"><code>clip_path</code></a></td><td style="text-align: left;">[(<a href="https://devdocs.io/matplotlib~3.1/path_api#matplotlib.path.Path" target="_blank" rel="noopener"><code>Path</code></a>, <a href="https://devdocs.io/matplotlib~3.1/transformations#matplotlib.transforms.Transform" target="_blank" rel="noopener"><code>Transform</code></a>)</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_color" target="_blank" rel="noopener"><code>color</code></a> or c</td><td style="text-align: left;">color</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_contains#matplotlib.artist.Artist.set_contains" target="_blank" rel="noopener"><code>contains</code></a></td><td style="text-align: left;">callable</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_figure#matplotlib.artist.Artist.set_figure" target="_blank" rel="noopener"><code>figure</code></a></td><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure" target="_blank" rel="noopener"><code>Figure</code></a></td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_fontfamily" target="_blank" rel="noopener"><code>fontfamily</code></a> or family</td><td style="text-align: left;">{FONTNAME, 'serif', 'sans-serif', 'cursive', 'fantasy', 'monospace'}</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_fontproperties" target="_blank" rel="noopener"><code>fontproperties</code></a> or font_properties</td><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/font_manager_api#matplotlib.font_manager.FontProperties" target="_blank" rel="noopener"><code>font_manager.FontProperties</code></a></td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_fontsize" target="_blank" rel="noopener"><code>fontsize</code></a> or size</td><td style="text-align: left;">{size in points, 'xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'}</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_fontstretch" target="_blank" rel="noopener"><code>fontstretch</code></a> or stretch</td><td style="text-align: left;">{a numeric value in range 0-1000, 'ultra-condensed', 'extra-condensed', 'condensed', 'semi-condensed', 'normal', 'semi-expanded', 'expanded', 'extra-expanded', 'ultra-expanded'}</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_fontstyle" target="_blank" rel="noopener"><code>fontstyle</code></a> or style</td><td style="text-align: left;">{'normal', 'italic', 'oblique'}</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_fontvariant" target="_blank" rel="noopener"><code>fontvariant</code></a> or variant</td><td style="text-align: left;">{'normal', 'small-caps'}</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_fontweight" target="_blank" rel="noopener"><code>fontweight</code></a> or weight</td><td style="text-align: left;">{a numeric value in range 0-1000, 'ultralight', 'light', 'normal', 'regular', 'book', 'medium', 'roman', 'semibold', 'demibold', 'demi', 'bold', 'heavy', 'extra bold', 'black'}</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_gid#matplotlib.artist.Artist.set_gid" target="_blank" rel="noopener"><code>gid</code></a></td><td style="text-align: left;">str</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_horizontalalignment" target="_blank" rel="noopener"><code>horizontalalignment</code></a> or ha</td><td style="text-align: left;">{'center', 'right', 'left'}</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_in_layout#matplotlib.artist.Artist.set_in_layout" target="_blank" rel="noopener"><code>in_layout</code></a></td><td style="text-align: left;">bool</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_label#matplotlib.artist.Artist.set_label" target="_blank" rel="noopener"><code>label</code></a></td><td style="text-align: left;">object</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_linespacing" target="_blank" rel="noopener"><code>linespacing</code></a></td><td style="text-align: left;">float (multiple of font size)</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_multialignment" target="_blank" rel="noopener"><code>multialignment</code></a> or ma</td><td style="text-align: left;">{'left', 'right', 'center'}</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_path_effects#matplotlib.artist.Artist.set_path_effects" target="_blank" rel="noopener"><code>path_effects</code></a></td><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/patheffects_api#matplotlib.patheffects.AbstractPathEffect" target="_blank" rel="noopener"><code>AbstractPathEffect</code></a></td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_picker#matplotlib.artist.Artist.set_picker" target="_blank" rel="noopener"><code>picker</code></a></td><td style="text-align: left;">None or bool or float or callable</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_position" target="_blank" rel="noopener"><code>position</code></a></td><td style="text-align: left;">(float, float)</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_rasterized#matplotlib.artist.Artist.set_rasterized" target="_blank" rel="noopener"><code>rasterized</code></a></td><td style="text-align: left;">bool or None</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_rotation" target="_blank" rel="noopener"><code>rotation</code></a></td><td style="text-align: left;">{angle in degrees, 'vertical', 'horizontal'}</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_rotation_mode" target="_blank" rel="noopener"><code>rotation_mode</code></a></td><td style="text-align: left;">{None, 'default', 'anchor'}</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_sketch_params#matplotlib.artist.Artist.set_sketch_params" target="_blank" rel="noopener"><code>sketch_params</code></a></td><td style="text-align: left;">(scale: float, length: float, randomness: float)</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_snap#matplotlib.artist.Artist.set_snap" target="_blank" rel="noopener"><code>snap</code></a></td><td style="text-align: left;">bool or None</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_text" target="_blank" rel="noopener"><code>text</code></a></td><td style="text-align: left;">object</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_transform#matplotlib.artist.Artist.set_transform" target="_blank" rel="noopener"><code>transform</code></a></td><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/transformations#matplotlib.transforms.Transform" target="_blank" rel="noopener"><code>Transform</code></a></td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_url#matplotlib.artist.Artist.set_url" target="_blank" rel="noopener"><code>url</code></a></td><td style="text-align: left;">str</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_usetex" target="_blank" rel="noopener"><code>usetex</code></a></td><td style="text-align: left;">bool or None</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_verticalalignment" target="_blank" rel="noopener"><code>verticalalignment</code></a> or va</td><td style="text-align: left;">{'center', 'top', 'bottom', 'baseline', 'center_baseline'}</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_visible#matplotlib.artist.Artist.set_visible" target="_blank" rel="noopener"><code>visible</code></a></td><td style="text-align: left;">bool</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_wrap" target="_blank" rel="noopener"><code>wrap</code></a></td><td style="text-align: left;">bool</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_x" target="_blank" rel="noopener"><code>x</code></a></td><td style="text-align: left;">float</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_y" target="_blank" rel="noopener"><code>y</code></a></td><td style="text-align: left;">float</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_zorder#matplotlib.artist.Artist.set_zorder" target="_blank" rel="noopener"><code>zorder</code></a></td><td style="text-align: left;">float</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用asyncio包处理并发</title>
      <link href="/notes/fluent-python/concurrency-with-asyncio/"/>
      <url>/notes/fluent-python/concurrency-with-asyncio/</url>
      
        <content type="html"><![CDATA[<blockquote><p>并发（concurrency）是指一次处理多件事，关于结构。并行（parallelism）是指一次做多件事，关于执行。并发用于定制方案，用来解决可能（但未必）并行的问题。</p><p>Rob Pike （Go语言的创造者之一）</p></blockquote><p>真正的并行需要多个核心。现代的笔记本电脑有4个CPU核心，但是通常不经意间就有超过100个进程同时运行。因此，实际上大多数过程都是并发处理的，而不是并行处理。计算机始终运行着100多个进程，确保每个进程都有机会取得进展，不过CPU本身同时做的事情不能超过四件。</p><p>asyncio包使用事件循环驱动的协程实现并发。<em>Guido van Rossum在Python仓库之外开发asyncio包，把这个项目的代号命名为Tulip（郁金香）。Python3.4把Tulip添加到标准库中时，把它重命名为asyncio。</em></p><h1 id="线程与协程对比">线程与协程对比</h1><p>在控制台中显示一个由ASCII字符&quot;|/-&quot;构成的动画旋转指针。一个借由threading模块使用线程实现，一个借由asyncio包使用协程实现。对比两种实现，理解如何不使用线程来实现并发行为。</p><a id="more"></a><h2 id="线程实现">线程实现</h2><p>使用threading模块使用线程实现。</p><figure class="highlight python"><figcaption><span>spinner_thread.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Signal</span>:</span>  <span class="comment"># 定义一个简单的可变对象，用于从外部控制线程</span></span><br><span class="line">    go = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spin</span><span class="params">(msg, signal)</span>:</span>  <span class="comment"># 这个函数会在单独的线程中运行</span></span><br><span class="line">    write, flush = sys.stdout.write, sys.stdout.flush</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> itertools.cycle(<span class="string">'|/-\\'</span>):  <span class="comment"># 无限循环</span></span><br><span class="line">        status = char + <span class="string">' '</span> + msg</span><br><span class="line">        write(status)</span><br><span class="line">        flush()</span><br><span class="line">        write(<span class="string">'\x08'</span> * len(status))  <span class="comment"># 动画的诀窍所在，使用退格符（\x08）把光标移回来</span></span><br><span class="line">        time.sleep(<span class="number">.1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> signal.go:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        write(<span class="string">' '</span> * len(status) + <span class="string">'\x08'</span> * len(status))  <span class="comment"># 使用空格清除状态消息，把光标移回开头</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">slow_function</span><span class="params">()</span>:</span>  <span class="comment"># 假设这是耗时的计算</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)  <span class="comment"># sleep函数会阻塞主线程，不过一定要这么做，以便释放GIL（全局解释器锁）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">supervisor</span><span class="params">()</span>:</span>  <span class="comment"># 这个函数设置从属线程，显示线程对象，运行耗时的计算，最后杀死线程</span></span><br><span class="line">    signal = Signal()</span><br><span class="line">    spinner = threading.Thread(target=spin, args=(<span class="string">'thinking!'</span>, signal))</span><br><span class="line">    print(<span class="string">'spinner object:'</span>, spinner)</span><br><span class="line">    spinner.start()  <span class="comment"># 启动从属线程</span></span><br><span class="line">    result = slow_function()  <span class="comment"># 运行slow_function函数，阻塞主线程。同时，从属线程以动画形式显示旋转指针</span></span><br><span class="line">    signal.go = <span class="literal">False</span>  <span class="comment"># 改变状态，spin函数会终止循环</span></span><br><span class="line">    spinner.join()  <span class="comment"># 等待spinner线程结束</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    result = supervisor()</span><br><span class="line">    print(<span class="string">'Answer:'</span>, result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python spinner_thread.py  # 运行查看动画</span><br><span class="line">spinner object: &lt;Thread(Thread-1, initial)&gt;</span><br><span class="line">Answer: 42!</span><br></pre></td></tr></table></figure><p><strong>Python没有提供终止线程的API，这是有意为之的。若想关闭线程，必须给线程发送消息。</strong>这里，使用的是signal.go属性：在主线程中把它设为False后，spinner线程最终会注意到，然后干净地退出。</p><h2 id="协程实现">协程实现</h2><p>使用@asyncio.coroutine装饰器替代线程，实现相同的行为。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine  # 打算交给asyncio处理的协程建议使用@asyncio.coroutine装饰</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spin</span><span class="params">(msg)</span>:</span>  <span class="comment"># 这里不需要signal参数</span></span><br><span class="line">    write, flush = sys.stdout.write, sys.stdout.flush</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> itertools.cycle(<span class="string">'|/-\\'</span>):</span><br><span class="line">        status = char + <span class="string">' '</span> + msg</span><br><span class="line">        write(status)</span><br><span class="line">        flush()</span><br><span class="line">        write(<span class="string">'\x08'</span> * len(status))</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">.1</span>)  <span class="comment"># 代替time.sleep(.1)，这样的休眠不会阻塞事件循环</span></span><br><span class="line">        <span class="keyword">except</span> asyncio.CancelledError:  <span class="comment"># 若发出了取消请求，会在yield处抛出CancelledError异常</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        write(<span class="string">' '</span> * len(status) + <span class="string">'\x08'</span> * len(status))</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">slow_function</span><span class="params">()</span>:</span>  <span class="comment"># 协程，在用休眠假装进行I/O操作时，使用yield from继续执行事件循环</span></span><br><span class="line">    <span class="comment"># 假装等待I/O一段时间</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">3</span>)  <span class="comment"># 把控制权交给主循环，在休眠结束后恢复这个协程</span></span><br><span class="line">                                 <span class="comment"># 若使用time.sleep(3)，则控制权回不到主循环，</span></span><br><span class="line">                                 <span class="comment"># spinner无法得到运行时间，也就看不到旋转动画和提示消息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">supervisor</span><span class="params">()</span>:</span>  <span class="comment"># 协程，使用yield from驱动slow_function函数</span></span><br><span class="line">    spinner = asyncio.<span class="keyword">async</span>(spin(<span class="string">'thinking!'</span>))  <span class="comment"># async函数排定协程的运行时间，使用一个Task对象包装协程</span></span><br><span class="line">    print(<span class="string">'spinner object:'</span>, spinner)</span><br><span class="line">    result = <span class="keyword">yield</span> <span class="keyword">from</span> slow_function()  <span class="comment"># 驱动slow_function函数。结束后，获取返回值。同时，事件循环继续运行</span></span><br><span class="line">                                         <span class="comment"># 因为slow_function函数最后使用yield from表达式把控制权交回给了主循环</span></span><br><span class="line">                                         <span class="comment"># 若使用result = slow_function()，则同样看不到动画和提示消息</span></span><br><span class="line">    spinner.cancel()  <span class="comment"># Task对象可以取消，取消后会在协程当前暂停的yield处抛出CancelledError异常</span></span><br><span class="line">                      <span class="comment"># 协程可以捕获这个异常，也可以延迟取消，甚至拒绝取消</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    loop = asyncio.get_event_loop()  <span class="comment"># 获取事件循环的引用</span></span><br><span class="line">    result = loop.run_until_complete(supervisor())  <span class="comment"># 驱动supervisor协程， 让它运行完毕</span></span><br><span class="line">    loop.close()</span><br><span class="line">    print(<span class="string">'Answer:'</span>, result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python spinner_asyncio.py  # 运行查看动画</span><br><span class="line">spinner object: &lt;Task pending coro=&lt;spin() running at spinner_asyncio.py:5&gt;&gt;</span><br><span class="line">Answer: 42!</span><br></pre></td></tr></table></figure><p><strong>除非想阻塞主线程，从而冻结事件循环或整个应用，否则不要在asyncio协程中使用time.sleep函数。如果协程需要在一段时间内什么也不做，应该使用yield from asyncio.sleep(DELAY)。</strong></p><p>使用@asyncio.coroutine装饰器不是强制要求，但是强烈建议这么做，因为这样能在一众普通的函数中把协程凸显出来，也有助于调试：如果还没从中产出值，协程就被垃圾回收了（意味着有操作未完成，因此有可能是个缺陷），那就可以发出警告。这个装饰器不会预激协程。</p><p>supervisor函数是这两个示例的核心。下面详细对比二者。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 线程版</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">supervisor</span><span class="params">()</span>:</span></span><br><span class="line">    signal = Signal()</span><br><span class="line">    spinner = threading.Thread(target=spin, args=(<span class="string">'thinking!'</span>, signal))</span><br><span class="line">    print(<span class="string">'spinner object:'</span>, spinner)</span><br><span class="line">    spinner.start()</span><br><span class="line">    result = slow_function()</span><br><span class="line">    signal.go = <span class="literal">False</span></span><br><span class="line">    spinner.join()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 异步版</span></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">supervisor</span><span class="params">()</span>:</span></span><br><span class="line">    spinner = asyncio.<span class="keyword">async</span>(spin(<span class="string">'thinking!'</span>))</span><br><span class="line">    print(<span class="string">'spinner object:'</span>, spinner)</span><br><span class="line">    result = <span class="keyword">yield</span> <span class="keyword">from</span> slow_function()</span><br><span class="line">    spinner.cancel()</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>这两种实现之间的主要区别概述如下：</p><ul><li>asyncio.Task对象差不多与threadig.Thread对象等效。Task对象像是实现协作式多任务的库（如gevent）中的绿色线程（green thread）。</li><li>Task对象用于驱动协程，Thread对象用于调用可调用的对象。</li><li>Task对象不由自己动手实例化，而是通过把协程传给asyncio.async函数或loop.create_task方法获取。</li><li>获取的Task对象已经排定了运行时间（例如，由asyncio.async函数排定）；Thread实例必须调用start方法，明确告知让它运行。</li><li>在线程版supervisor函数中，slow_function函数是普通的函数，直接由线程调用。在异步版supervisor函数中，slow_function函数是协程，由yield from驱动。</li><li>没有API能从外部终止线程，因为线程随时可能被中断，导致系统处于无效状态。如果想终止任务，可以使用Task.cancel实例方法，在协程内部抛出CancelledError异常。协程可以在暂停的yield处捕获这个异常，处理终止请求。</li><li>supervisor协程必须在main函数中由loop.run_until_complete方法执行。</li></ul><p>如果使用线程做过重要的编程，你就直到写出程序有多么困难，因为调度程序任何时候都能中断线程。必须记住保留锁，去保护程序中的重要部分，防止多步操作在执行的过程中中断，防止数据处于无效状态。</p><p>而协程默认会做好全方位保护，以防止中断。我们必须显示产出才能让程序的余下部分运行。对协程来说，无需保留锁，在多个线程之间同步操作，协程自身就会同步，因为在任意时刻只有一个协程运行。想交出控制权时，可以使用yield或yield from把控制权交还调度程序。这就是能够安全地取消协程的原因：按照定义，协程只能在暂停的yield处取消，因此可以处理CancelledError异常，执行清理操作。</p><p>下面说明asyncio.Future类与concurrent.futures.Future类之间的区别。</p><h2 id="asyncio.future故意不阻塞">asyncio.Future：故意不阻塞</h2><p><strong>asyncio.Future类与concurrent.futures.Future类的接口基本一致，不过实现方式不同，不可以互换。</strong></p><p>期物只是调度执行某物的结果。在asyncio包中，BaseEventLoop.create_task方法接收一个协程，排定它的运行时间，然后返回一个asyncio.Task实例——也是asyncio.Future类的实例，因为Task是Future的子类，用于包装协程。这与调用Executor.submit方法创建concurrent.futures.Future实例是一个道理。</p><p>与concurrent.futures.Future类似，asyncio.Future类也提供了done、add_done_callback和result等方法。前两个方法的用法类似，不过result方法差别很大。</p><p>asyncio.Future.result方法没有参数，因此不能指定超时时间。此外，如果调用result方法时期物还没运行完毕，那么result方法不会阻塞去等待结果，而是抛出asyncio.InvalidStatueError异常。</p><p>然而，获取asyncio.Future对象的结果通常使用yield from，从中产出结果。</p><p>使用yield from处理期物，等待期物运行完毕这一步无需我们关心，而且不会阻塞事件循环，因为在asyncio包中，yield from的作用是把控制权还给事件循环。</p><p>注意，使用yield from处理期物，与使用add_done_callback方法处理协程的作用一样：延迟的操作结束后，事件循环不会出发回调对象，而是设置期物的返回值；而yield from表达式则在暂停的协程中生成返回值，恢复执行协程。</p><p><strong>总之，因为asyncio.Future类的目的是与yield from一起使用，所以通常不需要使用以下方法。</strong></p><ul><li><p>无需调用my_future.add_done_callback，因为可以直接把想在期物运行结束后执行的操作放在协程中yield from my_future表达式的后面。这是协程的一大优势：协程是可以暂停和恢复的函数。</p></li><li><p>无需调用my_future.result，因为yield from从期物中产出的值就是结果（例如，result = yield from my_future）。</p></li></ul><p>当然，有时也需要使用done、add_done_callback和result方法。但一般情况下，asyncio.Future对象由yield from驱动，而不是靠调用这些方法驱动。</p><p>下面分析yield from和asyncio包的API如何拉近期物、任务和协程的关系。</p><h2 id="从期物任务和协程中产出">从期物、任务和协程中产出</h2><p>在asyncio包中，期物和协程的关系紧密，因为可以使用yield from从asyncio.Future对象中产出结果。这意味着，如果foo是协程函数（调用后返回协程对象），抑或是返回Future或Task实例的普通函数，那么可以这样写：res = yield from foo()。这是asyncio包的API中很多地方可以互换协程与期物的原因之一。</p><h1 id="从回调到期物到协程">从回调到期物到协程</h1><p>使用协程做面向事件编程，需要下一番功夫才能掌握，因此最好知道，与经典的回调式编程相比，协程有哪些改进。</p><p>“回调地狱”：如果一个操作需要依赖之前操作的结果，那就得嵌套回调。如果要连续做3次异步调用，那就需要嵌套3层回调。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JavaScript中的回调地狱：嵌套匿名函数，也称为灾难金字塔</span></span><br><span class="line">api_call1(request1, <span class="function"><span class="keyword">function</span> (<span class="params">response1</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第一步</span></span><br><span class="line">    <span class="keyword">var</span> request2 = step1(response1);  <span class="comment">// 处理回调收到的响应</span></span><br><span class="line">    aip_call2(requset2, <span class="function"><span class="keyword">function</span> (<span class="params">response2</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 第二步</span></span><br><span class="line">        ver request3 = step2(response2);</span><br><span class="line">        api_call3(request3, <span class="function"><span class="keyword">function</span> (<span class="params">response3</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 第三步</span></span><br><span class="line">            step(response3)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python中的回调地狱：链式回调</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stage1</span><span class="params">(response1)</span>:</span></span><br><span class="line">    request2 = step1(response1)</span><br><span class="line">    api_call2(request2, stage2)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stage2</span><span class="params">(response2)</span>:</span></span><br><span class="line">    request3 = step2(response2)</span><br><span class="line">    api_call3(request3, stage3)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stage3</span><span class="params">(response3)</span>:</span></span><br><span class="line">    step3(response3)</span><br><span class="line"></span><br><span class="line">api_call(request1, stage1)</span><br></pre></td></tr></table></figure><p>虽然代码的排布方式差异很大，但是作用却完全相同。JavaScript示例也能改写成链式风格，但是Python代码不能改写成嵌套风格，因为lambda表达式句法上有限制。</p><p>上述组织代码的方式导致代码难以阅读，也更难编写：每个函数做一部分工作，设置下一个回调，然后返回，让事件循环继续运行。这样，所有本地的上下文都会丢失。执行下一个回调时（例如stage2），就无法获取request2的值。如果需要那个值，那就必须依靠闭包，或者把它存储在外部数据结构中，以便在处理过程的不同阶段使用。</p><p>在这个问题上，协程能发挥很大的作用。在协程汇总，如果要连续执行3个异步操作，只需使用yield 3次，让事件循环继续运行。准备好结果后，调用send方法，激活协程。对事件循环来说，这种做法与调用回调类似。但是对使用协程式异步API的用户来说，情况就大为不同了：3次操作都在同一个函数定义体中，像是顺序代码，能在处理过程中使用局部变量保留整个任务的上下文。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">three_stages</span><span class="params">(request1)</span>:</span></span><br><span class="line">    response1 = <span class="keyword">yield</span> <span class="keyword">from</span> api_call1(request1)</span><br><span class="line">    <span class="comment"># 第一步</span></span><br><span class="line">    request2 = step1(response1)</span><br><span class="line">    response2 = <span class="keyword">yield</span> <span class="keyword">from</span> api_call2(request2)</span><br><span class="line">    <span class="comment"># 第二步</span></span><br><span class="line">    request3 = step2(response2)</span><br><span class="line">    response3 = <span class="keyword">yield</span> <span class="keyword">from</span> api_call3(request3)</span><br><span class="line">    <span class="comment"># 第三步</span></span><br><span class="line">    step3(response3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># three_stages(request1)  # 不能直接调用</span></span><br><span class="line">loop.create_task(three_stages(request1))  <span class="comment"># 必须显示调度执行</span></span><br></pre></td></tr></table></figure><p>与前一个示例相比，使用协程容易理解多了：操作的3个步骤依次写在同一个函数中。这样，后续处理便于使用前一步的结果；而且提供了上下文，能通过异常来报告错误。</p><p>假设在上一个示例中处理api_call2(request2, stage2)调用（stage1函数最后一行）时抛出了I/O异常，这个异常无法在stage1函数中捕获，因为api_call2是异步调用，在还未执行任何I/O操作时就会立即返回。在基于回调的API中，这个问题的解决方法是为每个异步调用注册两个回调，一个用于处理操作成功时的结果，另一个用于处理错误。一旦涉及错误处理，回调地狱的危害程度就会迅速增大。</p><p>与此相比，使用协程时三步操作的所有异步调用都在同一个函数中（three_stages），如果异步调用api_call1、api_call2和api_call3会抛出异常，那么可以把相应的yield from表达式放在try/except块中处理异常。这么做比陷入回调地狱好多了，但是我不会把这种方式称为协程天堂，毕竟我们还要付出代价。我们不能使用常规的函数，必须使用协程，而且要习惯yield from——这是第一个障碍。只要函数中有yield from，函数就会变成协程，而协程不能直接调用。我们必须使用事件循环显示排定协程的执行时间，或者在其他排定了执行时间的协程中使用yield from表达式把它激活。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> concurrency </tag>
            
            <tag> asyncio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习引言</title>
      <link href="/notes/introduction-to-ml-with-python/introduction-to-machine-learning/"/>
      <url>/notes/introduction-to-ml-with-python/introduction-to-machine-learning/</url>
      
        <content type="html"><![CDATA[<p>机器学习（machine learning）是从数据中提取知识。它是统计学、人工智能和计算机科学交叉的研究领域，也被称为预测分析（predictive analytics）或统计学习（statistical learning）。</p><h1 id="为何选择机器学习">为何选择机器学习</h1><p>在“智能”应用的早期，许多系统使用人为制订的“if”和“else”决策规则来处理数据，或根据用户输入的内容进行调整。想象有一个垃圾邮件过滤器，其任务是酌情将收到的某些邮件移动到垃圾邮件文件夹。你可以创建一个关键词黑名单，所有包含这些关键词的邮件都会被标记为垃圾邮件。这是用专家设计的规则体系来设计“智能”应用的一个示例。人为制订的决策规则对某些应用来说是可行的，特别是人们对其模型处理过程非常熟悉的应用。但是，人为制订决策规则主要有两个缺点。</p><ul><li>做决策所需要的逻辑只适用于单一领域和单项任务。任务哪怕稍有变化，都可能需要重写整个系统。</li><li>想要制订规则，需要对人类专家的决策过程有很深刻的理解。</li></ul><p>这种人为制订规则的方法并不适用的一个例子就是图像中的人脸检测。如今，每台智能手机都能够检测到图像中的人脸。但直到2001年，人脸检测问题才得到解决。其主要问题在于，计算机“感知”像素（像素组成了计算机中的图像）的方式与人类感知面部的方式有非常大的不同。正是由于这种表征差异，人类想要制订出一套好的规则来描述数字图像中的人脸构成，基本上是不可能的。</p><p>但有了机器学习算法，仅向程序输入海量人脸图像，就足以让算法确定识别人脸需要哪些特征。</p><a id="more"></a><h1 id="机器学习能够解决的问题">机器学习能够解决的问题</h1><p>从输入/输出对中进行学习的机器学习算法叫作监督学习算法（supervised learning algorithm），因为每个用于算法学习的样例都对应一个预期输出，好像有一个“老师”在监督着算法。虽然创建一个包含输入和输出的数据集往往费时又费力，但监督学习算法很好理解，其性能也易于测量。如果你的应用可以表示成一个监督学习问题，并且你能够创建包含预期输出的数据集，那么机器学习很可能可以解决你的问题。</p><p>监督机器学习任务的示例如下。</p><ul><li>识别信封上手写的邮政编码</li><li>基于医学影像判断肿瘤是否为良性</li><li>检测信用卡交易中的诈骗行</li></ul><p>另一类算法是无监督学习算法（unsupervised learning algorithm）。在无监督学习中，只有输入数据是已知的，没有为算法提供输出数据。虽然这种算法有许多成功的应用，但理解和评估这些算法往往更加困难。</p><p>无监督学习的示例如下。</p><ul><li>确定一系列博客文章的主题</li><li>将客户分成具有相似偏好的群组</li><li>检测网站的异常访问模式</li></ul><p>无论是监督学习任务还是无监督学习任务，将输入数据表征为计算机可以理解的形式都是十分重要的。通常来说，将数据想象成表格是很有用的。你想要处理的每一个数据点（每一封电子邮件、每一名客户、每一次交易）对应表格中的一行，描述该数据点的每一项属性（比如客户年龄、交易金额或交易地点）对应表格中的一列。</p><p>在机器学习中，这里的每个实体或每一行被称为一个样本（sample）或数据点，而每一列（用来描述这些实体的属性）则被称为特征（feature）。</p><h1 id="第一个应用鸢尾花分类">第一个应用：鸢尾花分类</h1><p>假设有一名植物学爱好者对她发现的鸢尾花的品种很感兴趣。她收集了每朵鸢尾花的一些测量数据：花瓣的长度和宽度以及花萼的长度和宽度，所有测量结果的单位都是厘米。</p><p>她还有一些鸢尾花的测量数据，这些花之前已经被植物学专家鉴定为属于setosa、versicolor或virginica三个品种之一。对于这些测量数据，她可以确定每朵鸢尾花所属的品种。我们假设这位植物学爱好者在野外只会遇到这三种鸢尾花。</p><p>我们的目标是构建一个机器学习模型，可以从这些已知品种的鸢尾花测量数据中进行学习，从而能够预测新鸢尾花的品种。</p><p>因为我们有已知品种的鸢尾花的测量数据，所以这是一个监督学习问题。在这个问题中，我们要在多个选项中预测其中一个（鸢尾花的品种）。这是一个分类（classification）问题的示例。可能的输出（鸢尾花的不同品种）叫作类别（class）。数据集中的每朵鸢尾花都属于三个类别之一，所以这是一个三分类问题。</p><p>单个数据点（一朵鸢尾花）的预期输出是这朵花的品种。对于一个数据点来说，它的品种叫作标签（label）。</p><h2 id="初识数据">初识数据</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iris_dataset = load_iris()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iris_dataset.keys()</span><br><span class="line">dict_keys([<span class="string">'data'</span>, <span class="string">'target'</span>, <span class="string">'target_names'</span>, <span class="string">'DESCR'</span>, <span class="string">'feature_names'</span>, <span class="string">'filename'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iris_dataset.target_names  <span class="comment"># 两种访问访问，属性或键</span></span><br><span class="line">array([<span class="string">'setosa'</span>, <span class="string">'versicolor'</span>, <span class="string">'virginica'</span>], dtype=<span class="string">'&lt;U10'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iris_dataset[<span class="string">'feature_names'</span>]</span><br><span class="line">[<span class="string">'sepal length (cm)'</span>, <span class="string">'sepal width (cm)'</span>, <span class="string">'petal length (cm)'</span>, <span class="string">'petal width (cm)'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iris_dataset.data.shape</span><br><span class="line">(<span class="number">150</span>, <span class="number">4</span>)  <span class="comment"># 鸢尾花有150行数据，每行数据有4个特征</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iris_dataset.target.shape</span><br><span class="line">(<span class="number">150</span>,)  <span class="comment"># 150行数据所属的类</span></span><br></pre></td></tr></table></figure><h2 id="衡量模型是否成功训练数据与测试数据">衡量模型是否成功：训练数据与测试数据</h2><p>我们不能将用于构建模型的数据（训练数据）用于评估模型。因为模型会一直记住整个训练集，所以对于训练集中的任何数据点总会预测正确的标签。这种“记忆”无法告诉我们模型的泛化（generalize）能力如何。</p><p>我们要用新数据来评估模型的性能。通常的做法是将收集好的带标签数据分成两部分。一部分数据用于构建机器学习模型，叫做训练数据（training data）或训练集（training set）。其余的数据用来评估模型性能，叫做测试数据（test data）、测试集（test set）或留出集（hold-out set）。</p><p>scikit-learn中的train_test_split函数可以打乱数据集并进行划分。这个函数默认将75%的行数据及对应标签作为训练集，剩下25%的数据及其标签作为测试集。训练集与测试集的分配比例可以是随意的，但使用25%的数据作为测试集是很好的经验法则。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.model_selection.train_test_split#sklearn.model_selection.train_test_split" target="_blank" rel="noopener"><code>sklearn.model_selection.train_test_split(*arrays, **options)</code></a></p><p>Split arrays or matrices into random train and test subsets.</p></blockquote><p>scikit-learn中的数据通常用大写的X表示，而标签用小写的y表示。这是受到了数学标准公式f(x)=y的启发，其中x是函数的输入，y是输出。我们用大写的X是因为数据是一个二维数组（矩阵），用小写的y是因为目标是一个一维数组（向量），这也是数学中的约定。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line"><span class="meta">... </span>    iris_dataset.data, iris_dataset.target, random_state=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>在对数据进行拆分之前，train_test_split函数利用伪随机数生成器将数据集打乱。如果只是将最后25%的数据作为测试集，那么所有数据点的标签都是2，因为数据点是按标签排序的。测试集中只有三个类别之一，这无法告诉我们模型的泛化能力如何，所以将数据打乱，确保测试集中包含所有类别的数据。</p><p>为了确保多次运行同一函数能够得到相同的输出，利用random_state参数指定了随机数生成器种子。这样函数输出就是固定不变的，所以这行代码的输出始终相同。</p><p>train_test_split函数的输出为X_train、X_test、y_train和y_test，它们都是NumPy数组。X_train包含75%的行数据，X_test包含剩下的 25%:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_train.shape, y_train.shape</span><br><span class="line">((<span class="number">112</span>, <span class="number">4</span>), (<span class="number">112</span>,))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_test.shape, y_test.shape</span><br><span class="line">((<span class="number">38</span>, <span class="number">4</span>), (<span class="number">38</span>,))</span><br></pre></td></tr></table></figure><h2 id="要事第一观察数据">要事第一：观察数据</h2><p>在构建机器学习模型之前，通常最好检查一下数据，看看如果不用机器学习能不能轻松完成任务，或者需要的信息有没有包含在数据中。</p><p>此外，检查数据也是发现异常值和特殊值的好方法。举个例子，可能有些鸢尾花的测量单位是英寸而不是厘米。在现实世界中，经常会遇到不一致的数据和意料之外的测量数据。</p><p>检查数据的最佳方法之一就是将其可视化。一种可视化方法是绘制散点图（scatter plot）。数据散点图将一个特征作为x轴，另一个特征作为y轴，将每一个数据点绘制为图上的一个点。不幸的是，计算机屏幕只有两个维度，所以我们一次只能绘制两个特征（也可能是3个）。用这种方法难以对多于3个特征的数据集作图。解决这个问题的一种方法是绘制散点图矩阵（pair plot），从而可以两两查看所有的特征。如果特征数不多的话，这种方法是合理的。但是你应该记住，散点图矩阵无法同时显示所有特征之间的关系，所以这种可视化方法可能无法展示数据的某些有趣内容。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> mglearn</span><br><span class="line"><span class="comment"># 利用X_train中的数据创建DataFrame</span></span><br><span class="line"><span class="comment"># 利用iris_dataset.feature_names中的字符串对数据列进行标记</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iris_dataframe = pd.DataFrame(X_train, columns=iris_dataset.feature_names)</span><br><span class="line"><span class="comment"># 利用DataFrame创建散点图矩阵，按y_train着色</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grr = pd.scatter_matrix(iris_dataframe, c=y_train, figsize=(<span class="number">15</span>, <span class="number">15</span>), marker=<span class="string">'o'</span>,</span><br><span class="line"><span class="meta">... </span>    hist_kwds=&#123;<span class="string">'bins'</span>: <span class="number">20</span>&#125;, s=<span class="number">60</span>, alpha=<span class="number">.8</span>, cmap=mglearn.cm3)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.show()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/iris-dataframe.png"></p><p>从图中可以看出，利用花瓣和花萼的测量数据基本可以将三个类别区分开。这说明机器学习模型很可能可以学会区分它们。</p><h2 id="构建第一个模型k近邻算法">构建第一个模型：k近邻算法</h2><p>构建此模型只需要保存训练集即可。要对一个新的数据点作出预测，算法会在训练集中寻找与这个新数据点距离最近的数据点，然后将找到的数据点的标签赋予这个新数据点。</p><p>k的含义是，我们可以考虑训练集中与新数据点最近的任意k个邻居，而不是只考虑最近的那一个。然后，我们可以用这些邻居中数量最多的类别做出预测。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>knn = KNeighborsClassifier(n_neighbors=<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>knn.fit(X_train, y_train)  <span class="comment"># 基于训练集构建模型，fit方法返回knn对象本身并做原处修改</span></span><br><span class="line">KNeighborsClassifier(algorithm=<span class="string">'auto'</span>, leaf_size=<span class="number">30</span>, metric=<span class="string">'minkowski'</span>,</span><br><span class="line">                     metric_params=<span class="literal">None</span>, n_jobs=<span class="literal">None</span>, n_neighbors=<span class="number">1</span>, p=<span class="number">2</span>,</span><br><span class="line">                     weights=<span class="string">'uniform'</span>)</span><br></pre></td></tr></table></figure><h2 id="做出预测">做出预测</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_new = np.array([[<span class="number">5</span>, <span class="number">2.9</span>, <span class="number">1</span>, <span class="number">.2</span>]])  <span class="comment"># 将测量的数据放入二维数组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_new.shape</span><br><span class="line">(<span class="number">1</span>, <span class="number">4</span>)  <span class="comment"># 我们有1行数据，每行数据有4个特征</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>prediction = knn.predict(X_new)  <span class="comment"># predict的参数必须是二维数组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>prediction</span><br><span class="line">array([<span class="number">0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iris_dataset.target_names[<span class="number">0</span>]</span><br><span class="line"><span class="string">'setosa'</span>  <span class="comment"># 这朵花属于setosa品种</span></span><br></pre></td></tr></table></figure><h2 id="评估模型">评估模型</h2><p>这里需要用到之前创建的测试集。这些数据没有用于构建模型，但我们直到测试集中每朵鸢尾花的实际品种。</p><p>因此，我们可以对测试数据中的每朵鸢尾花进行预测，并将预测结果与标签进行对比。我们可以通过计算精确度（accuracy）来衡量模型的优劣，精度就是品种预测正确的花所占的比例。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>y_pred = knn.predict(X_test)  <span class="comment"># 先预测</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y_pred</span><br><span class="line">array([<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>,</span><br><span class="line">       <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.mean(y_pred == y_test)  <span class="comment"># 再通过np.mean函数计算精度</span></span><br><span class="line"><span class="number">0.9736842105263158</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>knn.score(X_test, y_test)  <span class="comment"># 或者通过score方法计算精度</span></span><br><span class="line"><span class="number">0.9736842105263158</span></span><br></pre></td></tr></table></figure><p>对于这个模型来说，测试集的精度约为0.97，也就是说，对于测试集中的鸢尾花，我们的预测有97%是正确的。这让我们有信心将模型应用于新数据，并相信模型在约97%的情况下都是正确的。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Machine Learning with Python </tag>
            
            <tag> classification </tag>
            
            <tag> kmeans </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用futures处理并发</title>
      <link href="/notes/fluent-python/concurrency-with-futures/"/>
      <url>/notes/fluent-python/concurrency-with-futures/</url>
      
        <content type="html"><![CDATA[<p>本章讨论Python3.2引入的concurrent.futures模块。“期物”（future）是译者自创的词。期物指一种对象，表示异步执行的操作。</p><h1 id="示例网络下载的三种风格">示例：网络下载的三种风格</h1><p>为了高效处理网络I/O，需要使用并发，因为网络有很高的延迟，所以为了不浪费CPU周期去等待，最好在收到网络相应之前做些其他的事。本章有3个示例程序，从网上下载20个国家的国旗图像。第一个示例程序是依序下载的：下载完一个图像，并将其保存在硬盘中之后，才请求下一个图像。另外两个脚本是并发下载（分别使用concurrent.futres模块和asyncio包）的：几乎同时请求所有图像，每下载完一个文件就保存一个文件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python flags.py</span><br><span class="line">BD BR CD CN DE EG ET FR ID IN IR JP MX NG PH PK RU TR US VN</span><br><span class="line">20 flags downloaded in 3.41s</span><br><span class="line">$ python flags_threadpool.py</span><br><span class="line">IN ID CN EG TR NG JP FR DE PK VN RU ET MX PH US IR CD BR BD</span><br><span class="line">20 flags downloaded in 0.20s</span><br><span class="line">$ python flags_asyncio.py</span><br><span class="line">JP CN PK PH EG FR TR BD IN ET RU BR DE ID US NG MX IR CD VN</span><br><span class="line">20 flags downloaded in 0.26s</span><br></pre></td></tr></table></figure><p>两个并发下载的脚本之间性能差异不大，不过都比依序下载的脚本快5倍多（原书是5倍多，我的结果相差更大）。这只是一个特别小的任务，如果把下载的文件数量增加到几百个，并发下载的脚本能比依序下载的脚本快20倍或更多。将这三个脚本一起演示是为了表明一个观点：<strong>在I/O密集型应用中，如果代码写的正确，那么不管使用哪种并发策略（使用线程或asyncio包），吞吐量都比依序执行的代码高得多。</strong></p><a id="more"></a><h2 id="依序下载的脚本">依序下载的脚本</h2><figure class="highlight python"><figcaption><span>flags.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests  <span class="comment"># 导入requests库，这个库不在标准库中</span></span><br><span class="line"></span><br><span class="line">POP20_CC = (<span class="string">'CN IN US ID BR PK NG BD RU JP '</span></span><br><span class="line">            <span class="string">'MX PH VN ET EG DE IR TR CD FR'</span>).split()</span><br><span class="line"></span><br><span class="line">BASE_URL = <span class="string">'http://flupy.org/data/flags'</span></span><br><span class="line"></span><br><span class="line">DEST_DIR = <span class="string">'downloads/'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_flag</span><span class="params">(img, filename)</span>:</span></span><br><span class="line">    path = os.path.join(DEST_DIR, filename)</span><br><span class="line">    <span class="keyword">with</span> open(path, <span class="string">'wb'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(img)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flag</span><span class="params">(cc)</span>:</span></span><br><span class="line">    url = <span class="string">'&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif'</span>.format(BASE_URL, cc=cc.lower())</span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    <span class="keyword">return</span> resp.content</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(text)</span>:</span></span><br><span class="line">    print(text, end=<span class="string">' '</span>)</span><br><span class="line">    sys.stdout.flush()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> cc <span class="keyword">in</span> sorted(cc_list):  <span class="comment"># 按序下载</span></span><br><span class="line">        image = get_flag(cc)</span><br><span class="line">        show(cc)</span><br><span class="line">        save_flag(image, cc.lower() + <span class="string">'.gif'</span>)</span><br><span class="line">    <span class="keyword">return</span> len(cc_list)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(download_many)</span>:</span></span><br><span class="line">    t0 = time.time()</span><br><span class="line">    count = download_many(POP20_CC)</span><br><span class="line">    elapsed = time.time() - t0</span><br><span class="line">    msg = <span class="string">'\n&#123;&#125; flags downloaded in &#123;:.2f&#125;s'</span></span><br><span class="line">    print(msg.format(count, elapsed))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main(download_many)</span><br></pre></td></tr></table></figure><h2 id="使用concurrent.futures模块下载">使用concurrent.futures模块下载</h2><p>concurrent.futures模块的主要特色是ThreadPoolExecutor和ProcessPoolExecutor类，这两个类实现的接口能分别在不同的线程或进程中执行可调用的对象。这两个类在内部维护这一个工作线程或进程池，以及要执行的任务队列。不过，这个接口抽象的层级很高，像下载国旗这种简单的案例，无需关心任何细节。</p><figure class="highlight python"><figcaption><span>flags_threadpool.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flags <span class="keyword">import</span> save_flag, get_flag, show, main  <span class="comment"># 重用函数</span></span><br><span class="line"></span><br><span class="line">MAX_WOKERS = <span class="number">20</span>  <span class="comment"># 设置最大线程数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_one</span><span class="params">(cc)</span>:</span>  <span class="comment"># 下载一个国旗，这是在各个线程中执行的函数</span></span><br><span class="line">    image = get_flag(cc)</span><br><span class="line">    show(cc)</span><br><span class="line">    save_flag(image, cc.lower() + <span class="string">'.gif'</span>)</span><br><span class="line">    <span class="keyword">return</span> cc</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list)</span>:</span></span><br><span class="line">    wokers = min(MAX_WOKERS, len(cc_list))  <span class="comment"># 避免创建多余的线程</span></span><br><span class="line">    <span class="comment"># executor.__exit__方法会调用executor.shutdown(wait=True)方法</span></span><br><span class="line">    <span class="comment"># 它会在所有线程都执行完毕前阻塞线程</span></span><br><span class="line">    <span class="keyword">with</span> futures.ThreadPoolExecutor(wokers) <span class="keyword">as</span> executor:</span><br><span class="line">        res = executor.map(download_one, sorted(cc_list))  <span class="comment"># 返回一个生成器</span></span><br><span class="line">    <span class="keyword">return</span> len(list(res))  <span class="comment"># 获取各个函数返回的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main(download_many)</span><br></pre></td></tr></table></figure><h3 id="期物在哪里">期物在哪里</h3><p>期物是concurrent.futures模块和asyncio包的重要组件，可是，作为这两个库的用户，我们有时却见不到期物。</p><p>从Python3.4起，标准库中有两个名为Future的类：concurrent.futures.Future和asyncio.Future。这两个类的作用相同：两个Future类的实例都表示可能已经完成或者尚未完成的延迟计算。这与Twisted引擎中的Deferred类、Tornado框架中的Future类，以及多个JavaScript库中的Promise对象类似。</p><p>期物封装待完成的操作，可以放入队列，完成的状态可以查询，得到结果（或抛出异常）后可以获取结果（或异常）。</p><p>我们要记住一件事：<strong>通常情况下自己不应该创建期物，而只能由并发框架（concurrent.futures或asyncio）实例化。</strong>原因很简单：期物表示终将发生的事情，而确定某件事会发生的唯一方式是执行的时间已经排定。因此，只有排定把某件事交给concurrent.futures.Executor子类处理时，才会创建concurrent.futures.Future实例。例如，Executor.submit方法的参数是一个可调用的对象，调用这个方法后会为传入的可调用对象排期，并返回一个期物。</p><p>客户端代码不应该改变期物的状态，并发框架在期物表示的延迟计算结束后会改变期物的状态，而我们无法控制计算何时结束。</p><p>这两种期物都有done方法，这个方法不阻塞，返回值是布尔值，指明期物链接的可调用对象是否已经执行。客户端代码通常不会询问期物是否运行结束，而是会等待通知。因此，两个Future类都有add_done_callback方法：这个方法只有一个参数，类型是可调用的对象，期物运行结束后会调用指定的可调用对象。</p><p>此外，还有result方法。在期物运行结束后调用的话，这个方法在两个Future类中的作用相同：返回可调用对象的结果，或者重新抛出执行可调用的对象时抛出的异常。可是，如果期物没有运行结束，result方法在两个Future类中的行为相差很大。对concurrency.futures.Future实例来说，调用f.result()方法会阻塞调用方所在的线程，直到有结果可以返回。此时，result方法可以接收可选的timeout参数，如果在指定的时间内没有运行完毕，会抛出TimeoutError异常。asyncio.Future.result方法不支持设定超过时间，在那个库中获取期物的结果最好使用yield from结构。不过，对concurrency.futures.Future实例不能这么做。</p><p>这两个库中有几个函数会返回期物，其他函数则使用期物，以易于用户理解的方式实现自身。Executor.map方法属于后者：返回值是一个迭代器，迭代器的<code>__next__</code>方法调用各个期物的result方法，因此我们得到的是各个期物的结果，而非期物本身。</p><p>为了从实用的角度理解期物，我们可以实用concurrent.futures.as_completed函数重写示例。这个函数的参数是一个期物列表，返回值是一个迭代器，在期物运行结束后产出期物。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list)</span>:</span></span><br><span class="line">    cc_list = cc_list[:<span class="number">5</span>]  <span class="comment"># 使用5个做演示</span></span><br><span class="line">    <span class="keyword">with</span> futures.ThreadPoolExecutor(max_workers=<span class="number">3</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        to_do = []</span><br><span class="line">        <span class="keyword">for</span> cc <span class="keyword">in</span> sorted(cc_list):</span><br><span class="line">            future = executor.submit(download_one, cc)  <span class="comment"># 排定可调用对象的执行时间，返回一个期物</span></span><br><span class="line">            to_do.append(future)</span><br><span class="line">            msg = <span class="string">'Scheduled for &#123;&#125;: &#123;&#125;'</span></span><br><span class="line">            print(msg.format(cc, future))</span><br><span class="line">        results = []</span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> futures.as_completed(to_do):  <span class="comment"># 在期物运行结束后产出期物</span></span><br><span class="line">            res = future.result()  <span class="comment"># 这次不会阻塞，因为future由as_completed函数产出</span></span><br><span class="line">            msg = <span class="string">'&#123;&#125; result: &#123;!r&#125;'</span></span><br><span class="line">            print(msg.format(future, res))</span><br><span class="line">            results.append(res)</span><br><span class="line">        <span class="keyword">return</span> len(results)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python flags_threadpool.py</span><br><span class="line">Scheduled for BR: &lt;Future at 0x1031a25f8 state=running&gt;</span><br><span class="line">Scheduled for CN: &lt;Future at 0x1031ae0f0 state=running&gt;</span><br><span class="line">Scheduled for ID: &lt;Future at 0x1031ae6a0 state=running&gt;  # 最大3个</span><br><span class="line">Scheduled for IN: &lt;Future at 0x1031bb080 state=pending&gt;</span><br><span class="line">Scheduled for US: &lt;Future at 0x1031bb160 state=pending&gt;</span><br><span class="line">CN &lt;Future at 0x1031ae0f0 state=finished returned str&gt; result: &apos;CN&apos;</span><br><span class="line">ID BR &lt;Future at 0x1031ae6a0 state=finished returned str&gt; result: &apos;ID&apos;</span><br><span class="line">&lt;Future at 0x1031a25f8 state=finished returned str&gt; result: &apos;BR&apos;</span><br><span class="line">IN &lt;Future at 0x1031bb080 state=finished returned str&gt; result: &apos;IN&apos;</span><br><span class="line">US &lt;Future at 0x1031bb160 state=finished returned str&gt; result: &apos;US&apos;</span><br><span class="line"></span><br><span class="line">5 flags downloaded in 0.32s</span><br></pre></td></tr></table></figure><p>多次运行脚本看到的结果有所不同。如果把max_workers参数的值增大到5，结果的顺序变化更多。把max_workers参数的值设为1，代码依序运行，结果的顺序始终与调用submit方法的顺序一致。</p><h2 id="使用asyncio模块下载">使用asyncio模块下载</h2><figure class="highlight python"><figcaption><span>flags_asyncio.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这段脚本与原文的脚本代码不同，使用了Python3.5引入的async和await关键字</span></span><br><span class="line"><span class="comment"># 原脚本中的一些写法可能不再是推荐写法了，愿脚本的代码也不进行分析了</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> aiohttp  <span class="comment"># 它不在标准库中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flags <span class="keyword">import</span> BASE_URL, save_flag, show, main</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_flag</span><span class="params">(client, cc)</span>:</span></span><br><span class="line">    url = <span class="string">'&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif'</span>.format(BASE_URL, cc=cc.lower())</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> client.get(url) <span class="keyword">as</span> resp:</span><br><span class="line">        <span class="keyword">assert</span> resp.status == <span class="number">200</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> resp.read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">download_one</span><span class="params">(cc)</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> client:</span><br><span class="line">        image = <span class="keyword">await</span> get_flag(client, cc)</span><br><span class="line">        show(cc)</span><br><span class="line">        save_flag(image, cc.lower() + <span class="string">'.gif'</span>)</span><br><span class="line">        <span class="keyword">return</span> cc</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list)</span>:</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    to_do = [download_one(cc) <span class="keyword">for</span> cc <span class="keyword">in</span> sorted(cc_list)]</span><br><span class="line">    <span class="comment"># 虽然函数名是wait，但它不是阻塞性函数。wait是一个协程，等传给它所有协程运行完毕后结束</span></span><br><span class="line">    wait_coro = asyncio.wait(to_do)</span><br><span class="line">    <span class="comment"># 执行事件循环，直到wait_coro运行结束；事件循环运行的过程中，这个脚本会在这里阻塞</span></span><br><span class="line">    res, _ = loop.run_until_complete(wait_coro)</span><br><span class="line">    loop.close()  <span class="comment"># 关闭事件循环</span></span><br><span class="line">    <span class="keyword">return</span> len(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main(download_many)</span><br></pre></td></tr></table></figure><p>严格来说，我们目前测试的并发脚本都不能并行下载。使用concurrent.futures库实现的那两个示例受GIL（Global Interpreter Lock，全局解释器锁）的限制，而使用asyncio库实现的脚本在单个线程中运行。</p><ul><li>既然Python线程受GIL的限制，任何时候都只允许运行一个线程，那么flags_threadpool.py脚本的下载速度怎么会比flags.py脚本快5倍？这是因为GIL几乎对<strong>I/O密集型</strong>处理无害。原因见下一节阻塞型I/O和GIL。</li><li>flags_asyncio.py脚本和flags.py脚本都在单个线程中运行，前者怎么会比后者快5倍？原因见下下一节避免阻塞型调用。</li></ul><h1 id="阻塞型io和gil">阻塞型I/O和GIL</h1><p>CPython解释器本身就不是线程安全的，因此有全局解释器锁（GIL），一次只允许使用一个线程执行Python字节码（这是CPython解释器的局限，与Python语言本身无关）。因此，一个Python进程通常不能同时使用多个CPU核心。</p><p>编写Python代码时无法控制GIL；不过，执行耗时的任务时，可以使用一个内置的函数或一个使用C语言编写的扩展释放GIL。其实，有个使用C语言编写的Python库能管理GIL，自行启动操作系统线程，利用全部可用的CPU核心。这样做会极大地增加库代码的复杂度，因此大多数库的作者都不这么做。</p><p>然而，<strong>标准库中的所有执行阻塞型I/O操作的函数，在等待操作系统返回结果时都会释放GIL。这意味着在Python语言这个层次上可以使用多线程，而I/O密集型Python程序能从中受益：一个Python线程等待网络响应时，阻塞型I/O函数会释放GIL，再运行一个线程。</strong></p><p>下面简单说明如何在<strong>CPU密集型</strong>作业中使用concurrent.futures模块轻松绕开GIL。</p><h1 id="避免阻塞型调用">避免阻塞型调用</h1><p>用asyncio包时，我们编写的异步代码中包含由asyncio本身驱动的协程（即委派生成器），而生成器最终把职责委托给asyncio包或第三方库（如aiohttp）中的协程。这种处理方式相当于架起了管道，让asyncio事件循环（通过我们编写的协程）驱动执行低层异步I/O操作的库函数。</p><p>有两种方法能避免阻塞型调用中止整个应用程序的进程：</p><ul><li>在单独的线程中运行各个阻塞型操作</li><li>把每个阻塞型操作转换成非阻塞的异步调用使用</li></ul><p>多个线程是可以的，但是各个操作系统线程（Python使用的是这种线程）消耗的内存达兆字节（具体的量取决于操作系统种类）。如果要处理几千个连接，而每个连接都使用一个线程的话，我们负担不起。</p><p>为了降低内存的消耗，通常使用回调来实现异步调用。使用回调时，我们不等待响应，而是注册一个函数，在发生某件事时调用。这样，所有调用都是非阻塞的。因为回调简单，而且消耗低，所以Ryan Dahl（Node.js的发明者）用户这种方式。</p><p>当然，只有异步应用程序底层的事件循环能依靠各种基础设置的中断、线程、轮询和后台进程等，确保多个并发请求能取得进展并最终完成，这样才能使用回调。事件循环获得响应后，会回过头来调用我们指定的回调。不过，如果做法正确，事件循环和应用代码共用的主线程绝不会阻塞。</p><p>把生成器当作协程使用是异步编程的另一种方式。对事件循环来说，调用回调与在暂停的协程上调用send方法效果差不多。各个暂停的协程是要消耗内存，但是比线程消耗的内存数量级小。而且，协程能避免可怕的“回调地狱”。</p><p>flags.py脚本依序下载，而每次下载都要用几十亿个CPU周期等待即过。其实，CPU同时做了很多事，只是没有运行你的程序。与此相比，在flags_asyncio.py脚本中，在download_many函数中调用loop.run_until_complete方法时，事件循环驱动各个download_one协程，各个download_one协程中又驱动各个get_flag协程，运行到client.get(url)。这些调用都不会阻塞，因此在零点几秒内所有请求全部开始。</p><p>asyncio的基础设施获得第一个响应后，事件循环把响应发给等待结果的get_flag协程。得到响应后，get_flag向前执行，调用resp.read方法，然后把控制权还给主循环。（我不确定这段描述是否符合<code>return await resp.read()</code>的运行过程；作为参考，原脚本的代码是<code>return yield from resp.read()</code>）</p><p>因为异步操作是交叉执行的，所以并发下载多张图像所需的总时间比依序下载少得多。</p><h1 id="使用concurrent.futures模块启动进程">使用concurrent.futures模块启动进程</h1><p>concurrent.futures模块的文档副标题是“Launching parallel tasks”（执行并行任务）。这个模块实现的是真正的并行计算，因为它使用ProcessPoolExecutor类把工作分配给多个Python进程处理。因此，如果需要做CPU密集型处理，使用这个模块能绕开GIL，利用所有可用CPU核心。</p><p><a href="https://devdocs.io/python~3.6/library/concurrent.futures#concurrent.futures.ProcessPoolExecutor" target="_blank" rel="noopener">ProcessPoolExecutor</a>和<a href="https://devdocs.io/python~3.6/library/concurrent.futures#concurrent.futures.ThreadPoolExecutor" target="_blank" rel="noopener">ThreadPoolExecutor</a>类都实现了通用的Executor接口，因此使用concurrent.futures模块能特别轻松地把基于线程的方案转成基于进程的方案。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list)</span>:</span></span><br><span class="line">    workers = min(MAX_WORKERS, len(cc_list))</span><br><span class="line">    <span class="keyword">with</span> futures.ThreadPoolExecutor(workers) <span class="keyword">as</span> executor:  <span class="comment"># 基于线程</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> futures.ProcessPoolExecutor() <span class="keyword">as</span> executor:  <span class="comment"># 基于进程</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p><code>ThreadPoolExecutor.__init__</code>方法需要<code>max_workers</code>参数，指定线程池中线程的数量。在ProcessPoolExecutor类中，那个参数是可选的，而且大多数情况下不实用——默认值是<code>os.cpu_count()</code>函数返回的CPU数量。这样处理说得通，因为对于CPU密集型的处理来说，不可能要求使用超过CPU数量的workers。而对I/O密集型处理来说，可以在一个ThreadPoolExecutor实例中使用10个、100个或1000个线程；最佳线程数取决于做的是什么事，以及可用内存有多少，因此要仔细测试才能找到最佳的线程数。</p><h1 id="实验executor.map方法">实验Executor.map方法</h1><p>若想并发运行多个可调用的对象，最简单的方式是使用示例中见过的Executor.map方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep, strftime</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(*args)</span>:</span>  <span class="comment"># 打印传入的参数并在前加一个时间戳</span></span><br><span class="line">    print(strftime(<span class="string">'[%H:%M:%S]'</span>), end=<span class="string">' '</span>)</span><br><span class="line">    print(*args)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loiter</span><span class="params">(n)</span>:</span></span><br><span class="line">    msg = <span class="string">'&#123;&#125;loiter(&#123;&#125;): doing nothing for &#123;&#125;s...'</span></span><br><span class="line">    display(msg.format(<span class="string">'\t'</span>*n, n, n))</span><br><span class="line">    sleep(n)</span><br><span class="line">    msg = <span class="string">'&#123;&#125;loiter(&#123;&#125;): done.'</span></span><br><span class="line">    display(msg.format(<span class="string">'\t'</span>*n, n))</span><br><span class="line">    <span class="keyword">return</span> n * <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    display(<span class="string">'Script starting.'</span>)</span><br><span class="line">    executor = futures.ThreadPoolExecutor(max_workers=<span class="number">3</span>)</span><br><span class="line">    results = executor.map(loiter, range(<span class="number">5</span>))</span><br><span class="line">    display(<span class="string">'results:'</span>, results)  <span class="comment"># 返回的是生成器，目前不会阻塞</span></span><br><span class="line">    display(<span class="string">'Waiting for individual results:'</span>)</span><br><span class="line">    <span class="keyword">for</span> i, result <span class="keyword">in</span> enumerate(results):</span><br><span class="line">        display(<span class="string">'result &#123;&#125;: &#123;&#125;'</span>.format(i, result))</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python demo_executor_map.py</span><br><span class="line">[21:31:07] Script starting.</span><br><span class="line">[21:31:07] loiter(0): doing nothing for 0s...</span><br><span class="line">[21:31:07] loiter(0): done.</span><br><span class="line">[21:31:07]     loiter(1): doing nothing for 1s...</span><br><span class="line">[21:31:07]         loiter(2): doing nothing for 2s...</span><br><span class="line">[21:31:07] results: &lt;generator object Executor.map.&lt;locals&gt;.result_iterator at 0x10cd970f8&gt;</span><br><span class="line">[21:31:07] Waiting for individual results:</span><br><span class="line">[21:31:07] result 0: 0  # loiter(0)运行结束了，第一个worker就可以启动第四个线程，运行loiter(3)</span><br><span class="line">[21:31:07]             loiter(3): doing nothing for 3s...</span><br><span class="line">[21:31:08]     loiter(1): done.</span><br><span class="line">[21:31:08]                 loiter(4): doing nothing for 4s...</span><br><span class="line">[21:31:08] result 1: 10</span><br><span class="line">[21:31:09]         loiter(2): done.</span><br><span class="line">[21:31:09] result 2: 20</span><br><span class="line">[21:31:10]             loiter(3): done.</span><br><span class="line">[21:31:10] result 3: 30</span><br><span class="line">[21:31:12]                 loiter(4): done.</span><br><span class="line">[21:31:12] result 4: 40</span><br></pre></td></tr></table></figure><p>第一个线程执行loiter(0)，因此会休眠0秒，甚至会在第二个线程开始之前就结束，不过具体情况因人而异：对线程来说，你永远不知道某一时刻事件的具体排序；有可能在另一台设备中会看到loiter(1)在loiter(0)结束之前开始，这是因为sleep函数总会释放GIL。因此，即便休眠0秒，Python也可能会切换到另一个线程。</p><p><strong>Executor.map函数易于使用，不过有个特性可能有用，也可能没用，具体情况取决于需求：这个函数返回结果的顺序与调用开始的顺序一致。如果第一个调用生成结果用时10秒，而其他调用只用1秒，代码会阻塞10秒，获取map方法返回的生成器产出的第一个结果。在此之后，获取后续结果时不会阻塞，因为后续的调用已经结束。如果必须等到获取所有结果后再处理，这种行为没问题；不过，通常更可取的方式是，不管提交的顺序，只要有结果就获取。为此，要把Executor.submit方法和futures.as_completed函数结合起来使用（之前的示例中演示过如何组合使用）。</strong></p><p>executor.submit和futures.as_completed这个组合比executor.map更灵活，因为submit方法能处理不同的可调用对象和参数，而executor.map只能处理参数不同的同一个可调用对象。此外，传给futures.as_completed函数的期物集合可以来自Executor实例，例如一些由ThreadPoolExecutor实例创建，另一些由ProcessPoolExecutor实例创建。</p><h1 id="显示下载进度并处理错误节选">显示下载进度并处理错误（节选）</h1><h2 id="依序下载">依序下载</h2><p>在download_one函数中处理HTTP 404错误，其他异常则向上冒泡，交给download_many函数处理。</p><figure class="highlight python"><figcaption><span>flags2_sequential.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flag</span><span class="params">(base_url, cc)</span>:</span></span><br><span class="line">    url = <span class="string">'&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif'</span>.format(base_url, cc=cc.lower())</span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    <span class="keyword">if</span> resp.status_code != <span class="number">200</span>:</span><br><span class="line">        resp.raise_for_status()  <span class="comment"># 状态码不是200时，抛出异常</span></span><br><span class="line">    <span class="keyword">return</span> resp.content</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_one</span><span class="params">(cc, base_url, verbose=False)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        image = get_flag(base_url, cc)</span><br><span class="line">    <span class="keyword">except</span> requests.exceptions.HTTPError <span class="keyword">as</span> exc:  <span class="comment"># 捕获异常</span></span><br><span class="line">        res = exc.response</span><br><span class="line">        <span class="keyword">if</span> res.status_code == <span class="number">404</span>:  <span class="comment"># 单独处理404异常</span></span><br><span class="line">            status = HTTPStatus.not_found  <span class="comment"># HTTPStatus是自定义的Enum对象</span></span><br><span class="line">            msg = <span class="string">'not found'</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 抛出其他异常</span></span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 没有异常时</span></span><br><span class="line">        save_flag(image, cc.lower() + <span class="string">'.gif'</span>)</span><br><span class="line">        status = HTTPStatus.ok</span><br><span class="line">        msg = <span class="string">'OK'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> verbose:  <span class="comment"># 是否显示消息</span></span><br><span class="line">        print(cc, msg)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result(status, cc)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list, base_url, verbose, max_req)</span>:</span></span><br><span class="line">    counter = collections.Counter()  <span class="comment"># 计数</span></span><br><span class="line">    cc_iter = sorted(cc_list)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> verbose:  <span class="comment"># 是否显示进度条</span></span><br><span class="line">        <span class="comment"># 把cc_iter传给tqdm函数，返回一个迭代器，产出cc_iter中的元素，还会显示进度条动画</span></span><br><span class="line">        cc_iter = tqdm.tqdm(cc_iter)</span><br><span class="line">    <span class="keyword">for</span> cc <span class="keyword">in</span> cc_iter:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            res = download_one(cc, base_url, verbose)</span><br><span class="line">        <span class="keyword">except</span> requests.exceptions.HTTPError <span class="keyword">as</span> exc:  <span class="comment"># 与HTTP有关且download_one中没处理的异常</span></span><br><span class="line">            error_msg = <span class="string">'HTTP error &#123;res.status_code&#125; - &#123;res.reasion&#125;'</span></span><br><span class="line">            error_msg = errormsg.format(res=exc.response)</span><br><span class="line">        <span class="keyword">except</span> requests.exceptions.ConnectionError <span class="keyword">as</span> exc:  <span class="comment"># 与网络有关的异常</span></span><br><span class="line">            error_msg = <span class="string">'Connection error'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            error_msg = <span class="string">''</span></span><br><span class="line">            status = res.status</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> error_msg:</span><br><span class="line">            status = HTTPStatus.error</span><br><span class="line">        counter[status] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> verbose <span class="keyword">and</span> error_msg:</span><br><span class="line">            print(<span class="string">'*** Error for &#123;&#125;: &#123;&#125;'</span>.format(cc, error_msg))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> counter</span><br></pre></td></tr></table></figure><h2 id="使用futures.as_completed函数">使用futures.as_completed函数</h2><p>为了集成TQDM进度条，并处理各次请求中的错误，flags2_threadpool.py脚本用到futures.ThreadPoolExecutor类和futures.as_completed函数。</p><figure class="highlight python"><figcaption><span>flags2_threadpool.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list, base_url, verbose, concur_req)</span>:</span></span><br><span class="line">    counter = collections.Counter()</span><br><span class="line">    <span class="keyword">with</span> futures.ThreadPoolExecutor(max_workers=concur_req) <span class="keyword">as</span> executor:</span><br><span class="line">        to_do_map = &#123;&#125;  <span class="comment"># 把各个Future实例（表示一次下载）映射到相应的国家代码</span></span><br><span class="line">        <span class="keyword">for</span> cc <span class="keyword">in</span> sorted(cc_list):</span><br><span class="line">            future = executor.submit(download_one, cc, base_url, verbose)  <span class="comment"># 排定执行时间</span></span><br><span class="line">            to_do_map[future] = cc</span><br><span class="line">        done_iter = futures.as_completed(to_do_map)  <span class="comment"># 返回一个迭代器，在期物运行结束后产出期物</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> verbose:</span><br><span class="line">            <span class="comment"># done_iter没有__len__方法，必须通过total参数告诉tqdm函数预期的元素数量</span></span><br><span class="line">            done_iter = tqdm.tqdm(done_iter, total=len(cc_list))</span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> done_iter:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                res = future.result()  <span class="comment"># 不会阻塞，因为as_completed函数只返回已经运行结束的期物</span></span><br><span class="line">            <span class="keyword">except</span> requests.exceptions.HTTPError <span class="keyword">as</span> exc:</span><br><span class="line">                error_msg = <span class="string">'HTTP &#123;res.status_code&#125; - &#123;res.reason&#125;'</span></span><br><span class="line">                error_msg = error_msg.format(res=exc.response)</span><br><span class="line">            <span class="keyword">except</span> requests.exceptions.ConnectionError <span class="keyword">as</span> exc:</span><br><span class="line">                error_msg = <span class="string">'Connection error'</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                error_msg = <span class="string">''</span></span><br><span class="line">                status = res.status</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> error_msg:</span><br><span class="line">                status = HTTPStatus.error</span><br><span class="line">            counter[status] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> verbose <span class="keyword">and</span> error_msg:</span><br><span class="line">                cc = to_do_map[future]</span><br><span class="line">                print(<span class="string">'*** Error for &#123;&#125;: &#123;&#125;'</span>.format(cc, error_msg))</span><br><span class="line">    <span class="keyword">return</span> counter</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> concurrency </tag>
            
            <tag> futures </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用协程做离散事件仿真</title>
      <link href="/notes/fluent-python/coroutines-for-discrete-event-simulation/"/>
      <url>/notes/fluent-python/coroutines-for-discrete-event-simulation/</url>
      
        <content type="html"><![CDATA[<p>在计算机科学领域，仿真是协程的经典应用。</p><p>协程是asyncio包的基础构建。通过仿真系统能说明如何使用协程代替线程实现并发的活动。</p><h1 id="离散事件仿真简介">离散事件仿真简介</h1><p>离散事件仿真（Discrete Event Simulation，DES）是一种把系统建模成一系列事件的仿真类型。在离散事件仿真中，仿真“钟”向前推进的量不是固定的，而是直接推进到下一个事件模型的模拟时间。加入我们抽象模拟出租车的运营过程，其中一个事件是乘客上车，下一个事件则是乘客下车。不管乘客坐了5分钟还是50分钟，一旦乘客下车，仿真钟就会更新，指向此次运营的结束时间。使用离散事件仿真可以在不到一秒钟的事件模拟一年的出租车运营过程。这与连续仿真不同，连续仿真的仿真钟以固定的量（通常很小）不断向前推进。</p><p>显然，回合制游戏就是离散事件仿真的例子：游戏的状态只在玩家操作时变化，而且一旦玩家决定下一步怎么走了，仿真钟就会冻结。而实时游戏则是连续仿真，仿真钟一直在运行，游戏的状态在一秒钟之内更新很多次，因此反应慢的玩家特别吃亏。</p><p>这两种仿真类型都能使用多线程或在单个线程中使用面向事件的编程技术实现。可以说，为了实现连续仿真，在多个线程中处理实时并行的操作更自然。而协程恰好为实现离散事件仿真提供了合理的抽象。SimPy是一个实现离散时间仿真的Python包，通过一个协程表示离散事件仿真系统中的各个进程。</p><p>本节说明如何只使用标准库提供的功能实现一个特别简单的离散事件仿真系统。</p><a id="more"></a><h1 id="出租车队运营仿真">出租车队运营仿真</h1><figure class="highlight python"><figcaption><span>taxi_sim.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">DEFAULT_NUMBER_OF_TAXIS = <span class="number">3</span>  <span class="comment"># 默认出租车数量</span></span><br><span class="line">DEFAULT_END_TIME = <span class="number">180</span>       <span class="comment"># 默认仿真钟结束时间</span></span><br><span class="line">SEARCH_DURATION = <span class="number">5</span>          <span class="comment"># 默认（空车）徘徊时间</span></span><br><span class="line">TRIP_DURATION = <span class="number">20</span>           <span class="comment"># 默认载客行驶时间</span></span><br><span class="line">DEPARTURE_INTERVAL = <span class="number">5</span>       <span class="comment"># 默认出库间隔时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 属性分别为 发生时间, 协程的key, 事件的名称</span></span><br><span class="line">Event = collections.namedtuple(<span class="string">'Event'</span>, <span class="string">'time proc action'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">taxi_process</span><span class="params">(ident, trips, start_time=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">"""每次状态变化时向仿真程序产出一个事件"""</span></span><br><span class="line">    time = <span class="keyword">yield</span> Event(start_time, ident, <span class="string">'leave garage'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(trips):</span><br><span class="line">        time = <span class="keyword">yield</span> Event(time, ident, <span class="string">'pick up passenger'</span>)</span><br><span class="line">        time = <span class="keyword">yield</span> Event(time, ident, <span class="string">'drop off passenger'</span>)</span><br><span class="line">    <span class="keyword">yield</span> Event(time, ident, <span class="string">'going home'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simulator</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, procs_map)</span>:</span>  <span class="comment"># 初始化时传入所有出租车的协程</span></span><br><span class="line">        self.events = queue.PriorityQueue()</span><br><span class="line">        self.procs = dict(procs_map)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, end_time)</span>:</span></span><br><span class="line">        <span class="string">"""调度并显示事件，直到时间结束"""</span></span><br><span class="line">        <span class="comment"># 调度各辆出租车的第一个事件</span></span><br><span class="line">        <span class="keyword">for</span> _, proc <span class="keyword">in</span> sorted(self.procs.items()):</span><br><span class="line">            first_event = next(proc)  <span class="comment"># 预激</span></span><br><span class="line">            self.events.put(first_event)  <span class="comment"># 将第一个事件放入events</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 此次仿真的主循环</span></span><br><span class="line">        sim_time = <span class="number">0</span>  <span class="comment"># 仿真钟</span></span><br><span class="line">        <span class="keyword">while</span> sim_time &lt; end_time:</span><br><span class="line">            <span class="keyword">if</span> self.events.empty():  <span class="comment"># 所有事件都已完成，即各出租车完成出库，完成指定数目的行程，入库</span></span><br><span class="line">                print(<span class="string">'*** end of events ***'</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            current_event = self.events.get()  <span class="comment"># 获得最早发生的事件</span></span><br><span class="line">            sim_time, proc_id, previous_action = current_event  <span class="comment"># 拆包</span></span><br><span class="line">            print(<span class="string">'taxi:'</span>, proc_id, proc_id * <span class="string">'    '</span>, current_event)  <span class="comment"># 打印事件内容</span></span><br><span class="line">            active_proc = self.procs[proc_id]  <span class="comment"># 根据事件的协程的key得到产出该事件的协程（出租车）</span></span><br><span class="line">            next_time = sim_time + compute_duration(previous_action)  <span class="comment"># 计算下一个事件的事件</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                next_event = active_proc.send(next_time)  <span class="comment"># 发送到协程，并得到协程可能产出的事件</span></span><br><span class="line">            <span class="keyword">except</span> StopIteration:  <span class="comment"># 如果协程结束</span></span><br><span class="line">                <span class="keyword">del</span> self.procs[proc_id]  <span class="comment"># 删除该协程</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.events.put(next_event)  <span class="comment"># 否则将产出的事件加入到优先队列中</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 如果因为超时而停止，则输出还有多少事件</span></span><br><span class="line">            msg = <span class="string">'*** end of simulation time: &#123;&#125; events pending ***'</span></span><br><span class="line">            print(msg.format(self.events.qsize()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_duration</span><span class="params">(previous_action)</span>:</span></span><br><span class="line">    <span class="string">"""使用指数分布计算操作的耗时"""</span></span><br><span class="line">    <span class="keyword">if</span> previous_action <span class="keyword">in</span> [<span class="string">'leave garage'</span>, <span class="string">'drop off passenger'</span>]:</span><br><span class="line">        <span class="comment"># 新状态是四处徘徊</span></span><br><span class="line">        interval = SEARCH_DURATION</span><br><span class="line">    <span class="keyword">elif</span> previous_action == <span class="string">'pick up passenger'</span>:</span><br><span class="line">        <span class="comment"># 新状态是行程开始</span></span><br><span class="line">        interval = TRIP_DURATION</span><br><span class="line">    <span class="keyword">elif</span> previous_action == <span class="string">'going home'</span>:</span><br><span class="line">        interval = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'Unknown previous_action: %s'</span> % previous_action)</span><br><span class="line">    <span class="keyword">return</span> int(random.expovariate(<span class="number">1</span>/interval)) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(end_time=DEFAULT_END_TIME, num_taxis=DEFAULT_NUMBER_OF_TAXIS, seed=None)</span>:</span></span><br><span class="line">    <span class="string">"""初始化随机生成器，构建过程，运行仿真程序"""</span></span><br><span class="line">    <span class="keyword">if</span> seed <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        random.seed(seed)  <span class="comment"># 获得可复现的结果</span></span><br><span class="line">    taxis = &#123;i: taxi_process(i, (i+<span class="number">1</span>)*<span class="number">2</span>, i*DEPARTURE_INTERVAL)</span><br><span class="line">             <span class="keyword">for</span> i <span class="keyword">in</span> range(num_taxis)&#125;  <span class="comment"># 协程的字典，每辆出租车对应一个协程</span></span><br><span class="line">    sim = Simulator(taxis)  <span class="comment"># 初始化</span></span><br><span class="line">    sim.run(end_time)  <span class="comment"># 运行仿真</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">'Taxi fleet simulator.'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-e'</span>, <span class="string">'--end-time'</span>, type=int, default=DEFAULT_END_TIME,</span><br><span class="line">                        help=<span class="string">'simulation end time; default = %s'</span></span><br><span class="line">                        % DEFAULT_END_TIME)</span><br><span class="line">    parser.add_argument(<span class="string">'-t'</span>, <span class="string">'--taxis'</span>, type=int, default=DEFAULT_NUMBER_OF_TAXIS,</span><br><span class="line">                        help=<span class="string">'number of taxis running; default = %s'</span></span><br><span class="line">                        % DEFAULT_NUMBER_OF_TAXIS)</span><br><span class="line">    parser.add_argument(<span class="string">'-s'</span>, <span class="string">'--seed'</span>, type=int, default=<span class="literal">None</span>,</span><br><span class="line">                        help=<span class="string">'random generator seed (for testing)'</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    main(args.end_time, args.taxis, args.seed)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/fluent-python/sample-run-with-three-taxis.png"></p><p>运行taxi_sim.py创建3辆车的输出示例。-s 3参数设置随机数生成器的种子，这样在调试和演示时可以重复运行程序，输出相同的结果。不同颜色的箭头是后来加上的，表示不同出租车的行程。有了箭头，能直观地看出如何使用协程管理并发的活动。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python taxi_sim.py -s 3 -e 60</span><br><span class="line">taxi: 0  Event(time=0, proc=0, action=&apos;leave garage&apos;)</span><br><span class="line">taxi: 0  Event(time=2, proc=0, action=&apos;pick up passenger&apos;)</span><br><span class="line">taxi: 1      Event(time=5, proc=1, action=&apos;leave garage&apos;)</span><br><span class="line">taxi: 1      Event(time=8, proc=1, action=&apos;pick up passenger&apos;)</span><br><span class="line">taxi: 2          Event(time=10, proc=2, action=&apos;leave garage&apos;)</span><br><span class="line">taxi: 2          Event(time=15, proc=2, action=&apos;pick up passenger&apos;)</span><br><span class="line">taxi: 2          Event(time=17, proc=2, action=&apos;drop off passenger&apos;)</span><br><span class="line">taxi: 0  Event(time=18, proc=0, action=&apos;drop off passenger&apos;)</span><br><span class="line">taxi: 2          Event(time=18, proc=2, action=&apos;pick up passenger&apos;)</span><br><span class="line">taxi: 2          Event(time=25, proc=2, action=&apos;drop off passenger&apos;)</span><br><span class="line">taxi: 1      Event(time=27, proc=1, action=&apos;drop off passenger&apos;)</span><br><span class="line">taxi: 2          Event(time=27, proc=2, action=&apos;pick up passenger&apos;)</span><br><span class="line">taxi: 0  Event(time=28, proc=0, action=&apos;pick up passenger&apos;)</span><br><span class="line">taxi: 2          Event(time=40, proc=2, action=&apos;drop off passenger&apos;)</span><br><span class="line">taxi: 2          Event(time=44, proc=2, action=&apos;pick up passenger&apos;)</span><br><span class="line">taxi: 1      Event(time=55, proc=1, action=&apos;pick up passenger&apos;)</span><br><span class="line">taxi: 1      Event(time=59, proc=1, action=&apos;drop off passenger&apos;)</span><br><span class="line">taxi: 0  Event(time=65, proc=0, action=&apos;drop off passenger&apos;)</span><br><span class="line">*** end of simulation time: 3 events pending ***</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> coroutines </tag>
            
            <tag> Fluent Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协程</title>
      <link href="/notes/fluent-python/coroutines/"/>
      <url>/notes/fluent-python/coroutines/</url>
      
        <content type="html"><![CDATA[<p>字典为动词 “to yield” 给出了两个释义：产出和让步。对于 Python 生成器中的 yield 来说，这两个含义都成立。<code>yield item</code> 这行代码会产出一个值，提供给 <code>next(...)</code> 的调用方；此外，还会作出让步，暂停执行生成器，让调用方继续工作，直到需要使用另一个值时再调用 <code>next()</code>。调用方会从生成器中拉取值。</p><h1 id="用作协程的生成器的基本行为">用作协程的生成器的基本行为</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可能是协程最简单的使用演示</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">simple_coroutine</span><span class="params">()</span>:</span>  <span class="comment"># 定义体中有yield关键字</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'-&gt; coroutine started'</span>)</span><br><span class="line"><span class="meta">... </span>    x = <span class="keyword">yield</span>  <span class="comment"># yield在表达式中使用</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'-&gt; coroutine received:'</span>, x)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro = simple_coroutine()  <span class="comment"># 与创建生成器一样，调用函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro  <span class="comment"># 得到生成器对象</span></span><br><span class="line">&lt;generator object simple_coroutine at <span class="number">0x101df2888</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(my_coro)  <span class="comment"># 首先要调用next()函数，因为生成器还没有启动</span></span><br><span class="line">-&gt; coroutine started  # 生成器启动，在yield处暂停</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro.send(<span class="number">42</span>)  <span class="comment"># 发送数据</span></span><br><span class="line">-&gt; coroutine received: 42  # 协程恢复，继续运行，打印出内容</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration  <span class="comment"># 生成器运行到末尾，抛出StopIteration异常</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>协程可以身处四个状态中的一个。当前状态可以使用 <code>inspect.getgeneratorstate(...)</code> 函数确定，该函数会返回下述字符串中的一个。</p><p><code>'GEN_CREATED'</code>：等待开始执行。</p><p><code>'GEN_RUNNING'</code>：解释器正在执行。只有在多线程应用中才能看到这个状态。此外，生成器对象在自己身上调用 getgeneratorstate 函数也行，不过这样做没什么用。</p><p><code>'GEN_SUSPENDED'</code>：在 yield 表达式出暂停。</p><p><code>'GEN_CLOSED'</code>：执行结束。</p><p>因为 send 方法的参数会成为暂停的 yield 表达式的值，所以，仅当协程处于暂停状态时才能调用 send 方法，例如 <code>my_coro.send(42)</code>。不过，如果协程还没激活（即，状态是 <code>'GEN_CREATED'</code>），情况就不同了。因此，始终要调用 <code>next(my_coro)</code> 激活协程；也可以调用 <code>my_coro.send(None)</code>，效果一样。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro = simple_coroutine()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro.send(<span class="number">42</span>)  <span class="comment"># 协程未激活</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: can‘t send non-<span class="literal">None</span> value to a just-started generator  <span class="comment"># 错误消息明确</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(my_coro), my_coro.send(<span class="number">42</span>)  <span class="comment"># 先激活</span></span><br><span class="line">-&gt; coroutine started</span><br><span class="line">-&gt; coroutine received: 42</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">simple_coro2</span><span class="params">(a)</span>:</span>  <span class="comment"># 举个产出多个值的例子</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'-&gt; Started: a ='</span>, a)</span><br><span class="line"><span class="meta">... </span>    b = <span class="keyword">yield</span> a  <span class="comment"># 产出a后暂停执行</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'-&gt; Received: b ='</span>, b)</span><br><span class="line"><span class="meta">... </span>    c = <span class="keyword">yield</span> a + b</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'-&gt; Received: c ='</span>, c)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro2 = simple_coro2(<span class="number">14</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> inspect <span class="keyword">import</span> getgeneratorstate</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getgeneratorstate(my_coro2)</span><br><span class="line"><span class="string">'GEN_CREATED'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(my_coro2)  <span class="comment"># 激活协程</span></span><br><span class="line">-&gt; Started: a = 14  # 输出的内容</span><br><span class="line"><span class="number">14</span>  <span class="comment"># 产出的内容</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getgeneratorstate(my_coro2)  <span class="comment"># 在第一个yield表达式处暂停，等待调用者为b赋值</span></span><br><span class="line"><span class="string">'GEN_SUSPENDED'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro2.send(<span class="number">28</span>)  <span class="comment"># 为b赋值</span></span><br><span class="line">-&gt; Received: b = 28</span><br><span class="line"><span class="number">42</span>  <span class="comment"># 产出a+b，然后在第二个yield表达式处暂停，等待为c赋值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro2.send(<span class="number">99</span>)</span><br><span class="line">-&gt; Received: c = 99</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getgeneratorstate(my_coro2)  <span class="comment"># 协程结束</span></span><br><span class="line"><span class="string">'GEN_CLOSED'</span></span><br></pre></td></tr></table></figure><h1 id="示例使用协程计算移动平均值">示例：使用协程计算移动平均值</h1><p>在讨论闭包时，我们分别用类和高阶函数实现了该功能。下面展示如何使用协程实现相同的功能。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    total = <span class="number">0.0</span></span><br><span class="line"><span class="meta">... </span>    count = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    average = <span class="literal">None</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># 无限循环，仅当调用方在协程上调用.close()方法，或者协程被垃圾回收程序回收时，这个协程才会终止</span></span><br><span class="line"><span class="meta">... </span>        term = <span class="keyword">yield</span> average  <span class="comment"># 首次会产出None</span></span><br><span class="line"><span class="meta">... </span>        total += term  <span class="comment"># 使用协程的好处是，total和count声明为局部变量即可</span></span><br><span class="line"><span class="meta">... </span>        count += <span class="number">1</span>     <span class="comment"># 无需使用实例属性或闭包在多次调用之间保持上下文</span></span><br><span class="line"><span class="meta">... </span>        average = total/count</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg = averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="literal">None</span>)  <span class="comment"># 使用.send(None)方式激活协程</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">10</span>)</span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">30</span>)</span><br><span class="line"><span class="number">20.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">5</span>)</span><br><span class="line"><span class="number">15.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getgeneratorstate(coro_avg)</span><br><span class="line"><span class="string">'GEN_CLOSED'</span></span><br></pre></td></tr></table></figure><h1 id="预激协程的装饰器">预激协程的装饰器</h1><p>如果不预激，那么协程没什么用。为了简化协程的用法，有时会使用一个预激装饰器。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">coroutine</span><span class="params">(func)</span>:</span>  <span class="comment"># 定义的预激装饰器</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">"""装饰器：向前直行到第一个yield表达式，预激func"""</span></span><br><span class="line"><span class="meta">... </span>    @wraps(func)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">primer</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>        gen = func(*args, **kwargs)  <span class="comment"># 调用被装饰的函数</span></span><br><span class="line"><span class="meta">... </span>        next(gen)  <span class="comment"># 激活生成器</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> gen  <span class="comment"># 返回生成器</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> primer  <span class="comment"># 返回包装好的方法</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>averager = coroutine(averager)  <span class="comment"># 装饰averager函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg = averager()  <span class="comment"># 创建一个生成器对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getgeneratorstate(coro_avg)  <span class="comment"># 已经准备好，可以接受值了</span></span><br><span class="line"><span class="string">'GEN_SUSPENDED'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">10</span>)</span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">30</span>)</span><br><span class="line"><span class="number">20.0</span></span><br></pre></td></tr></table></figure><p>很多框架都提供了处理协程的特殊装饰器，不过不是所有的装饰器都用于预激协程，有些会提供其他服务，例如勾入事件循环。</p><p>使用 yield from 句法调用协程时，会自动预激，因此与示例中的 <code>@coroutine</code> 装饰器不兼容。Python3.4 标准库里的 <code>asyncio.coroutine</code> 装饰器不会预激协程，因此能兼容 yield from 句法。</p><h1 id="终止协程和异常处理">终止协程和异常处理</h1><p>协程中未处理的异常会向上冒泡，传给 next 函数或 send 方法的调用方（即触发协程的对象）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg = averager()  <span class="comment"># 预激的协程</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">40</span>)</span><br><span class="line"><span class="number">40.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">50</span>)</span><br><span class="line"><span class="number">45.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="string">'spam'</span>)  <span class="comment"># 发送的不是数字，协程会因此终止</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">7</span>, <span class="keyword">in</span> averager</span><br><span class="line">TypeError: unsupported operand type(s) <span class="keyword">for</span> +=: <span class="string">'float'</span> <span class="keyword">and</span> <span class="string">'str'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">60</span>)  <span class="comment"># 无法重新激活</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><p>上例暗示了终止协程的一种方式：<strong>发送某个哨符值，让协程退出。</strong>内置的 None 和 Ellipsis 等常量经常用作哨符值。Ellipsis 的优点是，数据流中不太常用这个值。我还见过有人把 StopIteration 类（类本身，而不是实例，也不抛出）作为哨符值：<code>my_coro.send(StopIteration)</code>。</p><p>从 Python2.5 开始，客户代码可以在生成器对象上调用两个方法，显式地把异常发给协程。这两个方法是 throw 和 close。</p><p><code>generator.throw(exc_type[, exc_value[, traceback]])</code></p><p>致使生成器在暂停的 yield 表达式处抛出指定的异常。如果生成器处理了抛出的异常，代码会向前执行到下一个 yield 表达式，而产出的值会成为调用 <code>generator.throw</code> 方法得到的返回值。如果生成器没有处理抛出的异常，异常会向上冒泡，传到调用方的上下文中。</p><p><code>generator.close()</code></p><p>致使生成器在暂停的 yield 表达式处抛出 GeneratorExit 异常。如果生成器没有处理这个异常，或者抛出了 StopIteration 异常（通常是指运行到结尾），调用方不会报错。如果收到 GeneratorExit 异常，生成器一定不能产出值，否则解释器会抛出 RuntimeError 异常。生成器抛出的其他异常会向上冒泡，传给调用方。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">DemoException</span><span class="params">(Exception)</span>:</span> <span class="keyword">pass</span>  <span class="comment"># 为演示定义的异常</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">demo_exc_handling</span><span class="params">()</span>:</span>  <span class="comment"># 学习在协程中处理异常</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'-&gt; coroutine started'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>            x = <span class="keyword">yield</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">except</span> DemoException:  <span class="comment"># 特别处理DemoException异常</span></span><br><span class="line"><span class="meta">... </span>            print(<span class="string">'*** DemoException handled. Continuing...'</span>)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">else</span>:  <span class="comment"># 如果没有异常，那么显示接收到的值</span></span><br><span class="line"><span class="meta">... </span>            print(<span class="string">'-&gt; coroutine received: &#123;!r&#125;'</span>.format(x))</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> RuntimeError(<span class="string">'This line should never run.'</span>)  <span class="comment"># 这行代码不会执行，因为只有未处理的异常</span></span><br><span class="line"><span class="meta">... </span>                                        <span class="comment"># 才会中止无限循环，而一旦出现未处理的异常，协程会立即终止</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>exc_coro = demo_exc_handling()  <span class="comment"># 创建</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(exc_coro)  <span class="comment"># 激活</span></span><br><span class="line">-&gt; coroutine started</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>exc_coro.send(<span class="number">11</span>)</span><br><span class="line">-&gt; coroutine received: 11</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>exc_coro.throw(DemoException)</span><br><span class="line">*** DemoException handled. Continuing...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> inspect <span class="keyword">import</span> getgeneratorstate</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getgeneratorstate(exc_coro)  <span class="comment"># DemoException异常不会导致协程中止</span></span><br><span class="line"><span class="string">'GEN_SUSPENDED'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>exc_coro.throw(ZeroDivisionError)  <span class="comment"># 未处理的异常会导致协程中止</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">5</span>, <span class="keyword">in</span> demo_exc_handling</span><br><span class="line">ZeroDivisionError</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getgeneratorstate(exc_coro)</span><br><span class="line"><span class="string">'GEN_CLOSED'</span></span><br></pre></td></tr></table></figure><p>如果不管协程如何结束都想做些清理工作，要把协程定义体中相关代码放入 try/finally 块中。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo_finally</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'-&gt; coroutine started'</span>)</span><br><span class="line">    <span class="keyword">try</span>:  <span class="comment"># 定义体放入try/finally块中</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                x = <span class="keyword">yield</span></span><br><span class="line">            <span class="keyword">except</span> DemoException:</span><br><span class="line">                print(<span class="string">'*** DemoException handled. Continuing...'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">'-&gt; coroutine received: &#123;!r&#125;'</span>.format(x))</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        print(<span class="string">'-&gt; coroutine ending'</span>)</span><br></pre></td></tr></table></figure><h1 id="让协程返回值">让协程返回值</h1><p>为了说明如何返回值，每次激活协程时不会产出移动平均值。这么做是为了强调某些协程不会产出值，而是在最后返回一个值（通常是某种累计值）。</p><figure class="highlight python"><figcaption><span>coroaverager2.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Result = namedtuple(<span class="string">'Result'</span>, <span class="string">'count average'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">()</span>:</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">if</span> term <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 为了返回值，协程必须正常终止，因此加了个判断条件</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br><span class="line">      <span class="keyword">return</span> Result(count, average)  <span class="comment"># 在Python3.3之前，如果生成器返回值，解释器会报句法错误</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> coroaverager2 <span class="keyword">import</span> averager</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg = averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(coro_avg)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">6.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    coro_avg.send(<span class="literal">None</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> StopIteration <span class="keyword">as</span> exc:</span><br><span class="line"><span class="meta">... </span>    result = exc.value  <span class="comment"># 异常对象的value属性保存着返回的值</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result</span><br><span class="line">Result(count=<span class="number">3</span>, average=<span class="number">15.5</span>)</span><br></pre></td></tr></table></figure><p><strong>return 表达式的值会偷偷传给调用方，赋值给 StopIteration 异常的一个属性。</strong>这样做有点不合常理，但是能保留生成器对象的常规行为——耗尽时抛出 StopIteration 异常。</p><p>获取协程的返回值虽然要饶个圈子，但这是 PEP 380 定义的方式，当我们意识到这一点后就说得通了：yield from 结构会在内部自动捕获 StopIteration 异常。这种处理方式与 for 循环处理 StopIteration 异常的方式一样：循环机制使用用于易于理解的方式处理异常。对 yield from 结构来说，解释器不仅会捕获 StopIteration 异常，还会把 value 属性的值变成 yield from 表达式的值。</p><h1 id="使用-yield-from">使用 yield from</h1><p>yield from 是全新的语言结构，它的作用比 yield 多很多。在生成器 gen 中使用 <code>yield from subgen()</code> 时，subgen 会获得控制权，把产出的值传给 gen 的调用方，即调用方可以直接控制 subgen。与此同时，gen 会阻塞，等待 subgen 终止。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">'AB'</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">yield</span> c</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">3</span>):</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">yield</span> i</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(gen())</span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span>  <span class="comment"># 可以改写为</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="keyword">from</span> <span class="string">'AB'</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="keyword">from</span> range(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(gen())</span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">chain</span><span class="params">(*iterables)</span>:</span>  <span class="comment"># python版本的chain函数，原函数用C语言编写并且做了优化</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> it <span class="keyword">in</span> iterables:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">yield</span> <span class="keyword">from</span> it</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = tuple(range(<span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(chain(s, t))</span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><code>yield from x</code> 表达式对 x 对象所做的第一个件事是，调用 <code>iter(x)</code>，从中获取迭代器。因此，x 可以是任何可迭代的对象。</p><p>可是，如果 yield from 结构唯一的作用是替代产出值的嵌套 for 循环，这个结构很有可能不会添加到 Python 语言中。yield from 结构的本质作用无法通过简单的可迭代对象说明，而要发散思维，使用嵌套的生成器。因此，引入 yield from 结构的 PEP 380 才起了 ”Syntax for Delegatinig to a Subgenerator“（”把职责委托给子生成器的句法“）这个标题。</p><p><strong>yield from 的主要功能是打开双向通道，把最外层的调用方与最内层的子生成器连接起来，这样二者可以直接发送和产出值，还可以直接传入异常，而不用在位于中间的协程中添加大量处理异常的样板代码。</strong>有个这个结构，协程可以通过以前不可能的方式委托职责。</p><p>若想使用 yield from 结构，就要大幅改动代码。为了说明需要改动的部分，PEP 380 使用了一些专门的术语。</p><p>委派生成器：包含 <code>yield from &lt;iterable&gt;</code> 表达式的生成器函数。</p><p>子生成器：从 yield from 表达式中 <code>&lt;iterable&gt;</code> 部分获取的生成器。这就是 PEP 380 的标题中所说的子生成器（subgenerator）。</p><p>调用方：调用委派生成器的客户端代码。</p><p><img src="/uploads/image/fluent-python/yield_from_at_work.png"></p><p>委派生成器在 yield from 表达式处暂停时，调用方可以直接把数据发给子生成器，子生成器再把产出的值发给调用方。子生成器返回之后，解释器会抛出 StopIteration 异常，并把返回值附加到异常对象上，此时委派生成器会恢复。</p><figure class="highlight python"><figcaption><span>coroaverager3.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Result = namedtuple(<span class="string">'Result'</span>, <span class="string">'count average'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">()</span>:</span>  <span class="comment"># 代码不变，这里作为子生成器使用</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">if</span> term <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 至关重要的终止条件。如果不这么做，使用yield from</span></span><br><span class="line">            <span class="keyword">break</span>         <span class="comment"># 调用这个协程的生成器会永远阻塞</span></span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br><span class="line">    <span class="keyword">return</span> Result(count, average)  <span class="comment"># 返回的Result会成为调用方中yield from表达式的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 委派生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grouper</span><span class="params">(results, key)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># grouper发送的每个值都会经由yield from处理，通过管道传给averager实例</span></span><br><span class="line">        <span class="comment"># grouper会在yield from表达式处暂停，等待averager实例处理客户端发来的值</span></span><br><span class="line">        <span class="comment"># averager实例运行完毕后，返回的值绑定到results[key]上</span></span><br><span class="line">        results[key] = <span class="keyword">yield</span> <span class="keyword">from</span> averager()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端代码，即调用方。这是驱动一切的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(data)</span>:</span></span><br><span class="line">    results = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key, values <span class="keyword">in</span> data.items():</span><br><span class="line">        group = grouper(results, key)  <span class="comment"># 创建group协程</span></span><br><span class="line">        next(group)  <span class="comment"># 预激</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> values:  <span class="comment"># 把各个value传给grouper。传入的值最终到达averager函数中term = yield那一行</span></span><br><span class="line">            group.send(value)  <span class="comment"># grouper永远不知道传入的值是什么</span></span><br><span class="line">        <span class="comment"># 把None传入grouper，导致当前的averager实例终止，也让grouper继续运行</span></span><br><span class="line">        <span class="comment"># 如果没有这一行，那么averager子生成器永远不会终止，委派生成器group永远不会再次激活</span></span><br><span class="line">        <span class="comment"># 因此永远不会为results[key]赋值</span></span><br><span class="line">        group.send(<span class="literal">None</span>)  </span><br><span class="line">    report(results)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出报告</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">report</span><span class="params">(results)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> key, result <span class="keyword">in</span> sorted(results.items()):</span><br><span class="line">        group, unit = key.split(<span class="string">';'</span>)</span><br><span class="line">        print(<span class="string">'&#123;:2&#125; &#123;:5&#125; averaging &#123;:.2f&#125;&#123;&#125;'</span>.format(</span><br><span class="line">            result.count, group, result.average, unit))</span><br><span class="line"></span><br><span class="line">data = &#123;  <span class="comment"># 男女学生的体重和身高</span></span><br><span class="line">    <span class="string">'girls;kg'</span>:</span><br><span class="line">        [<span class="number">40.9</span>, <span class="number">38.5</span>, <span class="number">44.3</span>, <span class="number">42.2</span>, <span class="number">45.2</span>, <span class="number">41.7</span>, <span class="number">44.5</span>, <span class="number">39.0</span>, <span class="number">40.6</span>, <span class="number">44.5</span>],</span><br><span class="line">    <span class="string">'girls;m'</span>:</span><br><span class="line">        [<span class="number">1.6</span>, <span class="number">1.51</span>, <span class="number">1.4</span>, <span class="number">1.3</span>, <span class="number">1.41</span>, <span class="number">1.39</span>, <span class="number">1.33</span>, <span class="number">1.46</span>, <span class="number">1.45</span>, <span class="number">1.43</span>],</span><br><span class="line">    <span class="string">'boys;kg'</span>:</span><br><span class="line">        [<span class="number">39.0</span>, <span class="number">40.8</span>, <span class="number">43.2</span>, <span class="number">40.8</span>, <span class="number">43.1</span>, <span class="number">38.6</span>, <span class="number">41.4</span>, <span class="number">40.6</span>, <span class="number">36.3</span>],</span><br><span class="line">    <span class="string">'boys;m'</span>:</span><br><span class="line">        [<span class="number">1.38</span>, <span class="number">1.5</span>, <span class="number">1.32</span>, <span class="number">1.25</span>, <span class="number">1.37</span>, <span class="number">1.48</span>, <span class="number">1.25</span>, <span class="number">1.49</span>, <span class="number">1.46</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main(data)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python coroaverager3.py</span><br><span class="line"> 9 boys  averaging 40.42kg</span><br><span class="line"> 9 boys  averaging 1.39m</span><br><span class="line">10 girls averaging 42.14kg</span><br><span class="line">10 girls averaging 1.43m</span><br></pre></td></tr></table></figure><p>grouper 函数中循环的目的：在 <code>averager()</code> 返回结果，并将结果绑定到 <code>results[key]</code> 上之后，生成器能够继续运行至下一个 yield 处，而不是抛出StopIteration 异常。如果不使用循环，下面的方法同样可以完成任务。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grouper</span><span class="params">(results, key)</span>:</span></span><br><span class="line">    results[key] = <span class="keyword">yield</span> <span class="keyword">from</span> averager()</span><br><span class="line">    _ = <span class="keyword">yield</span>  <span class="comment"># group.send(None)之后，group会暂停在此处，然后调用方会重新</span></span><br><span class="line">               <span class="comment"># 创建grouper并绑定到group变量上，旧的grouper会被垃圾回收程序回收</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grouper</span><span class="params">(results, key)</span>:</span></span><br><span class="line">    results[key] = <span class="keyword">yield</span> <span class="keyword">from</span> averager()  <span class="comment"># 不做处理</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(data)</span>:</span></span><br><span class="line">    results = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key, values <span class="keyword">in</span> data.items():</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            group.send(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:  <span class="comment"># 在调用方捕获异常</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    report(results)</span><br></pre></td></tr></table></figure><p>示例展示了 yield from 结构最简单的用法，只有一个委派生成器和一个子生成器。因为委派生成器相当于管道，所以可以把任意数量个委派生成器连接在一起：一个委派生成器使用 yield from 调用一个子生成器，而那个子生成器本身也是委派生成器，使用 yield from 调用另一个子生成器，以此类推。最终，这个链条要以一个只使用 yield 表达式的简单生成器结束；不过，也能以任何可迭代的对象结束（yield from iterable）。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> coroutines </tag>
            
            <tag> Fluent Python </tag>
            
            <tag> yield </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上下文管理器和else块</title>
      <link href="/notes/fluent-python/context-managers-and-else-blocks/"/>
      <url>/notes/fluent-python/context-managers-and-else-blocks/</url>
      
        <content type="html"><![CDATA[<h1 id="if语句之外的else块">if语句之外的else块</h1><p>else子句不仅能在if语句中使用，还能在for、while和try语句中使用。for/else、while/else和try/else的语义关系紧密，不过与if/else差别很大。</p><p>for：仅当for循环运行完毕时（即for循环没有被break语句终止）才运行else块。</p><p>while：仅当while循环因为条件为假值而退出时（即while循环没有被break语句终止）才运行else块。</p><p>try：仅当try块中没有异常抛出时才运行else块。else子句抛出的异常不会由前面的except子句处理。</p><p>在所有情况下，如果异常或者return、break或continue语句导致控制权跳到了复合语句的主块之外，else子句也会被跳过。</p><p>在这些语句中使用else子句通常能让代码更易于阅读，而且能省去一些麻烦，不用设值控制标志或者添加额外的if语句。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在循环中使用else子句</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> my_list:</span><br><span class="line">    <span class="keyword">if</span> item.flavor == <span class="string">'banana'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">'No banana flavor found!'</span>)</span><br><span class="line"><span class="comment"># 这样呢，我就是不喜欢用for/else</span></span><br><span class="line">have_banana_flavor = any(item.flavor == <span class="string">'banana'</span> <span class="keyword">for</span> item <span class="keyword">in</span> my_list)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> have_banana_flavor:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">'No banana flavor found!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在try/except块中使用else子句</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    dangerous_call()</span><br><span class="line">    after_call()  <span class="comment"># after_call()不应该放在try块中，为了清晰和准确，try块中</span></span><br><span class="line"><span class="keyword">except</span> OSError:   <span class="comment"># 应该只包含抛出预期异常的语句</span></span><br><span class="line">    log(<span class="string">'OSError...'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因此，像下面这样写更好</span></span><br><span class="line"><span class="keyword">try</span>:  <span class="comment"># try块防守的是可能出现的错误</span></span><br><span class="line">    dangerous_call()</span><br><span class="line"><span class="keyword">except</span> OSError:</span><br><span class="line">    log(<span class="string">'OSError...'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    after_call()</span><br></pre></td></tr></table></figure><p>在Python中，try/except不仅用于处理错误，还常用于控制流程。为此，Python官方词汇表还定义了一个缩略词（口号）。</p><p><strong>EAFP</strong>：取得原谅比获得许可容易（easier to ask for forgiveness than permission）。这是一种常见的Python编程风格，先假定存在有效的键或属性，如果假定不成立，那么捕获异常。这种风格简单明快，特点是代码中有很多try和except语句。与其他很多语言一样，这种风格的对立面是LBYL风格。</p><p><strong>LBYL</strong>：三思而后行（look before you leap）。这种编程风格在调用函数或查找属性或键之前显式测试前提条件。与EAFP风格相反，这种风格的特点是代码中有很多if语句。在多线程环境中，LBYL风格可能会在“检查”和“行事”的空当引入条件竞争。例如，对if key in mapping: return mapping[key]这段代码来说，如果在测试之后，但是在查找之前，另一个线程从映射中删除了那个键，那么这段代码就会失败。这个问题可以用锁或者EAFP风格解决。如果选择EAFP风格，那就要更深入地了解else子句，并在try/except语句中合理使用。</p><h1 id="上下文管理器和with块">上下文管理器和with块</h1><p>上下文管理器对象存在的目的是管理with语句，就像迭代器的存在是为了管理for语句一样。</p><p>with语句的目的是简化try/finally模式。这种模式用于保证一段代码运行完毕后执行某项操作，即便那段代码由于异常、return语句或sys.exit()调用而中止，也会执行指定的操作。finally子句中的代码通常用于释放重要的资源，或者还原临时变更的状态。</p><p>上下文管理器协议包含<code>__enter__</code>和<code>__exit__</code>两个方法。with语句开始运行时，会在上下文管理器对象上调用<code>__enter__</code>方法。with语句运行结束后，会在上下文管理器对象上调用<code>__exit__</code>方法，以此扮演finally子句的角色。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最常见的例子是确保关闭文件对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'class.wsd'</span>) <span class="keyword">as</span> fp:  <span class="comment"># fp绑定到打开的文件上，因为文件的__enter__方法返回self</span></span><br><span class="line"><span class="meta">... </span>    src = fp.read(<span class="number">60</span>)  <span class="comment"># 读取一些数据</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(src)</span><br><span class="line"><span class="number">60</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp  <span class="comment"># fp仍然可用，与函数和模块不同，with块没有定义新的作用域</span></span><br><span class="line">&lt;_io.TextIOWrapper name=<span class="string">'class.wsd'</span> mode=<span class="string">'r'</span> encoding=<span class="string">'UTF-8'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp.closed, fp.encoding  <span class="comment"># 可以读取fp对象的属性</span></span><br><span class="line">(<span class="literal">True</span>, <span class="string">'UTF-8'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp.read(<span class="number">60</span>)  <span class="comment"># 但不能在fp上执行I/O操作，因为在with块的末尾，调用TextIOWrapper.__exit__方法把文件关闭了</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: I/O operation on closed file.</span><br></pre></td></tr></table></figure><p><strong>执行with后面的表达式得到的结果是上下文管理器对象，不过把值绑定到目标变量上（as子句）是在上下文管理器对象上调用<code>__enter__</code>方法的结果。</strong>碰巧，示例中的open()函数返回TextIOWrapper类的实例，而该实例的<code>__enter__</code>方法返回self。不过<code>__enter__</code>方法除了返回上下文管理器之外，还可能返回其他对象。</p><p>不管控制流程以哪种方式退出with块，都会在上下文管理器对象上调用<code>__exit__</code>方法，而不是在<code>__enter__</code>方法返回的对象上调用。</p><p>with语句的as子句是可选的。对open函数来说，必须加上as子句，以便获取文件的引用。不过，有些上下文管理器会返回None，因为没什么有用的对象能提供给用户。</p><figure class="highlight python"><figcaption><span>mirror.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LookingGlass</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">import</span> sys</span><br><span class="line">        self.original_write = sys.stdout.write</span><br><span class="line">        sys.stdout.write = self.reverse_write  <span class="comment"># 通过猴子补丁替换成自己的反向输出方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'ABCDE'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_write</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.original_write(text[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_value, traceback)</span>:</span>  <span class="comment"># 如果一切正常，传入的参数是None, None, None</span></span><br><span class="line">        <span class="keyword">import</span> sys</span><br><span class="line">        sys.stdout.write = self.original_write  <span class="comment"># 退出时再换回来</span></span><br><span class="line">        <span class="keyword">if</span> exc_type <span class="keyword">is</span> ZeroDivisionError:  <span class="comment"># 如果有ZeroDivisionError类型异常</span></span><br><span class="line">            print(<span class="string">'Please DO NOT divide by zero!'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span>  <span class="comment"># 返回True，告诉解释器，异常已经处理了</span></span><br><span class="line">        <span class="comment"># 如果__exit__方法返回None，或者True之外的值，with块中的任何异常都会向上冒泡</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> mirror <span class="keyword">import</span> LookingGlass</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> LookingGlass() <span class="keyword">as</span> what:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Hello World!'</span>)</span><br><span class="line"><span class="meta">... </span>    print(what)</span><br><span class="line">...</span><br><span class="line">!dlroW olleH  <span class="comment"># 在with块中输出的内容都是反向的</span></span><br><span class="line">EDCBA</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>what  <span class="comment"># __enter__返回的结果存在what变量中</span></span><br><span class="line"><span class="string">'ABCDE'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(what)  <span class="comment"># 输出不再反向了</span></span><br><span class="line">ABCDE</span><br></pre></td></tr></table></figure><p><strong>在实际使用中，如果应用程序接管了标准输出，可能会把sys.stdout换成类似文件的其他对象，然后再切换成原来的版本。</strong><a href="https://devdocs.io/python~3.6/library/contextlib#contextlib.redirect_stdout" target="_blank" rel="noopener">contextlib.redirect_stdout</a>上下文管理器就是这么做的：只需传入类似文件的对象，用于替代sys.stdout。</p><p>解释器调用<code>__enter__</code>方法时，除了隐式的self之外，不会传入任何参数。传给<code>__exit__</code>方法的三个参数如下：</p><p>exc_type：异常类（例如ZeroDivisionError）。</p><p>exc_value：异常实例。有时会有参数传给异常构造方法，例如错误消息，这些参数可以使用exc_value.args获取。</p><p>traceback：trackback对象。</p><p>在try/finally语句的finally块中调用sys.exc_info()得到的就是<code>__exit__</code>接收的这三个参数。鉴于with语句是为了取代大多数try/finally语句，而且通常需要调用sys.exc_info()来判断做什么清理操作，这种行为是合理的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 上下文管理器的具体工作方式</span></span><br><span class="line"><span class="comment"># 在这个示例中，我们在with块之外使用LookingGlass类</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>manager = LookingGlass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>manager</span><br><span class="line">&lt;mirror.LookingGlass object at <span class="number">0x104f5f390</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>monster = manager.__enter__()  <span class="comment"># 从此进入镜中世界</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>monster</span><br><span class="line"><span class="string">'EDCBA'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>monster == <span class="string">'ABCDE'</span></span><br><span class="line">eurT</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>manager</span><br><span class="line">&gt;<span class="number">093</span>f5f401x0 ta tcejbo ssalGgnikooL.rorrim&lt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>manager.__exit__(<span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>)  <span class="comment"># 退出</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>monster</span><br><span class="line"><span class="string">'ABCDE'</span></span><br></pre></td></tr></table></figure><h1 id="contextlib模块中的实用工具">contextlib模块中的实用工具</h1><p>除了前面提到的redirect_stdout函数，contextlib模块中还有一些类和其他函数，使用范围更广。</p><p>closing：如果对象提供了close()方法，但没有实现<code>__enter__/__exit__</code>协议，那么可以使用这个函数构建上下文管理器。</p><p>suppress：构建临时忽略指定异常的上下文管理器。</p><p><span class="citation" data-cites="contextmanager">@contextmanager</span>：这个装饰器把简单的生成器函数变成上下文管理器，这样就不用创建类去实现管理器协议了。</p><p>ContextDecorator：这是个基类，用于定义基于类的上下文管理器。这种上下文管理器也能用于装饰器函数，在受管理的上下文中运行整个函数。</p><p>ExitStack：这个上下文管理器能进入多个上下文管理器。with块结束时，ExitStack按照后进先出的顺序调用栈中各个上下文管理器的<code>__exit__</code>方法。如果事先不知道with块要进入多少个上下文管理器，可以使用这个类。例如，同时打开任意一个文件列表中的所有文件。</p><p>在这些实用工具中，使用最广泛的是@contextmanager装饰器。这个装饰器也有迷惑人的一面，因为它与迭代无关，却要使用yield语句。</p><h1 id="使用contextmanager">使用@contextmanager</h1><p><span class="citation" data-cites="contextmanager装饰器能减少创建上下文管理器的样板代码量">@contextmanager装饰器能减少创建上下文管理器的样板代码量</span>，因为不用编写一个完整的类，定义<code>__enter__</code>和<code>__exit__</code>方法，而只需实现有一个yield语句的生成器，生成想让<code>__enter__</code>方法返回的值。</p><p>在使用@contextmanager装饰的生成器中，yield语句的作用是把函数的定义体分成两部分：yield语句前面的所有代码在with块开始时（即解释器调用<code>__enter__</code>方法时）执行，yield语句后面的代码在with块结束时（即调用<code>__exit__</code>方法时）执行。</p><figure class="highlight python"><figcaption><span>mirror_gen.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextlib.contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">looking_glass</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    original_write = sys.stdout.write</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_write</span><span class="params">(text)</span>:</span></span><br><span class="line">        original_write(text[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    sys.stdout.write = reverse_write</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'ABCDE'</span></span><br><span class="line">    sys.stdout.write = original_write</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> mirror_gen <span class="keyword">import</span> looking_glass</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> looking_glass() <span class="keyword">as</span> what:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Hello World!'</span>)</span><br><span class="line"><span class="meta">... </span>    print(what)</span><br><span class="line">...</span><br><span class="line">!dlroW olleH</span><br><span class="line">EDCBA</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>what</span><br><span class="line"><span class="string">'ABCDE'</span></span><br></pre></td></tr></table></figure><p>其实，contextlib.contextmanager装饰器会把函数包含成实现<code>__enter__</code>和<code>__exit__</code>方法的类。这个类的<code>__enter__</code>方法有如下作用：</p><ol type="1"><li>调用生成器函数，保存生成器对象（这里把它称为gen）。</li><li>调用next(gen)，执行到yield关键字所在的位置。</li><li>返回next(gen)产出的值，以便把产出的值绑定到with/as语句中的目标变量上。</li></ol><p>with块终止时，<code>__exit__</code>方法会做以下几件事：</p><ol type="1"><li>检查有没有把异常传给exc_type；如果有，调用gen.throw(exception)，在生成器函数定义体中包含yield关键字的那一行抛出异常。</li><li>否则，调用next(gen)，继续执行生成器函数定义体中yield语句之后的代码。</li></ol><p>上述示例中有一个严重的错误：如果在with块中抛出了异常，Python解释器会将其捕获，然后再looking_glass函数的yield表达式里再次抛出。但是，那里没有处理错误的代码，因此looking_glass函数会终止，永远无法恢复成原来的sys.stdout.write方法，导致系统处于无效状态。</p><p>下面的实例中添加了一些代码，特别用于处理ZeroDivisionError异常；这样，在功能上它就与基于类的实现等效了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextlib.contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">looking_glass</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    original_write = sys.stdout.write</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_write</span><span class="params">(text)</span>:</span></span><br><span class="line">        original_write(text[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    sys.stdout.write = reverse_write</span><br><span class="line">    msg = <span class="string">''</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">'ABCDE'</span></span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        msg = <span class="string">'Please DO NOT divide by zero!'</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        sys.stdout.write = original_write  <span class="comment"># 撤销猴子补丁</span></span><br><span class="line">        <span class="keyword">if</span> msg:  <span class="comment"># 有错误消息就输出</span></span><br><span class="line">            print(msg)</span><br></pre></td></tr></table></figure><p>前面说过，为了告诉解释器异常已经处理了，<code>__exit__</code>方法会返回True，此时解释器会压制异常。如果<code>__exit__</code>方法没有显式返回一个值，那么解释器得到的是None，然后向上冒泡异常。<strong>使用@contextmanager装饰器时，默认的行为是相反的：装饰器提供的<code>__exit__</code>方法假定发给生成器的所有异常都得到处理了，因此应该压制异常。</strong>如果不想让@contextmanager压制异常，必须在被装饰的函数中显式重新抛出异常。</p><p><strong>使用@contextmanager装饰器时，要把yield语句放在try/finally语句中（或者放在with语句中），这是无法避免的，因为我们永远不知道上下文管理器的用户会在with块中做什么。</strong></p><p>除了标准库中举的例子之外，Martijn Pieters实现的原地文件重写上下文管理器<a href="http://www.zopatista.com/python/2013/11/26/inplace-file-rewriting/" target="_blank" rel="noopener"><code>inplace</code></a>是@contextmanager不错的使用实例。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用inplace上下文管理器，它为同一个文件提供了两个句柄，以便同时读写同一个文件</span></span><br><span class="line"><span class="keyword">with</span> inplace(csvfilename, <span class="string">'r'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> (infh, outfh):</span><br><span class="line">    reader = csv.reader(infh)</span><br><span class="line">    writer = csv.writer(outfh)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        row += [<span class="string">'new'</span>, <span class="string">'columns'</span>]</span><br><span class="line">        writer.writerow(row)</span><br></pre></td></tr></table></figure><p><strong>在@contextmanager装饰器装饰的生成器中，yield与迭代没有任何关系。</strong>在本节所举的示例中，生成器函数的作用更像是协程：执行到某一点时暂停，让客户代码运行，直到客服让协程继续做事。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> contextlib </tag>
            
            <tag> with </tag>
            
            <tag> for/else </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标准库中的生成器函数</title>
      <link href="/notes/fluent-python/generator-functions-in-standard-library/"/>
      <url>/notes/fluent-python/generator-functions-in-standard-library/</url>
      
        <content type="html"><![CDATA[<p>本节专注于通用的函数：参数为任意的可迭代对象，返回值是生成器，用于生成选中的、计算出的和重新排列的元素。</p><h1 id="用于过滤">用于过滤</h1><p>从输入的可迭代对象中产出元素的子集，而且不修改元素本身。</p><table><colgroup><col style="width: 10%"><col style="width: 20%"><col style="width: 70%"></colgroup><thead><tr class="header"><th>模块</th><th>函数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>itertools</code></td><td><code>compress(it, selector_it)</code></td><td>并行处理两个可迭代对象；如果selector_it中的元素是真值，产出it中对应的元素</td></tr><tr class="even"><td><code>itertools</code></td><td><a href="https://devdocs.io/python~3.6/library/itertools#itertools.dropwhile" target="_blank" rel="noopener"><code>dropwhile(predicate, it)</code></a></td><td>扔掉满足条件的元素，predicate首次返回Flase时，停止检查，产出后续元素（不再检查）</td></tr><tr class="odd"><td>内置</td><td><code>filter(predicate, it)</code></td><td>把it中的各个元素传给predicate，如果predicate(item)返回真值，那么产出对应的元素；如果predicate是None，那么只产出真值元素</td></tr><tr class="even"><td><code>itertools</code></td><td><code>filterfalse(predicate, it)</code></td><td>与filter函数的作用类似，不过predicate的逻辑是相反的：predicate返回假值时产出对应的元素</td></tr><tr class="odd"><td><code>itertools</code></td><td><code>islice(it, stop)</code>或<code>islice(it, start, stop, step=1</code></td><td>产出it的切片，作用类似于s[:stop]或s[start:stop:step]，不过it可以是任何可迭代的对象，而且这个函数实现的是惰性操作</td></tr><tr class="even"><td><code>itertools</code></td><td><a href="https://devdocs.io/python~3.6/library/itertools#itertools.takewhile" target="_blank" rel="noopener"><code>takewhile(predicate, it)</code></a></td><td>产出满足条件的元素，predicate首次返回False时立即停止，不产出后续元素</td></tr></tbody></table><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">vowel</span><span class="params">(c)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> c.lower() <span class="keyword">in</span> <span class="string">'aeiou'</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(filter(vowel, <span class="string">'Aardvark'</span>))</span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> itertools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.filterfalse(vowel, <span class="string">'Aardvark'</span>))</span><br><span class="line">[<span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'v'</span>, <span class="string">'r'</span>, <span class="string">'k'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.dropwhile(vowel, <span class="string">'Aardvark'</span>))</span><br><span class="line">[<span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'v'</span>, <span class="string">'a'</span>, <span class="string">'r'</span>, <span class="string">'k'</span>]  <span class="comment"># 'r'是首个不满足条件的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.takewhile(vowel, <span class="string">'Aardvark'</span>))</span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'a'</span>]  <span class="comment"># 'A', 'a'都满足条件，'r'是首个不满足条件的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.compress(<span class="string">'Aardvark'</span>, (<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>)))</span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.islice(<span class="string">'Aardvark'</span>, <span class="number">4</span>))</span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'a'</span>, <span class="string">'r'</span>, <span class="string">'d'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.islice(<span class="string">'Aardvark'</span>, <span class="number">4</span>, <span class="number">7</span>))</span><br><span class="line">[<span class="string">'v'</span>, <span class="string">'a'</span>, <span class="string">'r'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.islice(<span class="string">'Aardvark'</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>))</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>]</span><br></pre></td></tr></table></figure><h1 id="用于映射">用于映射</h1><table><colgroup><col style="width: 10%"><col style="width: 20%"><col style="width: 70%"></colgroup><thead><tr class="header"><th>模块</th><th>函数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>itertools</code></td><td><code>accumulate(it, [func]</code></td><td>产出累计的总和；如果提供了func，那么把前两个元素传给它，然后把计算结果和下一个元素传给它，以此类推，最后产出结果</td></tr><tr class="even"><td>内置</td><td><code>enumerate(iterable, start=0)</code></td><td>产出由两个元素构成的元素，结构是(index, item)，其中index从start开始计数，item则从iterable中获取</td></tr><tr class="odd"><td>内置</td><td><code>map(func, it1, [it2, ..., itN])</code></td><td>把it中的各个元素传给func，产出结果；如果传入N个可迭代的对象，那么func必须能接受N个参数，而且要并行处理各个可迭代的对象</td></tr><tr class="even"><td><code>itertools</code></td><td><code>starmap(func, it)</code></td><td>把it中的各个元素传给func，产出结果；输入的可迭代对象应该产出可迭代的元素iit，然后以func(*iit)这种形式调用func</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sample = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.accumulate(sample))  <span class="comment"># 累加</span></span><br><span class="line">[<span class="number">5</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">32</span>, <span class="number">35</span>, <span class="number">35</span>, <span class="number">44</span>, <span class="number">45</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.accumulate(sample, min))  <span class="comment"># 计算最小值</span></span><br><span class="line">[<span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.accumulate(sample, max))  <span class="comment"># 计算最大值</span></span><br><span class="line">[<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> operator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.accumulate(sample, operator.mul))  <span class="comment"># 累乘</span></span><br><span class="line">[<span class="number">5</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">320</span>, <span class="number">2240</span>, <span class="number">13440</span>, <span class="number">40320</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.accumulate(range(<span class="number">1</span>, <span class="number">11</span>), operator.mul))  <span class="comment"># 从1!到10!</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>, <span class="number">720</span>, <span class="number">5040</span>, <span class="number">40320</span>, <span class="number">362880</span>, <span class="number">3628800</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(enumerate(<span class="string">'albatroz'</span>, <span class="number">1</span>))</span><br><span class="line">[(<span class="number">1</span>, <span class="string">'a'</span>), (<span class="number">2</span>, <span class="string">'l'</span>), (<span class="number">3</span>, <span class="string">'b'</span>), (<span class="number">4</span>, <span class="string">'a'</span>), (<span class="number">5</span>, <span class="string">'t'</span>), (<span class="number">6</span>, <span class="string">'r'</span>), (<span class="number">7</span>, <span class="string">'o'</span>), (<span class="number">8</span>, <span class="string">'z'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(operator.mul, range(<span class="number">11</span>), range(<span class="number">11</span>)))  <span class="comment"># 0到10的平方</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(operator.mul, range(<span class="number">11</span>), [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>]))  <span class="comment"># 短的iterator结束时停止</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">4</span>, <span class="number">16</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(<span class="keyword">lambda</span> a, b: (a, b), range(<span class="number">11</span>), [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>]))  <span class="comment"># 等同于zip</span></span><br><span class="line">[(<span class="number">0</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">8</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.starmap(operator.mul, enumerate(<span class="string">'albatroz'</span>, <span class="number">1</span>)))  <span class="comment"># 根据所在位置重复相应次数</span></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'ll'</span>, <span class="string">'bbb'</span>, <span class="string">'aaaa'</span>, <span class="string">'ttttt'</span>, <span class="string">'rrrrrr'</span>, <span class="string">'ooooooo'</span>, <span class="string">'zzzzzzzz'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.starmap(<span class="keyword">lambda</span> a, b: b/a,</span><br><span class="line"><span class="meta">... </span>    enumerate(itertools.accumulate(sample), <span class="number">1</span>)))  <span class="comment"># 计算均值</span></span><br><span class="line">[<span class="number">5.0</span>, <span class="number">4.5</span>, <span class="number">3.6666666666666665</span>, <span class="number">4.75</span>, <span class="number">5.2</span>, <span class="number">5.333333333333333</span>, <span class="number">5.0</span>, <span class="number">4.375</span>, <span class="number">4.888888888888889</span>, <span class="number">4.5</span>]</span><br></pre></td></tr></table></figure><h1 id="用于合并">用于合并</h1><table><colgroup><col style="width: 10%"><col style="width: 20%"><col style="width: 70%"></colgroup><thead><tr class="header"><th>模块</th><th>函数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>itertools</code></td><td><code>chain(it1, ..., itN)</code></td><td>先产出it1中的所有元素，然后产出it2中的所有元素，以此类推，无缝连接在一起</td></tr><tr class="even"><td><code>itertools</code></td><td><code>chain.from_iterable(it)</code></td><td>产出it生成的各个可迭代对象中的元素，一个接一个，无缝连接在一起；it应该产出可迭代元素，例如可迭代的对象列表</td></tr><tr class="odd"><td><code>itertools</code></td><td><code>product(it1, ..., itN, repeat=1)</code></td><td>计算笛卡尔积：从输入的各个可迭代元素中获取元素，合并成由N个元素组成的元组，与嵌套的for循环效果一样；repeat指明重复处理多少次输入的可迭代对象</td></tr><tr class="even"><td>内置</td><td><code>zip(it1, ..., itN)</code></td><td>并行从输入的各个可迭代对象中获取元素，产出由N个元素组成的元组，只要有一个可迭代的对象到头了，就默默地停止</td></tr><tr class="odd"><td><code>itertools</code></td><td><code>zip_longest(it1, ..., itN, fillvalue=None)</code></td><td>并行从输入的各个可迭代对象中获取元素，产出由N个元素组成的元组，等到最长的可迭代对象到头后才停止，空缺的值使用fillvalue填充</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.chain(<span class="string">'ABC'</span>, range(<span class="number">2</span>)))</span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.chain(enumerate(<span class="string">'ABC'</span>)))  <span class="comment"># 如果只传入一个可迭代的对象，那么chain函数没什么用</span></span><br><span class="line">[(<span class="number">0</span>, <span class="string">'A'</span>), (<span class="number">1</span>, <span class="string">'B'</span>), (<span class="number">2</span>, <span class="string">'C'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.chain.from_iterable(enumerate(<span class="string">'ABC'</span>)))  <span class="comment"># 各元素本身必须是可迭代对象</span></span><br><span class="line">[<span class="number">0</span>, <span class="string">'A'</span>, <span class="number">1</span>, <span class="string">'B'</span>, <span class="number">2</span>, <span class="string">'C'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(<span class="string">'ABC'</span>, range(<span class="number">5</span>)))</span><br><span class="line">[(<span class="string">'A'</span>, <span class="number">0</span>), (<span class="string">'B'</span>, <span class="number">1</span>), (<span class="string">'C'</span>, <span class="number">2</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(<span class="string">'ABC'</span>, range(<span class="number">5</span>), [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]))  <span class="comment"># 最短的iterator到头时停止</span></span><br><span class="line">[(<span class="string">'A'</span>, <span class="number">0</span>, <span class="number">10</span>), (<span class="string">'B'</span>, <span class="number">1</span>, <span class="number">20</span>), (<span class="string">'C'</span>, <span class="number">2</span>, <span class="number">30</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.zip_longest(<span class="string">'ABC'</span>, range(<span class="number">5</span>)))  <span class="comment"># 最长的iterator到头时停止，默认用None填充空缺的值</span></span><br><span class="line">[(<span class="string">'A'</span>, <span class="number">0</span>), (<span class="string">'B'</span>, <span class="number">1</span>), (<span class="string">'C'</span>, <span class="number">2</span>), (<span class="literal">None</span>, <span class="number">3</span>), (<span class="literal">None</span>, <span class="number">4</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.zip_longest(<span class="string">'ABC'</span>, range(<span class="number">5</span>), fillvalue=<span class="string">'?'</span>))  <span class="comment"># 使用指定字符填充</span></span><br><span class="line">[(<span class="string">'A'</span>, <span class="number">0</span>), (<span class="string">'B'</span>, <span class="number">1</span>), (<span class="string">'C'</span>, <span class="number">2</span>), (<span class="string">'?'</span>, <span class="number">3</span>), (<span class="string">'?'</span>, <span class="number">4</span>)]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.product(<span class="string">'ABC'</span>, range(<span class="number">2</span>)))  <span class="comment"># 生成3*2个元组</span></span><br><span class="line">[(<span class="string">'A'</span>, <span class="number">0</span>), (<span class="string">'A'</span>, <span class="number">1</span>), (<span class="string">'B'</span>, <span class="number">0</span>), (<span class="string">'B'</span>, <span class="number">1</span>), (<span class="string">'C'</span>, <span class="number">0</span>), (<span class="string">'C'</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>suits = <span class="string">'spades hearts diamonds clubs'</span>.split()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.product(<span class="string">'AK'</span>, suits))</span><br><span class="line">[(<span class="string">'A'</span>, <span class="string">'spades'</span>), (<span class="string">'A'</span>, <span class="string">'hearts'</span>), (<span class="string">'A'</span>, <span class="string">'diamonds'</span>), (<span class="string">'A'</span>, <span class="string">'clubs'</span>), (<span class="string">'K'</span>, <span class="string">'spades'</span>), (<span class="string">'K'</span>, <span class="string">'hearts'</span>), (<span class="string">'K'</span>, <span class="string">'diamonds'</span>), (<span class="string">'K'</span>, <span class="string">'clubs'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.product(<span class="string">'ABC'</span>))  <span class="comment"># 如果传入一个可迭代的对象，产出的是一系列只有一个元素的元组，不是特别有用</span></span><br><span class="line">[(<span class="string">'A'</span>,), (<span class="string">'B'</span>,), (<span class="string">'C'</span>,)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.product(<span class="string">'ABC'</span>, repeat=<span class="number">2</span>))  <span class="comment"># 重复2次</span></span><br><span class="line">[(<span class="string">'A'</span>, <span class="string">'A'</span>), (<span class="string">'A'</span>, <span class="string">'B'</span>), (<span class="string">'A'</span>, <span class="string">'C'</span>), (<span class="string">'B'</span>, <span class="string">'A'</span>), (<span class="string">'B'</span>, <span class="string">'B'</span>), (<span class="string">'B'</span>, <span class="string">'C'</span>), (<span class="string">'C'</span>, <span class="string">'A'</span>), (<span class="string">'C'</span>, <span class="string">'B'</span>), (<span class="string">'C'</span>, <span class="string">'C'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.product(range(<span class="number">2</span>), repeat=<span class="number">3</span>))</span><br><span class="line">[(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rows = itertools.product(<span class="string">'AB'</span>, range(<span class="number">2</span>), repeat=<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> row <span class="keyword">in</span> rows: print(row)</span><br><span class="line">...</span><br><span class="line">(<span class="string">'A'</span>, <span class="number">0</span>, <span class="string">'A'</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="string">'A'</span>, <span class="number">0</span>, <span class="string">'A'</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="string">'A'</span>, <span class="number">0</span>, <span class="string">'B'</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="string">'A'</span>, <span class="number">0</span>, <span class="string">'B'</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="string">'A'</span>, <span class="number">1</span>, <span class="string">'A'</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="string">'A'</span>, <span class="number">1</span>, <span class="string">'A'</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="string">'A'</span>, <span class="number">1</span>, <span class="string">'B'</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="string">'A'</span>, <span class="number">1</span>, <span class="string">'B'</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="string">'B'</span>, <span class="number">0</span>, <span class="string">'A'</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="string">'B'</span>, <span class="number">0</span>, <span class="string">'A'</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="string">'B'</span>, <span class="number">0</span>, <span class="string">'B'</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="string">'B'</span>, <span class="number">0</span>, <span class="string">'B'</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="string">'B'</span>, <span class="number">1</span>, <span class="string">'A'</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="string">'B'</span>, <span class="number">1</span>, <span class="string">'A'</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="string">'B'</span>, <span class="number">1</span>, <span class="string">'B'</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="string">'B'</span>, <span class="number">1</span>, <span class="string">'B'</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h1 id="用于扩展元素">用于扩展元素</h1><table><colgroup><col style="width: 10%"><col style="width: 20%"><col style="width: 70%"></colgroup><thead><tr class="header"><th>模块</th><th>函数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>itertools</code></td><td><code>combinations(it, out_len)</code></td><td>把it产出的out_len个元素组合在一起，然后产出</td></tr><tr class="even"><td><code>itertools</code></td><td><code>combinations_with_replacement(it, out_len)</code></td><td>把it产出的out_len个元素组合在一起，然后产出，包含相同元素的组合</td></tr><tr class="odd"><td><code>itertools</code></td><td><code>count(start=0, step=1)</code></td><td>从start开始不断产出数字，按step指定的步幅增加</td></tr><tr class="even"><td><code>itertools</code></td><td><code>cycle(it)</code></td><td>从it中产出各个元素，存储各个元素的副本，然后按顺序重复不断地产出各个元素</td></tr><tr class="odd"><td><code>itertools</code></td><td><code>permutations(it, out_len=None)</code></td><td>把out_len个it产出的元素排列在一起，然后产出这些排列；out_len的默认值等于len(list(it))</td></tr><tr class="even"><td><code>itertools</code></td><td><code>repeat(item, [times])</code></td><td>重复不断地产出指定的元素，除非提供times，指定次数</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct = itertools.count()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(ct), next(ct), next(ct)  <span class="comment"># 不能使用ct构建列表，因为ct是无穷的</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)                                              <span class="comment"># 如果使用islice或takewhile函数，</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.islice(itertools.count(<span class="number">1</span>, <span class="number">.3</span>), <span class="number">3</span>))  <span class="comment"># 可以从count生成器中构建列表</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">1.3</span>, <span class="number">1.6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cy = itertools.cycle(<span class="string">'ABC'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.islice(cy, <span class="number">7</span>))  <span class="comment"># cy同样是无穷的</span></span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'A'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rp = itertools.repeat(<span class="number">7</span>)  <span class="comment"># 无限产出7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(rp), next(rp)</span><br><span class="line">(<span class="number">7</span>, <span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.repeat(<span class="number">8</span>, <span class="number">4</span>))  <span class="comment"># 限制次数</span></span><br><span class="line">[<span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(operator.mul, range(<span class="number">11</span>), itertools.repeat(<span class="number">5</span>)))  <span class="comment"># 乘数固定为5</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">50</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.combinations(<span class="string">'ABC'</span>, <span class="number">2</span>))  <span class="comment"># 不同元素的组合，次序不重要</span></span><br><span class="line">[(<span class="string">'A'</span>, <span class="string">'B'</span>), (<span class="string">'A'</span>, <span class="string">'C'</span>), (<span class="string">'B'</span>, <span class="string">'C'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.combinations_with_replacement(<span class="string">'ABC'</span>, <span class="number">2</span>))  <span class="comment"># 可包含相同元素的组合</span></span><br><span class="line">[(<span class="string">'A'</span>, <span class="string">'A'</span>), (<span class="string">'A'</span>, <span class="string">'B'</span>), (<span class="string">'A'</span>, <span class="string">'C'</span>), (<span class="string">'B'</span>, <span class="string">'B'</span>), (<span class="string">'B'</span>, <span class="string">'C'</span>), (<span class="string">'C'</span>, <span class="string">'C'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.permutations(<span class="string">'ABC'</span>, <span class="number">2</span>))  <span class="comment"># 排列，次序重要</span></span><br><span class="line">[(<span class="string">'A'</span>, <span class="string">'B'</span>), (<span class="string">'A'</span>, <span class="string">'C'</span>), (<span class="string">'B'</span>, <span class="string">'A'</span>), (<span class="string">'B'</span>, <span class="string">'C'</span>), (<span class="string">'C'</span>, <span class="string">'A'</span>), (<span class="string">'C'</span>, <span class="string">'B'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.product(<span class="string">'ABC'</span>, repeat=<span class="number">2</span>))  <span class="comment"># 'ABC'和'ABC'（repeat=2的效果）的笛卡尔积</span></span><br><span class="line">[(<span class="string">'A'</span>, <span class="string">'A'</span>), (<span class="string">'A'</span>, <span class="string">'B'</span>), (<span class="string">'A'</span>, <span class="string">'C'</span>), (<span class="string">'B'</span>, <span class="string">'A'</span>), (<span class="string">'B'</span>, <span class="string">'B'</span>), (<span class="string">'B'</span>, <span class="string">'C'</span>), (<span class="string">'C'</span>, <span class="string">'A'</span>), (<span class="string">'C'</span>, <span class="string">'B'</span>), (<span class="string">'C'</span>, <span class="string">'C'</span>)]</span><br></pre></td></tr></table></figure><h1 id="用于重新排列元素">用于重新排列元素</h1><table><colgroup><col style="width: 10%"><col style="width: 20%"><col style="width: 70%"></colgroup><thead><tr class="header"><th>模块</th><th>函数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>itertools</code></td><td><code>groupby(it, key=None)</code></td><td>产出由两个元素组成的元素，形式为(key, group)，其中key是分组标准，group是生成器，用于产出分组里的元素</td></tr><tr class="even"><td>内置</td><td><code>reversed(seq)</code></td><td>从后向前，倒序产出seq中的元素；seq必须是序列，或者是实现了<code>__reversed__</code>特殊方法的对象</td></tr><tr class="odd"><td><code>itertools</code></td><td><code>tee(it, n=2)</code></td><td>产出一个由n个生成器组成的元组，每个生成器用于单独产出输入的可迭代对象中的元素</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.groupby(<span class="string">'LLLLAAGGG'</span>))</span><br><span class="line">[(<span class="string">'L'</span>, &lt;itertools._grouper object at <span class="number">0x103db4710</span>&gt;), (<span class="string">'A'</span>, &lt;itertools._grouper object at <span class="number">0x103db4390</span>&gt;), (<span class="string">'G'</span>, &lt;itertools._grouper object at <span class="number">0x103db4748</span>&gt;)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> char, group <span class="keyword">in</span> itertools.groupby(<span class="string">'LLLLAAGGG'</span>):</span><br><span class="line"><span class="meta">... </span>    print(char, <span class="string">'-&gt;'</span>, list(group))</span><br><span class="line">...</span><br><span class="line">L -&gt; ['L', 'L', 'L', 'L']</span><br><span class="line">A -&gt; ['A', 'A']</span><br><span class="line">G -&gt; ['G', 'G', 'G']</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>animals = [<span class="string">'duck'</span>, <span class="string">'eagle'</span>, <span class="string">'rat'</span>, <span class="string">'giraffe'</span>, <span class="string">'bear'</span>,</span><br><span class="line"><span class="meta">... </span>            <span class="string">'bat'</span>, <span class="string">'dolphin'</span>, <span class="string">'shark'</span>, <span class="string">'lion'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>animals.sort(key=len)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>animals</span><br><span class="line">[<span class="string">'rat'</span>, <span class="string">'bat'</span>, <span class="string">'duck'</span>, <span class="string">'bear'</span>, <span class="string">'lion'</span>, <span class="string">'eagle'</span>, <span class="string">'shark'</span>, <span class="string">'giraffe'</span>, <span class="string">'dolphin'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> length, group <span class="keyword">in</span> itertools.groupby(animals, len):</span><br><span class="line"><span class="meta">... </span>    print(length, <span class="string">'-&gt;'</span>, list(group))</span><br><span class="line">...</span><br><span class="line">3 -&gt; ['rat', 'bat']</span><br><span class="line">4 -&gt; ['duck', 'bear', 'lion']</span><br><span class="line">5 -&gt; ['eagle', 'shark']</span><br><span class="line">7 -&gt; ['giraffe', 'dolphin']</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> length, group <span class="keyword">in</span> itertools.groupby(reversed(animals), len):</span><br><span class="line"><span class="meta">... </span>    print(length, <span class="string">'-&gt;'</span>, list(group))</span><br><span class="line">...</span><br><span class="line">7 -&gt; ['dolphin', 'giraffe']</span><br><span class="line">5 -&gt; ['shark', 'eagle']</span><br><span class="line">4 -&gt; ['lion', 'bear', 'duck']</span><br><span class="line">3 -&gt; ['bat', 'rat']</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.tee(<span class="string">'ABC'</span>))</span><br><span class="line">[&lt;itertools._tee object at <span class="number">0x103db68c8</span>&gt;, &lt;itertools._tee object at <span class="number">0x103db6788</span>&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g1, g2 = itertools.tee(<span class="string">'ABC'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g1), next(g2)</span><br><span class="line">(<span class="string">'A'</span>, <span class="string">'A'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g2)</span><br><span class="line"><span class="string">'B'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(g1)</span><br><span class="line">[<span class="string">'B'</span>, <span class="string">'C'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(g2)</span><br><span class="line">[<span class="string">'C'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(*itertools.tee(<span class="string">'ABC'</span>)))</span><br><span class="line">[(<span class="string">'A'</span>, <span class="string">'A'</span>), (<span class="string">'B'</span>, <span class="string">'B'</span>), (<span class="string">'C'</span>, <span class="string">'C'</span>)]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> generators </tag>
            
            <tag> itertools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可迭代对象、迭代器和生成器</title>
      <link href="/notes/fluent-python/iterables-iterators-and-generators/"/>
      <url>/notes/fluent-python/iterables-iterators-and-generators/</url>
      
        <content type="html"><![CDATA[<h1 id="sentence类第1版单词序列">Sentence类第1版：单词序列</h1><figure class="highlight python"><figcaption><span>sentence.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">        self.words = RE_WORD.findall(text)  <span class="comment"># 返回全部菲重叠匹配</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.words[index]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.words)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Sentence(%s)'</span> % reprlib.repr(self.text)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sentence <span class="keyword">import</span> Sentence</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Sentence(<span class="string">'"The time has come," the Walrus said,'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">Sentence(<span class="string">'"The time ha... Walrus said,'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(s)  <span class="comment"># Sentence实例是可迭代的，因此可以用于构建列表和其他可迭代的类型</span></span><br><span class="line">[<span class="string">'The'</span>, <span class="string">'time'</span>, <span class="string">'has'</span>, <span class="string">'come'</span>, <span class="string">'the'</span>, <span class="string">'Walrus'</span>, <span class="string">'said'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(s, abc.Iterable)  <span class="comment"># 虽然可以迭代，但无法通过isinstance检测</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(Sentence, abc.Iterable)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>解释器需要迭代对象x时，会自动调用iter(x)。内置的iter函数有以下作用。</p><ol type="1"><li>检查对象是否实现了<code>__iter__</code>方法，如果实现了就调用它，获取一个迭代器。</li><li>如果没有实现<code>__iter__</code>方法，但是实现了<code>__getitem__</code>方法，Python会创建一个迭代器，尝试按顺序获取元素。</li><li>如果尝试失败，Python抛出TypeError异常，通常会提示“C object is not iterable”，其中C是目标对象所属的类。</li></ol><p>任何Python序列都可迭代的原因是，它们都实现了<code>__getitem__</code>方法。其实，标准的序列也都实现了<code>__iter__</code>方法，因此你也应该这么做。之所以对<code>__getitem__</code>方法做特殊处理，是为了向后兼容，而未来可能不会再这么做。</p><p>因为abc.Iterable类实现了<code>__subclasshook__</code>方法，该方法将定义了<code>__iter__</code>方法的类认作自己的虚拟子类。因此，虽然Sentence类可以迭代，但是无法通过issubclass(Sentence, abc.Iterable)测试。</p><p><strong>从Python3.4开始，检查对象x能否迭代，最准确的方法是：调用iter(x)函数，如果不可迭代，再处理TypeError异常。</strong>这比使用isinstance(x, abc.Iterable)更准确，因为iter(x)函数会考虑到遗留的<code>__getitem__</code>方法，而abc.Iterable类则不考虑。</p><h2 id="可迭代的对象与迭代器的对比">可迭代的对象与迭代器的对比</h2><p>可迭代的对象：使用iter内置函数可以获取迭代器的对象。如果对象实现了能返回迭代器的<code>__iter__</code>方法，那么对象就是可迭代的。序列都可以迭代；实现了<code>__getitem__</code>方法，而且其参数是从零开始的索引，这种对象也可以迭代。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> char <span class="keyword">in</span> s:  <span class="comment"># 使用for循环迭代，背后有迭代器，但是看不到</span></span><br><span class="line"><span class="meta">... </span>    print(char)</span><br><span class="line">...</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it = iter(s)  <span class="comment"># 使用迭代器迭代</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>        print(next(it))</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">except</span> StopIteration:  <span class="comment"># 迭代器到头</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">del</span> it  <span class="comment"># 释放引用</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">break</span></span><br><span class="line">...</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br></pre></td></tr></table></figure><img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYIamgBYbAJ2vHy2n9BKfCoabLgEPI089gc4IjGdLkQab6VagjGdny9b1HV3nNBPgsalmYlDhoKYjAWDh02h0ObfTVagfGb9cUKQAGdmPt25ZvqzRjJ_PEVZwh1IQgLmVJ-6pQpcURfq9KxPhoOltI5_kdF9qzxycEXYSxLi6SzNJTl2VxkhbIyr8KGBPWimge2cn8IcgQ0jnmZUBKd3HDAx0421IbbfGMvIc0H1KKb1KWLa4CVpPdpOjTgn5Mm0FIfaPN5s45N5XFJyyE4MnM2i_cjJpTlGi0"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterator</span><span class="params">(Iterable)</span>:</span>  <span class="comment"># abc.Iterator类源码</span></span><br><span class="line"></span><br><span class="line">    __slots__ = ()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'Return the next item from the iterator. When exhausted, raise StopIteration'</span></span><br><span class="line">        <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__subclasshook__</span><span class="params">(cls, C)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">is</span> Iterator:</span><br><span class="line">            <span class="keyword">if</span> (any(<span class="string">"__next__"</span> <span class="keyword">in</span> B.__dict__ <span class="keyword">for</span> B <span class="keyword">in</span> C.__mro__) <span class="keyword">and</span></span><br><span class="line">                any(<span class="string">"__iter__"</span> <span class="keyword">in</span> B.__dict__ <span class="keyword">for</span> B <span class="keyword">in</span> C.__mro__)):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Sentence(<span class="string">'A B'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it = iter(s)  <span class="comment"># 获取迭代器</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)  <span class="comment"># 获取下一个单词</span></span><br><span class="line"><span class="string">'A'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)</span><br><span class="line"><span class="string">'B'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)  <span class="comment"># 迭代到头</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(it)  <span class="comment"># 迭代器空了</span></span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(iter(s))  <span class="comment"># 重新构建迭代器</span></span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'B'</span>]</span><br></pre></td></tr></table></figure><h1 id="sentence类第2版典型的迭代器">Sentence类第2版：典型的迭代器</h1><figure class="highlight python"><figcaption><span>sentence_iter.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span>  <span class="comment"># 使用迭代器模式实现Sentence类</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">        self.words = RW_WORD.findall(text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Sentence(%s)'</span> % reprlib.repr(self.text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span>  <span class="comment"># 实例化并返回一个迭代器</span></span><br><span class="line">        <span class="keyword">return</span> SentenceIterator(self.words)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SentenceIterator</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        self.words = words  <span class="comment"># 引用单词列表</span></span><br><span class="line">        self.index = <span class="number">0</span>  <span class="comment"># 下一个要获取的单词</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            word = self.words[index]  <span class="comment"># 获取索引位上的单词</span></span><br><span class="line">        <span class="keyword">except</span> IndexError:  <span class="comment"># 如果索引位上没有单词</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration()  <span class="comment"># 抛出StopIteration异常</span></span><br><span class="line">        self.index += <span class="number">1</span>  <span class="comment"># 递增索引</span></span><br><span class="line">        <span class="keyword">return</span> word  <span class="comment"># 返回单词</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span>  <span class="comment"># 迭代器应该一直可以迭代</span></span><br><span class="line">        <span class="keyword">return</span> self  <span class="comment"># 因此__iter__方法应该返回自身</span></span><br></pre></td></tr></table></figure><p>对这个示例来说，其实没必要在SentenceIterator类中实现<code>__iter__</code>方法，不过这么做是对的，因为迭代器应该实现<code>__next__</code>和<code>__iter__</code>两个方法，而且这么做能让迭代器通过<code>issubclass(SentenceIterator, abc.Iterator)</code>测试。如果让SentenceIterator类继承abc.Iterator类，那么它会继承<code>abc.Iterator.__iter__</code>这个具体方法。</p><h2 id="把sentence编程迭代器坏主意">把Sentence编程迭代器：坏主意</h2><p>构建可迭代的对象和迭代器时经常会出现错误，原因是混淆了二者。可迭代的对象有个<code>__iter__</code>方法，每次都实例化一个新的迭代器；而迭代器要实现<code>__next__</code>方法，返回单个元素，此外还要实现<code>__iter__</code>方法，返回迭代器本身。</p><p>除了<code>__iter__</code>方法之外，你可能还想在Sentence类中实现<code>__next__</code>方法，让Sentence实例既是可迭代的对象，也是自身的迭代器。可是，这种想法非常糟糕。</p><p>迭代器模式可用来：（出自《设计模式：可复用面向对象软件的基础》）</p><ul><li>访问一个聚合对象的内容而无需暴露它的内部表示</li><li>支持对聚合对象的多种遍历</li><li>为遍历不同的聚合结构提供一个同一的接口（既支持多态迭代）</li></ul><p>为了“支持多种遍历”，必须能从同一个可迭代的实例中获取多个独立的迭代器，而且各个迭代器要能维护自身的内部状态，因此这一模式正确的实现方式是，每次调用iter(my_iterable)都构建一个独立的迭代器。</p><h1 id="sentence类第3版生成器函数">Sentence类第3版：生成器函数</h1><p>用生成器函数代替SentenceIterator类。</p><figure class="highlight python"><figcaption><span>sentence_gen.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">        self.words = RE_WORD.findall(text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Sentence(%s)'</span> % reprlib.repr(self.text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> self.words:</span><br><span class="line">            <span class="keyword">yield</span> word  <span class="comment"># 产出当前的word</span></span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><code>__iter__</code>方法的return语句不是必要的；这个函数可以直接“落空”，自动返回。不管有没有return语句，生成器函数都不会抛出StopIteration异常，而是在生成完全部值之后直接退出。</p><h2 id="生成器函数的工作原理">生成器函数的工作原理</h2><p>只要Python函数的定义体中有yield关键字，该函数就是生成器函数。调用生成器函数时，会返回一个生成器对象。也就是说，生成器函数是生成器工厂。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span>  <span class="comment"># 只要包含关键字yield，该函数就是生成器函数</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'start'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">1</span>  <span class="comment"># 生成器函数的定义体中通常都有循环</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'continue'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">2</span>  <span class="comment"># 不过这不是必要条件</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'end'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen  <span class="comment"># 函数对象</span></span><br><span class="line">&lt;function gen at <span class="number">0x10094ec80</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen()  <span class="comment"># 调用时返回一个生成器对象</span></span><br><span class="line">&lt;generator object gen at <span class="number">0x10094dba0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> gen():</span><br><span class="line"><span class="meta">... </span>    print(i)</span><br><span class="line">...</span><br><span class="line">start</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">end</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = gen()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)  <span class="comment"># 第一次调用，会打印'start'，然后停在第一个yield语句</span></span><br><span class="line">start</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)  <span class="comment"># 第二次调用，打印'continue'，停在第二个yield语句</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)  <span class="comment"># 第三次调用，打印'end'，到达定义体末尾，抛出异常</span></span><br><span class="line">end</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><h1 id="sentence类第4版惰性实现">Sentence类第4版：惰性实现</h1><p>惰性求值（lazy evaluation）和及早求值（eager evaluation）是编程语言理论方面的技术用语。</p><p>目前实现的几版Sentence类都不够惰性，因为<code>__init__</code>方法急迫地构建好了文本中的单词列表，然后将其绑定到self.words属性上。这样就得处理整个文本，列表使用的内存量可能与文本本身一样多（获取更多，这取决于文本中有多少非单词字符）。如果只需迭代前几个单词，大多数工作都是白费力气。</p><p>只要使用Python3，思索着做某件事有没有懒惰的方式，答案通常都是肯定的。re.finditer函数是re.findall函数的惰性版本，返回一个生成器，按需生成re.MatchObject实例。如果有很多匹配，re.finditer函数能节省大量内存。</p><figure class="highlight python"><figcaption><span>sentence_gen2.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Sentence(%s)'</span> % reprlib.repr(self.text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> match <span class="keyword">in</span> RE_WORD.finditer(self.text):</span><br><span class="line">            <span class="keyword">yield</span> match.group()  <span class="comment"># 提取具体文本</span></span><br></pre></td></tr></table></figure><h1 id="sentence类第5版生成器表达式">Sentence类第5版：生成器表达式</h1><p>生成器表达式可以理解为列表推导的惰性版本：不会迫切地构建列表，而是返回一个生成器，按需惰性生成元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'yield 1'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'yield 2'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res1 = [x * <span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> gen()]  <span class="comment"># 列表推导</span></span><br><span class="line"><span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">yield</span> <span class="number">2</span>  <span class="comment"># gen函数全部运行</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res1</span><br><span class="line">[<span class="number">3</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res2 = (x * <span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> gen())  <span class="comment"># 生成器，gen函数没有运行，故没有任何输出</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res2</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x10094daf0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> res2:  <span class="comment"># 循环迭代res2时，gen函数才会真正执行</span></span><br><span class="line"><span class="meta">... </span>    print(i)</span><br><span class="line">...</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="keyword">yield</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>sentence_genexp.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Sentence(%s)'</span> % reprlib.repr(self.text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (match.group() <span class="keyword">for</span> match <span class="keyword">in</span> RE_WORD.finditer(self.text))</span><br></pre></td></tr></table></figure><p><code>__iter__</code>不是生成器函数了（没有yield），而是使用生成器表达式构建生成器，然后将其返回。不过，最终的效果一样：调用<code>__iter__</code>方法会得到一个生成器对象。生成器表达式是语法糖：完全可以替换成生成器函数，不过有时使用生成器表达式更便利。</p><h1 id="何时使用生成器表达式">何时使用生成器表达式</h1><p>生成器表达式是创建生成器的简洁句法，这样无需先定义函数再调用。不过生成器函数灵活得多，可以使用多个语句实现复杂的逻辑，也可以作为协程使用。</p><p>遇到简单的情况时，可以使用生成器表达式，因为这样扫一眼就知道代码的作用；如果生成器表达式要分成多行写，倾向于定义生成器函数，以便提高可读性。此外，生成器函数有名称，因此可以重用。</p><h1 id="另一个示例等差数列生成器">另一个示例：等差数列生成器</h1><p>典型的迭代器模式作用很简单——遍历数据结构。不过，即便不是从集合中获取元素，而是获取序列中即时生成的下一个值时，也用得到这种基于方法的标准接口。例如，内置的range函数用于生成有穷整数等差数列（Arithmetic Progression，AP），itertools.count函数用于生成无穷等差数列。</p><figure class="highlight python"><figcaption><span>arithmetic_progression.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArithmeticProgression</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, begin, step, end=None)</span>:</span></span><br><span class="line">        self.begin = begin</span><br><span class="line">        self.step = step</span><br><span class="line">        self.end = end  <span class="comment"># None -&gt; 无穷数列</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        result = type(self.begin + self.step)(self.begin)  <span class="comment"># 强制转换类型</span></span><br><span class="line">        forever = self.end <span class="keyword">is</span> <span class="literal">None</span>  <span class="comment"># 提高可读性</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> forever <span class="keyword">or</span> result &lt; self.end:</span><br><span class="line">            <span class="keyword">yield</span> result</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">            result = self.begin + self.step * index  <span class="comment"># 没有累加，为了降低处理浮点数时累积效应致错的风险</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> arithmetic_progression <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ap = ArithmeticProgression(<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>)  <span class="comment"># 整型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(ap)</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ap = ArithmeticProgression(<span class="number">1</span>, <span class="number">.5</span>, <span class="number">3</span>)  <span class="comment"># 浮点型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(ap)</span><br><span class="line">[<span class="number">1.0</span>, <span class="number">1.5</span>, <span class="number">2.0</span>, <span class="number">2.5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ap = ArithmeticProgression(<span class="number">0</span>, <span class="number">1</span>/<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(ap)</span><br><span class="line">[<span class="number">0.0</span>, <span class="number">0.3333333333333333</span>, <span class="number">0.6666666666666666</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ap = ArithmeticProgression(<span class="number">0</span>, Fraction(<span class="number">1</span>, <span class="number">3</span>), <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(ap)</span><br><span class="line">[Fraction(<span class="number">0</span>, <span class="number">1</span>), Fraction(<span class="number">1</span>, <span class="number">3</span>), Fraction(<span class="number">2</span>, <span class="number">3</span>)]  <span class="comment"># 第一个数被转换成了Fraction类型</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ap = ArithmeticProgression(<span class="number">0</span>, Decimal(<span class="string">'.1'</span>), <span class="number">.3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(ap)</span><br><span class="line">[Decimal(<span class="string">'0'</span>), Decimal(<span class="string">'0.1'</span>), Decimal(<span class="string">'0.2'</span>)]</span><br></pre></td></tr></table></figure><p>这个简单的示例，说明了如何使用生成器函数实现特殊的<code>__iter__</code>方法。然而，如果一个类只是为了构建生成器而去实现<code>__iter__</code>方法，那还不如使用生成器函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aritprog_gen</span><span class="params">(begin, step, end=None)</span>:</span></span><br><span class="line">    result = type(self.begin + self.step)(self.begin)</span><br><span class="line">    forever = self.end <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> forever <span class="keyword">or</span> result &lt; self.end:</span><br><span class="line">        <span class="keyword">yield</span> result</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">        result = self.begin + self.step * index</span><br></pre></td></tr></table></figure><h2 id="使用itertools模块生成等差数列">使用itertools模块生成等差数列</h2><p>Python3.4中的<a href="https://devdocs.io/python~3.6/library/itertools" target="_blank" rel="noopener">itertools</a>模块提供了19个生成器函数，结合起来使用能实现很多有趣的用法。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/itertools#itertools.count" target="_blank" rel="noopener"><code>itertools.count(start=0, step=1)</code></a></p><p>Make an iterator that returns evenly spaced values starting with number start. Often used as an argument to map() to generate consecutive data points. Also, used with zip() to add sequence numbers. Roughly equivalent to:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(start=<span class="number">0</span>, step=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="comment"># count(10) --&gt; 10 11 12 13 14 ...</span></span><br><span class="line">    <span class="comment"># count(2.5, 0.5) -&gt; 2.5 3.0 3.5 ...</span></span><br><span class="line">    n = start</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        n += step</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>When counting with floating point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: <code>(start + step * i for i in count())</code>.</p></blockquote><p>itertools.count函数返回的生成器能生成等差数列。然而，itertools.count函数从不停止。因此，如果调用list(count())，Python会创建一个特别大的列表，超出可用内存，在调用失败之前，电脑会疯狂地运转。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/itertools#itertools.takewhile" target="_blank" rel="noopener"><code>itertools.takewhile(predicate, iterable)</code></a></p><p>Make an iterator that returns elements from the iterable as long as the predicate is true. Roughly equivalent to:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">takewhile</span><span class="params">(predicate, iterable)</span>:</span></span><br><span class="line">    <span class="comment"># takewhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 1 4</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">if</span> predicate(x):</span><br><span class="line">            <span class="keyword">yield</span> x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure></blockquote><p>itertools.takewhile函数则不同，它会生成一个使用另一个生成器的生成器，在指定的条件计算结果为false时停止。因此，可以把这两个函数结合在一起使用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> itertools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen = itertools.takewhile(<span class="keyword">lambda</span> n: n &lt; <span class="number">3</span>, itertools.count(<span class="number">1</span>, <span class="number">.5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(gen)</span><br><span class="line">[<span class="number">1</span>, <span class="number">1.5</span>, <span class="number">2.0</span>, <span class="number">2.5</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aritprog_gen</span><span class="params">(begin, step, end=None)</span>:</span>  <span class="comment"># 利用已有的生成器实现</span></span><br><span class="line">    first = type(begin + step)(begin)</span><br><span class="line">    ap_gen = itertools.count(first, step)</span><br><span class="line">    <span class="keyword">if</span> end <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        ap_gen = itertools.takewhile(<span class="keyword">lambda</span> n: n &lt; end, ap_gen)</span><br><span class="line">    <span class="keyword">return</span> ap_gen</span><br></pre></td></tr></table></figure><h1 id="python3.3中新出现的句法yield-from">Python3.3中新出现的句法：yield from</h1><p>如果生成器函数需要产出另一个生成器生成的值，传统的解决方法是使用嵌套的for循环。例如，chain生成器的等价实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chain</span><span class="params">(*iterables)</span>:</span></span><br><span class="line">    <span class="comment"># chain('ABC', 'DEF') --&gt; A B C D E F</span></span><br><span class="line">    <span class="keyword">for</span> it <span class="keyword">in</span> iterables:</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> it:  <span class="comment"># 使用循环</span></span><br><span class="line">            <span class="keyword">yield</span> element</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chain</span><span class="params">(*iterables)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> it <span class="keyword">in</span> iterables:</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> it  <span class="comment"># 使用yield from</span></span><br></pre></td></tr></table></figure><p>在这个示例中使用yield from是对的，而且代码读起来更顺畅，不过感觉更像是语法糖。除了代替循环之外，yield from还会创建通道，把内层生成器直接与外层生成器的客户端联系起来。把生成器当成协程使用时，这个通道特别重要，不仅能为客户端代码生成值，还能使用客户端提供的值。</p><h1 id="深入分析iter函数">深入分析iter函数</h1><p>在Python中迭代对象x时会调用iter(x)。可是，iter函数还有一个鲜为人知的用法：传入两个参数，使用常规的函数或任何可调用的对象创建迭代器。这样使用时，第一个参数必须是可调用的对象，用于不断调用（没有参数），产出各个值。第二个值是哨符，这是个标记值，当可调用的对象返回这个值时，触发迭代器抛出StopIteration异常，而不产出哨符。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/functions#iter" target="_blank" rel="noopener"><code>iter(object[, sentinel])</code></a></p><p>Return an iterator object. The first argument is interpreted very differently depending on the presence of the second argument. Without a second argument, object must be a collection object which supports the iteration protocol (the <code>__iter__()</code> method), or it must support the sequence protocol (the <code>__getitem__()</code> method with integer arguments starting at 0). If it does not support either of those protocols, TypeError is raised. If the second argument, sentinel, is given, then object must be a callable object. The iterator created in this case will call object with no arguments for each call to its <code>__next__()</code> method; if the value returned is equal to sentinel, StopIteration will be raised, otherwise the value will be returned.</p><p>One useful application of the second form of iter() is to read lines of a file until a certain line is reached. The following example reads a file until the readline() method returns an empty string:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'mydata.txt'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> iter(fp.readline, <span class="string">''</span>):  <span class="comment"># 逐行读取文件，直到遇到空行或者到达文件末尾</span></span><br><span class="line">        process_line(line)</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">d6</span><span class="params">()</span>:</span>  <span class="comment"># 掷骰子</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> randint(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d6_iter = iter(d6, <span class="number">1</span>)  <span class="comment"># 掷到1为止，但不会产出1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d6_iter  <span class="comment"># 返回的是一个callable_iterator对象</span></span><br><span class="line">&lt;callable_iterator object at <span class="number">0x101472e10</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> roll <span class="keyword">in</span> d6_iter:</span><br><span class="line"><span class="meta">... </span>    print(roll)</span><br><span class="line">...</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(d6_iter)  <span class="comment"># 与常规迭代器一样，一旦耗尽就没用了，想重新开始，必须再次创建</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> generators </tag>
            
            <tag> iterables </tag>
            
            <tag> iterators </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符重载</title>
      <link href="/notes/fluent-python/operator-overloading/"/>
      <url>/notes/fluent-python/operator-overloading/</url>
      
        <content type="html"><![CDATA[<h1 id="运算符重载基础">运算符重载基础</h1><p>在某些圈子中，运算符重载的名声并不好。这个语言特性可能（已经）被滥用，让程序员困惑，导致缺陷和意料之外的性能瓶颈。但是，如果使用得到，API会变得好用，代码变得易于阅读。Python施加了一些限制，做好了灵活性、可用性和安全性方面的平衡：</p><ul><li>不能重载内置类型的运算符</li><li>不能新建运算符，只能重载现有的</li><li>某些运算符不能重载——is、and、or和not（不过位运算符&amp;、｜和～可以）</li></ul><p>在Vector类中重载运算符，并修复==运算符可能出现的错误。</p><figure class="highlight python"><figcaption><span>vector.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    typecode = <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, components)</span>:</span></span><br><span class="line">        self._components = array(self.typecode, components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span>  <span class="comment"># 支持 == 中缀运算符，但是有错误</span></span><br><span class="line">        <span class="keyword">return</span> tuple(self) == tuple(other)  <span class="comment"># Vector([3, 4]) == (3, 4)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> math.sqrt(sum(x * x <span class="keyword">for</span> x <span class="keyword">in</span> self))</span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="一元运算符">一元运算符</h1><p><code>- (__neg__)</code>：一元取负算术运算符。如果x是-2，那么-x == 2。</p><p><code>+ (__pos__)</code>：一元取正算术运算符。通常，x == -x，但是也有例外。</p><p><code>~ (__invert__)</code>：对整数按位取反，定义为~x == -(x+1)。如果x是2，那么~x == -3。</p><p>Python语言参考手册还把内置的<code>abs(...)</code>函数列为一元运算符。它对应的特殊方法是<code>__abs__</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在Vector类中定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span>  <span class="comment"># 返回标量</span></span><br><span class="line">    <span class="keyword">return</span> math.sqrt(sum(x * x <span class="keyword">for</span> x <span class="keyword">in</span> self))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__neg__</span><span class="params">(self)</span>:</span>  <span class="comment"># 返回同属一类的实例</span></span><br><span class="line">    <span class="keyword">return</span> Vector(-x <span class="keyword">for</span> x <span class="keyword">in</span> self)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__pos__</span><span class="params">(self)</span>:</span>  <span class="comment"># 返回self的副本</span></span><br><span class="line">    <span class="keyword">return</span> Vector(self)</span><br></pre></td></tr></table></figure><p>我们不打算实现<code>__invert__</code>方法，因此如果用户在Vector实例上尝试计算~v，Python会抛出TypeError，而且输出明确的错误消息，&quot;bad operand type for unary ~: 'Vector'&quot;。</p><h2 id="x-和-x-何时不相等">x 和 +x 何时不相等</h2><p>第一例与decimal.Decimal类有关。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> decimal</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ctx = decimal.getcontext()  <span class="comment"># 当前上下文</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ctx.prec = <span class="number">40</span>  <span class="comment"># 精度设为40</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one_third = decimal.Decimal(<span class="string">'1'</span>) / decimal.Decimal(<span class="string">'3'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one_third</span><br><span class="line">Decimal(<span class="string">'0.3333333333333333333333333333333333333333'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one_third == +one_third</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ctx.prec = <span class="number">28</span>  <span class="comment"># 改变精度</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one_third == +one_third</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>+one_third  <span class="comment"># +one_third的精度与one_third的精度不一样</span></span><br><span class="line">Decimal(<span class="string">'0.3333333333333333333333333333'</span>)</span><br></pre></td></tr></table></figure><p>第二例与collections.Counter类有关。</p><p>Counter类实现了几个算术运算符，例如中缀运算符+，作用是把两个Counter实例的计数器加在一起。然而，从实用角度出发，Counter相加时，负值和零值计数会从结果中剔除。而一元运算符+等同于加上一个空Counter，因此它产生一个新的Counter且保留大于零的计数器。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct = Counter(<span class="string">'abracadabra'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct[<span class="string">'r'</span>] = <span class="number">-3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct[<span class="string">'d'</span>] = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct</span><br><span class="line">Counter(&#123;<span class="string">'a'</span>: <span class="number">5</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">1</span>, <span class="string">'d'</span>: <span class="number">0</span>, <span class="string">'r'</span>: <span class="number">-3</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>+ct</span><br><span class="line">Counter(&#123;<span class="string">'a'</span>: <span class="number">5</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct == +ct</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="重载向量加法运算符">重载向量加法运算符</h1><p>序列应该支持<code>+</code>运算符（用于拼接），以及<code>*</code>运算符（用于重复复制）。然而，对Vector类型来说，使用向量数学运算实现<code>+</code>和<code>*</code>运算符更有意义。</p><p>如果尝试把两个不同长度Vector实例加在一起会怎样？此时可以抛出错误，但是根据实际运行情况（例如信息检索），最好使用零填充较短的那个向量。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> vector <span class="keyword">import</span> Vector</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v2 = Vector([<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + v2</span><br><span class="line">Vector([<span class="number">9.0</span>, <span class="number">11.0</span>, <span class="number">13.0</span>])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v3 = Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + v3</span><br><span class="line">Vector([<span class="number">4.0</span>, <span class="number">6.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>])</span><br></pre></td></tr></table></figure><p>确定基本要求后，<code>__add__</code>方法的实现如下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在Vector类中定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    pairs = itertools.zip_longest(self, other, fillvalue=<span class="number">0.0</span>)</span><br><span class="line">    <span class="keyword">return</span> Vector(a + b <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs)</span><br></pre></td></tr></table></figure><p><strong>实现一元运算符和中缀运算符的特殊方法一定不能修改操作数。使用这些运算符的表达式期待结果是新对象。只有增量赋值表达式可能会修改第一个操作数（self）。</strong></p><p>上述的<code>__add__</code>方法也支持Vector之外的对象。这是因为<code>__add__</code>使用了zip_longest，它能处理任何可迭代对象，而且构造新Vector实例的生成器表达式仅仅是把zip_longest生成的值对相加，因此可以使用任何生成数字元素的可迭代对象。然而，如果对调操作数，混合类型的加法就会失败。</p><p>为了支持涉及不同类型的运算，Python为中缀运算符特殊方法提供了特殊的分派机制。对表达式 a + b 来说，解释器会执行以下几步操作。</p><ol type="1"><li><p>如果a有<code>__add__</code>方法，而且返回值不是NotImplemented，调用<code>a.__add__(b)</code>，然后返回结果。</p></li><li><p>如果a没有<code>__add__</code>方法，或者调用<code>__add__</code>方法返回NotImplemented，检查b有没有<code>__radd__</code>方法（<code>__add__</code>的“反向”reversed版本），如果有，而且没有返回NotImplemented，调用<code>b.__radd__(a)</code>，然后返回结果。</p></li><li><p>如果b没有<code>__radd__</code>方法，或者调用<code>__radd__</code>方法返回NotImplemented，抛出TypeError，并在错误消息中指明操作类型不支持。</p></li></ol><img src="http://www.plantuml.com/plantuml/svg/bP2zJiCm58NtFCLLfoBK3XaPkZ6mCB57Dhb09F8ZnnswC24XaA11G8jeLRPE20O6H47gqzZfnYlWsB4980Q695V7dyyzEGTHY81nnWSGOhxBeen7QUBbd7245e5re2qWEKH9rkTEbjFJeo0WOHW4SlGgdsz4CVvulpVa7h7Swk9534UaQzasNIllZiktApcRQdOVEQ6MDhgyVTfE-LQS7MAC2SUmOPsaF587pdvvBIQpXXr3tcSkF3KfsLynwVUOjElWDlcTan9Fls43nF1S59UhPL4-Zik7-R_p-_Q6F9k8ayNE8CDDnbAc6QmcJzSDdPvkKprcfDNoOcu5tPwIr4hFp4gq7TLVwBYR5URKNbsMSwIre_x32jMIqdIW6ZFdNrjyQ-X3Wsmiydzk-WG0"><p><strong>别把NotImplemented和NotImplementedError搞混了。前者是特殊的单例值，如果中缀运算符特殊方法不能处理给定的操作数，那么要把它返回（return）给解释器。而NotImplementedError是一种异常，抽象类中占位方法把它抛出（raise），提醒子类必须覆盖。</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在Vector类中定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    pairs = itertools.zip_longest(self, other, fillvalue=<span class="number">0.0</span>)</span><br><span class="line">    <span class="keyword">return</span> Vector(a + b <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__radd__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self + other  <span class="comment"># 直接委托__add__，处理数字和向量时，+可以交换，但是拼接序列时不行。</span></span><br></pre></td></tr></table></figure><p><strong>一般来说，如果中缀运算符的正向方法只处理与self属于同一类型的操作数，那就无需实现对应的反向方法，因为按照定义，反向方法是为了处理类型不同的操作数。</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> vector <span class="keyword">import</span> Vector</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + (<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">Vector([<span class="number">5.0</span>, <span class="number">5.0</span>, <span class="number">5.0</span>])  <span class="comment"># __add__方法可以处理任何具有数值元素的可迭代对象</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + <span class="number">1</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"/Users/cws/Desktop/vector.py"</span>, line <span class="number">49</span>, <span class="keyword">in</span> __add__</span><br><span class="line">    pairs = itertools.zip_longest(self, other, fillvalue=<span class="number">0.0</span>)</span><br><span class="line">TypeError: zip_longest argument <span class="comment">#2 must support iteration  # 错误消息明确</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + <span class="string">'abc'</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"/Users/cws/Desktop/vector.py"</span>, line <span class="number">50</span>, <span class="keyword">in</span> __add__</span><br><span class="line">    <span class="keyword">return</span> Vector(a + b <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs)</span><br><span class="line">  File <span class="string">"/Users/cws/Desktop/vector.py"</span>, line <span class="number">11</span>, <span class="keyword">in</span> __init__</span><br><span class="line">    self._components = array(self.typecode, components)</span><br><span class="line">  File <span class="string">"/Users/cws/Desktop/vector.py"</span>, line <span class="number">50</span>, <span class="keyword">in</span> &lt;genexpr&gt;</span><br><span class="line">    <span class="keyword">return</span> Vector(a + b <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs)</span><br><span class="line">TypeError: unsupported operand type(s) <span class="keyword">for</span> +: <span class="string">'float'</span> <span class="keyword">and</span> <span class="string">'str'</span>  <span class="comment"># 问题严重</span></span><br></pre></td></tr></table></figure><p>v1 + 'abc'是无法计算的：如果由于类型不兼容而导致运算符特殊方法无法返回有效的结果，那么应该返回NotImplemented。如果抛出异常，就终止了运算符分派机制。对TypeError来说，通常最好将其捕获，然后返回NotImplemented。这样，解释器会尝试调用反向运算符方法，如果操作数是不同的类型，对调之后，反向运算符方法可能会正确计算。</p><p>为了遵守鸭子类型精神，我们不能测试other操作数的类型，或者它的元素的类型。我们要捕获异常，然后返回NotImplemented。如果解释器还未反转操作数，那么它将尝试去做。如果反方向方法返回NotImplemented，那么Python会抛出TypeError，并返回一个标准的错误消息。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在Vector类中定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span>  <span class="comment"># 最终版本</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pairs = itertools.zip_longest(self, other, fillvalue=<span class="number">0.0</span>)</span><br><span class="line">        <span class="keyword">return</span> Vector(a + b <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs)</span><br><span class="line">    <span class="keyword">except</span> TypeError:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br></pre></td></tr></table></figure><h1 id="重载标量乘法运算符">重载标量乘法运算符<code>*</code></h1><p>标量积（scalar product）：<code>Vector([1, 2, 3]) * x</code>，x是数字，结果是一个新Vector实例，各个分量都会乘以x。这也叫元素级乘法（elementwise multiplication）。</p><p>向量点积（dot product）：矩阵乘法。NumPy等库目前的做法是，不重载这两种意义的<code>*</code>，只用<code>*</code>计算标量积。例如，在NumPy中，点积使用<code>numpy.dot()</code>函数计算。</p><p><em>从Python3.5起，<code>@</code>记号可以用作中缀点积运算符。</em></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在Vector类中定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, scalar)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Vector(n * scalar <span class="keyword">for</span> n <span class="keyword">in</span> self)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__rmul__</span><span class="params">(self, scalar)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self * scalar</span><br></pre></td></tr></table></figure><p>这两个方法确实可用，但是提供不兼容的操作数时会出问题。scalar参数的值要是数字，与浮点数相乘得到的积是另一个浮点数。因此，不能使用复数，但可以是int、bool（int的子类），甚至fractions.Fraction实例等标量。</p><p>我们可以采用鸭子类型技术，在<code>__mul__</code>方法中捕获TypeError。但是，这个问题有个更易于理解的方式，而且也更合理：白鹅类型。我们将使用isinstance()检查scalar的类型，但是不硬编码具体的类型，而是检查numbers.Real抽象基类。这个抽象基类涵盖了我们所需的全部类型，而且还支持以后声明为numbers.Real抽象基类的真实子类或虚拟子类的数值类型。（decimal.Decimal没有把自己注册为numbers.Real的虚拟子类。因此，Vector类不会处理decimal.Decimal数字）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numbers</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在类中定义</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, scalar)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(scalar, numbers.Real):  <span class="comment"># 显示检查抽象类型</span></span><br><span class="line">            <span class="keyword">return</span> Vector(n * scalar <span class="keyword">for</span> n <span class="keyword">in</span> self)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NotImplemented</span>  <span class="comment"># 返回NotImplemented，让Python尝试在scalar操作数上调用__rmul__方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__rmul__</span><span class="params">(self, scalar)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self * scalar</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__matmul__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> sum(a * b <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(self, other))</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__rmatmul__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self @ other  <span class="comment"># 委托</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> vector <span class="keyword">import</span> Vector</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 * <span class="number">11</span></span><br><span class="line">Vector([<span class="number">11.0</span>, <span class="number">22.0</span>, <span class="number">33.0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">11</span> * v1</span><br><span class="line">Vector([<span class="number">11.0</span>, <span class="number">22.0</span>, <span class="number">33.0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 * <span class="literal">True</span></span><br><span class="line">Vector([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 * Fraction(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">Vector([<span class="number">0.3333333333333333</span>, <span class="number">0.6666666666666666</span>, <span class="number">1.0</span>])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>va = Vector([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vz = Vector([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>va @ vz</span><br><span class="line"><span class="number">38.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>] @ vz  <span class="comment"># 反向调用成功</span></span><br><span class="line"><span class="number">380.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>va @ <span class="number">3</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unsupported operand type(s) <span class="keyword">for</span> @: <span class="string">'Vector'</span> <span class="keyword">and</span> <span class="string">'int'</span></span><br></pre></td></tr></table></figure><h1 id="中缀运算符方法的名称">中缀运算符方法的名称</h1><table><thead><tr class="header"><th>运算符</th><th>正向方法</th><th>反向方法</th><th>就地（in-place）方法</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>+</code></td><td><code>__add__</code></td><td><code>__radd__</code></td><td><code>__iadd__</code></td><td>加法或拼接</td></tr><tr class="even"><td><code>-</code></td><td><code>__sub__</code></td><td><code>__rsub__</code></td><td><code>__isub__</code></td><td>减法</td></tr><tr class="odd"><td><code>*</code></td><td><code>__mul__</code></td><td><code>__rmul__</code></td><td><code>__imul__</code></td><td>乘法或重复复制</td></tr><tr class="even"><td><code>/</code></td><td><code>__truediv__</code></td><td><code>__rtruediv__</code></td><td><code>__itruediv__</code></td><td>除法</td></tr><tr class="odd"><td><code>//</code></td><td><code>__floordiv__</code></td><td><code>__rfloordiv__</code></td><td><code>__ifloordiv__</code></td><td>整除</td></tr><tr class="even"><td><code>%</code></td><td><code>__mod__</code></td><td><code>__rmod__</code></td><td><code>__imod__</code></td><td>取模</td></tr><tr class="odd"><td><code>divmod()</code></td><td><code>__divmod__</code></td><td><code>__rdivmod__</code></td><td><code>__idivmod__</code></td><td>返回由整除的商和模数组成的元组</td></tr><tr class="even"><td><code>**, pow()</code></td><td><code>__pow__</code></td><td><code>__rpow__</code></td><td><code>__ipow__</code></td><td>取幂</td></tr><tr class="odd"><td><code>@</code></td><td><code>__matmul__</code></td><td><code>__rmatmul__</code></td><td><code>__imatmul__</code></td><td>矩阵乘法</td></tr><tr class="even"><td><code>&amp;</code></td><td><code>__and__</code></td><td><code>__rand__</code></td><td><code>__iand__</code></td><td>位与</td></tr><tr class="odd"><td><code>|</code></td><td><code>__or__</code></td><td><code>__ror__</code></td><td><code>__ior__</code></td><td>位或</td></tr><tr class="even"><td><code>^</code></td><td><code>__xor__</code></td><td><code>__rxor__</code></td><td><code>__ixor__</code></td><td>位异或</td></tr><tr class="odd"><td><code>&lt;&lt;</code></td><td><code>__lshift__</code></td><td><code>__rlshift__</code></td><td><code>__ilshift__</code></td><td>按位左移</td></tr><tr class="even"><td><code>&gt;&gt;</code></td><td><code>__rshift__</code></td><td><code>__rrshift__</code></td><td><code>__irshift</code></td><td>按位右移</td></tr></tbody></table><h1 id="众多比较运算符">众多比较运算符</h1><p>Python解释器对众多比较运算符的处理与前文类似，不过在两个方面有重大区别。</p><ul><li>正向和反向调用使用的是同一系列方法。</li><li>对<code>==</code>和<code>!=</code>来说，如果反向调用失败，Python会比较对象的ID，而不抛出TypeError。</li></ul><table><thead><tr class="header"><th>分组</th><th>中缀运算符</th><th>正向方法调用</th><th>反向方法调用</th><th>后备机制</th></tr></thead><tbody><tr class="odd"><td>相等性</td><td><code>a == b</code></td><td><code>a.__eq__(b)</code></td><td><code>b.__eq__(a)</code></td><td>返回<code>id(a) == id(b)</code></td></tr><tr class="even"><td></td><td><code>a != b</code></td><td><code>a.__ne__(b)</code></td><td><code>b.__ne__(a)</code></td><td>返回<code>not (a == b)</code></td></tr><tr class="odd"><td>排序</td><td><code>a &gt; b</code></td><td><code>a.__gt__(b)</code></td><td><code>b.__lt__(a)</code></td><td>抛出<code>TypeError</code></td></tr><tr class="even"><td></td><td><code>a &lt; b</code></td><td><code>a.__lt__(b)</code></td><td><code>b.__gt__(a)</code></td><td>抛出<code>TypeError</code></td></tr><tr class="odd"><td></td><td><code>a &gt;= b</code></td><td><code>a.__ge__(b)</code></td><td><code>b.__le__(a)</code></td><td>抛出<code>TypeError</code></td></tr><tr class="even"><td></td><td><code>a &lt;= b</code></td><td><code>a.__le__(b)</code></td><td><code>b.__ge__(a)</code></td><td>抛出<code>TypeError</code></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在Vector类中定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (len(self) == len(other) <span class="keyword">and</span>    <span class="comment"># 等价于 tuple(self) == tuple(other)</span></span><br><span class="line">            all(a == b <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(self, other)))  <span class="comment"># 但是明显此法更高效</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> vector <span class="keyword">import</span> Vector</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>va = Vector([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vb = Vector(range(<span class="number">1</span>, <span class="number">4</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>va == vb</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>va == (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>va == (1, 2, 3)的结果不是很理想，对操作数过度宽容可能导致令人惊讶的结果，而程序员讨厌惊喜。从Python自身来找线索，我们发现[1,2] == (1,2)的结果是False，因此，我们要保守一点，做些类型检查。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在Vector类中定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(other, Vector):</span><br><span class="line">        <span class="keyword">return</span> (len(self) == len(other) <span class="keyword">and</span></span><br><span class="line">                all(a ==b <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(self, other)))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span>  <span class="comment"># 让Python编辑器处理</span></span><br></pre></td></tr></table></figure><p>我们不用实现<code>__ne__</code>方法，因为从object继承的<code>__ne__</code>方法的后备行为满足了我们的需求。从object中继承的<code>__ne__</code>方法，运作方式与下述代码类似，不过原版是用C语言实现的：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__ne__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    eq_result = self == other</span><br><span class="line">    <span class="keyword">if</span> eq_result <span class="keyword">is</span> <span class="built_in">NotImplemented</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> eq_result</span><br></pre></td></tr></table></figure><h1 id="增量赋值运算符">增量赋值运算符</h1><p>Vector类已经支持增量赋值运算符<code>+=</code>和<code>*=</code>了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> vector <span class="keyword">import</span> Vector</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1_alias = v1</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(v1)</span><br><span class="line"><span class="number">4358324120</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 += Vector([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(v1)  <span class="comment"># v1重新绑定了实例</span></span><br><span class="line"><span class="number">4359075992</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1</span><br><span class="line">Vector([<span class="number">5.0</span>, <span class="number">7.0</span>, <span class="number">9.0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1_alias  <span class="comment"># 原来的实例没有变</span></span><br><span class="line">Vector([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 *= <span class="number">2</span>  <span class="comment"># 增量乘法运算</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1</span><br><span class="line">Vector([<span class="number">10.0</span>, <span class="number">14.0</span>, <span class="number">18.0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(v1)</span><br><span class="line"><span class="number">4359074872</span></span><br></pre></td></tr></table></figure><p>如果一个类没有实现就地运算符，增量赋值运算只是语法糖：a += b的作用与a = a + b完全一样。对不可变类型来说，这是预期的行为，而且，如果定义了<code>__add__</code>方法的话，不用编写额外的代码，+=就能使用。</p><p>然而，如果实现了就地运算符方法，例如<code>__iadd__</code>方法，计算a += b的结果时会调用它。这种运算符的名称表明，它们会就地修改左操作数，而不会创建新的对象作为结果。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> overloading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承的优缺点</title>
      <link href="/notes/fluent-python/inheritance-for-good-or-for-worse/"/>
      <url>/notes/fluent-python/inheritance-for-good-or-for-worse/</url>
      
        <content type="html"><![CDATA[<h1 id="子类化内置类型很麻烦">子类化内置类型很麻烦</h1><p>在Python2.2之前，内置类型（如list或dict）不能子类化。在Python2.2之后，内置类型可以子类化了，但是有个重要的注意事项：<strong>内置类型（使用C语言编写）不会调用用户定义的类覆盖的特殊方法。</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">DoppelDict</span><span class="params">(dict)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line"><span class="meta">... </span>            super().__setitem__(key, [value] * <span class="number">2</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd = DoppelDict(one=<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd</span><br><span class="line">&#123;<span class="string">'one'</span>: <span class="number">1</span>&#125;  <span class="comment"># __init__方法没有调用覆盖的__setitem__方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd[<span class="string">'two'</span>] = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd</span><br><span class="line">&#123;<span class="string">'two'</span>: [<span class="number">2</span>, <span class="number">2</span>], <span class="string">'one'</span>: <span class="number">1</span>&#125;  <span class="comment"># []运算符调用了</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd.update(three=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd</span><br><span class="line">&#123;<span class="string">'three'</span>: <span class="number">3</span>, <span class="string">'two'</span>: [<span class="number">2</span>, <span class="number">2</span>], <span class="string">'one'</span>: <span class="number">1</span>&#125;  <span class="comment"># upate方法没调用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd.get(<span class="string">'three'</span>)  <span class="comment"># get方法没调用</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>原生类型的这种行为违背了面向对象编程的一个基本原则：<strong>始终应该从示例（self）所属的类开始搜索方法，即使在超类中调用也是如此。</strong>在这种糟糕的局面中，<code>__missing__</code>方法却能按预期方式工作，不过这只是特例。</p><a id="more"></a><p>不只是实例内部的调用有这个问题，内置类型的方法调用的其他类的方法，如果被覆盖了，也不会被调用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">AnswerDict</span><span class="params">(dict)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span> <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ad = AnswerDict(a=<span class="string">'foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ad[<span class="string">'a'</span>]  <span class="comment"># 实例内部</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.update(ad)  <span class="comment"># 内置dict类型读取AnswerDict实例的值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'a'</span>]  <span class="comment"># 没有调用覆盖的__getitem__方法</span></span><br><span class="line"><span class="string">'foo'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="string">'foo'</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>不要子类化内置类型，用户自己定义的类应该继承collections模块中的类，例如UserDict、UserList和UserString，这些类做了特殊设计，因此易于扩展。</strong></p><h1 id="多重继承和方法解析顺序">多重继承和方法解析顺序</h1><p>任何实现多重继承的语言都要处理潜在的命名冲突，这种冲突由不相关的祖先类实现同名方法引起。这种冲突称为“菱形问题”。</p><figure class="highlight python"><figcaption><span>diamond.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'A ping:'</span>, self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pong</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'B pong:'</span>, self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pong</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'C pong:'</span>, self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B, C)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().ping()</span><br><span class="line">        print(<span class="string">'D ping:'</span>, self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pingpong</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.ping()</span><br><span class="line">        super().ping()</span><br><span class="line">        self.pong()</span><br><span class="line">        super().pong()</span><br><span class="line">        C.pong(self)</span><br></pre></td></tr></table></figure><img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pYnApabDuSe0SL9p2qeg5N9JSvDIYxYISnABYnKS5Qgv582W83ClNKEJgnOgx0GJpaSHTiOkx89g28m9L-MeO5EZgwlW16BewIaummJ03BreeDjIKlDYzO0Ad20IBY06K2M8rhC3gdD6KUS2ueFL0G00"><p>说明“菱形问题”的UML类图。虚线箭头是该示例的方法解析顺序。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> diamond <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = D()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.pong()  <span class="comment"># 直接调用，按MRO搜索，运行的是B类中的版本</span></span><br><span class="line">B pong: &lt;diamond.D object at <span class="number">0x10d5d4e80</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.pong(d)  <span class="comment"># 调用指定超类中的方法，此时要把实例作为显式参数传入</span></span><br><span class="line">C pong: &lt;diamond.D object at <span class="number">0x10d5d4e80</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>D.__mro__  <span class="comment"># D类的__mro__属性</span></span><br><span class="line">(&lt;class 'diamond.D'&gt;, &lt;class 'diamond.B'&gt;, &lt;class 'diamond.C'&gt;, &lt;class 'diamond.A'&gt;, &lt;class 'object'&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.pingpong()</span><br><span class="line">A ping: &lt;diamond.D object at <span class="number">0x10d5d4e80</span>&gt;</span><br><span class="line">D ping: &lt;diamond.D object at <span class="number">0x10d5d4e80</span>&gt;  <span class="comment"># 前两行是self.ping()的结果</span></span><br><span class="line">A ping: &lt;diamond.D object at <span class="number">0x10d5d4e80</span>&gt;  <span class="comment"># super().ping()</span></span><br><span class="line">B pong: &lt;diamond.D object at <span class="number">0x10d5d4e80</span>&gt;  <span class="comment"># self.pong()</span></span><br><span class="line">B pong: &lt;diamond.D object at <span class="number">0x10d5d4e80</span>&gt;  <span class="comment"># super().pong()</span></span><br><span class="line">C pong: &lt;diamond.D object at <span class="number">0x10d5d4e80</span>&gt;  <span class="comment"># C.pong(d)</span></span><br></pre></td></tr></table></figure><p>Python能区分d.pong()调用的是哪个方法，是因为Python会按照特定的顺序遍历继承图。这个顺序叫方法解析顺序（Method Resolution Order，MRO）。类都有一个名为<code>__mro__</code>的属性，它的值是一个元组，按照方法解析顺序列出各个超类，从当前类一直向上，直到object类。方法解析顺序不仅考虑继承图，还考虑子类声明中列出超类的顺序。如果把D类声明为<code>class D(C, B):</code>，那么D类的<code>__mro__</code>属性就会不一样，先搜索C类，再搜索B类。</p><p>若想把方法委托给超类，推荐的方式是使用内置的super()函数，最安全，也不易过时。调用框架或不受自己控制的类层次结构中的方法时，尤其适合使用super()。使用super()调用方法时，会遵守方法解析顺序。然而，有时可能需要绕过方法解析顺序，直接调用某个超类的方法。例如C.pong(d)。注意，直接在类上调用实例方法时，必须显式地传入self参数，因为这样访问的是未绑定方法（unbound method）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">print_mro</span><span class="params">(cls)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">', '</span>.join(c.__name__ <span class="keyword">for</span> c <span class="keyword">in</span> cls.__mro__))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_mro(bool)</span><br><span class="line">bool, int, object</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numbers</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_mro(numbers.Integral)</span><br><span class="line">Integral, Rational, Real, Complex, Number, object</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> io</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_mro(io.BytesIO)</span><br><span class="line">BytesIO, _BufferedIOBase, _IOBase, object  <span class="comment"># 以Base结尾的是抽象基类</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_mro(io.TextIOWrapper)</span><br><span class="line">TextIOWrapper, _TextIOBase, _IOBase, object</span><br></pre></td></tr></table></figure><p>多重继承能发挥积极作用。《设计模式:可复用面向对象软件的基础》一书中的适配器模式用的就是多重继承，因此使用多重继承肯定没有错（那本书中的其他22个设计模式都使用单继承，因此多重继承显然不是灵丹妙药)。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> inheritance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标准库中的抽象基类</title>
      <link href="/notes/fluent-python/abc-s-in-standard-library/"/>
      <url>/notes/fluent-python/abc-s-in-standard-library/</url>
      
        <content type="html"><![CDATA[<h1 id="collections.abc模块中的抽象基类">collections.abc模块中的抽象基类</h1><p>Python3.4在collections.abc模块中定义了16个抽象基类（Python3.6定义了25个），简要的UML类图如下。</p><img src="http://www.plantuml.com/plantuml/svg/TP513e8m44NtdA8Nu0Rkt6YCAnFs0qoaILiGXXYCXpS2RMTQtRxv_tVcjzCjAhG3BSgYhN4ie9veX8RKcN24sc0anzuHQCT5D_t2bYd06EavmTH9ikPIpqFmCQDhcEOAmw3TdKiecrOQdmpEz7tdHzOso2A3WSHkTfAv5rmIKe6PSME-8tLubsMyJEAmaiH-eLHCHUWvyIVS1sHoAjPlIToCUQUGqG_5UgHFs2T9pxjI34C-KcAYo6BN0OMksVEfE1lzDyMF-W00"><a id="more"></a><ul><li><p>Iterable、Container和Sized</p><p>各个集合应该继承这三个抽象基类，或者至少实现兼容的协议。</p></li><li><p>Sequence、Mapping和Set</p><p>这三个是主要的不可变集合类型，而且各自都有可变的子类。</p></li><li><p>MappingView</p><p>在Python3中，映射方法.items()、.keys()、.values()返回的对象分别是ItemsView、KeysView和ValuesView的实例。前两个类还从Set类继承了丰富的接口。</p></li><li><p>Callable和Hashable</p><p>这两个抽象基类与集合没有太大的关系，只不过因为collections.abc是标准库中定义抽象基类的第一个模块，而它们又太重要了，因此才把它们放到collections.abc模块中。这两个抽象基类的主要作用是为内置函数isinstance提供支持，以一种安全的方式判断对象能不能调用或散列。若想检查是否能调用，可以使用内置的callable()函数；但是没有类似的hashable()函数，因此测试对象是否可散列，最好使用isinstance(my_obj, Hashable)。</p></li><li><p>Iterator</p><p>注意它是Iterable的子类。</p></li></ul><p>继collections.abc之后，标准库中最有用的抽象基类包是numbers。</p><h1 id="抽象基类的数字塔">抽象基类的数字塔</h1><img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYIamgBYbAJ2vHy2j5vJldvnRaf5OW189I4tEGU8abcVbvo2AUUIMfwKL04OX92ZOrkhfmKw0qH11i4eY0Sc56mHWGOPXv0000"><p>如果想检查一个数是不是整数，可以使用instance(x, numbers.Integral)，这样代码就能接受int、bool（int的子类），或者外部库使用numbers抽象基类注册的其他类型。</p><p>与之类似，如果一个值可能是浮点数类型，可以使用instance(x, numbers.Real)检查。这样代码就能接受bool、int、float、fractions.Fraction，或者外部库提供的非复数类型。</p><p>decimal.Decimal没有注册为numbers.Real的虚拟子类。原因是，如果你的程序需要Decimal的精度，要防止与其他低精度数字类型混淆，尤其是浮点数。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口：协议</title>
      <link href="/notes/fluent-python/interfaces-protocols/"/>
      <url>/notes/fluent-python/interfaces-protocols/</url>
      
        <content type="html"><![CDATA[<h1 id="python文化中的接口和协议">Python文化中的接口和协议</h1><p>接口在动态类型语言中是怎么运作的呢？首先，基本的事实是，Python语言没有interface关键字，而且除了抽象基类，每个类都有接口：类实现或继承的公开属性（方法或数据属性），包括特殊方法，如<code>__getitem__</code>或<code>__add__</code>。</p><p>按照定义，受保护的属性和私有属性不在接口中：即便“受保护的”属性也只是采用命名约定实现的（单个前导下划线）；私有属性可以轻松地访问，原因也是如此。不要违背这些约定有意访问私有属性。</p><p>另一方面，不要觉得把公开数据属性放入对象的接口中不妥，因为如果需要，总能实现读值方法和设值方法，把数据属性变成特性，使用obj.attr句法的客户代码不会收到影响。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span>:</span></span><br><span class="line">    typecode = <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = float(x)  <span class="comment"># x和y是公开数据属性</span></span><br><span class="line">        self.y = float(y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (i <span class="keyword">for</span> i <span class="keyword">in</span> (self.x, self.y))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 其他方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重构：把x和y变成只读特性，但是Vector2d的基本接口没变：</span></span><br><span class="line"><span class="comment"># 用户仍能读取my_vector.x和my_vector.y</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span>:</span></span><br><span class="line">    typecode = <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.__x = float(x)</span><br><span class="line">        self.__y = float(y)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__x</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">y</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__y</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 不受影响</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (i <span class="keyword">for</span> i <span class="keyword">in</span> (self.x, self.y))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 其他方法</span></span><br></pre></td></tr></table></figure><p>关于接口，这里有个实用的补充定义：对象公开方法的子集，让对象在系统中扮演特定的角色。Python文档中的“文件类对象”或“可迭代对象”就是这个意思，这种说法指的不是特定的类。</p><p>协议是接口，但不是正式的（只由文档和约定定义），因此协议不能像正式接口那样施加限制。一个类可能只实现部分接口，这是允许的。</p><h1 id="python喜欢序列">Python喜欢序列</h1><img src="http://www.plantuml.com/plantuml/svg/VP113i8W44Ntd68kq1kuS-NQ0n0AFvQaK8MfKIjt5rDj0mjc-UU_p9y_M0E2k_AJ75oF85GVEIZDT9myA-iHQ16KPt7WOJA9bhybaPHwTKKfHThP4oEeVaGJjTbKOcVxWcao8to5u3R3w_Qb2pWVSvdyUheyfRbuezhyKbPgm1qXmjGRwmqUfQIdsNEElFTvU7VT5bniNPNosaMXVG00"><p>箭头由子类指向超类，以斜体显示的是抽象方法。</p><p>现在，看看示例中的Foo类。它没有继承abc.Sequence，而且只实现了序列协议的一个方法<code>__getitem__</code>（没有实现<code>__len__</code>方法）。这样足够访问元素、迭代和使用in运算符了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, pos)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> range(<span class="number">0</span>, <span class="number">30</span>, <span class="number">10</span>)[pos]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">1</span>]</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> f: print(i)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">20</span> <span class="keyword">in</span> f</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">15</span> <span class="keyword">in</span> f</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>Python数据模型的哲学是尽量支持基本协议。对序列来说，即便是最简单的实现，Python也会力求做到最好。鉴于序列协议的重要性，如果没有<code>__iter__</code>和<code>__contains__</code>方法，Python会调用<code>__getitem__</code>方法，设法让迭代和in运算符可用。Python中的迭代是鸭子类型的一种极端形式：为了迭代对象，解释器会尝试调用两个不同的方法。</p><h1 id="使用猴子补丁在运行时实现协议">使用猴子补丁在运行时实现协议</h1><p>示例中的FrenchDeck类有个重大缺陷：无法洗牌。如果FrenchDeck实例的行为像序列，那么它就不需要shuffle方法，因为已经有random.shuffle函数可用。如果遵守既定协议，很有可能增加利用现有的标准库和第三方代码的可能性，这得益于鸭子类型。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/random#random.shuffle" target="_blank" rel="noopener"><code>random.shuffle(x[, random])</code></a></p><p>Shuffle the sequence x in place.</p></blockquote><figure class="highlight python"><figcaption><span>frenchdeck.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">Card = collections.namedtuple(<span class="string">'Card'</span>, [<span class="string">'rank'</span>, <span class="string">'suit'</span>])</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrenchDeck</span>:</span>  <span class="comment"># 实现序列协议的FrenchDeck类</span></span><br><span class="line">    ranks = [str(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">11</span>)] + list(<span class="string">'JQKA'</span>)</span><br><span class="line">    suits = <span class="string">'spades diamonds clubs hearts'</span>.split()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._cards = [Card(rank, suit) <span class="keyword">for</span> suit <span class="keyword">in</span> self.suits</span><br><span class="line">                       <span class="keyword">for</span> rank <span class="keyword">in</span> self.ranks]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._cards)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._cards[item]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> frenchdeck <span class="keyword">import</span> FrenchDeck</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> random <span class="keyword">import</span> shuffle</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck = FrenchDeck()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shuffle(deck)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"/Users/cws/opt/anaconda3/envs/python36/lib/python3.6/random.py"</span>, line <span class="number">277</span>, <span class="keyword">in</span> shuffle</span><br><span class="line">    x[i], x[j] = x[j], x[i]</span><br><span class="line">TypeError: <span class="string">'FrenchDeck'</span> object does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure><p>然而，如果尝试打乱FrenchDeck实例，会出现异常。错误消息相当明确，对象不支持为元素赋值。FrenchDeck只实现了不可变序列协议，可变的序列还必须提供<code>__setitem__</code>方法。Python是动态语言，因此我们可以在运行时修正这个问题，甚至还可以在交互式控制台中。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">set_card</span><span class="params">(deck, position, card)</span>:</span></span><br><span class="line"><span class="meta">... </span>    deck._cards[position] = card</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>FrenchDeck.__setitem__ = set_card</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shuffle(deck)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[:<span class="number">5</span>]</span><br><span class="line">[Card(rank=<span class="string">'5'</span>, suit=<span class="string">'spades'</span>), Card(rank=<span class="string">'5'</span>, suit=<span class="string">'clubs'</span>), Card(rank=<span class="string">'Q'</span>, suit=<span class="string">'clubs'</span>), Card(rank=<span class="string">'10'</span>, suit=<span class="string">'clubs'</span>), Card(rank=<span class="string">'5'</span>, suit=<span class="string">'hearts'</span>)]</span><br></pre></td></tr></table></figure><p>特殊方法<code>__setitem__</code>的签名在语言参考中使用的是self、key和value，而这里使用的是deck、position和card。这么做是为了告诉你，每个Python方法说到底都是普通函数，把第一个参数命名为self只是一种约定。在控制台会话中使用那几个参数没问题，不过在Python源码文件中最好按照文档那样使用self、key和value。</p><p>这里的关键是，<code>set_card</code>函数要知道deck对象有一个名为<code>_cards</code>的属性，而且<code>_cards</code>的只必须是可变序列。然后，我们把<code>set_card</code>函数赋值给特殊方法<code>__setitem__</code>，从而把它依附到FrenchDeck类上。这种技术叫猴子补丁：在运行时修改类或模块，而不改动源码。猴子补丁很强大，但是打补丁的代码与要打补丁的程序耦合十分紧密，而且往往要处理隐藏和没有文档的部分。</p><p>除了举例说明猴子补丁之外，示例还强调了协议是动态的：random.shuffle函数不关心参数的类型，只要那个对象实现了部分可变序列协议即可。即便对象一开始没有所需的方法也没关系，后来再提供也行。目前，本章讨论的主题是“鸭子类型”：对象的类型无关紧要，只要实现了特定的协议即可。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> protocols </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口：抽象基类</title>
      <link href="/notes/fluent-python/interfaces-abc-s/"/>
      <url>/notes/fluent-python/interfaces-abc-s/</url>
      
        <content type="html"><![CDATA[<p>抽象基类与描述符和元类一样，适用于构建框架的工具。因此，只有少数Python开发者编写的抽象基类不会对用户施加不必要的限制，让他们做无用功。不建议自己编写抽象基类，因为很容易过度设计。只要正确使用现有的抽象基类，就能获得99.9%的好处，而不用冒着设计不当导致的巨大风险。</p><p>引入抽象基类之前，Python就已经非常成功了，即便现在也很少有代码使用抽象基类。</p><h1 id="抽象基类">抽象基类</h1><p>Python的抽象基类有一个重要的实用优势：可以使用register类方法在终端用户的代码中把某个类”声明“为一个抽象基类的“虚拟”子类。为此，被注册的类必须满足抽象基类对方法名称和签名的要求，最重要的是要满足底层语义契约；但是，开发那个类时不用了解抽象基类，更不用继承抽象类。这大大地打破了严格的耦合，与面向对象编程人员掌握的知识有很大的出入，因此使用继承时要小心。</p><p>有时，为了让抽象基类识别子类，甚至不用注册。其实，抽象基类的本质就是几个特殊方法。例如：</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Struggle</span>:</span>  <span class="comment"># 无继承</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span> <span class="keyword">return</span> <span class="number">23</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(Struggle(), abc.Sized)  <span class="comment"># 无注册abc.Sized.register(Struggle)</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(Struggle, abc.Sized)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>可以看出，无需注册，abc.Sized也能把Struggle识别为自己的子类，只要实现了特殊方法<code>__len__</code>即可。要使用正确的句法和语义，前者要求没有参数，后者要求返回一个非负整数，指明对象的长度。如果不使用规定的句法和语义实现特殊方法，会导致非常严重的问题。</p><p>如果实现的类体现了numbers、collections.abc或其他框架中抽象基类的概念，要么继承相应的抽象基类（必要时），要么把类注册到相应的抽象基类中。开始开发程序时，不要使用提供注册功能的库或框架，要自己动手注册；如果必要检查参数的类型（这是最常见的），例如检查是不是序列，那就这样做：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">isinstance(the_arg, collections.abc.Sequece)</span><br></pre></td></tr></table></figure><p>继承抽象基类很简单，只需要实现所需的方法，这样也能明确表明开发者的意图。这一意图还能通过注册虚拟子类来实现。此外，使用isinstance和issubclass测试抽象基类更为人接受。过去，这两个函数用来测试鸭子类型，但用于抽象基类会更灵活。毕竟，如果某个组件没有继承抽象基类，事后还可以注册，让显式类型检查通过。</p><p>然而，即便是抽象基类，也不能滥用isinstance检查，用的多了可能导致代码异味，即表明面向对象设计得不好。<strong>在一连串if/elif/elif中使用isinstance检查，然后根据对象的类型执行不同的操作，通常是不好的做法；此时应该使用多态，即采用一定的方式定义类，让解释器把调用分派给正确的方法，而不使用if/elif/elif块硬编码分派逻辑。</strong></p><p><strong>具体使用时，上述建议有一个常见的例外：有些Python API接受一个字符串或字符串序列；因为字符串是序列类型，所以为了把它和其他不可变序列区分开，最简单的方式是使用isinstance(x, str)检查。</strong></p><blockquote><p>尽管抽象基类使得类型检查变得更容易了，但不应该在程序中过度使用它。Python的核心在于它是一门动态语言，它带来了极大的灵活性。如果处处都强制实行类型约束，那么会使代码变得更加复杂，而本不应该如此。我们应该拥抱Python的灵活性。</p><p>——David Beazley和Brian Jones 《Python Cookbook(第3版)中文版》</p></blockquote><p>另一方面，如果必须强制执行API契约，通常可以使用isinstance检查抽象基类。“老兄，如果你想调用我，必须实现这个”，正如本书技术审校Lennart Regebro所说的。这对采用插入式架构的系统来说特别有用。在框架之外，鸭子类型通常比类型检查更简单，也更灵活。</p><p>例如，本书有几个示例要使用序列，把它当成列表处理。我没有检查参数的类型是不是list，而是直接接受参数，立即使用它构建一个列表（list(x)）。这样，我就可以接受任何可迭代对象；如果参数不是可迭代对象，调用立即失败，并且提供非常清晰的错误消息。当然，如果序列太长（复制开销很大）或者需要就地修改序列而导致无法复制参数，就不能采用这种方式；此时，使用isinstance(x, abc.MutableSequence)更好。如果可以接受任何可迭代对象，也可以调用iter(x)函数获得一个迭代器。</p><p>模仿collections.namedtuple处理<code>field_names</code>参数的方式也是一例：<code>field_names</code>的值可以是单个字符串，以空格或逗号分隔标识符，也可以是一个标识符序列。此时可能想使用isinstance，但我会使用鸭子类型。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:  <span class="comment"># 假设是单个字符串</span></span><br><span class="line">    field_names = field_names.replace(<span class="string">','</span>, <span class="string">' '</span>).split()  <span class="comment"># 试图替换并拆分</span></span><br><span class="line"><span class="keyword">except</span> AttributeError:  <span class="comment"># 抱歉，field_names看起来不像是字符串...</span></span><br><span class="line">    <span class="keyword">pass</span>                <span class="comment"># 没有.replace方法，或者返回值不能使用.split方法拆分</span></span><br><span class="line"><span class="comment"># 假设已经是由名称组成的可迭代对象了</span></span><br><span class="line">field_names = tuple(field_names)  <span class="comment"># 确保是可迭代对象，也为了保存一份副本，使用所得值创建一个元组</span></span><br></pre></td></tr></table></figure><h1 id="定义抽象基类的子类">定义抽象基类的子类</h1><img src="http://www.plantuml.com/plantuml/svg/ZLBB4e8m3Bpp5Vq1_i2R9m-U_02ca1tf37rOWgCY_svLK5iLpN6pEybkKYk2W7Py51gwXCzasRAN5OkbDIoLWHTz9aBr6bnR6aG_KGPH5DMTrHP5DZorAuQNPODPgGgaMBPH9z2ife599DXrCDNyf2qu3DD1UUNaeM9oP2FfZ5icgCSUlWMb7MK8XnYgR6VuTULrnzTi_jgyZJR_p24qFpZ163n_CI-TWw4O6-t580xyHdJMfKfjztWBKHBTxlPygiKvpn_NonuF4yFtXqYmARS0frbU0000"><p>Sequence和MutableSequence抽象基类的方法不全是抽象的。以斜体显示的名称是抽象类和抽象方法。</p><figure class="highlight python"><figcaption><span>frenchdeck2.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">Card = collections.namedtuple(<span class="string">'Card'</span>, [<span class="string">'rank'</span>, <span class="string">'suit'</span>])</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrenchDeck2</span><span class="params">(collections.MutableSequence)</span>:</span>  <span class="comment"># 继承抽象基类</span></span><br><span class="line">    ranks = [str(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">11</span>)] + list(<span class="string">'JQKA'</span>)</span><br><span class="line">    suits = <span class="string">'spades diamonds clubs hearts'</span>.split()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._cards = [Card(rank, suit) <span class="keyword">for</span> suit <span class="keyword">in</span> self.suits</span><br><span class="line">                                        <span class="keyword">for</span> rank <span class="keyword">in</span> self.ranks]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._cards)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, position)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._cards[position]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, position, value)</span>:</span>  <span class="comment"># 支持洗牌必须实现__setitem__方法</span></span><br><span class="line">        self._cards[position] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span><span class="params">(self, position)</span>:</span>  <span class="comment"># 必须实现的基类抽象方法</span></span><br><span class="line">        <span class="keyword">del</span> self._cards[position]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, position, value)</span>:</span>  <span class="comment"># 必须实现的基类抽象方法</span></span><br><span class="line">        self._cards.insert(position, value)</span><br></pre></td></tr></table></figure><p>导入时（加载并编译frenchdeck2.py模块时），Python不会检查抽象方法的实现，在运行时实例化FrenchDeck2类时才会真正检查。因此，如果没有正确实现某个抽象方法，Python会抛出TypeError异常，并把错误消息设为&quot;Cant' instantiate abstract class FrenchDeck2 with abstract method <code>__delitem__</code>, insert&quot;。正是这个原因，即便FrenchDeck2类不需要<code>__delitem__</code>和insert提供的行为，也要实现，因为MutableSequence抽象基类需要它们。</p><p>我们还可以覆盖从抽象基类继承的方法，以更高效的方式重新实现。例如，<code>__contains__</code>方法会全面扫描序列，可是，如果你定义的序列按顺序保存元素，那就可以重新定义<code>__contains__</code>方法，使用bisect函数做二分查找，从而提升搜索速度。</p><h1 id="定义并使用一个抽象基类">定义并使用一个抽象基类</h1><p>为了证明有必要定义抽象基类，我们要在框架中找到使用它的场景。想象一下这个场景：你要在网站或移动应用中显示随机广告，但是在整个广告清单轮转一遍之前，不重复显示广告。假设我们构建一个广告管理框架，名为ADAM。它的职责之一是，支持用户提供随机挑选的无重复类。为了让ADAM的用户明确理解“随机挑选的无重复”组件是什么意思，我们将定义一个抽象基类。</p><p>受到“栈”和“队列”（以物体的排列方式说明抽象接口）启发，我将使用现实世界中的物品命名这个抽象基类：宾果机和彩票机是随机从有限的集合中挑选物品的机器，选出的物品没有重复，直到选完为止。我们把这个抽象基类命名为Tombola，这是宾果机和打乱数字的滚动容器的意大利名。</p><p>Tombola抽象基类有四个方法，其中两个是抽象方法。</p><ul><li><code>.load(...)</code>：把元素放入容器。</li><li><code>.pick()</code>：从容器中随机拿出一个元素，返回选中的元素。</li></ul><p>另外两个是具体方法：</p><ul><li><code>.loaded()</code>：如果容器中至少有一个元素，返回True。</li><li><code>.inspect()</code>返回一个有序元组，由容器中的现有元素构成，不会修改容器的内容（内部的顺序不保留）。</li></ul><img src="http://www.plantuml.com/plantuml/svg/dL2n3e8m4DtvYXjrW0ymX05NHlUcBHTiB9IqXuOW_sv56ekBqPkkxrxVlNjdLIDWszC8BRO2RSA58yibmScqmcWEKmA-fe3Fe0slT_jFj5VoigAfhwLvCZ5mLUTwbEHVSo8rTmvArJNco1jSTp2cEaMChH-YFP4uOv9hlP22JcM8q8wbDZUqlsXzyVUAe5AE8C-lojB0DRX1BDEYcFvH3gdczpHz1x25D_T4eooB71sy9ukDRz5YNHGF"><figure class="highlight python"><figcaption><span>tombola.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tombola</span><span class="params">(abc.ABC)</span>:</span>  <span class="comment"># 自定义的抽象基类要继承abc.ABC</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod        # 抽象方法使用abstractmethod装饰器标记</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">(self, iterable)</span>:</span>  <span class="comment"># 而且定义体中通常只有文档字符串</span></span><br><span class="line">        <span class="string">"""从可迭代对象中添加元素"""</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""随机删除元素，然后将其返回。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        如果实例为空，这个方法应该抛出LookupError。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loaded</span><span class="params">(self)</span>:</span>  <span class="comment"># 具体方法</span></span><br><span class="line">        <span class="string">"""如果至少有一个元素，返回True，否则返回False。"""</span></span><br><span class="line">        <span class="keyword">return</span> bool(self.inspect())  <span class="comment"># 具体方法只能依赖抽象基类定义的接口</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inspect</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回一个有序元组，由当前元素构成。"""</span></span><br><span class="line">        items = []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># 我们不知道具体子类如何存储元素，不过为了得到inpect的结果</span></span><br><span class="line">            <span class="keyword">try</span>:     <span class="comment"># 我们可以不断调用.pick()方法，把Tombola清空</span></span><br><span class="line">                items.append(self.pick())</span><br><span class="line">            <span class="keyword">except</span> LookupError:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        self.load(items)  <span class="comment"># 然后再使用.load(...)把所有元素放回去</span></span><br><span class="line">        <span class="keyword">return</span> tuple(sorted(items))</span><br></pre></td></tr></table></figure><p><strong>其实，抽象方法可以有实现代码。即便实现了，子类也必须覆盖抽象方法，但是在子类中可以使用super()函数调用抽象方法，为它添加功能，而不是从头开始实现。</strong></p><p>示例中的inspect()方法实现的方式有些笨拙，不过却表明，有了pick()和load(...)方法，若想查看Tombola中的内容，可以先把所有元素挑出，然后再放回去。这个示例的目的是强调抽象基类可以提供具体方法，只要依赖接口中的其他方法就行。Tombola的具体子类知晓内部数据结构，可以覆盖inspect()方法，使用更聪明的方式实现，但这不是强制要求。</p><p>loaded()方法没有那么笨拙，但是耗时：调用inspect()方法构建有序元组的目的仅仅是在其上调用bool()函数。这样做是可以的，但是具体子类可以做的更好。</p><p>self.pick()抛出LookupError这一事实也是接口的一部分，但是在Python中没办法声明，只能在文档中说明。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BaseException</span><br><span class="line"> +-- Exception</span><br><span class="line">      +-- LookupError</span><br><span class="line">      |    +-- IndexError</span><br><span class="line">      |    +-- KeyError</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> tombola <span class="keyword">import</span> Tombola</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Fake</span><span class="params">(Tombola)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="number">13</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fake  <span class="comment"># 创建子类，不会报错</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Fake</span>'&gt;</span></span><br><span class="line">&gt;&gt;&gt; f = Fake()  # 尝试实例化Fake时抛出了TypeError</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: Can<span class="string">'t instantiate abstract class Fake with abstract methods load  # Python认为Fake是抽象类，因为它没有实现load方法</span></span><br></pre></td></tr></table></figure><h2 id="抽象基类句法详解">抽象基类句法详解</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tombola</span><span class="params">(abc.ABC)</span>:</span>  <span class="comment"># Python3.4之后</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tombola</span><span class="params">(metaclass=abc.ABCMeta)</span>:</span>  <span class="comment"># Python3.4之前</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tombola</span><span class="params">(object)</span>:</span></span><br><span class="line">    __metaclass__ = abc.ABCMeta  <span class="comment"># Python2</span></span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>声明抽象类方法的推荐方式是：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyABC</span><span class="params">(abc.ABC)</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">an_abstract_classmethod</span><span class="params">(cls, ...)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>在函数上堆叠装饰器的顺序通常很重要，<a href="https://devdocs.io/python~3.6/library/abc#abc.abstractmethod" target="_blank" rel="noopener">@abstractmethod的文档</a>就特别指出：</p><blockquote><p>When abstractmethod() is applied in combination with other method descriptors, it should be applied as the innermost decorator.</p></blockquote><h2 id="定义tombola抽象基类的子类">定义Tombola抽象基类的子类</h2><figure class="highlight python"><figcaption><span>bingo.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> tombola <span class="keyword">import</span> Tombola</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BingoCage</span><span class="params">(Tombola)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, items)</span>:</span></span><br><span class="line">        self._randomizer = random.SystemRandom()</span><br><span class="line">        self._items = []</span><br><span class="line">        self.load(items)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">(self, items)</span>:</span></span><br><span class="line">        self._items.extend(item)</span><br><span class="line">        self._randomizer.shuffle(self._items)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self._items.pop()</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">raise</span> LookupError(<span class="string">'pick from empty BingoCage'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.pick()</span><br></pre></td></tr></table></figure><p>BingoCage从Tombola中继承了耗时的loaded方法和笨拙的inspect方法。</p><figure class="highlight python"><figcaption><span>lotto.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> tombola <span class="keyword">import</span> Tombola</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LotteryBlower</span><span class="params">(Tombola)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, iterable)</span>:</span></span><br><span class="line">        self._balls = list(iterable)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">(self, iterable)</span>:</span></span><br><span class="line">        self._balls.extend(iterable)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            position = random.randrange(len(self._balls))</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">raise</span> LookupError(<span class="string">'pick from empty LotteryBlower'</span>)</span><br><span class="line">        <span class="keyword">return</span> self._balls.pop(position)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loaded</span><span class="params">(self)</span>:</span>  <span class="comment"># 覆盖基类方法</span></span><br><span class="line">        <span class="keyword">return</span> bool(self._balls)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inspect</span><span class="params">(self)</span>:</span>  <span class="comment"># 覆盖基类方法</span></span><br><span class="line">        <span class="keyword">return</span> tuple(sorted(self._balls))</span><br></pre></td></tr></table></figure><h2 id="tombola的虚拟子类">Tombola的虚拟子类</h2><p>白鹅类型的一个基本特性：即便不继承，也有办法把一个类注册为抽象基类的虚拟子类。这样做时，我们保证注册的类忠实地实现了抽象基类定义的接口，而Python会相信我们，从而不做检查（即便在实例化时也不会检查）。如果我们说谎了，那么常规的运行时异常会把我们捕获。</p><p>注册虚拟子类的方式是在抽象基类上调用register方法。这么做之后，注册的类会变成抽象基类的虚拟子类，而且issubclass和isinstance等函数都能识别，但是注册的类不会从抽象基类中继承任何方法或属性。</p><p>register方法通常作为普通的函数调用，不过也可以作为装饰器使用。</p><img src="http://www.plantuml.com/plantuml/svg/ROz93i8m34NtEOKlG0w0Aau0AzXN6RxQY0mbCHAexTqfWmG4lBAVRFdztbaGmi1N2WWQMIXTE2l3j3kpqXvxdCw81i9uLGfvLvX6GKkD0TmdErFRkkYuRMlg4Mk82oFQUb6dvEjDAQMOtpQ757JowcNncBP_L0PdZj_49sL_2IhcOXbWUFbOnQPcajbrFSjdz3KrJKQtjCYmcuruq6PQhTvIuYLxlvKVhlNj3G00"><figure class="highlight python"><figcaption><span>tombolist.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randrange</span><br><span class="line"><span class="keyword">from</span> tombola <span class="keyword">import</span> Tombola</span><br><span class="line"></span><br><span class="line"><span class="meta">@Tombola.register  # 把TomboList注册为Tombola的虚拟子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TomboList</span><span class="params">(list)</span>:</span>  <span class="comment"># TomboList扩展list</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self:  <span class="comment"># 从list继承__bool__方法，列表不为空时返回True</span></span><br><span class="line">            position = randrange(len(self))</span><br><span class="line">            <span class="keyword">return</span> self.pop(position)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> LookupError(<span class="string">'pop from empty TomboList'</span>)</span><br><span class="line"></span><br><span class="line">    load = list.extend  <span class="comment"># TomboList.load与list.extend一样</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># loaded = list.__bool__ 是错误的，因为list没有实现__bool__方法</span></span><br><span class="line">    <span class="comment"># 而内置的bool函数在没有实现__bool__方法时还可以使用__len__方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loaded</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(self)  <span class="comment"># 委托bool函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inspect</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> tuple(sorted(self))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是Python3.3之前的版本，不能把register当作类装饰器使用，必须使用标准的调用句法</span></span><br><span class="line"><span class="comment"># Tombola.register(TomboList)</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> tombola <span class="keyword">import</span> Tombola</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> tombolist <span class="keyword">import</span> TomboList</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(TomboList, Tombola)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = TomboList(range(<span class="number">100</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(t, Tombola)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>然而，类的继承关系在一个特殊的类属性中指定——<code>__mro__</code>，即方法解析顺序（Method Resolution Order）。这个属性的作用很简单，按顺序列出类及其超类，Python会按照这个顺序搜索方法。查看TomboList类的<code>__mro__</code>属性，你会发现它只列出了“真实的”超类，即list和object。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>TomboList.__mro__</span><br><span class="line">(&lt;class 'tombolist.TomboList'&gt;, &lt;class 'list'&gt;, &lt;class 'object'&gt;)</span><br></pre></td></tr></table></figure><p><code>TomboList.__mro__</code>中没有Tombola，因此TomboList没有从Tombola中继承任何方法。</p><h1 id="鹅的行为有可能像鸭子">鹅的行为有可能像鸭子</h1><p>即便不注册，抽象基类也能把一个类识别为虚拟子类。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Struggle</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span> <span class="keyword">return</span> <span class="number">23</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(Struggle(), abc.Sized)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(Struggle, abc.Sized)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>这是因为abc.Sized实现了一个特殊的类方法，名为<code>__subclasshook__</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sized</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line"></span><br><span class="line">    __slots__ = ()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__subclasshook__</span><span class="params">(cls, C)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">is</span> Sized:</span><br><span class="line">            <span class="keyword">if</span> any(<span class="string">"__len__"</span> <span class="keyword">in</span> B.__dict__ <span class="keyword">for</span> B <span class="keyword">in</span> C.__mro__):  <span class="comment"># 对C及其超类中所列的类来说，如果有名为__len__的属性</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span>  <span class="comment"># 返回True，表明C是Sized的虚拟子类</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span>  <span class="comment"># 否则返回NotImplemented</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://devdocs.io/python~3.6/library/abc#abc.ABCMeta.__subclasshook__" target="_blank" rel="noopener"><code>__subclasshook__(subclass)</code></a></p><p><strong>(Must be defined as a class method.)</strong></p><p>Check whether subclass is considered a subclass of this ABC.This means that you can customize the behavior of issubclass further without the need to call register() on every class you want to consider a subclass of the ABC. (This class method is called from the <strong>subclasscheck</strong>() method of the ABC.)</p><p>This method should return True, False or NotImplemented.If it returns True, the subclass is considered a subclass of this ABC.If it returns False, the subclass is not considered a subclass of this ABC, even if it would normally be one.If it returns NotImplemented, the subclass check is continued with the usual mechanism.</p></blockquote><p><code>__subclasshook__</code>在白鹅类型中添加了一些鸭子类型的踪迹。</p><p>在自己定义的抽象基类中要不要实现<code>__subclasshook__</code>方法呢？可能不需要。我在Python源码中只见到Sized这一个抽象基类实现了<code>__subclasshook__</code>方法，而Sized只声明了一个特殊方法，因此只用检查这么一个特殊方法。鉴于<code>__len__</code>方法的“特殊性”，我们基本可以确定它能做到该做的事。但是对其他特殊方法和基本的抽象基类来说，很难这么肯定。</p><p>例如，虽然映射实现了<code>__len__</code>、<code>__getitem__</code>和<code>__iter__</code>，但是不应该把它们视作Sequence的子类型，因为不能使用整数偏移值获取元素，也不能保证元素的顺序。当然，OrderedDict除外，它保留了插入元素的顺序，但是不支持通过偏移获取元素。</p><p>自己实现的<code>__subclasshook__</code>方法还可以检查方法签名和其他特性，但我觉得不值得这么做。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/notes/the-art-of-design-patterns/creational-patterns-singleton/"/>
      <url>/notes/the-art-of-design-patterns/creational-patterns-singleton/</url>
      
        <content type="html"><![CDATA[<h1 id="定义">定义</h1><p>单例模式（Singleton Pattern）：确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。</p><p>单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。</p><h1 id="意图">意图</h1><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><a id="more"></a><h1 id="动机">动机</h1><p>对一些类来说，只有一个实例是很重要的。一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID（序号）生成器。</p><p>怎样才能保证一个类只有一个实例并且这个实例易于被访问呢？一个全局变量使得一个对象可以被访问，但它不能防止你实例化多个对象。</p><p>一个更好的办法是，让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求），并且它可以提供一个访问该实例的方法。这就是Singleton模式。</p><h1 id="适用性">适用性</h1><ul><li>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。</li><li>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无须更改代码就能使用一个扩展的实例时。</li></ul><h1 id="结构">结构</h1><img src="http://www.plantuml.com/plantuml/svg/RO-nRi9044Jx-uefJP0jQ454Iec4Ge6e8egBRx5NCMlhRX62Y7-FSo5d5sot-qOpipKx0fqwlUB8rBXWmXTBPxqzeMni26-gdZ_FIkkobHtV23CJ0NOiLKFQ2huD-id14jHAILWCCA8fAjBrWsQJ9ppyxzkEl5Lk9PiyN9EqlzpDaFgIvw-Z4eiKRwHLWWsGURJW8x9KRRN2-twp-JEFD148NSPfowZnf6SlIROq90w_2KRcA3nNjHQZTuP2nKVDpf4SYhx83m00"><h1 id="时序图">时序图</h1><img src="http://www.plantuml.com/plantuml/svg/IqmkoIzIy4tCpEC24GgwTWh1cNdfEQab-NaALWhfgIMUUSKbYNd9gHgQG3vSZWkX2asBZKroKMfYIQgT7LOJYs5i_uBKeiIIpFmy3Kq0"><h1 id="优点">优点</h1><ul><li>对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。</li><li>节约系统资源。由于在系统内只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。</li><li>允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制类似的方法来获得指定数目的对象实例。</li></ul><h1 id="缺点">缺点</h1><ul><li>由于单例模式没有抽象层，因此单例类的扩展有很大困难。</li><li>单例类的职责过重，在一定程度上违反了单一职责原则。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品本身的功能耦合在一起。</li><li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；很多面向对象语言（如Java，C#）的运行环境都提供了自动垃圾回收技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。</li></ul><h1 id="应用">应用</h1><p>一个具有自动编号主键的表可以有多个用户同时使用，但是数据库中只能有一个地方分配下一个主键编号，否则可能会出现主键重复，因此该主键编号生成器必须具备唯一性，可以通过单例模式来实现。</p><h1 id="java代码">Java代码</h1><p>UML类图中的创建方式是不安全的。当创建过程稍长，就可能有多个线程同时进入if块内，重复创建单例类，导致对象状态丢失。下面看看解决方案。</p><p>运用一项叫做Initialization on Demand Holder（IoDH）的技术，既能实现延迟加载（Lazy Load），又可以保证线程安全，不影响系统性能。缺点是与编程语言本身的特性相关，很多面向对象语言不支持IoDH。做法是在单例类中增加一个静态内部类，在该内部类中创建单例对象，再将该单例对象通过getInstance()方法返回给外部使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于静态单例对象不是Singleton的成员变量，因此类加载时不会实例化Singleton，第一次调用getInstance()时将加载内部类Holder，在该内部类中定义了一个static类型的变量instance，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全，确保该成员变量只能初始化一次。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> design patterns </tag>
            
            <tag> The Art of Design Patterns </tag>
            
            <tag> creational </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列的修改、散列和切片</title>
      <link href="/notes/fluent-python/sequence-hacking-hashing-and-slicing/"/>
      <url>/notes/fluent-python/sequence-hacking-hashing-and-slicing/</url>
      
        <content type="html"><![CDATA[<h1 id="表示多维向量的vector类">表示多维向量的Vector类</h1><p>本章定义的Vector类是为了教学而使用的例子。如果在实际使用中需要做向量运算，应该使用NumPy和SciPy。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    typecode = <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, components)</span>:</span></span><br><span class="line">        <span class="comment"># 使用组合模式实现，向量的分量存储在浮点数数组中</span></span><br><span class="line">        self._components = array(self.typecode, components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 使用reprlib.repr()函数获取self._components的有限长度表示形式</span></span><br><span class="line">        <span class="comment"># 如 array('d', [0.0, 1.0, 2.0, 3.0, 4.0, ...])</span></span><br><span class="line">        components = reprlib.repr(self._components)</span><br><span class="line">        <span class="comment"># 去掉 [] 外面的字符</span></span><br><span class="line">        <span class="comment"># 我希望Vector实例的表示形式是 Vector([3.0, 4.0, 5.0])这样</span></span><br><span class="line">        <span class="comment"># 而不是 Vector(array('d', [3.0, 4.0, 5.0]))</span></span><br><span class="line">        <span class="comment"># 因为Vector实例中的数组是实现细节</span></span><br><span class="line">        <span class="comment"># 这两种所构建的Vector对象是一样的，所以我选择使用更简单的句法</span></span><br><span class="line">        components = components[components.find(<span class="string">'['</span>):<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Vector(&#123;&#125;)'</span>.format(components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(tuple(self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bytes__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (bytes([ord(self.typecode)]) +</span><br><span class="line">                bytes(self._components))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> tuple(self) == tuple(other)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 不能使用hypot方法了，先计算所有分量的平方和，在使用sqrt方法</span></span><br><span class="line">        <span class="keyword">return</span> math.sqrt(sum(x * x <span class="keyword">for</span> x <span class="keyword">in</span> self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(abs(self))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">frombytes</span><span class="params">(cls, octets)</span>:</span></span><br><span class="line">        typecode = chr(octets[<span class="number">0</span>])</span><br><span class="line">        memv = memoryview(octets[<span class="number">1</span>:]).cast(typecode)</span><br><span class="line">        <span class="keyword">return</span> cls(memv)</span><br></pre></td></tr></table></figure><p>如果Vector实例的分量超过6个，repr()生成的字符串就会使用...省略一部分。包含大量元素的集合类型一定要这么做，因为字符串表示形式是用于调试的（因此不想让大型对象在控制台或日志中输出几千行内容）。使用reprlib模块可以生成长度有限的表示形式。</p><a id="more"></a><p>编写<code>__repr__</code>方法时，本可以使用这个表达式生成简化的components显示形式：<code>reprlib.repr(list(self._components))</code>。然而，这么做有点浪费，因为要把<code>self._components</code>中的每个元素复制到一个列表中，然后使用列表的表示形式。我没有这么做，而是直接把<code>self._components</code>传给reprlib.repr函数，然后去掉[]外面的字符。</p><h1 id="协议和鸭子类型">协议和鸭子类型</h1><p>在Python中创建功能完善的序列类型无需使用继承，只需实现符合序列<strong>协议</strong>的方法。</p><p>在面向对象编程中，协议是非正式的接口，只在文档中定义，在代码中不定义。例如，Python的序列协议只需要<code>__len__</code>和<code>__getitem__</code>两个方法。任何类，只要使用标准的签名和语义实现了这两个方法，就能用在任何期待序列的地方。即便它是object的子类也无妨，我们说它是序列，因为它的行为像序列，这才是重点。</p><p>协议是非正式的，没有强制力，因此如果你知道类的具体使用场景，通常只需要实现一个协议的部分。例如，为了支持迭代，只需实现<code>__getitem__</code>方法，没必要提供<code>__len__</code>方法。</p><h1 id="可切片的序列">可切片的序列</h1><p>如果能委托给对象中的序列属性（如<code>self._componetns</code>数组），支持序列协议特别简单。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    <span class="comment"># 省略</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._components[index]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(v1)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1[<span class="number">0</span>], v1[<span class="number">-1</span>]</span><br><span class="line">(<span class="number">3.0</span>, <span class="number">5.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v7 = Vector(range(<span class="number">7</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v7[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">array(<span class="string">'d'</span>, [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>])</span><br></pre></td></tr></table></figure><p>可以看到，现在连切片都支持了，不过尚不完美。如果Vector实例的切片也是Vector实例，而不是数组，那就更好了。想想内置的序列类型，切片得到的都是各自类型的新实例，而不是其他类型。为了把Vector实例的切片也变成Vector实例，我们不能简单地委托给数组切片。我们要分析给<code>__getitem__</code>方法的参数，做适当的处理。</p><h2 id="切片原理">切片原理</h2><p>一例胜千言。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MySeq</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> index  <span class="comment"># 直接返回index</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = MySeq()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>]  <span class="comment"># 单个索引</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>:<span class="number">4</span>]  <span class="comment"># 1:4表示法变成了一个slice对象</span></span><br><span class="line">slice(<span class="number">1</span>, <span class="number">4</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>]</span><br><span class="line">slice(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>, <span class="number">9</span>]  <span class="comment"># 如果[]中有逗号，那么__getitem__收到的是元组</span></span><br><span class="line">(slice(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>), <span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>, <span class="number">7</span>:<span class="number">9</span>]  <span class="comment"># 元组中可以有多个切片对象</span></span><br><span class="line">(slice(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>), slice(<span class="number">7</span>, <span class="number">9</span>, <span class="literal">None</span>))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>slice  <span class="comment"># slice是内置的类型</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">slice</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">dir</span><span class="params">(slice)</span></span></span><br><span class="line">['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'indices', 'start', 'step', 'stop']</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(slice.indices)  <span class="comment"># slice.indices方法有很大的作用，但鲜为人知</span></span><br><span class="line">Help on method_descriptor:</span><br><span class="line"></span><br><span class="line">indices(...)</span><br><span class="line">    S.indices(len) -&gt; (start, stop, stride)</span><br><span class="line"></span><br><span class="line">    Assuming a sequence of length len, calculate the start <span class="keyword">and</span> stop</span><br><span class="line">    indices, <span class="keyword">and</span> the stride length of the extended slice described by</span><br><span class="line">    S. Out of bounds indices are clipped <span class="keyword">in</span> a manner consistent <span class="keyword">with</span> the</span><br><span class="line">    handling of normal slices.</span><br><span class="line">    <span class="comment"># 中文翻译 #</span></span><br><span class="line">    给定长度为len的序列，计算S表示的扩展切片的起始（start）和结尾（stop）索引，以及步幅（stride）。超出边界的索引会被截掉，这与常规切片的处理方式一样。</span><br></pre></td></tr></table></figure><p>indices方法开放了内置序列实现的棘手逻辑，用于优雅地处理缺失索引和负数索引，以及长度超过目标序列的切片。这个方法会“整顿”元组，把start、stop和stride都变成非负数，而且都落在指定长度序列的边界内。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设有个长度为5的序列，例如'ABCDE'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>slice(<span class="literal">None</span>, <span class="number">10</span>, <span class="number">2</span>).indices(<span class="number">5</span>)</span><br><span class="line">(<span class="number">0</span>, <span class="number">5</span>, <span class="number">2</span>)  <span class="comment"># 'ABCDE'[:10:2]等同于'ABCDE'[0, 5, 2]</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>slice(<span class="number">-3</span>, <span class="literal">None</span>, <span class="literal">None</span>).indices(<span class="number">5</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>)  <span class="comment"># 'ABCDE'[-3:]等同于'ABCDE'[2:5:1]</span></span><br></pre></td></tr></table></figure><p>在Vector类中无需使用slice.indices()方法，因为收到切片参数时，会委托_components数组处理。但是，如果没有底层序列类型作为依靠，那么使用这个方法能节省大量时间。</p><h2 id="能处理切片的__getitem__方法">能处理切片的<code>__getitem__</code>方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numbers  <span class="comment"># 开头导入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类中定义</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        cls = type(self)</span><br><span class="line">        <span class="keyword">if</span> isinstance(index, slice):  <span class="comment"># 切片</span></span><br><span class="line">            <span class="keyword">return</span> cls(self._components[index])</span><br><span class="line">        <span class="keyword">elif</span> isinstance(index, numbers.Integral):  <span class="comment"># 单个索引</span></span><br><span class="line">            <span class="keyword">return</span> self._components[index]</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 否则抛出异常</span></span><br><span class="line">            msg = <span class="string">'&#123;cls.__name__&#125; indices must be integers'</span></span><br><span class="line">            <span class="keyword">raise</span> TypeError(msg.format(cls=cls))  <span class="comment"># 为了创建符合Python风格的对象，我们要模仿Python内置的对象</span></span><br></pre></td></tr></table></figure><p>大量使用isinstance可能表明面向对象设计得不好，不过在<code>__getitem__</code>方法中使用它处理切片是合理的。numbers.Integral是一个抽象基类（Abstract Base Class，ABC），在isinstance中使用抽象基类做测试能让API更灵活且更容易更新。</p><h1 id="动态存取属性">动态存取属性</h1><p>Vector类没办法通过名称访问向量的分量（如v.x）。现在我们处理的向量可能有大量分量。不过，若能通过单个字母访问前几个分量的话会比较方便。</p><p>比如，用x、y、z和t代替v[0], v[1], v[2]和v[3]。我们可以在Vector中编写四个特性，但这样太麻烦。特殊方法<code>__getattr__</code>提供了更好的方式。属性查找失败后，解释器会调用<code>__getattr__</code>方法。简单来说，对my_obj.x表达式，Python会检查my_obj实例有没有名为x的属性；如果没有，到类（<code>my_obj.__class__</code>）中查找；如果还没有，顺着继承树继续查找（属性查找机制比这复杂的多）。如果依旧找不到，调用my_obj所属类中定义的<code>__getattr__</code>方法，传入self和属性名称的字符形式（如'x'）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 类中定义</span></span><br><span class="line">shortcut_names = <span class="string">'xyzt'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        cls = type(self)</span><br><span class="line">        <span class="keyword">if</span> len(name) == <span class="number">1</span>:</span><br><span class="line">            pos = cls.shortcut_names.find(name)</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= pos &lt; len(self._components):</span><br><span class="line">                <span class="keyword">return</span> self._components[pos]</span><br><span class="line">        msg = <span class="string">'&#123;.__name__!r&#125; object has no attribute &#123;!r&#125;'</span></span><br><span class="line">        <span class="keyword">raise</span> AttributeError(msg.format(cls, name))</span><br></pre></td></tr></table></figure><p><code>__getattr__</code>方法的实现不难，但是这样实现还不够。看看示例中古怪的交互行为。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v = Vector(range(<span class="number">5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v</span><br><span class="line">Vector([<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v.x</span><br><span class="line"><span class="number">0.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v.x = <span class="number">10</span>  <span class="comment"># 实例v中会新增一个属性x</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v.x  <span class="comment"># 属性x存在于实例中，因此直接返回它，不会调用__getattr__方法</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v  <span class="comment"># 向量的分量不会变</span></span><br><span class="line">Vector([<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>])</span><br></pre></td></tr></table></figure><p>为了避免这种现象，要改写Vector类中设置属性的逻辑。在Vector类中，如果为名称是单个小写字母的属性赋值，抛出AttributeError。为此，要实现<code>__setattr__</code>方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 类中定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line">        cls = type(slef)</span><br><span class="line">        <span class="keyword">if</span> len(name) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> name <span class="keyword">in</span> cls.shortcut_names:</span><br><span class="line">                error = <span class="string">'readonly attribute &#123;attr_name!r&#125;'</span></span><br><span class="line">            <span class="keyword">elif</span> name.islower():  <span class="comment"># 禁止为单个小写字母属性赋值</span></span><br><span class="line">                error = <span class="string">"can't set attributes 'a' to 'z' in &#123;cls_name!r&#125;"</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                error = <span class="string">''</span></span><br><span class="line">            <span class="keyword">if</span> error:</span><br><span class="line">                msg = error.format(cls_name=cls.__name__, attr_name=name)</span><br><span class="line">                <span class="keyword">raise</span> AttributeError(msg)</span><br><span class="line">        super().__setattr__(name, value)  <span class="comment"># 默认情况，在超类上调用__setattr__方法，提供标准行为</span></span><br></pre></td></tr></table></figure><p>不建议只为了避免创建实例属性而使用<code>__slots__</code>属性。<code>__slots__</code>属性只应该用于节省内存，而且仅当内存严重不足时才应该这么做。</p><p>虽然这个示例不支持为Vector分量赋值，但是有一个问题需要特别注意：多数时候，如果实现了<code>__getattr__</code>方法，那么也要定义<code>__setattr__</code>方法，以防对象的行为不一致。</p><h1 id="散列和快速等值测试">散列和快速等值测试</h1><p>我们要再次实现<code>__hash__</code>方法。加上现有的<code>__eq__</code>方法，这会把Vector实例变成可散列的对象。Vector2d中的<code>__hash__</code>方法简单地计算hash(self.x) ^ hash(self.y)。这一次，我们要使用异或运算符依次计算各个分量的散列值，像这样：v[0] ^ v[1] ^ v[2]...。这正是functools.reduce函数的作用。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/functools#functools.reduce" target="_blank" rel="noopener"><code>functools.reduce(function, iterable[, initializer])</code></a></p><p>Apply function of two arguments cumulatively to the items of sequence, from left to right, so as to reduce the sequence to a single value. For example, <code>reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])</code> calculates <code>((((1+2)+3)+4)+5)</code>.</p></blockquote><p>functools.reduce()的原理。它的关键思想是，把一系列值归约成单个值。reduce()函数的第一个参数是接受两个参数的函数，第二个参数是一个可迭代的对象。假如有个接受两个参数的fn函数和一个lst列表。调用reduce(fn, lst)时，fn会应用到第一对元素上，即fn(lst[0], lst[1])，生成第一个结果r1。然后，fn会应用到r1和下一个元素上，即fn(r1, lst[2])，生成第二个结果r2...直到最后一个元素，返回最后得到的结果rN。</p><p>使用reduce函数时最好提供第三个参数，这样能避免这个异常：TypeError: reduce() of empty sequence with no initial value。如果序列为空，initializer是返回的结果；否则，在归约中使用它作为第一个参数，因此应该使用恒等值。比如，对<code>+</code>、<code>|</code>和<code>^</code>来说，initializer应该是0；而对<code>*</code>和<code>&amp;</code>来说，应该是1。</p><p>回到散列问题上，计算聚合异或有3种方式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算整数0～5的累计异或</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">6</span>):  <span class="comment"># 使用循环</span></span><br><span class="line"><span class="meta">... </span>    n ^= i</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> functools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>functools.reduce(<span class="keyword">lambda</span> a, b: a^b, range(<span class="number">6</span>))  <span class="comment"># 使用匿名函数和reduce函数</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> operator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>functools.reduce(operator.xor, range(<span class="number">6</span>))  <span class="comment"># 使用运算符函数和reduce函数</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>编写<code>Vector.__hash__</code>方法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类中定义</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span>  <span class="comment"># 为了提高比较效率</span></span><br><span class="line">        <span class="comment"># tuple(self) == tuple(other) 要完整复制两个操作数</span></span><br><span class="line">        <span class="comment"># 构建两个元组，效率十分低下</span></span><br><span class="line">        <span class="keyword">if</span> len(self) != len(other):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 长度比较非常有必要，因为一旦有一个输入耗尽</span></span><br><span class="line">        <span class="comment"># zip函数会立即停止生成值，而不发出警告</span></span><br><span class="line">        <span class="comment"># 若无长度比较，可能会发生 Vector([1]) == Vector([1, 2]) is True</span></span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(self, other):</span><br><span class="line">            <span class="keyword">if</span> a != b:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">        hashes = (hash(x) <span class="keyword">for</span> x <span class="keyword">in</span> self._components)  <span class="comment"># 创建一个生成器表达式，惰性计算各个分量的散列值</span></span><br><span class="line">        <span class="keyword">return</span> functools.reduce(operator.xor, hashes, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/fluent-python/map-reduce.png"></p><p>示例中实现的<code>__hash__</code>方法是一种映射归约计算。把函数应用到各个元素上，生成一个新序列（映射，map），然后计算聚合值（规约，reduce）。映射过程计算各个分量的散列值，归约过程则使用xor运算符聚合所有散列值。把生成器表达式替换成map方法，映射过程更明显：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">    hashes = map(hash, self._components)  <span class="comment"># 与Python3生成器表达式原理一样</span></span><br><span class="line">    <span class="keyword">return</span> functools.reduce(operator.xor, hashes)</span><br></pre></td></tr></table></figure><p>示例中的<code>__eq__</code>方法的效率很好（不过Vector([1, 2] == (1, 2)的问题仍然存在），不过用于计算聚合值的整个for循环可以替换成一行all函数调用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> len(self) == len(other) <span class="keyword">and</span> all(a == b <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(self, other))</span><br></pre></td></tr></table></figure><p><em>zip函数的名字取自拉链系结物（zipper fastener），因为这个物品用于把两个拉链边的链牙咬合在一起，这形象地说明了zip(left, right)的作用。zip函数与文件压缩没有关系。</em></p><p>zip函数在当一个可迭代对象耗尽后，它不发出警告就停止。itertools.zip_longest函数的行为有所不同：使用可选的fillvalue填充缺失的值，因此可以继续产出，直到最长的可迭代对象耗尽。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/itertools#itertools.zip_longest" target="_blank" rel="noopener"><code>itertools.zip_longest(*iterables, fillvalue=None)</code></a></p><p>Make an iterator that aggregates elements from each of the iterables. If the iterables are of uneven length, missing values are filled-in with fillvalue. Iteration continues until the longest iterable is exhausted.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>zip(range(<span class="number">3</span>), <span class="string">'ABCDE'</span>)</span><br><span class="line">&lt;zip object at <span class="number">0x10cc9c088</span>&gt;  <span class="comment"># zip返回一个生成器</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(range(<span class="number">3</span>), <span class="string">'ABCDE'</span>))</span><br><span class="line">[(<span class="number">0</span>, <span class="string">'A'</span>), (<span class="number">1</span>, <span class="string">'B'</span>), (<span class="number">2</span>, <span class="string">'C'</span>)]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(range(<span class="number">2</span>), <span class="string">'ABC'</span>, <span class="string">'DEFG'</span>))</span><br><span class="line">[(<span class="number">0</span>, <span class="string">'A'</span>, <span class="string">'D'</span>), (<span class="number">1</span>, <span class="string">'B'</span>, <span class="string">'E'</span>)]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> itertools <span class="keyword">import</span> zip_longest</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip_longest(range(<span class="number">2</span>), <span class="string">'ABC'</span>, <span class="string">'DEFG'</span>, fillvalue=<span class="number">-1</span>))</span><br><span class="line">[(<span class="number">0</span>, <span class="string">'A'</span>, <span class="string">'D'</span>), (<span class="number">1</span>, <span class="string">'B'</span>, <span class="string">'E'</span>), (<span class="number">-1</span>, <span class="string">'C'</span>, <span class="string">'F'</span>), (<span class="number">-1</span>, <span class="number">-1</span>, <span class="string">'G'</span>)]</span><br></pre></td></tr></table></figure><h1 id="格式化">格式化</h1><p>Vector类的<code>__format__</code>方法与Vector2d类的相似，但是不使用极坐标，而使用球面坐标（也叫超球面坐标，hyperspherical coordinate），因为Vector类支持n个维度，而超过四维后，球体变成了“超球体”。因此，我们会把自定义格式后缀‘p’变成‘h’。</p><p>在小幅度改动<code>__format__</code>方法之前，我们要定义两个辅助方法：一个是angle(n)，用于计算某个角坐标；另一个是angles()，返回由所有角坐标构成的可迭代对象。我们不会讲解其中涉及的数学原理，如果你好奇的话，可以查看维基百科中的“<a href="https://en.wikipedia.org/wiki/N-sphere" target="_blank" rel="noopener">n为球体</a>”词条，那里有几个公式，我就是使用它们把Vector实例分量数组内的笛卡尔坐标转换成球面坐标的。</p><p>最终版的doctest和全部代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">A multidimensional ``Vector`` class, take 5</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">A ``Vector`` is built from an iterable of numbers::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; Vector([3.1, 4.2])</span></span><br><span class="line"><span class="string">    Vector([3.1, 4.2])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; Vector((3, 4, 5))</span></span><br><span class="line"><span class="string">    Vector([3.0, 4.0, 5.0])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; Vector(range(10))</span></span><br><span class="line"><span class="string">    Vector([0.0, 1.0, 2.0, 3.0, 4.0, ...])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests with two dimensions (same results as ``vector2d_v1.py``)::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 = Vector([3, 4])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; x, y = v1</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; x, y</span></span><br><span class="line"><span class="string">    (3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1</span></span><br><span class="line"><span class="string">    Vector([3.0, 4.0])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone = eval(repr(v1))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 == v1_clone</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print(v1)</span></span><br><span class="line"><span class="string">    (3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; octets = bytes(v1)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; octets</span></span><br><span class="line"><span class="string">    b'd\\x00\\x00\\x00\\x00\\x00\\x00\\x08@\\x00\\x00\\x00\\x00\\x00\\x00\\x10@'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(v1)</span></span><br><span class="line"><span class="string">    5.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; bool(v1), bool(Vector([0, 0]))</span></span><br><span class="line"><span class="string">    (True, False)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Test of ``.frombytes()`` class method:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone = Vector.frombytes(bytes(v1))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone</span></span><br><span class="line"><span class="string">    Vector([3.0, 4.0])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 == v1_clone</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests with three dimensions::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 = Vector([3, 4, 5])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; x, y, z = v1</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; x, y, z</span></span><br><span class="line"><span class="string">    (3.0, 4.0, 5.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1</span></span><br><span class="line"><span class="string">    Vector([3.0, 4.0, 5.0])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone = eval(repr(v1))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 == v1_clone</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print(v1)</span></span><br><span class="line"><span class="string">    (3.0, 4.0, 5.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(v1) # doctest:+ELLIPSIS</span></span><br><span class="line"><span class="string">    7.071067811...</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; bool(v1), bool(Vector([0, 0, 0]))</span></span><br><span class="line"><span class="string">    (True, False)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests with many dimensions::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v7 = Vector(range(7))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v7</span></span><br><span class="line"><span class="string">    Vector([0.0, 1.0, 2.0, 3.0, 4.0, ...])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(v7) # doctest:+ELLIPSIS</span></span><br><span class="line"><span class="string">    9.53939201...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Test of ``.__bytes__`` and ``.frombytes()`` methods::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 = Vector([3, 4, 5])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone = Vector.frombytes(bytes(v1))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone</span></span><br><span class="line"><span class="string">    Vector([3.0, 4.0, 5.0])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 == v1_clone</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of sequence behavior::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 = Vector([3, 4, 5])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; len(v1)</span></span><br><span class="line"><span class="string">    3</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1[0], v1[len(v1)-1], v1[-1]</span></span><br><span class="line"><span class="string">    (3.0, 5.0, 5.0)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Test of slicing::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v7 = Vector(range(7))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v7[-1]</span></span><br><span class="line"><span class="string">    6.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v7[1:4]</span></span><br><span class="line"><span class="string">    Vector([1.0, 2.0, 3.0])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v7[-1:]</span></span><br><span class="line"><span class="string">    Vector([6.0])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v7[1,2]</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">      ...</span></span><br><span class="line"><span class="string">    TypeError: Vector indices must be integers</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of dynamic attribute access::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v7 = Vector(range(10))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v7.x</span></span><br><span class="line"><span class="string">    0.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v7.y, v7.z, v7.t</span></span><br><span class="line"><span class="string">    (1.0, 2.0, 3.0)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Dynamic attribute lookup failures::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v7.k</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">      ...</span></span><br><span class="line"><span class="string">    AttributeError: 'Vector' object has no attribute 'k'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v3 = Vector(range(3))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v3.t</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">      ...</span></span><br><span class="line"><span class="string">    AttributeError: 'Vector' object has no attribute 't'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v3.spam</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">      ...</span></span><br><span class="line"><span class="string">    AttributeError: 'Vector' object has no attribute 'spam'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of hashing::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 = Vector([3, 4])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v2 = Vector([3.1, 4.2])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v3 = Vector([3, 4, 5])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v6 = Vector(range(6))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; hash(v1), hash(v3), hash(v6)</span></span><br><span class="line"><span class="string">    (7, 2, 1)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Most hash values of non-integers vary from a 32-bit to 64-bit CPython build::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; import sys</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; hash(v2) == (384307168202284039 if sys.maxsize &gt; 2**32 else 357915986)</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of ``format()`` with Cartesian coordinates in 2D::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 = Vector([3, 4])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(v1)</span></span><br><span class="line"><span class="string">    '(3.0, 4.0)'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(v1, '.2f')</span></span><br><span class="line"><span class="string">    '(3.00, 4.00)'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(v1, '.3e')</span></span><br><span class="line"><span class="string">    '(3.000e+00, 4.000e+00)'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of ``format()`` with Cartesian coordinates in 3D and 7D::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v3 = Vector([3, 4, 5])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(v3)</span></span><br><span class="line"><span class="string">    '(3.0, 4.0, 5.0)'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector(range(7)))</span></span><br><span class="line"><span class="string">    '(0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0)'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of ``format()`` with spherical coordinates in 2D, 3D and 4D::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector([1, 1]), 'h') # doctest:+ELLIPSIS</span></span><br><span class="line"><span class="string">    '&lt;1.414213..., 0.785398...&gt;'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector([1, 1]), '.3eh')</span></span><br><span class="line"><span class="string">    '&lt;1.414e+00, 7.854e-01&gt;'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector([1, 1]), '0.5fh')</span></span><br><span class="line"><span class="string">    '&lt;1.41421, 0.78540&gt;'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector([1, 1, 1]), 'h') # doctest:+ELLIPSIS</span></span><br><span class="line"><span class="string">    '&lt;1.73205..., 0.95531..., 0.78539...&gt;'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector([2, 2, 2]), '.3eh')</span></span><br><span class="line"><span class="string">    '&lt;3.464e+00, 9.553e-01, 7.854e-01&gt;'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector([0, 0, 0]), '0.5fh')</span></span><br><span class="line"><span class="string">    '&lt;0.00000, 0.00000, 0.00000&gt;'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector([-1, -1, -1, -1]), 'h') # doctest:+ELLIPSIS</span></span><br><span class="line"><span class="string">    '&lt;2.0, 2.09439..., 2.18627..., 3.92699...&gt;'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector([2, 2, 2, 2]), '.3eh')</span></span><br><span class="line"><span class="string">    '&lt;4.000e+00, 1.047e+00, 9.553e-01, 7.854e-01&gt;'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector([0, 1, 0, 0]), '0.5fh')</span></span><br><span class="line"><span class="string">    '&lt;1.00000, 1.57080, 0.00000, 0.00000&gt;'</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> numbers</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    typecode = <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, components)</span>:</span></span><br><span class="line">        self._components = array(self.typecode, components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        components = reprlib.repr(self._components)</span><br><span class="line">        components = components[components.find(<span class="string">'['</span>):<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Vector(&#123;&#125;)'</span>.format(components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(tuple(self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bytes__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (bytes([ord(self.typecode)]) +</span><br><span class="line">                bytes(self._components))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (len(self) == len(other) <span class="keyword">and</span></span><br><span class="line">                all(a == b <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(self, other)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">        hashes = (hash(x) <span class="keyword">for</span> x <span class="keyword">in</span> self)</span><br><span class="line">        <span class="keyword">return</span> functools.reduce(operator.xor, hashes, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> math.sqrt(sum(x * x <span class="keyword">for</span> x <span class="keyword">in</span> self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(abs(self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        cls = type(self)</span><br><span class="line">        <span class="keyword">if</span> isinstance(index, slice):</span><br><span class="line">            <span class="keyword">return</span> cls(self._components[index])</span><br><span class="line">        <span class="keyword">elif</span> isinstance(index, numbers.Integral):</span><br><span class="line">            <span class="keyword">return</span> self._components[index]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msg = <span class="string">'&#123;.__name__&#125; indices must be integers'</span></span><br><span class="line">            <span class="keyword">raise</span> TypeError(msg.format(cls))</span><br><span class="line"></span><br><span class="line">    shortcut_names = <span class="string">'xyzt'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        cls = type(self)</span><br><span class="line">        <span class="keyword">if</span> len(name) == <span class="number">1</span>:</span><br><span class="line">            pos = cls.shortcut_names.find(name)</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= pos &lt; len(self._components):</span><br><span class="line">                <span class="keyword">return</span> self._components[pos]</span><br><span class="line">        msg = <span class="string">'&#123;.__name__!r&#125; object has no attribute &#123;!r&#125;'</span></span><br><span class="line">        <span class="keyword">raise</span> AttributeError(msg.format(cls, name))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">angle</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        r = math.sqrt(sum(x * x <span class="keyword">for</span> x <span class="keyword">in</span> self[n:]))</span><br><span class="line">        a = math.atan2(r, self[n<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">if</span> (n == len(self) - <span class="number">1</span>) <span class="keyword">and</span> (self[<span class="number">-1</span>] &lt; <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> math.pi * <span class="number">2</span> - a</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">angles</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (self.angle(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span>, len(self)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__format__</span><span class="params">(self, fmt_spec=<span class="string">''</span>)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> fmt_spec.endswith(<span class="string">'h'</span>): <span class="comment"># hyperspherical coordinates</span></span><br><span class="line">            fmt_spec = fmt_spec[:<span class="number">-1</span>]</span><br><span class="line">            coords = itertools.chain([abs(self)], self.angles())</span><br><span class="line">            outer_fmt = <span class="string">'&lt;&#123;&#125;&gt;'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            coords = self</span><br><span class="line">            outer_fmt = <span class="string">'(&#123;&#125;)'</span></span><br><span class="line">        components = (format(c, fmt_spec) <span class="keyword">for</span> c <span class="keyword">in</span> coords)</span><br><span class="line">        <span class="keyword">return</span> outer_fmt.format(<span class="string">', '</span>.join(components))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">frombytes</span><span class="params">(cls, octets)</span>:</span></span><br><span class="line">        typecode = chr(octets[<span class="number">0</span>])</span><br><span class="line">        memv = memoryview(octets[<span class="number">1</span>:]).cast(typecode)</span><br><span class="line">        <span class="keyword">return</span> cls(memv)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>符合Python风格的对象</title>
      <link href="/notes/fluent-python/a-pythonic-object/"/>
      <url>/notes/fluent-python/a-pythonic-object/</url>
      
        <content type="html"><![CDATA[<p>得益于Python数据模型，自定义类型的行为可以像内置类型那样自然。实现如此自然的行为，靠的不是继承，而是鸭子类型（duck typing）：我们只需按照预定行为实现对象所需的方法即可。</p><h1 id="对象表示形式">对象表示形式</h1><p>每门面向对象的语言至少都有一种获取对象的字符串表示形式的标准方式。Python提供了两种方式。</p><p>repr()：以便于开发者理解的方式返回对象的字符串表示形式，由特殊方法<code>__repr__</code>支持。</p><p>str()：以便于用户理解的方式返回对象的字符串表示形式，由特殊方法<code>__str__</code>支持。</p><p>为了给对象提供其他的表示形式，还会用到另外两个特殊方法：<code>__bytes__</code>和<code>__format__</code>。<code>__bytes__</code>方法与<code>__str__</code>方法类似，bytes()函数调用它获取对象的字节序列表示形式。而<code>__format__</code>方法会被内置的format()函数和str.format()方法调用，使用特殊的格式代码显示对象的字符串表示形式。</p><a id="more"></a><h1 id="再谈向量类">再谈向量类</h1><p>为了说明用于生成对象表示形式的众多方法，我们将使用一个Vector2d类。</p><figure class="highlight python"><figcaption><span>vector2d.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span>:</span></span><br><span class="line">    typecode = <span class="string">'d'</span>  <span class="comment"># 类属性，在实例和字节序列之间转换时使用</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = float(x)  <span class="comment"># 把x和y转换成浮点数，尽早捕获错误</span></span><br><span class="line">        self.y = float(y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span>  <span class="comment"># 把Vector2d变成可迭代对象，这样才能拆包</span></span><br><span class="line">        <span class="keyword">return</span> (i <span class="keyword">for</span> i <span class="keyword">in</span> (self.x, self.y))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span>  <span class="comment"># __repr__方法使用&#123;!r&#125;获取各个分量的表示形式，然后插值，构成一个字符串</span></span><br><span class="line">        class_name = type(self).__name__</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&#123;&#125;(&#123;!r&#125;, &#123;!r&#125;)'</span>.format(class_name, *self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>  <span class="comment"># 从可迭代的实例中可以轻松地得到一个元组</span></span><br><span class="line">        <span class="keyword">return</span> str(tuple(self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bytes__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (bytes([ord(self.typecode)]) +  <span class="comment"># 为了生成字节序列，把typecode转换成字节序列，然后</span></span><br><span class="line">                bytes(array(self.typecode, self)))  <span class="comment"># 迭代实例，得到一个数组，再把数组转换成字节序列</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span>  <span class="comment"># 可用，但有点问题，比如Vector2d(3, 4) == [3, 4]的结果会是True。</span></span><br><span class="line">        <span class="keyword">return</span> tuple(self) == tuple(other)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> math.hypot(self.x, self.y)  <span class="comment"># 模是x和y分量构成的直角三角形的斜边长</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(abs(self))  <span class="comment"># abs(0.0)是False，非零值是True</span></span><br></pre></td></tr></table></figure><p>Vector2d实例具有以下基本行为：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector2d(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(v1.x, v1.y)  <span class="comment"># 实例的分量可以直接通过属性访问</span></span><br><span class="line"><span class="number">3.0</span> <span class="number">4.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = v1  <span class="comment"># 实例可以拆包成变量元组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y</span><br><span class="line">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1  <span class="comment"># repr函数调用实例，得到的结果类似于构建实例的源码</span></span><br><span class="line">Vector2d(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1_clone = eval(repr(v1))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 == v1_clone</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(v1)  <span class="comment"># print函数会调用str函数</span></span><br><span class="line">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>octets = bytes(v1)  <span class="comment"># bytes函数会调用__bytes__方法，生成实例的二进制表示形式</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>octets</span><br><span class="line"><span class="string">b'd\\x00\\x00\\x00\\x00\\x00\\x00\\x08@\\x00\\x00\\x00\\x00\\x00\\x00\\x10@'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>abs(v1)  <span class="comment"># abs函数会调用__abs__方法，返回实例的模</span></span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(v1), bool(Vector2d(<span class="number">0</span>, <span class="number">0</span>))  <span class="comment"># bool函数会调用__bool__方法，如果实例的模为0，返回False，否则返回True</span></span><br><span class="line"><span class="literal">True</span>, <span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="备选构造方法">备选构造方法</h1><p>我么可以把Vector2d实例转换成字节序列；同理，也应该能从字节序列转换成Vector2d实例。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在类中定义</span></span><br><span class="line"><span class="meta">@classmethod  # 类方法：从字节序列转换成Vector2d实例</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">frombytes</span><span class="params">(cls, octets)</span>:</span>  <span class="comment"># 不用传入self参数，相反，要通过cls传入类本身</span></span><br><span class="line">    typecode = chr(octets[<span class="number">0</span>])  <span class="comment"># 从第一个字节中读取typecode</span></span><br><span class="line">    memv = memoryview(octets[<span class="number">1</span>:]).cast(typecode)  <span class="comment"># 使用传入的octets字节序列创建一个memoryview，然后使用typecode转换</span></span><br><span class="line">    <span class="keyword">return</span> cls(*memv)  <span class="comment"># 拆包转换后的memoryview，得到构造方法所需的一对参数</span></span><br></pre></td></tr></table></figure><h2 id="classmethod与staticmethod">classmethod与staticmethod</h2><p>classmethod装饰器定义操作类，而不是操作实例的方法。classmethod改变了调用方法的方式，因此类方法的第一个参数是类本身，而不是实例。classmethod最常见的用途是定义备选构造方法。按照约定，类方法的第一个参数名为cls（但是Python不介意具体怎么命名）。</p><p>staticmethod装饰器也会改变方法的调用方式，但是第一个参数不是特殊的值。其实，静态方法就是普通的函数，只是碰巧在类的定义体中，而不是在模块层定义。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>:</span></span><br><span class="line"><span class="meta">... </span>    @classmethod</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">klassmeth</span><span class="params">(*args)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> args  <span class="comment"># 返回全部参数</span></span><br><span class="line"><span class="meta">... </span>    @staticmethod</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">statmeth</span><span class="params">(*args)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> args  <span class="comment"># 返回全部参数</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Demo.klassmeth()  <span class="comment"># 不管怎样调用类方法，第一个参数始终是Demo类</span></span><br><span class="line">(&lt;class '__main__.Demo'&gt;,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Demo.klassmeth(<span class="string">'spam'</span>)</span><br><span class="line">(&lt;class '__main__.Demo'&gt;, 'spam')</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Demo.statmeth()  <span class="comment"># 静态方法的行为与普通的函数类似</span></span><br><span class="line">()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Demo.statmeth(<span class="string">'spam'</span>)</span><br><span class="line">(<span class="string">'spam'</span>,)</span><br></pre></td></tr></table></figure><h1 id="格式化显示">格式化显示</h1><p>内置的format()函数和str.format()方法把各个类型的格式化方法委托给相应的<code>.__format__(format_spec)</code>方法。format_spec是格式说明符，它是：</p><ul><li>format(my_obj, format_spec)的第二个参数，或者</li><li>str.format()方法的格式字符串，{}里代换字段中冒号后面的部分。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>brl = <span class="number">1</span>/<span class="number">2.43</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>brl</span><br><span class="line"><span class="number">0.4115226337448559</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(brl, <span class="string">'0.4f'</span>)  <span class="comment"># 格式说明符是 '0.4f'</span></span><br><span class="line"><span class="string">'0.4115'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'1 BRL = &#123;rate:0.2f&#125; USD'</span>.format(rate=brl)  <span class="comment"># 格式说明符是 '0.2f'</span></span><br><span class="line"><span class="string">'1 BRL = 0.41 USD'</span></span><br></pre></td></tr></table></figure><p>'{rate:0.2f}'这样的格式字符串包含两部分，冒号左边的'rate'在代换字段句法中是字段名，冒号后面的'0.2f'是格式说明符。格式说明符使用的表示法叫格式规范微语言（“<a href="https://devdocs.io/python~3.6/library/string#formatspec" target="_blank" rel="noopener">Format Specification Mini-LMini-Language</a>“）。</p><p>格式规范微语言是可扩展的，因为各个类可以自行决定如果解释format_spec参数。例如，datetime模块中的类，它们的<code>__format__</code>方法使用的格式代码与strftime()函数一样。下面是内置的format()函数和str.format()方法的几个示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(now, <span class="string">'%H:%M:%S'</span>)</span><br><span class="line"><span class="string">'11:46:10'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"It's now &#123;:%I:%M %p&#125;"</span>.format(now)</span><br><span class="line"><span class="string">"It's now 11:46 AM"</span></span><br></pre></td></tr></table></figure><p>如果类没有定义<code>__format__</code>方法，从object继承的方法会返回str(my_object)。然而没如果传入格式说明符，<code>object.__format__</code>方法会抛出TypeError。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector2d(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(v1)  <span class="comment"># 若没有定义__format__方法，则返回str(v1)</span></span><br><span class="line"><span class="string">'(3.0, 4.0)'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(v1, <span class="string">'.3f'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">TypeError: unsupported format string passed to Vector2d.__format__</span><br></pre></td></tr></table></figure><p>我们将自己实现微语言来解决这个问题。首先，假设用户提供的格式说明符是用于格式化向量中各个浮点数分量的，想达到的效果是：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector2d(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(v1)</span><br><span class="line"><span class="string">'(3.0, 4.0)'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(v1, <span class="string">'.2f'</span>)</span><br><span class="line"><span class="string">'(3.00, 4.00)'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(v1, <span class="string">'.3e'</span>)</span><br><span class="line"><span class="string">'(3.000e+00, 4.000e+00)'</span></span><br></pre></td></tr></table></figure><p>实现这种输出的<code>__format__</code>方法如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在类中定义</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__format__</span><span class="params">(self, fmt_spec=<span class="string">''</span>)</span>:</span></span><br><span class="line">    components = (format(c, fmt_spec) <span class="keyword">for</span> c <span class="keyword">in</span> self)  <span class="comment"># 使用内置的format函数把fmt_spec应用到向量的各个分量上</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'(&#123;&#125;, &#123;&#125;)'</span>.format(*components)</span><br></pre></td></tr></table></figure><p>下面要在微语言中添加一个自定义的格式代码：如果格式说明符以'p'结尾，那么在极坐标中显示向量，即&lt;r, <span class="math inline">\(\theta\)</span>&gt;，其中r是模，<span class="math inline">\(\theta\)</span>是弧度；其他部分（'p'之前的部分）像往常那样解释。</p><p>对极坐标来说，我们已经定义了计算模的<code>__abs__</code>方法，因此还要定义一个简单的angle方法，使用math.atan2()函数计算角度。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在类中定义</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">angle</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> math.atan2(self.y, self.x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__format__</span><span class="params">(self, fmt_spec)</span>:</span>  <span class="comment"># 增强型__format__方法</span></span><br><span class="line">    <span class="keyword">if</span> fmt_spec.endswith(<span class="string">'p'</span>):</span><br><span class="line">        fmt_spec = fmt_spec[:<span class="number">-1</span>]</span><br><span class="line">        coords = (abs(self), self.angle())  <span class="comment"># 极坐标</span></span><br><span class="line">        outer_fmt = <span class="string">'&lt;&#123;&#125;, &#123;&#125;&gt;'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        coords = self</span><br><span class="line">        outer_fmt = <span class="string">'(&#123;&#125;, &#123;&#125;)'</span></span><br><span class="line">    components = (format(c, fmt_spec) <span class="keyword">for</span> c <span class="keyword">in</span> coords)</span><br><span class="line">    <span class="keyword">return</span> outer_fmt.format(*components)</span><br></pre></td></tr></table></figure><p>示例中的代码得到的结果如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(Vector2d(<span class="number">1</span>, <span class="number">1</span>), <span class="string">'p'</span>)</span><br><span class="line"><span class="string">'&lt;1.4142135623730951, 0.7853981633974483&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(Vector2d(<span class="number">1</span>, <span class="number">1</span>), <span class="string">'.3ep'</span>)</span><br><span class="line"><span class="string">'&lt;1.414e+00, 7.854e-01&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(Vector2d(<span class="number">1</span>, <span class="number">1</span>), <span class="string">'0.5fp'</span>)</span><br><span class="line"><span class="string">'&lt;1.41421, 0.78540&gt;'</span></span><br></pre></td></tr></table></figure><h1 id="可散列的vector2d">可散列的Vector2d</h1><p>目前Vector2d实例是不可散列的，因此不能放入集合（set）中。为了把Vector2d实例变成可散列的，必须使用<code>__hash__</code>方法（还需要<code>__eq__</code>方法）。此外，还要让向量不可变，为此，我们要把x和y分量设为只读属性。（要想创建可散列的类型，不一定要实现特性，也不一定要保护实例属性。只需正确地实现<code>__hash__</code>和<code>__eq__</code>方法即可。但是实例的散列值绝不应该变化，因此借机提到了只读属性）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 类中定义</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">    self.__x = x  <span class="comment"># 使用两个前导下划线，把属性标记为私有的</span></span><br><span class="line">    self.__y = y</span><br><span class="line"></span><br><span class="line"><span class="meta">@property  # @property装饰器把读值方法标记为特性</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.__x</span><br><span class="line"></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">y</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.__y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他方法保持不变，通过self.x和self.y读取公开特性，而不必读取私有属性</span></span><br></pre></td></tr></table></figure><p>让这些向量不可变是有原因的，因为这样才能实现<code>__hash__</code>方法。这个方法应该返回一个整数，理想情况下还要考虑对象属性的散列值（<code>__eq__</code>方法也要使用），因为相等的对象应该具有相同的散列值。根据<a href="https://docs.python.org/3/reference/datamodel.html" target="_blank" rel="noopener">特殊方法<code>__hash__</code>的文档</a>，最好使用位运算符异或（^）混合各分量的散列值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在类中定义</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> hash(self.x) ^ hash(self.y)</span><br></pre></td></tr></table></figure><p>完整代码清单，包含全部doctest。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">A two-dimensional vector class</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 = Vector2d(3, 4)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print(v1.x, v1.y)</span></span><br><span class="line"><span class="string">    3.0 4.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; x, y = v1</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; x, y</span></span><br><span class="line"><span class="string">    (3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1</span></span><br><span class="line"><span class="string">    Vector2d(3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone = eval(repr(v1))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 == v1_clone</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print(v1)</span></span><br><span class="line"><span class="string">    (3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; octets = bytes(v1)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; octets b'd\\x00\\x00\\x00\\x00\\x00\\x00\\x08@\\x00\\x00\\x00\\x00\\x00\\x00\\x10@'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(v1)</span></span><br><span class="line"><span class="string">    5.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; bool(v1), bool(Vector2d(0, 0))</span></span><br><span class="line"><span class="string">    (True, False)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Test of ``.frombytes()`` class method:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone = Vector2d.frombytes(bytes(v1))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone</span></span><br><span class="line"><span class="string">    Vector2d(3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 == v1_clone</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of ``format()`` with Cartesian coordinates:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(v1)</span></span><br><span class="line"><span class="string">    '(3.0, 4.0)'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(v1, '.2f')</span></span><br><span class="line"><span class="string">    '(3.00, 4.00)'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(v1, '.3e')</span></span><br><span class="line"><span class="string">    '(3.000e+00, 4.000e+00)'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of the ``angle`` method::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; Vector2d(0, 0).angle()</span></span><br><span class="line"><span class="string">    0.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; Vector2d(1, 0).angle()</span></span><br><span class="line"><span class="string">    0.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; epsilon = 10**-8</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(Vector2d(0, 1).angle() - math.pi/2) &lt; epsilon</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(Vector2d(1, 1).angle() - math.pi/4) &lt; epsilon</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of ``format()`` with polar coordinates:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector2d(1, 1), 'p') # doctest:+ELLIPSIS</span></span><br><span class="line"><span class="string">    '&lt;1.414213..., 0.785398...&gt;'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector2d(1, 1), '.3ep')</span></span><br><span class="line"><span class="string">    '&lt;1.414e+00, 7.854e-01&gt;'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector2d(1, 1), '0.5fp')</span></span><br><span class="line"><span class="string">    '&lt;1.41421, 0.78540&gt;'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of `x` and `y` read-only properties:</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1.x, v1.y</span></span><br><span class="line"><span class="string">    (3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1.x = 123</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">      ...</span></span><br><span class="line"><span class="string">    AttributeError: can't set attribute</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of hashing:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 = Vector2d(3, 4)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v2 = Vector2d(3.1, 4.2)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; hash(v1), hash(v2)</span></span><br><span class="line"><span class="string">    (7, 384307168202284039)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; len(set([v1, v2]))</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span>:</span></span><br><span class="line">    typecode = <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.__x = float(x)</span><br><span class="line">        self.__y = float(y)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__x</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">y</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (i <span class="keyword">for</span> i <span class="keyword">in</span> (self.x, self.y))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        class_name = type(self).__name__</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&#123;&#125;(&#123;!r&#125;, &#123;!r&#125;)'</span>.format(class_name, *self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(tuple(self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bytes__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (bytes([ord(self.typecode)]) +</span><br><span class="line">                bytes(array(self.typecode, self)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> tuple(self) == tuple(other)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> hash(self.x) ^ hash(self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> math.hypot(self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(abs(self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">angle</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> math.atan2(self.y, self.x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__format__</span><span class="params">(self, fmt_spec=<span class="string">''</span>)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> fmt_spec.endswith(<span class="string">'p'</span>):</span><br><span class="line">            fmt_spec = fmt_spec[:<span class="number">-1</span>]</span><br><span class="line">            coords = (abs(self), self.angle())</span><br><span class="line">            outer_fmt = <span class="string">'&lt;&#123;&#125;, &#123;&#125;&gt;'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            coords = self</span><br><span class="line">            outer_fmt = <span class="string">'(&#123;&#125;, &#123;&#125;)'</span></span><br><span class="line">            components = (format(c, fmt_spec) <span class="keyword">for</span> c <span class="keyword">in</span> coords)</span><br><span class="line">        <span class="keyword">return</span> outer_fmt.format(*components)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">frombytes</span><span class="params">(cls, octets)</span>:</span></span><br><span class="line">        typecode = chr(octets[<span class="number">0</span>])</span><br><span class="line">        memv = memoryview(octets[<span class="number">1</span>:]).cast(typecode)</span><br><span class="line">        <span class="keyword">return</span> cls(*memv)</span><br></pre></td></tr></table></figure><h1 id="python的私有属性和受保护的属性">Python的私有属性和“受保护的”属性</h1><p>Python不能像Java那样使用private修饰符创建私有属性，但是Python有个简单的机制，能避免子类意外覆盖“私有”属性。举个例子，有人编写了一个名为Dog的类，这个类的内部用到了mood实例属性，但是没有将其开放。现在，你创建了Dog的子类：Beagle。如果你在毫不知情的情况下又创建了名为mood的实例属性，那么在继承的方法中就会把Dog类的mood属性覆盖掉。这是个难以调试的问题。</p><p>为了避免这种情况，如果以<code>__mood</code>的形式命名实例属性，Python会把属性名存入实例的<code>__dict__</code>属性中，而且会在前面加上一个下划线和类名。因此，对Dog类来说，<code>__mood</code>会变成<code>_Dog__mood</code>；对Beagle类来说，会变成<code>_Beagle__mood</code>。这个语言特性叫名称改写（name mangling）。名称改写是一种安全措施，不能保证万无一失：它的目的是避免意外访问，不能防止故意做错事。</p><p>以上一节定义的Vector2d类为例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector2d(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1.__dict__</span><br><span class="line">&#123;<span class="string">'_Vector2d__x'</span>: <span class="number">3.0</span>, <span class="string">'_Vector2d__y'</span>: <span class="number">4.0</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1._Vector2d__x  <span class="comment"># 故意访问</span></span><br><span class="line"><span class="number">3.0</span></span><br></pre></td></tr></table></figure><p>不是所有Python程序员都喜欢名称改写功能，也不是所有人都喜欢<code>self.__x</code>这种不对称的名称。有些人不喜欢这种句法，他们约定使用一个下环线前缀编写“受保护”的属性（如<code>self._x</code>）。批评使用两个下划线这种改写机制的人认为，应该使用命名约定来避免意外覆盖属性。</p><blockquote><p>绝对不要使用两个前导下划线，这是很烦人的自私行为。如果担心命名冲突，应该明确使用一种名称改写方式（如<code>_MyThing_blahblah</code>）。这其实与使用双下划线一样，不过自己定的规则比双下划线易于理解。</p><p>—— Ian Bicking，<a href="http://pythonpaste.org/StyleGuide.html" target="_blank" rel="noopener">Paste的风格指南</a></p></blockquote><p>Python解释器不会对使用单个下划线的属性名做特殊处理，不过这是很多Python程序员严格遵守的约定，他们不会在类外部访问这种属性（不过在模块中，顶层名称使用一个前导下划线的话，的确会有影响：对from mymod import *来说，mymod中前缀为下划线的名称不会被导入。然而，依旧可以使用from mymod import _privatefunc将其导入）。遵守使用一个下划线标记对象的私有属性很容易，就像遵守使用全大写字母编写常量那样容易。</p><p>Vector2d的分量都是”私有的“，而且Vector2d实例都是”不可变的”。我用了两对引号，这是因为并不能真正实现私有和不可变。</p><h1 id="使用__slots__类属性节省空间">使用<code>__slots__</code>类属性节省空间</h1><p>默认情况下，Python在各个实例中名为<code>__dict__</code>的字典里存储实例属性。为了使用底层的散列表提升访问速度，字典会消耗大量内存。如果要处理数百万个属性不多的实例，通过<code>__slots__</code>类属性，能节省大量内存，方法是让解释器在元组中存储实例属性，而不使用字典。（继承自超类的<code>__slots__</code>属性没有效果。Python只会使用各个类中定义的<code>__slots__</code>属性）</p><p>定义<code>__slots__</code>的方式是，创建一个类属性，使用<code>__slots__</code>这个名字，并把它的值设为一个字符串构成的可迭代对象，其中各个元素表示各个实例属性。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span>:</span></span><br><span class="line">    __solots__ = (<span class="string">'__x'</span>, <span class="string">'__y'</span>)</span><br><span class="line"></span><br><span class="line">    typecode = <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类方法</span></span><br></pre></td></tr></table></figure><p>如果要处理数百万个数值对象，应该使用NumPy数组。NumPy数组能高效使用内存，而且提供了高度优化的数值处理函数，其中很多都一次操作整个数组。</p><p>在类中定义<code>__slots__</code>属性之后，实例不能再有<code>__slots__</code>中所列名称之外的其他属性。这只是一个副作用，不是<code>__slots__</code>存在的真正原因，不要使用<code>__slots__</code>属性禁止类的用户新增实例。<code>__slots__</code>是用于优化的，不是为了约束程序员。</p><p>然而，“节省的内存也可能被再次吃掉”：如果把'<code>__dict__</code>'这个名称添加到<code>__slots__</code>中，实例会在元组中保存各个实例的属性，此外还支持动态创建属性，这些属性存储在常规的<code>__dict__</code>中。当然，把'<code>__dict__</code>'添加到<code>__slots__</code>中可能完全违背了初衷，这取决于各个实例的静态属性和动态属性的数量及其用法。</p><p>此外，还有一个实例属性可能需要注意，即<code>__weakref__</code>属性，为了让对象支持弱引用，必须有这个属性。用户定义的类中默认就有<code>__weakref__</code>属性。可是，如果类中定义了<code>__slots__</code>属性，而且想把实例作为弱引用的目标，那么要把'<code>__weakref__</code>'添加到<code>__slots__</code>中。</p><p>综上，<code>__slots__</code>属性有些需要注意的地方，而且不能滥用，不能使用它限制用户能赋值的属性。处理列表数据时<code>__slots__</code>属性最有用，例如模式固定的数据库记录，以及特大型数据库。然而，如果你经常处理大量数据，一定要了解一下<a href="http://www.numpy.org" target="_blank" rel="noopener">NumPy</a>；此外，数据分析库<a href="http://pandas.pydata.org" target="_blank" rel="noopener">pandas</a>也值得了解，这个库可以处理非数值数据，而且能导入/导出很多不同的列表数据格式。</p><p>总之，如果使用得当，<code>__slots__</code>能显著节省内存，不过要注意以下几点：</p><ul><li>每个子类都要定义<code>__slots__</code>属性，因为解释器会忽略继承的<code>__slots__</code>属性。</li><li>实例只能拥有<code>__slots__</code>中列出的属性，除非把'<code>__dict__</code>'加入<code>__slots__</code>中（这样做就失去了节省内存的功效）。</li><li>如果不把'<code>__weakref__'</code>加入<code>__slots__</code>，实例就不能作为弱引用的目标。</li></ul><h1 id="覆盖类属性">覆盖类属性</h1><p>Python有个很独特的特性：类属性可用于为实例属性提供默认值。Vector2d中有个typecode类属性，<code>__bytes__</code>方法两次用到了它，而且都故意使用self.typecode读取它的值。因此Vector2d实例本身没有typecode属性，所以self.typecode默认获取的是Vector2d.typecode类属性的值。</p><p>但是，如果为不存在的实例属性赋值，会新建实例属性。假如我们为typecode实例属性赋值，那么同名类属性不受影响。然而，自此之后，实例读取的self.typecode是实例属性typecode，也就是把同名类属性遮盖了。借助这一特性，可以为各个实例的typecode属性定制不同的值。</p><p>Vector2d.typecode属性的默认值是'd'，即转换成字节序列时使用8字节双精度浮点数表示向量的各个分量。如果转换之前把Vector2d实例的typecode属性设为'f'，那么使用4字节的单精度浮点数表示各个分量。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector2d(<span class="number">1.1</span>, <span class="number">2.2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dumpd = bytes(v1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dumpd</span><br><span class="line"><span class="string">b'd\x9a\x99\x99\x99\x99\x99\xf1?\x9a\x99\x99\x99\x99\x99\x01@'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(dumpd)</span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1.typecode = <span class="string">'f'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dumpf = bytes(v1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dumpf</span><br><span class="line"><span class="string">b'f\xcd\xcc\x8c?\xcd\xcc\x0c@'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(dumpf)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Vector2d.typecode, v1.typecode</span><br><span class="line">(<span class="string">'d'</span>, <span class="string">'f'</span>)</span><br></pre></td></tr></table></figure><p>如果想修改类属性的值，必须直接在类上修改，不能通过实例修改。如果想修改所有实例（没有typecode实例变量）的typecode属性的默认值，可以这么做：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Vector2d.typecode = <span class="string">'f'</span></span><br></pre></td></tr></table></figure><p>然而，有种修改方法更符合Python风格，而且效果持久，也更有针对性。类属性是公开的，因此会被子类继承，于是经常会创建一个子类，只用于定制类的数据属性。Diango基于类的视图就大量使用了这个技术。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShortVector2d</span><span class="params">(Vector2d)</span>:</span></span><br><span class="line">    typecode = <span class="string">'f'</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象引用、可变性和垃圾回收</title>
      <link href="/notes/fluent-python/object-references-mutability-and-recycling/"/>
      <url>/notes/fluent-python/object-references-mutability-and-recycling/</url>
      
        <content type="html"><![CDATA[<h1 id="变量不是盒子">变量不是盒子</h1><p>以一个比喻说明Python的变量：变量是标注，而不是盒子。首先，我们要抛弃变量是存储数据的盒子这一错误观念。Python变量类似于Java中的引用式变量，因此最好把他们理解为附加在对象上的标注。在示例所示的交互式控制台中，无法使用“变量是盒子”做解释。而便利贴则指出了变量的正确工作方式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/fluent-python/variables-as-sticky-notes.png"></p><p>赋值方式：对引用式变量来说，说把变量分配给对象更合理，反过来说就有问题。毕竟，对象在赋值之前就创建了。下面的示例证明赋值语句的右边先执行。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Gizmo</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">'Gizmo id: %d'</span> %id(self))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = Gizmo()</span><br><span class="line">Gizmo id: <span class="number">4533161544</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = Gizmo() * <span class="number">10</span>  <span class="comment"># 在乘法运算中使用Gizmo实例会抛出异常</span></span><br><span class="line">Gizmo id: <span class="number">4533161376</span>  <span class="comment"># 在尝试求积之前会创建一个新的Gizmo实例</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unsupported operand type(s) <span class="keyword">for</span> *: <span class="string">'Gizmo'</span> <span class="keyword">and</span> <span class="string">'int'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir()  <span class="comment"># dir()的结果表明变量y没有被创建</span></span><br><span class="line">[<span class="string">'Gizmo'</span>, <span class="string">'__annotations__'</span>, <span class="string">'__builtins__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__loader__'</span>, <span class="string">'__name__'</span>, <span class="string">'__package__'</span>, <span class="string">'__spec__'</span>, <span class="string">'x'</span>]</span><br></pre></td></tr></table></figure><p>为了理解Python中的赋值居于，应该始终先读右边。对象在右边创建或获取，在此之后左边的变量才会绑定到对象上，这就像为对象贴上标注。因为变量只不过是标注，所以无法租出为对象贴上多个标注。贴的多个标注，就是别名。</p><h1 id="标识相等性和别名">标识、相等性和别名</h1><p>Lewis Carroll是Charles Lutwidge Dodgson教授的笔名。Carroll先生指的就是Dodgson教授，二者是同一个人。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>charles = &#123;<span class="string">'name'</span>: <span class="string">'Charles L. Dodgson'</span>, <span class="string">'born'</span>: <span class="number">1832</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lweis = charles</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lweis <span class="keyword">is</span> charles</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(charles), id(lweis)</span><br><span class="line">(<span class="number">4531455896</span>, <span class="number">4531455896</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lweis[<span class="string">'balance'</span>] = <span class="number">950</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>charles</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'Charles L. Dodgson'</span>, <span class="string">'born'</span>: <span class="number">1832</span>, <span class="string">'balance'</span>: <span class="number">950</span>&#125;</span><br></pre></td></tr></table></figure><p>然而，假如有冒充者（Alexander Pedachenko博士）生于1832年，声称他是Charles L. Dodgson。这个冒充者的证件可能一样，但是Pedachenko博士不是Dodgson教授。</p><p><img src="/uploads/image/fluent-python/python-is-and-equal.png"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>alex = &#123;<span class="string">'name'</span>: <span class="string">'Charles L. Dodgson'</span>, <span class="string">'born'</span>: <span class="number">1832</span>, <span class="string">'balance'</span>: <span class="number">950</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>alex == charles</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>alex <span class="keyword">is</span> <span class="keyword">not</span> charles</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(alex), id(charles)</span><br><span class="line">(<span class="number">4533183904</span>, <span class="number">4531455896</span>)</span><br></pre></td></tr></table></figure><p>每个变量都有标识、类型和值。对象一旦创建，它的标识绝不会变。is运算符比较两个对象的标识：id()函数返回对象表示的整数标识。</p><p>对象ID的真正意义在不同的实现中有所不同。在CPython中，id()返回对象的内存地址，但是在其他Python解释器中可能是别的值。关键是，ID一定是唯一的数值标注，而且在对象的生命周期中绝不会变。</p><h2 id="在和is之间选择">在==和is之间选择</h2><p>==运算符比较两个对象的值（对象中保存的数据），而is比较对象的标识。（==相当于Java中的equal()方法，而is相当于Java中的==）。通常，我们关注的是值，而不是标识，因此Python代码中==的出现频率比is高。</p><p><strong>然而，在变量和单例值之间比较时，应该使用is。目前，最常使用is检查变量绑定的值是不是None。</strong>下面是推荐的写法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>is运算符比==速度快，因为它不能重载，所以Python不用寻找并调用特殊方法，而是直接比较两个整数ID。而a==b是语法糖，等同于<code>a.__eq__(b)</code>。继承自object的<code>__eq__</code>方法比较两个对象的ID，结果与is一样，但是多数内置类型使用更有意义的方式覆盖了<code>__eq__</code>方法，会考虑对象属性的值。相等性测试可能涉及大量处理工作，例如，比较大型集合或嵌套层级深的机构时。</p><h2 id="元组的相对不变性">元组的相对不变性</h2><p>元素与多数Python集合（列表、字典、集，等等）一样，保存的是对象的引用（str、bytes和array.array等单一类型序列是扁平的，它们保存的不是引用，而是在连续的内容中保存数据本身）。如果引用的元素是可变的，即使元组本身不可变，元素依然可变。也就是说，元组的不可变性其实是指tuple数据结构的物理内容（即保存的引用）不可变，与引用的对象无关。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 == t2, t1 <span class="keyword">is</span> t2  <span class="comment"># t1与t2相等，但不是同一个对象</span></span><br><span class="line">(<span class="literal">True</span>, <span class="literal">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(t1[<span class="number">-1</span>])</span><br><span class="line"><span class="number">4533178056</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1[<span class="number">-1</span>].append(<span class="number">99</span>)  <span class="comment"># 改变t[-1]的内容</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(t1[<span class="number">-1</span>])  <span class="comment"># t[-1]的标识没变</span></span><br><span class="line"><span class="number">4533178056</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 == t2  <span class="comment"># 内容不再相等</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>来自2.6.1节的一个谜题：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>] += [<span class="number">50</span>, <span class="number">60</span>]</span><br></pre></td></tr></table></figure><p>上述两个表达式的运行结果是哪一个？</p><ol type="a"><li><p>t变成(1, 2, [30, 40, 50, 60])。</p></li><li><p>因为tuple不支持对它的元素赋值，所以会抛出TypeError异常。</p></li><li><p>以上两个都不是。</p></li><li><p>a和b都是对的。</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ========== 谜题答案 ==========</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>] += [<span class="number">50</span>, <span class="number">60</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>])  <span class="comment"># 由此可见谜题的答案是 d</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(<span class="string">'s[a] += b'</span>)  <span class="comment"># 查看 s[a] += b 背后的字节码</span></span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_NAME                <span class="number">0</span> (s)</span><br><span class="line">              <span class="number">2</span> LOAD_NAME                <span class="number">1</span> (a)</span><br><span class="line">              <span class="number">4</span> DUP_TOP_TWO</span><br><span class="line">              <span class="number">6</span> BINARY_SUBSCR                       <span class="comment"># 将s[a]的值存入TOS(Top Of Stack，栈的顶端)</span></span><br><span class="line">              <span class="number">8</span> LOAD_NAME                <span class="number">2</span> (b)</span><br><span class="line">             <span class="number">10</span> INPLACE_ADD                         <span class="comment"># 计算TOS += b。这一步能够完成，是因为TOS指向的是一个可变对象</span></span><br><span class="line">             <span class="number">12</span> ROT_THREE</span><br><span class="line">             <span class="number">14</span> STORE_SUBSCR                        <span class="comment"># s[a] = TOS赋值。这一步失败，是因为s是不可变的元组</span></span><br><span class="line">             <span class="number">16</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">18</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><p>这其实是个非常罕见的边界情况，在15年的Python生涯中，我还没见过谁在这个地方吃过亏。至此我得到了3个教训。</p><ul><li>不要把可变对象放在元组里面。</li><li>增量赋值不是一个原子操作。我们刚才也看到了，它虽然抛出了异常，但还是完成了操作。</li><li>查看Python的字节码并不难，而且它对我们了解代码背后的运行机制很有帮助。</li></ul><h1 id="默认做浅复制">默认做浅复制</h1><p>复制列表（或多数内置的可变集合）最简单的方式是使用内置的类型构造方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="number">3</span>, [<span class="number">55</span>, <span class="number">44</span>], (<span class="number">7</span>, <span class="number">8</span> ,<span class="number">9</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 = list(l1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 == l1, l2 <span class="keyword">is</span> l1  <span class="comment"># 二者相等，但不是同一个对象</span></span><br><span class="line">(<span class="literal">True</span>, <span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>对列表和其他可变序列来说，还能使用简洁的l2=l1[:]语句创建副本。然而，构造方法或[:]做的是浅复制（即复制了最外层容器，副本中的元素是源容器中元素的引用）。如果所有元素都是不可变的，那么这样没有问题，还能节省内存。但是，如果有可变的元素，可能就会导致意想不到的问题。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="number">3</span>, [<span class="number">66</span>, <span class="number">55</span>, <span class="number">44</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 = list(l1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1[<span class="number">1</span>] <span class="keyword">is</span> l2[<span class="number">1</span>], l1[<span class="number">2</span>] <span class="keyword">is</span> l2[<span class="number">2</span>]  <span class="comment"># 浅复制复制的是引用</span></span><br><span class="line">(<span class="literal">True</span>, <span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1.append(<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1[<span class="number">1</span>].remove(<span class="number">55</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1</span><br><span class="line">[<span class="number">3</span>, [<span class="number">66</span>, <span class="number">44</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>), <span class="number">100</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2</span><br><span class="line">[<span class="number">3</span>, [<span class="number">66</span>, <span class="number">44</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2[<span class="number">1</span>] += [<span class="number">33</span>, <span class="number">22</span>]  <span class="comment"># 对可变的对象来说，+=运算符就地修改列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2[<span class="number">2</span>] += (<span class="number">10</span>, <span class="number">11</span>)  <span class="comment"># 对元组来说，+=运算符创建一个新元组，然后重新绑定给变量</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1</span><br><span class="line">[<span class="number">3</span>, [<span class="number">66</span>, <span class="number">44</span>, <span class="number">33</span>, <span class="number">22</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>), <span class="number">100</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2</span><br><span class="line">[<span class="number">3</span>, [<span class="number">66</span>, <span class="number">44</span>, <span class="number">33</span>, <span class="number">22</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>)]</span><br></pre></td></tr></table></figure><h2 id="为任意对象做深复制和浅复制">为任意对象做深复制和浅复制</h2><p>copy模块提供的deepcopy和copy函数能为任意对象做深复制和浅复制。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bus</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, passengers=None)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> passengers <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="meta">... </span>            self.passengers = []</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>            self.passengers = list(passengers)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.passengers.append(name)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">drop</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.passengers.remove(name)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> copy <span class="keyword">import</span> copy, deepcopy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1 = Bus([<span class="string">'Alice'</span>, <span class="string">'Bill'</span>, <span class="string">'Claire'</span>, <span class="string">'David'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2 = copy(bus1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3 = deepcopy(bus1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(bus1), id(bus2), id(bus3)  <span class="comment"># 3个不同的实例</span></span><br><span class="line">(<span class="number">4533933560</span>, <span class="number">4533933840</span>, <span class="number">4533934232</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1.drop(<span class="string">'Bill'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2.passengers  <span class="comment"># bus1中的Bill下车后，bus2中也没有他了</span></span><br><span class="line">[<span class="string">'Alice'</span>, <span class="string">'Claire'</span>, <span class="string">'David'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3.passengers</span><br><span class="line">[<span class="string">'Alice'</span>, <span class="string">'Bill'</span>, <span class="string">'Claire'</span>, <span class="string">'David'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(bus1.passengers), id(bus2.passengers), id(bus3.passengers)  <span class="comment"># 审查passengers属性，bus1和bus2共享同一个列表对象（浅复制）</span></span><br><span class="line">(<span class="number">4533897800</span>, <span class="number">4533897800</span>, <span class="number">4533249800</span>)</span><br></pre></td></tr></table></figure><p>一般来说，深复制不是件简单的事。如果对象有循环引用，那么这个朴素的算法会进入无限循环。deepcopy函数会记住已经复制的对象，因此能优雅地处理循环引用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [a, <span class="number">30</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>, [[...], <span class="number">30</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = deepcopy(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>, [[...], <span class="number">30</span>]]</span><br></pre></td></tr></table></figure><p>此外，深复制有时可能太深了。例如，对象可能会引用不该复制的外部资源或单例值。我们可以实现特殊方法<code>__copy__()</code>和<code>__deepcopy__()</code>，控制copy和deepcopy的行为。</p><h1 id="函数的参数作为引用时">函数的参数作为引用时</h1><p>Python唯一支持的参数传递模式是共享参数（call by sharing）。多数面向对象语言都采用这一模式。共享传参指函数的各个形式参数获得实参中各个引用的副本，也就是说，函数内部的形参是实参的别名。这种方案的结果是，函数可能会修改作为参数传入的可变对象，但是无法修改那些对象的标识。</p><h2 id="不要使用可变类型作为参数的默认值">不要使用可变类型作为参数的默认值</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">HauntedBus</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">"""备受幽灵乘客折磨的校车"""</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, passengers=[])</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.passengers = passengers</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.passengers.append(name)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">drop</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.passengers.remove(name)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1 = HauntedBus([<span class="string">'Alice'</span>, <span class="string">'Bill'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1.pick(<span class="string">'Charlie'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1.drop(<span class="string">'Alice'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1.passengers</span><br><span class="line">[<span class="string">'Bill'</span>, <span class="string">'Charlie'</span>]  <span class="comment"># 不使用默认值没什么问题</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2 = HauntedBus()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2.pick(<span class="string">'Carrie'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2.passengers</span><br><span class="line">[<span class="string">'Carrie'</span>]  <span class="comment"># 使用默认值，目前为止也没什么问题</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3 = HauntedBus()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3.passengers  <span class="comment"># bus3不是预期中的空车</span></span><br><span class="line">[<span class="string">'Carrie'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3.pick(<span class="string">'Dave'</span>)  <span class="comment"># Dave登上bus3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2.passengers  <span class="comment"># Dave出现在了bus2中</span></span><br><span class="line">[<span class="string">'Carrie'</span>, <span class="string">'Dave'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3.passengers <span class="keyword">is</span> bus2.passengers  <span class="comment"># passergers属性是同一个对象</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>问题在于，没有指定初始乘客的HauntedBus实例会共享同一个乘客列表。这是因为self.passengers变成了passengers参数默认值的别名。出现这个问题的根源是，默认值在定义函数时计算（通常在加载模块时），因此默认值变成了函数对象的属性。因此，如果默认值是可变对象，而且修改了它的值，那么后续的函数调用都会受到影响。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>HauntedBus.__init__.__defaults__</span><br><span class="line">([<span class="string">'Carrie'</span>, <span class="string">'Dave'</span>],)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>HauntedBus.__init__.__defaults__[<span class="number">0</span>] <span class="keyword">is</span> bus2.passengers <span class="keyword">is</span> bus3.passengers</span><br><span class="line"><span class="literal">True</span>  <span class="comment"># 使用默认值的实例，其passengers属性实际上都是默认值[]的别名</span></span><br></pre></td></tr></table></figure><h2 id="防御可变参数">防御可变参数</h2><p>如果定义的函数接收可变参数，应该谨慎考虑调用方是否期望修改传入的参数。具体情况具体分析，这其实需要函数的编写者和调用方达成共识。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">TwilightBus</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">"""让乘客销声匿迹的校车</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    一个简单的类，说明接受可变参数的风险"""</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, passengers=None)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> passengers <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="meta">... </span>            self.passengers = <span class="literal">None</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>            self.passengers = passengers  <span class="comment"># self.passengers变成passengers的别名</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.passengers.append(name)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">drop</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.passengers.remove(name)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>basketball_team = [<span class="string">'Sue'</span>, <span class="string">'Tina'</span>, <span class="string">'Maya'</span>, <span class="string">'Diana'</span>, <span class="string">'Pat'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus = TwilightBus(basketball_team)  <span class="comment"># self.passengers变成了实参basketball_team的别名</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus.drop(<span class="string">'Tina'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus.drop(<span class="string">'Pat'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>basketball_team  <span class="comment"># 下车的学生从篮球队中消失了</span></span><br><span class="line">[<span class="string">'Sue'</span>, <span class="string">'Maya'</span>, <span class="string">'Diana'</span>]</span><br></pre></td></tr></table></figure><p>TwilightBus违反了设计接口的最佳实践，即“最少惊讶原则”。正确的做法是，校车自己维护乘客列表。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, passengers=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> passengers <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self.passengers = []</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.passengers = list(passengers)  <span class="comment"># 修改此处，创建passengers的副本，然后赋值给self.passengers</span></span><br></pre></td></tr></table></figure><p>在内部像这样处理乘客列表，就不会影响初始化校车时传入的参数了。此外，这种处理方式还更灵活：现在传给passengers参数的值可以是元组或任何其他可迭代对象，例如set对象，甚至数据库查询结果。</p><h1 id="del和垃圾回收">del和垃圾回收</h1><p>del语句删除名称，而不是对象。del命令可能会导致对象被当作垃圾回收，但是仅当删除的变量保存的是对象的最后一个引用，或者无法得到对象时（如果两个对象相互引用，当它们的引用只存在二者之间时，垃圾回收程序会判定它们无法获取，进而把它们都销毁）。重新绑定也可能会导致对象的引用数量归零，导致对象被销毁。</p><p>有个<code>__del__</code>特殊方法，它是他不会销毁实例，不应该在代码中调用。即将销毁实例时，Python解释器会调用<code>__del__</code>方法，给实例最后的机会，释放外部资源。自己编写的代码很少需要实现<code>__del__</code>。</p><p>在CPython中，垃圾回收使用的主要算法是引用计数。实际上，每个对象都会统计有多少引用指向自己。当引用计数归零时，对象立即就被销毁：CPython会在对象上调用<code>__del__</code>方法（如果定义了），然后释放分配给对象的内存。CPython 2.0增加了分代垃圾回收算法，用于检测引用循环中涉及的对象组——如果一组对象之间全是相互引用，即使再出色的引用方式也会导致组中的对象不可获取。Python的其他实现有更复杂的垃圾回收程序，而且不依赖引用计数，这意味着，对象的引用数量归零时可能不会立即调用<code>__del__</code>方法。</p><p>对了演示对象生命结束时的情形，使用weakref.finalize注册一个回调函数，在销毁对象时调用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> weakref</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = s1  <span class="comment"># s1和s2指向同一个集合</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">bye</span><span class="params">()</span>:</span>  <span class="comment"># 这个函数一定不能是要销毁的对象的绑定方法，否则会有一个指向对象的引用</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Gone with the wind...'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ender = weakref.finalize(s1, bye)  <span class="comment"># 在s1引用的对象上注册bye回调，finalize持有&#123;1, 2, 3&#125;的弱引用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ender.alive</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> s1  <span class="comment"># 删除引用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ender.alive  <span class="comment"># 对象依然存在</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = <span class="string">'spam'</span>  <span class="comment"># 重新绑定了s2，原来的集合对象无法获取，对象被销毁了</span></span><br><span class="line">Gone <span class="keyword">with</span> the wind...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ender.alive</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="弱引用">弱引用</h1><p>弱引用不会增加对象的引用数量。引用的目标对象称为所指对象（referent）。因此，弱引用不会妨碍所指对象被当作垃圾回收。弱引用在缓存应用中很有用，因为我们不想仅因为被缓存引用着而始终保存缓存对象。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_set = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref = weakref.ref(a_set)  <span class="comment"># 创建弱引用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref  <span class="comment"># 审查</span></span><br><span class="line">&lt;weakref at <span class="number">0x10e3dae08</span>; to <span class="string">'set'</span> at <span class="number">0x10e326ac8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref()  <span class="comment"># 调用wref()返回的是被引用的对象。因为这是控制台会话，所以&#123;0, 1&#125;会绑定给 _ 变量</span></span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_set = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;  <span class="comment"># &#123;0, 1&#125;的引用数减少了，但是 _ 变量仍然指代它</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref()  <span class="comment"># 依旧返回&#123;0, 1&#125;</span></span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref() <span class="keyword">is</span> <span class="literal">None</span>  <span class="comment"># 计算表达式时，&#123;0, 1&#125;存在，因此返回False，随后 _ 绑定到结果值False，现在&#123;0, 1&#125;没有强引用了</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref() <span class="keyword">is</span> <span class="literal">None</span>  <span class="comment"># &#123;0, 1&#125;对象不存在了，所以返回True</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p><a href="http://docs.python.org/3/library/weakref.html" target="_blank" rel="noopener">weakref模块的文档</a>指出，weakref.ref类其实是底层接口，供高级用途使用，多数程序最好使用weakref集合和finalize。也就是说，应该使用WeakKeyDictionary、WeakValueDictionary、WeakSet和finalize（在内部使用弱引用），不要自己动手创建并处理weakref.ref实例。</p><h2 id="weakvaluedictionary简介">WeakValueDictionary简介</h2><p>WeakValueDictionary类实现的是一种可变映射，里面的值是对象的弱引用，被引用的对象在程序的其他地方被当作垃圾回收后，对应的键会自动从WeakValueDictionary中删除。因此WeakValueDictionary经常用于缓存。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Cheese</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, kind)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.kind = kind</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">'Cheese(%r)'</span> % self.kind</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> weakref</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stock = weakref.WeakValueDictionary()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>catalog = [Cheese(<span class="string">'Red Leicester'</span>), Cheese(<span class="string">'Tilsit'</span>), Cheese(<span class="string">'Brie'</span>), Cheese(<span class="string">'Parmesan'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> cheese <span class="keyword">in</span> catalog:  <span class="comment"># 循环中cheese是全局变量，循环结束后也不会消失</span></span><br><span class="line"><span class="meta">... </span>    stock[cheese.kind] = cheese</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(stock.keys())  <span class="comment"># stock是完整的</span></span><br><span class="line">[<span class="string">'Brie'</span>, <span class="string">'Parmesan'</span>, <span class="string">'Red Leicester'</span>, <span class="string">'Tilsit'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> catalog</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(stock.keys())  <span class="comment"># 为什么会剩下一个</span></span><br><span class="line">[<span class="string">'Parmesan'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> cheese  <span class="comment"># 临时变量cheese引用了对象，导致该变量存在时间比预期长</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(stock.keys())</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><p>与WeakValueDictionary对应的是WeakKeyDictionary，后者的键是弱引用。WeakKeyDictionary实例可以为应用中其他部分拥有的对象附加数据，这样就无需为对象添加属性。这对覆盖属性访问权限的对象尤其有用。WeakSet类：保存元素弱引用的集合类。元素没有强应用时，集合会把它删除。</p><h2 id="弱引用的局限">弱引用的局限</h2><p>不是每个Python对象都可以作为弱引用的目标（或称所指对象）。基本的list和dict实例不能作为所指对象，但是他们的子类可以轻松地解决这个问题。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="string">"""list的子类，实例可以作为弱引用的目标"""</span></span><br><span class="line"></span><br><span class="line">a_list = MyList(range(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># a_list可以作为弱引用的目标</span></span><br><span class="line">wref_to_a_list = weakref.ref(a_list)</span><br></pre></td></tr></table></figure><p>set实例可以作为所指对象（因此前面的实例才使用{0, 1}），用户定义的类型也没问题（Cheese类）。但是，int和tuple实例不能作为弱引用的目标，甚至它们的子类也不行。这些局限基本上是CPython的实现细节，在其他Python解释器中情况可能不一样，这些局限是内部优化导致的结果。</p><h1 id="python对不可变类型施加的把戏">Python对不可变类型施加的把戏</h1><p>对元组t来说，t[:]不创建副本，而是返回同一个对象的引用。此外，tuple(t)获得的也是同一个元组的引用。在Python控制台中输入help(tuple)，你会看到这句话：“If the argument is a tuple, the return value is the same object.”。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 = tuple(t1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 <span class="keyword">is</span> t1</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t3 = t1[:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t3 <span class="keyword">is</span> t1</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>str、bytes和frozenset实例也有这种行为。frozenset实例不是序列，不能使用fs[:]，但是fs.copy()具有相同的效果：它会欺骗你，返回同一个对象的引用，而不是创建一个副本。copy方法不会复制所有对象，这是一个善意的谎言，为的是接口的兼容性：这使得frozenset的兼容性比set强。两个不可变对象是同一个对象还是副本，对最终用户来说没有区别。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t3 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 <span class="keyword">is</span> t3  <span class="comment"># t1和t3不是同一个对象</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = <span class="string">'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = <span class="string">'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 <span class="keyword">is</span> s2  <span class="comment"># 奇怪的事情发生了，s1和s2指代同一个字符串</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>共享字符串字面量是一种优化措施，称为驻留（interning）。CPython还会在小的整数上使用这个优化措施，防止重复创建“热门”数字。注意，CPython不会驻留所有字符串和整数，驻留的条件是实现细节，而且没有文档说明。因此，千万不要依赖字符串或整数的驻留！比较字符串或整数是否相等时，应该使用==，而不是is。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标准库中的装饰器</title>
      <link href="/notes/fluent-python/decorators-in-standard-library/"/>
      <url>/notes/fluent-python/decorators-in-standard-library/</url>
      
        <content type="html"><![CDATA[<p>标准库中最值得关注的两个装饰器是lru_cache和全新的singledispatch（Python3.4新增）。这两个装饰器都在functools模块中定义。</p><h1 id="使用lru_cache做备忘">使用lru_cache做备忘</h1><p>functools.lru_cache实现了备忘（memoization）功能。这是一项优化技术，它把耗时的函数的结果保存起来，避免传入相同的参数时重复计算。LRU三个字母是“Least Recently Used”的缩写，表明缓存不会无限制增长，一段时间不用的缓存条目会被扔掉。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/functools#functools.lru_cache" target="_blank" rel="noopener"><code>@functools.lru_cache(maxsize=128, typed=False)</code></a></p><p>maxsize参数指定存储多少个调用的结果。缓存满了之后，旧的结果会被扔掉，腾出空间。为了得到最佳性能，maxsize应该设为2的幂。</p><p>Typed参数如果设为True，把不同类型参数得到的结果分开保存，即把通常认为相同的浮点数和整数参数（如1和1.0）区分开。</p><p>lru_cache使用字典存储结果，而且键根据调用时传入的定位参数和关键字参数创建，所以被lru_cache装饰的函数，它的所有参数都必须是可散列的。</p></blockquote><a id="more"></a><p>生成第n个斐波那契这种慢速递归函数适合使用lru_cache。</p><figure class="highlight python"><figcaption><span>clockdemo.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        t0 = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        elapsed = time.time() - t0</span><br><span class="line">        name = func.__name__</span><br><span class="line">        arg_lst = []</span><br><span class="line">        <span class="keyword">if</span> args:</span><br><span class="line">            arg_lst.append(<span class="string">', '</span>.join(repr(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args))</span><br><span class="line">        <span class="keyword">if</span> kwargs:</span><br><span class="line">            pairs = [<span class="string">'%s=%r'</span> % (k, w) <span class="keyword">for</span> k, w <span class="keyword">in</span> sorted(kwargs.items())]</span><br><span class="line">            arg_lst.append(<span class="string">', '</span>.join(pairs))</span><br><span class="line">        arg_str = <span class="string">', '</span>.join(arg_lst)</span><br><span class="line">        print(<span class="string">'[%0.8fs] %s(%s) -&gt; %r '</span> % (elapsed, name, arg_str, result))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clocked</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> clockdemo <span class="keyword">import</span> clock</span><br><span class="line"></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">2</span>) + fibonacci(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(fibonacci(<span class="number">6</span>))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[0.00000095s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000095s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00005102s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00000072s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000787s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00001478s] fibonacci(3) -&gt; 2</span><br><span class="line">[0.00007391s] fibonacci(4) -&gt; 3</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000691s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00001407s] fibonacci(3) -&gt; 2</span><br><span class="line">[0.00000119s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000691s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000095s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000834s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00001383s] fibonacci(3) -&gt; 2</span><br><span class="line">[0.00002813s] fibonacci(4) -&gt; 3</span><br><span class="line">[0.00005007s] fibonacci(5) -&gt; 5</span><br><span class="line">[0.00013185s] fibonacci(6) -&gt; 8</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>浪费时间的地方很明显：fibonacci(1)调用了8次，fibonacci(2)调用了5次……下面使用缓存实现，速度更快。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">from</span> clockdemo <span class="keyword">import</span> clock</span><br><span class="line"></span><br><span class="line"><span class="meta">@functools.lru_cache()  # 必须加括号，因为lru_cache可以接受配置参数，lru_cache应用到clock返回的函数上</span></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">2</span>) + fibonacci(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(fibonacci(<span class="number">6</span>))</span><br></pre></td></tr></table></figure><p>执行时间减半了，而且n的每个值只调用一次函数。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[0.00000000s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000119s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00004601s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00000119s] fibonacci(3) -&gt; 2</span><br><span class="line">[0.00005412s] fibonacci(4) -&gt; 3</span><br><span class="line">[0.00000000s] fibonacci(5) -&gt; 5</span><br><span class="line">[0.00006390s] fibonacci(6) -&gt; 8</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>除了优化递归算法之外，lru_cache在从Web中获取信息的应用中也能发挥巨大作用。</p><h1 id="单分派泛函数">单分派泛函数</h1><p>假设我们在开发一个调试Web应用的工具，想生成HTML，显示不同类型的Python对象。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> html</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">htmlize</span><span class="params">(obj)</span>:</span></span><br><span class="line">    content = html.escape(repr(obj))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;pre&gt;&#123;&#125;&lt;/pre&gt;'</span>.format(content)</span><br></pre></td></tr></table></figure><p>这个函数适用于任何Python类型，但是现在想做个扩展，让它使用特别的方式显示某些类型。</p><ul><li>str: 把内部的换行符替换为'&lt;br&gt;\n'；不使用&lt;pre&gt;，而是使用&lt;p&gt;。</li><li>int: 以十进制和十六进制显示数字。</li><li>list: 输出一个HTML列表，根据各个元素的类型进行格式化。</li></ul><p>因为Python不支持重载方法或函数，所以不能使用不同的签名定义htmlize的变体，也无法使用不同的方式处理不同的数据类型。在Python中，一种常见的做法是把htmlize变成一个分派函数，使用一串if/elif/elif，调用专门的函数，如htmlize_str、htmlize_int，等等。这样不便于模块的用户扩展，还显得笨拙：时间一长，分派函数htmlize会变得很大，而且它与各个专门函数之间的耦合也很紧密。</p><p>Python3.4新增的functools.singledispatch装饰器可以把整体方案拆分成多个模块，甚至可以为你无法修改的类提供专门的函数。使用@singledispatch装饰的普通函数会变成泛函数（generic function）：根据第一个参数的类型，以不同方式执行相同操作的一组函数。（这才称得上是单分派。如果根据多个参数选择专门的函数，那就是多分派了。）具体做法如下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"><span class="keyword">import</span> numbers</span><br><span class="line"><span class="keyword">import</span> html</span><br><span class="line"></span><br><span class="line"><span class="meta">@singledispatch  # 标记处理object函数的基函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">htmlize</span><span class="params">(obj)</span>:</span></span><br><span class="line">    content = html.escape(repr(obj))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;pre&gt;&#123;&#125;&lt;/pre&gt;'</span>.format(content)</span><br><span class="line"></span><br><span class="line"><span class="meta">@htmlize.register(str)  # 专门函数，函数名称无关紧要，_是个不错的选择</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(text)</span>:</span></span><br><span class="line">    content = html.escape(text).replace(<span class="string">'\n'</span>, <span class="string">'&lt;br&gt;\n'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;p&gt;&#123;0&#125;&lt;/p&gt;'</span>.format(content)</span><br><span class="line"></span><br><span class="line"><span class="meta">@htmlize.register(numbers.Integral)  # numbers.Integral是int的虚拟超类</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;pre&gt;&#123;0&#125; (0x&#123;0:x&#125;)&lt;/pre&gt;'</span>.format(n)</span><br><span class="line"></span><br><span class="line"><span class="meta">@htmlize.register(tuple)  # 可以叠放多个register装饰器，让同一个函数支持不同类型</span></span><br><span class="line"><span class="meta">@htmlize.register(abc.MutableSequence)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(seq)</span>:</span></span><br><span class="line">    inner = <span class="string">'&lt;/li&gt;\n&lt;li&gt;'</span>.join(htmlize(item) <span class="keyword">for</span> item <span class="keyword">in</span> seq)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;ul&gt;\n&lt;li&gt;'</span> + inner + <span class="string">'&lt;/li&gt;\n&lt;/ul&gt;'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(repr(htmlize(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)), <span class="string">'\n'</span>)</span><br><span class="line">    print(repr(htmlize(abs)), <span class="string">'\n'</span>)</span><br><span class="line">    print(repr(htmlize(<span class="string">'Heimlich &amp; Co.\n- a game'</span>)), <span class="string">'\n'</span>)</span><br><span class="line">    print(repr(htmlize(<span class="number">42</span>)), <span class="string">'\n'</span>)</span><br><span class="line">    print(htmlize([<span class="string">'alpha'</span>, <span class="number">66</span>, &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;]))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;&lt;pre&gt;&#123;1, 2, 3&#125;&lt;/pre&gt;&apos;</span><br><span class="line"></span><br><span class="line">&apos;&lt;pre&gt;&amp;lt;built-in function abs&amp;gt;&lt;/pre&gt;&apos;</span><br><span class="line"></span><br><span class="line">&apos;&lt;p&gt;Heimlich &amp;amp; Co.&lt;br&gt;\n- a game&lt;/p&gt;&apos;</span><br><span class="line"></span><br><span class="line">&apos;&lt;pre&gt;42 (0x2a)&lt;/pre&gt;&apos;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;&lt;p&gt;alpha&lt;/p&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;pre&gt;66 (0x42)&lt;/pre&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;pre&gt;&#123;1, 2, 3&#125;&lt;/pre&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>只要可能，注册的专门函数应该处理抽象基类（如numbers.Integral和abc.MutableSequence），不要处理具体实现类（如int和list）。这样，代码支持的兼容类型更广泛。</p><p>singledispatch机制的一个显著特征是，你可以在系统的任何地方和任何模块中注册专门函数。如果后来在新的模块中定义了新的类型，可以轻松地添加一个新的专门函数用来处理那个类型。此外，还可以为不是自己编写的或者不能修改的类添加自定义函数。</p><p>singledispatch提供的特性很多，这个机制最好的文档是 <a href="https://www.python.org/dev/peps/pep-0443/" target="_blank" rel="noopener">PEP 443 —— Single-dispatch generic functions</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> decorators </tag>
            
            <tag> Fluent Python </tag>
            
            <tag> lru_cache </tag>
            
            <tag> singledispatch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现一个简单的装饰器</title>
      <link href="/notes/fluent-python/implementing-a-simple-decorator/"/>
      <url>/notes/fluent-python/implementing-a-simple-decorator/</url>
      
        <content type="html"><![CDATA[<h1 id="一个简单的clock装饰器">一个简单的clock装饰器</h1><p>定义一个装饰器，它会在每次调用被装饰的函数时计时，然后把经过的时间、传入的参数和调用的结果打印出来。</p><figure class="highlight python"><figcaption><span>clockdeco_demo.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*args)</span>:</span>  <span class="comment"># 定义内部函数clocked，它接受任意个定位参数</span></span><br><span class="line">        t0 = time.perf_counter()</span><br><span class="line">        result = func(*args)  <span class="comment"># func是自由变量</span></span><br><span class="line">        elapsed = time.perf_counter() - t0</span><br><span class="line">        name = func.__name__</span><br><span class="line">        arg_str = <span class="string">', '</span>.join(repr(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args)</span><br><span class="line">        print(<span class="string">'[%0.8fs] %s(%s) -&gt; %r'</span> % (elapsed, name, arg_str, result))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clocked  <span class="comment"># 返回内部函数，取代被装饰的函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@clock  # 示例</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snooze</span><span class="params">(seconds)</span>:</span></span><br><span class="line">    time.sleep(seconds)</span><br><span class="line"></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'*'</span> * <span class="number">40</span>, <span class="string">'Calling snooze(.123)'</span>)</span><br><span class="line">    snooze(<span class="number">.123</span>)</span><br><span class="line">    print(<span class="string">'*'</span> * <span class="number">40</span>, <span class="string">'Calling factorial(6)'</span>)</span><br><span class="line">    print(<span class="string">'6! ='</span>, factorial(<span class="number">6</span>))</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**************************************** Calling snooze(.123)</span><br><span class="line">[0.12325113s] snooze(0.123) -&gt; None</span><br><span class="line">**************************************** Calling factorial(6)</span><br><span class="line">[0.00000078s] factorial(1) -&gt; 1</span><br><span class="line">[0.00003158s] factorial(2) -&gt; 2</span><br><span class="line">[0.00010166s] factorial(3) -&gt; 6</span><br><span class="line">[0.00043166s] factorial(4) -&gt; 24</span><br><span class="line">[0.00044242s] factorial(5) -&gt; 120</span><br><span class="line">[0.00045205s] factorial(6) -&gt; 720</span><br><span class="line">6! = 720</span><br></pre></td></tr></table></figure><h1 id="工作原理">工作原理</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">factorial = clock(factorial)</span><br></pre></td></tr></table></figure><p>因此，在两个示例中，factorial会作为func参数传给clock。然后，clock函数会返回clocked函数，Python解释器在背后会把clocked赋值给factorial。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> clockdeco_demo  <span class="comment"># 导入模块</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>clockdeco_demo.factorial.__name__  <span class="comment"># factorial的__name__</span></span><br><span class="line"><span class="string">'clocked'</span></span><br></pre></td></tr></table></figure><p>所以，现在factorial保存的是clocked函数的引用。自此之后，每次调用factorial(n)，执行的都是clocked(n)。这是装饰器的典型行为：把被装饰的函数替换成新函数，二者接受相同的参数，而且（通常）返回被装饰的函数本该返回的值，同时还会做些额外操作。</p><p><em>Gamma等人写的《设计模式：可复用面向对象软件的基础》一书是这样概述装饰器模式的：“动态地给一个对象添加一些额外的职责。”函数装饰器符合这一说法，但是，在实现层面，Python装饰器与GoF所述的装饰器没有多少相似之处。</em></p><p>上例实现的clock装饰器有几个缺点：不支持关键字参数，而且遮盖了被装饰函数的<code>__name__</code>和<code>__doc__</code>属性，下面使用functools.wraps装饰器把相关的属性从func复制到clocked中。此外，还能正确处理关键字参数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(func)</span>:</span>  <span class="comment"># 新版clock</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)  # 标准库中的装饰器之一</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*args, **kwargs)</span>:</span>  <span class="comment"># 接受定位和关键字参数</span></span><br><span class="line">        t0 = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        elapsed = time.time() - t0</span><br><span class="line">        name = func.__name__</span><br><span class="line">        arg_lst = []</span><br><span class="line">        <span class="keyword">if</span> args:</span><br><span class="line">            arg_lst.append(<span class="string">', '</span>.join(repr(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args))</span><br><span class="line">        <span class="keyword">if</span> kwargs:</span><br><span class="line">            pairs = [<span class="string">'%s=%r'</span> % (k, w) <span class="keyword">for</span> k, w <span class="keyword">in</span> sorted(kwargs.items())]</span><br><span class="line">            arg_lst.append(<span class="string">', '</span>.join(pairs))</span><br><span class="line">        arg_str = <span class="string">', '</span>.join(arg_lst)</span><br><span class="line">        print(<span class="string">'[%0.8fs] %s(%s) -&gt; %r '</span> % (elapsed, name, arg_str, result))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clocked</span><br><span class="line"></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  <span class="comment"># 测试</span></span><br><span class="line">    print(<span class="string">'6! ='</span>, factorial(n=<span class="number">6</span>))</span><br><span class="line">    print(factorial.__name__)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[0.00000000s] factorial(1) -&gt; 1</span><br><span class="line">[0.00003505s] factorial(2) -&gt; 2</span><br><span class="line">[0.00014687s] factorial(3) -&gt; 6</span><br><span class="line">[0.00014997s] factorial(4) -&gt; 24</span><br><span class="line">[0.00015521s] factorial(5) -&gt; 120  # 递归是通过定位传入的</span><br><span class="line">[0.00015807s] factorial(n=6) -&gt; 720  # 最外层是通过关键词传入的</span><br><span class="line">6! = 720</span><br><span class="line">factorial  # 函数的__name__属性也被复制过来了</span><br></pre></td></tr></table></figure><h1 id="叠放装饰器">叠放装饰器</h1><p>把@d1和<span class="citation" data-cites="d2两个装饰器按顺序应用到f函数上">@d2两个装饰器按顺序应用到f函数上</span>，作用相当于f = d1(d2(f))。在一节中使用过该技巧：<span class="citation" data-cites="lru_cache应用到">@lru_cache应用到</span><span class="citation" data-cites="clock装饰fibonacci得到的结果上">@clock装饰fibonacci得到的结果上</span>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@d1</span></span><br><span class="line"><span class="meta">@d2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'f'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'f'</span>)</span><br><span class="line"></span><br><span class="line">f = d1(d2(f))</span><br></pre></td></tr></table></figure><h1 id="参数化装饰器">参数化装饰器</h1><p>解析源码中的装饰器时，Python把被装饰的函数作为第一个参数传给装饰器函数。那怎么让装饰器接受其他参数呢？答案是：创建一个装饰器工厂函数，把参数传给它，返回一个装饰器，然后再把它应用到要装饰的函数上。例如下面的装饰器。</p><figure class="highlight python"><figcaption><span>registration.py</span></figcaption><table><tr><td class="code"><pre><span class="line">registry = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">'running register(%s)'</span> % func)</span><br><span class="line">    registry.append(func)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f1()'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'running main()'</span>)</span><br><span class="line">print(<span class="string">'registry -&gt;'</span>, registry)</span><br><span class="line">f1()</span><br></pre></td></tr></table></figure><p>为了便于启用或禁用register执行的函数注册功能，为它提供一个可选的active参数，设为False时，不注册被装饰的函数。</p><figure class="highlight python"><figcaption><span>registration_param.py</span></figcaption><table><tr><td class="code"><pre><span class="line">registry = set()  <span class="comment"># 便于添加和删除对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(active=True)</span>:</span>  <span class="comment"># 接受一个可选的关键字参数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span>  <span class="comment"># 真正的装饰器，其参数是函数</span></span><br><span class="line">        print(<span class="string">'running register(active=%s)-&gt;decorate(%s)'</span> % (active, func))</span><br><span class="line">        <span class="keyword">if</span> active:</span><br><span class="line">            registry.add(func)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            registry.discard(func)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> func  <span class="comment"># 返回一个函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decorate  <span class="comment"># register时装饰器工厂函数，因此返回decorate</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@register(active=False)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f1()'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@register()  # 即使不传入参数，也必须作为函数调用（@register()）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f2()'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f3()'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> registration_param <span class="keyword">import</span> *  <span class="comment"># 导入</span></span><br><span class="line">running register(active=False)-&gt;decorate(&lt;function f1 at 0x109fd0bf8&gt;)</span><br><span class="line">running register(active=True)-&gt;decorate(&lt;function f2 at 0x109fd0c80&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>registry</span><br><span class="line">&#123;&lt;function f2 at <span class="number">0x109fd0c80</span>&gt;&#125;  <span class="comment"># 只有f2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>register()(f3)  <span class="comment"># register()返回decoratro，然后应用到f3上</span></span><br><span class="line">running register(active=True)-&gt;decorate(&lt;function f3 at 0x109fd0b70&gt;)</span><br><span class="line">&lt;function f3 at <span class="number">0x109fd0b70</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>registry</span><br><span class="line">&#123;&lt;function f2 at <span class="number">0x109fd0c80</span>&gt;, &lt;function f3 at <span class="number">0x109fd0b70</span>&gt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>register(active=<span class="literal">False</span>)(f2)  <span class="comment"># 删除f2</span></span><br><span class="line">running register(active=False)-&gt;decorate(&lt;function f2 at 0x109fd0c80&gt;)</span><br><span class="line">&lt;function f2 at <span class="number">0x109fd0c80</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>registry</span><br><span class="line">&#123;&lt;function f3 at <span class="number">0x109fd0b70</span>&gt;&#125;</span><br></pre></td></tr></table></figure><p>参数化装饰器的远离相当复杂，刚刚讨论的比大多数都简单。参数化装饰器通常会把被装饰的函数替换掉，而且结构上需要多一层嵌套。接下来会探讨这种函数金字塔。</p><h1 id="参数化clock装饰器">参数化clock装饰器</h1><p>为clock装饰器添加一个功能：让用户传入一个格式字符串，控制被装饰函数的输出。</p><figure class="highlight python"><figcaption><span>clockdeco_param.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">DEFAULT_FMT = <span class="string">'[&#123;elapsed:0.8f&#125;s] &#123;name&#125;(&#123;args&#125;) -&gt; &#123;result&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(fmt=DEFAULT_FMT)</span>:</span>  <span class="comment"># 装饰器工厂函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span>  <span class="comment"># 真正的装饰器</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*_args)</span>:</span>  <span class="comment"># 包装被装饰的函数</span></span><br><span class="line">            t0 = time.time()</span><br><span class="line">            _result = func(*_args)  <span class="comment"># 调用被装饰的函数</span></span><br><span class="line">            elapsed = time.time() - t0</span><br><span class="line">            name = func.__name__</span><br><span class="line">            args = <span class="string">', '</span>.join(repr(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> _args)</span><br><span class="line">            result = repr(_result)</span><br><span class="line">            print(fmt.format(**locals()))  <span class="comment"># 引用clock的局部变量</span></span><br><span class="line">            <span class="keyword">return</span> _result  <span class="comment"># 返回被装饰函数返回的值</span></span><br><span class="line">        <span class="keyword">return</span> clocked</span><br><span class="line">    <span class="keyword">return</span> decorate</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line"><span class="meta">    @clock()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">snooze</span><span class="params">(seconds)</span>:</span></span><br><span class="line">        time.sleep(seconds)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @clock('&#123;name&#125;: &#123;elapsed&#125;s')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">snooze1</span><span class="params">(seconds)</span>:</span></span><br><span class="line">        time.sleep(seconds)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @clock('&#123;name&#125;(&#123;args&#125;) dt=&#123;elapsed:0.3f&#125;s')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">snooze2</span><span class="params">(seconds)</span>:</span></span><br><span class="line">        time.sleep(seconds)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> func <span class="keyword">in</span> [snooze, snooze1, snooze2]:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            func(<span class="number">.123</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[0.12812114s] snooze(0.123) -&gt; None</span><br><span class="line">[0.12493706s] snooze(0.123) -&gt; None</span><br><span class="line">[0.12483931s] snooze(0.123) -&gt; None</span><br><span class="line">snooze1: 0.12311005592346191s</span><br><span class="line">snooze1: 0.12802791595458984s</span><br><span class="line">snooze1: 0.12346792221069336s</span><br><span class="line">snooze2(0.123) dt=0.124s</span><br><span class="line">snooze2(0.123) dt=0.123s</span><br><span class="line">snooze2(0.123) dt=0.124s</span><br></pre></td></tr></table></figure><p><em>Graham Dumpleton和Lennart Regebro（Fluent Python一书的技术审校之一）认为，装饰器最好通过实现<code>__call__</code>方法的类实现，不应该通过函数实现。</em></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> decorators </tag>
            
            <tag> Fluent Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数装饰器和闭包</title>
      <link href="/notes/fluent-python/function-decorators-and-closures/"/>
      <url>/notes/fluent-python/function-decorators-and-closures/</url>
      
        <content type="html"><![CDATA[<p>函数装饰器用于在源码中“标记”函数，以某种方式增强函数的行为。这是一项强大的功能，但是若想掌握，必须理解闭包。除了在装饰器中有用处之外，闭包还是回调式异步编程和函数式编程风格的基础。</p><h1 id="装饰器基础知识">装饰器基础知识</h1><p>装饰器是可调用的对象，其参数是另一个函数（被装饰的函数）。装饰器可能会处理被装饰的函数，然后把它返回，或者将其替换成另一个函数或可调用对象。</p><p>假如有个名为decorate的装饰器，下述两种写法的效果一样：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写法1</span></span><br><span class="line"><span class="meta">@decorate</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running target()'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写法2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running target()'</span>)</span><br><span class="line"></span><br><span class="line">target = decorate(target)</span><br></pre></td></tr></table></figure><a id="more"></a><p>两个代码片段执行完毕后得到的是decorate(target)返回的函数。为了确认被装饰的函数会被替换，看一个实例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">'running inner()'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> inner  <span class="comment"># 返回inner函数</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@deco  <span class="comment"># 使用deco装饰target函数</span></span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'running target()'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>target()</span><br><span class="line">running inner()  <span class="comment"># 被装饰的target函数其实会运行inner</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>target  <span class="comment"># 审查对象，target现在是inner的引用</span></span><br><span class="line">&lt;function deco.&lt;locals&gt;.inner at <span class="number">0x106580d08</span>&gt;</span><br></pre></td></tr></table></figure><p>装饰器可以像常规的可调用对象那样调用，其参数是另一个函数。有时，这样做更方便，尤其是做元编程（在运行时改变程序的行为）时。</p><ul><li>装饰器的一大特性是，能把被装饰的函数替换成其他函数。</li><li>第二个特性是，装饰器在加载模块时立即执行。</li></ul><h1 id="python何时执行装饰器">Python何时执行装饰器</h1><p>装饰器的一个关键特性是，它们在被装饰的函数定义之后立即运行。这通常是在导入时（即Python加载模块时）。</p><figure class="highlight python"><figcaption><span>registration.py</span></figcaption><table><tr><td class="code"><pre><span class="line">registry = []  <span class="comment"># 保存被@register装饰的函数引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(func)</span>:</span>  <span class="comment"># 参数是函数</span></span><br><span class="line">    print(<span class="string">'running register(%s'</span> % func)  <span class="comment"># 为了演示，显示被装饰的函数</span></span><br><span class="line">    registry.append(func)  <span class="comment"># 存入被装饰的函数</span></span><br><span class="line">    <span class="keyword">return</span> func  <span class="comment"># 返回值是函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">     print(<span class="string">'running f1()'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f2()'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">()</span>:</span>  <span class="comment"># f1和f2被装饰，f3没有装饰</span></span><br><span class="line">    print(<span class="string">'running f3()'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running main()'</span>)</span><br><span class="line">    print(<span class="string">'registry -&gt;'</span>, registry)</span><br><span class="line">    f1()</span><br><span class="line">    f2()</span><br><span class="line">    f3()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()  <span class="comment"># 作为脚本运行时才调用main()</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python registration.py  <span class="comment"># 把registration.py当作脚本运行时</span></span><br><span class="line">running register(&lt;function f1 at <span class="number">0x10a8e46a8</span>&gt;</span><br><span class="line">running register(&lt;function f2 at <span class="number">0x10a8e4730</span>&gt;</span><br><span class="line">running main()</span><br><span class="line">registry -&gt; [&lt;function f1 at 0x10a8e46a8&gt;, &lt;function f2 at 0x10a8e4730&gt;]</span><br><span class="line">running f1()</span><br><span class="line">running f2()</span><br><span class="line">running f3()</span><br><span class="line"></span><br><span class="line">$ python  <span class="comment"># 运行python解释器</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> registration  <span class="comment"># 导入模块</span></span><br><span class="line">running register(&lt;function f1 at <span class="number">0x10e893b70</span>&gt;</span><br><span class="line">running register(&lt;function f2 at <span class="number">0x10e893bf8</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>registration.registry  <span class="comment"># 查看registry的值</span></span><br><span class="line">[&lt;function f1 at <span class="number">0x10e893b70</span>&gt;, &lt;function f2 at <span class="number">0x10e893bf8</span>&gt;]</span><br></pre></td></tr></table></figure><p>上例主要想强调，函数装饰器在导入模块时立即执行（register运行了两次，分别装饰了f1和f2），而被装饰的函数只有在明确调用时运行。这突出了导入时和运行时之间的区别。</p><p>考虑到装饰器在真实代码中的常用方式，上例有两个不寻常的地方。</p><ul><li>装饰器函数与被装饰的函数在同一个模块中定义。实际情况是，装饰器通常在一个模块中定义，然后应用到其他模块中的函数上。</li><li>register装饰器返回的函数与通过参数传入的函数相同。实际上，大多数装饰器会在内部定义一个函数，然后将其返回。</li></ul><p>虽然register装饰器原封不动地返回被装饰的函数，到那时这种技术并非没有用处。很多Python Web框架使用这样的装饰器把函数添加到某种中央注册处，例如把URL模式映射到生成HTTP响应的函数上的注册处。这种注册装饰器可能会也可能不会修改被装饰的函数。</p><h1 id="使用装饰器改进策略模式">使用装饰器改进策略模式</h1><p>回顾，支持的简单方案：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fidelity_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""为积分为1000或以上的顾客提供5%折扣"""</span></span><br><span class="line">    <span class="keyword">return</span> order.total() * <span class="number">.05</span> <span class="keyword">if</span> order.customer.fidelity &gt;= <span class="number">1000</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bulk_item_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""单个商品为20个或以上时提供10%折扣"""</span></span><br><span class="line">    discount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> order.cart:</span><br><span class="line">        <span class="keyword">if</span> item.quantity &gt;= <span class="number">20</span>:</span><br><span class="line">            discount += item.total() * <span class="number">.1</span></span><br><span class="line">    <span class="keyword">return</span> discount</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">large_order_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""订单中的不同商品达到10个或以上时提供7%折扣"""</span></span><br><span class="line">    distinct_items = &#123;item.product <span class="keyword">for</span> item <span class="keyword">in</span> order.cart&#125;</span><br><span class="line">    <span class="keyword">if</span> len(distinct_items) &gt;= <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">return</span> order.total() * <span class="number">.07</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">promos = [fidelity_promo, bulk_item_promo, large_order_promo]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""选择可用的最佳折扣"""</span></span><br><span class="line">    <span class="keyword">return</span> max(promo(order) <span class="keyword">for</span> promo <span class="keyword">in</span> promos)  <span class="comment"># 返回折扣额度最大的那个</span></span><br></pre></td></tr></table></figure><p>该方案的主要问题是，定义体中有函数的名称，但是best_promo用来判断哪个折扣幅度最大的promos列表中也有函数名称。这种重复是个问题，因为新增策略函数后可能会忘记把它添加到promos列表中，导致best_promo忽略新策略，而不报错，为系统引入了不易察觉的缺陷。下面使用注册装饰器解决这个问题。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">promos = []  <span class="comment"># 列表起初是空的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">promotion</span><span class="params">(promo_func)</span>:</span></span><br><span class="line">    promos.append(promo_func)  <span class="comment"># 添加到promos列表中</span></span><br><span class="line">    <span class="keyword">return</span> promo_func  <span class="comment"># 原封不动返回</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@promotion  # 装饰策略</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fidelity_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""为积分为1000或以上的顾客提供5%折扣"""</span></span><br><span class="line">    <span class="keyword">return</span> order.total() * <span class="number">.05</span> <span class="keyword">if</span> order.customer.fidelity &gt;= <span class="number">1000</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@promotion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bulk_item_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""单个商品为20个或以上时提供10%折扣"""</span></span><br><span class="line">    discount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> order.cart:</span><br><span class="line">        <span class="keyword">if</span> item.quantity &gt;= <span class="number">20</span>:</span><br><span class="line">            discount += item.total() * <span class="number">.1</span></span><br><span class="line">    <span class="keyword">return</span> discount</span><br><span class="line"></span><br><span class="line"><span class="meta">@promotion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">large_order_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""订单中的不同商品达到10个或以上时提供7%折扣"""</span></span><br><span class="line">    distinct_items = &#123;item.product <span class="keyword">for</span> item <span class="keyword">in</span> order.cart&#125;</span><br><span class="line">    <span class="keyword">if</span> len(distinct_items) &gt;= <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">return</span> order.total() * <span class="number">.07</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_promo</span><span class="params">(order)</span>:</span>  <span class="comment"># 不变</span></span><br><span class="line">    <span class="string">"""选择可用的最佳折扣"""</span></span><br><span class="line">    <span class="keyword">return</span> max(promo(order) <span class="keyword">for</span> promo <span class="keyword">in</span> promos)</span><br></pre></td></tr></table></figure><p>与使用globals()或用insepect找出全部策略的方案相比，使用装饰器有几个优点。</p><ul><li>促销策略函数无须使用特殊的名称（即不用以_promo结尾）。</li><li><span class="citation" data-cites="promotion装饰器突出了被装饰的函数的作用">@promotion装饰器突出了被装饰的函数的作用</span>，还便于临时禁用某个促销策略：只需把装饰器注释掉。</li><li>促销折扣策略可以在其他模块中定义，在系统中的任何地方都行，只要使用@promotion装饰即可。</li></ul><p>不过，多数装饰器会修改被装饰的函数。通常它们会定义一个内部函数，然后将其返回，替换被装饰的函数。使用内部函数的代码几乎都要靠闭包才能正确运作。</p><h1 id="变量作用域规则">变量作用域规则</h1><p>为了理解闭包，先了解Python中的变量作用域。示例 一个函数，读取一个局部变量和一个全局变量。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(a)</span>:</span></span><br><span class="line">        print(a)</span><br><span class="line">        print(b)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">3</span>, <span class="keyword">in</span> f1</span><br><span class="line">NameError: name <span class="string">'b'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">6</span>  <span class="comment"># 先给全局变量b赋值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">3</span>)  <span class="comment"># 再调用就不会出错</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p>下面看一个可能会让你吃惊的示例。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(a)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(a)</span><br><span class="line"><span class="meta">... </span>    print(b)</span><br><span class="line"><span class="meta">... </span>    b = <span class="number">9</span>  <span class="comment"># 由于给变量b赋值，编译器将b归类为局部变量</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2(<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span>  <span class="comment"># print(a)执行了</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">3</span>, <span class="keyword">in</span> f2</span><br><span class="line">UnboundLocalError: local variable <span class="string">'b'</span> referenced before assignment  <span class="comment"># 局部变量'b'未定义</span></span><br></pre></td></tr></table></figure><p>Python编译函数的定义体时，它判断b是局部变量，因为在函数中给它赋值了。生成的字节码（可以用dis.dis(f2)查看f2的字节码）证实了这种判断，Python会尝试从本地环境获取b。后面调用f2(3)时，f2的定义体会获取并打印局部变量a的值，但是尝试获取局部变量b的值时，发现b没有绑定值。</p><p>这不是缺陷，而是设计选择：Python不要求声明变量，但是假定在函数定义体中赋值的变量是局部变量。JavaScript也不要求声明变量，但是如果忘记把变量声明为局部变量（使用var），可能会在不知情的情况下获取全局变量。</p><p>如果在函数中赋值时想让解释器把b当成全局变量，要使用global声明。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">(a)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">global</span> b</span><br><span class="line"><span class="meta">... </span>    print(a)</span><br><span class="line"><span class="meta">... </span>    print(b)</span><br><span class="line"><span class="meta">... </span>    b = <span class="number">9</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f3(<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f3(<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><h1 id="闭包">闭包</h1><p>在函数内部定义函数不常见，直到开始使用匿名函数才会这样做。而且，只有涉及嵌套函数时才有闭包问题。其实，闭包指延伸了作用域的函数，其中包括函数定义体中引用、但是不在定义体中定义的非全局变量。函数是不是匿名的没有关系，关键是它能访问定义体之外定义的非全局变量。</p><p>假如有个名为avg的函数，它的作用是计算不断增加的系列值的均值。例如，整个历史中某个商品的平均收盘价。每天都会增加新价格，因此平均值要考虑至目前为止所有的价格。起初，avg是这样使用的：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">10</span>)</span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">11</span>)</span><br><span class="line"><span class="number">10.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">12</span>)</span><br><span class="line"><span class="number">11.0</span></span><br></pre></td></tr></table></figure><p>avg从何而来，它又在哪里保存历史值呢？下面看两种实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Averager</span><span class="params">()</span>:</span>  <span class="comment"># 使用类实现</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.series = []</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, new_value)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.series.append(new_value)</span><br><span class="line"><span class="meta">... </span>        total = sum(self.series)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> total / len(self.series)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg = Averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">1</span>)</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg = Averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">10</span>)</span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">11</span>)</span><br><span class="line"><span class="number">10.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">12</span>)</span><br><span class="line"><span class="number">11.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.series  <span class="comment"># 历史值保存在实例的series属性中</span></span><br><span class="line">[<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span>  <span class="comment"># 函数式实现</span></span><br><span class="line"><span class="meta">... </span>    series = []  <span class="comment"># series是make_averager的局部变量</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line"><span class="meta">... </span>        series.append(new_value)  <span class="comment"># 访问了定义体之外的局部变量</span></span><br><span class="line"><span class="meta">... </span>        total = sum(series)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> total / len(series)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> averager</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg = make_averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">10</span>)</span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">11</span>)</span><br><span class="line"><span class="number">10.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">12</span>)</span><br><span class="line"><span class="number">11.0</span></span><br></pre></td></tr></table></figure><p>函数式实现中的avg函数在哪里寻找series呢？注意，series是make_averager函数的局部变量，因为那个函数的定义体中初始化了series。可是，调用avg(10)时，make_averager函数已经返回了，而它的本地作用域也一去不复返了。</p><p>在averager函数中，series是自由变量（free variable），这是一个技术术语，指未在本地作用域中绑定的变量（series的绑定发生在make_averager定义体中）。</p><p><img src="/uploads/image/fluent-python/closure-and-free-variable.png"></p><p>averager的闭包延伸到那个函数的作用域之外，包含自由变量series的绑定。审查返回的averager对象：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__code__.co_varnames</span><br><span class="line">(<span class="string">'new_value'</span>, <span class="string">'total'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__code__.co_freevars</span><br><span class="line">(<span class="string">'series'</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__closure__</span><br><span class="line">(&lt;cell at <span class="number">0x106562738</span>: list object at <span class="number">0x10658fd48</span>&gt;,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__closure__[<span class="number">0</span>].cell_contents</span><br><span class="line">[<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]</span><br></pre></td></tr></table></figure><p>综上，闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时，虽然定义作用域不可用了，但是仍能使用那些绑定。注意，只有嵌套在其他函数中的函数（本例的averager函数）才可能需要处理不在全局作用域中的外部变量（本例的series）。</p><h1 id="nonlocal声明">nonlocal声明</h1><p>在上例中，我们把所有值存储在历史数列中，然后在每次调用averager时使用sum求和。更好的实现方式是，只存储目前的总值和元素个数，然后使用这两个数计算均值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    count = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    total = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line"><span class="meta">... </span>        count += <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>        total += new_value</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> total / count</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> averager</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg = make_averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">10</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">5</span>, <span class="keyword">in</span> averager</span><br><span class="line">UnboundLocalError: local variable <span class="string">'count'</span> referenced before assignment</span><br></pre></td></tr></table></figure><p>为什么想象中的自由变量count会变成局部变量呢？</p><p><strong>问题是，当count是任何不可变类型（数字、字符串、元组等）时，count += 1语句的作用其实与count = count + 1一样。因此，在averager定义体中为count赋值了，这会把count变成局部变量。total变量也受这个问题影响。</strong></p><p><strong>对不可变类型来说，只能读取，不能更新。如果尝试重新绑定，例如count = count + 1，其实会隐式创建局部变量count。这样，count就不是自由变量，因此不会保存在闭包中。</strong></p><p>Python3引入了nonlocal声明。它的作用是把变量标记为自由变量，即使在函数中为变量赋予新值了，也会变成自由变量。如果为nonlocal声明的变量赋予新值，闭包中保存的绑定会更新。使用nonlocal修正后的函数如下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> count, total</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        total += new_value</span><br><span class="line">        <span class="keyword">return</span> total / count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> decorators </tag>
            
            <tag> Fluent Python </tag>
            
            <tag> strategy </tag>
            
            <tag> closures </tag>
            
            <tag> global </tag>
            
            <tag> nonlocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SOLID设计原则</title>
      <link href="/notes/the-art-of-design-patterns/solid-design-principles/"/>
      <url>/notes/the-art-of-design-patterns/solid-design-principles/</url>
      
        <content type="html"><![CDATA[<h1 id="solid">SOLID</h1><p>在程序设计领域，SOLID是五种常用原则的首字母缩写。《设计模式的艺术》一书还列出了另外两种（表格最后两行）原则。</p><table><thead><tr class="header"><th>首字母</th><th>名称</th><th>定义</th></tr></thead><tbody><tr class="odd"><td>S</td><td>单一职责原则（Single Responsibility Principle）</td><td>一个类只负责一个功能领域中的相应职责</td></tr><tr class="even"><td>O</td><td>开闭原则（Open-Closed Principle）</td><td>软件实体应对扩展开放，而对修改关闭</td></tr><tr class="odd"><td>L</td><td>里氏代换原则（Liskov Substitution Principle）</td><td>所有引用基类对象的地方能够透明地使用其子类的对象</td></tr><tr class="even"><td>I</td><td>接口隔离原则（Interface Segregation Principle）</td><td>使用多个专门的接口，而不使用单一的总接口</td></tr><tr class="odd"><td>D</td><td>依赖反转原则（Dependence Inversion Principle）</td><td>抽象不应该依赖于细节，细节应该依赖于抽象</td></tr><tr class="even"><td></td><td>合成复用原则（Composite Reuse Principle）</td><td>尽量使用对象组合，而不是继承来达到复用的目的</td></tr><tr class="odd"><td></td><td>迪米特法则（Law of Demeter）</td><td>一个软件实体应当尽可能少地与其他实体发生相互作用</td></tr></tbody></table><a id="more"></a><h1 id="单一职责原则">单一职责原则</h1><blockquote><p>一个类只负责一个功能领域中的相应职责。或者定义为：就一个类而言，应该只有一个引起它变化的原因。</p></blockquote><p>单一职责原则用于控制类的粒度。在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，要将这些职责进行分离，将不同的职责封装在不同的类中。</p><h1 id="开闭原则">开闭原则</h1><blockquote><p>一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。</p></blockquote><p>软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时，具备较好的稳定性和延续性。</p><p>为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。</p><h1 id="里氏代换原则">里氏代换原则</h1><blockquote><p>所有引用基类（父类）的地方必须能透明地使用其子类的对象。</p></blockquote><p>里氏代换原则表明，在软件中将一个基类对象替换成它的子类对象，程序不会产生任何错误和异常，反过来则不成立。这是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中应尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</p><h1 id="接口隔离原则">接口隔离原则</h1><blockquote><p>使用多个专门的接口，而不使用单一的总接口，客户端不应该依赖那些它不需要的接口。</p></blockquote><p>每一个接口应该承担一种相对独立的角色。这里的“接口”有两种不同的含义，对于这两种不同的含义，ISP的表达方式以及含义都有所不同。</p><ol type="1"><li>当把”接口“理解成一个类型所提供的所有方法特征的集合时，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做”角色隔离原则”。</li><li>如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便。为了使接口的职责单一，需要将大接口重的方法根据其职责不同分别放在不同的小接口中。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“定制服务”，即为不同的客户端提供宽窄不同的接口。</li></ol><p>在使用接口隔离原则时，需要注意控制接口的粒度，接口不能太小，太小会导致系统中接口泛滥，不利于维护；也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来不方便。一般而言，接口中仅包含为某一类用户定制的方法即可。</p><h1 id="依赖反转原则">依赖反转原则</h1><blockquote><p>抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。</p></blockquote><p>如果说开闭原则是面向对象设计的目标的话，那么依赖反转原则就是面向对象设计的主要实现机制之一，它是系统抽象化的具体实现。</p><p>依赖反转原则要求在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要使用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，因为无法调用到在子类中增加的新方法。</p><p>在实现依赖反转原则时，需要针对抽象层编程，而将具体类的对象通过<strong>依赖注入</strong>（Dependency Injection，DI）的方式注入到其他对象中。依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有3中：构造注入、设值注入和接口注入。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过实现接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象覆盖父类对象。</p><h1 id="合成复用原则">合成复用原则</h1><blockquote><p>尽量使用对象组合，而不是继承来达到复用的目的。</p></blockquote><p>在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过关联（包括组合和聚合）关系或通过继承，但首先应该考虑使用关联，关联可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，使用继承时，需要严格遵循里氏代换原则。</p><p>通过继承来进行复用的主要问题在于继承会破坏系统的封装行，因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性。</p><p>关联关系可以将已有的对象纳入到新对象中，使之称为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见，所以这种复用又称为“黑箱”复用。相对于继承关系而言，其耦合度较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用成员对象的操作。合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。</p><p>一般而言，如果两个类之间是“Has-A”的关系，应使用组合或聚合，如果是“Is-A”的关系，可使用继承。</p><h1 id="迪米特法则">迪米特法则</h1><blockquote><p>一个软件实体应当尽可能少地与其他实体发生相互作用。</p></blockquote><p>如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易。这是对软件实体之间通信的限制。迪米特法则要求限制软件实体之间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。</p><p>在迪米特法则中，对于一个对象，其”朋友“包括以下几类：</p><ol type="1"><li>当前对象本身（this）。</li><li>以参数形式传入到当前对象方法中的对象。</li><li>当前对象的成员对象。</li><li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友。</li><li>当前对象所创建的对象。</li></ol><p>任何一个对象，如果满足上面的条件之一，就是当前对象的”朋友“，否则就是”陌生人“。在应用迪米特法则时，一个对象只能与直接“朋友”发生交互，不要与“陌生人“发生直接交互，这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。</p><p>迪米特法则要求在设计系统时，应该尽量减少对象之间的交互。如果一个对象需要调用另一个对象的方法，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> design patterns </tag>
            
            <tag> The Art of Design Patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML类图</title>
      <link href="/documentation/uml-class-diagram/"/>
      <url>/documentation/uml-class-diagram/</url>
      
        <content type="html"><![CDATA[<p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html" target="_blank" rel="noopener">看懂UML类图和时序图</a></p><p><a href="https://plantuml.com/zh/class-diagram" target="_blank" rel="noopener">类图的语法和功能</a></p><h1 id="从一个示例开始">从一个示例开始</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title 示例</span><br><span class="line">abstract 车 &lt;&lt;abstract&gt;&gt;</span><br><span class="line">hide empty fields</span><br><span class="line">hide empty methods</span><br><span class="line">小汽车 .up.|&gt; 车 : 实现</span><br><span class="line">自行车 .up.|&gt; 车 : 实现</span><br><span class="line">SUV -left-|&gt; 小汽车 : 泛化</span><br><span class="line">小汽车 “1” *-down- “4” 轮胎 : 组合</span><br><span class="line">小汽车 “1” *-down- “1” 发动机 : 组合</span><br><span class="line">学生 .right.&gt; 自行车 : 依赖</span><br><span class="line">班级 “1” -up-o “many” 学生 : 聚合</span><br><span class="line">学生 “1” -down- “1” 身份证 : 关联</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><img src="http://www.plantuml.com/plantuml/svg/AyaioKbLUBvarvDztLo9ISKbHOd99GelzYvJiB61SUtik38oKr8LKdCBIYeLSbDparABk9vkw7-sSIz8eLvfWLwD7LYFbSBJTVEUzstWUj6-wiN27boomQ5X2hevgMabka0PX45M2iysptxQCmt9x4SDSmmVDSnLqD9DoI_FqmNnJK3y5tlNlMZk0-fulhlbwOGE_3h0_AVz4vzshNWsPnUIfhNBda-Phw1Nb9cUKQ87T2FSqLOAJ_RDVR5r6jVp_hNFTos76w9RMg2R3-Bb9kPLWas5666byA9n5fAHSFMeRdYnQ_MJtNjVh6y41KNhvXUDKm00"><ul><li>小汽车与自行车和抽象类车之间的关系为<strong>实现</strong>关系，使用带空心箭头的虚线表示。</li><li>小汽车与SUV之间的关系是<strong>泛化</strong>关系，使用带空心箭头的实线表示。</li><li>小汽车与发动机、轮胎之间是<strong>组合</strong>关系，使用带实心箭头的实线表示。</li><li>学生与班级之间是<strong>聚合</strong>关系，使用带空心箭头的实线表示。</li><li>学生与身份证之间是<strong>关联</strong>关系，使用一根实线表示。</li><li>学生上学需要用到自行车，与自行车是一种<strong>依赖</strong>关系，使用带箭头的虚线表示。</li></ul><a id="more"></a><h1 id="类之间的关系">类之间的关系</h1><h2 id="泛化和实现">泛化和实现</h2><p>泛化关系（generalization）：最终代码中，泛化关系表现为继承非抽象类或实现接口（需要编程语言支持）。</p><p>实现关系（realize）： 最终代码中，实现关系表现为继承抽象类。</p><h2 id="聚合和组合">聚合和组合</h2><p>聚合关系（aggregation）：表示整体由部分构成，与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在。例如，部门撤销了，人员不会消失，他们依然存在。</p><p>组合关系（composition）：组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了。例如，公司不存在了，部门也将不存在了。</p><h2 id="关联和依赖">关联和依赖</h2><p>关联关系（association）：描述不同类的对象之间的结构关系，它是一种静态关系，通常与运行状态无关，一般由常识等因素决定。关联关系是一种“强关联”的关系。比如，乘车人和车票、学生与学校之间就是一种关联关系。关联关系默认不强调方向，表示对象相互知道。在最终代码中，关联对象通常是以成员变量的形式实现的。</p><p>依赖关系（dependency）：描述一个对象在运行期间会用到另一个对象。与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化，依赖关系也可能发生变化。显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单项依赖，杜绝双向依赖的产生。在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，使用对方的方法和属性。</p>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UML </tag>
            
            <tag> plantuml </tag>
            
            <tag> design patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式一览</title>
      <link href="/notes/the-art-of-design-patterns/overview-of-design-patterns/"/>
      <url>/notes/the-art-of-design-patterns/overview-of-design-patterns/</url>
      
        <content type="html"><![CDATA[<blockquote><p>符合模式并不表示做得对。——Ralph Johnson</p><p>经典的《设计模式：可复用面性对象软件的基础》的作者之一</p></blockquote><blockquote><p>虽然设计模式与语言无关，但这并不意味着每一个模式都能在每一门语言中使用。1996年，Peter Norvig在题为“<a href="http://norvig.com/design-patterns/" target="_blank" rel="noopener">Design Patterns in Dynamic Languages</a>”的演讲中指出，Gamma等人合著的《设计模式：可复用面向对象软件的基础》一书中有23个模式，其中有16个在动态语言中“不见了，或者简化了”（参见第9张幻灯片）。他讨论的是Lisp和Dylan，不过很多相关的动态特性在Python中也能找到。</p><p>——流畅的Python，第6章</p></blockquote><h1 id="设计模式是什么">设计模式是什么</h1><p>设计模式的一般定义如下：</p><p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。</p><a id="more"></a><p>狭义的设计模式是指GoF在《设计模式：可复用面性对象软件的基础》一书中所介绍的23种经典设计模式。不过设计模式并不仅仅只有这23种。</p><p>一般而言，一个模式有四个基本要素：</p><ol type="1"><li>模式名称（pattern name）：通过一两个词来为模式命名，以便我们更好地理解模式并方便开发人员之间交流。</li><li>问题（problem）：描述了应该在何时使用模式，它包含了设计中存在的问题以及问题存在的原因。</li><li>解决方案（solution）：描述了一个设计模式的组成部分，以及这些组成部分之间的相互关系、各自的职责和协作方式，通常解决方案通过UML类图和核心代码进行描述。</li><li>效果（consequences）：描述了模式的优缺点以及在使用模式时应权衡的问题。</li></ol><h1 id="组织编目">组织编目</h1><table><tr><th colspan="2" rowspan="2"></th><th colspan="3">目的</th></tr><tr><th>创建型</th><th>结构型</th><th>行为型</th></tr><tr><th rowspan="2">范围</th><th>类</th><td>工厂方法</td><td>适配器（类）</td><td>解释器<br>模板方法</td></tr><tr><th>对象</th><td>抽象工厂<br>生成器<br>原型<br>单例</td><td>适配器（对象）<br>桥接<br>组成<br>装饰<br>外观<br>享元<br>代理</td><td>职责链<br>命令<br>迭代器<br>中介者<br>观察者<br>状态<br>策略<br>访问者</td></tr></table><p>根据两条准则对模式进行分类。第一是目的准则，即模式是用来完成什么工作的。依据其目的可分为创建型（creational）、结构型（structural）或行为型（behavioral）三种。创建型模式与对象的创建有关；结构型模式处理类或对象的组合；行为型模式对类或对象怎样交互和怎样分配职责进行描述。</p><p>第二准则是范围，指定模式主要是用于类还是用于对象。类模式处理类和子类之间的关系，这些关系通过继承建立，是静态的，在编译时刻便确定下来了。对象模式处理对象间的关系，这些关系在运行时刻是可以变化的，更具动态性。从某种意义上来说，几乎所有模式都适用继承机制，所以”类模式“只指那些集中于处理类间关系的模式，而大部分模式都属于对象模式的范畴。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> design patterns </tag>
            
            <tag> The Art of Design Patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用一等函数实现设计模式</title>
      <link href="/notes/fluent-python/design-patterns-with-first-class-functions/"/>
      <url>/notes/fluent-python/design-patterns-with-first-class-functions/</url>
      
        <content type="html"><![CDATA[<p>虽然设计模式与语言无关，但这并不意味着每一个模式都能在每一门语言中使用。1996年，Peter Norvig在题为“<a href="http://norvig.com/design-patterns/" target="_blank" rel="noopener">Design Patterns in Dynamic Languages</a>”的演讲中指出，Gamma等人合著的《设计模式：可复用面向对象软件的基础》一书中有23个模式，其中有16个在动态语言中“不见了，或者简化了”（参见第9张幻灯片）。他讨论的是Lisp和Dylan，不过很多相关的动态特性在Python中也能找到。</p><p>具体而言，Norvig建议在有一等函数的语言中重新审视策略、命令、模板方法和访问者模式。通常，我们可以把这些模式中涉及的某些类的实例替换成简单的函数，从而减少样板代码。</p><h1 id="重构策略模式">重构策略模式</h1><h2 id="经典的策略模式">经典的策略模式</h2><p>《设计模式：可复用面向对象软件的基础》一书是这样概率策略模式的：定义一系列算法，把它们一一封装起来，并且使它们可以相互替换。本模式使得算法可以独立于使用它的客户而变化。</p><a id="more"></a><p>电商领域有个功能明显可以使用策略模式，根据客户的属性或订单中的商品计算折扣。假如一个网店制定了下述折扣规则。</p><ul><li>有1000或以上积分的顾客，每个订单享5%折扣。</li><li>同一订单中，单个商品的数量达到20个或以上，享10%折扣。</li><li>订单中的不同商品达到10个或以上，享7%折扣。</li></ul><p>简单起见，假定一个订单一次只能享用一个折扣。</p><img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYIiv9B2vMy2zAIIrIgEPI08AI_9B470rDC3kbD1N8gkLAJ2ekAKfCBb48AChFpI_9pC-3Agw6oTGgf6GM9-UNvfM0DK2CTGDQbvDPKWdM1TM1HPbJQKwsPqbgBW5bFeb5wQbWb-9K2F57lYx2dLm85zlKwEgYEWbT4iKXw99erdFbvPUaAYWzsT7rP4VtisdjIWg9nGfvXb3XvskdFP-w529c11LxshhzoTx9o3B6N7c62df5cUaP9NgGEE3ACrBGoqbD0_8HNa0DHZqza4RKC8E8eGSGM1G0"><p>上下文：把一些计算委托给实现不同算法的可互换组建，它提供服务。在这个电商示例中，上下文是Order，它会根据不同的算法计算促销折扣。</p><p>策略：实现不同算法的组件共同的接口。</p><p>具体策略：策略的具体子类。</p><p>按照《设计模式：可复用面向对象软件的基础》一书的说明，具体策略由上下文类的客户选择。在这个示例中，实例化订单之前，系统会以某种方式选择一种促销折扣策略，然后把它传给Order构造方法。具体怎么选择策略，不在这个模式的职责范围内。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Customer = namedtuple(<span class="string">'Customer'</span>, <span class="string">'name fidelity'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, product, quantity, price)</span>:</span></span><br><span class="line">        self.product = product</span><br><span class="line">        self.quantity = quantity</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.price * self.quantity</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span>  <span class="comment"># 上下文</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, customer, cart, promotion=None)</span>:</span></span><br><span class="line">        self.customer = customer</span><br><span class="line">        self.cart = list(cart)</span><br><span class="line">        self.promotion = promotion</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">'__total'</span>):</span><br><span class="line">            self.__total = sum(item.total() <span class="keyword">for</span> item <span class="keyword">in</span> self.cart)</span><br><span class="line">        <span class="keyword">return</span> self.__total</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">due</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.promotion <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            discount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            discount = self.promotion.discount(self)</span><br><span class="line">        <span class="keyword">return</span> self.total() - discount</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        fmt = <span class="string">'&lt;Order total: &#123;:.2f&#125; due: &#123;:.2f&#125;&gt;'</span></span><br><span class="line">        <span class="keyword">return</span> fmt.format(self.total(), self.due())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promotion</span><span class="params">(ABC)</span>:</span>  <span class="comment"># 策略:抽象基类</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">discount</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="string">"""返回折扣金额(正值)"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FidelityPromo</span><span class="params">(Promotion)</span>:</span>  <span class="comment"># 第一个具体策略</span></span><br><span class="line">    <span class="string">"""为积分为1000或以上的顾客提供5%折扣"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">discount</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> order.total() * <span class="number">.05</span> <span class="keyword">if</span> order.customer.fidelity &gt;= <span class="number">1000</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BulkItemPromo</span><span class="params">(Promotion)</span>:</span>  <span class="comment"># 第二个具体策略</span></span><br><span class="line">    <span class="string">"""单个商品为20个或以上时提供10%折扣"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">discount</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        discount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> order.cart:</span><br><span class="line">            <span class="keyword">if</span> item.quantity &gt;= <span class="number">20</span>:</span><br><span class="line">                discount += item.total() * <span class="number">.1</span></span><br><span class="line">        <span class="keyword">return</span> discount</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LargeOrderPromo</span><span class="params">(Promotion)</span>:</span>  <span class="comment"># 第三个具体策略</span></span><br><span class="line">    <span class="string">"""订单中的不同商品达到10个或以上时提供7%折扣"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">discount</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        distinct_items = &#123;item.product <span class="keyword">for</span> item <span class="keyword">in</span> order.cart&#125;</span><br><span class="line">        <span class="keyword">if</span> len(distinct_items) &gt;= <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> order.total() * <span class="number">.07</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>Promotion定义为抽象基类（Abstract Base Class, ABC），这么做是为了使用@abstractmethod装饰器，从而明确表明所用的模式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>joe = Customer(<span class="string">'John Doe'</span>, <span class="number">0</span>)  <span class="comment"># joe积分为0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ann = Customer(<span class="string">'Ann Smith'</span>, <span class="number">1100</span>)  <span class="comment"># ann积分1100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cart = [LineItem(<span class="string">'banana'</span>, <span class="number">4</span>, <span class="number">.5</span>),</span><br><span class="line"><span class="meta">... </span>        LineItem(<span class="string">'apple'</span>, <span class="number">10</span>, <span class="number">1.5</span>),</span><br><span class="line"><span class="meta">... </span>        LineItem(<span class="string">'watermellon'</span>, <span class="number">5</span>, <span class="number">5.0</span>)]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(joe, cart, FidelityPromo())  <span class="comment"># joe不享折扣</span></span><br><span class="line">&lt;Order total: <span class="number">42.00</span> due: <span class="number">42.00</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(ann, cart, FidelityPromo())  <span class="comment"># ann享有5%积分折扣</span></span><br><span class="line">&lt;Order total: <span class="number">42.00</span> due: <span class="number">39.90</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>banana_cart = [LineItem(<span class="string">'banana'</span>, <span class="number">30</span>, <span class="number">.5</span>),</span><br><span class="line"><span class="meta">... </span>               LineItem(<span class="string">'apple'</span>, <span class="number">10</span>, <span class="number">1.5</span>)]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(joe, banana_cart, BulkItemPromo())  <span class="comment"># 香蕉个数超过20个，香蕉享10%折扣</span></span><br><span class="line">&lt;Order total: <span class="number">30.00</span> due: <span class="number">28.50</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>long_order = [LineItem(str(item_code), <span class="number">1</span>, <span class="number">1.0</span>) <span class="keyword">for</span> item_code <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(joe, long_order, LargeOrderPromo())  <span class="comment"># long_order不同商品达到10个，享7%折扣</span></span><br><span class="line">&lt;Order total: <span class="number">10.00</span> due: <span class="number">9.30</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(joe, cart, LargeOrderPromo())  <span class="comment"># cart不同商品有3个，不能享折扣</span></span><br><span class="line">&lt;Order total: <span class="number">42.00</span> due: <span class="number">42.00</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="使用函数实现策略模式">使用函数实现策略模式</h2><p>在上述示例中，每个具体策略都是一个类，而且都只定义了一个方法，即discount。此外，策略实例没有状态（没有实例属性）。它们看起来像是普通的函数——的确如此。下面是对示例的重构，把具体策略换成了简单的函数，而且去掉了Promo抽象类。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Customer = namedtuple(<span class="string">'Customer'</span>, <span class="string">'name fidelity'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, product, quantity, price)</span>:</span></span><br><span class="line">        self.product = product</span><br><span class="line">        self.quantity = quantity</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.price * self.quantity</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span>  <span class="comment"># 上下文</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, customer, cart, promotion=None)</span>:</span></span><br><span class="line">        self.customer = customer</span><br><span class="line">        self.cart = list(cart)</span><br><span class="line">        self.promotion = promotion</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">'__total'</span>):</span><br><span class="line">            self.__total = sum(item.total() <span class="keyword">for</span> item <span class="keyword">in</span> self.cart)</span><br><span class="line">        <span class="keyword">return</span> self.__total</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">due</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.promotion <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            discount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            discount = self.promotion(self)  <span class="comment"># 计算折扣只需调用self.promotion()函数</span></span><br><span class="line">        <span class="keyword">return</span> self.total() - discount</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        fmt = <span class="string">'&lt;Order total: &#123;:.2f&#125; due: &#123;:.2f&#125;&gt;'</span></span><br><span class="line">        <span class="keyword">return</span> fmt.format(self.total(), self.due())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 无抽象类</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fidelity_promo</span><span class="params">(order)</span>:</span>  <span class="comment"># 各个策略都是函数</span></span><br><span class="line">    <span class="string">"""为积分为1000或以上的顾客提供5%折扣"""</span></span><br><span class="line">    <span class="keyword">return</span> order.total() * <span class="number">.05</span> <span class="keyword">if</span> order.customer.fidelity &gt;= <span class="number">1000</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bulk_item_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""单个商品为20个或以上时提供10%折扣"""</span></span><br><span class="line">    discount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> order.cart:</span><br><span class="line">        <span class="keyword">if</span> item.quantity &gt;= <span class="number">20</span>:</span><br><span class="line">            discount += item.total() * <span class="number">.1</span></span><br><span class="line">    <span class="keyword">return</span> discount</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">large_order_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""订单中的不同商品达到10个或以上时提供7%折扣"""</span></span><br><span class="line">    distinct_items = &#123;item.product <span class="keyword">for</span> item <span class="keyword">in</span> order.cart&#125;</span><br><span class="line">    <span class="keyword">if</span> len(distinct_items) &gt;= <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">return</span> order.total() * <span class="number">.07</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>新的Order类使用起来更简单。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>joe = Customer(<span class="string">'John Doe'</span>, <span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ann = Customer(<span class="string">'Ann Smith'</span>, <span class="number">1100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cart = [LineItem(<span class="string">'banana'</span>, <span class="number">4</span>, <span class="number">.5</span>),</span><br><span class="line"><span class="meta">... </span>        LineItem(<span class="string">'apple'</span>, <span class="number">10</span>, <span class="number">1.5</span>),</span><br><span class="line"><span class="meta">... </span>        LineItem(<span class="string">'watermellon'</span>, <span class="number">5</span>, <span class="number">5.0</span>)]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(joe, cart, fidelity_promo)  <span class="comment"># 没必要实例化对象，把函数作为参数传入</span></span><br><span class="line">&lt;Order total: <span class="number">42.00</span> due: <span class="number">42.00</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(ann, cart, fidelity_promo)</span><br><span class="line">&lt;Order total: <span class="number">42.00</span> due: <span class="number">39.90</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>banana_cart = [LineItem(<span class="string">'banana'</span>, <span class="number">30</span>, <span class="number">.5</span>),</span><br><span class="line"><span class="meta">... </span>               LineItem(<span class="string">'apple'</span>, <span class="number">10</span>, <span class="number">1.5</span>)]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(joe, banana_cart, bulk_item_promo)</span><br><span class="line">&lt;Order total: <span class="number">30.00</span> due: <span class="number">28.50</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>long_order = [LineItem(str(item_code), <span class="number">1</span>, <span class="number">1.0</span>) <span class="keyword">for</span> item_code <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(joe, long_order, large_order_promo)</span><br><span class="line">&lt;Order total: <span class="number">10.00</span> due: <span class="number">9.30</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(joe, cart, large_order_promo)</span><br><span class="line">&lt;Order total: <span class="number">42.00</span> due: <span class="number">42.00</span>&gt;</span><br></pre></td></tr></table></figure><p>至此，我们使用函数实现了策略模式，由此也出现了其他可能性。假设我们想创建一个“元策略”，让它为指定的订单选择最佳折扣。</p><h2 id="选择最佳策略简单的方式">选择最佳策略：简单的方式</h2><p>best_promo函数的实现特别简单：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">promos = [fidelity_promo, bulk_item_promo, large_order_promo]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""选择可用的最佳折扣"""</span></span><br><span class="line">    <span class="keyword">return</span> max(promo(order) <span class="keyword">for</span> promo <span class="keyword">in</span> promos)  <span class="comment"># 返回折扣额度最大的那个</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(joe, long_order, best_promo)  <span class="comment"># 订购多种商品时，选择larger_order_promo</span></span><br><span class="line">&lt;Order total: <span class="number">10.00</span> due: <span class="number">9.30</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(joe, banana_cart, best_promo)  <span class="comment"># 订购大量香蕉时，选择bulk_item_promo</span></span><br><span class="line">&lt;Order total: <span class="number">30.00</span> due: <span class="number">28.50</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(ann, cart, best_promo)  <span class="comment"># 为忠实顾客ann提供fidelity_promo优惠的折扣</span></span><br><span class="line">&lt;Order total: <span class="number">42.00</span> due: <span class="number">39.90</span>&gt;</span><br></pre></td></tr></table></figure><p>虽然上述示例可用，而且易读，但是有些重复可能会导致不易察觉的缺陷：若想添加新的促销策略，要定义相应的函数，还要记得把它添加到promos列表中；否则，当新促销函数显式地作为参数传给Order时，它是可用的，但是best_promo不会考虑它。继续往下读，了解这个问题的几种解决方案。</p><h2 id="找出模块中的全部策略">找出模块中的全部策略</h2><p>在Python中，模块也是一等对象，而且标准库提供了几个处理模块的函数。</p><blockquote><p><code>globals()</code></p><p>返回一个字典，表示当前的全局符号表。这个符号表始终针对当前模块（对函数或方法来说，是指定义它们的模块，而不是调用它们的模块）。</p></blockquote><p>示例：使用globals函数帮助best_promo自动找到其他可用的*_promo函数，过程优点曲折。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">promos = [globals()[name] <span class="keyword">for</span> name <span class="keyword">in</span> globals()</span><br><span class="line">          <span class="keyword">if</span> name.endswith(<span class="string">'_promo'</span>)</span><br><span class="line">          <span class="keyword">and</span> name != <span class="string">'best_promo'</span>]  <span class="comment"># 过滤掉best_promo自身，防止无限递归</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""选择可用的最佳折扣"""</span></span><br><span class="line">    <span class="keyword">return</span> max(promo(order) <span class="keyword">for</span> promo <span class="keyword">in</span> promos)</span><br></pre></td></tr></table></figure><p>收集所有可用促销的另一种方法是，在一个单独的模块中保存所有策略函数，把best_promo排除在外。</p><figure class="highlight python"><figcaption><span>promotions.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fidelity_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""为积分为1000或以上的顾客提供5%折扣"""</span></span><br><span class="line">    <span class="keyword">return</span> order.total() * <span class="number">.05</span> <span class="keyword">if</span> order.customer.fidelity &gt;= <span class="number">1000</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bulk_item_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""单个商品为20个或以上时提供10%折扣"""</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">large_order_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""订单中的不同商品达到10个或以上时提供7%折扣"""</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> promotions</span><br><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">promos = [func <span class="keyword">for</span> name, func <span class="keyword">in</span> inspect.getmembers(promotions, inspect.isfunction)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""选择可用的最佳折扣"""</span></span><br><span class="line">    <span class="keyword">return</span> max(promo(order) <span class="keyword">for</span> promo <span class="keyword">in</span> promos)</span><br></pre></td></tr></table></figure><p>不管怎么命名策略函数，上述示例都可用。唯一重要的是，promotions模块只能包含计算订单折扣的函数。如果有人在promotions模块中使用不同的签名定义函数，那么best_promo函数尝试将其应用到订单上时会出错。可以添加更为严格的测试，审查传给实例的参数，进一步过滤函数。上述示例的目的不是提供完善的方案，而是强调模块内省的一种用途。</p><p>动态收集促销折扣函数更为显式的一种方案是使用简单的装饰器。</p><h1 id="命令模式">命令模式</h1><p>命令设计模式也可以通过把函数作为参数传递而简化。</p><img src="http://www.plantuml.com/plantuml/svg/XPB1IiD054NtynMFhdIHG6kpAuBejkXUHAR9mmvqPa9c0fLQ4AJWIX3x1Q8W2EhABgH_KzD-Xed9n9cuw2plE-zov_A6B4907kjBuCW7c91mH9M2WpWUiP1g9aMbz56aX0wKJcYeuL1oJaK44mBvcnXz2ZZ6CDMuiqkcrU9nZCB5_pCdL6dS1lLfcCXjq94CKuv2Lm0J2XDzhd6iVo6pthloF3kPEx3Zk1Cx0x5AWfvhLxG5qZCz4UU3dhTVvoH_edJTxTwyqo6B8XHd2RiOwaP0rxj1EfP2QeJMzzjZThjOlxwtW2eGxKhUVDoivo-RwrafTmnzlrnzFPNQNgLbTy_P_BD6kmQTBLRB1tiX8A8Dlk-Sa-Y0NrwJoUmNpdQP-KPXsiqdTKzs7SKySFzTIiw9b59z4CrcHF03"><p>菜单驱动的文本编辑器的UML类图，使用命令设计模式实现。各个命令可以有不同的接收者（实现操作的对象）。对PasteCommand来说，接收者是Document。对OpenCommand来说，接收者是应用程序。</p><p>命令模式的目的是解耦调用操作对象（调用者）和提供实现的对象（接收者）。这个模式的做法是，在二者之间放一个Command对象，让它实现只有一个方法（execute）的接口，调用接收者中的方法执行所需的操作。这样，调用者无需了解接收者的接口，而且不同的接收者可以适应不同的Command子类。调用者有一个具体的命令，通过调用execute方法执行。MacroCommand可能保存一系列命令，它的execute()方法会在各个命令上调用相同的方法。</p><p>我们可以不为调用者提供一个Command实例，而是给它一个函数。此时，调用者不用调用command.execute()，直接调用command()即可。MacroCommand可以实现成定义了<code>__call__</code>方法的类。这样，MacroCommand的实例就是可调用对象，各自维护着一个函数列表，供以后调用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MacroCommand</span>:</span></span><br><span class="line">    <span class="string">"""一个执行一组命令的命令"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, commands)</span>:</span></span><br><span class="line">        self.commands = list(commands)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> command <span class="keyword">in</span> self.commands:</span><br><span class="line">            command()</span><br></pre></td></tr></table></figure><p>使用一等函数对命令模式的重新审视到此结束。站在一定高度上看，这里采用的方式与策略模式所用的类似：<strong>把实现单方法接口的类的实例替换成可调用对象</strong>。毕竟，每个Python可调用对象都实现了单方法接口，这个方法就是<code>__call__</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> command </tag>
            
            <tag> design patterns </tag>
            
            <tag> Fluent Python </tag>
            
            <tag> first-class functions </tag>
            
            <tag> strategy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>networkx all simple paths</title>
      <link href="/source-code/networkx-all-simple-paths/"/>
      <url>/source-code/networkx-all-simple-paths/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><figcaption><span>simple_paths.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">all_simple_paths</span><span class="params">(G, source, target, cutoff=None)</span>:</span></span><br><span class="line">    <span class="string">"""Generate all simple paths in the graph G from source to target.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    A simple path is a path with no repeated nodes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    G : NetworkX graph</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    source : node</span></span><br><span class="line"><span class="string">       Starting node for path</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    target : nodes</span></span><br><span class="line"><span class="string">       Single node or iterable of nodes at which to end path</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    cutoff : integer, optional</span></span><br><span class="line"><span class="string">        Depth to stop the search. Only paths of length &lt;= cutoff are returned.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    path_generator: generator</span></span><br><span class="line"><span class="string">       A generator that produces lists of simple paths.  If there are no paths</span></span><br><span class="line"><span class="string">       between the source and target within the given cutoff the generator</span></span><br><span class="line"><span class="string">       produces no output.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Examples</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    This iterator generates lists of nodes::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; G = nx.complete_graph(4)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; for path in nx.all_simple_paths(G, source=0, target=3):</span></span><br><span class="line"><span class="string">        ...     print(path)</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">        [0, 1, 2, 3]</span></span><br><span class="line"><span class="string">        [0, 1, 3]</span></span><br><span class="line"><span class="string">        [0, 2, 1, 3]</span></span><br><span class="line"><span class="string">        [0, 2, 3]</span></span><br><span class="line"><span class="string">        [0, 3]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    You can generate only those paths that are shorter than a certain</span></span><br><span class="line"><span class="string">    length by using the `cutoff` keyword argument::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; paths = nx.all_simple_paths(G, source=0, target=3, cutoff=2)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; print(list(paths))</span></span><br><span class="line"><span class="string">        [[0, 1, 3], [0, 2, 3], [0, 3]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    To get each path as the corresponding list of edges, you can use the</span></span><br><span class="line"><span class="string">    :func:`networkx.utils.pairwise` helper function::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; paths = nx.all_simple_paths(G, source=0, target=3)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; for path in map(nx.utils.pairwise, paths):</span></span><br><span class="line"><span class="string">        ...     print(list(path))</span></span><br><span class="line"><span class="string">        [(0, 1), (1, 2), (2, 3)]</span></span><br><span class="line"><span class="string">        [(0, 1), (1, 3)]</span></span><br><span class="line"><span class="string">        [(0, 2), (2, 1), (1, 3)]</span></span><br><span class="line"><span class="string">        [(0, 2), (2, 3)]</span></span><br><span class="line"><span class="string">        [(0, 3)]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Pass an iterable of nodes as target to generate all paths ending in any of several nodes::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; G = nx.complete_graph(4)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; for path in nx.all_simple_paths(G, source=0, target=[3, 2]):</span></span><br><span class="line"><span class="string">        ...     print(path)</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">        [0, 1, 2]</span></span><br><span class="line"><span class="string">        [0, 1, 2, 3]</span></span><br><span class="line"><span class="string">        [0, 1, 3]</span></span><br><span class="line"><span class="string">        [0, 1, 3, 2]</span></span><br><span class="line"><span class="string">        [0, 2]</span></span><br><span class="line"><span class="string">        [0, 2, 1, 3]</span></span><br><span class="line"><span class="string">        [0, 2, 3]</span></span><br><span class="line"><span class="string">        [0, 3]</span></span><br><span class="line"><span class="string">        [0, 3, 1, 2]</span></span><br><span class="line"><span class="string">        [0, 3, 2]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Iterate over each path from the root nodes to the leaf nodes in a</span></span><br><span class="line"><span class="string">    directed acyclic graph using a functional programming approach::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; from itertools import chain</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; from itertools import product</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; from itertools import starmap</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; from functools import partial</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt;</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; chaini = chain.from_iterable</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt;</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; G = nx.DiGraph([(0, 1), (1, 2), (0, 3), (3, 2)])</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; roots = (v for v, d in G.in_degree() if d == 0)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; leaves = (v for v, d in G.out_degree() if d == 0)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; all_paths = partial(nx.all_simple_paths, G)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; list(chaini(starmap(all_paths, product(roots, leaves))))</span></span><br><span class="line"><span class="string">        [[0, 1, 2], [0, 3, 2]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The same list computed using an iterative approach::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; G = nx.DiGraph([(0, 1), (1, 2), (0, 3), (3, 2)])</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; roots = (v for v, d in G.in_degree() if d == 0)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; leaves = (v for v, d in G.out_degree() if d == 0)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; all_paths = []</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; for root in roots:</span></span><br><span class="line"><span class="string">        ...     for leaf in leaves:</span></span><br><span class="line"><span class="string">        ...         paths = nx.all_simple_paths(G, root, leaf)</span></span><br><span class="line"><span class="string">        ...         all_paths.extend(paths)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; all_paths</span></span><br><span class="line"><span class="string">        [[0, 1, 2], [0, 3, 2]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Iterate over each path from the root nodes to the leaf nodes in a</span></span><br><span class="line"><span class="string">    directed acyclic graph passing all leaves together to avoid unnecessary</span></span><br><span class="line"><span class="string">    compute::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; G = nx.DiGraph([(0, 1), (2, 1), (1, 3), (1, 4)])</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; roots = (v for v, d in G.in_degree() if d == 0)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; leaves = [v for v, d in G.out_degree() if d == 0]</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; all_paths = []</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; for root in roots:</span></span><br><span class="line"><span class="string">        ...     paths = nx.all_simple_paths(G, root, leaves)</span></span><br><span class="line"><span class="string">        ...     all_paths.extend(paths)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; all_paths</span></span><br><span class="line"><span class="string">        [[0, 1, 3], [0, 1, 4], [2, 1, 3], [2, 1, 4]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Notes</span></span><br><span class="line"><span class="string">    -----</span></span><br><span class="line"><span class="string">    This algorithm uses a modified depth-first search to generate the</span></span><br><span class="line"><span class="string">    paths [1]_.  A single path can be found in $O(V+E)$ time but the</span></span><br><span class="line"><span class="string">    number of simple paths in a graph can be very large, e.g. $O(n!)$ in</span></span><br><span class="line"><span class="string">    the complete graph of order $n$.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    References</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    .. [1] R. Sedgewick, "Algorithms in C, Part 5: Graph Algorithms",</span></span><br><span class="line"><span class="string">       Addison Wesley Professional, 3rd ed., 2001.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    See Also</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    all_shortest_paths, shortest_path</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> source <span class="keyword">not</span> <span class="keyword">in</span> G:</span><br><span class="line">        <span class="keyword">raise</span> nx.NodeNotFound(<span class="string">'source node %s not in graph'</span> % source)</span><br><span class="line">    <span class="keyword">if</span> target <span class="keyword">in</span> G:</span><br><span class="line">        targets = &#123;target&#125;</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            targets = set(target)</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="keyword">raise</span> nx.NodeNotFound(<span class="string">'target node %s not in graph'</span> % target)</span><br><span class="line">    <span class="keyword">if</span> source <span class="keyword">in</span> targets:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">if</span> cutoff <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        cutoff = len(G) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> cutoff &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">if</span> G.is_multigraph():</span><br><span class="line">        <span class="keyword">return</span> _all_simple_paths_multigraph(G, source, targets, cutoff)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> _all_simple_paths_graph(G, source, targets, cutoff)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># source: single node</span></span><br><span class="line"><span class="comment"># targets: set of nodes</span></span><br><span class="line"><span class="comment"># cutoff: maximum edges in a path</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_all_simple_paths_graph</span><span class="params">(G, source, targets, cutoff)</span>:</span></span><br><span class="line">    visited = collections.OrderedDict.fromkeys([source])</span><br><span class="line">    stack = [iter(G[source])]  <span class="comment"># 添加邻接结点。G[node]类似于字典，key是邻接结点，value是边的属性</span></span><br><span class="line">    <span class="keyword">while</span> stack:  <span class="comment"># len(stack) &gt; 0时，bool(stack) = True</span></span><br><span class="line">        children = stack[<span class="number">-1</span>]</span><br><span class="line">        child = next(children, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> child <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            stack.pop()  <span class="comment"># 回退到上一个访问结点</span></span><br><span class="line">            visited.popitem()  <span class="comment"># 已访问结点做同样的操作</span></span><br><span class="line">        <span class="keyword">elif</span> len(visited) &lt; cutoff:</span><br><span class="line">            <span class="keyword">if</span> child <span class="keyword">in</span> visited:  <span class="comment"># 跳过已访问结点</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> child <span class="keyword">in</span> targets:</span><br><span class="line">                <span class="keyword">yield</span> list(visited) + [child]</span><br><span class="line">            visited[child] = <span class="literal">None</span>  <span class="comment"># 将当前结点放入visited中，值无所谓，这里用的是None</span></span><br><span class="line">            <span class="keyword">if</span> targets - set(visited.keys()):  <span class="comment"># 如果存在尚未访问的目标</span></span><br><span class="line">                stack.append(iter(G[child]))  <span class="comment"># 当前结点的邻接结点入栈</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 所有目标均已访问</span></span><br><span class="line">                visited.popitem()  <span class="comment"># 停止寻找</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># len(visited) == cutoff:</span></span><br><span class="line">            <span class="comment"># set(children) | &#123;child&#125;: 剩余的未访问结点</span></span><br><span class="line">            <span class="keyword">for</span> target <span class="keyword">in</span> (targets &amp; (set(children) | &#123;child&#125;)) - set(visited.keys()):</span><br><span class="line">                <span class="keyword">yield</span> list(visited) + [target]</span><br><span class="line">            stack.pop()</span><br><span class="line">            visited.popitem()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_all_simple_paths_multigraph</span><span class="params">(G, source, targets, cutoff)</span>:</span></span><br><span class="line">    visited = collections.OrderedDict.fromkeys([source])</span><br><span class="line">    stack = [(v <span class="keyword">for</span> u, v <span class="keyword">in</span> G.edges(source))]  <span class="comment"># G.edges(u) returns all edges from u</span></span><br><span class="line">    <span class="comment"># so when there exsit multi-edges between u and v, the v can also appear repeatedly</span></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        children = stack[<span class="number">-1</span>]</span><br><span class="line">        child = next(children, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> child <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            stack.pop()</span><br><span class="line">            visited.popitem()</span><br><span class="line">        <span class="keyword">elif</span> len(visited) &lt; cutoff:</span><br><span class="line">            <span class="keyword">if</span> child <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> child <span class="keyword">in</span> targets:</span><br><span class="line">                <span class="keyword">yield</span> list(visited) + [child]</span><br><span class="line">            visited[child] = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> targets - set(visited.keys()):</span><br><span class="line">                stack.append((v <span class="keyword">for</span> u, v <span class="keyword">in</span> G.edges(child)))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                visited.popitem()</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># len(visited) == cutoff:</span></span><br><span class="line">            <span class="keyword">for</span> target <span class="keyword">in</span> targets - set(visited.keys()):</span><br><span class="line">                count = ([child] + list(children)).count(target)</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">                    <span class="keyword">yield</span> list(visited) + [target]</span><br><span class="line">            stack.pop()</span><br><span class="line">            visited.popitem()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithms </tag>
            
            <tag> stack </tag>
            
            <tag> networkx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python repr方法</title>
      <link href="/programming/python-repr-method/"/>
      <url>/programming/python-repr-method/</url>
      
        <content type="html"><![CDATA[<h1 id="repr">repr</h1><blockquote><p><a href="https://devdocs.io/python~3.6/library/functions#repr" target="_blank" rel="noopener"><code>repr(object)</code></a></p><p>Return a string containing a printable representation of an object. For many types, this function makes an attempt to return a string that would yield an object with the same value when passed to eval(), otherwise the representation is a string enclosed in angle brackets that contains the name of the type of the object together with additional information often including the name and address of the object.</p></blockquote><p>repr的返回结果大致有两种类型：</p><ul><li>返回一个字符串，这个字符串所代表的代码与原对象相同，即<code>eval(repr(object) == object</code>。</li><li>返回一组尖括号，括号内包含了对象的名称和地址。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Student = namedtuple(<span class="string">'Student'</span>, <span class="string">'id name gender'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>alice = Student(<span class="number">1</span>, <span class="string">'Alice'</span>, <span class="string">'female'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>alice</span><br><span class="line">Student(id=<span class="number">1</span>, name=<span class="string">'Alice'</span>, gender=<span class="string">'female'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval(repr(alice)) == alice</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, id, name, gender)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.id, self.name, self.gender = id, name, gender</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john = Person(<span class="number">2</span>, <span class="string">'John'</span>, <span class="string">'male'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john</span><br><span class="line">&lt;__main__.Person object at <span class="number">0x10bf970b8</span>&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="自定义返回值">自定义返回值</h1><p>自定义返回值只需实现<code>__repr__</code>方法。可以看到默认的输出是第二种，想实现类似第一种可以像下面这样做。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="string">"%s(%s)"</span> % (self.__class__.__name__, <span class="string">', '</span>.join(<span class="string">'%s=%r'</span> % (k, v) <span class="keyword">for</span> k, v <span class="keyword">in</span> self.__dict__.items()))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Person.__repr__ = func</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john</span><br><span class="line">Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval(repr(john)) == john</span><br><span class="line"><span class="literal">False</span>  <span class="comment"># 不相等是因为没有定义__eq__</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval(repr(john))   <span class="comment"># 但内容是相同的</span></span><br><span class="line">Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>)</span><br></pre></td></tr></table></figure><p>优点：对简单类通用。</p><p>缺点：可能会输出不希望被看到的私有属性。如果内部变量有循环引用的话会陷入无限递归。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>marry = Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john = Person(<span class="number">2</span>, <span class="string">'John'</span>, <span class="string">'male'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>marry._sepouse = john  <span class="comment"># 不想被看到的信息</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>marry</span><br><span class="line">Person(id=<span class="number">3</span>, name=<span class="string">'Marry'</span>, gender=<span class="string">'female'</span>, _sepouse=Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john._sepouse = marry  <span class="comment"># 互相引用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john  <span class="comment"># 无限递归</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> func</span><br><span class="line">  ...  <span class="comment"># 省略</span></span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;genexpr&gt;</span><br><span class="line">RecursionError: maximum recursion depth exceeded</span><br></pre></td></tr></table></figure><h1 id="隐藏私有属性">隐藏私有属性</h1><p>常用做法：指定传入的字典即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, id, name, gender)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.id, self.name, self.gender = id, name, gender</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">"%s(%s)"</span> % (self.__class__.__name__, <span class="string">', '</span>.join(<span class="string">'%s=%r'</span> % (k, v) <span class="keyword">for</span> k, v <span class="keyword">in</span> self.get_params().items()))</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">get_params</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> dict(id=self.id, name=self.name, gender=self.gender)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>)</span><br><span class="line">Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john = Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>marry = Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john._sepouse = marry</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>marry._sepouse = john</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john</span><br><span class="line">Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>marry</span><br><span class="line">Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>)</span><br></pre></td></tr></table></figure><h1 id="避免无限递归">避免无限递归</h1><p>reprlib提供了一个装饰器，能检测递归调用，并用指定的字符代替调用。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/reprlib#reprlib.recursive_repr" target="_blank" rel="noopener"><code>@reprlib.recursive_repr(fillvalue=&quot;...&quot;)</code></a></p><p>Decorator for <code>__repr__()</code> methods to detect recursive calls within the same thread. If a recursive call is made, the fillvalue is returned, otherwise, the usual <code>__repr__()</code> call is made.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, id, name, gender)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.id, self.name, self.gender = id, name, gender</span><br><span class="line"><span class="meta">... </span>    @reprlib.recursive_repr()  <span class="comment"># 因为装饰器有参数，所以必须加上()</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">'%s(%s)'</span> % (type(self).__name__, <span class="string">', '</span>.join(<span class="string">'%s=%r'</span> % (k, v) <span class="keyword">for</span> k, v <span class="keyword">in</span> self.__dict__.items()))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>marry = Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john = Person(<span class="number">2</span>, <span class="string">'John'</span>, <span class="string">'male'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>marry</span><br><span class="line">Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>)  <span class="comment"># 无递归调用时</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>marry._sepouse = john</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john._sepouse = marry  <span class="comment"># 有递归调用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>marry</span><br><span class="line">Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>, _sepouse=Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>, _sepouse=...))</span><br></pre></td></tr></table></figure><h1 id="规避过长的描述">规避过长的描述</h1><p><code>repr()</code>函数的目的是方便程序员检查、调试程序。如果对象的属性中包含过长的列表、字符串等属性，朴素的<code>repr()</code>函数会打印全部内容。其结果会在控制台或日志文件中占据大量篇幅，与初衷相悖。此时推荐的做法是输出其简略的字符串表示形式。万幸，我们无需重复造轮子，也不一定造地好。<code>reprlib.repr()</code>函数能帮我们达到预期的结果。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/reprlib#reprlib.repr" target="_blank" rel="noopener"><code>reprlib.repr(obj)</code></a></p><p>This is the repr() method of aRepr. It returns a string similar to that returned by the built-in function of the same name, but with limits on most sizes.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array(range(<span class="number">10000</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a  <span class="comment"># numpy就做了类似处理</span></span><br><span class="line">array([   <span class="number">0</span>,    <span class="number">1</span>,    <span class="number">2</span>, ..., <span class="number">9997</span>, <span class="number">9998</span>, <span class="number">9999</span>])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> reprlib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = list(range(<span class="number">10000</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reprlib.repr(b)</span><br><span class="line"><span class="string">'[0, 1, 2, 3, 4, 5, ...]'</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> reprlib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Text</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, content)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.content = content</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">'Text(%s)'</span> % reprlib.repr(self.content)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = Text(<span class="string">'The beginning to learn a programming language is to print "Hello World!"'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">Text(<span class="string">'The beginnin...Hello World!"'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> repr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从定位参数到仅限关键字参数</title>
      <link href="/notes/fluent-python/from-positional-to-keyword-only-parameters/"/>
      <url>/notes/fluent-python/from-positional-to-keyword-only-parameters/</url>
      
        <content type="html"><![CDATA[<h1 id="从定位参数到仅限关键字参数">从定位参数到仅限关键字参数</h1><p>Python最好的特性之一是提供了极为灵活的参数处理机制，而且Python3进一步提供了仅限关键字参数（keyword-only argument）。与之密切相关的是，调用函数时使用<code>*</code>和<code>**</code>“展开”可迭代对象，映射到单个参数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tag</span><span class="params">(name, *content, cls=None, **attrs)</span>:</span></span><br><span class="line">    <span class="string">"""生成一个或多个HTML标签"""</span></span><br><span class="line">    <span class="keyword">if</span> cls <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        attrs[<span class="string">'class'</span>] = cls</span><br><span class="line">    <span class="keyword">if</span> attrs:</span><br><span class="line">        attr_str = <span class="string">''</span>.join(<span class="string">' %s="%s"'</span> % (attr, value)</span><br><span class="line">            <span class="keyword">for</span> attr, value <span class="keyword">in</span> sorted(attrs.items()))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        attr_str = <span class="string">''</span></span><br><span class="line">    <span class="keyword">if</span> content:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'\n'</span>.join(<span class="string">'&lt;%s%s&gt;%s&lt;/%s&gt;'</span> %</span><br><span class="line">            (name, attr_str, c, name) <span class="keyword">for</span> c <span class="keyword">in</span> content)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;%s%s /&gt;'</span> % (name, attr_str)</span><br></pre></td></tr></table></figure><a id="more"></a><p>tag函数的调用方式很多</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag(<span class="string">'br'</span>)  <span class="comment"># A</span></span><br><span class="line"><span class="string">'&lt;br /&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag(<span class="string">'p'</span>, <span class="string">'hello'</span>, <span class="string">'sidebar'</span>)  <span class="comment"># B</span></span><br><span class="line"><span class="string">'&lt;p&gt;hello&lt;/p&gt;\n&lt;p&gt;sidebar&lt;/p&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag(<span class="string">'p'</span>, <span class="string">'hello'</span>, cls=<span class="string">'sidebar'</span>)  <span class="comment"># C</span></span><br><span class="line"><span class="string">'&lt;p class="sidebar"&gt;hello&lt;/p&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_tag = &#123;<span class="string">'name'</span>: <span class="string">'img'</span>, <span class="string">'title'</span>: <span class="string">'Sunset Boulevard'</span>, <span class="string">'src'</span>: <span class="string">'sunset.jpg'</span>, <span class="string">'cls'</span>: <span class="string">'framed'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag(**my_tag)  <span class="comment"># D</span></span><br><span class="line"><span class="string">'&lt;img class="framed" src="sunset.jpg" title="Sunset Boulevard" /&gt;'</span></span><br></pre></td></tr></table></figure><p>A. 传入单个定位参数。</p><p>B. 传入多个定位参数，根据函数定义，第1个参数被传入name，剩余的未命名定位参数被传入content。</p><p>C. cls参数只能通过关键字参数指定，它一定不会捕获未命名的定位参数。（因为cls参数在有<code>*</code>参数的后面（不能放在<code>**</code>参数的后面），若不指定关键字，则编译器无法判断它是该传入content还是该传入cls）</p><p>D. 在my_tag前面加上<code>**</code>，字典中的所有元素作为单个参数传入，同名键会绑定到对应的具名参数上，余下的被<code>**attrs</code>捕获。</p><p>如果不想支持数量不定的定位参数（即<code>*content</code>），但想支持仅限关键字参数，在签名中放一个<code>*</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, *, b)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> a, b</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment"># 强制以关键字传入</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: f() takes <span class="number">1</span> positional argument but <span class="number">2</span> were given</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">1</span>, b=<span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h1 id="获取关于参数的信息">获取关于参数的信息</h1><p>查看<code>__defaultS__</code>、<code>__code__.co_varnames</code>、<code>__code__.co_argcount</code>的值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, b=None, *c, d=None, **e)</span>:</span> f, g = <span class="number">0</span>, <span class="number">1</span>; <span class="keyword">return</span> f + g</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__defaults__  <span class="comment"># 形式参数的默认值</span></span><br><span class="line">(<span class="literal">None</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__kwdefaults__  <span class="comment"># 仅限关键字形式参数的默认值</span></span><br><span class="line">&#123;<span class="string">'d'</span>: <span class="literal">None</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__code__.co_varnames  <span class="comment"># 参数名称+函数定义体中创建的局部变量</span></span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'d'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__code__.co_argcount  <span class="comment"># 参数数量（看来不包括带*参数以及在其后面的参数）</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>上述组织方式不友好，我们有更好的模块inspect模块。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> inspect <span class="keyword">import</span> signature</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sig = signature(f)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sig</span><br><span class="line">&lt;Signature (a, b=<span class="literal">None</span>, *c, d=<span class="literal">None</span>, **e)&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name, param <span class="keyword">in</span> sig.parameters.items():</span><br><span class="line"><span class="meta">... </span>    print(param.kind, <span class="string">':'</span>, name, <span class="string">'='</span>, param.default)</span><br><span class="line">...</span><br><span class="line">POSITIONAL_OR_KEYWORD : a = &lt;<span class="class"><span class="keyword">class</span> '<span class="title">inspect</span>.<span class="title">_empty</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">POSITIONAL_OR_KEYWORD</span> :</span> b = <span class="literal">None</span></span><br><span class="line">VAR_POSITIONAL : c = &lt;<span class="class"><span class="keyword">class</span> '<span class="title">inspect</span>.<span class="title">_empty</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">KEYWORD_ONLY</span> :</span> d = <span class="literal">None</span></span><br><span class="line">VAR_KEYWORD : e = &lt;<span class="class"><span class="keyword">class</span> '<span class="title">inspect</span>.<span class="title">_empty</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>signature返回一个Signature对象，它有一个parameters属性，这是一个有序映射，把参数名和Parameter对象对应起来。Parameter也有自己的属性。例如name、default、kind、annotation（下一节函数注解中使用此属性获取附加的元数据）。特殊的<code>inspect._empty</code>表示参数没有默认值。kind属性是<code>_ParameterKind</code>类中的5个值之一。</p><ul><li><p>POSITIONAL_OR_KEYWORD：可以通过定位参数和关键字参数传入的形参（多数Python函数的参数属于此类）。</p></li><li><p>VAR_POSITIONAL：定位参数元组。</p></li><li><p>VAR_KEYWORD：关键字参数字典。</p></li><li><p>KEYWORD_ONLY：仅限关键字参数（Python3新增）。</p></li><li><p>POSITIONAL_ONLY：仅限定位参数；目前，Python声明函数的句法不支持，但是有些使用C语言实现且不接受关键字参数的函数（如divmod）支持。</p></li></ul><p>Signature对象有个bind方法，它可以把任意个参数绑定到签名中的形参上，所用的规则与实参到形参的匹配方式一样。框架可以使用这个方法在真正调用函数前验证参数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> inspect <span class="keyword">import</span> signature</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sig = signature(tag)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_tag = &#123;<span class="string">'name'</span>: <span class="string">'img'</span>, <span class="string">'title'</span>: <span class="string">'Sunset Boulevard'</span>, <span class="string">'src'</span>: <span class="string">'sunset.jpg'</span>, <span class="string">'cls'</span>: <span class="string">'framed'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bound_args = sig.bind(**my_tag)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bound_args</span><br><span class="line">&lt;BoundArguments (name=<span class="string">'img'</span>, cls=<span class="string">'framed'</span>, attrs=&#123;<span class="string">'title'</span>: <span class="string">'Sunset Boulevard'</span>, <span class="string">'src'</span>: <span class="string">'sunset.jpg'</span>&#125;)&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> bound_args.arguments.items():</span><br><span class="line"><span class="meta">... </span>    print(k, <span class="string">'='</span>, v)</span><br><span class="line">...</span><br><span class="line">name = img</span><br><span class="line">cls = framed</span><br><span class="line">attrs = &#123;<span class="string">'title'</span>: <span class="string">'Sunset Boulevard'</span>, <span class="string">'src'</span>: <span class="string">'sunset.jpg'</span>&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> my_tag[<span class="string">'name'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bound_args = sig.bind(**my_tag)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"/Users/cws/opt/anaconda3/envs/python36/lib/python3.6/inspect.py"</span>, line <span class="number">2997</span>, <span class="keyword">in</span> bind</span><br><span class="line">    <span class="keyword">return</span> args[<span class="number">0</span>]._bind(args[<span class="number">1</span>:], kwargs)</span><br><span class="line">  File <span class="string">"/Users/cws/opt/anaconda3/envs/python36/lib/python3.6/inspect.py"</span>, line <span class="number">2912</span>, <span class="keyword">in</span> _bind</span><br><span class="line">    <span class="keyword">raise</span> TypeError(msg) <span class="keyword">from</span> <span class="literal">None</span></span><br><span class="line">TypeError: missing a required argument: <span class="string">'name'</span></span><br></pre></td></tr></table></figure><h1 id="函数注解">函数注解</h1><p>Python3提供了一种句法，用于为函数声明中的参数和返回值附加元数据。函数声明中的各个参数可以在<code>:</code>之后增加注解表达式。</p><p>Python对注解所做的唯一的事情是，把它们存储在函数的<code>__annotations__</code>属性里。仅此而已，Python不做检查、不做强制、不做验证，什么操作都不做。换句话说，注解对Python解释器没有任何意义。注解只是元数据，可以供IDE、框架和装饰器等工具使用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, b, c, d)</span>:</span> <span class="keyword">pass</span>  <span class="comment"># 常规</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, b: str, c: <span class="string">'int &gt; 0'</span>, d: float=<span class="number">0.0</span>)</span> -&gt; str:</span> <span class="keyword">pass</span>  <span class="comment"># 加注解</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__annotations__</span><br><span class="line">&#123;'b': &lt;class 'str'&gt;, 'c': 'int &gt; 0', 'd': &lt;class 'float'&gt;, 'return': &lt;class 'str'&gt;&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> inspect <span class="keyword">import</span> signature</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sig = signature(f)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sig.return_annotation</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">for</span> <span class="title">param</span> <span class="title">in</span> <span class="title">sig</span>.<span class="title">parameters</span>.<span class="title">values</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    note = repr(param.annotation).ljust(<span class="number">26</span>)</span><br><span class="line"><span class="meta">... </span>    print(note, <span class="string">':'</span>, param.name, <span class="string">'='</span>, param.default)</span><br><span class="line">...</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">inspect</span>.<span class="title">_empty</span>'&gt;   :</span> a = &lt;<span class="class"><span class="keyword">class</span> '<span class="title">inspect</span>.<span class="title">_empty</span>'&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">str</span>'&gt;              :</span> b = &lt;<span class="class"><span class="keyword">class</span> '<span class="title">inspect</span>.<span class="title">_empty</span>'&gt;</span></span><br><span class="line"><span class="class">'<span class="title">int</span> &gt; 0'                  :</span> c = &lt;<span class="class"><span class="keyword">class</span> '<span class="title">inspect</span>.<span class="title">_empty</span>'&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">float</span>'&gt;            :</span> d = <span class="number">0.0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> parameters </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一等函数</title>
      <link href="/notes/fluent-python/first-class-functions/"/>
      <url>/notes/fluent-python/first-class-functions/</url>
      
        <content type="html"><![CDATA[<h1 id="把函数试作对象">把函数试作对象</h1><p>在 Python 中，整数、字符串、字典和函数都是一等对象。“一等对象”为满足下述条件的过程实体：</p><ul><li>在运行时创建</li><li>能赋值给变量或数据结构中的元素</li><li>能作为参数传给函数</li><li>能作为函数的返回结果</li></ul><p>人们经常将“把函数视作一等对象”简称为“一等函数”。这样说并不完美，似乎表明这是函数中的特殊群体。在 Python 中，所有函数都是一等对象。</p><a id="more"></a><h1 id="高阶函数">高阶函数</h1><p>接受函数为参数，或者把函数作为结果返回的函数都是高阶函数（higher-order function）。使用高阶函数是函数式编程的特点之一。常见的高阶函数有 <code>max</code>, <code>min</code>, <code>sorted</code>, <code>map</code>, <code>filter</code>, <code>reduce</code>。</p><p><code>max</code>, <code>min</code>, <code>sorted</code> 中的 key 参数接受函数，任何单参数函数都能作为 key 参数的值。例如，想根据单词长度排序时，只需把 len 函数传入。若想创建押韵词典（水果中的各类浆果 *berry 都排在一起），可以把各个单词反过来拼写，然后排序。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits = [<span class="string">'strawberry'</span>, <span class="string">'fig'</span>, <span class="string">'apple'</span>, <span class="string">'cherry'</span>, <span class="string">'raspberry'</span>, <span class="string">'banana'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(fruits, key=len)</span><br><span class="line">[<span class="string">'fig'</span>, <span class="string">'apple'</span>, <span class="string">'cherry'</span>, <span class="string">'banana'</span>, <span class="string">'raspberry'</span>, <span class="string">'strawberry'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(fruits, key=<span class="keyword">lambda</span> i: i[::<span class="number">-1</span>])</span><br><span class="line">[<span class="string">'banana'</span>, <span class="string">'apple'</span>, <span class="string">'fig'</span>, <span class="string">'raspberry'</span>, <span class="string">'strawberry'</span>, <span class="string">'cherry'</span>]</span><br></pre></td></tr></table></figure><p><code>map</code>, <code>filter</code>, <code>reduce</code> 在多数使用场景下都有更好的替代品。</p><h2 id="mapfilter和reduce的替代品">map、filter和reduce的替代品</h2><p>在 Python3 中，<code>map</code> 和 <code>filter</code> 返回生成器（一种迭代器），因此它们的直接替代品是生成器表达式（在 Python2 中，这两个函数返回列表，因此最接近的替代品是列表推导）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">"""Returns n!"""</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> n * fact(n - <span class="number">1</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(fact, range(<span class="number">6</span>))</span><br><span class="line">&lt;map object at <span class="number">0x10c597f98</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(fact(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">6</span>))</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x10c58b780</span>&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(fact, range(<span class="number">6</span>)))</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[fact(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">6</span>)]</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(fact, filter(<span class="keyword">lambda</span> n: n % <span class="number">2</span>, range(<span class="number">6</span>))))</span><br><span class="line">[<span class="number">1</span>, <span class="number">6</span>, <span class="number">120</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[fact(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">6</span>) <span class="keyword">if</span> n % <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">6</span>, <span class="number">120</span>]</span><br></pre></td></tr></table></figure><p><code>reduce</code> 这个函数最常用于求和，可使用 <code>sum</code> 函数替代，在可读性和性能方面，这是一项重大改善。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> add</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(add, range(<span class="number">100</span>))</span><br><span class="line"><span class="number">4950</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum(range(<span class="number">100</span>))</span><br><span class="line"><span class="number">4950</span></span><br></pre></td></tr></table></figure><h2 id="归约函数">归约函数</h2><p><code>sum</code> 和 <code>reduce</code> 的通用思想是把某个操作连续应用到序列的元素上，累计之前的结果，把一系列值归约成一个值。<code>all</code> 和 <code>any</code> 也是内置的归约函数。</p><blockquote><p><code>all(iterable)</code></p><p>Return True if all elements of the iterable are true (or if the iterable is empty).</p><p><code>any(iterable)</code></p><p>Return True if any element of the iterable is true. If the iterable is empty, return False.</p></blockquote><h1 id="匿名函数">匿名函数</h1><p>lambda 关键字在 Python 表达式内创建匿名函数。然而，Python 简单的句法限制了 lambda 函数的定义体只能使用纯表达式。换句话说，lambda 函数的定义体中不能赋值，也不能使用 while 和 try 等 Python 语句。</p><p>如果使用 lambda 表达式导致一段代码难以理解，Fredrik Lundh 建议像下面这样重构。</p><p>（1）编写注释，说明 lambda 表达式的作用。</p><p>（2）研究一会注释，并找出一个名称来概括注释。</p><p>（3）把 lambda 表达式转换成def语句，使用那个名称来定义函数。</p><p>（4）删除注释。</p><p>与def语句一样，lambda 表达式会创建函数对象。这是 Python 中几种可调用对象的一种。</p><h1 id="可调用对象">可调用对象</h1><p>除了用户定义的函数，调用运算符，即 <code>()</code>，还可以应用到其他对象上。如果想判断对象能否调用，可以使用内置的 <code>callable</code> 函数。Python 数据模型文档列出了 7 种可调用对象。</p><ul><li>用户定义的函数：使用 def 语句或 lambda 表达式创建。</li><li>内置函数：使用 C 语言（CPython）实现的函数，如 len 或 <code>time.strftime</code>。</li><li>内置方法：使用 C 语言实现的方法，如 <code>dict.get</code>。</li><li>方法：在类的定义体中定义的函数。</li><li>类：调用类时会运行类的 <code>__new__</code> 方法创建一个实例，然后运行 <code>__init__</code> 方法，初始化实例，最后把实例返回给调用方。因为 Python 没有 new 运算符，所以调用类相当于调用函数。</li><li>类的实例：如果类定义了 <code>__call__</code> 方法，那么它的实例可以作为函数调用。</li><li>生成器函数：使用 yield 关键字的函数或方法。调用生成器函数返回的是生成器对象。生成器函数在很多方面与其他可调用对象不同。</li></ul><p>Python 中有各种各样可调用的类型，因此判断对象能否调用，最安全的方法是使用内置的 callable 函数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>abs, str, <span class="number">1</span></span><br><span class="line">(&lt;built-in function abs&gt;, &lt;class 'str'&gt;, 1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[callable(obj) <span class="keyword">for</span> obj <span class="keyword">in</span> (abs, str, <span class="number">1</span>)]</span><br><span class="line">[<span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">False</span>]</span><br></pre></td></tr></table></figure><h1 id="函数内省">函数内省</h1><p>函数对象有很多属性。使用 dir 函数可以探知 fact 具有以下属性。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(fact)</span><br><span class="line">[<span class="string">'__annotations__'</span>, <span class="string">'__call__'</span>, <span class="string">'__class__'</span>, <span class="string">'__closure__'</span>, <span class="string">'__code__'</span>, <span class="string">'__defaults__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__get__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__globals__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__kwdefaults__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__module__'</span>, <span class="string">'__name__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__qualname__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>]</span><br></pre></td></tr></table></figure><p>其中大多数属性是 Python 对象共有的。</p><p>与用户定义的常规类一样，函数使用 <code>__dict__</code> 属性存储赋予它的用户属性。一般来说，为函数随意赋予属性不是很常见的做法。</p><p>下面重点说明函数专有而用户定义的一般对象没有的属性。计算两个属性集合的差集便能得到函数专有属性列表。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = C()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span> <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(set(dir(func)) - set(dir(obj)))</span><br><span class="line">[<span class="string">'__annotations__'</span>, <span class="string">'__call__'</span>, <span class="string">'__closure__'</span>, <span class="string">'__code__'</span>, <span class="string">'__defaults__'</span>, <span class="string">'__get__'</span>, <span class="string">'__globals__'</span>, <span class="string">'__kwdefaults__'</span>, <span class="string">'__name__'</span>, <span class="string">'__qualname__'</span>]</span><br></pre></td></tr></table></figure><table><thead><tr class="header"><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>__annotations__</code></td><td>dict</td><td>参数和返回值的注解</td></tr><tr class="even"><td><code>__call__</code></td><td>method-wrapper</td><td>实现()运算符：即可调用对象协议</td></tr><tr class="odd"><td><code>__closure__</code></td><td>tuple</td><td>函数闭包，即自由变量的绑定（通常是None）</td></tr><tr class="even"><td><code>__code__</code></td><td>code</td><td>编译成字节码的函数元数据和函数定义体</td></tr><tr class="odd"><td><code>__defaults__</code></td><td>tuple</td><td>形式参数的默认值</td></tr><tr class="even"><td><code>__get__</code></td><td>method-wrapper</td><td>实现只读描述符协议</td></tr><tr class="odd"><td><code>__globals__</code></td><td>dict</td><td>函数所在模块中的全局变量</td></tr><tr class="even"><td><code>__kwdefaults__</code></td><td>dict</td><td>仅限关键字形式参数的默认值</td></tr><tr class="odd"><td><code>__name__</code></td><td>str</td><td>函数名称</td></tr><tr class="even"><td><code>__qualname__</code></td><td>str</td><td>函数的限定名称，如Random.choice（<a href="https://www.python.org/dev/peps/pep-3155/" target="_blank" rel="noopener">参阅PEP 3155</a>）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> first-class functions </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>支持函数式编程的包</title>
      <link href="/notes/fluent-python/packages-for-functional-programming/"/>
      <url>/notes/fluent-python/packages-for-functional-programming/</url>
      
        <content type="html"><![CDATA[<h1 id="operator模块">operator模块</h1><p>Python的目标不是变成函数式编程语言，但是得益于operator和functools等包的支持，函数式编程风格也可以信手拈来。下面是operator模块中定义的部分函数（省略了以_开头的名称，因为它们基本上是实现细节）：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> operator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[name <span class="keyword">for</span> name <span class="keyword">in</span> dir(operator) <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'_'</span>)]</span><br><span class="line">[<span class="string">'abs'</span>, <span class="string">'add'</span>, <span class="string">'and_'</span>, <span class="string">'attrgetter'</span>, <span class="string">'concat'</span>, <span class="string">'contains'</span>, <span class="string">'countOf'</span>, <span class="string">'delitem'</span>, <span class="string">'eq'</span>, <span class="string">'floordiv'</span>, <span class="string">'ge'</span>, <span class="string">'getitem'</span>, <span class="string">'gt'</span>, <span class="string">'iadd'</span>, <span class="string">'iand'</span>, <span class="string">'iconcat'</span>, <span class="string">'ifloordiv'</span>, <span class="string">'ilshift'</span>, <span class="string">'imatmul'</span>, <span class="string">'imod'</span>, <span class="string">'imul'</span>, <span class="string">'index'</span>, <span class="string">'indexOf'</span>, <span class="string">'inv'</span>, <span class="string">'invert'</span>, <span class="string">'ior'</span>, <span class="string">'ipow'</span>, <span class="string">'irshift'</span>, <span class="string">'is_'</span>, <span class="string">'is_not'</span>, <span class="string">'isub'</span>, <span class="string">'itemgetter'</span>, <span class="string">'itruediv'</span>, <span class="string">'ixor'</span>, <span class="string">'le'</span>, <span class="string">'length_hint'</span>, <span class="string">'lshift'</span>, <span class="string">'lt'</span>, <span class="string">'matmul'</span>, <span class="string">'methodcaller'</span>, <span class="string">'mod'</span>, <span class="string">'mul'</span>, <span class="string">'ne'</span>, <span class="string">'neg'</span>, <span class="string">'not_'</span>, <span class="string">'or_'</span>, <span class="string">'pos'</span>, <span class="string">'pow'</span>, <span class="string">'rshift'</span>, <span class="string">'setitem'</span>, <span class="string">'sub'</span>, <span class="string">'truediv'</span>, <span class="string">'truth'</span>, <span class="string">'xor'</span>]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="算术运算符函数">算术运算符函数</h2><p>在函数式编程中，经常需要把算术运算符当作函数使用。例如，不使用递归进行阶乘</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> a, b: a*b, range(<span class="number">1</span>, n+<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>operator模块为多个算术运算符提供了对应的函数，从而避免编写<code>lambda a, b: a*b</code>这种平凡的匿名函数。使用算术运算符函数，可以把上例改写为</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> mul</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">_fact</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> reduce(mul, range(<span class="number">1</span>, n+<span class="number">1</span>))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>all(fact(i) == _fact(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">100</span>))</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="getter函数">getter函数</h2><p>operator模块中还有一类函数，能替代从序列中取出元素或读取对象属性的lambda表达式：因此，itemgetter和attrgetter其实会自行构建函数（点击链接查看其等价函数）。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/operator#operator.itemgetter" target="_blank" rel="noopener"><code>operator.itemgetter(item) operator.itemgetter(*items)</code></a></p><p>Return a callable object that fetches <em>item</em> from its operand using the operand’s <code>__getitem__()</code> method. If multiple items are specified, returns a tuple of lookup values. For example:</p><ul><li>After <code>f = itemgetter(2)</code>, the call <code>f(r)</code> returns <code>r[2]</code>.</li><li>After <code>g = itemgetter(2, 5, 3)</code>, the call <code>g(r)</code> returns <code>(r[2], r[5], r[3])</code>.</li></ul><hr><p><a href="https://devdocs.io/python~3.6/library/operator#operator.attrgetter" target="_blank" rel="noopener"><code>operator.attrgetter(attr) operator.attrgetter(*attrs)</code></a></p><p>Return a callable object that fetches <em>attr</em> from its operand. If more than one attribute is requested, returns a tuple of attributes. The attribute names can also contain dots. For example:</p><ul><li>After <code>f = attrgetter('name')</code>, the call <code>f(b)</code> returns <code>b.name</code>.</li><li>After <code>f = attrgetter('name', 'date')</code>, the call <code>f(b)</code> returns <code>(b.name, b.date)</code>.</li><li>After <code>f = attrgetter('name.first', 'name.last')</code>, the call <code>f(b)</code> returns <code>(b.name.first, b.name.last)</code>.</li></ul></blockquote><h2 id="methodcall函数">methodcall函数</h2><p>它的作用与attrgetter和itemgetter类似，它会自行创建函数。methodcaller创建的函数会在对象上调用参数指定的方法。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/operator#operator.methodcaller" target="_blank" rel="noopener"><code>operator.methodcaller(name[, args...])</code></a></p><p>Return a callable object that calls the method <em>name</em> on its operand. If additional arguments and/or keyword arguments are given, they will be given to the method as well. For example:</p><ul><li>After <code>f = methodcaller('name')</code>, the call <code>f(b)</code> returns <code>b.name()</code>.</li><li>After <code>f = methodcaller('name', 'foo', bar=1)</code>, the call <code>f(b)</code> returns <code>b.name('foo', bar=1)</code>.</li></ul></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> methodcaller</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'The time has come'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>upcase = methodcaller(<span class="string">'upper'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>upcase(s)  <span class="comment"># 相当于s.upper()</span></span><br><span class="line"><span class="string">'THE TIME HAS COME'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hiphenate = methodcaller(<span class="string">'replace'</span>, <span class="string">' '</span>, <span class="string">'-'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hiphenate(s)  <span class="comment"># 相当于s.replace(' ', '-')</span></span><br><span class="line"><span class="string">'The-time-has-come'</span></span><br></pre></td></tr></table></figure><h1 id="使用functools.partial冻结参数">使用functools.partial冻结参数</h1><blockquote><p><a href="https://devdocs.io/python~3.6/library/functools#functools.partial" target="_blank" rel="noopener"><code>functools.partial(func, *args, **keywords)</code></a></p></blockquote><p>partial这个高阶函数用于部分应用一个函数。部分应用是指，基于一个函数创建一个新的调用对象，把原函数的某些参数固定。使用这个函数可以把接受一个或多个参数的函数改编成需要回调的API，这样参数更少。</p><p>示例：使用partial把一个两参数函数改编成需要单参数的可调用对象。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> mul</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>triple = partial(mul, <span class="number">3</span>)  <span class="comment"># 相当于 lambda e: mul(3, e)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>triple</span><br><span class="line">functools.partial(&lt;built-<span class="keyword">in</span> function mul&gt;, <span class="number">3</span>)  <span class="comment"># 返回一个partial对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>triple(<span class="number">7</span>)  <span class="comment"># triple接受单参数</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(triple, range(<span class="number">1</span>, <span class="number">10</span>)))</span><br><span class="line">[<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">21</span>, <span class="number">24</span>, <span class="number">27</span>]</span><br></pre></td></tr></table></figure><p>functools.partialmethod函数（Python3.4新增）的作用与partial一样，不过是用于处理方法（在类中定义的函数）的。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/functools#functools.partialmethod" target="_blank" rel="noopener"><code>class functools.partialmethod(func, *args, **keywords)</code></a></p></blockquote><p>Example:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Cell</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self._alive = <span class="literal">False</span></span><br><span class="line"><span class="meta">... </span>    @property</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">alive</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> self._alive</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">set_state</span><span class="params">(self, state)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self._alive = bool(state)</span><br><span class="line"><span class="meta">... </span>    set_alive = partialmethod(set_state, <span class="literal">True</span>)</span><br><span class="line"><span class="meta">... </span>    set_dead = partialmethod(set_state, <span class="literal">False</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Cell()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.alive</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.set_alive()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.alive</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> functional programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dict：处理找不到的键</title>
      <link href="/notes/fluent-python/handling-missing-keys-in-a-dict/"/>
      <url>/notes/fluent-python/handling-missing-keys-in-a-dict/</url>
      
        <content type="html"><![CDATA[<h1 id="get">get</h1><blockquote><p><code>get(key[, default])</code></p></blockquote><p>当key存在时，返回其对应的值，否则返回default，defaut的默认值为None，这比处理KeyError要方便不少。相当于<code>return m[key] if key in a else default</code>。</p><p>但是要更新某个键对应的值时，不管使用<code>__getitem__</code>（即类似m[key]的形式）还是get都会不自然，而且效率低。</p><h1 id="setdefault">setdefault</h1><blockquote><p><code>setdefault(key[, default])</code></p></blockquote><p>当key不存在时，会先更新key的值为default，然后返回default。当key存在时，返回key的值。相当于：</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setdefault</span><span class="params">(self, key, default=None)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> self[key]  <span class="comment"># key已存在时</span></span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">        self[key] = default  <span class="comment"># key不存在时</span></span><br><span class="line">        <span class="keyword">return</span> default</span><br></pre></td></tr></table></figure><p>get(key, default)与setdefault(key, default)在key不存在时都能返回default，不同的是setdefault在返回前更新了key的值，这在某些时候（比如值是一个对象，且对其进行修改时）非常有用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name_list = m.get(<span class="string">'names'</span>, [])  <span class="comment"># 第1次查询</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name_list.append(<span class="string">'Alice'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="string">'names'</span>] = name_list  <span class="comment"># 第2次查询</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m</span><br><span class="line">&#123;<span class="string">'names'</span>: [<span class="string">'Alice'</span>]&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.setdefault(<span class="string">'names'</span>, []).append(<span class="string">'John'</span>)  <span class="comment"># 1步到位</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m</span><br><span class="line">&#123;<span class="string">'names'</span>: [<span class="string">'Alice'</span>, <span class="string">'John'</span>]&#125;</span><br></pre></td></tr></table></figure><h1 id="defaultdict">defaultdict</h1><blockquote><p><code>class collections.defaultdict([default_factory[, ...]])</code></p></blockquote><p>在用户创建defaultdict对象的时候，就需要给它配置一个为找不到的键创造默认值的方法。具体而言，在实例化一个defaultdict的时候，需要给构造方法提供一个可调用对象，这个可调用对象会在<code>__getitem__</code>碰到找不到的键的时候被调用，让<code>__getitem__</code>返回某种默认值。</p><p>defaultdict里的<code>default_factory</code>只会在<code>__getitem__</code>里被调用，在其他的方法里完全不会发挥作用。比如，dd是个defaultdict，k是个找不到的键，dd[k]这个表达式会调用<code>default_factory</code>创造某个默认值，而dd.get(k)则会返回None。</p><p>所有这一切背后的功臣其实是特殊方法<code>__missing__</code>。它会在defaultdict遇到找不到的键的时候调用<code>default_factory</code>，而实际上这个特性是所有映射类型都可以选择去支持的。</p><p>使用例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = defaultdict(list)  <span class="comment"># default_factory=list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="string">'names'</span>].append(<span class="string">'Alice'</span>)  <span class="comment"># default_factor会被调用，为查询不到的键创建一个值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">defaultdict(&lt;class 'list'&gt;, &#123;'names': ['Alice']&#125;)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.get(<span class="number">0</span>)  <span class="comment"># default_factor会被调用不会被调用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.get(<span class="string">'names'</span>)</span><br><span class="line">[<span class="string">'Alice'</span>]</span><br></pre></td></tr></table></figure><h1 id="特殊方法">特殊方法</h1><p><strong>所有的映射类型在处理找不到的键的时候，都会牵扯到<code>__missing__</code>方法。</strong>这也是这个方法称作“missing”的原因。虽然基类dict并没有定义这个方法，但是dict是知道有这么个东西存在的。也就是说，如果有一个类继承了dict，然后这个继承类提供了<code>__missing__</code>方法，那么在<code>__getitem__</code>碰到找不到的键的时候，Python 就会自动调用它，而不是抛出一个KeyError异常。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">StrKeyDict</span><span class="params">(dict)</span>:</span>  <span class="comment"># 继承自dict</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> isinstance(key, str):  <span class="comment"># 如果key本身是字符串，就抛出异常</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">raise</span> KeyError(key)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> self[str(key)]  <span class="comment"># 否则，转换成字符串在进行查找</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key, default=None)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> self[key]  <span class="comment"># 将get方法的查找工作委托给__getitem__，这样在宣布</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">except</span> KeyError:      <span class="comment"># 查找失败之前，还能通过__missing__再给某个键一次机会</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> default</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self, key)</span>:</span>  <span class="comment"># 继承的__contains__方法在找不到键时不会调用__missing__</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> key <span class="keyword">in</span> self.keys() <span class="keyword">or</span> str(key) <span class="keyword">in</span> self.keys()  <span class="comment"># 因此这里需要重写此方法</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = StrKeyDict(&#123;i <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> str(i): i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m</span><br><span class="line">&#123;<span class="number">0</span>: <span class="number">0</span>, <span class="string">'1'</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">4</span>, <span class="string">'3'</span>: <span class="number">9</span>, <span class="number">4</span>: <span class="number">16</span>, <span class="string">'5'</span>: <span class="number">25</span>, <span class="number">6</span>: <span class="number">36</span>, <span class="string">'7'</span>: <span class="number">49</span>, <span class="number">8</span>: <span class="number">64</span>, <span class="string">'9'</span>: <span class="number">81</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="number">0</span>]</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.get(<span class="number">0</span>)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="number">1</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.get(<span class="number">1</span>)  <span class="comment"># 与defaultdict不同，能触发__missing__</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> <span class="keyword">in</span> m</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> <span class="keyword">in</span> m</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><ul><li><p><code>__missing__</code>方法中isinstance是必须的，否则当str(key)是一个不存在的键时，会陷入无限递归。</p></li><li><p><code>__contains__</code>方法中没有用key in my_dict来检查键是否存在，因为那也会导致<code>__contains__</code>被递归调用（or关键字后面的第二次查找会调用<code>__contains__</code>）。为了避免这一情况，这里采用了更显式的方法，直接在self.keys()里查询。</p></li><li><p>像<code>k in my_dict.keys()</code>这种操作在Python 3中是很快的，而且即便映射类型对象很庞大也没关系。这是因为dict.keys()的返回值是一个”视图“。视图就像一个集合，而且跟字典类似的是，在视图里查找一个元素的速度很快。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dict </tag>
            
            <tag> Fluent Python </tag>
            
            <tag> special methods </tag>
            
            <tag> defaultdict </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用bisect来管理已排序的序列</title>
      <link href="/notes/fluent-python/managing-ordered-sequences-with-bisect/"/>
      <url>/notes/fluent-python/managing-ordered-sequences-with-bisect/</url>
      
        <content type="html"><![CDATA[<h1 id="bisect">bisect</h1><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><thead><tr class="header"><th>Method</th><th>Doc</th></tr></thead><tbody><tr class="odd"><td><code>bisect.bisect_left(a, x, lo=0, hi=len(a))</code></td><td>Return the leftmost index where to insert item x in list a, assuming a is sorted.</td></tr><tr class="even"><td><code>bisect.bisect_right(a, x, lo=0, hi=len(a))</code></td><td>Return the rightmost index where to insert item x in list a, assuming a is sorted.</td></tr><tr class="odd"><td><code>bisect.bisect(a, x, lo=0, hi=len(a))</code></td><td>Equal to bisect_right.</td></tr><tr class="even"><td><code>bisect.insort_left(a, x, lo=0, hi=len(a))</code></td><td>Insert item x in a and keep it sorted assuming a is sorted. If equal keys are found, add to the left.</td></tr><tr class="odd"><td><code>bisect.insort_right(a, x, lo=0, hi=len(a))</code></td><td>Insert item x in a and keep it sorted assuming a is sorted. If equal keys are found, add to the right.</td></tr><tr class="even"><td><code>bisect.insort(a, x, lo=0, hi=len(a))</code></td><td>Equal to insort_right.</td></tr></tbody></table><a id="more"></a><h1 id="sortedcollection">SortedCollection</h1><p>Python的高产贡献者Raymond Hettinger写了一个排序集合模块<a href="http://code.activestate.com/recipes/577197-sortedcollection/" target="_blank" rel="noopener">SortedCollection</a>，模块里集成了bisect功能，但是比独立的bisect更易用。</p><table><colgroup><col style="width: 33%"><col style="width: 66%"></colgroup><thead><tr class="header"><th>Method</th><th>Doc</th></tr></thead><tbody><tr class="odd"><td><code>def clear(self)</code></td><td></td></tr><tr class="even"><td><code>def copy(self)</code></td><td></td></tr><tr class="odd"><td><code>def index(self, item)</code></td><td>Find the position of an item. Raise ValueError if not found.</td></tr><tr class="even"><td><code>def count(self, item)</code></td><td>Return number of occurrences of item.</td></tr><tr class="odd"><td><code>def insert(self, item)</code></td><td>Insert a new item. If equal keys are found, add to the left.</td></tr><tr class="even"><td><code>def insert_right(self, item)</code></td><td>Insert a new item. If equal keys are found, add to the right.</td></tr><tr class="odd"><td><code>def remove(self, item)</code></td><td>Remove first occurence of item. Raise ValueError if not found.</td></tr><tr class="even"><td><code>def find(self, k)</code></td><td>Return first item with a key == k. Raise ValueError if not found.</td></tr><tr class="odd"><td><code>def find_le(self, k)</code></td><td>Return last item with a key &lt;= k. Raise ValueError if not found.</td></tr><tr class="even"><td><code>def find_lt(self, k)</code></td><td>Return last item with a key &lt; k. Raise ValueError if not found.</td></tr><tr class="odd"><td><code>def find_ge(self, k)</code></td><td>Return first item with a key &gt;= k. Raise ValueError if not found.</td></tr><tr class="even"><td><code>def find_gt(self, k)</code></td><td>Return first item with a key &gt; k. Raise ValueError if not found.</td></tr></tbody></table><h1 id="bisect源码">bisect源码</h1><figure class="highlight python"><figcaption><span>bisect.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="string">"""Bisection algorithms."""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insort_right</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="string">"""Insert item x in list a, and keep it sorted assuming a is sorted.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If x is already in a, insert it to the right of the rightmost x.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Optional args lo (default 0) and hi (default len(a)) bound the</span></span><br><span class="line"><span class="string">    slice of a to be searched.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; a[mid]: hi = mid</span><br><span class="line">        <span class="keyword">else</span>: lo = mid+<span class="number">1</span></span><br><span class="line">    a.insert(lo, x)</span><br><span class="line"></span><br><span class="line">insort = insort_right   <span class="comment"># backward compatibility</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bisect_right</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="string">"""Return the index where to insert item x in list a, assuming a is sorted.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The return value i is such that all e in a[:i] have e &lt;= x, and all e in</span></span><br><span class="line"><span class="string">    a[i:] have e &gt; x.  So if x already appears in the list, a.insert(x) will</span></span><br><span class="line"><span class="string">    insert just after the rightmost x already there.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Optional args lo (default 0) and hi (default len(a)) bound the</span></span><br><span class="line"><span class="string">    slice of a to be searched.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; a[mid]: hi = mid</span><br><span class="line">        <span class="keyword">else</span>: lo = mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> lo</span><br><span class="line"></span><br><span class="line">bisect = bisect_right   <span class="comment"># backward compatibility</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insort_left</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="string">"""Insert item x in list a, and keep it sorted assuming a is sorted.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If x is already in a, insert it to the left of the leftmost x.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Optional args lo (default 0) and hi (default len(a)) bound the</span></span><br><span class="line"><span class="string">    slice of a to be searched.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> a[mid] &lt; x: lo = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: hi = mid</span><br><span class="line">    a.insert(lo, x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bisect_left</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="string">"""Return the index where to insert item x in list a, assuming a is sorted.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The return value i is such that all e in a[:i] have e &lt; x, and all e in</span></span><br><span class="line"><span class="string">    a[i:] have e &gt;= x.  So if x already appears in the list, a.insert(x) will</span></span><br><span class="line"><span class="string">    insert just before the leftmost x already there.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Optional args lo (default 0) and hi (default len(a)) bound the</span></span><br><span class="line"><span class="string">    slice of a to be searched.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> a[mid] &lt; x: lo = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: hi = mid</span><br><span class="line">    <span class="keyword">return</span> lo</span><br><span class="line"></span><br><span class="line"><span class="comment"># Overwrite above definitions with a fast C implementation</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> _bisect <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h1 id="sortedcollection源码">SortedCollection源码</h1><figure class="highlight python"><figcaption><span>recipe-577197-1.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_left, bisect_right</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortedCollection</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''Sequence sorted by a key function.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    SortedCollection() is much easier to work with than using bisect() directly.</span></span><br><span class="line"><span class="string">    It supports key functions like those use in sorted(), min(), and max().</span></span><br><span class="line"><span class="string">    The result of the key function call is saved so that keys can be searched</span></span><br><span class="line"><span class="string">    efficiently.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Instead of returning an insertion-point which can be hard to interpret, the</span></span><br><span class="line"><span class="string">    five find-methods return a specific item in the sequence. They can scan for</span></span><br><span class="line"><span class="string">    exact matches, the last item less-than-or-equal to a key, or the first item</span></span><br><span class="line"><span class="string">    greater-than-or-equal to a key.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Once found, an item's ordinal position can be located with the index() method.</span></span><br><span class="line"><span class="string">    New items can be added with the insert() and insert_right() methods.</span></span><br><span class="line"><span class="string">    Old items can be deleted with the remove() method.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The usual sequence methods are provided to support indexing, slicing,</span></span><br><span class="line"><span class="string">    length lookup, clearing, copying, forward and reverse iteration, contains</span></span><br><span class="line"><span class="string">    checking, item counts, item removal, and a nice looking repr.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Finding and indexing are O(log n) operations while iteration and insertion</span></span><br><span class="line"><span class="string">    are O(n).  The initial sort is O(n log n).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The key function is stored in the 'key' attibute for easy introspection or</span></span><br><span class="line"><span class="string">    so that you can assign a new key function (triggering an automatic re-sort).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    In short, the class was designed to handle all of the common use cases for</span></span><br><span class="line"><span class="string">    bisect but with a simpler API and support for key functions.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; from pprint import pprint</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; from operator import itemgetter</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s = SortedCollection(key=itemgetter(2))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; for record in [</span></span><br><span class="line"><span class="string">    ...         ('roger', 'young', 30),</span></span><br><span class="line"><span class="string">    ...         ('angela', 'jones', 28),</span></span><br><span class="line"><span class="string">    ...         ('bill', 'smith', 22),</span></span><br><span class="line"><span class="string">    ...         ('david', 'thomas', 32)]:</span></span><br><span class="line"><span class="string">    ...     s.insert(record)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; pprint(list(s))         # show records sorted by age</span></span><br><span class="line"><span class="string">    [('bill', 'smith', 22),</span></span><br><span class="line"><span class="string">     ('angela', 'jones', 28),</span></span><br><span class="line"><span class="string">     ('roger', 'young', 30),</span></span><br><span class="line"><span class="string">     ('david', 'thomas', 32)]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s.find_le(29)           # find oldest person aged 29 or younger</span></span><br><span class="line"><span class="string">    ('angela', 'jones', 28)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s.find_lt(28)           # find oldest person under 28</span></span><br><span class="line"><span class="string">    ('bill', 'smith', 22)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s.find_gt(28)           # find youngest person over 28</span></span><br><span class="line"><span class="string">    ('roger', 'young', 30)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; r = s.find_ge(32)       # find youngest person aged 32 or older</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s.index(r)              # get the index of their record</span></span><br><span class="line"><span class="string">    3</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s[3]                    # fetch the record at that index</span></span><br><span class="line"><span class="string">    ('david', 'thomas', 32)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s.key = itemgetter(0)   # now sort by first name</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; pprint(list(s))</span></span><br><span class="line"><span class="string">    [('angela', 'jones', 28),</span></span><br><span class="line"><span class="string">     ('bill', 'smith', 22),</span></span><br><span class="line"><span class="string">     ('david', 'thomas', 32),</span></span><br><span class="line"><span class="string">     ('roger', 'young', 30)]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, iterable=<span class="params">()</span>, key=None)</span>:</span></span><br><span class="line">        self._given_key = key</span><br><span class="line">        key = (<span class="keyword">lambda</span> x: x) <span class="keyword">if</span> key <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> key</span><br><span class="line">        decorated = sorted((key(item), item) <span class="keyword">for</span> item <span class="keyword">in</span> iterable)</span><br><span class="line">        self._keys = [k <span class="keyword">for</span> k, item <span class="keyword">in</span> decorated]</span><br><span class="line">        self._items = [item <span class="keyword">for</span> k, item <span class="keyword">in</span> decorated]</span><br><span class="line">        self._key = key</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_getkey</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._key</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_setkey</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">is</span> <span class="keyword">not</span> self._key:</span><br><span class="line">            self.__init__(self._items, key=key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_delkey</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._setkey(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    key = property(_getkey, _setkey, _delkey, <span class="string">'key function'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__init__([], self._key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copy</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__class__(self, self._key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._items)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._items[i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self._items)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reversed__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> reversed(self._items)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'%s(%r, key=%s)'</span> % (</span><br><span class="line">            self.__class__.__name__,</span><br><span class="line">            self._items,</span><br><span class="line">            getattr(self._given_key, <span class="string">'__name__'</span>, repr(self._given_key))</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reduce__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__class__, (self._items, self._given_key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        k = self._key(item)</span><br><span class="line">        i = bisect_left(self._keys, k)</span><br><span class="line">        j = bisect_right(self._keys, k)</span><br><span class="line">        <span class="keyword">return</span> item <span class="keyword">in</span> self._items[i:j]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'Find the position of an item.  Raise ValueError if not found.'</span></span><br><span class="line">        k = self._key(item)</span><br><span class="line">        i = bisect_left(self._keys, k)</span><br><span class="line">        j = bisect_right(self._keys, k)</span><br><span class="line">        <span class="keyword">return</span> self._items[i:j].index(item) + i</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'Return number of occurrences of item'</span></span><br><span class="line">        k = self._key(item)</span><br><span class="line">        i = bisect_left(self._keys, k)</span><br><span class="line">        j = bisect_right(self._keys, k)</span><br><span class="line">        <span class="keyword">return</span> self._items[i:j].count(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'Insert a new item.  If equal keys are found, add to the left'</span></span><br><span class="line">        k = self._key(item)</span><br><span class="line">        i = bisect_left(self._keys, k)</span><br><span class="line">        self._keys.insert(i, k)</span><br><span class="line">        self._items.insert(i, item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_right</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'Insert a new item.  If equal keys are found, add to the right'</span></span><br><span class="line">        k = self._key(item)</span><br><span class="line">        i = bisect_right(self._keys, k)</span><br><span class="line">        self._keys.insert(i, k)</span><br><span class="line">        self._items.insert(i, item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'Remove first occurence of item.  Raise ValueError if not found'</span></span><br><span class="line">        i = self.index(item)</span><br><span class="line">        <span class="keyword">del</span> self._keys[i]</span><br><span class="line">        <span class="keyword">del</span> self._items[i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        <span class="string">'Return first item with a key == k.  Raise ValueError if not found.'</span></span><br><span class="line">        i = bisect_left(self._keys, k)</span><br><span class="line">        <span class="keyword">if</span> i != len(self) <span class="keyword">and</span> self._keys[i] == k:</span><br><span class="line">            <span class="keyword">return</span> self._items[i]</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'No item found with key equal to: %r'</span> % (k,))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_le</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        <span class="string">'Return last item with a key &lt;= k.  Raise ValueError if not found.'</span></span><br><span class="line">        i = bisect_right(self._keys, k)</span><br><span class="line">        <span class="keyword">if</span> i:</span><br><span class="line">            <span class="keyword">return</span> self._items[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'No item found with key at or below: %r'</span> % (k,))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_lt</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        <span class="string">'Return last item with a key &lt; k.  Raise ValueError if not found.'</span></span><br><span class="line">        i = bisect_left(self._keys, k)</span><br><span class="line">        <span class="keyword">if</span> i:</span><br><span class="line">            <span class="keyword">return</span> self._items[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'No item found with key below: %r'</span> % (k,))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_ge</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        <span class="string">'Return first item with a key &gt;= equal to k.  Raise ValueError if not found'</span></span><br><span class="line">        i = bisect_left(self._keys, k)</span><br><span class="line">        <span class="keyword">if</span> i != len(self):</span><br><span class="line">            <span class="keyword">return</span> self._items[i]</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'No item found with key at or above: %r'</span> % (k,))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_gt</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        <span class="string">'Return first item with a key &gt; k.  Raise ValueError if not found'</span></span><br><span class="line">        i = bisect_right(self._keys, k)</span><br><span class="line">        <span class="keyword">if</span> i != len(self):</span><br><span class="line">            <span class="keyword">return</span> self._items[i]</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'No item found with key above: %r'</span> % (k,))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------  Simple demo and tests  -------------------------</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ve2no</span><span class="params">(f, *args)</span>:</span></span><br><span class="line">        <span class="string">'Convert ValueError result to -1'</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> f(*args)</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">slow_index</span><span class="params">(seq, k)</span>:</span></span><br><span class="line">        <span class="string">'Location of match or -1 if not found'</span></span><br><span class="line">        <span class="keyword">for</span> i, item <span class="keyword">in</span> enumerate(seq):</span><br><span class="line">            <span class="keyword">if</span> item == k:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">slow_find</span><span class="params">(seq, k)</span>:</span></span><br><span class="line">        <span class="string">'First item with a key equal to k. -1 if not found'</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> seq:</span><br><span class="line">            <span class="keyword">if</span> item == k:</span><br><span class="line">                <span class="keyword">return</span> item</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">slow_find_le</span><span class="params">(seq, k)</span>:</span></span><br><span class="line">        <span class="string">'Last item with a key less-than or equal to k.'</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> reversed(seq):</span><br><span class="line">            <span class="keyword">if</span> item &lt;= k:</span><br><span class="line">                <span class="keyword">return</span> item</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">slow_find_lt</span><span class="params">(seq, k)</span>:</span></span><br><span class="line">        <span class="string">'Last item with a key less-than k.'</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> reversed(seq):</span><br><span class="line">            <span class="keyword">if</span> item &lt; k:</span><br><span class="line">                <span class="keyword">return</span> item</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">slow_find_ge</span><span class="params">(seq, k)</span>:</span></span><br><span class="line">        <span class="string">'First item with a key-value greater-than or equal to k.'</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> seq:</span><br><span class="line">            <span class="keyword">if</span> item &gt;= k:</span><br><span class="line">                <span class="keyword">return</span> item</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">slow_find_gt</span><span class="params">(seq, k)</span>:</span></span><br><span class="line">        <span class="string">'First item with a key-value greater-than or equal to k.'</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> seq:</span><br><span class="line">            <span class="keyword">if</span> item &gt; k:</span><br><span class="line">                <span class="keyword">return</span> item</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line">    pool = [<span class="number">1.5</span>, <span class="number">2</span>, <span class="number">2.0</span>, <span class="number">3</span>, <span class="number">3.0</span>, <span class="number">3.5</span>, <span class="number">4</span>, <span class="number">4.0</span>, <span class="number">4.5</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">500</span>):</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">            s = [choice(pool) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">            sc = SortedCollection(s)</span><br><span class="line">            s.sort()</span><br><span class="line">            <span class="keyword">for</span> probe <span class="keyword">in</span> pool:</span><br><span class="line">                <span class="keyword">assert</span> repr(ve2no(sc.index, probe)) == repr(slow_index(s, probe))</span><br><span class="line">                <span class="keyword">assert</span> repr(ve2no(sc.find, probe)) == repr(slow_find(s, probe))</span><br><span class="line">                <span class="keyword">assert</span> repr(ve2no(sc.find_le, probe)) == repr(slow_find_le(s, probe))</span><br><span class="line">                <span class="keyword">assert</span> repr(ve2no(sc.find_lt, probe)) == repr(slow_find_lt(s, probe))</span><br><span class="line">                <span class="keyword">assert</span> repr(ve2no(sc.find_ge, probe)) == repr(slow_find_ge(s, probe))</span><br><span class="line">                <span class="keyword">assert</span> repr(ve2no(sc.find_gt, probe)) == repr(slow_find_gt(s, probe))</span><br><span class="line">            <span class="keyword">for</span> i, item <span class="keyword">in</span> enumerate(s):</span><br><span class="line">                <span class="keyword">assert</span> repr(item) == repr(sc[i])        <span class="comment"># test __getitem__</span></span><br><span class="line">                <span class="keyword">assert</span> item <span class="keyword">in</span> sc                       <span class="comment"># test __contains__ and __iter__</span></span><br><span class="line">                <span class="keyword">assert</span> s.count(item) == sc.count(item)  <span class="comment"># test count()</span></span><br><span class="line">            <span class="keyword">assert</span> len(sc) == n                         <span class="comment"># test __len__</span></span><br><span class="line">            <span class="keyword">assert</span> list(map(repr, reversed(sc))) == list(map(repr, reversed(s)))    <span class="comment"># test __reversed__</span></span><br><span class="line">            <span class="keyword">assert</span> list(sc.copy()) == list(sc)          <span class="comment"># test copy()</span></span><br><span class="line">            sc.clear()                                  <span class="comment"># test clear()</span></span><br><span class="line">            <span class="keyword">assert</span> len(sc) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    sd = SortedCollection(<span class="string">'The quick Brown Fox jumped'</span>.split(), key=str.lower)</span><br><span class="line">    <span class="keyword">assert</span> sd._keys == [<span class="string">'brown'</span>, <span class="string">'fox'</span>, <span class="string">'jumped'</span>, <span class="string">'quick'</span>, <span class="string">'the'</span>]</span><br><span class="line">    <span class="keyword">assert</span> sd._items == [<span class="string">'Brown'</span>, <span class="string">'Fox'</span>, <span class="string">'jumped'</span>, <span class="string">'quick'</span>, <span class="string">'The'</span>]</span><br><span class="line">    <span class="keyword">assert</span> sd._key == str.lower</span><br><span class="line">    <span class="keyword">assert</span> repr(sd) == <span class="string">"SortedCollection(['Brown', 'Fox', 'jumped', 'quick', 'The'], key=lower)"</span></span><br><span class="line">    sd.key = str.upper</span><br><span class="line">    <span class="keyword">assert</span> sd._key == str.upper</span><br><span class="line">    <span class="keyword">assert</span> len(sd) == <span class="number">5</span></span><br><span class="line">    <span class="keyword">assert</span> list(reversed(sd)) == [<span class="string">'The'</span>, <span class="string">'quick'</span>, <span class="string">'jumped'</span>, <span class="string">'Fox'</span>, <span class="string">'Brown'</span>]</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> sd:</span><br><span class="line">        <span class="keyword">assert</span> item <span class="keyword">in</span> sd</span><br><span class="line">    <span class="keyword">for</span> i, item <span class="keyword">in</span> enumerate(sd):</span><br><span class="line">        <span class="keyword">assert</span> item == sd[i]</span><br><span class="line">    sd.insert(<span class="string">'jUmPeD'</span>)</span><br><span class="line">    sd.insert_right(<span class="string">'QuIcK'</span>)</span><br><span class="line">    <span class="keyword">assert</span> sd._keys ==[<span class="string">'BROWN'</span>, <span class="string">'FOX'</span>, <span class="string">'JUMPED'</span>, <span class="string">'JUMPED'</span>, <span class="string">'QUICK'</span>, <span class="string">'QUICK'</span>, <span class="string">'THE'</span>]</span><br><span class="line">    <span class="keyword">assert</span> sd._items == [<span class="string">'Brown'</span>, <span class="string">'Fox'</span>, <span class="string">'jUmPeD'</span>, <span class="string">'jumped'</span>, <span class="string">'quick'</span>, <span class="string">'QuIcK'</span>, <span class="string">'The'</span>]</span><br><span class="line">    <span class="keyword">assert</span> sd.find_le(<span class="string">'JUMPED'</span>) == <span class="string">'jumped'</span>, sd.find_le(<span class="string">'JUMPED'</span>)</span><br><span class="line">    <span class="keyword">assert</span> sd.find_ge(<span class="string">'JUMPED'</span>) == <span class="string">'jUmPeD'</span></span><br><span class="line">    <span class="keyword">assert</span> sd.find_le(<span class="string">'GOAT'</span>) == <span class="string">'Fox'</span></span><br><span class="line">    <span class="keyword">assert</span> sd.find_ge(<span class="string">'GOAT'</span>) == <span class="string">'jUmPeD'</span></span><br><span class="line">    <span class="keyword">assert</span> sd.find(<span class="string">'FOX'</span>) == <span class="string">'Fox'</span></span><br><span class="line">    <span class="keyword">assert</span> sd[<span class="number">3</span>] == <span class="string">'jumped'</span></span><br><span class="line">    <span class="keyword">assert</span> sd[<span class="number">3</span>:<span class="number">5</span>] ==[<span class="string">'jumped'</span>, <span class="string">'quick'</span>]</span><br><span class="line">    <span class="keyword">assert</span> sd[<span class="number">-2</span>] == <span class="string">'QuIcK'</span></span><br><span class="line">    <span class="keyword">assert</span> sd[<span class="number">-4</span>:<span class="number">-2</span>] == [<span class="string">'jumped'</span>, <span class="string">'quick'</span>]</span><br><span class="line">    <span class="keyword">for</span> i, item <span class="keyword">in</span> enumerate(sd):</span><br><span class="line">        <span class="keyword">assert</span> sd.index(item) == i</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sd.index(<span class="string">'xyzpdq'</span>)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="number">0</span>, <span class="string">'Oops, failed to notify of missing value'</span></span><br><span class="line">    sd.remove(<span class="string">'jumped'</span>)</span><br><span class="line">    <span class="keyword">assert</span> list(sd) == [<span class="string">'Brown'</span>, <span class="string">'Fox'</span>, <span class="string">'jUmPeD'</span>, <span class="string">'quick'</span>, <span class="string">'QuIcK'</span>, <span class="string">'The'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> doctest</span><br><span class="line">    <span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line">    print(doctest.testmod())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> bisect </tag>
            
            <tag> binary serch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>list.sort方法和内置函数sorted</title>
      <link href="/notes/fluent-python/list-sort-and-the-sorted-built-in-function/"/>
      <url>/notes/fluent-python/list-sort-and-the-sorted-built-in-function/</url>
      
        <content type="html"><![CDATA[<h1 id="python的一个惯例">Python的一个惯例</h1><p>如果一个函数或者方法对对象进行的是就地改动，那它就应该返回None，好让调用者知道传入的参数发生了变动，而且并未产生新的对象。例如，list.sort和random.shuffle函数。</p><h1 id="list.sort和sorted">list.sort和sorted</h1><blockquote><p><code>sort(*, key=None, reverse=False)</code></p></blockquote><blockquote><p><code>sorted(iterable, *, key=None, reverse=False)</code></p></blockquote><p>这两个函数都有两个可选的关键字参数。</p><ul><li><p>reverse：如果被设定为True，被排序的序列里的元素会以降序输出。默认值是False。</p></li><li><p>key：指定一个函数，这个函数会被用在序列里的每一个元素上，所产生的结果将是排序算法依赖的对比关键字。默认值是None，直接比较元素。</p></li></ul><p>sorted函数会新建一个列表作为返回值。这个方法可以接受任何形式的可迭代对象作为参数，甚至包括不可变序列或生成器。而不管接受的是怎样的参数，它最后都会返回一个列表。</p><a id="more"></a><h1 id="例">例</h1><p>参数使用例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits = [<span class="string">'grape'</span>, <span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'Grape'</span>, <span class="string">'Apple'</span>, <span class="string">'Banana'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits.sort()  <span class="comment"># 默认</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits  <span class="comment"># 参数本身改变了</span></span><br><span class="line">[<span class="string">'Apple'</span>, <span class="string">'Banana'</span>, <span class="string">'Grape'</span>, <span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'grape'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits.sort(reverse=<span class="literal">True</span>)  <span class="comment"># 降序</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits</span><br><span class="line">[<span class="string">'grape'</span>, <span class="string">'banana'</span>, <span class="string">'apple'</span>, <span class="string">'Grape'</span>, <span class="string">'Banana'</span>, <span class="string">'Apple'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits.sort(key=len)  <span class="comment"># 按照字符串长度排序</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits</span><br><span class="line">[<span class="string">'grape'</span>, <span class="string">'apple'</span>, <span class="string">'Grape'</span>, <span class="string">'Apple'</span>, <span class="string">'banana'</span>, <span class="string">'Banana'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits.sort(key=str.lower)  <span class="comment"># 按照小写字母的大小排序</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits</span><br><span class="line">[<span class="string">'apple'</span>, <span class="string">'Apple'</span>, <span class="string">'banana'</span>, <span class="string">'Banana'</span>, <span class="string">'grape'</span>, <span class="string">'Grape'</span>]</span><br></pre></td></tr></table></figure><p>sorted函数使用例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits = [<span class="string">'grape'</span>, <span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'Grape'</span>, <span class="string">'Apple'</span>, <span class="string">'Banana'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = sorted(fruits)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits  <span class="comment"># 参数不变</span></span><br><span class="line">[<span class="string">'grape'</span>, <span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'Grape'</span>, <span class="string">'Apple'</span>, <span class="string">'Banana'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r  <span class="comment"># 返回一个新列表</span></span><br><span class="line">[<span class="string">'Apple'</span>, <span class="string">'Banana'</span>, <span class="string">'Grape'</span>, <span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'grape'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = sorted(fruits)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r1 = sorted(tuple(fruits))  <span class="comment"># 参数是不可变序列（元组）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r2 = sorted(set(fruits))  <span class="comment"># 参数是集合</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r == r1 == r2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = [(<span class="string">'amily'</span>, <span class="number">12</span>), (<span class="string">'william'</span>, <span class="number">17</span>), (<span class="string">'joseph'</span>, <span class="number">16</span>), (<span class="string">'olivia'</span>, <span class="number">13</span>), (<span class="string">'amily'</span>, <span class="number">11</span>), (<span class="string">'olivia'</span>, <span class="number">17</span>)]  <span class="comment"># (name, age)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = sorted(m)  <span class="comment"># 默认参数：按name升序排列，name完全一样，按age升序排列</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r</span><br><span class="line">[(<span class="string">'amily'</span>, <span class="number">11</span>), (<span class="string">'amily'</span>, <span class="number">12</span>), (<span class="string">'joseph'</span>, <span class="number">16</span>), (<span class="string">'olivia'</span>, <span class="number">13</span>), (<span class="string">'olivia'</span>, <span class="number">17</span>), (<span class="string">'william'</span>, <span class="number">17</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = sorted(m, key=<span class="keyword">lambda</span> i: i[<span class="number">1</span>])  <span class="comment"># 按年龄</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r</span><br><span class="line">[(<span class="string">'amily'</span>, <span class="number">11</span>), (<span class="string">'amily'</span>, <span class="number">12</span>), (<span class="string">'olivia'</span>, <span class="number">13</span>), (<span class="string">'joseph'</span>, <span class="number">16</span>), (<span class="string">'william'</span>, <span class="number">17</span>), (<span class="string">'olivia'</span>, <span class="number">17</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = sorted(m, key=<span class="keyword">lambda</span> i: (i[<span class="number">1</span>], i[<span class="number">0</span>]))  <span class="comment"># 先按年龄排序，年龄相同时按名字排序</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r</span><br><span class="line">[(<span class="string">'amily'</span>, <span class="number">11</span>), (<span class="string">'amily'</span>, <span class="number">12</span>), (<span class="string">'olivia'</span>, <span class="number">13</span>), (<span class="string">'joseph'</span>, <span class="number">16</span>), (<span class="string">'olivia'</span>, <span class="number">17</span>), (<span class="string">'william'</span>, <span class="number">17</span>)]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> sorted </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>切片</title>
      <link href="/notes/fluent-python/slicing/"/>
      <url>/notes/fluent-python/slicing/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么切片和区间会忽略最后一个元素">为什么切片和区间会忽略最后一个元素</h1><p>在切片和区间操作里不包含区间范围的最后一个元素是Python的风格，这个习惯符合Python、C和其他语言里以0作为起始下标的传统。这样做带来的好处如下。</p><ul><li>当只有最后一个位置信息时，可以快速看出切片和区间里有几个元素：range(3)和my_list[:3]都返回3个元素。</li><li>当起止位置信息都可见时，可以快速计算出切片和区间的长度，用后一个数减去第一个下标(stop - start)即可。</li><li>可以利用任意一个下标来把序列分割成不重叠的两部分，只要写成my_list[:x]和my_list[x:]就可以了。</li></ul><h1 id="切片示例">切片示例</h1><p>在Python里，像列表（list）、元组（tuple）和字符串（str）这类序列类型都支持切片操作。</p><p>常用用法：<code>my_list[start:stop]</code></p><p>理解：取出下标从start到stop - 1之间的所有元素，组成新列表。</p><p>相当于：<code>[my_list[i] for i in range(start, stop)]</code></p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>li = list(range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[<span class="number">0</span>:len(li)]  <span class="comment"># 拷贝整个列表</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[:]  <span class="comment"># 常用写法，更简单易读</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[<span class="number">1</span>:]  <span class="comment"># 从第1个元素切到最后一个元素</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[:<span class="number">5</span>]  <span class="comment"># 从第0个元素切到第4个元素</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[<span class="number">1</span>:<span class="number">5</span>] <span class="comment"># 从第0个元素切到第4个元素</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>更高级的：<code>my_list[start:stop:step]</code></p><p>理解：将my_list[start:stop]按序分组，每组step个元素，取出每组的第1个元素组成新列表。</p><p>相当于：<code>[my_list[i] for i in range(start, stop, step)]</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[::<span class="number">1</span>]  <span class="comment"># 等价于 li[:]</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[::<span class="number">3</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[::<span class="number">-1</span>] <span class="comment"># step可以为负值，负值意味着反向取值</span></span><br><span class="line">[<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[<span class="number">5</span>:<span class="number">1</span>:<span class="number">-2</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><h1 id="切片对象">切片对象</h1><blockquote><p><code>class slice(stop)</code></p></blockquote><blockquote><p><code>class slice(start, stop[, step])</code></p></blockquote><p><code>a:b:c</code>这种用法只能作为索引或者下标用在[]中来返回一个切片对象：slice(a, b, c)。在对seq[start:stop:step]进行求值的时候，Python会调用<code>seq.__getitem__(slice(start, stop, step))</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>first_five = slice(<span class="number">5</span>)  <span class="comment"># 1个参数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[first_five]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>last_five = slice(len(li) - <span class="number">5</span>, len(li))  <span class="comment"># 2个参数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[last_five]</span><br><span class="line">[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>odd = slice(<span class="number">1</span>, len(li), <span class="number">2</span>)  <span class="comment"># 全部3个参数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[odd]</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><h1 id="给切片赋值">给切片赋值</h1><p>如果把切片放在赋值语句的左边，或把它作为del操作的对象，我们就可以对序列进行嫁接、切除或就地修改操作。</p><p>如果赋值的对象是一个切片，那么赋值语句的右侧必须是个可迭代对象。即便只有单独一个值，也要把它转换成可迭代的序列。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[<span class="number">2</span>:<span class="number">3</span>] = <span class="number">-2</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: can only assign an iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[<span class="number">2</span>:<span class="number">3</span>] = [<span class="number">-2</span>]  <span class="comment"># 必须可迭代</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[<span class="number">0</span>:<span class="number">6</span>] = [<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>, <span class="number">-4</span>, <span class="number">-5</span>]  <span class="comment"># 切除前6个元素，嫁接5个新元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li</span><br><span class="line">[<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>, <span class="number">-4</span>, <span class="number">-5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li = list(range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[<span class="number">2</span>::<span class="number">2</span>] = [<span class="number">-2</span>, <span class="number">-4</span>, <span class="number">-6</span>, <span class="number">-8</span>]  <span class="comment"># 偶数改为负值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">3</span>, <span class="number">-4</span>, <span class="number">5</span>, <span class="number">-6</span>, <span class="number">7</span>, <span class="number">-8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> li[<span class="number">1</span>::<span class="number">2</span>]  <span class="comment"># 删除奇数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li</span><br><span class="line">[<span class="number">0</span>, <span class="number">-2</span>, <span class="number">-4</span>, <span class="number">-6</span>, <span class="number">-8</span>]</span><br></pre></td></tr></table></figure><h1 id="多维切片和省略">多维切片和省略</h1><p>[]运算符里还可以使用逗号分开的多个索引或者是切片，外部库NumPy里就用到了这个特性，二维的numpy.ndarray就可以用a[i, j]这种形式来获取，抑或是a[m:n, k:l]的方式来得到二维切片。要正确处理这种[]运算符的话，对象的特殊方法<code>__getitem__</code>和<code>__setitem__</code>需要以元组的形式来接收a[i, j]中的索引。也就是说，如果要得到a[i, j]的值，Python会调用<code>a.__getitem__((i, j))</code>。</p><p>Python内置的序列类型都是一维的，因此它们只支持单一的索引，成对出现的索引是没有用的。</p><p>省略（ellipsis）的正确书写方法是三个英文句号（<code>...</code>）。省略在Python解释器眼里是一个符号，而实际上它是Ellipsis对象的别名，而Ellipsis对象又是ellipsis类的单一实例（是的，你没看错，ellipsis是类名，全小写，而它的内置实例写作Ellipsis。这其实跟bool是小写，但是它的两个实例写作True和False异曲同工）。它可以当作切片规范的一部分，也可以用在函数的参数清单中，比如<code>f(a, ..., z)</code>，或<code>a[i:...]</code>。在NumPy中，<code>...</code>用作多维数组切片的快捷方式。如果x是四维数组，那么<code>x[i,...]</code>就是<code>x[i, :, :, :]</code>的缩写。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">12</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(a)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">numpy</span>.<span class="title">ndarray</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">a</span>.<span class="title">shape</span>  # 查看维度</span></span><br><span class="line"><span class="class"><span class="params">(<span class="number">12</span>,)</span>  # 一维的含有12个元素的数组</span></span><br><span class="line">&gt;&gt;&gt; a.shape = 3, 4  # 将其转换为一个二维的数组</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.shape</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)  <span class="comment"># 二维，各维度分别含有3、4个元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>, <span class="number">1</span>]  <span class="comment"># 等价于a[0][1]</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>:, <span class="number">2</span>:]</span><br><span class="line">array([[ <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.shape = <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>  <span class="comment"># 转换为三维数组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>],</span><br><span class="line">        [ <span class="number">2</span>,  <span class="number">3</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">        [ <span class="number">6</span>,  <span class="number">7</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">11</span>]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>:, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">array([<span class="number">5</span>, <span class="number">9</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>, <span class="built_in">Ellipsis</span>]  <span class="comment"># 完整的取出第1个维度的1号元素</span></span><br><span class="line">array([[<span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">6</span>, <span class="number">7</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>...</span><br><span class="line"><span class="built_in">Ellipsis</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>, ...]  <span class="comment"># 完整的取出第1个维度的1号元素</span></span><br><span class="line">array([[<span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">6</span>, <span class="number">7</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>, :, :]</span><br><span class="line">array([[<span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">6</span>, <span class="number">7</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[..., <span class="number">1</span>]  <span class="comment"># 取出最后1个维度的1号元素</span></span><br><span class="line">array([[ <span class="number">1</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">5</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">9</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[..., <span class="number">1</span>, ...]  <span class="comment"># 不能包含多个ellipsis</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">IndexError: an index can only have a single ellipsis (<span class="string">'...'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> slicing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python map filter函数</title>
      <link href="/programming/python-map-filter-functions/"/>
      <url>/programming/python-map-filter-functions/</url>
      
        <content type="html"><![CDATA[<h1 id="map">map</h1><blockquote><p><code>map(function, iterable, ...)</code></p></blockquote><p>将 <code>iterable</code> 中的元素依次传入 <code>function</code>，返回 <code>function</code> 的返回值。大致相当于</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span><span class="params">(function, *iterable)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> zip(*iterable):</span><br><span class="line">        <span class="keyword">yield</span> function(*e)</span><br></pre></td></tr></table></figure><a id="more"></a><p>例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(int, <span class="string">'0123456789'</span>))  <span class="comment"># 类型转换</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(<span class="keyword">lambda</span> x, y: x + y, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))  <span class="comment"># 对应两数相加</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]                     <span class="comment"># 当列表长度不一致时，按照最小的那个长度算</span></span><br></pre></td></tr></table></figure><p>可以用列表解析实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[int(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">'0123456789'</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x + y <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(range(<span class="number">1</span>, <span class="number">6</span>), range(<span class="number">1</span>, <span class="number">5</span>))]</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure><h1 id="filter">filter</h1><blockquote><p><code>filter(function, iterable)</code></p></blockquote><p>将 <code>iterable</code> 中的元素依次传入 <code>function</code>，返回 <code>function</code> 的返回值为真时的元素。</p><p>当 <code>function != None</code> 时，相当于 <code>(item for item in iterable if function(item))</code>；</p><p>当 <code>function == None</code> 时，相当于 <code>(item for item in iterable if item)</code>。</p><p>例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, range(<span class="number">11</span>)))  <span class="comment"># 返回10以下的偶数</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><h1 id="组合使用">组合使用</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(str, filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span> ==<span class="number">0</span>, range(<span class="number">10</span>))))  <span class="comment"># map/filter组合</span></span><br><span class="line">[<span class="string">'0'</span>, <span class="string">'2'</span>, <span class="string">'4'</span>, <span class="string">'6'</span>, <span class="string">'8'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[str(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>]  <span class="comment"># 列表解析</span></span><br><span class="line">[<span class="string">'0'</span>, <span class="string">'2'</span>, <span class="string">'4'</span>, <span class="string">'6'</span>, <span class="string">'8'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, map(int, <span class="string">'0123456789'</span>)))</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[int(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">'0123456789'</span> <span class="keyword">if</span> int(i) % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用特殊方法</title>
      <link href="/notes/fluent-python/how-special-methods-are-used/"/>
      <url>/notes/fluent-python/how-special-methods-are-used/</url>
      
        <content type="html"><![CDATA[<p>不管在哪种框架下写程序，都会花费大量时间去实现那些会被框架本身调用的方法，Python也不例外。Python解释器碰到特殊的句法时，会使用特殊方法去激活一些基本的对象操作，这些特殊方法的名字以两个下划线开头，以两个下划线结尾(例如<code>__getitem__</code>)。比如obj[key]的背后就是<code>__getitem__</code>方法，为了能求得my_collection[key]的值，解释器实际上会调用<code>my_collection.__getitem__(key)</code>。</p><p>这些特殊方法名能让你自己的对象实现和支持以下的语言架构，并与之交互：</p><ul><li>迭代</li><li>集合类</li><li>属性访问</li><li>运算符重载</li><li>函数和方法的调用</li><li>对象的创建和销毁</li><li>字符串表示形式和格式化</li><li>管理上下文（即with块）</li></ul><a id="more"></a><h1 id="一摞python风格的纸牌">一摞Python风格的纸牌</h1><figure class="highlight python"><figcaption><span>french_deck.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">Card = collections.namedtuple(<span class="string">'Card'</span>, [<span class="string">'rank'</span>, <span class="string">'suit'</span>])</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrenchDeck</span>:</span></span><br><span class="line">    ranks = [str(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">11</span>)] + list(<span class="string">'JQKA'</span>)</span><br><span class="line">    suits = <span class="string">'spades diamonds clubs hearts'</span>.split()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'__init__'</span>)</span><br><span class="line">        self._cards = [Card(rank, suit) <span class="keyword">for</span> suit <span class="keyword">in</span> self.suits</span><br><span class="line">                       <span class="keyword">for</span> rank <span class="keyword">in</span> self.ranks]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'__len__'</span>)</span><br><span class="line">        <span class="keyword">return</span> len(self._cards)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        print(<span class="string">'__getitem__'</span>)</span><br><span class="line">        <span class="keyword">return</span> self._cards[item]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        print(<span class="string">'__setitem__'</span>)</span><br><span class="line">        self._cards[key] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'__iter__'</span>)</span><br><span class="line"></span><br><span class="line">suit_values = dict(spades=<span class="number">3</span>, hearts=<span class="number">2</span>, diamonds=<span class="number">1</span>, clubs=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spades_high</span><span class="params">(card)</span>:</span></span><br><span class="line">    <span class="comment"># 按照常规，用点数来判定扑克牌的大小，2 最小、A 最大；</span></span><br><span class="line">    <span class="comment"># 同时还要加上对花色的判定，黑桃最大、红桃次之、方块再次、梅花最小。</span></span><br><span class="line">    rank_value = FrenchDeck.ranks.index(card.rank)</span><br><span class="line">    <span class="keyword">return</span> rank_value * len(suit_values) + suit_values[card.suit]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> french_deck <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> random <span class="keyword">import</span> choice, randrange</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck = FrenchDeck()  <span class="comment"># 初始化</span></span><br><span class="line">__init__</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(deck)  <span class="comment"># len</span></span><br><span class="line">__len__</span><br><span class="line"><span class="number">52</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[<span class="number">0</span>]  <span class="comment"># 下标访问</span></span><br><span class="line">__getitem__</span><br><span class="line">Card(rank=<span class="string">'2'</span>, suit=<span class="string">'spades'</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>choice(deck)  <span class="comment"># 随机抽取</span></span><br><span class="line">__len__</span><br><span class="line">__getitem__</span><br><span class="line">Card(rank=<span class="string">'K'</span>, suit=<span class="string">'diamonds'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[randrange(<span class="number">0</span>, len(deck))]  <span class="comment"># 随机抽取等价替代</span></span><br><span class="line">__len__</span><br><span class="line">__getitem__</span><br><span class="line">Card(rank=<span class="string">'8'</span>, suit=<span class="string">'clubs'</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> card <span class="keyword">in</span> deck:  <span class="comment"># 迭代，无需调用__len__方法</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line">__getitem__</span><br><span class="line"><span class="comment"># 中间全都是__getitem__ #</span></span><br><span class="line">__getitem__</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[<span class="number">-2</span>:]  <span class="comment"># 切片，注意只调用一次__getitem__方法</span></span><br><span class="line">__getitem__</span><br><span class="line">[Card(rank=<span class="string">'K'</span>, suit=<span class="string">'hearts'</span>), Card(rank=<span class="string">'A'</span>, suit=<span class="string">'hearts'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[<span class="number">12</span>::<span class="number">13</span>]  <span class="comment"># 从第12张牌开始，每隔13张取一张牌</span></span><br><span class="line">__getitem__</span><br><span class="line">[Card(rank=<span class="string">'A'</span>, suit=<span class="string">'spades'</span>), Card(rank=<span class="string">'A'</span>, suit=<span class="string">'diamonds'</span>), Card(rank=<span class="string">'A'</span>, suit=<span class="string">'clubs'</span>), Card(rank=<span class="string">'A'</span>, suit=<span class="string">'hearts'</span>)]</span><br></pre></td></tr></table></figure><p>迭代通常是隐式的，譬如说一个集合类型没有实现<code>__contains__</code>方法，那么in运算符就会按顺序做一次迭代搜索。于是，in运算符可以用在我们的FrenchDeck类上，因为它是可迭代的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[<span class="number">2</span>]</span><br><span class="line">__getitem__</span><br><span class="line">Card(rank=<span class="string">'4'</span>, suit=<span class="string">'spades'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Card(<span class="string">'4'</span>, <span class="string">'spades'</span>) <span class="keyword">in</span> deck  <span class="comment"># in，没有实现__contains__方式时，按顺序查找</span></span><br><span class="line">__getitem__</span><br><span class="line">__getitem__</span><br><span class="line">__getitem__</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> card <span class="keyword">in</span> sorted(deck, key=spades_high):  <span class="comment"># sorted</span></span><br><span class="line"><span class="meta">... </span>    print(card)</span><br><span class="line">...</span><br><span class="line">__len__</span><br><span class="line">__getitem__</span><br><span class="line"><span class="comment"># 省略 #</span></span><br><span class="line">__getitem__</span><br><span class="line">Card(rank=<span class="string">'2'</span>, suit=<span class="string">'clubs'</span>)</span><br><span class="line">Card(rank=<span class="string">'2'</span>, suit=<span class="string">'diamonds'</span>)</span><br><span class="line"><span class="comment"># 省略 #</span></span><br><span class="line">Card(rank=<span class="string">'A'</span>, suit=<span class="string">'hearts'</span>)</span><br><span class="line">Card(rank=<span class="string">'A'</span>, suit=<span class="string">'spades'</span>)</span><br></pre></td></tr></table></figure><p>虽然FrenchDeck隐式地继承了object类，但功能却不是继承而来的。我们通过数据模型和一些合成来实现这些功能。通过实现<code>__len__</code>和<code>__getitem__</code>这两个特殊方法，FrenchDeck就跟一个Python自有的序列数据类型一样，可以体现出Python的核心语言特性（例如迭代和切片）。同时这个类还可以用于标准库中诸如random.choice、reversed和sorted这些函数。另外，对合成的运用使得<code>__len__</code>和<code>__getitem__</code>的具体实现可以代理给self._cards这个Python列表（即list对象）。</p><table><thead><tr class="header"><th>操作</th><th>底层支持</th></tr></thead><tbody><tr class="odd"><td>初始化</td><td><code>__init__</code></td></tr><tr class="even"><td>获取长度</td><td><code>__len__</code></td></tr><tr class="odd"><td>下标访问</td><td><code>__getitem__</code></td></tr><tr class="even"><td>随机抽取</td><td><code>__len__</code>, <code>__getitem__</code></td></tr><tr class="odd"><td>查询</td><td><code>__getitem__</code>（没有实现<code>__contains__</code>方法时，in运算符会做一次顺序搜索）</td></tr><tr class="even"><td>迭代</td><td><code>__getitem__</code>（调用次数与迭代次数有关，神奇的是不需要调用<code>__len__</code>）</td></tr><tr class="odd"><td>切片</td><td><code>__getitem__</code>（只调用一次，同样不需要调用<code>__len__</code>）</td></tr><tr class="even"><td>排序</td><td><code>__len__</code>（一次）, <code>__getitem__</code>（调用次数与迭代次数有关）</td></tr></tbody></table><h1 id="如何使用特殊方法">如何使用特殊方法</h1><p>首先明确一点，特殊方法的存在是为了被Python解释器调用的，你自己并不需要调用它们。也就是说没有<code>my_object.__len__()</code>这种写法，而应该使用len(my_object)。在执行len(my_object)的时候，如果my_object是一个自定义类的对象，那么Python会自己去调用其中由你实现的<code>__len__</code>方法。</p><p>然而如果是Python内置的类型，比如列表(list)、字符串(str)、字节序列(bytearray)等，那么CPython会抄个近路，<code>__len__</code>实际上会直接返回PyVarObject里的ob_size属性。PyVarObject是表示内存中长度可变的内置对象的C语言结构体。直接读取这个值比调用一个方法要快很多。</p><p>很多时候，特殊方法的调用是隐式的，比如for i in x这个语句，背后其实用的是iter(x)，而这个函数的背后则是<code>x.__iter__()</code>方法。当然<strong>前提</strong>是这个方法在x中被实现了。</p><p>通常你的代码无需直接使用特殊方法。除非有大量的元编程存在，直接调用特殊方法的频率应该远远低于你去实现它们的次数。唯一的例外可能是<code>__init__</code>方法，你的代码里可能经常会用到它，目的是在你自己的子类的<code>__init__</code>方法中调用超类的构造器。</p><p>通过内置的函数（例如len、iter、str，等等）来使用特殊方法是最好的选择。这些内置函数不仅会调用特殊方法，通常还提供额外的好处，而且对于内置的类来说，它们的速度更快。</p><p>不要自己想当然地随意添加特殊方法，比如<code>__foo__</code>之类的，因为虽然现在这个名字没有被Python内部使用，以后就不一定了。</p><h2 id="模拟数值类型">模拟数值类型</h2><p><img src="/uploads/image/fluent-python/example-of-2d-vector-addition.png" title="一个二维向量加法的例子"></p><p>一个二维向量加法的例子，Vector(2, 4) + Vector(2, 1) = Vector(4, 5)</p><p>向量加法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v2 = Vector(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + v2</span><br><span class="line">Vector(<span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>向量的模：abs是一个内置函数，如果输入是整数或者浮点数，它返回的是输入值的绝对值；如果输入是复数(complex number)，那么返回这个复数的模。为了保持一致性，我们的API在碰到abs函数的时候，也应该返回该向量的模。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v = Vector(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>abs(v)</span><br><span class="line"><span class="number">5.0</span></span><br></pre></td></tr></table></figure><p>标量乘法（即向量与数的乘法，得到的结果向量的方向与原向量一致，模变大）：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v * <span class="number">3</span></span><br><span class="line">Vector(<span class="number">9</span>, <span class="number">12</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>abs(v * <span class="number">3</span>)</span><br><span class="line"><span class="number">15.0</span></span><br></pre></td></tr></table></figure><h2 id="实现">实现</h2><figure class="highlight python"><figcaption><span>vector.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> hypot</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x=<span class="number">0</span>, y=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Vector(%r, %r)'</span> % (self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> hypot(self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(self.x <span class="keyword">or</span> self.y)  <span class="comment"># 更高效</span></span><br><span class="line">        <span class="comment"># return bool(abs(self))</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        x = self.x + other.x</span><br><span class="line">        y = self.y + other.y</span><br><span class="line">        <span class="keyword">return</span> Vector(x, y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, scalar)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Vector(self.x * scalar, self.y * scalar)</span><br></pre></td></tr></table></figure><h2 id="自定义的布尔值">自定义的布尔值</h2><p>尽管Python里有bool类型，但实际上任何对象都可以用于需要布尔值的上下文中（比如if或while语句，或者and、or和not运算符）。为了判定一个值x为真还是为假，Python会调用bool(x)，这个函数只能返回True或者False。</p><p>默认情况下，我们自己定义的类的实例总被认为是真的，除非这个类对<code>__bool__</code>或者<code>__len__</code>函数有自己的实现。bool(x)的背后是调用<code>x.__bool__()</code>的结果；如果不存在<code>__bool__</code>方法，那么bool(x)会尝试调用<code>x.__len__()</code>。若返回0，则bool会返回False；否则返回True。</p><table><thead><tr class="header"><th>操作</th><th>底层支持</th></tr></thead><tbody><tr class="odd"><td>取绝对值或取模</td><td><code>__abs__</code></td></tr><tr class="even"><td>布尔运算</td><td><code>__bool__</code>（优先调用），<code>__len__</code>（不存在<code>__bool__</code>时调用）</td></tr><tr class="odd"><td>加法</td><td><code>__add__</code></td></tr><tr class="even"><td>乘法</td><td><code>__mul__</code></td></tr></tbody></table><h1 id="特殊方法一览">特殊方法一览</h1><p>Python语言参考手册中的<a href="https://docs.python.org/3/reference/datamodel.html" target="_blank" rel="noopener">“Data Model”</a>一章列出了83个特殊方法的名字，其中47个用于实现算术运算、位运算和比较操作。</p><h2 id="跟运算无关的特殊方法">跟运算无关的特殊方法</h2><table><thead><tr class="header"><th>类别</th><th>方法名</th></tr></thead><tbody><tr class="odd"><td>字符串 / 字节序列表示形式</td><td><code>__repr__</code>、<code>__str__</code>、<code>__format__</code>、<code>__bytes__</code></td></tr><tr class="even"><td>数值转换</td><td><code>__abs__</code>、<code>__bool__</code>、<code>__complex__</code>、<code>__int__</code>、<code>__float__</code>、<code>__hash__</code>、<code>__index__</code></td></tr><tr class="odd"><td>集合模拟</td><td><code>__len__</code>、<code>__getitem__</code>、<code>__setitem__</code>、<code>__delitem__</code>、<code>__contains__</code></td></tr><tr class="even"><td>迭代枚举</td><td><code>__iter__</code>、<code>__reversed__</code>、<code>__next__</code></td></tr><tr class="odd"><td>可调用模拟</td><td><code>__call__</code></td></tr><tr class="even"><td>上下文管理</td><td><code>__enter__</code>、<code>__exit__</code></td></tr><tr class="odd"><td>实例创建和销毁</td><td><code>__new__</code>、<code>__init__</code>、<code>__del__</code></td></tr><tr class="even"><td>属性管理</td><td><code>__getattr__</code>、<code>__getattribute__</code>、<code>__setattr__</code>、<code>__delattr__</code>、<code>__dir__</code></td></tr><tr class="odd"><td>属性描述符</td><td><code>__get__</code>、<code>__set__</code>、<code>__delete__</code></td></tr><tr class="even"><td>跟类相关的服务</td><td><code>__prepare__</code>、<code>__instancecheck__</code>、<code>__subclasscheck__</code></td></tr></tbody></table><h2 id="跟运算符相关的特殊方法">跟运算符相关的特殊方法</h2><table><colgroup><col style="width: 23%"><col style="width: 76%"></colgroup><thead><tr class="header"><th>类别</th><th>方法名和对应的运算符</th></tr></thead><tbody><tr class="odd"><td>一元运算符</td><td><code>__neg__ -</code>、<code>__pos__ +</code>、<code>__abs__ abs()</code></td></tr><tr class="even"><td>比较运算符</td><td><code>__lt__ &lt;</code>、<code>__le__ &lt;=</code>、<code>__eq__ ==</code>、<code>__ne__ !=</code>、<code>__gt__ &gt;</code>、<code>__ge__ &gt;=</code></td></tr><tr class="odd"><td>算术运算符</td><td><code>__add__ +</code>、<code>__sub__ -</code>、<code>__mul__ *</code>、<code>__truediv__ /</code>、<code>__floordiv__ //</code>、<code>__mod__ %</code>、<code>__divmod__ divmod()</code>、<code>__pow__ **</code>或<code>pow()</code>、<code>__round__ round()</code></td></tr><tr class="even"><td>反向算术运算符</td><td><code>__radd__</code>、<code>__rsub__</code>、<code>__rmul__</code>、<code>__rtruediv__</code>、 <code>__rfloordiv__</code>、<code>__rmod__</code>、<code>__rdivmod__</code>、<code>__rpow__</code></td></tr><tr class="odd"><td>增量赋值算术运算符</td><td><code>__iadd__</code>、<code>__isub__</code>、<code>__imul__</code>、<code>__itruediv__</code>、 <code>__ifloordiv__</code>、<code>__imod__</code>、<code>__ipow__</code></td></tr><tr class="even"><td>位运算符</td><td><code>__invert__ ~</code>、<code>__lshift__ &lt;&lt;</code>、<code>__rshift__ &gt;&gt;</code>、<code>__and__ &amp;</code>、<code>__or__ |</code>、<code>__xor__ ^</code></td></tr><tr class="odd"><td>反向位运算符</td><td><code>__rlshift__</code>、<code>__rrshift__</code>、<code>__rand__</code>、<code>__rxor__</code>、<code>__ror__</code></td></tr><tr class="even"><td>增量赋值位运算符</td><td><code>__ilshift__</code>、<code>__irshift__</code>、<code>__iand__</code>、<code>__ixor__</code>、<code>__ior__</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> special methods </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jupyter Notebook ModuleNotFoundError</title>
      <link href="/programming/jupyter-notebook-ModuleNotFoundError/"/>
      <url>/programming/jupyter-notebook-ModuleNotFoundError/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_34650787/article/details/83304080" target="_blank" rel="noopener">点击查看原文</a></p><p>可能原因：安装了多个Python版本，终端和Jupyter Notebook使用的不是同一个Python。</p><p>在Terminal和Jupyter Notebook中分别执行</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.executable</span><br></pre></td></tr></table></figure><p>比较各自的输出路径。若不相同，例如</p><p>Terminal：<code>/Users/cws/opt/anaconda3/bin/python</code></p><p>Notebook：<code>/usr/local/bin/python3.6</code></p><p>则可按照下述操作解决此问题。打开Terminal，</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(base) MacBook-Pro:~ cws$ jupyter kernelspec list</span><br><span class="line">Available kernels:  <span class="comment"># 列出所有内核</span></span><br><span class="line">  python36    /Users/cws/Library/Jupyter/kernels/python36</span><br><span class="line">  python3     /Library/Frameworks/Python.framework/Versions/<span class="number">3.6</span>/share/jupyter/kernels/python3</span><br></pre></td></tr></table></figure><p>根据自己正在使用的内核，例如python3，进入对应目录/Library/.../python3，修改配置文件kernel.json</p><figure class="highlight diff"><figcaption><span>kernel.json</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> "argv": [</span><br><span class="line"><span class="deletion">- "python",</span></span><br><span class="line"><span class="addition">+ "/Users/cws/opt/anaconda3/bin/python",</span></span><br><span class="line">  "-m",</span><br><span class="line">  "ipykernel_launcher",</span><br><span class="line">  "-f",</span><br><span class="line">  "&#123;connection_file&#125;"</span><br><span class="line"> ],</span><br><span class="line"> "display_name": "Python 3",</span><br><span class="line"> "language": "python"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后保存，重启Notebook。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> jupyter notebook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树</title>
      <link href="/notes/introduction-to-algorithms/red-black-trees/"/>
      <url>/notes/introduction-to-algorithms/red-black-trees/</url>
      
        <content type="html"><![CDATA[<h1 id="红黑树">红黑树</h1><p>红黑树（red-black tree）是一棵二叉搜索树，是许多平衡搜索树的一种。它在每个节点上增加了一个存储位来表示结点的颜色，可以是RED或BLACK。通过对任何一条从根到叶子的简单路径上各个结点的颜色进行约束，<strong>红黑树确保没有一条路径会比其他路径长出2倍</strong>，因而是近似于平衡的。</p><h1 id="性质">性质</h1><p>树中每个结点包含5个属性：color、key、left、right和p。</p><p>一棵红黑树是满足下面<strong>红黑性质</strong>的二叉搜索树：</p><ol type="1"><li>每个结点或是红色的，或是黑色的。</li><li>根节点是黑色的。</li><li>每个叶子结点（NIL）是黑色的。</li><li>如果一个结点是红色的，则它的两个子节点都是黑色的。</li><li>对每个结点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色结点。</li></ol><a id="more"></a><p>为了便于处理红黑树中的边界条件，使用一个哨兵来代替NIL。哨兵的color=BLACK，其他属性的p、left、right、key的取值不重要。尽管可以为树中每一个NIL（叶子结点）新增一个不同的哨兵结点，但会浪费空间。取而代之的是，使用一个哨兵T.nil​来代表所有的NIL。如图(b)可以用更少的空间等价地表示图(a)。其中黑色结点用黑色、红色节点用灰色表示。</p><p><strong>黑高</strong>（black-height）：从某个结点x出发（不含该结点）到达一个叶节点的任意一条简单路径上的黑色结点个数（根据性质5可知结点的黑高是唯一的）称为该结点的黑高，记为bh(x)​。定义红黑树的黑高为其根节点的黑高。如图(a)所示的红黑树中，红黑树的黑高为3。图(c)省略了哨兵，多数时候采用这种更简洁的画法。</p><p><img src="/uploads/image/introduction-to-algorithms/red-black-tree.png"></p><blockquote><p>引理13.1</p><p>一棵有n个内部结点的红黑树的高度至多为<span class="math inline">\(2\lg(n+1)\)</span>。</p></blockquote><p><strong>证明</strong>： 先证明以任一结点x为根的子树中至少包含<span class="math inline">\(2^{bh(x)}-1\)</span>个内部结点。使用归纳法证明。</p><ol type="1"><li><p>如果x的高度为0，则x为叶节点（T.nil)，且以x为根节点的子树至少包含<span class="math inline">\(2^{bh(x)}-1=2^0-1=0\)</span>个内部结点。</p></li><li><p>如果x的高度为h(h&gt;0)，假设以x为根节点的子树至少包含<span class="math inline">\(2^{bh(x)}-1\)</span>个内部结点成立。</p></li><li><p>考虑高度h+1且有两个子节点的内部节点<span class="math inline">\(x^\prime\)</span>。子节点的高度为h，黑高为</p><ul><li><span class="math inline">\(bh(x^\prime)\)</span>（当子节点为红色时），</li><li>或<span class="math inline">\(bh(x^\prime)-1\)</span>（当子节点为黑色时）。</li></ul><p>根据归纳假设，以子节点为根节点的子树至少包含<span class="math inline">\(2^{bh(x)-1}-1\)</span>个结点。于是，以<span class="math inline">\(x^\prime\)</span>为根的子树至少包含<span class="math inline">\((2^{bh(x)-1}-1)+(2^{bh(x)-1}-1)+1=2^{bh(x)}-1\)</span>个内部结点。</p></li></ol><p>之后，证明引理：设h为树的高度。根据性质4，从根到叶节点的任何一条简单路径上都至少有一半的结点为黑色。因此，根的黑高至少为h/2，于是有<span class="math inline">\(n\ge2^{h/2}-1\)</span>，将1移到左边，再对两边取对数，得到<span class="math inline">\(h\le2\lg(n+1)\)</span>。</p><h1 id="旋转">旋转</h1><p>搜索树操作TREE-INSERT和TREE-DELETE在含n个关键字的红黑树上，运行花费时间为<span class="math inline">\(O(\lg{n})\)</span>。由于这两个操作对树做了修改，结果可能违反红黑性质。为了维护这些性质，必须要改变树中某些结点的颜色以及指针结构。</p><p>指针结构的修改是通过<strong>旋转</strong>（rotation）来完成的，这是一种能保持二叉搜索树性质的局部操作。<strong>在旋转操作中只有指针改变</strong>，其他所有属性都保持不变。下图给出了两种旋转：左旋和右旋。</p><ul><li>左旋：结点x取代<span class="math inline">\(\beta\)</span>成为y的左孩子结点，<span class="math inline">\(\beta\)</span>取代y成为x的右孩子结点。</li><li>右旋：结点y取代<span class="math inline">\(\beta\)</span>成为x的左孩子结点，<span class="math inline">\(\beta\)</span>取代x成为y的左孩子结点。</li></ul><p><img src="/uploads/image/introduction-to-algorithms/red-black-tree-rotation.png"></p><p>容易观察到，旋转前与旋转后各元素的大小顺序没有改变，都是<span class="math inline">\(\alpha\le{x}\le\beta\le{y}\le\gamma\)</span>。</p><p>在LEFT-ROTATE的伪代码中，假设<span class="math inline">\(x.right\ne{T.nil}\)</span>且根节点的父节点为T.nil。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">LEFT-ROTATE(T, x):</span><br><span class="line">y = x.right              <span class="comment"># y的位置（结合上图理解）</span></span><br><span class="line">x.right = y.left         <span class="comment"># beta取代y成为x的右孩子</span></span><br><span class="line"><span class="keyword">if</span> y.left != T.nil:      <span class="comment"># 此时y.left还是beta结点</span></span><br><span class="line">    y.left.p = x         <span class="comment"># 修改beta的父节点为x</span></span><br><span class="line">y.p = x.p                <span class="comment"># 修改y的父节点</span></span><br><span class="line"><span class="keyword">if</span> x.p == T.nil:         <span class="comment"># 若x原本是根节点，y将变为树的根</span></span><br><span class="line">    T.root = y</span><br><span class="line"><span class="keyword">elif</span> x == x.p.left:      <span class="comment"># 若原本x是左孩子，y取代x后依旧是左孩子</span></span><br><span class="line">    x.p.left = y</span><br><span class="line"><span class="keyword">else</span>:                    <span class="comment"># 若原本x是右孩子，y取代x后依旧是右孩子</span></span><br><span class="line">    x.p.right = y</span><br><span class="line">y.left = x               <span class="comment"># x变为y的左孩子</span></span><br><span class="line">x.p = y                  <span class="comment"># 修改x的父节点为y</span></span><br></pre></td></tr></table></figure><p>RIGHT-ROTATE操作的代码是对称的。它们都在O(1)时间内运行完成。</p><p><img src="/uploads/image/introduction-to-algorithms/red-black-tree-left-rotate.png"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">RIGHT-ROTATE(T, x):</span><br><span class="line">y = x.p</span><br><span class="line">y.left = x.right</span><br><span class="line"><span class="keyword">if</span> x.right != T.nil:</span><br><span class="line">    x.right.p = y</span><br><span class="line">x.p = y.p</span><br><span class="line"><span class="keyword">if</span> y.p == T.nil:</span><br><span class="line">    T.root = x</span><br><span class="line"><span class="keyword">elif</span> y == y.p.left:</span><br><span class="line">    y.p.left = x</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    y.p.right = x</span><br><span class="line">x.right = y</span><br><span class="line">y.p = x</span><br></pre></td></tr></table></figure><h1 id="插入">插入</h1><p>利用二叉搜索树的插入过程，略作修改来将结点z插入树T内，就好像T是一棵普通的二叉搜索树一样，然后将z着为红色。为了保证红黑性质能继续保持，调用一个辅助程序RB-INSERT-FIXUP来对结点重新着色并旋转。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">RB-INSERT(T, z):</span><br><span class="line">y = T.nil             <span class="comment"># 与普通的二叉搜索树不同，此处y指向哨兵</span></span><br><span class="line">x = T.root            <span class="comment"># 寻找z的插入位置</span></span><br><span class="line"><span class="keyword">while</span> x != T.nil:</span><br><span class="line">    y = x</span><br><span class="line">    <span class="keyword">if</span> z.key &lt; x.key:</span><br><span class="line">        x = x.left</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x = x.right</span><br><span class="line">z.p = y               <span class="comment"># 插入结点z</span></span><br><span class="line"><span class="keyword">if</span> y == T.nil:</span><br><span class="line">    T.root = z</span><br><span class="line"><span class="keyword">elif</span> z.key &lt; y.key:</span><br><span class="line">    y.left = z</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    y.right = z</span><br><span class="line">z.left = T.nil        <span class="comment"># 设置新节点的左右孩子为哨兵结点，以保持合理的树结构</span></span><br><span class="line">z.right = T.nil</span><br><span class="line">z.color = RED         <span class="comment"># 新插入节点着红色</span></span><br><span class="line">RB-INSERT-FIXUP(T, z) <span class="comment"># 辅助程序，对结点重新着色并旋转以维护红黑性质</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">RB-INSERT-FIXUP(T, z):</span><br><span class="line"><span class="keyword">while</span> z.p.color == RED:        <span class="comment"># z的父节点也为红色，违反性质4</span></span><br><span class="line">    <span class="keyword">if</span> z.p == z.p.p.left:      <span class="comment"># 如果z的父节点是左孩子结点</span></span><br><span class="line">        y = z.p.p.right        <span class="comment"># z的叔结点(父节点的另一个兄弟结点)</span></span><br><span class="line">        <span class="keyword">if</span> y.color == RED:        <span class="comment"># 情况1：z的叔结点y也是红色的</span></span><br><span class="line">            z.p.color = BLACK          <span class="comment"># z的父节点涂黑</span></span><br><span class="line">            y.color = BLACK            <span class="comment"># z的叔结点也涂黑</span></span><br><span class="line">            z.p.p.color = RED          <span class="comment"># z的祖父结点涂红(将祖父结点涂红可能违反性质4)</span></span><br><span class="line">            z = z.p.p                  <span class="comment"># z指针上升至祖父结点，等候下一次循环修复性质</span></span><br><span class="line">        <span class="keyword">elif</span> z == z.p.right:      <span class="comment"># 情况2：叔结点非红且z是右孩子结点</span></span><br><span class="line">            z = z.p                    <span class="comment"># 注意此时无论情况1是否发生，z的父节点都是红色</span></span><br><span class="line">            LEFT-ROTATE(T, z)          <span class="comment"># 左旋，转为情况3</span></span><br><span class="line">                                  <span class="comment"># 情况3：叔结点非红且z是左孩子结点(注意左旋后z的位置变化)</span></span><br><span class="line">        z.p.color = BLACK         <span class="comment"># 父节点涂黑</span></span><br><span class="line">        z.p.p.color = RED         <span class="comment"># 祖父结点涂红</span></span><br><span class="line">        RIGHT-ROTATE(T, z.p.p)    <span class="comment"># 右旋</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        same <span class="keyword">as</span> then clause <span class="keyword">with</span> <span class="string">"right"</span> <span class="keyword">and</span> <span class="string">"left"</span> exchanged</span><br><span class="line">T.root.color = BLACK              <span class="comment"># 根节点涂黑，修复性质2</span></span><br></pre></td></tr></table></figure><p>在调用RB-INSERT-FIXUP操作时，哪些红黑性质可能会被破坏呢？性质1（非红即黑）和性质3（叶子全黑）继续成立，因为新插入的红节点的两个子节点都是哨兵T.nil。性质5（黑高相等）也会成立，因为结点z代替了黑色的哨兵结点，并且z本身是红结点且有哨兵结点。仅可能被破坏的就是性质2（根节点为黑色）和性质4（红节点不能有红孩子）。如果z是根节点，则破坏了性质2；如果z的父节点是红节点，则破坏了性质4。</p><p>当违反性质4时，z与父节点z.p都时红色，此时可能发生的情况如下：</p><ul><li>情况1：z的叔结点y是红色的。通过重新着色修复性质。</li><li>z的叔结点y是黑色：<ul><li>情况2：z是一个右孩子。通过左旋转化为情况3。（表明这几种情况不是完全独立的）</li><li>情况3：z是一个左孩子。通过重新着色和右旋修复性质。</li></ul></li></ul><p>下图给出一个范例，显示在一棵红黑树上RB-INSERT-FIXUP如何操作。</p><p><img src="/uploads/image/introduction-to-algorithms/red-black-tree-insert-fixup.png"></p><p>由于一棵有n个结点的红黑树的高度为<span class="math inline">\(O(\lg{n})\)</span>，因此RB-INSERT的插入操作要花费<span class="math inline">\(O(\lg{n})\)</span>时间。在RB-INSERT-FIXUP中，仅当情况1发生，然后指针z沿着树上升2层，while循环才会重复执行。所以while循环可能被执行的总次数为<span class="math inline">\(O(\lg{n})\)</span>。因此，RB-INSERT总共花费<span class="math inline">\(O(\lg{n})\)</span>时间。此外，该程序所做的旋转不超过2次，因为只要执行了情况2（先左旋后右旋，旋转两次）或情况3（一次右旋），while循环就结束了。</p><h1 id="删除">删除</h1><p>从一棵红黑树中删除结点的过程是基于二叉搜索树的删除过程而来的。首先，需要特别设计一个子过程：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">RB-TRANSPLANT(T, u, v): <span class="comment"># 用根节点为v的子树替换根节点为u的子树</span></span><br><span class="line"><span class="keyword">if</span> u.p == T.nil:        <span class="comment"># 若u为根结点，只需改变树的根指针即可</span></span><br><span class="line">    T.root = v</span><br><span class="line"><span class="keyword">elif</span> u == u.p.left:     <span class="comment"># 若u是左孩子</span></span><br><span class="line">    u.p.left = v        <span class="comment"># 移植v</span></span><br><span class="line"><span class="keyword">else</span>:                   <span class="comment"># 若u是右孩子</span></span><br><span class="line">    u.p.right = v</span><br><span class="line">v.p = u.p               <span class="comment"># 无条件执行，因为红黑树所有结点(包括哨兵结点)都有父节点属性</span></span><br></pre></td></tr></table></figure><p>过程RB-DELETE与TREE-DELETE类似，两个过程具有相同的基本结构。在RB-DELETE中能够找到TREE-DELETE的每一行语句（其中NIL被替换成了T.nil，TRANSPLANT换成了RB-TRANSPLANT），其执行的条件相同。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">RB-DELETE(T, z):</span><br><span class="line">y = z                             <span class="comment"># y为从树中删除的结点或者移至树内的结点</span></span><br><span class="line">y-original-color = y.color        <span class="comment"># 记录y的原始颜色</span></span><br><span class="line"><span class="keyword">if</span> z.left == T.nil:               <span class="comment"># 情况(a)：左孩子为空</span></span><br><span class="line">    x = z.right                     <span class="comment"># 移植后的结点可能会破坏红黑性质，用x记录其踪迹</span></span><br><span class="line">    RB-TRANSPLANT(T, z, z.right)    <span class="comment"># 用z的右孩子(可能为T.nil)替换z，达到删除z的目的</span></span><br><span class="line"><span class="keyword">elif</span> z.right == T.nil:            <span class="comment"># 情况(b)：右孩子为空</span></span><br><span class="line">    x = z.left                      <span class="comment"># 记录x的踪迹</span></span><br><span class="line">    RB-TRANSPLANT(T, z, z.left)     <span class="comment"># 用z的左孩子替换z</span></span><br><span class="line"><span class="keyword">else</span>:                             <span class="comment"># 情况(c)和(d)：有两个孩子，用z的后继结点y替换z</span></span><br><span class="line">    y = TREE-MINIMUM(z.right)       <span class="comment"># 查找后继结点y</span></span><br><span class="line">    y-original-color = y.color      <span class="comment"># 记录y的初始颜色</span></span><br><span class="line">    x = y.right                     <span class="comment"># 记录x的踪迹</span></span><br><span class="line">    <span class="keyword">if</span> y.p != z                   <span class="comment"># 情况(d)：后继结点y不是z的子节点</span></span><br><span class="line">        RB-TRANSPLANT(T, y, y.right)</span><br><span class="line">        y.right = z.right</span><br><span class="line">        y.right.p = y</span><br><span class="line">    <span class="keyword">else</span>:                         <span class="comment"># 情况(c)：y是z的子节点</span></span><br><span class="line">        x.p = y                     <span class="comment"># 没搞懂你存在的意义</span></span><br><span class="line">    RB-TRANSPLANT(T, z, y)</span><br><span class="line">    y.left = z.left</span><br><span class="line">    y.left.p = y</span><br><span class="line">    y.color = z.color             <span class="comment"># 删除z后，将替换z的结点y涂与z相同的颜色</span></span><br><span class="line"><span class="keyword">if</span> y-original-color == BLACK:  <span class="comment"># 如果原始为黑色，删除或移动y会破坏红黑性质；原始为红色，则不会</span></span><br><span class="line">    RB-DELETE-FIXUP(T, x)      <span class="comment"># 调用子过程修复红黑性质</span></span><br></pre></td></tr></table></figure><p>删除过程分为两部分：</p><ul><li><p>与二叉搜索树的删除操作相同的删除操作。下图描述了在二叉搜索树上删除结点时的4种情况，在红黑树上删除结点时同样考虑这4种情况。</p></li><li><p>修复红黑性质的RB-DELETE-FIXUP操作。为此，在删除结点时用变量y-original-color和x记录了必要的信息。</p></li></ul><p><img src="/uploads/image/introduction-to-algorithms/binary-search-tree-delete.png"></p><p>在RB-DELETE的最后，如果结点y是黑色的，就有可能已经引入了一个或多个红黑性质被破坏的情况，所以调用RB-DELETE-FIXUP来恢复红黑性质。如果结点y是红色，当y被删除或移动时，红黑性质仍然保持，原因如下：</p><ol type="1"><li>树中的黑高没有变化。</li><li>不存在两个相邻的红色结点：<ul><li>情况(a)或情况(b)发生时（y与z相同），y是红色，则其子节点一定是黑色。y被删除后，其子节点替换y的位置。因此，不会出现两个相邻的红色结点。</li><li>情况(c)发生时（y是z的后继结点），y是红色，则y的右孩子x一定是黑色，y替换z后被涂成与z相同的颜色，y和x不会出现两个相邻的红色结点。</li><li>情况(d)的第一步替换中，y是红色，则x是黑色，x替换y之后不会出现两个相邻的红色结点。第二步替换中，y替换z并且被涂成与z相同的颜色。因此y与r不会是两个相邻的红色结点（y与r的颜色就是原来z与r的颜色）。</li></ul></li><li>y是红色，就不可能是根节点，所以根节点仍旧是黑色。</li></ol><p>如果结点y是黑色，则会产生三个问题，可以通过调用RB-DELETE-FIXUP进行修复。</p><ol type="1"><li>在情况(a)和(b)中，y（与z相同）是黑色，若y的一个红色的孩子（l或r）替换了y成为新的根节点，则违反了性质2（根节点为黑色）。</li><li>在情况(c)和(d)中，y是黑色，若y.p与x同时为红色，则删除z后出现y.p与x都是红色的情况，违反了性质4（红色结点的孩子是黑色的）。</li><li>y为黑色，移动y将导致包含y的任何简单路径上的黑结点个数少1。因此，y的任何祖先都不满足性质5（到叶节点的简单路径含有相同数目的黑色结点）。改正这一问题的办法是将现在占有y原来位置的结点x视为还有一重额外的黑色。当将黑色结点y删除或移动时，将其黑色“下推“给结点x。这个额外的黑色是针对结点x的，而不是反映在它的color属性上的。x.color仍然是RED（如果x是红黑色的）或BLACK（如果x是双重黑色的）。x时双重黑色或红黑色时，分别给包含x的简单路径上黑结点数贡献了2或1。</li></ol><p>下面是过程RB-DELETE-FIXUP的伪代码。该过程可以恢复性质1、性质2和性质4。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">RB-DELETE-FIXUP(T, x):</span><br><span class="line"><span class="keyword">while</span> x != T.root <span class="keyword">and</span> x.color == BLACK:<span class="comment"># x为双重黑色，为黑色结点数贡献2</span></span><br><span class="line">    <span class="keyword">if</span> x == x.p.left:</span><br><span class="line">        w = x.p.right                  <span class="comment"># w指向兄弟结点</span></span><br><span class="line">        <span class="keyword">if</span> w.color == RED:             <span class="comment"># 情况1：w是红色的，可以通过以下操作转化为情况2、3或4</span></span><br><span class="line">            w.color = BLACK               <span class="comment"># 而不会违反红黑树的任何性质</span></span><br><span class="line">            x.p.color = RED            <span class="comment"># 改变w和x.p的颜色</span></span><br><span class="line">            LEFT-ROTATE(T, x.p)        <span class="comment"># 然后对x.p做一次左旋</span></span><br><span class="line">            w = x.p.right              <span class="comment"># x的新的兄弟结点w是黑色了</span></span><br><span class="line">        <span class="keyword">if</span> w.left.color == BLACK <span class="keyword">and</span> w.right.color == BLACK: <span class="comment"># 情况2：w和w的两个孩子都是黑色的</span></span><br><span class="line">            w.color = RED              <span class="comment"># 抹去w的黑色，w的所有祖先的黑高降低了1</span></span><br><span class="line">            x = x.p                    <span class="comment"># 作为补偿，在x.p(也是w的父节点)上新增一重额外的黑色</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 情况3和情况4的公共前提：w是黑色的，但两个孩子不全是黑色</span></span><br><span class="line">            <span class="keyword">if</span> w.right.color == BLACK: <span class="comment"># 情况3：w的右孩子是黑色的，暗示着左孩子是红色的</span></span><br><span class="line">                w.left.color = BLACK      <span class="comment"># 通过下列操作转化为情况4而不违反红黑树的任何性质</span></span><br><span class="line">                w.color = RED             <span class="comment"># w与其左孩子交换颜色(w变为红色了)</span></span><br><span class="line">                RIGHT-ROTATE(T, w)        <span class="comment"># 然后对w进行右旋(旋转后的w变成了新w的右孩子)</span></span><br><span class="line">                w = x.p.right             <span class="comment"># x的新的兄弟结点w仍旧是黑色的</span></span><br><span class="line">            w.color = x.p.color        <span class="comment"># 情况4：w的右孩子是红色的，左孩子颜色无所谓</span></span><br><span class="line">            x.p.color = BLACK          <span class="comment"># w涂上父节点的颜色</span></span><br><span class="line">            w.right.color = BLACK      <span class="comment"># 然后将父节点x.p和右孩子w.right涂成黑色</span></span><br><span class="line">            LEFT-ROTATE(T, x.p)        <span class="comment"># 最后对x.p进行一次左旋，即可去掉x的额外的黑色</span></span><br><span class="line">            x = T.root                 <span class="comment"># 将x设置为root，退出while循环</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">         <span class="comment"># same as then clause with "right" and "left" exchanged</span></span><br><span class="line">x.color = BLACK                        <span class="comment"># 若x指向红黑结点或根节点，直接涂成黑色即可修复性质5</span></span><br></pre></td></tr></table></figure><p>while循环的目标是将额外的黑色沿树上移，直到可以将额外的黑色移除：</p><ol type="1"><li>x指向红黑结点，此时将x着为黑色（x.color = BLACK），”移除”额外的黑色。</li><li>x指向根结点，此时”移除“额外的黑色即可。根结点x到所有叶子结点的简单路径的黑色结点数都降低1。</li><li>执行适当的旋转和重新着色，退出循环（while循环内的代码）。</li></ol><p>在while循环中，x总是指向一个具有双重黑色的非根结点。要判断x是左孩子还是右孩子。为左孩子时的代码与为右孩子时的代码是对称的。</p><p><img src="/uploads/image/introduction-to-algorithms/red-black-tree-delete-fixup.png"></p><p>对图的说明：</p><ul><li>加黑的结点color属性为BLACK，深阴影的结点color属性为RED，浅阴影的结点color属性用c和<span class="math inline">\(c^\prime\)</span>表示，它既可为RED也可为BLACK。字母<span class="math inline">\(\alpha,\beta,\dots,\zeta\)</span>代表任意的子树。容易观察到在上述4中操作中，任意结点的黑高都没有发生变化（注意x的黑色层数）。</li><li>x指向的结点带有额外的一重黑色，即x为双重黑色或红黑色。</li></ul><p>对代码内注释的整理：</p><ul><li>x的兄弟结点w是红色的。改变w和x.p的颜色，对x.p做一次左旋。旋转后，x的新兄弟结点new w是黑色的，就将情况1转换为情况2、3或4。</li><li>x的兄弟结点w是黑色的。<ul><li>w的两个子节点都是黑色的。去掉w的黑色，作为补偿对w.p（=x.p）补偿一层黑色。在代码中表现为指针x的移动。</li><li>w的两个孩子不全是黑色的。<ul><li>w的左孩子是红色的，右孩子是黑色的。交换w和左孩子w.left的颜色，对w进行右旋。旋转后，x的新兄弟结点w是一个有红色右孩子的黑色结点，将情况3转换成情况4。</li><li>w的右孩子是红色的，左孩子颜色可红可黑。通过进行某些颜色修改并对x.p做一次左旋，可以去掉x的额外的黑色，从而使它变为单黑色。将x设置为根后，当while循环测试循环条件时，循环终止。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Algorithms </tag>
            
            <tag> data structures </tag>
            
            <tag> red-black tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx启用WebDAV</title>
      <link href="/server/nginx-set-up-a-webdav/"/>
      <url>/server/nginx-set-up-a-webdav/</url>
      
        <content type="html"><![CDATA[<h1 id="环境">环境</h1><p><a href="https://en.wikipedia.org/wiki/WebDAV" target="_blank" rel="noopener">WebDAV</a>: Web Distributed Authoring and Versioning.</p><ul><li><p>系统：ubuntu 18.04.2 LTS</p></li><li><p>nginx：1.14.0</p></li><li><p>客户端：iOS documents 和 Windows winscp</p></li></ul><h1 id="安装nginx">安装nginx</h1><p>nginx默认支持dav，但PROPFIND、OPTIONS操作还不支持。支持这些操作需要额外的模块。</p><ul><li>完全安装。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ubuntu@ip:~$ sudo apt-get update</span><br><span class="line">ubuntu@ip:~$ sudo apt-get install nginx-full</span><br></pre></td></tr></table></figure><ul><li>部分安装。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ubuntu@ip:~$ sudo apt-get update</span><br><span class="line">ubuntu@ip:~$ sudo apt-get install nginx nginx-extras</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="配置">配置</h1><p>使用新域名。在sites-available目录下添加配置文件。</p><figure class="highlight plain"><figcaption><span>/etc/nginx/sites-available/dav</span></figcaption><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 443 ssl;</span><br><span class="line">        listen [::]:443 ssl;</span><br><span class="line"></span><br><span class="line">        server_name your_dav_domain.com;</span><br><span class="line">        root /var/www/nginx/dav;</span><br><span class="line"></span><br><span class="line">        ssl on;</span><br><span class="line">        ssl_certificate /your/path/dav.crt;</span><br><span class="line">        ssl_certificate_key /your/path/dav.key;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                charset         utf-8;</span><br><span class="line">                autoindex       on;</span><br><span class="line"></span><br><span class="line">                client_body_temp_path   /etc/nginx/client_temp;</span><br><span class="line">                client_max_body_size    512m;  # 最大文件，若为0则表示不限制</span><br><span class="line"></span><br><span class="line">                dav_methods PUT DELETE MKCOL COPY MOVE;</span><br><span class="line">                dav_ext_methods PROPFIND OPTIONS;  # 需要额外的模块支持</span><br><span class="line"></span><br><span class="line">                create_full_put_path    on;</span><br><span class="line">                dav_access              group:rw all:r;</span><br><span class="line"></span><br><span class="line">                auth_basic              &quot;Access limited&quot;;</span><br><span class="line">                auth_basic_user_file    /etc/nginx/user.passwd;</span><br><span class="line"></span><br><span class="line">                access_log              /var/log/nginx/access.dav.log;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启用该配置。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git@ip:/etc/nginx/sites-enabled$ <span class="built_in">cd</span> /etc/nginx/sites-available/</span><br><span class="line">git@ip:/etc/nginx/sites-available$ sudo ln -s dav ../sites-enabled/dav</span><br><span class="line">git@ip:/etc/nginx/sites-available$ sudo nginx -t</span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf <span class="built_in">test</span> is successful</span><br><span class="line">git@ip:/etc/nginx/sites-available$ sudo nginx -s reload</span><br></pre></td></tr></table></figure><h1 id="删除文件夹">删除文件夹</h1><p>搭建了webdav服务器后，能访问并可以执行部分操作，如创建文件等。但也有不能执行的操作，出现此问题的原因是客户端和服务器的要求不兼容。比如winscp可以删除文件夹，但不可以修改文件夹名称。documents不可以删除文件夹（但是文件夹里面的文件会被成功删除），也不能重命名文件夹（客户端提示权限不足，提示并不正确，看nginx的错误日志）。</p><table><thead><tr class="header"><th>操作</th><th>winscp</th><th>documents</th><th>err_log</th></tr></thead><tbody><tr class="odd"><td>浏览</td><td>Y</td><td>Y</td><td></td></tr><tr class="even"><td>创建文件</td><td>Y</td><td>Y</td><td></td></tr><tr class="odd"><td>创建文件夹</td><td>Y</td><td>Y</td><td></td></tr><tr class="even"><td>移动文件（包括重命名）</td><td>Y</td><td>Y</td><td></td></tr><tr class="odd"><td>移动文件夹（包括重命名）</td><td>N</td><td>N</td><td>&quot;/folder&quot; is collection</td></tr><tr class="even"><td>删除文件</td><td>Y</td><td>Y</td><td></td></tr><tr class="odd"><td>删除文件夹</td><td>Y</td><td>N</td><td>DELETE &quot;/folder&quot; failed (21: Is a directory)</td></tr></tbody></table><p>根据日志，报错的原因是nginx要求对文件夹的操作请求的末尾带上斜线/，比如删除文件夹必须是DELETE /folder/，但是客户端发出的请求是DELETE /folder，因此报错。</p><p>修复方法是重写请求，在webdav的配置文件中加入下列修改：</p><figure class="highlight diff"><figcaption><span>/etc/nginx/sites-enabled/dav</span></figcaption><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"><span class="addition">+    # 如果请求内容是文件夹，在请求末尾加上/</span></span><br><span class="line"><span class="addition">+    if ( -d $request_filename ) &#123;  </span></span><br><span class="line"><span class="addition">+        rewrite ^(.*[^/])$ $1/ break;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="移动文件夹">移动文件夹</h1><p>加了如上配置后，documents可以删除文件夹了，但是不论winscp还是documents都无法重命名文件夹。错误日志为<code>both URI &quot;/fog/&quot; and &quot;Destination&quot; URI &quot;https://dav.server.demo/fofg&quot; should be either collections or non-collections</code>。即nginx收到了将文件夹重命名为文件的操作请求，于是报出以上错误。在尝试了各种配置无法解决后，我在nginx源文件ngx_http_dav_module.c中找到了这段代码。这段代码要求URI和Destination一致，要么都带/，要么都不带/。</p><figure class="highlight c"><figcaption><span>~/nginx-1.14.0/src/http/modules/ngx_http_dav_module.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((r-&gt;uri.data[r-&gt;uri.len - <span class="number">1</span>] == <span class="string">'/'</span> &amp;&amp; *(last - <span class="number">1</span>) != <span class="string">'/'</span>)</span><br><span class="line">    || (r-&gt;uri.data[r-&gt;uri.len - <span class="number">1</span>] != <span class="string">'/'</span> &amp;&amp; *(last - <span class="number">1</span>) == <span class="string">'/'</span>))</span><br><span class="line">&#123;</span><br><span class="line">    ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                  <span class="string">"both URI \"%V\" and \"Destination\" URI \"%V\" "</span></span><br><span class="line">                  <span class="string">"should be either collections or non-collections"</span>,</span><br><span class="line">                  &amp;r-&gt;uri, &amp;dest-&gt;value);</span><br><span class="line">    <span class="keyword">return</span> NGX_HTTP_CONFLICT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要解决这个问题，我注释掉了这段代码，重新编译nginx。</p><h1 id="编译nginx">编译nginx</h1><p>下载nginx和nginx-dav-ext-module。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ubuntu@ip:~$ wget http://nginx.org/download/nginx-1.14.0.tar.gz</span><br><span class="line">ubuntu@ip:~$ tar xzf nginx-1.14.0.tar.gz</span><br><span class="line">ubuntu@ip:~$ git <span class="built_in">clone</span> https://github.com/arut/nginx-dav-ext-module.git</span><br></pre></td></tr></table></figure><p>在nginx源码中注释掉上述代码。</p><figure class="highlight c"><figcaption><span>~/nginx-1.14.0/src/http/modules/ngx_http_dav_module.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if ((r-&gt;uri.data[r-&gt;uri.len - 1] == '/' &amp;&amp; *(last - 1) != '/')</span></span><br><span class="line"><span class="comment">    || (r-&gt;uri.data[r-&gt;uri.len - 1] != '/' &amp;&amp; *(last - 1) == '/'))</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0,</span></span><br><span class="line"><span class="comment">                  "both URI \"%V\" and \"Destination\" URI \"%V\" "</span></span><br><span class="line"><span class="comment">                  "should be either collections or non-collections",</span></span><br><span class="line"><span class="comment">                  &amp;r-&gt;uri, &amp;dest-&gt;value);</span></span><br><span class="line"><span class="comment">    return NGX_HTTP_CONFLICT;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>设置编译参数，<a href="https://xuexb.github.io/learn-nginx/guide/nginx-configure-descriptions.html" target="_blank" rel="noopener">编译参数介绍</a>。不想深究编译参数，可以使用如下默认的编译参数。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ubuntu@ip:~/nginx-1.14.0$ nginx -V  <span class="comment"># 查看编译参数</span></span><br><span class="line">nginx version: nginx/1.14.0 (Ubuntu)</span><br><span class="line">built with OpenSSL 1.1.1  11 Sep 2018</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --with-cc-opt=<span class="string">'-g -O2 -fdebug-prefix-map=/build/nginx-DUghaW/nginx-1.14.0=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wdate-time -D_FORTIFY_SOURCE=2'</span> --with-ld-opt=<span class="string">'-Wl,-Bsymbolic-functions -Wl,-z,relro -Wl,-z,now -fPIC'</span> --prefix=/usr/share/nginx --conf-path=/etc/nginx/nginx.conf --http-log-path=/var/<span class="built_in">log</span>/nginx/access.log --error-log-path=/var/<span class="built_in">log</span>/nginx/error.log --lock-path=/var/lock/nginx.lock --pid-path=/run/nginx.pid --modules-path=/usr/lib/nginx/modules --http-client-body-temp-path=/var/lib/nginx/body --http-fastcgi-temp-path=/var/lib/nginx/fastcgi --http-proxy-temp-path=/var/lib/nginx/proxy --http-scgi-temp-path=/var/lib/nginx/scgi --http-uwsgi-temp-path=/var/lib/nginx/uwsgi --with-debug --with-pcre-jit --with-http_ssl_module --with-http_stub_status_module --with-http_realip_module --with-http_auth_request_module --with-http_v2_module --with-http_dav_module --with-http_slice_module --with-threads --with-http_addition_module --with-http_geoip_module=dynamic --with-http_gunzip_module --with-http_gzip_static_module --with-http_image_filter_module=dynamic --with-http_sub_module --with-http_xslt_module=dynamic --with-stream=dynamic --with-stream_ssl_module --with-mail=dynamic --with-mail_ssl_module</span><br></pre></td></tr></table></figure><p>保持这些参数不变，添加额外的nginx-dav-ext-module模块。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ubuntu@ip:~/nginx-1.14.0$ ./configure --with-cc-opt=...原来的参数... --add-module=../nginx-dav-ext-module</span><br><span class="line">ubuntu@ip:~/nginx-1.14.0$ make  <span class="comment"># 编译</span></span><br><span class="line">ubuntu@ip:~/nginx-1.14.0$ sudo objs/nginx -t  <span class="comment"># 测试</span></span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf <span class="built_in">test</span> is successful</span><br><span class="line">ubuntu@ip:~/nginx-1.14.0$ sudo cp /usr/sbin/nginx /usr/sbin/nginx.bak  <span class="comment"># 备份</span></span><br><span class="line">ubuntu@ip:~/nginx-1.14.0$ sudo nginx -s stop  <span class="comment"># 停止服务</span></span><br><span class="line">ubuntu@ip:~/nginx-1.14.0$ sudo cp objs/nginx /usr/sbin/nginx  <span class="comment"># 替换</span></span><br><span class="line">ubuntu@ip:~/nginx-1.14.0$ sudo service nginx start  <span class="comment"># 重启</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> webdav </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu挂载和卸除文件系统</title>
      <link href="/server/ubuntu-mount-and-unmount-drive/"/>
      <url>/server/ubuntu-mount-and-unmount-drive/</url>
      
        <content type="html"><![CDATA[<h1 id="挂载">挂载</h1><p>查看文件系统</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git@ip:~$ sudo fdisk -l</span><br><span class="line">...省略...</span><br><span class="line">Disk /dev/xvdb: 20 GiB, 21474836480 bytes, 41943040 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br></pre></td></tr></table></figure><p>目标文件系统为/dev/xvdb。挂载：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git@ip:~$ sudo mkdir /mnt/data</span><br><span class="line">git@ip:~$ sudo mount /dev/xvdb /mnt/data/</span><br><span class="line">git@ip:~$ sudo df -h  <span class="comment"># 显示文件系统</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">...省略...</span><br><span class="line">/dev/xvdb        20G  208M   19G   2% /mnt/data</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="卸除">卸除</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git@ip:~$ sudo umount /dev/xvdb  <span class="comment"># 通过设备名</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git@ip:~$ sudo umount /mnt/data  <span class="comment"># 通过挂载点</span></span><br></pre></td></tr></table></figure><h1 id="自动挂载">自动挂载</h1><p>查看文件系统信息：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git@ip:~$ sudo e2label /dev/xvdb data  <span class="comment"># 修改卷标</span></span><br><span class="line">git@ip:~$ sudo blkid /dev/xvdb</span><br><span class="line">/dev/xvdb: LABEL=<span class="string">"data"</span> UUID=<span class="string">"a0001bdb-4b69-4419-9339-f57ddec2f007"</span> TYPE=<span class="string">"ext4"</span></span><br></pre></td></tr></table></figure><p>修改fstab文件：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git@ip:~$ sudo nano /etc/fstab</span><br></pre></td></tr></table></figure><p>添加一列：</p><figure class="highlight diff"><figcaption><span>/etc/fstab</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="addition">+    LABEL=data              /mnt/data       ext4    defaults                0 2</span></span><br></pre></td></tr></table></figure><p>/etc/fstab文件包含了如下字段，通过空格或Tab分隔：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;file system&gt;    &lt;dir&gt;    &lt;type&gt;    &lt;options&gt;    &lt;dump&gt;    &lt;pass&gt;</span><br></pre></td></tr></table></figure><ul><li><file system> - 要挂载的分区或存储设备。</file></li><li><dir><ul><li>file systems的挂载位置。</li></ul></dir></li><li><type> - 文件系统类型，支持许多种不同的文件系统：ext2, ext3, ext4, reiserfs, xfs, jfs, smbfs, iso9660, vfat, ntfs, swap及auto。设置成auto类型，mount命令会猜测使用的文件系统类型，对CDROM和DVD等移动设备是非常有用的。</type></li><li><options> - 挂载时使用的参数，注意有些参数是特定文件系统才有的。</options></li><li><dump> - dump工具通过它决定何时作备份。dump会检查其内容，并用数字来决定是否对这个文件系统进行备份。允许的数字是0和1。0表示忽略，1则进行备份。大部分的用户是没有安装dump的，对他们而言<dump>应设为0。</dump></dump></li><li><pass> - fsck读取<pass>的数值来决定需要检查的文件系统的检查顺序。允许的数字是0, 1, 和2。根目录应当获得最高的优先权1,其它所有需要被检查的设备设置为2。0表示设备不会被fsck所检查。</pass></pass></li></ul><p><strong>验证配置的正确性</strong>：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git@ip:~$ sudo mount -a  <span class="comment"># 有错误时打印错误信息</span></span><br><span class="line">mount: /mnt/data: can<span class="string">'t find LABEL=date.</span></span><br></pre></td></tr></table></figure><p>最后可以重启系统验证一下。</p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> command </tag>
            
            <tag> mount </tag>
            
            <tag> unmount </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python迭代器与生成器</title>
      <link href="/programming/python-iterator-generator/"/>
      <url>/programming/python-iterator-generator/</url>
      
        <content type="html"><![CDATA[<h1 id="迭代器">迭代器</h1><p>迭代是访问集合元素的一种方式。迭代器从集合的第一个元素开始访问，直到所有元素被访问完。迭代器只能往前访问，不能后退。字符串，列表，集合等集合对象都可用于创建迭代器。</p><p>多数情况下，更倾向于通过以下方式遍历集合：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line"><span class="meta">... </span>    print(i, end=<span class="string">' '</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>    print()</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>等价地，可以创建一个集合a的迭代器：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it = iter(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>        print(next(it), end=<span class="string">' '</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">except</span> StopIteration:   <span class="comment"># 访问结束后再次调用next(it)会抛出此异常</span></span><br><span class="line"><span class="meta">... </span>        print()</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">break</span></span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>例如，有一个链表，我希望像遍历数组一样可以遍历链表。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        self.key, self.next = key, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.y = self  <span class="comment"># 用变量y记录位置</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.y <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 队尾判断</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x = self.y  <span class="comment"># 暂存</span></span><br><span class="line">            <span class="keyword">if</span> self.y <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment"># 更新位置以便下次访问</span></span><br><span class="line">                self.y = self.y.next</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a, b, c = Node(<span class="number">1</span>), Node(<span class="number">2</span>), Node(<span class="number">3</span>)</span><br><span class="line">    a.next, b.next, c.next = b, c, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a:             <span class="comment"># for each</span></span><br><span class="line">        print(i, end=<span class="string">' '</span>)</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line">    it = iter(b)            <span class="comment"># iterator</span></span><br><span class="line">    print(next(it))</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h1 id="生成器">生成器</h1><p>在Python中，使用了yield的函数被称为生成器。生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</p><p>python可以通过列表解析（list comprehension）的方式构建集合：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><p>实际上，<code>(i for i in range(10))</code>就是一个生成器。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">generator</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>在生成器运行过程中，每次遇到yield时函数会暂停并保存当前所有的运行信息，返回yield的值，并在下一次执行next()方法时从当前位置继续运行。</p><p>这在很多情况下特别有用。例如，最近研究如何获得一个图中两点之间的所有简单路径。一个测试示例中大概包含一千万条不同的简单路径，若是一次性将这一千万条作为数组返回，……，大概我的笔记本会原地爆炸吧。</p><p>这时生成器就排上用场了。为了简化说明，使用斐波那契数列作为示例。一个斐波那契数列的迭代版本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">"""返回斐波那契数列的前n个元素组成的列表"""</span></span><br><span class="line">    a, b, c, r = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, []</span><br><span class="line">    <span class="keyword">while</span> c &lt; n:</span><br><span class="line">        r.append(a)</span><br><span class="line">        a, b, c = b, a + b, c + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure><p>假设需要获得前一千万个数，……，(#`O′)。下面使用yield将之变为生成器。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci_it</span><span class="params">(n)</span>:</span> <span class="comment"># 它是一个迭代器</span></span><br><span class="line">    a, b, c = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> c &lt; n:</span><br><span class="line">        <span class="keyword">yield</span> a  <span class="comment"># 每次执行到此处暂停，返回一个结果，下次调用next时将从此处继续执行</span></span><br><span class="line">        a, b, c = b, a + b, c + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> fibonacci_it(<span class="number">10</span>):    <span class="comment"># 使用</span></span><br><span class="line">        print(i, end=<span class="string">' '</span>)</span><br><span class="line">    print()</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 1 1 2 3 5 8 13 21 34</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> iterator </tag>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NetworkX</title>
      <link href="/documentation/networkx-documentation/"/>
      <url>/documentation/networkx-documentation/</url>
      
        <content type="html"><![CDATA[<h1 id="图的种类">图的种类</h1><p>有4种+1类<a href="https://networkx.github.io/documentation/stable/reference/classes/index.html#basic-graph-types" target="_blank" rel="noopener">Basic graph types</a>。</p><ul><li>Graph：无向图，允许自环（顶点与自身连接的边）。</li><li>DiGraph：有向图，允许自环。</li><li>MultiGraph：无向图，允许自环和平行边（两条或多条与同一对顶点相连接的边）。</li><li>MultiDiGraph：有向图，允许自环和平行边。</li><li>Ordered Graph：OrderedGraph，OrderedDiGraph，OrderedMultiGraph，OrderedMultiDiGraph。</li></ul><p>Ordered Graph的存在意义：在返回图中顶点或边的集合时，Ordered Graph总是以一个固定的顺序返回。</p><p>当<strong>无需此项性质</strong>或<strong>使用Python 3.6+</strong>（Python 3.6+中，集合的顺序是固定的）时，使用前四种基本类即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = nx.Graph()</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="方法">方法</h1><h2 id="adding-and-removing-nodes-and-edges">Adding and removing nodes and edges</h2><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><thead><tr class="header"><th><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.__init__.html#networkx.Graph.__init__" target="_blank" rel="noopener"><code>Graph.__init__</code></a>([incoming_graph_data])</th><th>Initialize a graph with edges, name, or graph attributes.</th></tr></thead><tbody><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.add_node.html#networkx.Graph.add_node" target="_blank" rel="noopener"><code>Graph.add_node</code></a>(node_for_adding, **attr)</td><td>Add a single node <code>node_for_adding</code> and update node attributes.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.add_nodes_from.html#networkx.Graph.add_nodes_from" target="_blank" rel="noopener"><code>Graph.add_nodes_from</code></a>(nodes_for_adding, **attr)</td><td>Add multiple nodes.</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.remove_node.html#networkx.Graph.remove_node" target="_blank" rel="noopener"><code>Graph.remove_node</code></a>(n)</td><td>Remove node n.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.remove_nodes_from.html#networkx.Graph.remove_nodes_from" target="_blank" rel="noopener"><code>Graph.remove_nodes_from</code></a>(nodes)</td><td>Remove multiple nodes.</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.add_edge.html#networkx.Graph.add_edge" target="_blank" rel="noopener"><code>Graph.add_edge</code></a>(u_of_edge, v_of_edge, **attr)</td><td>Add an edge between u and v.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.add_edges_from.html#networkx.Graph.add_edges_from" target="_blank" rel="noopener"><code>Graph.add_edges_from</code></a>(ebunch_to_add, **attr)</td><td>Add all the edges in ebunch_to_add.</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.add_weighted_edges_from.html#networkx.Graph.add_weighted_edges_from" target="_blank" rel="noopener"><code>Graph.add_weighted_edges_from</code></a>(ebunch_to_add)</td><td>Add weighted edges in <code>ebunch_to_add</code> with specified weight attr</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.remove_edge.html#networkx.Graph.remove_edge" target="_blank" rel="noopener"><code>Graph.remove_edge</code></a>(u, v)</td><td>Remove the edge between u and v.</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.remove_edges_from.html#networkx.Graph.remove_edges_from" target="_blank" rel="noopener"><code>Graph.remove_edges_from</code></a>(ebunch)</td><td>Remove all edges specified in ebunch.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.update.html#networkx.Graph.update" target="_blank" rel="noopener"><code>Graph.update</code></a>([edges, nodes])</td><td>Update the graph using nodes/edges/graphs as input.</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.clear.html#networkx.Graph.clear" target="_blank" rel="noopener"><code>Graph.clear</code></a>()</td><td>Remove all nodes and edges from the graph.</td></tr></tbody></table><h2 id="reporting-nodes-edges-and-neighbors">Reporting nodes edges and neighbors</h2><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><thead><tr class="header"><th><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.nodes.html#networkx.Graph.nodes" target="_blank" rel="noopener"><code>Graph.nodes</code></a></th><th>A NodeView of the Graph as G.nodes or G.nodes().</th></tr></thead><tbody><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.__iter__.html#networkx.Graph.__iter__" target="_blank" rel="noopener"><code>Graph.__iter__</code></a>()</td><td>Iterate over the nodes.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.has_node.html#networkx.Graph.has_node" target="_blank" rel="noopener"><code>Graph.has_node</code></a>(n)</td><td>Returns True if the graph contains the node n.</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.__contains__.html#networkx.Graph.__contains__" target="_blank" rel="noopener"><code>Graph.__contains__</code></a>(n)</td><td>Returns True if n is a node, False otherwise.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.edges.html#networkx.Graph.edges" target="_blank" rel="noopener"><code>Graph.edges</code></a></td><td>An EdgeView of the Graph as G.edges or G.edges().</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.has_edge.html#networkx.Graph.has_edge" target="_blank" rel="noopener"><code>Graph.has_edge</code></a>(u, v)</td><td>Returns True if the edge (u, v) is in the graph.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.get_edge_data.html#networkx.Graph.get_edge_data" target="_blank" rel="noopener"><code>Graph.get_edge_data</code></a>(u, v[, default])</td><td>Returns the attribute dictionary associated with edge (u, v).</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.neighbors.html#networkx.Graph.neighbors" target="_blank" rel="noopener"><code>Graph.neighbors</code></a>(n)</td><td>Returns an iterator over all neighbors of node n.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.adj.html#networkx.Graph.adj" target="_blank" rel="noopener"><code>Graph.adj</code></a></td><td>Graph adjacency object holding the neighbors of each node.</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.__getitem__.html#networkx.Graph.__getitem__" target="_blank" rel="noopener"><code>Graph.__getitem__</code></a>(n)</td><td>Returns a dict of neighbors of node n.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.adjacency.html#networkx.Graph.adjacency" target="_blank" rel="noopener"><code>Graph.adjacency</code></a>()</td><td>Returns an iterator over (node, adjacency dict) tuples for all nodes.</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.nbunch_iter.html#networkx.Graph.nbunch_iter" target="_blank" rel="noopener"><code>Graph.nbunch_iter</code></a>([nbunch])</td><td>Returns an iterator over nodes contained in nbunch that are also in the graph.</td></tr></tbody></table><h2 id="counting-nodes-edges-and-neighbors">Counting nodes edges and neighbors</h2><table><colgroup><col style="width: 51%"><col style="width: 48%"></colgroup><thead><tr class="header"><th><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.order.html#networkx.Graph.order" target="_blank" rel="noopener"><code>Graph.order</code></a>()</th><th>Returns the number of nodes in the graph.</th></tr></thead><tbody><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.number_of_nodes.html#networkx.Graph.number_of_nodes" target="_blank" rel="noopener"><code>Graph.number_of_nodes</code></a>()</td><td>Returns the number of nodes in the graph.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.__len__.html#networkx.Graph.__len__" target="_blank" rel="noopener"><code>Graph.__len__</code></a>()</td><td>Returns the number of nodes in the graph.</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.degree.html#networkx.Graph.degree" target="_blank" rel="noopener"><code>Graph.degree</code></a></td><td>A DegreeView for the Graph as G.degree or G.degree().</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.size.html#networkx.Graph.size" target="_blank" rel="noopener"><code>Graph.size</code></a>([weight])</td><td>Returns the number of edges or total of all edge weights.</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.number_of_edges.html#networkx.Graph.number_of_edges" target="_blank" rel="noopener"><code>Graph.number_of_edges</code></a>([u, v])</td><td>Returns the number of edges between two nodes.</td></tr></tbody></table><h2 id="making-copies-and-subgraphs">Making copies and subgraphs</h2><table><colgroup><col style="width: 50%"><col style="width: 49%"></colgroup><thead><tr class="header"><th><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.copy.html#networkx.Graph.copy" target="_blank" rel="noopener"><code>Graph.copy</code></a>([as_view])</th><th>Returns a copy of the graph.</th></tr></thead><tbody><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.to_undirected.html#networkx.Graph.to_undirected" target="_blank" rel="noopener"><code>Graph.to_undirected</code></a>([as_view])</td><td>Returns an undirected copy of the graph.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.to_directed.html#networkx.Graph.to_directed" target="_blank" rel="noopener"><code>Graph.to_directed</code></a>([as_view])</td><td>Returns a directed representation of the graph.</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.subgraph.html#networkx.Graph.subgraph" target="_blank" rel="noopener"><code>Graph.subgraph</code></a>(nodes)</td><td>Returns a SubGraph view of the subgraph induced on <code>nodes</code>.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.edge_subgraph.html#networkx.Graph.edge_subgraph" target="_blank" rel="noopener"><code>Graph.edge_subgraph</code></a>(edges)</td><td>Returns the subgraph induced by the specified edges.</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> networkx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广度优先搜索和深度优先搜索</title>
      <link href="/notes/introduction-to-algorithms/breadth-first-search-and-depth-first-search/"/>
      <url>/notes/introduction-to-algorithms/breadth-first-search-and-depth-first-search/</url>
      
        <content type="html"><![CDATA[<h1 id="广度优先搜索">广度优先搜索</h1><p>广度优先搜索是最简单的图搜索算法之一，也是许多重要算法的原型。<strong>Prim的最小生成树算法和Dijkstra的单源最短路径算法都使用了类似广度优先搜索的思想</strong>。</p><p>给定图G=(V,E)和一个可以识别的源结点s，广度优先搜索对图G中的边进行系统性的探索来发现<strong>可以从源结点s到达的所有结点</strong>。该算法能够计算从源结点s到每个可到达的结点的距离（最少的边数），同时生成一棵“广度优先搜索树”。该树以源结点s为根节点，包含所有可以从s到达的结点。对于每个从源结点s可以到达的结点v，在广度优先搜索树里从结点s到结点v的简单路径所对应的就是图G中从结点s到结点v的“最短路径”，即包含最少边数的路径。该算法既可以用于有向图，也可以用于无向图。</p><p>广度优先搜索之所以如此得名是因为该算法始终是将已发现结点和未发现结点之间的边界，沿其广度方向向外扩展。也就是说，<strong>算法需要在发现所有距离源结点s为k的所有结点之后，才会发现距离源结点s为k+1的其他结点</strong>。</p><h2 id="算法">算法</h2><p>为了跟踪算法的进展，广度优先搜索在概念上将每个结点涂上白色、灰色或黑色。所有结点在一开始的时候涂上白色。在算法推进过程中，这些结点可能会变成灰色或黑色（灰色或黑色结点不会变回白色）。在搜索过程中，第一次遇到一个结点就称该结点被“<strong>发现</strong>”，此时该结点的颜色将发生改变。因此，凡是灰色和黑色的结点都是已被发现的结点。</p><a id="more"></a><p>如果边<span class="math inline">\((u,v)\in{E}\)</span>且结点u是黑色，则结点v既可能是灰色也可能是黑色。也就是说，所有与黑色结点邻接的结点都已经被发现。对于灰色结点来说，其邻接结点中可能存在未被发现的白色结点。灰色结点所代表的就是已知和未知两个集合之间的边界。</p><p>在执行广度优先搜索的过程中将构造出一棵广度优先树。一开始，该树仅含有根节点，就是源结点s。在扫描已发现结点u的邻接链表时，每当发现一个白色结点v，就将结点v和边(u,v)同时加入该棵树中。在广度优先树中，称结点u是结点v的<strong>前驱</strong>或者<strong>父结点</strong>。由于每个结点最多被发现一次，它最多只有一个父结点。广度优先树中的祖先和后代关系皆以相对于根节点s的位置来定义：如果结点u是从根节点s到结点v的简单路径上的一个结点，则结点u是结点v的祖先，结点v是结点u的后代。</p><p>在下面给出的 广度优先搜索过程BFS中，假定输入图G=(V,E)是以邻接链表所表示的。该算法为图中每个结点赋予了一些额外的属性：</p><ul><li>u.color：每个结点u的颜色。</li><li>u.pi：u的前驱结点，如果u没有前驱结点，则u.pi=NIL。</li><li>u.d：BFS算法所计算出的从源结点s到结点u之间的距离。</li></ul><p>该算法使用一个先进先出的队列Q来管理灰色结点集。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BFS(G, s):</span><br><span class="line">    <span class="keyword">for</span> each vertex u <span class="keyword">in</span> G.V-&#123;s&#125;:  <span class="comment"># 初始化</span></span><br><span class="line">        u.color = WHITE</span><br><span class="line">        u.d = infinity</span><br><span class="line">        u.pi = NIL</span><br><span class="line">    s.color = GRAY</span><br><span class="line">    s.d = <span class="number">0</span></span><br><span class="line">    s.pi = NIL</span><br><span class="line">    Q = &#123;&#125;</span><br><span class="line">    ENQUEUE(Q, s)</span><br><span class="line">    <span class="keyword">while</span> Q <span class="keyword">is</span> <span class="keyword">not</span> empty:</span><br><span class="line">        u = DEQUEUE(Q)</span><br><span class="line">        <span class="keyword">for</span> each v <span class="keyword">in</span> G.Adj[u]:</span><br><span class="line">            <span class="keyword">if</span> v.color == WHITE:</span><br><span class="line">                v.color = GRAY</span><br><span class="line">                v.d = u.d + <span class="number">1</span></span><br><span class="line">                v.pi = u</span><br><span class="line">                ENQUEUE(Q, v)</span><br><span class="line">        u.color = BLACK</span><br></pre></td></tr></table></figure><p>下图描述的是BFS在一个样本图上的推进过程。</p><p><img src="/uploads/image/introduction-to-algorithms/operation-of-BFS-on-an-undirected-graph.png" title="BFS在一个无向图上的推进过程"></p><h2 id="分析">分析</h2><p>每个结点的入队（当它是白色时）次数最多为一次，因而出队最多一次。入队和出队的时间均为O(1)，因此，对队列进行操作的总时间为O(V)。因为算法只在一个结点出队的时候才对该结点的邻接链表进行扫描，所以每个邻接链表最多只扫描一次。由于所有邻接链表的长度之和是<span class="math inline">\(\Theta(E)\)</span>，用于扫描邻接链表的总时间为O(E)。初始化操作的成本是O(V)，因此<strong>广度优先搜索的总运行时间为</strong>O(V+E)。因此，广度优先搜索的运行时间是图G的邻接链表大小的一个线性函数。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> networkx <span class="keyword">import</span> Graph</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_f</span><span class="params">(graph)</span>:</span></span><br><span class="line">    fmt = <span class="string">'&#123;0:&lt;10s&#125; &#123;1:&lt;10s&#125; &#123;2:&lt;10s&#125;\n'</span></span><br><span class="line">    title = fmt.format(<span class="string">'vertex'</span>, <span class="string">'distance'</span>, <span class="string">'previous'</span>)</span><br><span class="line">    data = <span class="string">''</span>.join(fmt.format(str(k), str(attr[<span class="string">'distance'</span>]), str(attr[<span class="string">'previous'</span>])) <span class="keyword">for</span> k, attr <span class="keyword">in</span> graph.nodes.items())</span><br><span class="line">    print(title + data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">breadth_first_search</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> attr <span class="keyword">in</span> graph.nodes.values():</span><br><span class="line">        attr[<span class="string">'visited'</span>], attr[<span class="string">'distance'</span>], attr[<span class="string">'previous'</span>] = <span class="literal">False</span>, float(<span class="string">'inf'</span>), <span class="literal">None</span></span><br><span class="line">    graph.nodes[s][<span class="string">'visited'</span>], graph.nodes[s][<span class="string">'distance'</span>], q = <span class="literal">True</span>, <span class="number">0</span>, Queue()</span><br><span class="line">    q.put(s)</span><br><span class="line">    <span class="keyword">while</span> q.empty() <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">        u = q.get()</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> graph[u].keys():</span><br><span class="line">            v_attr, u_attr = graph.nodes[v], graph.nodes[u]</span><br><span class="line">            <span class="keyword">if</span> v_attr[<span class="string">'visited'</span>] <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">                v_attr[<span class="string">'visited'</span>], v_attr[<span class="string">'distance'</span>], v_attr[<span class="string">'previous'</span>] = <span class="literal">True</span>, u_attr[<span class="string">'distance'</span>] + <span class="number">1</span>, u</span><br><span class="line">                q.put(v)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    g = Graph()</span><br><span class="line">    g.add_nodes_from(<span class="string">'rstuvwxy'</span>)</span><br><span class="line">    g.add_edges_from(</span><br><span class="line">        [(<span class="string">'r'</span>, <span class="string">'v'</span>), (<span class="string">'r'</span>, <span class="string">'s'</span>), (<span class="string">'s'</span>, <span class="string">'w'</span>), (<span class="string">'w'</span>, <span class="string">'t'</span>), (<span class="string">'w'</span>, <span class="string">'x'</span>), (<span class="string">'t'</span>, <span class="string">'x'</span>), (<span class="string">'t'</span>, <span class="string">'u'</span>), (<span class="string">'u'</span>, <span class="string">'x'</span>), (<span class="string">'u'</span>, <span class="string">'y'</span>),</span><br><span class="line">         (<span class="string">'x'</span>, <span class="string">'y'</span>)])</span><br><span class="line">    breadth_first_search(g, <span class="string">'s'</span>)</span><br><span class="line">    print_f(g)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vertex     distance   previous  </span><br><span class="line">r          1          s</span><br><span class="line">s          0          None</span><br><span class="line">t          2          w</span><br><span class="line">u          3          t</span><br><span class="line">v          2          r</span><br><span class="line">w          1          s</span><br><span class="line">x          2          w</span><br><span class="line">y          3          x</span><br></pre></td></tr></table></figure><h1 id="深度优先搜索">深度优先搜索</h1><p>深度优先搜索总是对最近才发现的结点v的出发边进行搜索，直到该结点的所有出发边都被发现为止。一旦结点v的所有出发边都被发现，搜索则“回溯”到v的前驱结点，来搜索该前驱结点的出发边。该过程一直持续到从源结点可以达到的所有结点都被发现为止。如果还存在尚未发现的结点，则深度优先搜索将从这些未被发现的结点中任选一个作为新的源结点，并重复同样的搜索过程。该算法重复整个过程，直到图中的所有结点都被发现为止。</p><p>与广度优先搜索不同的是，广度优先搜索的前驱子图形成一棵树，而深度优先搜索的前驱子图可能由多棵树组成，因为搜索可能从多个源结点重复进行。深度优先搜索的前驱子图形成一个由多棵<strong>深度优先树</strong>构成的<strong>深度优先森林</strong>。</p><h2 id="算法-1">算法</h2><p>像广度优先搜索算法一样，深度优先搜索算法在搜索过程中也是对结点进行涂色来指明结点的状态。每个结点的初始颜色都是白色，在结点被<strong>发现</strong>后变为灰色，在其邻接链表被扫描完成后变为黑色。该方法可以保证每个结点仅在一棵深度优先树中出现，因此，所有的深度优先树是不相交的（disjoint）。</p><p>深度优先搜索算法还在每个结点盖上一个<strong>时间戳</strong>。每个结点v有两个时间戳：第一个时间戳v.d记录结点v第一次被发现的时间（涂上灰色的时候），第二个时间戳v.f记录的是搜索完成对v的邻接链表扫描的时间（涂上黑色的时候）。这些时间戳提供了图结构的重要信息，通常能够帮助推断深度优先算法的行为。</p><p>因为|V|个结点中每个结点只能有一个发现事件和一个完成事件，所以这些时间戳都是处于1和2|V|之间的整数。很显然，对于每个结点u，我们有：u.d &lt; u.f。结点u在时刻u.d之前为白色，在时刻u.d和u.f之间为灰色，在时刻u.f之后为黑色。</p><p>下面的伪代码给出的是基本的深度优先搜索算法。输入图G既可以是无向图，也可以是有向图。变量time是一个全局变量，用来计算时间戳。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DFS(G):</span><br><span class="line">    <span class="keyword">for</span> each vertex u <span class="keyword">in</span> G.V:  <span class="comment"># 初始化</span></span><br><span class="line">        u.color = WHITE</span><br><span class="line">        u.pi = NIL</span><br><span class="line">    time = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> each vertex u <span class="keyword">in</span> G.V:</span><br><span class="line">        <span class="keyword">if</span> u.color == WHITE:</span><br><span class="line">            DFS-VISIT(G, u)  <span class="comment"># 以u为源结点进行深度优先探索</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DFS-VISIT(G, u):</span><br><span class="line">    time = time + <span class="number">1</span></span><br><span class="line">    u.d = time</span><br><span class="line">    u.color = GRAY            <span class="comment"># 发现</span></span><br><span class="line">    <span class="keyword">for</span> each v <span class="keyword">in</span> G.Adj[u]:   <span class="comment"># 探索u的邻接结点</span></span><br><span class="line">        <span class="keyword">if</span> v.color == WHITE:  <span class="comment"># 若发现新的未探索结点</span></span><br><span class="line">            v.pi = u</span><br><span class="line">            DFS-VISIT(G, v)   <span class="comment"># 优先递归探索新的结点v</span></span><br><span class="line">            <span class="comment"># 探索完v后，循环继续进行，探索u的下一个邻接结点</span></span><br><span class="line">    u.color = BLACK</span><br><span class="line">    time = time + <span class="number">1</span></span><br><span class="line">    u.f = time                <span class="comment"># 探索完成</span></span><br></pre></td></tr></table></figure><p>注意，深度优先算法的结果可能依赖于算法DFS中第6行对结点进行检查的次序和算法DFS-VISIT中的第5行对一个结点的邻接结点进行访问的次序。不过，这些不同的访问次序在实际中并不会导致问题，因为我们通常可以对任意的深度优先搜索结果加以有效利用，并获得等价的结果。</p><p>下图展示算法DFS在有向图上的运行过程。结点中的时间戳表明该结点的发现时间和完成时间。</p><p><img src="/uploads/image/introduction-to-algorithms/progress-of-the-depth-first-search-algorithm-DFS-on-a-directed-graph.png"></p><h2 id="分析-1">分析</h2><p>如果排除调用DFS-VISIT的时间，DFS中两个循环所需的时间均为<span class="math inline">\(\Theta(V)\)</span>。对每个结点<span class="math inline">\(v\in{V}\)</span>来说，DFS-VISIT被调用的次数刚好为1次，这是因为在对一个结点u调用DFS-VISIT时，该结点u必须是白色，而DFS-VISIT所做的第一件事情就是将结点u涂上灰色。在执行DFS-VISIT(G, v)的过程中，5~8行的循环所执行的次数为|Adj[v]|。由于<span class="math inline">\(\sum_{v\in{V}}|Adj[v]|=\Theta(E)\)</span>，执行循环操作的总成本是<span class="math inline">\(\Theta(E)\)</span>。因此，深度优先搜索算法的运行时间为<span class="math inline">\(\Theta(V+E)\)</span>。</p><h2 id="代码-1">代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> networkx <span class="keyword">import</span> Graph, DiGraph</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_f</span><span class="params">(g)</span>:</span></span><br><span class="line">    fmt = <span class="string">'&#123;0:&lt;10s&#125; &#123;1:&lt;10s&#125; &#123;2:&lt;10s&#125;\n'</span></span><br><span class="line">    title = fmt.format(<span class="string">'vertex'</span>, <span class="string">'distance'</span>, <span class="string">'previous'</span>)</span><br><span class="line">    data = <span class="string">''</span>.join(fmt.format(str(k), str(attr[<span class="string">'distance'</span>]), str(attr[<span class="string">'previous'</span>])) <span class="keyword">for</span> k, attr <span class="keyword">in</span> g.nodes.items())</span><br><span class="line">    print(title + data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">depth_first_search</span><span class="params">(g)</span>:</span>  <span class="comment"># 函数入口</span></span><br><span class="line">    <span class="keyword">for</span> attr <span class="keyword">in</span> g.nodes.values():  <span class="comment"># 初始化</span></span><br><span class="line">        attr[<span class="string">'visited'</span>], attr[<span class="string">'previous'</span>] = <span class="literal">False</span>, <span class="literal">None</span></span><br><span class="line">    g.graph[<span class="string">'time'</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> u, attr <span class="keyword">in</span> g.nodes.items():  <span class="comment"># 递归搜索无法访问到非连通的部分，通过此处循环解决</span></span><br><span class="line">        <span class="keyword">if</span> attr[<span class="string">'visited'</span>] <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">            dfs_visit(g, u)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs_visit</span><span class="params">(g, u)</span>:</span>  <span class="comment"># 递归方法主体</span></span><br><span class="line">    g.graph[<span class="string">'time'</span>] += <span class="number">1</span></span><br><span class="line">    g.nodes[u][<span class="string">'distance'</span>], g.nodes[u][<span class="string">'visited'</span>] = g.graph[<span class="string">'time'</span>], <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> g[u].keys():</span><br><span class="line">        <span class="keyword">if</span> g.nodes[v][<span class="string">'visited'</span>] <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">            g.nodes[v][<span class="string">'previous'</span>] = u</span><br><span class="line">            dfs_visit(g, v)  <span class="comment"># 递归</span></span><br><span class="line">    g.nodes[u][<span class="string">'visited'</span>] = <span class="literal">True</span></span><br><span class="line">    g.graph[<span class="string">'time'</span>] += <span class="number">1</span></span><br><span class="line">    g.nodes[u][<span class="string">'distance'</span>] = str(g.nodes[u][<span class="string">'distance'</span>]) + <span class="string">'/'</span> + str(g.graph[<span class="string">'time'</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    h = DiGraph()</span><br><span class="line">    h.add_nodes_from(<span class="string">'uvwxyz'</span>)</span><br><span class="line">    h.add_edges_from([(<span class="string">'u'</span>, <span class="string">'v'</span>), (<span class="string">'u'</span>, <span class="string">'x'</span>), (<span class="string">'x'</span>, <span class="string">'v'</span>), (<span class="string">'v'</span>, <span class="string">'y'</span>), (<span class="string">'y'</span>, <span class="string">'x'</span>), (<span class="string">'w'</span>, <span class="string">'y'</span>), (<span class="string">'w'</span>, <span class="string">'z'</span>), (<span class="string">'z'</span>, <span class="string">'z'</span>)])</span><br><span class="line">    depth_first_search(h)</span><br><span class="line">    print_f(h)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vertex     distance   previous  </span><br><span class="line">u          1/8        None</span><br><span class="line">v          2/7        u</span><br><span class="line">w          9/12       None</span><br><span class="line">x          4/5        y</span><br><span class="line">y          3/6        v</span><br><span class="line">z          10/11      w</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Algorithms </tag>
            
            <tag> algorithms </tag>
            
            <tag> stack </tag>
            
            <tag> recursion </tag>
            
            <tag> queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的表示</title>
      <link href="/notes/introduction-to-algorithms/representations-of-graphs/"/>
      <url>/notes/introduction-to-algorithms/representations-of-graphs/</url>
      
        <content type="html"><![CDATA[<h1 id="图的表示">图的表示</h1><p>对于图G=(V,E)，可以用两种标准表示方法表示。两种表示方法都既可以表示无向图，也可以表示有向图。</p><ul><li><p><strong>邻接链表表示</strong>：将图作为邻接链表的组合。</p><p>在表示<strong>稀疏图</strong>（边的条数|E|远远小于<span class="math inline">\(|V|^2\)</span>的图）时非常紧凑而成为通常的选择。</p></li><li><p><strong>邻接矩阵表示</strong>：将图作为邻接矩阵来看待。</p><p>在<strong>稠密图</strong>（|E|接近<span class="math inline">\(|V|^2\)</span>的图）的情况下，倾向于使用邻接矩阵表示法。另外，如果需要快速判断任意两个结点之间是否有边相连，可能也需要使用邻接矩阵表示法。</p></li></ul><p><img src="/uploads/image/introduction-to-algorithms/two-representations-of-an-undirected-graph.png" title="无向图的表示方法"></p><p><img src="/uploads/image/introduction-to-algorithms/two-representations-of-a-directed-graph.png" title="有向图的表示方法"></p><a id="more"></a><h1 id="邻接链表表示">邻接链表表示</h1><p>如上图(b)所示：对于图G=(V,E)来说，其<strong>邻接链表表示</strong>由一个包含|V|条链表的数组Adj所构成，每个结点有一条链表。对于每个结点<span class="math inline">\(u\in{V}\)</span>，邻接链表Adj[u]包含所有与结点u之间有边相邻的结点v，即Adj[u]包含图G中所有与u邻接的结点（也可以说，该链表里包含指向这些结点的指针）。</p><p>如果G是一个有向图，则对于边(u,v)来说，结点v将出现在链表Adj[u]里，因此，所有邻接链表的长度之和等于|E|。如果G是一个无向图，则对于边(u,v)来说，结点v将出现在链表Adj[u]里，结点u将出现在链表Adj[v]里，因此，所有邻接链表的长度之和为2|E|。但不管是有向图还是无向图，邻接链表表示法的存储空间需求均为<span class="math inline">\(\Theta(V+E)\)</span>。</p><p>对邻接链表稍加修改，即可以用来表示<strong>权重图</strong>，权重图是图中的每条边都带有一个相关的权重的图。可以直接将边<span class="math inline">\((u,v)\in{E}\)</span>的权重值w(u,v)存放在结点u的邻接链表里。从这种意义上说，邻接链表表示法的鲁棒性很高，可以通过对其进行简单修改来支持许多其他的图变种。</p><p>邻接链表的一个潜在缺陷是无法快速判断一条边(u,v)是否是图中的一条边，唯一的办法是在邻接链表Adj[u]里面搜索结点v。邻接矩阵表示则克服了这个缺陷，但付出的代价是更大的存储空间消耗。</p><h1 id="邻接矩阵表示">邻接矩阵表示</h1><p>对于<strong>邻接矩阵表示</strong>来说，通常会将图G中的结点编为<code>1,2,...,|V|</code>，这种编号可以是任意的。在进行此种编号之后，图G的邻接矩阵表示由一个<span class="math inline">\(|V|\times|V|\)</span>的矩阵<span class="math inline">\(A=(a_{ij})\)</span>予以表示，该矩阵满足下述条件： <span class="math display">\[a_{ij}=\begin{cases}1\quad\text{if }(i,j)\in{E}\\0\quad\text{otherwise}\end{cases}\]</span> 图(c)给出的是图(a)的邻接矩阵表示。不管一个图中由多少条边，邻接矩阵的空间需求皆为<span class="math inline">\(\Theta(V^2)\)</span>。</p><p>无向图的邻接矩阵是一个对称矩阵。由于在无向图中，边(u,v)和边(v,u)是同一条边，无向图的邻接矩阵A就是自己的转置，即<span class="math inline">\(A=A^T\)</span>。在某些应用中，可能只需要存放对角线及其以上的这部分邻接矩阵（即半个矩阵），从而将图存储空间需要减少几乎一半。</p><p>与邻接链表表示法一样，邻接矩阵也可以用来表示权重图。例如，如果G=(V,E)为一个权重图，则直接将边<span class="math inline">\((u,v)\in{E}\)</span>的权重w(u,v)存放在邻接矩阵中的第u行第v列记录上。对于不存在的边，则在相应的行列记录上存放值NIL。不过，对于许多问题来说，用0或<span class="math inline">\(\infty\)</span>来表示一条不存在的边可能更为便捷。</p><p>邻接矩阵表示法更为简单，因此在图规模比较小时，可能更倾向于使用邻接矩阵表示法。</p><p>而且，对于无向图来说，邻接矩阵还有一个优势：每个纪录项只需要1位空间。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graph </tag>
            
            <tag> Introduction to Algorithms </tag>
            
            <tag> adjacent list </tag>
            
            <tag> adjacent matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小费用流问题</title>
      <link href="/notes/minimum-cost-flow-problems/"/>
      <url>/notes/minimum-cost-flow-problems/</url>
      
        <content type="html"><![CDATA[<h1 id="最小费用流问题">最小费用流问题</h1><p>最小费用流问题（MCFP）试图在一个流网络中寻找发送指定流量的最便宜的可行方案。一个典型的应用是寻找工厂到仓库之间的最佳配送路径，每段路线都有相应的容量和费用。</p><p><strong>定义</strong></p><p>有向图G=(V,E)定义的流网络中，源结点为<span class="math inline">\(s\in{V}\)</span>，汇点为t，每条边<span class="math inline">\((u,v)\in{E}\)</span>有容量c(u,v)&gt;0，流<span class="math inline">\(f(u,v)\ge0\)</span>和代价a(u,v)（代价可以为负）。沿某条边(u,v)发送流量的代价为f(u,v)*a(u,v)。问题要求从源结点s发送指定大小的流量d到汇点t。最小费用流问题试图最小化所有边的总代价：<span class="math inline">\(\sum_{(u,v)\in{E}}a(u,v)*f(u,v)\)</span></p><p>满足以下约束条件：</p><ul><li>容量限制：对于所有的结点<span class="math inline">\(u,v\in{V}\)</span>，要求<span class="math inline">\(0\le{f(u,v)}\le{c(u,v)}\)</span>。</li><li>流量守恒：对于所有的结点<span class="math inline">\(u\in{V-\lbrace{s,t}\rbrace}\)</span>，要求<span class="math inline">\(\sum_{v\in{V}}f(v,u)=\sum_{v\in{V}}f(u，v)\)</span>。</li><li>流量要求：<span class="math inline">\(\sum_{v\in{V}}f(s,v)=d\quad\text{and}\quad\sum_{v\in{V}}f(v,t)=d\)</span>。</li></ul><h1 id="负权环路消除法">负权环路消除法</h1><p>负权环路是指有向图G=(V,E)中的环路且构成环路的所有边的权重之和为负数值。</p><a id="more"></a><h2 id="残存网络">残存网络</h2><p>假定由一个流网络G=(V,E)，其源结点为s，汇点为t。设f为图G中的一个流，考虑结点对<span class="math inline">\(u,v\in{V}\)</span>，定义残存容量<span class="math inline">\(c_f(u,v)\)</span>如下： <span class="math display">\[c_f(u,v)=\begin{cases}c(u,v)-f(u,v)&amp;\text{if }(u,v)\in{E}\\f(v,u)&amp;\text{if }(v,u)\in{E}\\0&amp;otherwise\end{cases}\]</span> 定义残存网络代价<span class="math inline">\(a_f(u,v)\)</span>如下： <span class="math display">\[a_f(u,v)=\begin{cases}a(u,v)&amp;\text{if }(u,v)\in{E}\\-a(u,v)&amp;\text{if }(v,u)\in{E}\\0&amp;otherwise\end{cases}\]</span> 负权环路消除法的核心思想是在残存网络中寻找从源结点s可达的负权环路，然后沿环路发送流量。直到残存网路中不存在从源结点s可达的负权环路为止。算法的步骤如下：</p><ol type="1"><li>设G=(V,E)为一个流网络，求出值为d的一个流。通过修改最大流的Ford-Fulkerson算法，可以求出值为d的一个流。</li><li>在残存网络中寻找从源结点s可达的负权环路。单源最短路径算法的Bellman-Ford算法可以检测图G=(V,E)中是否含有负权环路，通过修改Bellman-Ford算法可以求出该环路。</li><li>若存在，沿环路发送流量，返回步骤2。若不存在，则当前网络中的流为最佳方案。</li></ol><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> graph.max_flow <span class="keyword">import</span> find_path</span><br><span class="line"><span class="keyword">from</span> graph.bellman_ford <span class="keyword">import</span> initialize_single_source, relax</span><br><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_f</span><span class="params">(graph)</span>:</span></span><br><span class="line">    print(<span class="string">'min cost:'</span>, graph.graph[<span class="string">'min_cost'</span>])</span><br><span class="line">    fmt = <span class="string">'&#123;0:&lt;4s&#125; &#123;1:&lt;4s&#125; &#123;2:&lt;4s&#125; &#123;3:&lt;4s&#125; &#123;4:&lt;8s&#125;\n'</span></span><br><span class="line">    title = fmt.format(<span class="string">'u'</span>, <span class="string">'v'</span>, <span class="string">'flow'</span>, <span class="string">'cost'</span>, <span class="string">'capacity'</span>)</span><br><span class="line">    data = <span class="string">''</span>.join(</span><br><span class="line">        fmt.format(str(u), str(v), str(attr[<span class="string">'flow'</span>]), str(attr[<span class="string">'cost'</span>]), str(attr[<span class="string">'capacity'</span>]))</span><br><span class="line">        <span class="keyword">for</span> u, v, attr <span class="keyword">in</span> graph.edges(data=<span class="literal">True</span>) <span class="keyword">if</span> attr[<span class="string">'flow'</span>] &gt; <span class="number">0</span>)</span><br><span class="line">    print(title + data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flow</span><span class="params">(graph, s, t, f)</span>:</span></span><br><span class="line">    <span class="string">"""求出任意一个值为f的流"""</span></span><br><span class="line">    p = find_path(graph, s, t, set())</span><br><span class="line">    <span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        residual = [graph[u][v][<span class="string">'capacity'</span>] - graph[u][v][<span class="string">'flow'</span>] <span class="keyword">for</span> u, v <span class="keyword">in</span> p]</span><br><span class="line">        augment_flow = min(min(residual), f)</span><br><span class="line">        <span class="keyword">for</span> u, v <span class="keyword">in</span> p:</span><br><span class="line">            graph[u][v][<span class="string">'flow'</span>] += augment_flow</span><br><span class="line">            graph[v][u][<span class="string">'flow'</span>] -= augment_flow</span><br><span class="line">        f -= augment_flow</span><br><span class="line">        <span class="keyword">if</span> f == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        p = find_path(graph, s, t, set())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bellman_ford</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    initialize_single_source(graph, s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(graph.number_of_nodes() - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> u, v, e_attr <span class="keyword">in</span> graph.edges(data=<span class="literal">True</span>):</span><br><span class="line">            <span class="keyword">if</span> e_attr[<span class="string">'capacity'</span>] - e_attr[<span class="string">'flow'</span>] &gt; <span class="number">0</span>:  <span class="comment"># 只有此值大于0的边存在于残存网络中</span></span><br><span class="line">                relax(graph, u, v, e_attr[<span class="string">'cost'</span>])</span><br><span class="line">    <span class="keyword">for</span> u, v, e_attr <span class="keyword">in</span> graph.edges(data=<span class="literal">True</span>):</span><br><span class="line">        residual = e_attr[<span class="string">'capacity'</span>] - e_attr[<span class="string">'flow'</span>]</span><br><span class="line">        <span class="keyword">if</span> residual &gt; <span class="number">0</span> <span class="keyword">and</span> graph.nodes[v][<span class="string">'distance'</span>] &gt; graph.nodes[u][<span class="string">'distance'</span>] + e_attr[<span class="string">'cost'</span>]:</span><br><span class="line">            <span class="comment"># 当存在负权环路时，返回从环路可达的一个结点</span></span><br><span class="line">            <span class="keyword">return</span> u</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_negative_cycle</span><span class="params">(graph, v, cycle)</span>:</span></span><br><span class="line">    <span class="string">"""根据previous属性找出环路"""</span></span><br><span class="line">    <span class="comment"># 先找到环路中任一结点</span></span><br><span class="line">    visit = &#123;v&#125;</span><br><span class="line">    pre = graph.nodes[v][<span class="string">'previous'</span>]  <span class="comment"># 前驱结点</span></span><br><span class="line">    <span class="keyword">while</span> pre <span class="keyword">not</span> <span class="keyword">in</span> visit:</span><br><span class="line">        visit.add(pre)</span><br><span class="line">        pre = graph.nodes[pre][<span class="string">'previous'</span>]</span><br><span class="line">    <span class="comment"># 通过previous找出环路</span></span><br><span class="line">    anchor = pre</span><br><span class="line">    end, start = pre, graph.nodes[pre][<span class="string">'previous'</span>]</span><br><span class="line">    <span class="keyword">while</span> start != anchor:</span><br><span class="line">        cycle.append((start, end))</span><br><span class="line">        end = start</span><br><span class="line">        start = graph.nodes[start][<span class="string">'previous'</span>]</span><br><span class="line">    cycle.append((start, end))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">negative_cycle_canceling</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    key = bellman_ford(graph, s)  <span class="comment"># bellman ford求最短路径的方式寻找环路</span></span><br><span class="line">    <span class="keyword">while</span> key <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        cycle = []</span><br><span class="line">        get_negative_cycle(graph, key, cycle)</span><br><span class="line">        cancel_flow = min(graph[u][v][<span class="string">'capacity'</span>] - graph[u][v][<span class="string">'flow'</span>] <span class="keyword">for</span> u, v <span class="keyword">in</span> cycle)  <span class="comment"># 修改环路上的流量</span></span><br><span class="line">        <span class="keyword">for</span> u, v <span class="keyword">in</span> cycle:</span><br><span class="line">            graph[u][v][<span class="string">'flow'</span>] += cancel_flow</span><br><span class="line">            graph[v][u][<span class="string">'flow'</span>] -= cancel_flow</span><br><span class="line">        key = bellman_ford(graph, s)  <span class="comment"># 重新寻找环路</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min_cost</span><span class="params">(graph, s, t, d)</span>:</span></span><br><span class="line">    <span class="string">"""求解流量值为d的最小费用流"""</span></span><br><span class="line">    flow(graph, s, t, d)  <span class="comment"># 先找到一个可行解，当d大于最大流量时，找到的可行解是最大流量</span></span><br><span class="line">    negative_cycle_canceling(graph, s)  <span class="comment"># 移除负权环路</span></span><br><span class="line">    graph.graph[<span class="string">'min_cost'</span>] = sum(attr[<span class="string">'flow'</span>] * attr[<span class="string">'cost'</span>] <span class="keyword">for</span> attr <span class="keyword">in</span> graph.edges.values() <span class="keyword">if</span> attr[<span class="string">'flow'</span>] &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_graph</span><span class="params">(graph, vertices, edges)</span>:</span></span><br><span class="line">    graph.add_nodes_from(vertices)</span><br><span class="line">    <span class="keyword">for</span> u, v, cap, cost <span class="keyword">in</span> edges:</span><br><span class="line">        graph.add_edges_from([(u, v, &#123;<span class="string">'capacity'</span>: cap, <span class="string">'cost'</span>: cost&#125;), (v, u, &#123;<span class="string">'capacity'</span>: <span class="number">0</span>, <span class="string">'cost'</span>: -cost&#125;)], flow=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    g = nx.DiGraph()</span><br><span class="line">    v = <span class="string">'s1234t'</span></span><br><span class="line">    e = [(<span class="string">'s'</span>, <span class="string">'1'</span>, <span class="number">10</span>, <span class="number">2</span>), (<span class="string">'s'</span>, <span class="string">'3'</span>, <span class="number">35</span>, <span class="number">4</span>), (<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="number">20</span>, <span class="number">6</span>), (<span class="string">'1'</span>, <span class="string">'3'</span>, <span class="number">10</span>, <span class="number">1</span>), (<span class="string">'2'</span>, <span class="string">'t'</span>, <span class="number">35</span>, <span class="number">2</span>),</span><br><span class="line">         (<span class="string">'3'</span>, <span class="string">'2'</span>, <span class="number">5</span>, <span class="number">6</span>), (<span class="string">'3'</span>, <span class="string">'4'</span>, <span class="number">30</span>, <span class="number">2</span>), (<span class="string">'4'</span>, <span class="string">'2'</span>, <span class="number">15</span>, <span class="number">2</span>), (<span class="string">'4'</span>, <span class="string">'t'</span>, <span class="number">10</span>, <span class="number">7</span>)]</span><br><span class="line">    initialize_graph(g, v, e)</span><br><span class="line">    min_cost(g, <span class="string">'s'</span>, <span class="string">'t'</span>, <span class="number">20</span>)</span><br><span class="line">    print_f(g)</span><br><span class="line"></span><br><span class="line">    g.clear()</span><br><span class="line">    e = [(<span class="string">'s'</span>, <span class="string">'1'</span>, <span class="number">16</span>, <span class="number">3</span>), (<span class="string">'s'</span>, <span class="string">'2'</span>, <span class="number">13</span>, <span class="number">4</span>), (<span class="string">'1'</span>, <span class="string">'3'</span>, <span class="number">12</span>, <span class="number">7</span>), (<span class="string">'2'</span>, <span class="string">'1'</span>, <span class="number">4</span>, <span class="number">3</span>), (<span class="string">'2'</span>, <span class="string">'4'</span>, <span class="number">14</span>, <span class="number">6</span>),</span><br><span class="line">         (<span class="string">'3'</span>, <span class="string">'2'</span>, <span class="number">9</span>, <span class="number">5</span>), (<span class="string">'3'</span>, <span class="string">'t'</span>, <span class="number">20</span>, <span class="number">6</span>), (<span class="string">'4'</span>, <span class="string">'3'</span>, <span class="number">7</span>, <span class="number">8</span>), (<span class="string">'4'</span>, <span class="string">'t'</span>, <span class="number">4</span>, <span class="number">9</span>)]</span><br><span class="line">    initialize_graph(g, v, e)</span><br><span class="line">    min_cost(g, <span class="string">'s'</span>, <span class="string">'t'</span>, <span class="number">19</span>)</span><br><span class="line">    print_f(g)</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">min cost: 195</span><br><span class="line">u    v    flow cost capacity</span><br><span class="line">s    1    10   2    10</span><br><span class="line">s    3    10   4    35</span><br><span class="line">1    2    5    6    20</span><br><span class="line">1    3    5    1    10</span><br><span class="line">2    t    20   2    35</span><br><span class="line">3    4    15   2    30</span><br><span class="line">4    2    15   2    15</span><br><span class="line"></span><br><span class="line">min cost: 340</span><br><span class="line">u    v    flow cost capacity</span><br><span class="line">s    1    12   3    16</span><br><span class="line">s    2    7    4    13</span><br><span class="line">1    3    12   7    12</span><br><span class="line">2    4    7    6    14</span><br><span class="line">3    t    15   6    20</span><br><span class="line">4    3    3    8    7</span><br><span class="line">4    t    4    9    4</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithms </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大子数组问题</title>
      <link href="/notes/introduction-to-algorithms/maximum-subarray-problems/"/>
      <url>/notes/introduction-to-algorithms/maximum-subarray-problems/</url>
      
        <content type="html"><![CDATA[<h1 id="最大化收益">最大化收益</h1><p>假设你知道了未来 17 天某公司的股票价格，你的目标是最大化收益。</p><ul><li>你可能认为可以“低价买进，高价卖出”——在最低价格时买进股票，之后在最高价格时卖出，这样可以最大化收益。但遗憾的是，在一段时间内，可能无法做到在最低价格时买进股票，然后在最高价格时卖出。例如，下图中，最低价在后，最高价在前。</li></ul><p><img src="/uploads/image/introduction-to-algorithms/maximum-subarray-problem-price-of-stock.png" title="未来 17 天股票价格"></p><a id="more"></a><ul><li>你还可能认为可以在最低价格时买进，或在最高价格时卖出，即可最大化收益。如果这种策略总是有效的，则确定最大化收益是非常简单的：寻找最高和最低价格，然后从最高价格开始向左寻找之前的最低价格；从最低价格开始向右寻找之后的最高价格；取两对价格中差值最大者。例如上图中，在第 7 天股票价格最低时买入，即可最大化收益。但下图给出了一个简单的反例，显示有时最大收益既不是在最低价格时买进，也不是在最高价格时卖出。</li></ul><p><img src="/uploads/image/introduction-to-algorithms/maximum-subarray-problem-a-counter-example.png" title="一个反例：最大收益既不是在最低价格时买进，也不是在最高价格时卖出"></p><p>暴力求解方法：</p><p>尝试每对可能的买进和卖出日期组合，只要卖出日期在买进日期之后即可。n 天中共有 <span class="math inline">\(\begin{pmatrix}n\\2\end{pmatrix}=\Theta(n^2)\)</span> 种日期组合。处理每对日期所花费的时间至少也是常量，因次这种方法的运行时间为 <span class="math inline">\(\Omega(n^2)\)</span>。</p><h1 id="最大子数组问题">最大子数组问题</h1><p>从一个稍微不同的角度来看待输入数据。我们的目的是寻找一段日期，使得从第一天到最后一天的股票价格净变值最大。因此，我们不再从每日价格的角度来看待输入数据，而是考察每日价格变化，第 <code>i</code> 天的价格变化定义为第i天和第 <code>i-1</code> 天的价格差。第一幅图的最后一行给出了每日价格变化。如果将这一行看作一个数组A，那么问题就转化为寻找A的<strong>和最大的非空连续子数组</strong>。这样的连续子数组为<strong>最大子数组</strong>（maximum subarray）。例如，对第一幅图中的数组，<code>A[1...16]</code> 的最大子数组为 <code>A[8...11]</code>，其和为 43。因此，可以在第 8 天开始前（第 7 天结束后）买入股票，并在第 11 天结束后卖出，获得每股收益 43。</p><p><img src="/uploads/image/introduction-to-algorithms/maximum-subarray.png" title="最大子数组"></p><p>乍一看，这种变换对问题求解并没有什么帮助。对于一段 n 天的日期，仍需要检查 <span class="math inline">\(\begin{pmatrix}n-1\\2\end{pmatrix}=\Theta(n^2)\)</span> 个子数组。计算一个子数组之和所需的时间是线性的，但当计算所有 <span class="math inline">\(\Theta(n^2)\)</span> 个子数组和时，可以重新组织计算方式，利用之前计算出的子数组和来计算当前子数组的和，使得每个子数组和的计算时间为 <span class="math inline">\(O(1)\)</span>，从而暴力求解方法所花费的时间仍为 <span class="math inline">\(\Theta(n^2)\)</span>。</p><p>接下来，寻找最大子数组问题的更高效的求解方法。在此过程中，我们通常说“一个最大子数组”而不是“最大子数组”，因为可能有多个子数组达到最大和。</p><p>只有当数组中包含负数时，最大子数组问题才有意义。如果所有数组元素都是非负的，最大子数组问题没有任何难度，因为整个数组的和肯定是最大的。</p><h1 id="使用分治策略的算法">使用分治策略的算法</h1><p>假定要寻找子数组 <code>A[low...high]</code> 的最大子数组。使用分治技术意味着要将子数组划分成两个规模尽量相等的子数组。也就是说，找到子数组的中央位置，比如 <code>mid</code>，然后考虑求解两个子数组 <code>A[low...mid]</code> 和 <code>A[mid+1...high]</code>。如下图(a)所示，<code>A[low...high]</code> 的任何连续子数组 <code>A[i...j]</code> 所处的位置必然是以下三种情况之一：</p><ul><li>完全位于子数组 <code>A[low...mid]</code> 中，因此 <span class="math inline">\(low\le{i}\le{j}\le{mid}\)</span>。</li><li>完全位于子数组 <code>A[mid+1...high]</code> 中，因此 <span class="math inline">\(mid&lt;i\le{j}\le{high}\)</span>。</li><li>跨越了中点，因此 <span class="math inline">\(low\le{i}\le{mid}&lt;j\le{high}\)</span>。</li></ul><p><img src="/uploads/image/introduction-to-algorithms/maximum-subarray-problem-possible-locations.png" title="最大子数组所处的三种位置"></p><p>我们可以递归地求解 <code>A[low...mid]</code> 和 <code>A[mid+1...high]</code> 的最大子数组，因为这两个子问题仍是最大子数组问题，只是规模更小。因此，剩下的全部工作就是寻找跨越中点的最大子数组，然后在三种情况中选取和最大者。</p><p>求出跨越中点的最大子树组并非原问题规模更小的实例，因为它加入了限制——求出的子数组必须跨越中点。如上图(b)所示，任何跨越中点的子数组都有两个子数组 <code>A[i...mid]</code> 和 <code>A[mid+1...j]</code> 组成。因此，只需找出形如 <code>A[i...mid]</code> 和 <code>A[mid+1...j]</code> 的最大子数组，然后将其合并即可。过程 <code>FIND-MAX-CROSSING-SUBARRAY</code> 接收数组A和下标 <code>low</code>、<code>mid</code> 和 <code>high</code> 为输入，返回一个下标元组划定跨越中点的最大子数组的边界，并返回最大子数组值的和。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high):  <span class="comment"># 设 high-low+1 = n</span></span><br><span class="line">    left-sum = -infinty</span><br><span class="line">    sum = <span class="number">0</span>                   <span class="comment"># 求出左半部的最大子数组</span></span><br><span class="line">    <span class="keyword">for</span> i = mid downto low:   <span class="comment"># 循环 mid-low+1 次</span></span><br><span class="line">        sum = sum + A[i]      <span class="comment"># 循环体花费常数时间</span></span><br><span class="line">        <span class="keyword">if</span> sum &gt; left-sum：</span><br><span class="line">            left-sum = sum</span><br><span class="line">            max-left = i</span><br><span class="line">    right-sum = -infinty</span><br><span class="line">    sum = <span class="number">0</span>                   <span class="comment"># 求出右半部的最大子数组</span></span><br><span class="line">    <span class="keyword">for</span> j = mid + <span class="number">1</span> to high:  <span class="comment"># 循环 high-(mid+1)+1=high-mid 次</span></span><br><span class="line">        sum = sum + A[j]      <span class="comment"># 循环体花费常数时间</span></span><br><span class="line">        <span class="keyword">if</span> sum &gt; right-sum:</span><br><span class="line">            right-sum = sum</span><br><span class="line">            max-right = j</span><br><span class="line">    <span class="keyword">return</span> (max-left, max-right, left-sum + right-sum)</span><br></pre></td></tr></table></figure><p>如果子数组 <code>A[low...high]</code> 包含 n 个元素，则两个 for 循环的总迭代次数为 n 次，每次迭代花费 <span class="math inline">\(\Theta(1)\)</span> 时间，因此调用 <code>FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)</code> 花费 <span class="math inline">\(\Theta(n)\)</span>时间。</p><p>求解最大子数组问题的分治算法的伪代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FIND-MAXIMUM-SUBARRAY(A, low, high):</span><br><span class="line">    <span class="keyword">if</span> high == low:  <span class="comment"># 只有一个元素的情况，花费常量时间</span></span><br><span class="line">        <span class="keyword">return</span> (low, high, A[low])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mid = math.floor((low+high)/<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 分解成子问题</span></span><br><span class="line">        (left-low, left-high, left-sum)    = FIND-MAXIMUM-SUBARRAY(A, low, mid)  <span class="comment"># 递归</span></span><br><span class="line">        (right-low, right-high, right-sum) = FIND-MAXIMUM-SUBARRAY(A, mid+<span class="number">1</span>, high)</span><br><span class="line">        (cross-low, cross-high, cross-sum) = FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)  <span class="comment"># 对第三种情况单独求解</span></span><br><span class="line">        <span class="comment"># 合并：三种结果中最大的子数组为原问题的解</span></span><br><span class="line">        <span class="keyword">if</span> left-sum &gt;= right-sum <span class="keyword">and</span> left-sum &gt;= cross-sum:</span><br><span class="line">            <span class="keyword">return</span> (left-low, left-high, left-sum)</span><br><span class="line">        <span class="keyword">elif</span> right-sum &gt;= left-sum <span class="keyword">and</span> right-sum &gt;= cross-sum:</span><br><span class="line">            <span class="keyword">return</span> (right-low, right-high, right-sum)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (cross-low, cross-high, cross-sum)</span><br></pre></td></tr></table></figure><p>初始调用 <code>FIND-MAXIMUM-SUBARRAY(A, 0, A.lenght-1)</code> 即可求出 <code>A[0...n-1]</code> 的最大子数组。</p><h2 id="分析">分析</h2><p>建立一个递归式来描述递归过程 <code>FIND-MAXIMUM-SUBARRAY</code> 的运行时间。对问题进行简化，假设原问题的规模为 2 的幂，这样所有子问题的规模均为整数。用 <span class="math inline">\(T(n)\)</span> 表示 <code>FIND-MAXIMUM-SUBARRAY</code> 求解 n 个元素的最大子数组的运行时间。</p><p>对于 <code>n=1</code> 的基本情况，花费常量时间，因此 <span class="math inline">\(T(1)=\Theta(1)\)</span>。</p><p>当 <code>n&gt;1</code> 时为递归情况。到达递归调用前花费 <span class="math inline">\(\Theta(1)\)</span> 时间。递归求解的子问题均为 n/2 个元素的子数组（假定原问题规模为 2 的幂，保证了 n/2 为整数），因此每个子问题求解时间为 <span class="math inline">\(T(n/2)\)</span>。调用 <code>FIND-MAX-CROSSING-SUBARRAY</code> 花费 <span class="math inline">\(\Theta(n)\)</span> 时间。合并过程花费 <span class="math inline">\(\Theta(1)\)</span> 时间。因此，对于递归情况，有 <span class="math inline">\(T(n)=\Theta(1)+2T(n/2)+\Theta(n)+\Theta(1)=2T(n/2)+\Theta(n)\)</span>。</p><p>结合两式，得到 <code>FIND-MAXIMUM-SUBARRAY</code> 运行时间 <span class="math inline">\(T(n)\)</span> 的递归式：</p><p><span class="math display">\[T(n)=\begin{cases}\Theta(1)&amp;\text{if }n=1\\2T(n/2)+Theta(n)&amp;\text{if }n&gt;1\end{cases}\]</span></p><p>此递归式与归并排序的递归式一样，其解为 <span class="math inline">\(T(n)=\Theta(n\lg{n})\)</span>。利用分治策略的求解方法渐进复杂性优于暴力求解方法。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_max_crossing_subarray</span><span class="params">(a, low, mid, high)</span>:</span></span><br><span class="line">    left_sum = right_sum = float(<span class="string">'-inf'</span>)</span><br><span class="line">    max_left = max_right = t = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(low, mid + <span class="number">1</span>)):</span><br><span class="line">        t += a[i]</span><br><span class="line">        <span class="keyword">if</span> t &gt; left_sum:</span><br><span class="line">            left_sum, max_left = t, i</span><br><span class="line">    t = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(mid + <span class="number">1</span>, high + <span class="number">1</span>):</span><br><span class="line">        t += a[i]</span><br><span class="line">        <span class="keyword">if</span> t &gt; right_sum:</span><br><span class="line">            right_sum, max_right = t, i</span><br><span class="line">    <span class="keyword">return</span> max_left, max_right, left_sum + right_sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_maximum_subarray_dac</span><span class="params">(a, low, high)</span>:</span></span><br><span class="line">    <span class="string">"""divide and conquer"""</span></span><br><span class="line">    <span class="keyword">if</span> high == low:</span><br><span class="line">        <span class="keyword">return</span> low, high, a[low]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mid = (low + high) // <span class="number">2</span></span><br><span class="line">        left_low, left_high, left_sum = find_maximum_subarray_dac(a, low, mid)</span><br><span class="line">        right_low, right_high, right_sum = find_maximum_subarray_dac(a, low + <span class="number">1</span>, high)</span><br><span class="line">        cross_low, cross_high, cross_sum = find_max_crossing_subarray(a, low, mid, high)</span><br><span class="line">        <span class="keyword">if</span> left_sum &gt;= right_sum <span class="keyword">and</span> left_sum &gt;= cross_sum:</span><br><span class="line">            <span class="keyword">return</span> left_low, left_high, left_sum</span><br><span class="line">        <span class="keyword">elif</span> right_sum &gt;= left_sum <span class="keyword">and</span> right_sum &gt;= cross_sum:</span><br><span class="line">            <span class="keyword">return</span> right_low, right_high, right_sum</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> cross_low, cross_high, cross_sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">13</span>, <span class="number">-3</span>, <span class="number">-25</span>, <span class="number">20</span>, <span class="number">-3</span>, <span class="number">-16</span>, <span class="number">-23</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">-7</span>, <span class="number">12</span>, <span class="number">-5</span>, <span class="number">-22</span>, <span class="number">15</span>, <span class="number">-4</span>, <span class="number">7</span>]</span><br><span class="line">    print(find_maximum_subarray_dac(arr, <span class="number">0</span>, len(arr) - <span class="number">1</span>))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(7, 10, 43)</span><br></pre></td></tr></table></figure><h1 id="使用动态规划的算法">使用动态规划的算法</h1><p>从数组的左边界开始，从左至右处理，记录到目前为止已经处理过的最大子数组。定义数组 <code>dp</code>，其中 <code>dp[j]</code> 代表数组<code>A[0...j]</code>中以 <code>A[j]</code> 结尾的最大子数组，则</p><ul><li><code>j = 0</code> 时，以 <code>A[j]</code> 结尾的最大子数组就是其本身。</li><li><code>j &gt; 0</code> 时，以 <code>A[j]</code> 结尾的最大子数组可能有两种情况：<ul><li>最大子数组是 <code>A[i..j]</code>，此时 <code>dp[j] = dp[j - 1] + A[j]</code></li><li>最大子数组是 <code>A[j]</code>，此时 <code>dp[j] = A[j]</code>。</li></ul></li></ul><p>即</p><p><span class="math display">\[dp[j]=\begin{cases}A[j]&amp;j=0\\max(dp[j-1],0)+A[j]&amp;j=1\dots{n-1}\end{cases}\]</span></p><h2 id="代码-1">代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kadanes</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> a:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    dp = [<span class="number">0</span>] * len(a)</span><br><span class="line">    dp[<span class="number">0</span>] = a[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(a)):</span><br><span class="line">        dp[i] = max(dp[i - <span class="number">1</span>], <span class="number">0</span>) + a[i]</span><br><span class="line">    <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: a = [13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7]</span><br><span class="line">Output: 43</span><br></pre></td></tr></table></figure><h2 id="分析-1">分析</h2><p>对一个输入规模为 <span class="math inline">\(n\)</span> 的数组，迭代次数为 <span class="math inline">\(n\)</span>，每次迭代花费 <span class="math inline">\(\Theta(1)\)</span> 时间。因此，算法的总代价为 <span class="math inline">\(n*\Theta(1)=\Theta(n)\)</span>。</p><p>算法使用了一个长度为 <span class="math inline">\(n\)</span> 的辅助数组，因此空间复杂度为 <span class="math inline">\(\Theta(n)\)</span>。</p><h2 id="降低空间复杂度">降低空间复杂度</h2><p>若只需要整个数组的最大子数组，那么可以用一个变量代替 <code>dp</code> 数组，从而降低动态规划算法的空间复杂度。该变量记录到目前为止已处理过的最大子数组中最大的值。修改后的算法代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kadanes_r1</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> a:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    curr = res = a[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(a)):</span><br><span class="line">        curr = max(curr, <span class="number">0</span>) + a[i]</span><br><span class="line">        res = max(res, curr)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>修改后的算法时间复杂度还是 <span class="math inline">\(\Theta(n)\)</span>，空间复杂度降低为 <span class="math inline">\(O(1)\)</span>。</p><h2 id="记录子数组位置">记录子数组位置</h2><p>展开 <code>max</code>，在 <code>curr</code> 和 <code>res</code> 的值发生改变的同时，更新起始或终止位置。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kadanes_r2</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> a:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    curr = res = a[<span class="number">0</span>]</span><br><span class="line">    start = end = <span class="number">0</span></span><br><span class="line">    temp = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(a)):</span><br><span class="line">        <span class="keyword">if</span> curr &lt; <span class="number">0</span>:</span><br><span class="line">            curr, temp = <span class="number">0</span>, i</span><br><span class="line">        curr += a[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> res &lt; curr:</span><br><span class="line">            res = curr             <span class="comment"># 更新最优解</span></span><br><span class="line">            start, end = temp, i   <span class="comment"># 记录起始下标</span></span><br><span class="line">    <span class="keyword">return</span> start, end, res</span><br></pre></td></tr></table></figure><p>时间复杂度为 <span class="math inline">\(\Theta(n)\)</span>，空间复杂度为 <span class="math inline">\(O(1)\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> Introduction to Algorithms </tag>
            
            <tag> algorithms </tag>
            
            <tag> divide and conquer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序统计量</title>
      <link href="/notes/introduction-to-algorithms/order-statistics/"/>
      <url>/notes/introduction-to-algorithms/order-statistics/</url>
      
        <content type="html"><![CDATA[<h1 id="顺序统计量">顺序统计量</h1><p>在一个由n个元素组成的集合中，第i个顺序统计量（order statistic）是该集合中第i小的元素。</p><p>例如，在一个元素集合中，最小值是第1个顺序统计量（i=1），最大值是第n个顺序统计量（i=n）。</p><p>将从一个由n个互异的元素构成的集合中选择第i个顺序统计量的问题形式化定义为如下的<strong>选择问题</strong>：</p><p><strong>输入</strong>： 一个包含n个（互异的）数的集合A和一个整数<span class="math inline">\(i，1\le{i}\le{n}\)</span>。</p><p><strong>输出</strong>： 元素<span class="math inline">\(x\in{A}\)</span>，且A中恰好有i-1个其他元素小于它。</p><a id="more"></a><h1 id="最大值和最小值">最大值和最小值</h1><h2 id="找到最小值或最大值">找到最小值或最大值</h2><p>在一个有n个元素的集合中，找出其最小值：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minimum</span><span class="params">(a)</span>:</span>  <span class="comment"># 与min()作用相同</span></span><br><span class="line">    <span class="keyword">if</span> len(a) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'minimum() arg is an empty sequence'</span>)</span><br><span class="line">    m = a[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(a)):  <span class="comment"># 循环n-1次，n位数组长度</span></span><br><span class="line">        m = min(m, a[i])  <span class="comment"># 元素之间比较n-1次</span></span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">18</span>, <span class="number">24</span>, <span class="number">17</span>, <span class="number">3</span>, <span class="number">21</span>, <span class="number">7</span>, <span class="number">23</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">39</span>, <span class="number">46</span>, <span class="number">26</span>, <span class="number">30</span>, <span class="number">38</span>, <span class="number">52</span>]</span><br><span class="line">    print(<span class="string">'min ='</span>, minimum(arr))</span><br></pre></td></tr></table></figure><p>需要做n-1次比较，n-1次既是其比较次数上界亦是其下界。找出最大值的方法类似。</p><p>在一个包含n个元素的集合中找出最小值（最大值）的时间是<span class="math inline">\(\Theta(n)\)</span>。</p><p>输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">min = 3</span><br></pre></td></tr></table></figure><h2 id="同时找到最小值和最大值">同时找到最小值和最大值</h2><p>可以分别独立地找出最小值和最大值，这各需要n-1次比较，共需2n-2次比较。即将每个元素与当前最小值比较一次，再与最大元素比较一次。代价是每个元素都需要2次比较。</p><p>事实上，只需要最多<span class="math inline">\(3\lfloor{n/2}\rfloor\)</span>次比较就可以同时找到最小值和最大值。</p><p>记录已知的最大值和最小值，对输入元素成对地进行处理。首先，将一对输入元素相互进行比较，然后把较小的与当前最小值比较，把较大的与当前最大值进行比较。这样，对每连个元素共需3次比较。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min_max</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(a) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'min_max() arg is an empty sequence'</span>)</span><br><span class="line">    mini = maxi = a[<span class="number">0</span>]  <span class="comment"># n为奇数时，临时变量同时指向第一个元素</span></span><br><span class="line">    i = <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> len(a) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        mini, maxi = a[<span class="number">0</span>], a[<span class="number">1</span>]  <span class="comment"># n为偶数时，先比较前两个元素确定当前最小值和最大值</span></span><br><span class="line">        <span class="keyword">if</span> mini &lt; maxi:</span><br><span class="line">            mini, maxi = maxi, mini</span><br><span class="line">        i = <span class="number">3</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(a):</span><br><span class="line">        x, y = a[i - <span class="number">1</span>], a[i]</span><br><span class="line">        <span class="keyword">if</span> a[i - <span class="number">1</span>] &gt; a[i]:</span><br><span class="line">            x, y = y, x  <span class="comment"># 先比较数组中两个元素</span></span><br><span class="line">        mini = min(mini, x)  <span class="comment"># 小的元素与当前最小值比较</span></span><br><span class="line">        maxi = max(maxi, y)  <span class="comment"># 大的元素与当前最大值比较</span></span><br><span class="line">        i += <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> mini, maxi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">18</span>, <span class="number">24</span>, <span class="number">17</span>, <span class="number">3</span>, <span class="number">21</span>, <span class="number">7</span>, <span class="number">23</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">39</span>, <span class="number">46</span>, <span class="number">26</span>, <span class="number">30</span>, <span class="number">38</span>, <span class="number">52</span>]</span><br><span class="line">    print(<span class="string">'(min, max) ='</span>, min_max(arr))</span><br></pre></td></tr></table></figure><p>分析以下总的比较次数：</p><ul><li>如果n是奇数，那么第一个元素不用比较，后n-1个元素每两个进行3次比较，总共进行<span class="math inline">\(3(n-1)/2=3\lfloor{n/2}\rfloor\)</span>次比较。</li><li>如果n是偶数，那么前两个元素比较1次，后n-2个元素每两个进行3次比较，总共进行<span class="math inline">\(1+3(n-2)/2=3n/2-2&lt;3\lfloor{n/2}\rfloor\)</span>。</li></ul><p>因此，不管是哪一种情况，总的比较次数至多是<span class="math inline">\(3\lfloor{n/2}\rfloor\)</span>。</p><p>输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(min, max) = (3, 52)</span><br></pre></td></tr></table></figure><h1 id="期望为线性时间的选择算法">期望为线性时间的选择算法</h1><p>一般选择问题看起来要比找最小值这样的简单问题更难。但令人惊奇的是，这两个问题的渐进运行时间确实相同的：<span class="math inline">\(\Theta(n)\)</span>。下面介绍一种解决选择问题的分治算法。RANDOMIZED-SELECT算法是以快速排序算法为模型的。</p><ul><li><p>与快速排序一样，将输入数组进行递归划分。</p></li><li><p>与快速排序不同的是，快速排序会递归处理划分的两边，而RANDOMIZED-SELECT只处理划分的一边。快速排序的期望运行时间是<span class="math inline">\(n\lg(n)\)</span>，而RANDOMIZED-SELECT的期望运行时间为O(n)。</p></li></ul><p>RANDOMIZED-SELECT返回数组<code>A[p...r]</code>中第i小的元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">RANDOMIZED-SELECT(A, p, r, i):</span><br><span class="line">    <span class="keyword">if</span> p == r:          <span class="comment"># 如果数组中只包括一个元素，那么此时i必然等于1</span></span><br><span class="line">        <span class="keyword">return</span> A[p]    <span class="comment"># 此时只需返回这唯一的一个元素</span></span><br><span class="line">    q = RANDOMIZED-PARTITION(A, p, r)  <span class="comment"># 随机选择主元并划分，返回主元位置。因为主元与其他元素</span></span><br><span class="line">    k = q-p+<span class="number">1</span>  <span class="comment"># 主元是第k小             # 都比较过，所以主元所在位置就是最终在已排序数组中的位置</span></span><br><span class="line">    <span class="keyword">if</span> i == k:          <span class="comment"># 检测A[q]是否是第i小元素</span></span><br><span class="line">        <span class="keyword">return</span> A[q]</span><br><span class="line">    <span class="keyword">elif</span> i &lt; k:         <span class="comment"># i&lt;k说明A[q]过大，要找的元素落在左边</span></span><br><span class="line">        <span class="keyword">return</span> RANDOMIZED-SELECT(A, p, q<span class="number">-1</span>, i)</span><br><span class="line">    <span class="keyword">else</span>:               <span class="comment"># 否则落在右边</span></span><br><span class="line">        <span class="keyword">return</span> RANDOMIZED-SELECT(A, q+<span class="number">1</span>, r, i-k)  <span class="comment"># 左边+主元一共k个元素，在右边要找第i-k小元素</span></span><br></pre></td></tr></table></figure><p>程序判断了p==r即子数组只含有1个元素的情况，那么含有0个元素的情况呢？划分操作有可能产生长度为0的子数组，那么上述递归操作会调用含有0个元素的子数组吗？答案是这种情况不会发生。考虑主元位于边界的情况：</p><ul><li>p=q：左边子数组长度为0，右边不为0。主元是第1小元素，由于i不可能小于1，若所寻目标i=1，程序结束并返回；若i&gt;1，程序将在右边的子数组中递归寻找。</li><li>p=r：与p=q是对称的。i不可能大于n（数组中元素总个数）。此时主元是第n小，若i=n，程序结束并返回；若i&lt;n，则在左边的子数组中递归寻找。</li></ul><p>因此，程序会不递归调用含有0个元素的数组。</p><h2 id="分析">分析</h2><p>RANDOMIZED-SELECT的最坏情况运行时间为<span class="math inline">\(\Theta(n^2)\)</span>，即使是找最小元素也是如此，因为在每次划分时可能极不走运地总是按余下的元素中最大的来进行划分，而划分操作需要<span class="math inline">\(\Theta(n)\)</span>时间。但因为算法是随机化的，所以不存在一个特定的会导致其最坏情况发生的输入数据。下面分析算法的期望运行时间。</p><p>设该算法在一个含有n个元素的输入数组<code>A[p...r]</code>上的运行时间是一个随机变量，记为T(n)。对每一个<span class="math inline">\(k(1\le{k}\le{n})\)</span>，子数组<code>A[p...q]</code>（全部小于或等于主元）有k个元素的概率是1/n。对所有的<code>k=1,2,...,n</code>，定义指示器变量<span class="math inline">\(X_k\)</span>为：<span class="math inline">\(X_k=I\lbrace子数组A[p...q]正好包含k个元素\rbrace\)</span>。假设元素是互异的，有<span class="math inline">\(E[X_k]=1/n\)</span>。</p><p>为了得到所需时间的上界，假定查找的第i个元素总是在划分中包含较大元素的一边。指示器随机变量<span class="math inline">\(X_k\)</span>恰好在给定的k值上取值1，对其他值都为0。当<span class="math inline">\(X_k=1\)</span>时，可能要递归处理的两个子数组大小分别为k-1和n-k。因此可以得到递归式： <span class="math display">\[\begin{aligned}T(n)&amp;\le\sum_{k=1}^nX_k\cdot\Bigl(T\bigl(max(k-1,n-k)\bigr)+O(n)\Bigr)\\&amp;=\sum_{k=1}^nX_k\cdot{T(max(k-1,n-k))}+O(n)\end{aligned}\]</span> 两边取期望值，得到 <span class="math display">\[\begin{aligned}E[T(n)]&amp;\le{E\Big[\sum_{k=1}^nX_k\cdot{T(max(k-1,n-k))}+O(n)\Bigr]}\\&amp;=\sum_{k=1}^nE\Big[X_k\cdot{T(max(k-1,n-k))}\Big]+O(n)\quad\text{(期望的线性性质)}\\&amp;=\sum_{k=1}^nE[X_k]\cdot{E[T(max(k-1,n-k))]}+O(n)\quad\text{(}X_k\text{和}T(max(k-1,n-k))\text{相互独立)}\\&amp;=\sum_{k=1}^n\frac{1}{n}\cdot{E[T(max(k-1,n-k))]}+O(n)\end{aligned}\]</span> 考虑表达式max(k-1,n-k)，有 <span class="math display">\[max(k-1,n-k)=\begin{cases}k-1\quad\text{若}k&gt;\lceil{n/2}\rceil\\n-k\quad\text{若}k\le\lceil{n/2}\rceil\end{cases}\]</span> 观察到表达式max(k-1,n-k)的取值是成对出现的：</p><ul><li>如果n是偶数，则<span class="math inline">\(k=1,2,\dots,n/2\)</span>与<span class="math inline">\(k=n,n-1,\dots,n/2+1\)</span>时的取值相等，取值分别是<span class="math inline">\(n-1,n-2,\dots,n/2\)</span>。</li><li>如果n是奇数，则<span class="math inline">\(k=1,2,\dots,\lfloor{n/2}\rfloor\)</span>与<span class="math inline">\(k=n,n-1,\dots,\lceil{n/2}\rceil+1\)</span>时的取值相等，分别是<span class="math inline">\(n-1,n-2,\dots,\lceil{n/2}\rceil\)</span>。此外<span class="math inline">\(k=\lceil{n/2}\rceil\)</span>时的取值单独出现，值是<span class="math inline">\(\lfloor{2/n}\rfloor\)</span>。</li></ul><p>因此，有 <span class="math display">\[E[T(n)]\le\frac{2}{n}\sum_{k=\lfloor{n/2}\rfloor}^{n-1}E[T(k)]+O(n)\]</span> 下面用替代法来得到E[T(n)]=O(n)。</p><p>假设对某个常数c，有<span class="math inline">\(E[T(n)]\le{cn}\)</span>。假设对小于某个常数的n，有T(n)=O(1)。同时，选择一个常数a，使得对所有n&gt;0，上式中O(n)项所描述的函数有上界an。利用这个归纳假设，可以得到： <span class="math display">\[\begin{aligned}E[T(n)]&amp;\le\frac{2}{n}\sum_{k=\lfloor{n/2}\rfloor}^{n-1}ck+an\\&amp;=\frac{2c}{n}\Big(\sum_{k=1}^{n-1}k-\sum_{k=1}^{\lfloor{n/2}\rfloor-1}k\Big)+an\\&amp;=\frac{2c}{n}\Big(\frac{(n-1)n}{2}-\frac{(\lfloor{n/2}\rfloor-1)\lfloor{n/2}\rfloor}{2}\Big)+an\\&amp;\le\frac{2c}{n}\Big(\frac{(n-1)n}{2}-\frac{(n/2-2)(n/2-1)}{2}\Big)+an\\&amp;=\frac{2c}{n}\Big(\frac{n^2-n}{2}-\frac{n^2-3n/2+2}{2}\Big)+an\\&amp;=\frac{c}{n}(\frac{3n}{4}+\frac{1}{2}-\frac{2}{n})+an\\&amp;\le\frac{3cn}{4}+\frac{c}{2}+an\\&amp;=cn-\color{red}{(\frac{cn}{4}-\frac{c}{2}-an)}\end{aligned}\]</span> 为了完成证明，还需要证明：对足够大的n，最后一个表达式至多是cn。 <span class="math display">\[\begin{aligned}\frac{cn}{4}-\frac{c}{2}-an&amp;\ge0\\n(\frac{c}{4}-a)&amp;\ge\frac{c}{2}\end{aligned}\]</span> 只要选择的常数c能够满足c/4-a&gt;0，就可以将两边同时除以c/4-a，得到 <span class="math display">\[n\ge\frac{c/2}{c/4-a}=\frac{2c}{c-4a}\]</span> 因此，如果假设对所有n&lt;2c/(c-4a)，都有T(n)=O(1)，那么就有E[T(n)]=O(n)。</p><p>结果：假设所有元素是互异的，在期望线性时间内，可以找到任一顺序统计量，特别是中位数（？）。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sort.quick_sort <span class="keyword">import</span> partition</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randomized_select</span><span class="params">(a, p, r, i)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> p == r:  <span class="comment"># 只有一个元素时，i一定等于1，i代表的是在a[p..r]中第i小</span></span><br><span class="line">        <span class="keyword">return</span> a[p]</span><br><span class="line">    q = partition(a, p, r, randint(p, r))  <span class="comment"># 随机选择主元并划分</span></span><br><span class="line">    k = q - p + <span class="number">1</span>  <span class="comment"># 主元是第k小元素</span></span><br><span class="line">    <span class="keyword">if</span> i == k:</span><br><span class="line">        <span class="keyword">return</span> a[q]</span><br><span class="line">    <span class="keyword">elif</span> i &lt; k:  <span class="comment"># 在左边继续寻找</span></span><br><span class="line">        <span class="keyword">return</span> randomized_select(a, p, q - <span class="number">1</span>, i)</span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 在右边继续寻找，注意要寻找的序号要变化</span></span><br><span class="line">        <span class="keyword">return</span> randomized_select(a, q + <span class="number">1</span>, r, i - k)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">18</span>, <span class="number">24</span>, <span class="number">17</span>, <span class="number">3</span>, <span class="number">21</span>, <span class="number">7</span>, <span class="number">23</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">39</span>, <span class="number">46</span>, <span class="number">26</span>, <span class="number">30</span>, <span class="number">38</span>, <span class="number">52</span>]</span><br><span class="line">    print([randomized_select(arr, <span class="number">0</span>, len(arr) - <span class="number">1</span>, i + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr))])</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[3, 7, 17, 18, 21, 23, 24, 26, 30, 35, 38, 39, 41, 46, 52]</span><br></pre></td></tr></table></figure><h1 id="最坏情况为线性时间的选择算法">最坏情况为线性时间的选择算法</h1><p>本节介绍一个最坏情况运行时间为<span class="math inline">\(\Theta(n)\)</span>的选择算法：SELECT算法。像RANDOMIZED-SELECT一样，SELECT算法通过对输入数组的递归划分来找出所需元素，但是，在该算法中<strong>能够保证得到对数组的一个好的划分</strong>。</p><p>SELECT算法的执行步骤如下：</p><ol type="1"><li>如果n=1，则返回唯一元素作为第i小的元素。否则将输入数组的n个元素划分为<span class="math inline">\(\lfloor{n/5}\rfloor\)</span>组，每组5个元素，剩下的一组至多由n%5个元素组成。</li><li>寻找这<span class="math inline">\(\lceil{n/5}\rceil\)</span>组中每一组的中位数：首先对每组元素进行插入排序，然后确定每组有序元素的中位数。</li><li>对第2步中找出的<span class="math inline">\(\lceil{n/5}\rceil\)</span>个中位数，递归调用SELECT以找出其中的中位数x（如果由偶数个中位数，为了方便，约定x是较小的中位数）。</li><li>按中位数的中位数x对输入数组进行划分。让k比划分的低区中的元素数目多1，因此x是第k小的元素，并且有n-k个元素在划分的高区。</li><li>如果i=k，则返回x。如果i&lt;k，则在地区递归调用SELECT来找出第i小的元素。如果i&gt;k，则在高区递归查找第i-k小的元素。</li></ol><h2 id="分析-1">分析</h2><p>首先确定大于划分主元x的元素个数的下界。下图给出了一些形象的说明。在第2步找出的中位数中，至少有一半大于或等于中位数的中位数x。因此，在这<span class="math inline">\(\lceil{n/5}\rceil\)</span>个组中， 除了当n不能被5整除时产生的所含元素少于5的那个组，和包含x的那个组之外，至少有一半的组中有3个元素大于x。不算这两个组，大于x的元素个数至少为 <span class="math display">\[3\Bigl(\big\lceil\frac{1}{2}\lceil\frac{n}{5}\rceil\big\rceil-2\Bigr)\ge\frac{3n}{10}-6\]</span> 类似地，至少有3n/10-6个元素小于x。因此，在最坏情况下，在第5步中，SELECT的递归调用最多作用于7n/10+6个元素。</p><p><img src="/uploads/image/introduction-to-algorithms/select-analysis.png" title="灰色阴影覆盖的元素全都大于x"></p><p>现在，设计一个递归式来推到SELECT算法的最坏情况运行时间T(n)。</p><p>步骤1：分组需要O(n)时间。</p><p>步骤2：对大小为O(1)（大小为5）的集合调用O(n)（<span class="math inline">\(\lceil{n/5}\rceil\)</span>次）插入排序，总时间也为O(n)。</p><p>步骤3：递归所需时间为<span class="math inline">\(T(\lceil{n/5}\rceil)\)</span>。</p><p>步骤4：partition所需时间为O(n)。</p><p>步骤5：递归所需时间至多为T(7n/10+6)。</p><p>将上述时间累加，可得到 <span class="math display">\[T(n)\le{T(\lceil{n/5}\rceil)+T(7n/10+6)+O(n)}\]</span> 下面用替换法证明这个运行时间是线性的。更明确地说，证明对某个适当大的常数c和所有的n&gt;0，有<span class="math inline">\(T(n)\le{cn}\)</span>。挑选一个常数a，使得对所有的n&gt;0，公式中的O(n)项所对应的函数有上界an。假设<span class="math inline">\(T(n)\le{cn}\)</span>成立。将假设带入上述递归式的右边，得到 <span class="math display">\[\begin{aligned}T(n)&amp;\le{c\lceil{n/5}\rceil}+c(7n/10+6)+an\\&amp;\le{cn/5+c}+7cn/10+6c+an\\&amp;=9cn/10+7c+an\\&amp;=cn+\color{red}{(-cn/10+7c+an)}\end{aligned}\]</span> 若<span class="math inline">\(-cn/10+7c+an\le0\)</span>时，则<span class="math inline">\(T(n)\le{cn}\)</span>成立。 <span class="math display">\[\begin{aligned}-cn/10+7c+an&amp;\le0\\cn/10-7c&amp;\ge{an}\\c\frac{n-70}{10}&amp;\ge{an}\end{aligned}\]</span> 观察上式可知，当n&gt;70时，<span class="math inline">\(-cn/10+7c+an\le0\)</span>，此时<span class="math inline">\(c\ge10a\color{red}{(n/(n-70))}\)</span>。 <span class="math display">\[\frac{n}{n-70}=\frac{1}{1-\frac{70}{n}}\]</span> 当n增大时，n/(n-70)减小，因此只要适当地选择c的值，使不等式<span class="math inline">\(-cn/10+7c+an\le0\)</span>成立，就能证明<span class="math inline">\(T(n)\le{cn}\)</span>。例如，n&gt;70时，<span class="math inline">\(n/(n-70)\le71\)</span>，选择常数<span class="math inline">\(c\ge710a\)</span>即可满足<span class="math inline">\(T(n)\le{cn}\)</span>。又例如，当<span class="math inline">\(n\ge140\)</span>时，<span class="math inline">\(n/(n-70)\le2\)</span>，选择常数<span class="math inline">\(c\ge20a\)</span>即可。无论如何选择n的边界x，在n&lt;x时，<span class="math inline">\(T(n)\le{cn}\)</span>成立（只需选择足够大的c即可）。因此，最坏情况下SELECT的运行时间是线性的。</p><h2 id="代码-1">代码</h2><p>不同的是：将选择中位数的中位数过程（步骤1~3）从选择算法中独立出来。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sort.quick_sort <span class="keyword">import</span> partition</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> ceil</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(a, i, j)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> i != j:</span><br><span class="line">        a[i], a[j] = a[j], a[i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span><span class="params">(a, p, r)</span>:</span>  <span class="comment"># 修改过的插入排序，对a[p..r]进行排序</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(p + <span class="number">1</span>, r + <span class="number">1</span>):</span><br><span class="line">        key = a[j]</span><br><span class="line">        i = j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= p <span class="keyword">and</span> a[i] &gt; key:</span><br><span class="line">            a[i + <span class="number">1</span>] = a[i]</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        a[i + <span class="number">1</span>] = key</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">median_of_median</span><span class="params">(a, p, r)</span>:</span></span><br><span class="line">    <span class="string">"""将数组分成每5个元素一组，找其中位数，若有多个，递归中位数组成的数组，继续寻找"""</span></span><br><span class="line">    <span class="keyword">if</span> p == r:</span><br><span class="line">        <span class="keyword">return</span> a[p]</span><br><span class="line">    <span class="comment"># 对每5个元素调用插入排序</span></span><br><span class="line">    left = p</span><br><span class="line">    <span class="keyword">while</span> left &lt;= r:</span><br><span class="line">        right = min(left + <span class="number">4</span>, r)</span><br><span class="line">        insertion_sort(a, left, right)  <span class="comment"># 对每5个数排序，剩下的一组若不足5个，有几个算几个</span></span><br><span class="line">        <span class="comment"># 交换中位数到数组前面，方便递归调用</span></span><br><span class="line">        exchange(a, p + (right - p) // <span class="number">5</span>, (right + left) // <span class="number">2</span>)</span><br><span class="line">        left += <span class="number">5</span></span><br><span class="line">    n = ceil((r - p + <span class="number">1</span>) / <span class="number">5</span>)  <span class="comment"># 所有分组的中位数的个数</span></span><br><span class="line">    <span class="keyword">return</span> median_of_median(a, p, p + n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select</span><span class="params">(a, p, r, i)</span>:</span></span><br><span class="line">    median_of_median(a, p, r)  <span class="comment"># 找出中位数的中位数，过程结束时找到的中位数位置为p</span></span><br><span class="line">    q = partition(a, p, r, p)  <span class="comment"># 以找到的中位数为pivot，划分数组</span></span><br><span class="line">    k = q - p + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i == k:</span><br><span class="line">        <span class="keyword">return</span> a[q]</span><br><span class="line">    <span class="keyword">elif</span> i &lt; k:</span><br><span class="line">        <span class="keyword">return</span> select(a, p, q - <span class="number">1</span>, i)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> select(a, q + <span class="number">1</span>, r, i - k)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">18</span>, <span class="number">24</span>, <span class="number">17</span>, <span class="number">3</span>, <span class="number">21</span>, <span class="number">7</span>, <span class="number">23</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">39</span>, <span class="number">46</span>, <span class="number">26</span>, <span class="number">30</span>, <span class="number">38</span>, <span class="number">52</span>]</span><br><span class="line">    print([select(arr, <span class="number">0</span>, len(arr) - <span class="number">1</span>, i + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr))])</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[3, 7, 17, 18, 21, 23, 24, 26, 30, 35, 38, 39, 41, 46, 52]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Algorithms </tag>
            
            <tag> algorithms </tag>
            
            <tag> divide and conquer </tag>
            
            <tag> quicksort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大流</title>
      <link href="/notes/introduction-to-algorithms/maximum-flow/"/>
      <url>/notes/introduction-to-algorithms/maximum-flow/</url>
      
        <content type="html"><![CDATA[<h1 id="流网络和流">流网络和流</h1><p><strong>流网络</strong>G=(V,E)是一个有向图，图中每条边<span class="math inline">\((u,v)\in{E}\)</span>有一个非负的<strong>容量值</strong><span class="math inline">\(c(u,v)\ge0\)</span>。而且，如果边集合E包含一条边(u,v)，则图中不存在反向边(v,u)。如果<span class="math inline">\((u,v)\notin{E}\)</span>，为方便起见，定义c(u,v)=0，并且在图中不允许自循环。</p><p>在流网络的所有结点中，特别分辨出两个特殊结点：<strong>源结点</strong>s和<strong>汇点</strong>t。为方便起点，假定每个结点都在从源结点到汇点的某条路径上。因此，流网络图是连通的，并且由于除源结点外的每个结点都至少有一条进入的边，有<span class="math inline">\(|E|\ge|V|-1\)</span>。下图描述的是一个流网络的例子。</p><p><img src="/uploads/image/introduction-to-algorithms/flow-network.png" title="一个流网络"></p><a id="more"></a><p>下面给出流的形式化定义。设G=(V,E)为一个流网络，其容量函数为c。设s为网络的源结点，t为汇点。G中的<strong>流</strong>是一个实值函数<span class="math inline">\(f:V\times{V}\rightarrow\mathbb{R}\)</span>，满足下面的两条性质：</p><ul><li>容量限制：对于所有的结点<span class="math inline">\(u,v\in{V}\)</span>，要求<span class="math inline">\(0\le{f(u,v)}\le{c(u,v)}\)</span>。</li><li>流量守恒：对于所有的结点<span class="math inline">\(u\in{V-\lbrace{s,t}\rbrace}\)</span>，要求</li></ul><p><span class="math display">\[\sum_{v\in{V}}f(v,u)=\sum_{v\in{V}}f(u，v)\]</span></p><p>当<span class="math inline">\((u,v)\notin{E}\)</span>时，从结点u到结点v之间没有流，因此f(u,v)=0。</p><p>容量限制性质说明，从一个结点到另一个结点之间的流必须为非负值且不能超过给定的容量限制。</p><p>流量守恒性质说明，流入一个结点（源结点和汇点除外）的总流量必须等于流出该节点的总流量，“流入等于流出”。</p><p>一个流f的<strong>值</strong>|f|（这里，符号| |表示流的值）定义如下： <span class="math display">\[|f|=\sum_{v\in{V}}f(s,v)-\sum_{v\in{V}}f(v,s)\tag{26.1}\]</span> 也就是说，流f的值是从源结点流出的总流量减去流入源结点的总流量。在<strong>最大流问题</strong>中，给定一个流网络G、一个源结点s、一个汇点t，希望找到值最大的一个流。</p><h1 id="反平行边多源点汇点">反平行边、多源点汇点</h1><p>上述流网络假设：如果边<span class="math inline">\((u,v)\in{E}\)</span>，则<span class="math inline">\((v,u)\notin{E}\)</span>。称(u,v)和边(v,u)为<strong>反平行</strong>（antiparallel）。如果一个流问题中包含反平行边，必须将这种网络转换为一个等价的但不包含反平行边的网络。下图描述的就是这样一个等价网络。选择两条反平行边中的一条，在这个例子中是边<span class="math inline">\((v_1,v_2)\)</span>，通过加入一个新结点<span class="math inline">\(v^\prime\)</span>来将其分且为两段，并以边<span class="math inline">\((v_1,v^\prime)\)</span>和<span class="math inline">\((v^\prime,v_2)\)</span>来替换边<span class="math inline">\((v_1,v_2)\)</span>。同时将两条新设立的边的容量设置为与原来的边的容量相同。</p><p><img src="/uploads/image/introduction-to-algorithms/flow-network-with-antiparallel-edges.png" title="带有反平行边的流网络"></p><p>一个最大流问题可能有几个源结点和几个汇点。在具有多个源结点和汇点的网络中，确定最大流的问题可以规约为一个普通的最大流问题。下图(b描述的是如何将(a)所示的网络转换为只有一个源结点和一个汇点的普通流网络。转换方法是加入一个<strong>超级源结点</strong>s，并加入有向边<span class="math inline">\((s,s_i),i=1,2,\dots,m\)</span>，其容量<span class="math inline">\(c(s,s_i)=\infty\)</span>。同时创建一个新的<strong>超级汇点</strong>t，并加入有向边<span class="math inline">\((t_i,t),i=1,2,\dots,n\)</span>，其容量<span class="math inline">\(c(t_i,t)=\infty\)</span>。</p><p><img src="/uploads/image/introduction-to-algorithms/flow-network-with-multiple-source-multiple-sink.png" title="含有多个源结点和汇点的流网络"></p><h1 id="ford-fulkerson方法">Ford-Fulkerson方法</h1><p>Ford-Fulkerson方法是解决最大流问题的一种方法。之所以称其为“方法”而不是“算法”，是因为它包含了几种运行时间各不相同的具体实现。Ford-Fulkerson方法依赖于三种重要思想，它们与许多的流算法和问题有关：残存网络、增广路径和切割。这些思想是最大流最小切割定理的精髓。</p><p>Ford-Fulkerson方法循环增加流的值。</p><ul><li>在开始的时候，对于所有的结点<span class="math inline">\(u,v\in{V}\)</span>，f(u,v)=0，给出的初始流值为0。</li><li>在每一次迭代中，将图G的流值进行增加，方法是在一个关联的“残存网络”<span class="math inline">\(G_f\)</span>中寻找一条“增广路径”。增加的是整个网络中的流量，对于图中特定的一条边来说，其流量在迭代过程中可能增加，也可能减少。对某些边的流进行缩减可能是必要的，以便让算法可以将更多的流从源结点发送到汇点。</li><li>重复对流进行上述迭代过程，直到残存网络中不再存在增广路径未知。最大流最小切割定理将说明在算法终止时，将获得一个最大流。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FORD-FULKERSON-METHOD(G, s, t):</span><br><span class="line">    initialize flow f to <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> there exists an augmenting path p <span class="keyword">in</span> the residual network:</span><br><span class="line">        augment flow f along p</span><br><span class="line">    <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure><p>为了实现和分析Ford-Fulkerson方法，需要引入几个新的概念。</p><h2 id="残存网络">残存网络</h2><p>从直观上看，给定流网络G和流量f，残存网络<span class="math inline">\(G_f\)</span>由那些仍有空间对流量进行调整的边构成。</p><ul><li>流网络的一条边可以允许的额外流量等于该边的容量减去该边上的流量。如果该差值为正，则将该条边置于图<span class="math inline">\(G_f\)</span>中，并将其残存容量设置为<span class="math inline">\(c_f(u,v)=c(u,v)-f(u,v)\)</span>。如果边(u,v)的流量等于其容量，则其<span class="math inline">\(c_f(u,v)=0\)</span>，该条边将不属于<span class="math inline">\(G_f\)</span>。</li><li>残存网络<span class="math inline">\(G_f\)</span>还可能包含图G中不存在的边。算法对流量进行操作的目标是增加总流量，为此，算法可能对某些特定边上的流量进行缩减。为了表示对一个正流量f(u,v)的缩减，将边(v,u)加入到图<span class="math inline">\(G_f\)</span>中，并将其残存容量设置为<span class="math inline">\(c_f(v,u)=f(u,v)\)</span>。也就是说，一条边所能允许的反向流量最多将其正向流量抵消。</li></ul><p>残存网络中的这些反向边允许算法将已经发送出来的流量发送回去。而将流量从同一条边发送回去等同于缩减该条边的流量，这种操作在许多算法中都是必要的。</p><p>更形式化地，假定由一个流网络G=(V,E)，其源结点为s，汇点为t。设f为图G中的一个流，考虑结点对<span class="math inline">\(u,v\in{V}\)</span>，定义残存容量<span class="math inline">\(c_f(u,v)\)</span>如下： <span class="math display">\[c_f(u,v)=\begin{cases}c(u,v)-f(u,v)&amp;\text{if }(u,v)\in{E}\\f(v,u)&amp;\text{if }(v,u)\in{E}\\0&amp;otherwise\end{cases}\tag{26.2}\]</span> 因为假定边<span class="math inline">\((u,v)\in{E}\)</span>意味着<span class="math inline">\((v,u)\notin{E}\)</span>（对流网络的假设），对于每一对边来说，上述公式中只有一种情况成立。下图中，(a)所示的流网络中流f所对应的残存网络如(b)所示。</p><p>给定一个流网络G=(V,E)和一个流f，则由f所诱导的图G的残存网络为<span class="math inline">\(G_f=(V,E_f)\)</span>，其中 <span class="math display">\[E_f=\lbrace(u,v)\in{V\times{V}}:c_f(u,v)&gt;0\rbrace\]</span> 也就是说，残存网络的每条边或<strong>残存边</strong>，必须允许大于0的流量通过。图(a)给出了流网络G和流量f，图(b)描述的是对应的残存网络<span class="math inline">\(G_f\)</span>。<span class="math inline">\(E_f\)</span>中的边要么是E中原有的边，要么是其反向边，因此有 <span class="math display">\[|E_f|\le2|E|\]</span></p><p><img src="/uploads/image/introduction-to-algorithms/maximum-flow-problem.png" title="最大流问题以及残存网络"></p><p>可以在残存网络中定义一个流，它满足流的定义，但是针对的是残存网络<span class="math inline">\(G_f\)</span>中的容量<span class="math inline">\(c_f\)</span>。残存网络中的一个流指出的是一条路线图：如何在原来的流网络中增加流。如果f是G的一个流，<span class="math inline">\(f^\prime\)</span>是对应的残存网络<span class="math inline">\(G_f\)</span>中的一个流，定义<span class="math inline">\(f\uparrow{f^\prime}\)</span>为流<span class="math inline">\(f^\prime\)</span>对流f的<strong>递增</strong>（augmentation），它是一个从<span class="math inline">\(V\times{V}\)</span>到<span class="math inline">\(\mathbb{R}\)</span>的函数，其定义如下： <span class="math display">\[(f\uparrow{f^\prime})(u,v)=\begin{cases}f(u,v)+f^\prime(u,v)-f^\prime(v,u)&amp;if (u,v)\in{E}\\0&amp;otherwise\end{cases}\tag{26.4}\]</span></p><p>该定义背后的直观解释遵循残存网络的定义。因为在残存网络中将流量发送到反向边上等同于在原来的网络中缩减流量，所以将边(u,v)的流量增加了<span class="math inline">\(f^\prime(u,v)\)</span>，但减少了<span class="math inline">\(f^\prime(v,u)\)</span>。在残存网络中将流量推送回去也称为<strong>抵消操作</strong>（cancellation）。例如，如果将5货箱的冰球从城市u发送到城市v，同时将2货箱冰球从城市v发送到城市u，那么可以等价（以最后结果来看）地将3货箱冰球从城市u发送到城市v，而不从城市v发送货箱到城市u。这类抵消操作对于任何最大流算法来说都是非常关键的。</p><blockquote><p>引理26.1</p><p>设G=(V,E)为一个流网络，源结点为s，汇点为t，设f为G中的一个流。设<span class="math inline">\(G_f\)</span>为由流f所诱导的G的残存网络，设<span class="math inline">\(f^\prime\)</span>为<span class="math inline">\(G_f\)</span>中的一个流。那么式(26.4)所定义的函数<span class="math inline">\(f\uparrow{f^\prime}\)</span>是G的一个流，其值<span class="math inline">\(|f\uparrow{f^\prime}|=|f|+|f^\prime|\)</span>。</p></blockquote><p><strong>证明</strong>：首先证明<span class="math inline">\(f\uparrow{f^\prime}\)</span>是G的一个流，即满足流的两条性质：容量限制和流量守恒。</p><p>对于容量限制，注意到，如果边<span class="math inline">\((u,v)\in{E}\)</span>，则<span class="math inline">\(c_f(v,u)=f(u,v)\)</span>。而且<span class="math inline">\(f^\prime(v,u)\le{c_f(v,u)}=f(u,v)\)</span>。因此， <span class="math display">\[\begin{aligned}(f\uparrow{f^\prime})(u,v)&amp;=f(u,v)+f^\prime(u,v)-f^\prime(v,u)&amp;\text{(by equation(26.4))}\\&amp;\ge{f(u,v)+f^\prime(u,v)}-f(u,v)&amp;\text{(because }f^\prime(v,u)\le{f(u,v)}\text{)}\\&amp;=f^\prime(u,v)\\&amp;\ge0\end{aligned}\]</span> 此外， <span class="math display">\[\begin{aligned}(f\uparrow{f^\prime})(u,v)&amp;=f(u,v)+f^\prime(u,v)-f^\prime(v,u)&amp;\text{(by equation(26.4))}\\&amp;\le{f(u,v)+f^\prime(u,v)}&amp;\text{(because flows are nonnegative}\\&amp;\le{f(u,v)+c_f(u,v)}&amp;\text{(capacity constraint)}\\&amp;=f(u,v)+c(u,v)-f(u,v)&amp;\text{(by definition (26.2))}\\&amp;=c(u,v)\end{aligned}\]</span></p><p>对于流量守恒性质，因为f和<span class="math inline">\(f^\prime\)</span>均遵守流量守恒性质，所以有<span class="math inline">\(f(u,v)=f(v,u)\)</span>和<span class="math inline">\(f^\prime(u,v)=f^\prime(v,u)\)</span>。因此，对于所有的结点<span class="math inline">\(u\in{V-\lbrace{s,t}\rbrace}\)</span>，有</p><p><span class="math display">\[\begin{aligned}\sum_{v\in{V}}(f\uparrow{f^\prime})(u,v)&amp;=\sum_{v\in{V}}(f(u,v)+f^\prime(u,v)-f^\prime(v,u))\\&amp;=\sum_{v\in{V}}f(u,v)+\sum_{v\in{V}}f^\prime(u,v)-\sum_{v\in{V}}f^\prime(v,u)\\&amp;=\sum_{v\in{V}}f(v,u)+\sum_{v\in{V}}f^\prime(v,u)-\sum_{v\in{V}}f^\prime(u,v)\\&amp;=\sum_{v\in{V}}(f(v,u)+f^\prime(v,u)-f^\prime(u,v))\\&amp;=\sum_{v\in{V}}(f\uparrow{f^\prime})(v,u)\end{aligned}\]</span></p><p>最后，计算<span class="math inline">\(f\uparrow{f^\prime}\)</span>的值。将顶点集合分<span class="math inline">\(V_1\)</span>和<span class="math inline">\(V_2\)</span>两个集合。定义<span class="math inline">\(V_1=\lbrace{v:(s,v)\in{E}}\rbrace\)</span>为有边从源结点s到达的结点集合，<span class="math inline">\(V_2=\lbrace{v:(v,s)\in{E}}\rbrace\)</span>为有边通往s的结点集合，有<span class="math inline">\(V_1\bigcup{V_2}\subseteq{V}\)</span>。并且因为不允许有反平行边，又有<span class="math inline">\(V_1\bigcap{V_2}=\varnothing\)</span>。现在来计算</p><p><span class="math display">\[\begin{aligned}|f\uparrow{f^\prime}|&amp;=\sum_{v\in{V}}(f\uparrow{f^\prime})(s,v)-\sum_{v\in{V}}(f\uparrow{f^\prime})(v,s)\\&amp;=\sum_{v\in{V_1\cup{V_2}}}(f\uparrow{f^\prime})(s,v)-\sum_{v\in{V_1\cup{V_2}}}(f\uparrow{f^\prime})(v,s)\\\end{aligned}\tag{26.5}\]</span> 回忆之间的内容，对于边<span class="math inline">\((u,v)\notin{E}\)</span>，定义f(u,v)=0，因此有<span class="math inline">\(f(s,v)=0\text{, if }{v\in{V_2}}\)</span>和<span class="math inline">\(f(v,s)=0\text{, if }{v\in{V_1}}\)</span>。现在将<span class="math inline">\(f\uparrow{f^\prime}\)</span>的定义应用到式(26.5)上，然后对和值项进行重新排序与重组可以获得： <span class="math display">\[\begin{aligned}|f\uparrow{f^\prime}|&amp;=\sum_{v\in{V_1}}(f\uparrow{f&#39;})(s,v)-\sum_{v\in{V_2}}(f\uparrow{f&#39;})(v,s)\\&amp;=\sum_{v\in{V_1}}(f(s,v)+f&#39;(s,v)-f&#39;(v,s))-\sum_{v\in{V_2}}(f(v,s)+f&#39;(v,s)-f&#39;(s,v))\\&amp;=\sum_{v\in{V_1}}f(s,v)-\sum_{v\in{V_2}}f(v,s)+\sum_{v\in{V_1}}f&#39;(s,v)+\sum_{v\in{V_2}}f&#39;(s,v)-\sum_{v\in{V_1}}f&#39;(v,s)-\sum_{v\in{V_2}}f&#39;(v,s)\\&amp;=\sum_{v\in{V_1}}f(s,v)-\sum_{v\in{V_2}}f(v,s)+\sum_{v\in{V_1\bigcup{V_2}}}f&#39;(s,v)-\sum_{v\in{V_1\bigcup{V_2}}}f&#39;(v,s)\\&amp;=\sum_{v\in{V}}f(s,v)-\sum_{v\in{V}}f(v,s)+\sum_{v\in{V}}f&#39;(s,v)-\sum_{v\in{V}}f&#39;(v,s)\\&amp;=|f|+|f&#39;|\end{aligned}\]</span></p><h2 id="增广路径">增广路径</h2><p>给定流网络G=(V,E)和流f，增广路径p是残存网络<span class="math inline">\(G_f\)</span>中一条从源结点到汇点t的简单路径。根据残存网络的定义，对于一条增广路径上的边(u,v)，可以增加其流量的幅度最大为<span class="math inline">\(c_f(u,v)\)</span>，而不会违反原始流网络G中对边(u,v)或(v,u)的容量限制。</p><p>上图(b)中阴影覆盖的路径是一条增广路径。如果将图中的残存网络<span class="math inline">\(G_f\)</span>看作一个流网络，那么可以对这条路径上每条边的流量增加4个单位，而不会违反容量限制，因为该条路径上最小的残存容量是<span class="math inline">\(c_f(v_2,v_3)=4\)</span>。称在一条增广路径p上能够为每条边增加的流量的最大值为路径p的<strong>残存容量</strong>，该容量由下面的表达式给出： <span class="math display">\[c_f(p)=min\lbrace{c_f(u,v):(u,v)\text{ 属于路径 }p}\rbrace\]</span></p><p>下面精确阐述残存网络中的流：</p><blockquote><p>引理26.2</p><p>设G=(V,E)为一个流网络，设f为G中的一个流，设p为残存网络<span class="math inline">\(G_f\)</span>中的一条增广路径。定义一个函数<span class="math inline">\(f_p:V\times{V}\rightarrow\mathbb{R}\)</span>如下： <span class="math display">\[f_p(u,v)=\begin{cases}c_f(p)&amp;\text{if }(u,v)\text{ is on }p\\0&amp;otherwise\end{cases}\tag{26.8}\]</span> 则<span class="math inline">\(f_p\)</span>是残存网络<span class="math inline">\(G_f\)</span>中的一个流，其值为<span class="math inline">\(|f_p|=c_f(p)&gt;0\)</span>。</p></blockquote><p>式(26.8)表示，残存网络中在增广路径p上的边的流量等于残存容量<span class="math inline">\(c_f(p)\)</span>，不在增广路径p上的边的流量为0。</p><p>下面的推论证明，如果将流f增加<span class="math inline">\(f_p\)</span>的量，则将获得G的另一个流，该流的值更加接近最大值。</p><blockquote><p>推论26.3</p><p>设G=(V,E)为一个流网络，设f为G中的一个流，设p为残存网络<span class="math inline">\(G_f\)</span>中的一条增广路径。设<span class="math inline">\(f_p\)</span>由式(26.8)所定义，假定将f增加<span class="math inline">\(f_p\)</span>的量，则函数<span class="math inline">\(f\uparrow{f_p}\)</span>是图G中的一个流，其值为<span class="math inline">\(|f\uparrow{f_p}|=|f|+|f_p|&gt;|f|\)</span>。</p></blockquote><p><strong>证明</strong>：根据引理26.1和引理26.2可得到上述结论。</p><h2 id="流网络的切割">流网络的切割</h2><p>Ford-Fulkerson方法的核心就是沿着增广路径重复增加路径上的流量，直到找到最大流为止。如何知道在算法中终止时，确实找到了一个最大流呢？最大流最小割定理告诉我们，一个流是最大流当且仅当其残存网络中不包含任何增广路径。为了证明这个定理，首先来探讨一下流网络中的切割概念。</p><p>流网络G=(V,E)中的一个切割(S,T)将结点集合V划分为S和T=V-S两个集合，使得<span class="math inline">\(s\in{S},t\in{T}\)</span>。若f是一个流，则定义横跨切割(S,T)的<strong>净流量</strong>f(S,T)如下： <span class="math display">\[f(S,T)=\sum_{u\in{S}}\sum_{v\in{T}}f(u,v)-\sum_{u\in{S}}\sum_{v\in{T}}f(v,u)\tag{26.9}\]</span> 切割(S,T)的<strong>容量</strong>是： <span class="math display">\[c(S,T)=\sum_{u\in{S}}\sum_{v\in{T}}c(u,v)\tag{26.10}\]</span> 一个网络的最小切割是整个网络中<strong>容量最小</strong>的切割。</p><p>流的定义和切割容量的定义之间存在着不对称性，这种不对称性是有意而为，并且很重要。</p><ul><li>对于容量，计算从集合S发出进入集合T的边的容量，而忽略反方向边上的容量。</li><li>对于流，考虑的则是从S到T的流量减去从T到S的反方向的流量。</li></ul><p>下图描述的是流网络的一个切割（<span class="math inline">\(\lbrace{s,v_1,v_2}\rbrace,\lbrace{v_3,v_4,t}\rbrace\)</span>）。横跨该切割的净流量是<span class="math inline">\(f(v_1,v_3)+f(v_2,v_4)-f(v_3,v_2)=12+11-4=19\)</span>。该切割的容量是<span class="math inline">\(c(v_1,v_3)+c(v_2,v_4)=12+14=26\)</span>。</p><p><img src="/uploads/image/introduction-to-algorithms/s-t-cut-in-flow-network.png" title="流网络的一个ST切割"></p><blockquote><p>引理26.4</p><p>设f为流网络G的一个流，该流网络的源结点为s，汇点为t，设(S,T)为流网络G的任意切割，则横跨切割(S,T)的净流量为f(S,T)=|f|。</p></blockquote><p>直观上，从源结点s发往汇点t的流量必然经过切割的边界（图中虚线）,并且流满足流量守恒性质，表明所有从源结点s发出的流量最终都会流入汇点t。因此所有横跨边界的净流量等于流的值。</p><p>形式化地：对于任意结点<span class="math inline">\(u\in{V-\lbrace{s,t}\rbrace}\)</span>，重写（将右边的子式移到左边）流量守恒性质如下： <span class="math display">\[\begin{aligned}\sum_{v\in{V}}f(u,v)-\sum_{v\in{V}}f(v,u)=0\qquad{u\in{V-\lbrace{s,t}\rbrace}}\end{aligned}\tag{26.11}\]</span> 针对所有结点<span class="math inline">\(S-\lbrace{s}\rbrace\)</span>求和： <span class="math display">\[\sum_{u\in{S-\{s\}}}(\sum_{v\in{V}}f(u,v)-\sum_{v\in{V}}f(v,u))=0\]</span> 根据式(26.1)对|f|的定义，将上式的左项加进来： <span class="math display">\[\begin{aligned}|f|&amp;=\sum_{v\in{V}}f(s,v)-\sum_{v\in{V}}f(v,s)+\sum_{u\in{S-\{s\}}}(\sum_{v\in{V}}f(u,v)-\sum_{v\in{V}}f(v,u))\\&amp;=\sum_{v\in{V}}f(s,v)-\sum_{v\in{V}}f(v,s)+\sum_{u\in{S-\{s\}}}\sum_{v\in{V}}f(u,v)-\sum_{u\in{S-\{s\}}}\sum_{v\in{V}}f(v,u)\\&amp;=\sum_{v\in{V}}(f(s,v)+\sum_{u\in{S-\{s\}}}f(u,v))-\sum_{v\in{V}}(f(v,s)+\sum_{u\in{S-\{s\}}}f(v,s))\\&amp;=\sum_{v\in{V}}\sum_{u\in{S}}f(u,v)-\sum_{v\in{V}}\sum_{u\in{S}}f(v,u)\end{aligned}\]</span></p><p>因为<span class="math inline">\(V=S\bigcup{T},S\bigcap{T}=\varnothing\)</span>，将上述表达式中针对集合V的求和分解为针对S和T的求和，得到： <span class="math display">\[\begin{aligned}|f|&amp;=\sum_{v\in{S}}\sum_{u\in{S}}f(u,v)+\sum_{v\in{T}}\sum_{u\in{S}}f(u,v)-\sum_{v\in{S}}\sum_{u\in{S}}f(v,u)-\sum_{v\in{T}}\sum_{u\in{S}}f(v,u)\\&amp;=\sum_{v\in{T}}\sum_{u\in{S}}f(u,v)-\sum_{v\in{T}}\sum_{u\in{S}}f(v,u)+\color{red}{\Bigl(\sum_{v\in{S}}\sum_{u\in{S}}f(u,v)-\sum_{v\in{S}}\sum_{u\in{S}}f(v,u)\Bigr)}\end{aligned}\]</span> 上式表达式括号里面的两个求和项实际上是一样的。因此，这些求和项相互抵消，得到： <span class="math display">\[|f|=\sum_{v\in{T}}\sum_{u\in{S}}f(u,v)-\sum_{v\in{T}}\sum_{u\in{S}}f(v,u)=f(S,T)\]</span></p><blockquote><p>推论26.5</p><p>流网络G中任意流f的值不能超过G的任意切割容量。</p></blockquote><p><strong>证明</strong>：设(S,T)为流网络G的任意切割，设f为G中的任意流。根据引理26.4和容量限制性质，有 <span class="math display">\[\begin{aligned}|f|=f(S,T)&amp;=\sum_{u\in{S}}\sum_{v\in{T}}f(u,v)-\sum_{u\in{S}}\sum_{v\in{T}}f(v,u)\\&amp;\le\sum_{u\in{}S}\sum_{v\in{T}}f(u,v)\le\sum_{u\in{}S}\sum_{v\in{T}}c(u,v)=c(S,T)\end{aligned}\]</span></p><h2 id="最大流最小割定理">最大流最小割定理</h2><blockquote><p>定理26.6 （最大流最小割定理）</p><p>设f为流网络G=(V,E)中的一个流，该流网络的源结点为s，汇点为t，则下面的条件是等价的：</p><ol type="1"><li>f是G的一个最大流。</li><li>残存网络<span class="math inline">\(G_f\)</span>不包含任何增广路径。</li><li>|f|=c(S,T)，其中(S,T)是流网络的某个切割。</li></ol></blockquote><p><strong>证明</strong>：</p><ul><li><p><span class="math inline">\((1)\Rightarrow(2)\)</span>：使用反证法。假定f是G的一个最大流，但残存网络<span class="math inline">\(G_f\)</span>同时包含一条增广路径p。那么根据推论26.3，对f增加流量<span class="math inline">\(f_p\)</span>所形成的流是G中的一个值严格大于|f|的流，这与f是最大流的假设矛盾。</p></li><li><p><span class="math inline">\((2)\Rightarrow(3)\)</span>：假设<span class="math inline">\(G_f\)</span>不包含任何增广路径，也就是说，在残存网络<span class="math inline">\(G_f\)</span>中不存在任何从源结点s到汇点t的路径。定义<span class="math inline">\(S=\lbrace{v\in{V}:\text{在 }G_f\text{中存在从 }s\text{到}v\text{的路径}}\rbrace,T=V-S\)</span>。显然，<span class="math inline">\(s\in{S}\)</span>，而因为<span class="math inline">\(G_f\)</span>中不存在从s到t的路径（增广路径），所以<span class="math inline">\(t\notin{S}\)</span>。因此，划分(S,T)是流网络G的一个切割。下面证明|f|=c(S,T)。</p><p>考虑一对结点<span class="math inline">\(u\in{S}\)</span>和<span class="math inline">\(v\in{T}\)</span>。</p><ul><li>如果<span class="math inline">\((u,v)\in{E}\)</span>，则必有f(u,v)=c(u,v)，否则边(u,v)将属于<span class="math inline">\(E_f\)</span>，在残存网络中存在一条路径<span class="math inline">\(s\rightsquigarrow{u}\rightarrow{v}\)</span>到达结点v，即<span class="math inline">\(v\in{S}\)</span>，这与结点<span class="math inline">\(v\in{T}\)</span>矛盾。</li><li>如果<span class="math inline">\((v,u)\in{E}\)</span>，则必有f(v,u)=0，否则边(u,v)将属于<span class="math inline">\(E_f\)</span>，得出<span class="math inline">\(v\in{S}\)</span>，与<span class="math inline">\(v\in{T}\)</span>矛盾。</li><li>如果边(u,v)和(v,u)都不在集合E中，则f(u,v)=f(v,u)=0。</li></ul></li></ul><p>因此有 <span class="math display">\[\begin{aligned}f(S,T)&amp;=\sum_{u\in{S}}\sum_{v\in{T}}f(u,v)-\sum_{u\in{S}}\sum_{v\in{T}}f(v,u)\\&amp;=\sum_{u\in{S}}\sum_{v\in{T}}f(u,v)-\sum_{u\in{S}}\sum_{v\in{T}}0\\&amp;=c(S,T)\end{aligned}\]</span></p><ul><li><span class="math inline">\((3)\Rightarrow(1)\)</span>：根据推论26.5，对于所有切割(S,T)，<span class="math inline">\(|f|\le{c(S,T)}\)</span>。因此，条件|f|=c(S,T)隐含着|f|是一个最大流。</li></ul><h1 id="基本的ford-fulkerson算法">基本的Ford-Fulkerson算法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FORD-FULKERSON(G, s, t):</span><br><span class="line">    <span class="keyword">for</span> each edge (u,v) <span class="keyword">in</span> G.E:  <span class="comment"># 将流f初始化为0</span></span><br><span class="line">        (u,v).f = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> there exists a path p <span class="keyword">from</span> s to t <span class="keyword">in</span> the residual network:  <span class="comment"># 寻找增广路径</span></span><br><span class="line">        c_f(p) = min&#123;c_f(u,v):(u,v) <span class="keyword">is</span> <span class="keyword">in</span> p&#125;   <span class="comment"># 残存容量</span></span><br><span class="line">        <span class="keyword">for</span> each edge (u,v) <span class="keyword">in</span> p:              <span class="comment"># 修改原始流网络中的流</span></span><br><span class="line">            <span class="keyword">if</span> (u,v) <span class="keyword">in</span> E:</span><br><span class="line">                (u,v).f = (u,v).f + c_f(p)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                (v,u).f = (v,u).f - c_f(p)</span><br></pre></td></tr></table></figure><p>FORD-FULKERSON算法仅是对FORD-FULKERSON-METHOD过程的简单扩展。下图描述的是一个样本运行过程的每次迭代的结果。</p><p><img src="/uploads/image/introduction-to-algorithms/ford-fulkerson-example.png" title="Ford-Fulkerson示例"></p><h2 id="分析">分析</h2><p>假定所选择的任意增广路径和所有的容量都是整数（如果容量为有理数，则可以通过乘以某个系数来将其转换为整数；如果容量为无理数，则Ford-Fulkerson方法可能不会终止）。</p><ul><li>初始化：对每条边赋初始值0，成本是O(E)。</li><li>寻找增广路径：如果用来实现流网络G=(V,E)的数据结构是合理的，使用深度优先搜索或广度优先搜索在一个残存网络中找到一条路径的时间应是O(V+E)=O(E)。</li><li>while循环：执行一遍的时间为O(E)。如果<span class="math inline">\(f^\star\)</span>表示网络中的一个最大流，则在FORD-FULKERSON算法中，while循环的次数最多为<span class="math inline">\(|f^\star|\)</span>次，因为流量值在每次迭代中最少增加一个单位。</li></ul><p>从而整个FORD-FULKERSON算法的运行时间为<span class="math inline">\(O(E|f^\star|)\)</span>。</p><p>当容量都是整数值且最优的流量值<span class="math inline">\(|f^\star|\)</span>较小时，FORD-FULKERSON算法的运行时间相当不错。下图描述的是当<span class="math inline">\(|f^\star|\)</span>的取值较大时可能发生的情况。该网络的一个最大流取值为2 000 000，1 000 000单位的流量流经路径<span class="math inline">\(s\rightarrow{u}\rightarrow{t}\)</span>，另外1 000 000单位的流量流经路径<span class="math inline">\(s\rightarrow{v}\rightarrow{t}\)</span>。</p><p>如果FORD-FULKERSON算法找到的第一条增广路径为<span class="math inline">\(s\rightarrow{u}\rightarrow{v}\rightarrow{t}\)</span>，如图(a)所示，则在第一次迭代后，流的值为1。产生的残存网络如图(b)所示，找到的第二条增广路径为<span class="math inline">\(s\rightarrow{v}\rightarrow{u}\rightarrow{t}\)</span>，然后流的值将为2。图(c)描述的是结果残存网络。</p><p>如此继续下去，在每个奇数次迭代中，选择增广路径<span class="math inline">\(s\rightarrow{u}\rightarrow{v}\rightarrow{t}\)</span>，在每个偶数次迭代中，选择增广路径<span class="math inline">\(s\rightarrow{v}\rightarrow{u}\rightarrow{t}\)</span>，这样将一共执行2 000 000次递增操作，每次将流量增加1个单位。</p><p><img src="/uploads/image/introduction-to-algorithms/ford-fulkerson-analysis.png" title="循环次数很大的一个示例问题"></p><h1 id="edmonds-karp算法">Edmonds-Karp算法</h1><p>使用广度优先搜索寻找增广路径可以改善FORD-FULKERSON算法的效率。广度优先搜索得到的增广路径是一条从源结点s到汇点t的<strong>最短</strong>（边数最少）路径。称如此实现的Ford-Fulkerson方法为Edmonds-Karp算法。该算法的运行时间为<span class="math inline">\(O(VE^2)\)</span>，只与流网络的规模有关，与最优的流量值无关。</p><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_f</span><span class="params">(graph)</span>:</span></span><br><span class="line">    print(<span class="string">'max flow:'</span>, graph.graph[<span class="string">'max_flow'</span>])</span><br><span class="line">    fmt = <span class="string">'&#123;0:&lt;4s&#125; &#123;1:&lt;4s&#125; &#123;2:&lt;4s&#125; &#123;3:&lt;8s&#125;\n'</span></span><br><span class="line">    title = fmt.format(<span class="string">'u'</span>, <span class="string">'v'</span>, <span class="string">'flow'</span>, <span class="string">'capacity'</span>)</span><br><span class="line">    data = <span class="string">''</span>.join(</span><br><span class="line">        fmt.format(str(u), str(v), str(attr[<span class="string">'flow'</span>]), str(attr[<span class="string">'capacity'</span>])) <span class="keyword">for</span> u, v, attr <span class="keyword">in</span> graph.edges(data=<span class="literal">True</span>) <span class="keyword">if</span></span><br><span class="line">        attr[<span class="string">'flow'</span>] &gt; <span class="number">0</span>)</span><br><span class="line">    print(title + data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_path_dfs</span><span class="params">(graph, s, t, p)</span>:</span></span><br><span class="line">    <span class="string">"""寻找增广路径，深度优先搜索（递归实现）"""</span></span><br><span class="line">    <span class="keyword">if</span> s == t:</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> graph.get_e(s):</span><br><span class="line">        residuals = e.c - e.f</span><br><span class="line">        <span class="keyword">if</span> residuals &gt; <span class="number">0</span> <span class="keyword">and</span> e <span class="keyword">not</span> <span class="keyword">in</span> p:</span><br><span class="line">            p.add(e)  <span class="comment"># 将当前邻接边加入path，向sink寻路</span></span><br><span class="line">            result = find_path_dfs(graph, e.v, t, p)</span><br><span class="line">            <span class="keyword">if</span> result <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">            p.remove(e)  <span class="comment"># 若没找到通向sink的路，从path中移除当前边，循环下一条邻接边</span></span><br><span class="line">    <span class="comment"># 未找到路径，将返回默认值None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_path_bfs</span><span class="params">(graph, s, t, p)</span>:</span></span><br><span class="line">    <span class="string">"""Ford-Fulkerson Method的一种特殊实现：Edmonds-Karp algorithm</span></span><br><span class="line"><span class="string">    使用广度优先搜索寻找增广路径，寻找一条边数最少的增广路径"""</span></span><br><span class="line">    previous, visit, q = &#123;s: <span class="literal">None</span>&#125;, set(), Queue()</span><br><span class="line">    q.put(s)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">        u = q.get()</span><br><span class="line">        visit.add(u)  <span class="comment"># visit用来记录结点是否曾被访问过</span></span><br><span class="line">        <span class="keyword">if</span> u == t:  <span class="comment"># 输出路径</span></span><br><span class="line">            pre = previous[t]</span><br><span class="line">            <span class="keyword">while</span> pre <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                p.add((pre, u))  <span class="comment"># path的顺序无影响</span></span><br><span class="line">                u = pre</span><br><span class="line">                pre = previous[pre]</span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line">        <span class="keyword">for</span> v, attr <span class="keyword">in</span> graph[u].items():</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> visit:</span><br><span class="line">                residual = attr[<span class="string">'capacity'</span>] - attr[<span class="string">'flow'</span>]  <span class="comment"># 判断残存容量</span></span><br><span class="line">                <span class="keyword">if</span> residual &gt; <span class="number">0</span>:</span><br><span class="line">                    q.put(v)</span><br><span class="line">                    previous[v] = u  <span class="comment"># previous记录前驱结点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_path</span><span class="params">(graph, s, t, path)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> find_path_bfs(graph, s, t, path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_flow</span><span class="params">(graph, s, t)</span>:</span></span><br><span class="line">    <span class="string">"""求最大流"""</span></span><br><span class="line">    p = find_path(graph, s, t, set())</span><br><span class="line">    <span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        augment_flow = min(graph[u][v][<span class="string">'capacity'</span>] - graph[u][v][<span class="string">'flow'</span>] <span class="keyword">for</span> u, v <span class="keyword">in</span> p)</span><br><span class="line">        <span class="keyword">for</span> u, v <span class="keyword">in</span> p:</span><br><span class="line">            graph[u][v][<span class="string">'flow'</span>] += augment_flow</span><br><span class="line">            graph[v][u][<span class="string">'flow'</span>] -= augment_flow</span><br><span class="line">        p = find_path(graph, s, t, set())</span><br><span class="line">    graph.graph[<span class="string">'max_flow'</span>] = sum(attr[<span class="string">'flow'</span>] <span class="keyword">for</span> attr <span class="keyword">in</span> graph[s].values())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_graph</span><span class="params">(graph, vertices, edges)</span>:</span></span><br><span class="line">    graph.add_nodes_from(vertices)</span><br><span class="line">    <span class="keyword">for</span> u, v, c <span class="keyword">in</span> edges:</span><br><span class="line">        graph.add_edges_from([(u, v, &#123;<span class="string">'capacity'</span>: c&#125;), (v, u, &#123;<span class="string">'capacity'</span>: <span class="number">0</span>&#125;)], flow=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    g = nx.DiGraph()</span><br><span class="line">    v = <span class="string">'s1234t'</span></span><br><span class="line">    e = [(<span class="string">'s'</span>, <span class="string">'1'</span>, <span class="number">6</span>), (<span class="string">'s'</span>, <span class="string">'3'</span>, <span class="number">5</span>), (<span class="string">'s'</span>, <span class="string">'4'</span>, <span class="number">1</span>), (<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="number">5</span>), (<span class="string">'1'</span>, <span class="string">'4'</span>, <span class="number">2</span>), (<span class="string">'1'</span>, <span class="string">'t'</span>, <span class="number">3</span>),</span><br><span class="line">         (<span class="string">'2'</span>, <span class="string">'t'</span>, <span class="number">5</span>), (<span class="string">'3'</span>, <span class="string">'1'</span>, <span class="number">2</span>), (<span class="string">'3'</span>, <span class="string">'4'</span>, <span class="number">4</span>), (<span class="string">'4'</span>, <span class="string">'2'</span>, <span class="number">3</span>), (<span class="string">'4'</span>, <span class="string">'t'</span>, <span class="number">3</span>)]</span><br><span class="line">    initialize_graph(g, v, e)</span><br><span class="line">    max_flow(g, <span class="string">'s'</span>, <span class="string">'t'</span>)</span><br><span class="line">    print_f(g)</span><br><span class="line"></span><br><span class="line">    g.clear()</span><br><span class="line">    e = [(<span class="string">'s'</span>, <span class="string">'1'</span>, <span class="number">16</span>), (<span class="string">'s'</span>, <span class="string">'2'</span>, <span class="number">13</span>), (<span class="string">'1'</span>, <span class="string">'3'</span>, <span class="number">12</span>), (<span class="string">'2'</span>, <span class="string">'1'</span>, <span class="number">4</span>), (<span class="string">'2'</span>, <span class="string">'4'</span>, <span class="number">14</span>), (<span class="string">'3'</span>, <span class="string">'2'</span>, <span class="number">9</span>),</span><br><span class="line">         (<span class="string">'3'</span>, <span class="string">'t'</span>, <span class="number">20</span>), (<span class="string">'4'</span>, <span class="string">'3'</span>, <span class="number">7</span>), (<span class="string">'4'</span>, <span class="string">'t'</span>, <span class="number">4</span>)]</span><br><span class="line">    initialize_graph(g, v, e)</span><br><span class="line">    max_flow(g, <span class="string">'s'</span>, <span class="string">'t'</span>)</span><br><span class="line">    print_f(g)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">max flow: 11</span><br><span class="line">u    v    flow capacity</span><br><span class="line">s    1    6    6</span><br><span class="line">s    3    5    5</span><br><span class="line">1    2    2    5</span><br><span class="line">1    4    2    2</span><br><span class="line">1    t    3    3</span><br><span class="line">2    t    5    5</span><br><span class="line">3    1    1    2</span><br><span class="line">3    4    4    4</span><br><span class="line">4    2    3    3</span><br><span class="line">4    t    3    3</span><br><span class="line"></span><br><span class="line">max flow: 23</span><br><span class="line">u    v    flow capacity</span><br><span class="line">s    1    12   16</span><br><span class="line">s    2    11   13</span><br><span class="line">1    3    12   12</span><br><span class="line">2    4    11   14</span><br><span class="line">3    t    19   20</span><br><span class="line">4    3    7    7</span><br><span class="line">4    t    4    4</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Algorithms </tag>
            
            <tag> algorithms </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Python中使用CPLEX</title>
      <link href="/operations-research/cplex-in-python/"/>
      <url>/operations-research/cplex-in-python/</url>
      
        <content type="html"><![CDATA[<h1 id="设置api">设置API</h1><p>从搭建运行环境开始。使用的软件如下：</p><ul><li>ILOG CPLEX Optimization studio 12.9.0 64bit。</li><li>Python3.6.8 64bit。</li></ul><p>安装好ILOG CPLEX Optimization studio后，<a href="https://www.ibm.com/support/knowledgecenter/zh/SSSA5P_12.9.0/ilog.odms.cplex.help/CPLEX/GettingStarted/topics/set_up/Python_setup.html" target="_blank" rel="noopener">设置 CPLEX 的 Python API</a>。</p><h2 id="使用脚本-setup.py">使用脚本 setup.py</h2><p>要在系统上安装 CPLEX-Python 模块，请使用位于 yourCplexhome/python/VERSION/PLATFORM 中的脚本 setup.py。 如果要将 CPLEX-Python 模块安装在非缺省位置，请使用选项 --home 识别安装目录。 例如，要将 CPLEX-Python 模块安装在缺省位置，请从命令行使用以下命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><p>要安装在目录 yourPythonPackageshome/cplex 中，请从命令行使用以下命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python setup.py install --home yourPythonPackageshome/cplex</span><br></pre></td></tr></table></figure><p>这两个命令（缺省和指定主目录）均会调用 Python 包 distutils。 有关适用于该软件包的其他选项，请参考 Python distutils 的文档。</p><p>设置完成后，若能在Python解释器中导入cplex库（<code>import cplex</code>）说明配置成功。</p><a id="more"></a><p><strong>附</strong>：</p><ol type="1"><li>CPLEX API和Python位数需一致。</li><li>CPLEX Optimization studio 12.9版本不支持32bit。</li><li>如果都安装64bit版本，Python不要选择v3.7，某些库尚不支持Python3.7 64bit。</li></ol><h1 id="hello-cplex">Hello CPLEX</h1><p>cplex中重要的一个类就是Cplex类，它提供了创建、修改、查询最优化问题的一系列方法。Cplex 的官方文档：<a href="https://www.ibm.com/support/knowledgecenter/zh/SSSA5P_12.9.0/ilog.odms.cplex.help/refpythoncplex/html/cplex.Cplex-class.html" target="_blank" rel="noopener">Class Cplex</a>。使用cplex优化一个LP模型：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Maximize</span><br><span class="line">3x1 + 5x2</span><br><span class="line">Subject to</span><br><span class="line"> x1 + 7x2 &lt;= 140</span><br><span class="line"> x1 + 2x2 &lt;= 50</span><br><span class="line">3x1 + 2x2 &lt;= 130</span><br><span class="line">Bounds</span><br><span class="line">0 &lt;= x1 &lt;= infinity</span><br><span class="line">0 &lt;= x2 &lt;= infinity</span><br><span class="line">End</span><br></pre></td></tr></table></figure><p>将上述内容保存至文件hello.lp，之后可以直接读取该文件。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cplex</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    c = cplex.Cplex()</span><br><span class="line">    c.read(<span class="string">'hello.lp'</span>)</span><br><span class="line">    c.solve()</span><br><span class="line">    print(c.solution.get_objective_value(), c.solution.get_values())</span><br></pre></td></tr></table></figure><p>或者直接构建相同的模型。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cplex</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    c = cplex.Cplex()</span><br><span class="line">    <span class="comment"># 设置优化目标为最大化，默认是minimize</span></span><br><span class="line">    c.objective.set_sense(c.objective.sense.maximize)</span><br><span class="line">    <span class="comment"># obj: 目标函数</span></span><br><span class="line">    <span class="comment"># names: 变量名</span></span><br><span class="line">    <span class="comment"># lb: lower bound</span></span><br><span class="line">    <span class="comment"># ub: upper bound</span></span><br><span class="line">    c.variables.add(</span><br><span class="line">        obj=[<span class="number">3</span>, <span class="number">5</span>], names=[<span class="string">'x1'</span>, <span class="string">'x2'</span>],</span><br><span class="line">        lb=[<span class="number">0.0</span>, <span class="number">0.0</span>], ub=[cplex.infinity] * <span class="number">2</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># lin_expr: 线性表达式，约束条件左边</span></span><br><span class="line">    <span class="comment"># senses: 约束条件的比较符号，G|L|E|R，分别表示大于等于|小于等于|等于|区间约束</span></span><br><span class="line">    <span class="comment"># rhs: right hand side，约束条件右边的值</span></span><br><span class="line">    c.linear_constraints.add(</span><br><span class="line">        lin_expr=[([<span class="string">'x1'</span>, <span class="string">'x2'</span>], [<span class="number">1</span>, <span class="number">7</span>]),</span><br><span class="line">                  ([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>]),</span><br><span class="line">                  ([<span class="string">'x1'</span>, <span class="string">'x2'</span>], [<span class="number">3</span>, <span class="number">2</span>])],</span><br><span class="line">        senses=<span class="string">'L'</span> * <span class="number">3</span>,</span><br><span class="line">        rhs=[<span class="number">140.0</span>, <span class="number">50.0</span>, <span class="number">130.0</span>]</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 求解问题，解决方案保存在c.solution变量</span></span><br><span class="line">    c.solve()</span><br><span class="line">    <span class="comment"># 打印最优值和所有变量的值</span></span><br><span class="line">    print(c.solution.get_objective_value(), c.solution.get_values())</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CPXPARAM_Read_DataCheck                          1</span><br><span class="line">Tried aggregator 1 time.</span><br><span class="line">No LP presolve or aggregator reductions.</span><br><span class="line">Presolve time = 0.00 sec. (0.00 ticks)</span><br><span class="line"></span><br><span class="line">Iteration log . . .</span><br><span class="line">Iteration:     1   Dual infeasibility =             0.000000</span><br><span class="line">Iteration:     2   Dual objective     =           175.789474</span><br><span class="line">145.0 [40.0, 5.0]  # 最优值和此时变量的值，上面是log内容</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 运筹学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linear programming </tag>
            
            <tag> cplex </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单源最短路径</title>
      <link href="/notes/introduction-to-algorithms/single-source-shortest-paths/"/>
      <url>/notes/introduction-to-algorithms/single-source-shortest-paths/</url>
      
        <content type="html"><![CDATA[<h1 id="简介">简介</h1><p>最短路径问题（Shortest path problem, SPP）旨在寻找图中两个结点之间的最短路径。本文介绍单源最短路径问题：给定一个图 <span class="math inline">\(G=(V,E)\)</span>，我们希望找到从给定源节点 <span class="math inline">\(s\)</span> 到每个结点 <span class="math inline">\(v\in{V}\)</span> 的最短路径。广度优先搜索就是权重均为1的单源最短路径问题，根节点（源点）到每个结点的最短距离等于最短路径上的边的条数。单源最短路径问题可以用来解决许多其他问题，其中就包括它的几个变体：</p><ul><li>单目的地最短路径问题：找到从给定结点 <span class="math inline">\(v\)</span> 到给定目的地结点 <span class="math inline">\(t\)</span> 的最短路径。如果将图的每条边的方向翻转过来，就可以将这个问题转换为单源最短路径问题。</li><li>单节点对最短路径问题：找到从给定结点 <span class="math inline">\(u\)</span> 到给定节点 <span class="math inline">\(v\)</span> 的最短距离。如果解决了针对单个结点 <span class="math inline">\(u\)</span> 的单源最短路径问题，那么也就解决了这个问题。而且，在该问题的所有已知算法中，最坏情况下的渐进运行时间都和最好的单源最短路径算法的运行时间一样。</li><li>所有结点对最短距离：对于每对结点 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(v\)</span>，找到从结点 <span class="math inline">\(u\)</span> 到结点 <span class="math inline">\(v\)</span> 的最短路径。可以针对每个结点运行一遍单源最短路径算法，但可以更快地解决这个问题。此类问题适合使用Floyd-Warshall算法。</li></ul><a id="more"></a><h1 id="最短路径的最优子结构">最短路径的最优子结构</h1><blockquote><p>引理24.1 （最短路径的子路径也是最短路径）</p><p>给定带权重的有向图 <span class="math inline">\(G=(V,E)\)</span> 和权重函数 <span class="math inline">\(w:E\rightarrow{R}\)</span>。设 <span class="math inline">\(p=\langle{v_0,v_1,\dots,v_k\rangle}\)</span> 为从结点 <span class="math inline">\(v_0\)</span> 到结点 <span class="math inline">\(v_k\)</span> 的一条最短路径，并且对于任意的 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j，0\le{I}\le{j}\le{k}\)</span>，设 <span class="math inline">\(p_{ij}=\langle{v_i,v_{i+1},\dots,v_j}\rangle\)</span> 为路径 <span class="math inline">\(p\)</span> 中从结点 <span class="math inline">\(v_i\)</span> 到结点 <span class="math inline">\(v_j\)</span> 的子路径。那么 <span class="math inline">\(p_{ij}\)</span> 是从结点 <span class="math inline">\(v_i\)</span> 到结点 <span class="math inline">\(v_j\)</span> 的一条最短路径。</p></blockquote><p><strong>证明</strong>：假设 <span class="math inline">\(p\)</span> 是从 <span class="math inline">\(v_0\)</span> 到 <span class="math inline">\(v_k\)</span> 的一条最短路径。将路径p分解为</p><p><span class="math display">\[v_0\mathop{\rightsquigarrow}^{p_{0i}}v_i\mathop{\rightsquigarrow}^{p_{ij}}v_j\mathop{\rightsquigarrow}^{p_{jk}}v_k\]</span></p><p>则有 <span class="math inline">\(w(p)=w(p_{0i})+w(p_{ij})+w(p_{jk})\)</span>。</p><p>假设存在一条从 <span class="math inline">\(v_i\)</span> 到 <span class="math inline">\(v_j\)</span> 的路径 <span class="math inline">\(p^\prime_{ij}\)</span>，且 <span class="math inline">\(w(p^\prime_{ij})&lt;w(p_{ij})\)</span>。则</p><p><span class="math display">\[v_0\mathop{\rightsquigarrow}^{p_{0i}}v_i\mathop{\rightsquigarrow}^{\color{red}{p^\prime_{ij}}}v_j\mathop{\rightsquigarrow}^{p_{jk}}v_k\]</span></p><p>是一条从结点 <span class="math inline">\(v_0\)</span> 到结点 <span class="math inline">\(v_k\)</span> 的权重为 <span class="math inline">\(w(p^\prime)=w(p_{0i})+w(p^\prime_{ij})+w(p_{jk})\)</span> 的路径，而该权重小于 <span class="math inline">\(w(p)\)</span>。</p><p>这与 <span class="math inline">\(p\)</span> 是从 <span class="math inline">\(v_0\)</span> 到 <span class="math inline">\(v_k\)</span> 的一条最短路径这一假设矛盾。</p><h1 id="环路">环路</h1><p>不失一般性，我们可以假定找到的最短路径中没有环路，即它们都是简单路径。</p><ul><li><p>若一条路径包含权重为正值的环路，那么将环路从路径上删除就可以得到一条源点和终点相同的权重更小的路径。</p></li><li><p>若包含权重为负值的环路，那么只要沿着环路再遍历一遍，就能找到一条权重更小的路径。如果从结点s到结点v的某条路径上存在权重为负值的环路，我们定义结点s到结点v的最短路径<span class="math inline">\(\delta(s,v)=-\infty\)</span>。例如下图中，存在<span class="math inline">\(\langle{e,f,e}\rangle\)</span>这条权重为-3的环路，因此所有经过这条环路可达的结点e,f,g的最短路径权重为<span class="math inline">\(-\infty\)</span>。</p><p><img src="/uploads/image/introduction-to-algorithms/negative-edge-weights-in-a-directed-graph.png" title="包含权重为负值的环路的有向图"></p></li><li><p>若包含权重为0的环路，那么删除该环路后得到的路径权重与原来的相等。只要一条最短路径上还有权重为0的环路，我们就可以重复删除这些环路，直到得到一条不包含环路的简单路径。</p></li></ul><p>由于图<span class="math inline">\(G=(V,E)\)</span>中的任意无环路径最多包含|V|个不同的结点，到任意结点的最短路径最多包含|V|-1条边。</p><h1 id="最短路径的表示">最短路径的表示</h1><p>通常情况下，我们不但希望计算出最短路径权重，还希望计算出最短路径上的结点。</p><p>给定图<span class="math inline">\(G=(V,E)\)</span>，对于每个结点v，维持一个<strong>前驱结点</strong><span class="math inline">\(v.\pi\)</span>。该前驱结点可能是另一个结点或者NIL。将从结点v开始的前驱结点链反转过来，就是从s到v的一条最短路径。</p><p>我们感兴趣的是由<span class="math inline">\(\pi\)</span>值所诱导的<strong>前驱子图</strong><span class="math inline">\(G_\pi=(V_\pi,E_\pi)\)</span>。定义结点集<span class="math inline">\(V_\pi\)</span>为图G中的前驱结点不为NIL的结点的集合，再加上源节点s，即<span class="math inline">\(V_\pi=\{v\in{V}:v.\pi\neq{NIL}\}\cup\{s\}\)</span>。有向边集合<span class="math inline">\(E_\pi\)</span>是由<span class="math inline">\(V_\pi\)</span>中的结点的<span class="math inline">\(\pi\)</span>值所诱导的边的集合，即<span class="math inline">\(E_\pi=\{(v.\pi,v)\in{E}:v\in{V_\pi-\{s\}}\}\)</span>。</p><p>一个正确的单源最短路径算法：在算法终止时，<span class="math inline">\(G_\pi\)</span>是一棵“最短路径树“。最短路径树是一棵有根节点的树，该树包括了从源节点s到每个可以从s到达的结点的一条最短路径。类似于广度优先搜索中的广度优先树，但它所包括的最短路径是以边的权重来定义的，而不是边的条数。</p><p>需要指出的是，最短路径不一定是唯一的，最短路径树也不一定是唯一的。如下图(a)所示的带权重的有向图中，有(b)和(c)两种最短路径，即存在两棵根节点为s的最短路径树。</p><p><img src="/uploads/image/introduction-to-algorithms/two-shortest-paths-trees-with-the-same-root.png" title="根结点相同的两棵不同的最短路径树"></p><h1 id="松弛操作">松弛操作</h1><p>本文的算法需要使用松弛（relaxation）技术。对于每个结点v来说，维持一个属性v.d，用来记录从源节点s到结点v的最短路径权重的上界。称之为s到v的<strong>最短路径估计</strong>。使用下面运行时间为<span class="math inline">\(\Theta(V)\)</span>的算法来对最短路径估计和前驱结点进行初始化。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INITIALIZE-SINGLE-SOURCE(G, s):</span><br><span class="line">    <span class="keyword">for</span> each vertex v <span class="keyword">in</span> G.V:</span><br><span class="line">        v.d = infinity</span><br><span class="line">        v.pi = NIL</span><br><span class="line">    s.d = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>下面的伪代码给出了对边(u,v)在O(1)时间内进行的松弛操作：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">RELAX(u, v, w)：</span><br><span class="line">    <span class="keyword">if</span> v.d &gt; u.d + w(u, v):</span><br><span class="line">        v.d = u.d + w(u, v)</span><br><span class="line">        v.pi = u</span><br></pre></td></tr></table></figure><p>对一条边的松弛过程为：</p><p>首先测试一下是否可以对从s到v的最短距离进行改善。测试方法是，将从结点s到结点u之间的最短路径距离u.d加上结点u与v之间的边权重w(u, v)，并与当前的s到v的最短路径估计v.d进行比较。如果前者更小，则对v.d和v.pi进行更新。如下图：</p><ol type="a"><li><p>v.d=9; u.d=5; w(u,v)=2，9&gt;5+2，因此v的最短路径估计v.d降低，同时v的前驱结点也要更新为u。称这种情况为松弛成功。</p></li><li><p>6&lt;5+2，因此v.d和v.pi属性都不会变化。称这种情况为松弛失败。</p></li></ol><p><img src="/uploads/image/introduction-to-algorithms/single-source-shortest-path-relax.png" title="松弛成功和松弛失败"></p><h1 id="bellman-ford算法">Bellman-Ford算法</h1><p>Bellman-Ford算法解决的是一般情况下的单源最短路径问题。边的权重可以为负值。算法返回一个布尔值，以表明是否存在一个从源节点可以到达的权重为负值的环路。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BELLMAN-FORD(G, w, s):</span><br><span class="line">    INITIALIZE-SINGLE-SOURCE(G, s)</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to |G.V| - <span class="number">1</span>:        <span class="comment"># 算法对每条边进行|V|-1次处理</span></span><br><span class="line">        <span class="keyword">for</span> each edge(u, v) <span class="keyword">in</span> G.E:</span><br><span class="line">            RELAX(u, v, w)</span><br><span class="line">    <span class="keyword">for</span> each edge(u, v) <span class="keyword">in</span> G.E:    <span class="comment"># 检查是否存在权重为负值的环路</span></span><br><span class="line">        <span class="keyword">if</span> v.d &gt; u.d + w(u, v):</span><br><span class="line">            <span class="keyword">return</span> false           <span class="comment"># 若存在，返回false</span></span><br><span class="line">    <span class="keyword">return</span> true</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-algorithms/execution-of-bellman-ford.png" title="Bellman Ford每次迭代后的结果"></p><p>例如在图(a)所示的带权重的有向图中，按(t,x), (t,y), (t,z), (x,t), (y,x), (y,z), (z,x), (z,s), (s,t), (s,y)的顺序对边执行松弛操作的过程。有向图中有6个顶点，因此需要循环5次。单次循环后的结果分为如图(b)~(e)所示。只有v.d值降低的结点成功松弛。</p><p>边的顺序不会对最终结果产生影响，但若斟酌选择，可以减少松弛失败的次数，从而提高代码的执行效率。在后续的优化中将会提到一种选择方案。</p><h2 id="分析">分析</h2><p>INITIALIZE-SINGLE-SOURCE所需时间为<span class="math inline">\(\Theta(V)\)</span>，内层循环对每条边都执行一次RELAX操作，因此运行时间为<span class="math inline">\(\Theta(E)\)</span>，且一共要进行|V|-1次循环，检测是否存在权重为负值的环路所需时间为O(E)，Bellman-Ford算法的总运行时间为<span class="math inline">\(\Theta(V)+(|V|-1)\Theta(E)+O(E)=O(VE)\)</span>。</p><h2 id="优化">优化</h2><ol type="1"><li><p>提前跳出循环。</p><p>实际操作中，Bellman-Ford算法经常会在未达到|V|-1次前就出解，|V|-1其实是最大值。于是可以在循环中设置判定，在某次循环不再进行松弛时，直接退出循环，进行负权环判定。（若存在负权环，则循环次数一定会达到|V|-1次，因此，若是提前跳出循环，则说明图中没有负权环）</p></li><li><p>队列优化。参考最短路径快速算法。</p><p>松弛操作必定只会发生在最短路径前驱结点松弛成功过的结点上：结点v的所有前驱结点<span class="math inline">\(\{u|(u,v)\in{E}\}\)</span>中，若存在松弛成功（更新了最短路径估计d和前驱结点pi）的结点，则对结点v执行松弛操作RELAX(v, n, w)。</p><p>反过来说，我们应该对哪些结点v执行松弛操作：若结点u成功松弛，则应该对u的所有后继结点<span class="math inline">\(\{v|(u,v)\in{E}\}\)</span>执行松弛操作。</p><p>用一个队列记录松弛过的结点，避免了冗余计算。</p></li></ol><h2 id="代码">代码</h2><p>图用邻接链表的方式存储。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_f</span><span class="params">(graph, result=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> result <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        print(<span class="string">'has negative cycle or not?'</span>, <span class="keyword">not</span> result)</span><br><span class="line">    fmt = <span class="string">'&#123;0:&lt;10s&#125; &#123;1:&lt;10s&#125; &#123;2:&lt;10s&#125;\n'</span></span><br><span class="line">    title = fmt.format(<span class="string">'vertex'</span>, <span class="string">'distance'</span>, <span class="string">'previous'</span>)</span><br><span class="line">    data = <span class="string">''</span>.join(fmt.format(str(k), str(attr[<span class="string">'distance'</span>]), str(attr[<span class="string">'previous'</span>])) <span class="keyword">for</span> k, attr <span class="keyword">in</span> graph.nodes.items())</span><br><span class="line">    print(title + data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_single_source</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    <span class="string">"""初始化单源点"""</span></span><br><span class="line">    <span class="keyword">for</span> attr <span class="keyword">in</span> graph.nodes.values():</span><br><span class="line">        attr[<span class="string">'previous'</span>] = <span class="literal">None</span></span><br><span class="line">        attr[<span class="string">'distance'</span>] = float(<span class="string">'inf'</span>)</span><br><span class="line">    graph.nodes[s][<span class="string">'distance'</span>] = <span class="number">0</span>  <span class="comment"># 源点距离初始为0，其他为无穷远</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relax</span><span class="params">(graph, u, v, w)</span>:</span></span><br><span class="line">    <span class="string">"""relax操作，distance的值只在此处发生改变"""</span></span><br><span class="line">    u_attr, v_attr = graph.nodes[u], graph.nodes[v]</span><br><span class="line">    <span class="keyword">if</span> v_attr[<span class="string">'distance'</span>] &gt; u_attr[<span class="string">'distance'</span>] + w:</span><br><span class="line">        v_attr[<span class="string">'distance'</span>] = u_attr[<span class="string">'distance'</span>] + w  <span class="comment"># 更新最短距离</span></span><br><span class="line">        v_attr[<span class="string">'previous'</span>] = u  <span class="comment"># 更新前驱结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detect_negative_cycle</span><span class="params">(graph)</span>:</span></span><br><span class="line">    <span class="string">"""检测图g中是否包含负权环路"""</span></span><br><span class="line">    <span class="keyword">for</span> u, v, w <span class="keyword">in</span> graph.edges.data(<span class="string">'weight'</span>):</span><br><span class="line">        <span class="keyword">if</span> graph.nodes[v][<span class="string">'distance'</span>] &gt; graph.nodes[u][<span class="string">'distance'</span>] + w:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bellman_ford</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    <span class="string">"""Bellman Ford算法，同时判断是否存在权重为负值的环路"""</span></span><br><span class="line">    initialize_single_source(graph, s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(graph.number_of_nodes() - <span class="number">1</span>):  <span class="comment"># 重复|V|-1遍</span></span><br><span class="line">        <span class="keyword">for</span> u, v, w <span class="keyword">in</span> graph.edges.data(<span class="string">'weight'</span>):  <span class="comment"># 对每条边执行一次relax</span></span><br><span class="line">            relax(graph, u, v, w)</span><br><span class="line">    <span class="keyword">return</span> detect_negative_cycle(graph)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bellman_ford_op_1</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    <span class="string">"""优化方案1：提前跳出循环"""</span></span><br><span class="line">    initialize_single_source(graph, s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(graph.number_of_nodes() - <span class="number">1</span>):</span><br><span class="line">        relaxed = <span class="literal">False</span>  <span class="comment"># 一次循环开始前，标志位置为0</span></span><br><span class="line">        <span class="keyword">for</span> u, v, w <span class="keyword">in</span> graph.edges.data(<span class="string">'weight'</span>):</span><br><span class="line">            <span class="keyword">if</span> relax(graph, u, v, w) <span class="keyword">is</span> <span class="literal">True</span>:  <span class="comment"># 若松弛成功，标志位置为1</span></span><br><span class="line">                relaxed = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> relaxed <span class="keyword">is</span> <span class="literal">False</span>:  <span class="comment"># 提前跳出循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 若完整执行了|V|-1次循环，则去判断是否包含负权环</span></span><br><span class="line">        <span class="keyword">return</span> detect_negative_cycle(graph)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bellman_ford_op_2</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    <span class="string">"""队列优化"""</span></span><br><span class="line">    initialize_single_source(graph, s)</span><br><span class="line">    q = Queue()</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> graph.edges:</span><br><span class="line">        graph[u][v][<span class="string">'__times__'</span>] = <span class="number">0</span>  <span class="comment"># 记录松弛次数（不论结果），当超过|V|-1次时，说明图中包含负权环</span></span><br><span class="line">    q.put(s)  <span class="comment"># 初始放入源点</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">        u = q.get()</span><br><span class="line">        <span class="keyword">for</span> v, attr <span class="keyword">in</span> graph[u].items():  <span class="comment"># 遍历邻接边</span></span><br><span class="line">            <span class="keyword">if</span> relax(graph, u, v, attr[<span class="string">'weight'</span>]) <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">                q.put(v)  <span class="comment"># 将松弛成功过的结点放入队列</span></span><br><span class="line">                graph[u][v][<span class="string">'__times__'</span>] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> graph[u][v][<span class="string">'__times__'</span>] &gt; graph.number_of_nodes() - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># Bellman-Ford示例</span></span><br><span class="line">    g = nx.DiGraph()</span><br><span class="line">    g.add_nodes_from(<span class="string">'stxyz'</span>)</span><br><span class="line">    edges = [(<span class="string">'s'</span>, <span class="string">'t'</span>, <span class="number">6</span>), (<span class="string">'s'</span>, <span class="string">'y'</span>, <span class="number">7</span>), (<span class="string">'t'</span>, <span class="string">'x'</span>, <span class="number">5</span>), (<span class="string">'t'</span>, <span class="string">'y'</span>, <span class="number">8</span>), (<span class="string">'t'</span>, <span class="string">'z'</span>, <span class="number">-4</span>), (<span class="string">'x'</span>, <span class="string">'t'</span>, <span class="number">-2</span>), (<span class="string">'y'</span>, <span class="string">'x'</span>, <span class="number">-3</span>),</span><br><span class="line">             (<span class="string">'y'</span>, <span class="string">'z'</span>, <span class="number">9</span>), (<span class="string">'z'</span>, <span class="string">'s'</span>, <span class="number">2</span>), (<span class="string">'z'</span>, <span class="string">'x'</span>, <span class="number">7</span>)]</span><br><span class="line">    g.add_weighted_edges_from(edges)</span><br><span class="line">    r = bellman_ford(g, <span class="string">'s'</span>)</span><br><span class="line">    print_f(g, r)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 一个带有负权环路的示例</span></span><br><span class="line">    g.clear()</span><br><span class="line">    g.add_nodes_from(<span class="string">'s1234t'</span>)</span><br><span class="line">    edges = [(<span class="string">'s'</span>, <span class="string">'1'</span>, <span class="number">1</span>), (<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="number">1</span>), (<span class="string">'2'</span>, <span class="string">'1'</span>, <span class="number">-2</span>), (<span class="string">'1'</span>, <span class="string">'3'</span>, <span class="number">1</span>), (<span class="string">'3'</span>, <span class="string">'4'</span>, <span class="number">-4</span>), (<span class="string">'4'</span>, <span class="string">'1'</span>, <span class="number">1</span>), (<span class="string">'4'</span>, <span class="string">'t'</span>, <span class="number">1</span>)]</span><br><span class="line">    g.add_weighted_edges_from(edges)</span><br><span class="line">    r = bellman_ford_op_2(g, <span class="string">'s'</span>)</span><br><span class="line">    print_f(g, r)</span><br><span class="line"></span><br><span class="line">    g.clear()</span><br><span class="line">    g.add_nodes_from(<span class="string">'s1234t'</span>)</span><br><span class="line">    edges = [(<span class="string">'s'</span>, <span class="string">'1'</span>, <span class="number">3</span>), (<span class="string">'1'</span>, <span class="string">'s'</span>, <span class="number">-3</span>), (<span class="string">'s'</span>, <span class="string">'2'</span>, <span class="number">4</span>), (<span class="string">'2'</span>, <span class="string">'s'</span>, <span class="number">-4</span>), (<span class="string">'2'</span>, <span class="string">'1'</span>, <span class="number">3</span>), (<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="number">-3</span>), (<span class="string">'1'</span>, <span class="string">'3'</span>, <span class="number">7</span>),</span><br><span class="line">             (<span class="string">'3'</span>, <span class="string">'1'</span>, <span class="number">-7</span>), (<span class="string">'3'</span>, <span class="string">'2'</span>, <span class="number">5</span>), (<span class="string">'2'</span>, <span class="string">'4'</span>, <span class="number">6</span>), (<span class="string">'4'</span>, <span class="string">'2'</span>, <span class="number">-6</span>), (<span class="string">'3'</span>, <span class="string">'4'</span>, <span class="number">-8</span>), (<span class="string">'3'</span>, <span class="string">'t'</span>, <span class="number">6</span>),</span><br><span class="line">             (<span class="string">'t'</span>, <span class="string">'3'</span>, <span class="number">-6</span>), (<span class="string">'4'</span>, <span class="string">'t'</span>, <span class="number">9</span>), (<span class="string">'t'</span>, <span class="string">'4'</span>, <span class="number">-9</span>)]</span><br><span class="line">    g.add_weighted_edges_from(edges)</span><br><span class="line">    r = bellman_ford_op_1(g, <span class="string">'s'</span>)</span><br><span class="line">    print_f(g, r)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">has negative cycle or not? False</span><br><span class="line">vertex     distance   previous  </span><br><span class="line">s          0          None</span><br><span class="line">t          2          x</span><br><span class="line">x          4          y</span><br><span class="line">y          7          s</span><br><span class="line">z          -2         t</span><br><span class="line"></span><br><span class="line">has negative cycle or not? True</span><br><span class="line">vertex     distance   previous  </span><br><span class="line">s          0          None</span><br><span class="line">1          -4         4</span><br><span class="line">2          -3         1</span><br><span class="line">3          -2         1</span><br><span class="line">4          -6         3</span><br><span class="line">t          -4         4</span><br><span class="line"></span><br><span class="line">has negative cycle or not? True</span><br><span class="line">vertex     distance   previous  </span><br><span class="line">s          -23        2</span><br><span class="line">1          -17        3</span><br><span class="line">2          -24        4</span><br><span class="line">3          -15        t</span><br><span class="line">4          -18        3</span><br><span class="line">t          -9         4</span><br></pre></td></tr></table></figure><h1 id="dijkstra算法">Dijkstra算法</h1><p>Dijkstra算法是另一个解决单源最短路径问题的算法，该要求所有边的权重都为非负值。</p><p>Dijkstra算法在运行过程中维持的关键信息是一组结点集合S。从源节点s到该集合中每个结点之间的最短距离已经被找到。算法重复从结点集V-S中选择<strong>最短路径估计最小</strong>的结点u，将u加入到集合S，然后对所有从u发出的边进行松弛（对于边<span class="math inline">\((u,v),v\in{S}\)</span>是没有松弛的必要的，即使对之松弛，松弛一定不会成功，因为s到v的最短距离已经求出）。因为算法总是选择集合V-S中最近的结点来加入到集合S中，该算法使用的是贪心策略。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DIJKSTRA(G, w, s):</span><br><span class="line">    INITIALIZE-SINGLE-SOURCE(G, s)</span><br><span class="line">    S = empty set           <span class="comment"># 到源点s的最短距离被找到的结点集，伪代码中体现的作用不大</span></span><br><span class="line">    Q = G.V                 <span class="comment"># 初始时将所有结点放入优先队列</span></span><br><span class="line">    <span class="keyword">while</span> Q <span class="keyword">not</span> empty:</span><br><span class="line">        u = EXTRACT-MIN(Q)  <span class="comment"># 选择最短路径估计最小的结点</span></span><br><span class="line">        S = S + &#123;u&#125;         <span class="comment"># 将u加入集合S</span></span><br><span class="line">        <span class="keyword">for</span> each vertex v <span class="keyword">in</span> G.Adj[u]:     <span class="comment"># 松弛所有从u发出的边</span></span><br><span class="line">            RELAX(u, v, w)  <span class="comment"># 如果松弛成功，还要改变优先队列中结点v的减值</span></span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-algorithms/execution-of-dijkstra.png" title="Dijkstra每次迭代后的结果"></p><p>在一个结点个数为5的带权重的有向图上执行Dijkstra算法的过程如上图。</p><p>(a)~(e) 为每次while循环开始时，灰色结点为最短路径估计最小的结点。白色结点属于集合V-S。</p><p>(b)~(f) 为每次for循环结束后，阴影的边描述了前驱节点。黑色的结点属于集合S。图(f)就是最终结果。</p><h2 id="分析-1">分析</h2><p>首先分析算法的循环次数。算法调用1次INITIALIZE-SINGLE-SOURCE操作和1次初始化优先队列操作Q=G.V。之后的while循环执行次数为|V|次，因为每次循环都从最小优先队列Q中提取一个结点。因此，EXTRACT-MIN也执行了|V|次。内层的for循环对从结点u发出的边执行一次松弛操作，而在while循环过程中，u取到了图中所有的结点且各取到一次。因此for循环实际上对图中所有的边执行了1次松弛操作，即RELAX操作的执行次数为|E|。暗含在其中的降低键值DECREASE-KEY操作也执行了|E|次。</p><p>如何实现算法中的优先队列直接影响到算法的时间复杂度。在此列出3中实现下的时间复杂度分析。</p><table><thead><tr class="header"><th>实现方式</th><th>初始化代价*1</th><th>提取最小值代价*V</th><th>降低键值代价*E</th><th>Dijkstra算法总代价</th></tr></thead><tbody><tr class="odd"><td>数组</td><td><span class="math inline">\(O(V)\)</span></td><td><span class="math inline">\(O(V)\)</span>，搜索整个数组</td><td><span class="math inline">\(O(1)\)</span></td><td><span class="math inline">\(O(V^2+E)=O(V^2)\)</span></td></tr><tr class="even"><td>二叉堆</td><td><span class="math inline">\(O(V)\)</span></td><td><span class="math inline">\(O(\lg{V})\)</span>，调整队</td><td><span class="math inline">\(O(\lg{V})\)</span>，调整堆</td><td><span class="math inline">\(O((V+E)\lg{V})\)</span></td></tr><tr class="odd"><td>斐波那契堆</td><td><span class="math inline">\(O(V)\)</span></td><td><span class="math inline">\(O(\lg{V})\)</span>，摊还代价</td><td><span class="math inline">\(O(1)\)</span>，摊还代价</td><td><span class="math inline">\(O(V\lg{V}+E)\)</span></td></tr></tbody></table><p>若所有结点都可以从源节点到达（|V|&lt;|E|），则<span class="math inline">\(O((V+E)\lg{V})=O(E\lg{V})\)</span>。对于稀疏图，特别地，如果<span class="math inline">\(E=o(V^2/\lg{V})\)</span>，则使用二叉堆实现最小优先队列相对于用数组直接实现的<span class="math inline">\(O(V^2)\)</span>代价有改善。</p><p>Dijkstra算法与广度优先搜索算法及计算最小生成树的Prim算法的相似点：</p><ul><li>与广度优先搜索算法：集合S对应的是广度优先搜索中的黑色结点集合：正如集合S中的结点的最短路径权重已经计算出来一样，在广度优先搜索中，黑色结点的正确广度优先距离也已经计算出来。</li><li>与Prim算法：两个算法都使用最小优先队列来寻找集合之外“最轻”结点，将该节点加入到集合里，并对位于集合外面的结点的权重进行相应调整。</li></ul><h2 id="代码-1">代码</h2><p>使用内建的优先队列时的妥协：</p><p>因为无法改变优先队列中的键值（或者说改变了也没有意义，优先队列不会调整结点在队列中的先后顺序），所以在初始时<span class="math inline">\(Q\neq{G.V}\)</span>，而是只将源点s放入优先队列。之后在松弛过程中，若发现集合S中不存在的结点，再将之放入优先队列。</p><p>但这也随之产生了一个问题：多条不同的边可能指向同一个集合S外的结点u，当这些边成功松弛多次时，结点u被多次加入队列中（因为内建的优先队列没有提供DECREASE-KEY操作，只能通过重复放入的方式更新键值）。这些重复加入的结点u携带不同的键值，显然，因最近一次松弛成功而被加入队列的结点u携带最小的键值。携带较大键值的结点u对算法没有意义，但它们仍然存在于队列中。因此，在循环开始时对取得的结点进行判断：若u结点在visit集合中，说明源结点s到u的最短距离已经求出，跳过这样的结点。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue</span><br><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"><span class="keyword">from</span> graph.bellman_ford <span class="keyword">import</span> initialize_single_source, relax, print_f</span><br><span class="line"><span class="keyword">from</span> data_structure.fib_heap <span class="keyword">import</span> FibHeap, Node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dijkstra_queue</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    <span class="string">"""使用优先队列"""</span></span><br><span class="line">    initialize_single_source(graph, s)</span><br><span class="line">    visit, q = set(), PriorityQueue()  <span class="comment"># visit：集合S</span></span><br><span class="line">    q.put((graph.nodes[s][<span class="string">'distance'</span>], s))  <span class="comment"># 初始时s入队列</span></span><br><span class="line">    <span class="keyword">while</span> q.empty() <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">        u = q.get()[<span class="number">1</span>]  <span class="comment"># 选择最近的节点u</span></span><br><span class="line">        <span class="keyword">if</span> u <span class="keyword">not</span> <span class="keyword">in</span> visit:</span><br><span class="line">            visit.add(u)</span><br><span class="line">            <span class="keyword">for</span> v, e_attr <span class="keyword">in</span> graph[u].items():</span><br><span class="line">                <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> visit:  <span class="comment"># 已经访问过的顶点无需入队列</span></span><br><span class="line">                    relax(graph, u, v, e_attr[<span class="string">'weight'</span>])  <span class="comment"># relax最近顶点u的临界点</span></span><br><span class="line">                    q.put((graph.nodes[v][<span class="string">'distance'</span>], v))  <span class="comment"># 临接顶点入队列，同一顶点可能带有不同的distance值多次入队列</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dijkstra_fibonacci</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    <span class="string">"""使用斐波那契堆优化算法"""</span></span><br><span class="line">    initialize_single_source(graph, s)</span><br><span class="line">    m, visit, heap = &#123;&#125;, set(), FibHeap()  <span class="comment"># m：顶点到堆中结点的映射&#123;v.key:Node&#125;</span></span><br><span class="line">    <span class="keyword">for</span> v, v_attr <span class="keyword">in</span> graph.nodes.items():  <span class="comment"># 所有顶点入堆</span></span><br><span class="line">        n = Node(v_attr[<span class="string">'distance'</span>])</span><br><span class="line">        n.v = v  <span class="comment"># 为fibonacci node添加属性v，记录指向顶点的指针</span></span><br><span class="line">        heap.insert(n)</span><br><span class="line">        m[v] = n</span><br><span class="line">    <span class="keyword">while</span> heap.n &gt; <span class="number">0</span>:  <span class="comment"># 实际上循环|V|-1次，等价于for i in range(len(g.get_v_set()))</span></span><br><span class="line">        u = heap.pop().v  <span class="comment"># 选择最近的节点u</span></span><br><span class="line">        visit.add(u)</span><br><span class="line">        <span class="keyword">for</span> v, e_attr <span class="keyword">in</span> graph[u].items():</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> visit:</span><br><span class="line">                relax(graph, u, v, e_attr[<span class="string">'weight'</span>])</span><br><span class="line">                heap.decrease_key(m[v], graph.nodes[v][<span class="string">'distance'</span>])  <span class="comment"># 修改heap中对应节点的key值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># Dijkstra示例</span></span><br><span class="line">    g = nx.DiGraph()</span><br><span class="line">    g.add_nodes_from(<span class="string">'s12345t'</span>)</span><br><span class="line">    edges = [(<span class="string">'s'</span>, <span class="string">'1'</span>, <span class="number">2</span>), (<span class="string">'s'</span>, <span class="string">'2'</span>, <span class="number">3</span>), (<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="number">4</span>), (<span class="string">'1'</span>, <span class="string">'3'</span>, <span class="number">8</span>), (<span class="string">'1'</span>, <span class="string">'4'</span>, <span class="number">5</span>), (<span class="string">'2'</span>, <span class="string">'4'</span>, <span class="number">3</span>), (<span class="string">'2'</span>, <span class="string">'5'</span>, <span class="number">4</span>),</span><br><span class="line">             (<span class="string">'3'</span>, <span class="string">'4'</span>, <span class="number">2</span>), (<span class="string">'3'</span>, <span class="string">'t'</span>, <span class="number">9</span>), (<span class="string">'4'</span>, <span class="string">'t'</span>, <span class="number">6</span>), (<span class="string">'5'</span>, <span class="string">'t'</span>, <span class="number">10</span>)]</span><br><span class="line">    g.add_weighted_edges_from(edges)</span><br><span class="line">    dijkstra_queue(g, <span class="string">'s'</span>)</span><br><span class="line">    print_f(g)</span><br><span class="line"></span><br><span class="line">    g.clear()</span><br><span class="line">    g.add_nodes_from(<span class="string">'stxyz'</span>)</span><br><span class="line">    edges = [(<span class="string">'s'</span>, <span class="string">'t'</span>, <span class="number">10</span>), (<span class="string">'s'</span>, <span class="string">'y'</span>, <span class="number">5</span>), (<span class="string">'t'</span>, <span class="string">'x'</span>, <span class="number">1</span>), (<span class="string">'t'</span>, <span class="string">'y'</span>, <span class="number">2</span>), (<span class="string">'x'</span>, <span class="string">'z'</span>, <span class="number">4</span>), (<span class="string">'y'</span>, <span class="string">'t'</span>, <span class="number">3</span>), (<span class="string">'y'</span>, <span class="string">'x'</span>, <span class="number">9</span>),</span><br><span class="line">             (<span class="string">'y'</span>, <span class="string">'z'</span>, <span class="number">2</span>), (<span class="string">'z'</span>, <span class="string">'s'</span>, <span class="number">7</span>), (<span class="string">'z'</span>, <span class="string">'x'</span>, <span class="number">6</span>)]</span><br><span class="line">    g.add_weighted_edges_from(edges)</span><br><span class="line">    dijkstra_fibonacci(g, <span class="string">'s'</span>)</span><br><span class="line">    print_f(g)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vertex     distance   previous  </span><br><span class="line">s          0          None</span><br><span class="line">1          2          s</span><br><span class="line">2          3          s</span><br><span class="line">3          10         1</span><br><span class="line">4          6          2</span><br><span class="line">5          7          2</span><br><span class="line">t          12         4</span><br><span class="line"></span><br><span class="line">vertex     distance   previous  </span><br><span class="line">s          0          None</span><br><span class="line">t          8          y</span><br><span class="line">x          9          t</span><br><span class="line">y          5          s</span><br><span class="line">z          7          y</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Algorithms </tag>
            
            <tag> algorithms </tag>
            
            <tag> fibonacci heap </tag>
            
            <tag> greedy method </tag>
            
            <tag> priority queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树</title>
      <link href="/notes/introduction-to-algorithms/binary-search-trees/"/>
      <url>/notes/introduction-to-algorithms/binary-search-trees/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉搜索树">二叉搜索树</h1><p>一棵二叉搜索树是以一棵二叉树来组织的。每个结点除了key之外，还包含属性left、right、p，分别指向结点的左孩子、右孩子和父节点。如果父节点或者子节点不存在，则相应属性值为NIL。根节点是唯一父节点为NIL的结点。</p><h1 id="性质">性质</h1><p>二叉搜索树性质：</p><p>设x是二叉搜索树中的一个结点。如果y是x左子树中的一个结点，那么<span class="math inline">\(y.key\le{x.key}\)</span>。如果y是x右子树中的一个结点，那么<span class="math inline">\(y.key\ge{x.key}\)</span>。</p><p>根据此性质，可以通过中序遍历（inorder tree walk）算法按序输出二叉搜索树中的所有关键字。比较简单的递归实现如下：</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INORDER-TREE-WALK(x):</span><br><span class="line">    <span class="keyword">if</span> x != NIL:</span><br><span class="line">        INORDER-TREE-WALK(x.left)</span><br><span class="line">        <span class="keyword">print</span> x.key</span><br><span class="line">        INORDER-TREE-WALK(x.right)</span><br></pre></td></tr></table></figure><p>包含相同结点的两棵高度不同的二叉搜索树。大部分搜索树操作的运行时间与树的高度成正比。因此(b)比(a)低效。</p><p><img src="/uploads/image/introduction-to-algorithms/binary-search-trees.png" title="二叉搜索树"></p><h1 id="操作">操作</h1><h2 id="查找">查找</h2><p>使用下面的过程在一棵二叉搜索树中查找一个具有给定关键字的结点。输入一个指向树根的指针x和一个关键字k，如果这个结点存在，返回一个指向关键字为k的结点的指针；否则返回NIL。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">TREE-SEARCH(x, k):</span><br><span class="line">    <span class="keyword">if</span> x == NIL <span class="keyword">or</span> k == x.key:  <span class="comment"># 如果关键字与k相等，返回结果</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">if</span> k &lt; x.key:               <span class="comment"># 如果关键字大于k，查找在左子树中继续</span></span><br><span class="line">        <span class="keyword">return</span> TREE-SEARCH(x.left, k)   <span class="comment"># 递归</span></span><br><span class="line">    <span class="keyword">else</span>:                       <span class="comment"># 如果关键字小于k，查找在右子树中继续</span></span><br><span class="line">        <span class="keyword">return</span> TREE-SEARCH(x.right, k)</span><br></pre></td></tr></table></figure><p>可以采用循环来展开递归，用一种迭代方式重写此过程。对于大多数计算机，迭代版本的效率要高得多。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ITERATIVE-TREE-SEARCH(x, k):</span><br><span class="line">    <span class="keyword">while</span> x != NIL <span class="keyword">and</span> k != x.key:  <span class="comment"># 迭代实现：如果关键字与k不相等，重复循环</span></span><br><span class="line">        <span class="keyword">if</span> k &lt; x.key:               <span class="comment"># 如果关键字大于k，查找在左子树中继续</span></span><br><span class="line">            x = x.left</span><br><span class="line">        <span class="keyword">else</span>:                       <span class="comment"># 否则，在右子树中继续</span></span><br><span class="line">            x = x.right</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-algorithms/binary-search-tree-search.png" title="搜索键值等于13的结点"></p><p>例如在如上图所示的二叉查找树中查找键值为13的查找路径是<span class="math inline">\(15\rightarrow6\rightarrow7\rightarrow13\)</span>。具体步骤为：</p><ol type="1"><li>x指向根节点，比较x与13。13&lt;15：x指向x.left，在左子树中继续查找。</li><li>13&gt;6：x指向x.right，在右子树中继续查找。</li><li>13&gt;7：x指向x.right，在右子树中继续查找。</li><li>13=13：返回x。</li></ol><h3 id="最大和最小关键字">最大和最小关键字</h3><p>查找最小关键字元素：从根开始沿着left孩子指针直到遇到一个NIL。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">TREE-MINIMUM(X):</span><br><span class="line">    <span class="keyword">while</span> x.left != NIL:  <span class="comment"># 假设x != NIL，不停查找左子树</span></span><br><span class="line">        x = x.left</span><br><span class="line">    <span class="keyword">return</span> x              <span class="comment"># 当x的左子树为NIL时，x为最小关键字元素</span></span><br></pre></td></tr></table></figure><p>查找最大关键字的TREE-MAXIMUM的伪代码是对称的，如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">TREE-MAXIMUM(x):</span><br><span class="line">    <span class="keyword">while</span> x.right != NIL:</span><br><span class="line">        x = x.right</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h3 id="后继和前驱">后继和前驱</h3><p>给定一棵二叉搜索树中的一个结点，有时候需要按中序遍历的次序查找它的后继。如果所有的关键字互不相同，则一个结点x的<strong>后继</strong>是大于x.key的最小关键字的结点。二叉搜索树的性质允许我们通过没有任何关键字的比较来确定一个结点的后继。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">TREE-SUCCESSOR(x):</span><br><span class="line">    <span class="keyword">if</span> x.right != NIL:  <span class="comment"># 如果x的右子树不为空，根据性质，右子树中的关键字均大于x的关键字</span></span><br><span class="line">        <span class="keyword">return</span> TREE-MINIMUM(x.right)  <span class="comment"># 此时x的后继为右子树中最小的结点</span></span><br><span class="line">    y = x.p  <span class="comment"># 如果右子树为空，那么x的后继是 x的有左孩子的最底层祖先（回想中序遍历次序）</span></span><br><span class="line">    <span class="keyword">while</span> y != NIL <span class="keyword">and</span> x == y.right:</span><br><span class="line">        x = y</span><br><span class="line">        y = y.p</span><br><span class="line">    <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><p>查找<strong>前驱</strong>的TREE-PREDECESSOR的伪代码是对称的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">TREE-PREDECESSOR(x):</span><br><span class="line">    <span class="keyword">if</span> x.left != NIL:</span><br><span class="line">        <span class="keyword">return</span> TREE-MAXIMUM(x.left)</span><br><span class="line">    y = x.p</span><br><span class="line">    <span class="keyword">while</span> y != NIL <span class="keyword">and</span> x == y.left:</span><br><span class="line">        x = y</span><br><span class="line">        y = y.p</span><br><span class="line">    <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><h2 id="插入和删除">插入和删除</h2><p>插入和删除操作会引起由二叉搜索树表示的动态集合的变化（二叉搜索树中的元素集合会变化）。一定要修改指针以保持二叉搜索树性质的成立。</p><h3 id="插入">插入</h3><p>插入操作相对简单些。将结点z插入到树中的相应位置上，这个过程要修改T和z的某些属性。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">TREE-INSERT(T, z):</span><br><span class="line">    y = NIL</span><br><span class="line">    x = T.root            <span class="comment"># 找到z在树中的位置</span></span><br><span class="line">    <span class="keyword">while</span> x != NIL:</span><br><span class="line">        y = x</span><br><span class="line">        <span class="keyword">if</span> z.key &lt; x.key:</span><br><span class="line">            x = x.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x = x.right</span><br><span class="line">    z.p = y               <span class="comment"># 找到z的位置时，y为z在树中的父节点</span></span><br><span class="line">    <span class="keyword">if</span> y == NIL:          <span class="comment"># 如果父节点为NIL，说明在插入前二叉搜索树是空的</span></span><br><span class="line">        T.root = z</span><br><span class="line">    <span class="keyword">elif</span> z.key &lt; y.key:   <span class="comment"># 判断z与父节点y的大小关系，决定z称为左孩子还是右孩子</span></span><br><span class="line">        y.left = z</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        y.right = z</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-algorithms/binary-search-tree-insert.png" title="插入一个键值等于13的新结点"></p><p>例如在如上图所示的二叉查找树中插入键值为13的结点。步骤为：</p><ol type="1"><li>x指向根节点。比较x的键值与欲插入的键值13的大小关系：12&lt;13：x指向x.right。意味着，结点13应该在根节点的右子树中。</li><li>x.key=18，18&gt;13：x指向x.left。</li><li>x.key=15，15&gt;13：x指向x.left。</li><li>x=NIL，x就是结点13应该插入的位置。修改相应指针完成插入操作。</li></ol><h3 id="删除">删除</h3><p>从一棵二叉搜索树T中删除一个结点z时需要考虑三种基本情况。</p><ul><li>如果z没有孩子结点。</li><li>如果z只有一个孩子。</li><li>如果z既有左孩子又有右孩子。</li></ul><p>在具体的删除操作中，则需要考虑4中情况，它与上面的三种情况有些不同。</p><ul><li><ol type="a"><li>若z的左孩子为空，那么用其右孩子来替换z，这个右孩子可以是NIL。为NIL时对应上面的第一种情况；不为NIL时对应第二种情况。</li></ol></li><li><ol start="2" type="a"><li>若z的右孩子为空，那么用其左孩子来替换z。</li></ol><p>否则，z既有左孩子又有右孩子。需要查找z的后继节点y（这个后继位于z的右子树中并且没有左孩子）。</p></li><li><ol start="3" type="a"><li>若y是z的右孩子，那么用y替换z，并仅留下y的右孩子。</li></ol></li><li><ol start="4" type="a"><li>若y位于z的右子树中但并不是z的右孩子。在这种情况下，先用y的右孩子替换y，然后再用y替换z。</li></ol></li></ul><p><img src="/uploads/image/introduction-to-algorithms/binary-search-tree-delete.png" title="删除结点的4种情况"></p><p>为了在二叉搜索树内移动子树，定义一个子过程TRANSPLANT。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">TRANSPLANT(T, u, v):        <span class="comment"># 用根节点为v的子树替换根节点为u的子树</span></span><br><span class="line">    <span class="keyword">if</span> u.p == NIL:          <span class="comment"># 若u为根节点，则子树的替换实际上就是整棵树的替换</span></span><br><span class="line">        T.root = v          <span class="comment"># 因而，只需修改树的root属性</span></span><br><span class="line">    <span class="keyword">elif</span> u == u.p.left:     <span class="comment"># 若u是左孩子</span></span><br><span class="line">        u.p.left = v        <span class="comment"># 修改父节点左孩子指针</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        u.p.right = v       <span class="comment"># 否则修改右孩子指针</span></span><br><span class="line">    <span class="keyword">if</span> v != NIL:            <span class="comment"># 若v不为空，修改v的父节点指针</span></span><br><span class="line">        v.p = u.p</span><br></pre></td></tr></table></figure><p>注意到，TRANSPLANT并没有处理v.left和v.right的更新，这些更新都由TRANSPLANT的调用者来负责。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">TREE-DELETE(T, z):</span><br><span class="line">    <span class="keyword">if</span> z.left == NIL:                  <span class="comment"># 情况(a)：左孩子为空</span></span><br><span class="line">        TRANSPLANT(T, z, z.right)      <span class="comment"># 用右孩子替换</span></span><br><span class="line">    <span class="keyword">elif</span> z.right == NIL:               <span class="comment"># 情况(b):右孩子为空</span></span><br><span class="line">        TRANSPLANT(T, z, z.left)       <span class="comment"># 用左孩子替换</span></span><br><span class="line">    <span class="keyword">else</span>:                              <span class="comment"># 既有左孩子又有右孩子</span></span><br><span class="line">        y = TREE-MINIMUM(z.right)      <span class="comment"># 查找z的后继y</span></span><br><span class="line">        <span class="keyword">if</span> y.p != z:                   <span class="comment"># 情况(d)：如果y不是z的右孩子</span></span><br><span class="line">            TRANSPLANT(T, y, y.right)  <span class="comment"># 用y的右孩子替换y</span></span><br><span class="line">            y.right = z.right          <span class="comment"># 修改y的右孩子指针</span></span><br><span class="line">            y.right.p = y              <span class="comment"># 将原来z的孩子结点的父节点指针指向y</span></span><br><span class="line">        TRANSPLANT(T, z, y)            <span class="comment"># 情况(c)：y是z的子节点，用y替换z，也是(d)的第二步替换</span></span><br><span class="line">        y.left = z.left                <span class="comment"># 修改y的指针属性</span></span><br><span class="line">        y.left.p = y</span><br></pre></td></tr></table></figure><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> data_structure.binary_tree <span class="keyword">import</span> BinaryTree, Node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span><span class="params">(BinaryTree)</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(x, k)</span>:</span></span><br><span class="line">        <span class="string">"""在根节点为x的子树中迭代查找键值为k的结点"""</span></span><br><span class="line">        <span class="keyword">while</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> k != x.key:</span><br><span class="line">            <span class="keyword">if</span> k &lt; x.key:</span><br><span class="line">                x = x.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x = x.right</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimum</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="string">"""返回以x为根节点的子树中键值最小的结点，x为空时返回None"""</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">while</span> x.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                x = x.left</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximum</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="string">""""返回子树中键值最大的结点"""</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">while</span> x.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                x = x.right</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">successor</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""返回结点x的后继结点"""</span></span><br><span class="line">        <span class="keyword">if</span> x.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self.minimum(x.right)</span><br><span class="line">        y = x.p</span><br><span class="line">        <span class="keyword">while</span> y <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> x == y.right:</span><br><span class="line">            x, y = y, y.p</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predecessor</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""返回前驱"""</span></span><br><span class="line">        <span class="keyword">if</span> x.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self.maximum(x.left)</span><br><span class="line">        y = x.p</span><br><span class="line">        <span class="keyword">while</span> y <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> x == y.left:</span><br><span class="line">            x, y = y, y.p</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, z)</span>:</span></span><br><span class="line">        <span class="string">"""插入结点z"""</span></span><br><span class="line">        y, x = <span class="literal">None</span>, self.root</span><br><span class="line">        <span class="keyword">while</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            y = x</span><br><span class="line">            <span class="keyword">if</span> z.key &lt; x.key:</span><br><span class="line">                x = x.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x = x.right</span><br><span class="line">        z.p = y</span><br><span class="line">        <span class="keyword">if</span> y <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.root = z</span><br><span class="line">        <span class="keyword">elif</span> z.key &lt; y.key:</span><br><span class="line">            y.left = z</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            y.right = z</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transplant</span><span class="params">(self, u, v)</span>:</span></span><br><span class="line">        <span class="string">"""用v替换u"""</span></span><br><span class="line">        <span class="keyword">if</span> u.p <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.root = v</span><br><span class="line">        <span class="keyword">elif</span> u == u.p.left:</span><br><span class="line">            u.p.left = v</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            u.p.right = v</span><br><span class="line">        <span class="keyword">if</span> v <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            v.p = u.p</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, z)</span>:</span></span><br><span class="line">        <span class="string">"""删除结点z"""</span></span><br><span class="line">        <span class="keyword">if</span> z.left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.transplant(z, z.right)</span><br><span class="line">        <span class="keyword">elif</span> z.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.transplant(z, z.left)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            y = self.minimum(z.right)</span><br><span class="line">            <span class="keyword">if</span> y.p != z:</span><br><span class="line">                self.transplant(y, y.right)</span><br><span class="line">                y.right, y.right.p = z.right, y</span><br><span class="line">            self.transplant(z, y)</span><br><span class="line">            y.left, y.left.p = z.left, y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    key = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">18</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">15</span>, <span class="number">19</span>, <span class="number">17</span>, <span class="number">3</span>, <span class="number">21</span>]</span><br><span class="line">    n = &#123;i: Node(i) <span class="keyword">for</span> i <span class="keyword">in</span> key&#125;</span><br><span class="line">    bst = BinarySearchTree()</span><br><span class="line">    [bst.insert(n[i]) <span class="keyword">for</span> i <span class="keyword">in</span> key]</span><br><span class="line">    print(<span class="string">'初始    '</span>, bst)</span><br><span class="line">    print(<span class="string">'查找 8  '</span>, bst.search(bst.root, <span class="number">8</span>))  <span class="comment"># 在整棵树中搜索</span></span><br><span class="line">    print(<span class="string">'查找 9  '</span>, bst.search(bst.root, <span class="number">9</span>))</span><br><span class="line">    print(<span class="string">'12的前驱'</span>, bst.predecessor(n[<span class="number">12</span>]))  <span class="comment"># 前驱</span></span><br><span class="line">    print(<span class="string">'12的后继'</span>, bst.successor(n[<span class="number">12</span>]))  <span class="comment"># 后继</span></span><br><span class="line">    n[<span class="number">8</span>] = Node(<span class="number">8</span>)</span><br><span class="line">    bst.insert(n[<span class="number">8</span>])  <span class="comment"># 插入</span></span><br><span class="line">    print(<span class="string">'插入 8后'</span>, bst)</span><br><span class="line">    bst.delete(n[<span class="number">3</span>])  <span class="comment"># 情况(a)，只有右孩子</span></span><br><span class="line">    print(<span class="string">'删除 3后'</span>, bst)</span><br><span class="line">    bst.delete(n[<span class="number">8</span>])  <span class="comment"># 情况(a)，只有左孩子</span></span><br><span class="line">    print(<span class="string">'删除 8后'</span>, bst)</span><br><span class="line">    bst.delete(n[<span class="number">18</span>])  <span class="comment"># 情况(c)，有右孩子结点19，且右孩子是其后继结点</span></span><br><span class="line">    print(<span class="string">'删除18后'</span>, bst)</span><br><span class="line">    bst.delete(n[<span class="number">12</span>])  <span class="comment"># 情况(d)，后继结点是15</span></span><br><span class="line">    print(<span class="string">'删除12后'</span>, bst)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">初始     &#123;12: [&#123;5: [&#123;2: [None, 3]&#125;, 9]&#125;, &#123;18: [&#123;15: [None, 17]&#125;, &#123;19: [None, 21]&#125;]&#125;]&#125;</span><br><span class="line">查找 8   None</span><br><span class="line">查找 9   9</span><br><span class="line">12的前驱 9</span><br><span class="line">12的后继 15</span><br><span class="line">插入 8后 &#123;12: [&#123;5: [&#123;2: [None, 3]&#125;, &#123;9: [8, None]&#125;]&#125;, &#123;18: [&#123;15: [None, 17]&#125;, &#123;19: [None, 21]&#125;]&#125;]&#125;</span><br><span class="line">删除 3后 &#123;12: [&#123;5: [2, &#123;9: [8, None]&#125;]&#125;, &#123;18: [&#123;15: [None, 17]&#125;, &#123;19: [None, 21]&#125;]&#125;]&#125;</span><br><span class="line">删除 8后 &#123;12: [&#123;5: [2, 9]&#125;, &#123;18: [&#123;15: [None, 17]&#125;, &#123;19: [None, 21]&#125;]&#125;]&#125;</span><br><span class="line">删除18后 &#123;12: [&#123;5: [2, 9]&#125;, &#123;19: [&#123;15: [None, 17]&#125;, 21]&#125;]&#125;</span><br><span class="line">删除12后 &#123;15: [&#123;5: [2, 9]&#125;, &#123;19: [17, 21]&#125;]&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Algorithms </tag>
            
            <tag> data structures </tag>
            
            <tag> binary tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有根树</title>
      <link href="/notes/introduction-to-algorithms/rooted-trees/"/>
      <url>/notes/introduction-to-algorithms/rooted-trees/</url>
      
        <content type="html"><![CDATA[<h1 id="有根树">有根树</h1><p>表示链表的方法可以推广到任意同构的数据结构上。树的结点用对象表示。与链表类似，每个结点都含有一个关键字key。其余的属性包括指向其他结点的指针，它们随树的种类不同会有所变化。</p><p>链表的结点：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Node:</span><br><span class="line">    key       <span class="comment"># 结点自身的键值</span></span><br><span class="line">    previous  <span class="comment"># 前驱节点</span></span><br><span class="line">    next      <span class="comment"># 后继结点</span></span><br></pre></td></tr></table></figure><h1 id="二叉树">二叉树</h1><p>二叉树的结点：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Node:</span><br><span class="line">    key    <span class="comment"># 键值</span></span><br><span class="line">    p      <span class="comment"># 父节点，只有根节点的父节点为NIL</span></span><br><span class="line">    left   <span class="comment"># 左孩子，若没有左孩子，则该属性为NIL</span></span><br><span class="line">    right  <span class="comment"># 右孩子，若没有右孩子，则该属性为NIL</span></span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="/uploads/image/introduction-to-algorithms/binary-tree.png" title="二叉树的表示方法"></p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.p = self.left = self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_left</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.left, n.p = n, self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_right</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.right, n.p = n, self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.values(self.root))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">values</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""递归得到以当前结点为根节点的子树中所有结点的值"""</span></span><br><span class="line">        v, c = [], <span class="number">0</span>  <span class="comment"># c：孩子个数</span></span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            v.append(self.values(node.left))</span><br><span class="line">            c += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            v.append(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            v.append(self.values(node.right))</span><br><span class="line">            c += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            v.append(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> c &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;node.key: v&#125;</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> node.key</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    key = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">    n = [Node(i) <span class="keyword">for</span> i <span class="keyword">in</span> key]</span><br><span class="line">    t = BinaryTree()</span><br><span class="line">    t.root = n[<span class="number">0</span>]</span><br><span class="line">    n[<span class="number">0</span>].set_left(n[<span class="number">1</span>])</span><br><span class="line">    n[<span class="number">0</span>].set_right(n[<span class="number">2</span>])</span><br><span class="line">    n[<span class="number">1</span>].set_right(n[<span class="number">3</span>])</span><br><span class="line">    n[<span class="number">2</span>].set_left(n[<span class="number">4</span>])</span><br><span class="line">    n[<span class="number">2</span>].set_right(n[<span class="number">5</span>])</span><br><span class="line">    n[<span class="number">3</span>].set_left(n[<span class="number">6</span>])</span><br><span class="line">    n[<span class="number">3</span>].set_right(n[<span class="number">7</span>])</span><br><span class="line">    n[<span class="number">4</span>].set_right(n[<span class="number">8</span>])</span><br><span class="line">    n[<span class="number">5</span>].set_left(n[<span class="number">9</span>])</span><br><span class="line">    n[<span class="number">8</span>].set_left(n[<span class="number">10</span>])</span><br><span class="line">    print(t)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">0</span>: [&#123;<span class="number">1</span>: [<span class="literal">None</span>, &#123;<span class="number">3</span>: [<span class="number">6</span>, <span class="number">7</span>]&#125;]&#125;, &#123;<span class="number">2</span>: [&#123;<span class="number">4</span>: [<span class="literal">None</span>, &#123;<span class="number">8</span>: [<span class="number">10</span>, <span class="literal">None</span>]&#125;]&#125;, &#123;<span class="number">5</span>: [<span class="number">9</span>, <span class="literal">None</span>]&#125;]&#125;]&#125;</span><br></pre></td></tr></table></figure><h1 id="分支无限制的有根树">分支无限制的有根树</h1><p>二叉树的表示方法可以推广到每个结点的孩子数至多为常数k的任意类型的树：只需要将left和right属性用<code>child1，child2，...，childk</code>代替。缺点是，若大部分结点只有少量的孩子，则会浪费大量存储空间（大量无意义的孩子指针）。此外，若孩子的结点数无限制时，此方法失效。所幸的是，有一个巧妙地方法可以用来表示孩子数任意的树。</p><p><strong>左孩子右兄弟表示法</strong>（left-child, right-sibling representation）：对任意n个结点的有根树，只需要O(n)的存储空间。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Node:</span><br><span class="line">    key              <span class="comment"># 键值</span></span><br><span class="line">    p                <span class="comment"># 父节点，若为根节点，则为NIL</span></span><br><span class="line">    left-child       <span class="comment"># 最左边的孩子结点，若没有孩子结点，则为NIL</span></span><br><span class="line">    right-sibling    <span class="comment"># 右侧相邻的兄弟结点，若是其父节点的最右孩子，则为NIL</span></span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-algorithms/tree-with-unbounded-branching.png" title="不限分支数的有根树的表示方法"></p><h2 id="代码-1">代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> data_structure.binary_tree <span class="keyword">import</span> Node <span class="keyword">as</span> Ne</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(Ne)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_child</span><span class="params">(self, c)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.set_left(c)  <span class="comment"># 添加第一个孩子</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 追加孩子</span></span><br><span class="line">            x = self.left</span><br><span class="line">            <span class="keyword">while</span> x.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment"># 寻找追加位置</span></span><br><span class="line">                x = x.right</span><br><span class="line">            x.right, c.p = c, self  <span class="comment"># 添加指针</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        self.root = root</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.values(self.root))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">values</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 没有孩子节点</span></span><br><span class="line">            <span class="keyword">return</span> node.key</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c = node.left</span><br><span class="line">            v = [self.values(c)]  <span class="comment"># 所有孩子组成的列表</span></span><br><span class="line">            <span class="keyword">while</span> c.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                v.append(self.values(c.right))</span><br><span class="line">                c = c.right</span><br><span class="line">            <span class="keyword">return</span> &#123;node.key: v&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    key = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line">    n = [Node(i) <span class="keyword">for</span> i <span class="keyword">in</span> key]</span><br><span class="line">    t = Tree(n[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        n[<span class="number">0</span>].add_child(n[i])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>, <span class="number">6</span>):</span><br><span class="line">        n[<span class="number">1</span>].add_child(n[i])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>, <span class="number">10</span>):</span><br><span class="line">        n[<span class="number">2</span>].add_child(n[i])</span><br><span class="line">    n[<span class="number">3</span>].add_child(n[<span class="number">10</span>])</span><br><span class="line">    n[<span class="number">5</span>].add_child(n[<span class="number">11</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">12</span>, <span class="number">14</span>):</span><br><span class="line">        n[<span class="number">8</span>].add_child(n[i])</span><br><span class="line">    print(t)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;0: [&#123;1: [4, &#123;5: [11]&#125;]&#125;, &#123;2: [6, 7, &#123;8: [12, 13]&#125;, 9]&#125;, &#123;3: [10]&#125;]&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Algorithms </tag>
            
            <tag> data structures </tag>
            
            <tag> binary tree </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/notes/introduction-to-algorithms/linked-lists/"/>
      <url>/notes/introduction-to-algorithms/linked-lists/</url>
      
        <content type="html"><![CDATA[<h1 id="链表">链表</h1><p>链表（linked list）中的各元素按线性顺序排列。数据的线性顺序是由数组下标决定的，然而与数组不同的是，链表的顺序是由各个对象里的指针决定的。链表为动态集合提供了一种简单而灵活的表示方法。</p><h1 id="种类">种类</h1><p>链表可以有多种形式。它可以是单链接的或双链接的，可以是已排序的或未排序的，可以是循环的或非循环的。</p><ul><li><p>双向链表（doubly linked list）L的每个元素都是一个对象，每个对象有一个关键字k和两个指针：next和prev。对象中还可以包含其他辅助数据（或称为卫星数据）。设x为链表的一个元素，x.next指向它在链表中的后继元素，x.prev则指向它的前驱元素。如果x.prev=NIL，则元素x没有前驱，因此是链表的第一个元素，即链表的头（head）。如果x.next=NIL，则元素x没有后继，因此是链表的最后一个元素，即链表的尾（tail）。属性L.head指向链表的第一个元素。如果L.head=NIL，则链表为空。</p><p><img src="/uploads/image/introduction-to-algorithms/linked-list.png" title="链表"></p></li><li><p>单链接的（single linked）：省略每个元素中的prev指针。</p></li></ul><a id="more"></a><ul><li>已排序（sorted）的：链表的线性顺序与链表元素中关键字的线性顺序一致。据此，最小的元素就是表头元素，而最大的元素则是表尾元素。</li><li><p>未排序（unsorted）的：链表的各元素可以以任何顺序出现。</p></li><li><p>循环链表（circular list）：表头元素的prev指针指向表尾元素，而表尾元素的next指针则指向表头元素。可以将循环链表想象成一个各元素组成的圆环。</p></li></ul><h1 id="操作">操作</h1><h2 id="搜索">搜索</h2><p>过程LIST-SEARCH采用简单的线性搜索方法，用于查找链表L中第一个关键字为k的元素，并返回指向该元素的指针。如果链表中没有关键字为k的对象，则返回NIL。要搜索一个有n个对象的链表，过程LIST-SEARCH在最坏情况下的运行时间为<span class="math inline">\(\Theta(n)\)</span>，因为可能需要搜索整个链表。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">LIST-SEARCH(L, k):</span><br><span class="line">    x = L.head</span><br><span class="line">    <span class="keyword">while</span> x != NIL <span class="keyword">and</span> x.key != k:</span><br><span class="line">        x = x.next</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h2 id="插入">插入</h2><p>给定一个元素x，过程LIST-INSERT将x”连接入“到链表的前端。在一个含n个元素的链表上执行LIST-INSERT的运行时间是<span class="math inline">\(\Theta(1)\)</span>。例如，在(a)所示的链表中插入键值为25的元素。插入后的链表如(b)所示。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">LIST-INSERT(L, x):</span><br><span class="line">    x.next = L.head      <span class="comment"># 将x的后继元素指向当前head</span></span><br><span class="line">    <span class="keyword">if</span> L.head != NIL:    <span class="comment"># 若当前head不为NIL</span></span><br><span class="line">        L.head.prev = x  <span class="comment"># 修改head的前驱元素为x</span></span><br><span class="line">    L.head = x           <span class="comment"># 更改链表的表头元素</span></span><br><span class="line">    x.prev = NIL         <span class="comment"># 修改x的前驱元素为NIL</span></span><br></pre></td></tr></table></figure><h2 id="删除">删除</h2><p>过程LIST-DELETE将一个元素x从链表L中移除。通过修改一些指针，将x“删除出”该链表。如果要删除具有给定关键字值的元素，则必须先调用LIST-SEARCH找到该元素。LIST-DELETE的运行时间为<span class="math inline">\(\Theta(1)\)</span>。例如，在(b)所示的链表中删除键值为4的元素，删除后的链表如(c)所示。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">LIST-DELETE(L, x):</span><br><span class="line">    <span class="keyword">if</span> x.prev != NIL:          <span class="comment"># 如果x不是表头元素</span></span><br><span class="line">        x.prev.next = x.next   <span class="comment"># 修改x的前驱中的后继指针</span></span><br><span class="line">    <span class="keyword">else</span>:                      <span class="comment"># 如果x是表头元素，则x没有前驱</span></span><br><span class="line">        L.head = x.next        <span class="comment"># 直接修改表头指针</span></span><br><span class="line">    <span class="keyword">if</span> x.next != NIL:          <span class="comment"># 如果x有后继元素</span></span><br><span class="line">        x.next.prev = x.prev   <span class="comment"># 修改后继元素的前驱指针</span></span><br></pre></td></tr></table></figure><h2 id="哨兵">哨兵</h2><p>哨兵（sentinel）是一个哑对象，其作用是简化边界条件的处理。在链表L中设置一个哨兵L.nil，对于链表代码中出现的每一处（表头和表尾）对NIL的引用，都代之以对哨兵L.nil的引用，即表头元素的prev指针和表尾的next指针均指向L.nil。这样的调整将一个常规的双向链表转变为一个<strong>有哨兵的双向循环链表</strong>（circular, doubly linked list with a sentinel），哨兵位于表头和表尾之间。属性L.nil.next指向表头，L.nil.prev指向表尾。一个空链表只由一个哨兵构成，L.nil.next和L.nil.prev同时指向L.nil。</p><p><img src="/uploads/image/introduction-to-algorithms/circular-doubly-linked-list-with-a-sentinel.png" title="有哨兵的双向循环链表"></p><p>应当慎用哨兵。假如有许多个很短的链表，它们的哨兵所占用的额外的存储空间会造成严重的存储浪费。</p><p>引入哨兵后，搜索、插入和删除的代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">LIST-SEARCH<span class="string">'(L, k):</span></span><br><span class="line"><span class="string">    x = L.nil.next   # 初始x指向表头元素</span></span><br><span class="line"><span class="string">    while x != L.nil and x.key != k:</span></span><br><span class="line"><span class="string">        x = x.next</span></span><br><span class="line"><span class="string">    return x</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">LIST-INSERT'</span>(L, X):</span><br><span class="line">    x.next = L.nil.next</span><br><span class="line">    L.nil.next.prev = x</span><br><span class="line">    L.nil.next = x</span><br><span class="line">    x.prev = L.nil</span><br><span class="line"></span><br><span class="line">LIST-DELETE<span class="string">'(L, x):</span></span><br><span class="line"><span class="string">    x.prev.next = x.next</span></span><br><span class="line"><span class="string">    x.next.prev = x.prev</span></span><br></pre></td></tr></table></figure><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.prev = self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>:</span></span><br><span class="line">    <span class="string">"""双向循环链表"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""空链表"""</span></span><br><span class="line">        self.nil, self.size = Element(<span class="literal">None</span>), <span class="number">0</span></span><br><span class="line">        self.nil.prev = self.nil.next = self.nil  <span class="comment"># 哨兵（sentinel）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str([x.key <span class="keyword">for</span> x <span class="keyword">in</span> self])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self.to_list())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_list</span><span class="params">(self)</span>:</span></span><br><span class="line">        x, values = self.head(), []</span><br><span class="line">        <span class="keyword">while</span> x != self.nil:</span><br><span class="line">            values.append(x)</span><br><span class="line">            x = x.next</span><br><span class="line">        <span class="keyword">return</span> values</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""删除元素x"""</span></span><br><span class="line">        x.prev.next, x.next.prev = x.next, x.prev</span><br><span class="line">        self.size -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        <span class="string">"""查找键值为k的元素"""</span></span><br><span class="line">        x = self.head()</span><br><span class="line">        <span class="keyword">while</span> x != self.nil <span class="keyword">and</span> x.key != k:  <span class="comment"># 找不到时x重新指向nil</span></span><br><span class="line">            x = x.next</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""插入元素x，x作为新的表头"""</span></span><br><span class="line">        x.next, self.head().prev = self.head(), x  <span class="comment"># 链接x与第1个元素</span></span><br><span class="line">        self.nil.next, x.prev = x, self.nil  <span class="comment"># 链接哨兵与x</span></span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">head</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回表头元素"""</span></span><br><span class="line">        <span class="keyword">return</span> self.nil.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tail</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回表尾元素"""</span></span><br><span class="line">        <span class="keyword">return</span> self.nil.prev</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(y, z)</span>:</span></span><br><span class="line">    <span class="string">"""合并链表y和z为一个新的链表，y和z会被销毁"""</span></span><br><span class="line">    x = LinkedList()</span><br><span class="line">    x.nil.next, y.head().prev = y.head(), x.nil  <span class="comment"># 链接x.nil与y的头部</span></span><br><span class="line">    x.nil.prev, z.tail().next = z.tail(), x.nil  <span class="comment"># 链接x.nil与z的尾部</span></span><br><span class="line">    y.tail().next, z.head().prev = z.head(), y.tail()  <span class="comment"># 链接y的尾部与z的头部</span></span><br><span class="line">    y = z = <span class="literal">None</span>  <span class="comment"># 销毁y和z</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    l = LinkedList()</span><br><span class="line">    l.insert(Element(<span class="number">1</span>))</span><br><span class="line">    l.insert(Element(<span class="number">2</span>))</span><br><span class="line">    l.insert(Element(<span class="number">3</span>))</span><br><span class="line">    l.insert(Element(<span class="number">4</span>))</span><br><span class="line">    l.insert(Element(<span class="number">5</span>))</span><br><span class="line">    l.insert(Element(<span class="number">6</span>))</span><br><span class="line">    print(l)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[6, 5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Algorithms </tag>
            
            <tag> data structures </tag>
            
            <tag> list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tex Commands</title>
      <link href="/documentation/tex-commands/"/>
      <url>/documentation/tex-commands/</url>
      
        <content type="html"><![CDATA[<h1 id="希腊字母">希腊字母</h1><table><thead><tr class="header"><th>Notation</th><th>Commands</th><th>Notation</th><th>Commands</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\alpha\)</span></td><td><code>\alpha</code></td><td><span class="math inline">\(\beta\)</span></td><td><code>\beta</code></td></tr><tr class="even"><td><span class="math inline">\(\gamma\)</span> <span class="math inline">\(\Gamma\)</span></td><td><code>\gamma \Gamma</code></td><td><span class="math inline">\(\delta\)</span> <span class="math inline">\(\Delta\)</span></td><td><code>\delta \Delta</code></td></tr><tr class="odd"><td><span class="math inline">\(\varepsilon\)</span></td><td><code>\varepsilon</code></td><td><span class="math inline">\(\epsilon\)</span></td><td><code>\epsilon</code></td></tr><tr class="even"><td><span class="math inline">\(\zeta\)</span></td><td><code>\zeta</code></td><td><span class="math inline">\(\eta\)</span></td><td><code>\eta</code></td></tr><tr class="odd"><td><span class="math inline">\(\theta\)</span> <span class="math inline">\(\Theta\)</span></td><td><code>\theta \Theta</code></td><td><span class="math inline">\(\vartheta\)</span></td><td><code>\vartheta</code></td></tr><tr class="even"><td><span class="math inline">\(\iota\)</span></td><td><code>\iota</code></td><td><span class="math inline">\(\kappa\)</span></td><td><code>\kappa</code></td></tr><tr class="odd"><td><span class="math inline">\(\lambda\)</span> <span class="math inline">\(\Lambda\)</span></td><td><code>\lambda \Lambda</code></td><td><span class="math inline">\(\mu\)</span></td><td><code>\mu</code></td></tr><tr class="even"><td><span class="math inline">\(\nu\)</span></td><td><code>\nu</code></td><td><span class="math inline">\(\xi\)</span> <span class="math inline">\(\Xi\)</span></td><td><code>\xi \Xi</code></td></tr><tr class="odd"><td><span class="math inline">\(\omicron\)</span></td><td><code>\omicron</code></td><td><span class="math inline">\(\pi\)</span> <span class="math inline">\(\Pi\)</span></td><td><code>\pi \Pi</code></td></tr><tr class="even"><td><span class="math inline">\(\varpi\)</span></td><td><code>\varpi</code></td><td><span class="math inline">\(\rho\)</span></td><td><code>\rho</code></td></tr><tr class="odd"><td><span class="math inline">\(\varrho\)</span></td><td><code>\varrho</code></td><td><span class="math inline">\(\sigma\)</span> <span class="math inline">\(\Sigma\)</span></td><td><code>\sigma \Sigma</code></td></tr><tr class="even"><td><span class="math inline">\(\varsigma\)</span></td><td><code>\varsigma</code></td><td><span class="math inline">\(\tau\)</span></td><td><code>\tau</code></td></tr><tr class="odd"><td><span class="math inline">\(\upsilon\)</span> <span class="math inline">\(\Upsilon\)</span></td><td><code>\upsilon \Upsilon</code></td><td><span class="math inline">\(\varphi\)</span></td><td><code>\varphi</code></td></tr><tr class="even"><td><span class="math inline">\(\phi\)</span> <span class="math inline">\(\Phi\)</span></td><td><code>\phi \Phi</code></td><td><span class="math inline">\(\chi\)</span></td><td><code>\chi</code></td></tr><tr class="odd"><td><span class="math inline">\(\psi\)</span> <span class="math inline">\(\Psi\)</span></td><td><code>\psi \Psi</code></td><td><span class="math inline">\(\omega\)</span> <span class="math inline">\(\Omega\)</span></td><td><code>\omega \Omega</code></td></tr></tbody></table><a id="more"></a><h1 id="括号">括号</h1><table><thead><tr class="header"><th>Notation</th><th>Commands</th><th>Notation</th><th>Commands</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\lbrace\)</span> <span class="math inline">\(\rbrace\)</span></td><td><code>\lbrace \rbrace</code></td><td><span class="math inline">\(\langle\)</span> <span class="math inline">\(\rangle\)</span></td><td><code>\langle \rangle</code></td></tr></tbody></table><h1 id="运算符号">运算符号</h1><table><thead><tr class="header"><th>Notation</th><th>Commands</th><th>Notation</th><th>Commands</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\times\)</span></td><td><code>$\times$</code></td><td><span class="math inline">\(\div\)</span></td><td><code>$\div$</code></td></tr><tr class="even"><td><span class="math inline">\(\frac{a}{b}\)</span></td><td><code>$\frac{a}{b}$</code></td><td><span class="math inline">\(\pm\)</span></td><td><code>$\pm$</code></td></tr><tr class="odd"><td><span class="math inline">\(\sum\)</span></td><td><code>\sum</code></td><td><span class="math inline">\(\prod\)</span></td><td><code>\prod</code></td></tr><tr class="even"><td><span class="math inline">\(\lceil\)</span> <span class="math inline">\(\rceil\)</span></td><td><code>$\lceil$ $\rceil$</code></td><td><span class="math inline">\(\lfloor\)</span> <span class="math inline">\(\rfloor\)</span></td><td><code>$\lfloor$ $\rfloor$</code></td></tr></tbody></table><h1 id="角标">角标</h1><table><thead><tr class="header"><th>Notation</th><th>Commands</th><th>Notation</th><th>Commands</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\hat a\)</span></td><td><code>\hat a</code></td><td><span class="math inline">\(\dot a\)</span></td><td><code>$\dot a$</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mathjax </tag>
            
            <tag> tex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斐波那契堆</title>
      <link href="/notes/introduction-to-algorithms/fibonacci-heaps/"/>
      <url>/notes/introduction-to-algorithms/fibonacci-heaps/</url>
      
        <content type="html"><![CDATA[<h1 id="斐波那契堆">斐波那契堆</h1><p>斐波那契堆数据结构有两种用途：</p><ul><li>它支持一些列操作，这些操作构成了所谓的“可合并堆”。</li><li>斐波那契堆的一些操作（INSERT/UNION/DECREASE-KEY）可以在常数摊还时间内完成，非常适用于需要频繁使用这些操作的应用。</li></ul><table><thead><tr class="header"><th>操作</th><th>二项堆（最坏情形）</th><th>斐波那契堆（摊还）</th></tr></thead><tbody><tr class="odd"><td>MAKE-HEAP()：创建空堆</td><td><span class="math inline">\(\Theta(1)\)</span></td><td><span class="math inline">\(\Theta(1)\)</span></td></tr><tr class="even"><td>INSERT(H, x)：插入元素x</td><td><span class="math inline">\(\Theta(\lg{n})\)</span></td><td><span class="math inline">\(\Theta(1)\)</span></td></tr><tr class="odd"><td>MINIMUM()：提取最小元素</td><td><span class="math inline">\(\Theta(1)\)</span></td><td><span class="math inline">\(\Theta(1)\)</span></td></tr><tr class="even"><td>EXTRACT-MIN()：删除并返回最小元素</td><td><span class="math inline">\(\Theta(\lg{n})\)</span></td><td><span class="math inline">\(O(\lg{n})\)</span></td></tr><tr class="odd"><td>UNION(H1, H2)：创建一个包含H1和H2中所有元素的新堆</td><td><span class="math inline">\(\Theta(n)\)</span></td><td><span class="math inline">\(\Theta(1)\)</span></td></tr><tr class="even"><td>DECREASE-KEY(H, x, k)：将元素x的关键字赋予新值k</td><td><span class="math inline">\(\Theta(\lg{n})\)</span></td><td><span class="math inline">\(\Theta(1)\)</span></td></tr><tr class="odd"><td>DELETE(H, x)：删除元素x</td><td><span class="math inline">\(\Theta(\lg{n})\)</span></td><td><span class="math inline">\(O(\lg{n})\)</span></td></tr></tbody></table><ul><li>从理论上看，当EXTRACT-MIN和DELETE数目相比于其他操作小得多的时候，斐波那契堆尤为合适。例如，一些图问题算法可能每条边调用一次DECREASE-KEY。对于有很多边的稠密图，每次调用DECREASE-KEY需要<span class="math inline">\(\Theta(1)\)</span>摊还时间，相比起二叉堆最坏情况时间<span class="math inline">\(\Theta(\lg{n})\)</span>，其积累起来是个很大的改进。如最小生成树和寻找单源最短路径的快速算法必不可少地要用到斐波那契堆。</li><li>从实际上看，除了某些需要管理大量数据的应用外，对于大多数应用，斐波那契堆的常数因子和编程复杂性使得它比起普通二项（或k项）堆并不那么适用。因此对斐波那契堆的研究主要出于理论研究。</li></ul><a id="more"></a><h1 id="结构">结构</h1><p>一个斐波那契堆（Fibonacci heap）一系列具有最小堆序（min-heap ordered）的有根树的集合。也就是说，每棵树均遵守最小堆性质（min-heap property）：每个结点的关键字大于或等于它的父结点的关键字。</p><p>斐波那契堆的每个结点x包含：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    int     key      <span class="comment"># 值</span></span><br><span class="line">    int     degree   <span class="comment"># 度，孩子数目</span></span><br><span class="line">    Node    left     <span class="comment"># 左兄弟</span></span><br><span class="line">    Node    right    <span class="comment"># 右兄弟</span></span><br><span class="line">    Node    p        <span class="comment"># 父节点</span></span><br><span class="line">    Node    child    <span class="comment"># 任意一个孩子</span></span><br><span class="line">    bool    marked   <span class="comment"># 是否第一次被删除某个孩子</span></span><br></pre></td></tr></table></figure><p>x的所有孩子被链接成一个环形的双向链表（如下图(b)所示，通常情况下省略了指针，将图画成(a)的样子，因为很容易从(a)中推断出指针指向），称为x的孩子链表（child list）。</p><p>斐波那契堆H包含：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FiboHeap</span>:</span></span><br><span class="line">    Node        min        <span class="comment"># 堆中最小结点（minimum node）</span></span><br><span class="line">    LinkedList  root_list  <span class="comment"># 包含所有根结点的双向环形链表</span></span><br><span class="line">    int         n          <span class="comment"># 堆中所有结点数目</span></span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-algorithms/fibonacci-heap.png" title="斐波那契堆"></p><h1 id="可合并堆">可合并堆</h1><h2 id="创建一个新的斐波那契堆">创建一个新的斐波那契堆</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MAKE-FIB-HEAP():</span><br><span class="line">    H = FiboHeap()</span><br><span class="line">    H.n         = <span class="number">0</span>                 <span class="comment"># 结点数目为0</span></span><br><span class="line">    H.min       = NIL               <span class="comment"># 最小结点为NIL</span></span><br><span class="line">    H.root_list = new LinkedList()  <span class="comment"># 根链表初始为空</span></span><br><span class="line">    <span class="keyword">return</span> H</span><br></pre></td></tr></table></figure><h2 id="插入一个结点">插入一个结点</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FIB-HEAP-INSERT(H, x):</span><br><span class="line">    x.degree    = <span class="number">0</span>                        <span class="comment"># 初始化x的属性</span></span><br><span class="line">    x.p         = NIL</span><br><span class="line">    x.child     = NIL</span><br><span class="line">    x.mark      = <span class="literal">False</span></span><br><span class="line">    H.root_list.insert(x)                  <span class="comment"># 将x插入H的根链表</span></span><br><span class="line">    <span class="keyword">if</span> H.min == NIL <span class="keyword">or</span> x.key &lt; H.min.key:  <span class="comment"># 更新H.min</span></span><br><span class="line">        H.min = x</span><br><span class="line">    H.n = H.n + <span class="number">1</span>                          <span class="comment"># 更新结点数目</span></span><br></pre></td></tr></table></figure><p>在一个斐波那契堆中插入键值为21的结点：</p><p><img src="/uploads/image/introduction-to-algorithms/fib-heap-insert.png" title="插入"></p><p>图中插入位置为H.min的前驱，实际的插入位置没有影响。</p><h2 id="两个斐波那契堆的合并">两个斐波那契堆的合并</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FIB-HEAP-UNION(H1, H2):</span><br><span class="line">    H = MAKE-FIB-HEAP()</span><br><span class="line">    H.root_list = concatenate(H1.root_list, H2.root_list) <span class="comment"># 合并根链表</span></span><br><span class="line">    H.min = H1.min      <span class="comment"># 判断合并后堆的最小结点</span></span><br><span class="line">    <span class="keyword">if</span> H1.min == NIL <span class="keyword">or</span> (H2.min != NIL <span class="keyword">and</span> H2.min.key &lt; H1.min.key):</span><br><span class="line">        H.min = H2.min</span><br><span class="line">    H.n = H1.n + H2.n   <span class="comment"># 更新结点数目</span></span><br><span class="line">    <span class="keyword">return</span> H</span><br></pre></td></tr></table></figure><h2 id="抽取最小结点">抽取最小结点</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FIB-HEAP-EXTRACT-MIN(H):</span><br><span class="line">    z = H.min</span><br><span class="line">    <span class="keyword">if</span> z != NIL:</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> z.child:           <span class="comment"># 将min的所有孩子结点移动到根链表</span></span><br><span class="line">            H.root_list.insert(x)   <span class="comment"># 更新left和right</span></span><br><span class="line">            x.p = NIL               <span class="comment"># 更新父节点，不更新child意味着孩子结点x的孩子结点不变</span></span><br><span class="line">        H.root_list.delete(z)       <span class="comment"># 删除最小结点min</span></span><br><span class="line">        H.min = NIL</span><br><span class="line">        CONSOLIDATE(H)              <span class="comment"># 子过程</span></span><br><span class="line">        H.n = H.n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> z</span><br></pre></td></tr></table></figure><p>其中子过程CONSOLIDATE(H)用来把具有相同度数的根节点合并（consolidating），直到每个度数至多只有一个根。该过程使用一个辅助数组<code>A[0...D(H.n)]</code>来记录根节点对用的度数的轨迹，其中D(H.n)表示一个n个结点的斐波那契堆中任何结点的最大度数上界（<span class="math inline">\(D(n)=O(\lg{n})\)</span>）。如果A[i]=y，那么当前的y是一个具有y.degree=i的根。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CONSOLIDATE(H):</span><br><span class="line">    let A[<span class="number">0.</span>.D(H.n)] be a new array</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to D(H.n):  <span class="comment"># 初始化A</span></span><br><span class="line">        A[i] = NIL</span><br><span class="line">    <span class="keyword">for</span> each node w <span class="keyword">in</span> the root list of H:</span><br><span class="line">        x = w</span><br><span class="line">        d = x.degree</span><br><span class="line">        <span class="keyword">while</span> A[d] != NIL:</span><br><span class="line">            y = A[d]      <span class="comment"># 另一个具有相同度数d的结点y</span></span><br><span class="line">            <span class="keyword">if</span> x.key &gt; y.key:</span><br><span class="line">                exchange x <span class="keyword">with</span> y   <span class="comment"># 始终保证x.key &lt; y.key</span></span><br><span class="line">            FIB-HEAP-LINK(H, y, x)  <span class="comment"># 子过程：将y链接为x的孩子结点</span></span><br><span class="line">            A[d] = NIL              <span class="comment"># 合并后具有度数d的结点不存在了</span></span><br><span class="line">            d = d + <span class="number">1</span>               <span class="comment"># 合并后x的度数，通过while循环再次寻找具有相同度数的结点y</span></span><br><span class="line">        A[d] = x                    <span class="comment"># 不存在相同度数d的y，记录x的度数信息</span></span><br><span class="line">        <span class="keyword">if</span> H.min == NIL <span class="keyword">or</span> x.key &lt; H.min.key:  <span class="comment"># 更新min结点</span></span><br><span class="line">            H.min = x</span><br><span class="line"></span><br><span class="line">FIB-HEAP-LINK(H, y, x):</span><br><span class="line">    H.root_list.delete(y)    <span class="comment"># 从H的根链表中移除y</span></span><br><span class="line">    x.child.insert(y)        <span class="comment"># 将y添加到x的孩子结点中</span></span><br><span class="line">    x.degree = x.degree + <span class="number">1</span>  <span class="comment"># 更新x的度</span></span><br><span class="line">    y.mark = <span class="literal">False</span>           <span class="comment"># 清除y上的标记</span></span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-algorithms/fib-heap-extract-min.png" title="提取最小的元素"></p><ul><li><span class="math inline">\((a)\)</span> 从当前的斐波那契堆中提取最小结点H.min。以后把“键值为x的结点”省略称为“结点x“。</li><li><span class="math inline">\((a)\rightarrow(b)\)</span> 将结点3的所有子节点移动到根链表。H.min指针右移一位。此时不一定指向最小元素，在后续操作中会调整。</li><li><span class="math inline">\((b)\rightarrow(c)\)</span> 创建一个辅助数组A，遍历根链表。当前结点的度数为1，A[1]为空，将A[1]指向当前结点。继续下一位。</li><li><span class="math inline">\((d)\rightarrow(e)\)</span> 过程类似。结果是A[2]指向度数为2的结点24；A[0]指向度数为0的结点23。</li><li><span class="math inline">\((e)\rightarrow(f)\)</span> 结点7的度数为0，但A[0]不为空，将结点7与A[0]指向的结点23合并：键值较大的结点23移动到结点7的子节点链表中。移动后，清除A[0]。</li><li><span class="math inline">\((f)\rightarrow(g)\)</span> 结点7的度数为1，A[1]不为空且指向结点17。于是将结点17移动到结点7的子结点链表中。清除A[1]。</li><li><span class="math inline">\((g)\rightarrow(h)\)</span> 结点7的度数为2，A[2]不为空且指向24。合并结点7与结点24。清除A[2]。此时结点7的度数为3，而A[3]为空，令A[3]指向结点结点7。继续下一个结点。</li><li><span class="math inline">\((i)\rightarrow(j)\)</span> A[0]指向结点21；A[1]指向结点18。</li><li><span class="math inline">\((j)\rightarrow(k)\)</span> 结点52度数为0，A[0]不为空且指向21。合并结点21与结点52。清除A[0]；合并后结点21的度数为1，A[1]指向结点18。合并结点21与结点18。清除A[1]；合并后结点18度数为2，A[2]为空，令A[2]指向结点18。继续下一结点。</li><li><span class="math inline">\((k)\rightarrow(l)\)</span> 结点38的度数为1，A[1]为空。令A[1]指向结点38。继续下一节点。</li><li><span class="math inline">\((m)\)</span> 所有结点遍历完毕。更新H.min。</li></ul><h1 id="减值和删除">减值和删除</h1><h2 id="关键字减值">关键字减值</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FIB-HEAP-DECREASE-KEY(H, x, k):</span><br><span class="line">    <span class="keyword">if</span> k &gt; x.key:</span><br><span class="line">        error <span class="string">"new key is greater than current key"</span></span><br><span class="line">    x.key = k</span><br><span class="line">    y = x.p</span><br><span class="line">    <span class="keyword">if</span> y != NIL <span class="keyword">and</span> x.key &lt; y.key:  <span class="comment"># 如果更新后x的值小于父节点的值，调整堆</span></span><br><span class="line">        CUT(H, x, y)                <span class="comment"># 子过程：切断x与其父节点y之间的链接</span></span><br><span class="line">        CASCADING-CUT(H, y)         <span class="comment"># 子过程：级联切断</span></span><br><span class="line">    <span class="keyword">if</span> x.key &lt; H.min.key:           <span class="comment"># 更新min结点</span></span><br><span class="line">        H.min = x</span><br><span class="line"></span><br><span class="line">CUT(H, x, y):                <span class="comment"># 切断x与其父节点y之间的链接，并将x添加到根链表</span></span><br><span class="line">    y.child.delete(x)        <span class="comment"># remove x from the child list of y</span></span><br><span class="line">    y.degree = y.degree - <span class="number">1</span>  <span class="comment"># decrementint y.degree</span></span><br><span class="line">    H.root_list.insert(x)    <span class="comment"># add x to the root list of H</span></span><br><span class="line">    x.p = NIL</span><br><span class="line">    x.mark = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">CASCADING-CUT(H, y):            <span class="comment"># 级联切断</span></span><br><span class="line">    z = y.p</span><br><span class="line">    <span class="keyword">if</span> z != NIL:</span><br><span class="line">        <span class="keyword">if</span> y.mark == <span class="literal">False</span>:     <span class="comment"># 如果mark为false，那么上次CUT中，是结点y第一次失去孩子</span></span><br><span class="line">            y.mark == <span class="literal">True</span>      <span class="comment"># 第一次失去孩子，mark置为True</span></span><br><span class="line">        <span class="keyword">else</span>:                   <span class="comment"># 如果mark为True，那么上次CUT之前，y已经失去过孩子</span></span><br><span class="line">            CUT(H, y, z)</span><br><span class="line">            CASCADING-CUT(H, Z) <span class="comment"># 向上递归，直到遇到根节点或者一个未被标记的结点（mark=False）</span></span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-algorithms/fib-heap-decrease-key.png" title="减小元素的值"></p><ul><li><span class="math inline">\((a)\)</span> 初始斐波那契堆。将结点46的键值降低为15。</li><li><p><span class="math inline">\((a)\rightarrow(b)\)</span> 修改键值。将修改后的结点15移动到根链表（切断）。其父节点24，之前未被标记。现在失去了一个孩子，标记它。</p></li><li><p><span class="math inline">\((b)\)</span> 在此斐波那契堆上，将结点35的键值降低为5。</p></li><li><span class="math inline">\((b)\rightarrow(c)\)</span> 修改键值，将修改后的结点5移动到根链表（切断）。</li><li><span class="math inline">\((c)\rightarrow(d)\)</span> 结点5的原来的父节点26是被标记的，触发级联切断的条件：切断结点26与其父节点，将结点26移动到根链表，清除其标记。之后对结点26的原来的父节点24递归地调用级联切断过程。</li><li><span class="math inline">\((d)\rightarrow(e)\)</span> 结点24同样是被标记的，切断结点24与其父节点7。最后对结点24的原来的父节点7递归地调用级联切断。</li><li><p>结点7没有父节点，级联切断不处理此类结点。</p></li></ul><h2 id="删除一个结点">删除一个结点</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FIB-HEAP-DELETE(H, x):</span><br><span class="line">    FIB-HEAP-DECREASE-KEY(H, x, -infinty)</span><br><span class="line">    FIB-HEAP-EXTRACT-MIN(H)</span><br></pre></td></tr></table></figure><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> data_structure.linked_list <span class="keyword">import</span> Element, LinkedList, union <span class="keyword">as</span> union_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(Element)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        Element.__init__(self, k)</span><br><span class="line">        self.degree, self.mark = <span class="number">0</span>, <span class="literal">False</span>  <span class="comment"># mark：第1次失去孩子后为True、第2次后为False</span></span><br><span class="line">        self.p = self.child = self.prev = self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.value())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">value</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.child <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> len(self.child) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.key</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;self.key: [c.value() <span class="keyword">for</span> c <span class="keyword">in</span> self.child]&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FibHeap</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.n, self.min = <span class="number">0</span>, <span class="literal">None</span>  <span class="comment"># 堆中结点数目, 堆中最小结点</span></span><br><span class="line">        self.root_list = LinkedList()  <span class="comment"># 根链表</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        s = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self.root_list:</span><br><span class="line">            s.append(str(x))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">', '</span>.join(s)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x.degree, x.mark = <span class="number">0</span>, <span class="literal">False</span></span><br><span class="line">        x.p = x.child = <span class="literal">None</span></span><br><span class="line">        self.root_list.insert(x)  <span class="comment"># 插入根链表</span></span><br><span class="line">        <span class="keyword">if</span> self.min <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> x.key &lt; self.min.key:</span><br><span class="line">            self.min = x</span><br><span class="line">        self.n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        z = self.min</span><br><span class="line">        <span class="keyword">if</span> z <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> z.child <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment"># 将所有子节点插入到根链表</span></span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> z.child:</span><br><span class="line">                    self.root_list.insert(x)</span><br><span class="line">                    x.p = <span class="literal">None</span></span><br><span class="line">            self.min = <span class="literal">None</span></span><br><span class="line">            self.root_list.delete(z)  <span class="comment"># 从根链表中移除</span></span><br><span class="line">            self.consolidate()  <span class="comment"># 合并度数相同的结点</span></span><br><span class="line">            self.n -= <span class="number">1</span>  <span class="comment"># 总结点数目减1</span></span><br><span class="line">            z.child = <span class="literal">None</span>  <span class="comment"># 清除指针，不清除对斐波那契堆也没什么影响</span></span><br><span class="line">        <span class="keyword">return</span> z</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">consolidate</span><span class="params">(self)</span>:</span></span><br><span class="line">        degree = &#123;&#125;  <span class="comment"># degree[i]=y，那么y.degree=i</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self.root_list:  <span class="comment"># 在link()中可能被删除的元素已经访问过，因此可以使用迭代器</span></span><br><span class="line">            d = x.degree</span><br><span class="line">            <span class="keyword">while</span> d <span class="keyword">in</span> degree:</span><br><span class="line">                y = degree.pop(d)  <span class="comment"># another node with the same degree as x</span></span><br><span class="line">                <span class="keyword">if</span> x.key &gt; y.key:</span><br><span class="line">                    x, y = y, x</span><br><span class="line">                self.link(y, x)</span><br><span class="line">                d = d + <span class="number">1</span></span><br><span class="line">            degree[d] = x</span><br><span class="line">            <span class="keyword">if</span> self.min <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> self.min.key &gt; x.key:</span><br><span class="line">                self.min = x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">link</span><span class="params">(self, y, x)</span>:</span></span><br><span class="line">        self.root_list.delete(y)</span><br><span class="line">        y.p = x</span><br><span class="line">        <span class="keyword">if</span> x.child <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            x.child = LinkedList()</span><br><span class="line">        x.child.insert(y)</span><br><span class="line">        x.degree += <span class="number">1</span></span><br><span class="line">        y.mark = <span class="literal">False</span>  <span class="comment"># y成为孩子结点时，mark置为False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decrease_key</span><span class="params">(self, x, k)</span>:</span> <span class="comment"># 没有对结点x是否在堆中进行判断，heap.min可能会指向堆外结点</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; x.key:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'new key is greater than current key'</span>)</span><br><span class="line">        x.key, y = k, x.p</span><br><span class="line">        <span class="keyword">if</span> y <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> x.key &lt; y.key:  <span class="comment"># 当更新后的值小于父节点时调整堆</span></span><br><span class="line">            self.cut(x, y)  <span class="comment"># 切断x与y</span></span><br><span class="line">            self.cascading_cut(y)</span><br><span class="line">        <span class="keyword">if</span> x.key &lt; self.min.key:</span><br><span class="line">            self.min = x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cut</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        y.child.delete(x)  <span class="comment"># 分离x与其父节点y</span></span><br><span class="line">        self.root_list.insert(x)  <span class="comment"># 使x成为根节点</span></span><br><span class="line">        y.degree -= <span class="number">1</span></span><br><span class="line">        x.p, x.mark = <span class="literal">None</span>, <span class="literal">False</span>  <span class="comment"># x成为根结点时，mark置为False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cascading_cut</span><span class="params">(self, y)</span>:</span></span><br><span class="line">        z = y.p</span><br><span class="line">        <span class="keyword">if</span> z <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> y.mark <span class="keyword">is</span> <span class="literal">False</span>:  <span class="comment"># mark=False，是第一次失去孩子</span></span><br><span class="line">                y.mark = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># mark=True,是第二次失去孩子</span></span><br><span class="line">                self.cut(y, z)</span><br><span class="line">                self.cascading_cut(z)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.decrease_key(x, float(<span class="string">'-inf'</span>))</span><br><span class="line">        self.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(h1, h2)</span>:</span></span><br><span class="line">    h = FibHeap()  <span class="comment"># 初始化新堆</span></span><br><span class="line">    h.root_list = union_list(h1.root_list, h2.root_list)  <span class="comment"># 合并根链表，h1和h2的根链表会被销毁</span></span><br><span class="line">    h.min = h1.min  <span class="comment"># 比较最小结点</span></span><br><span class="line">    <span class="keyword">if</span> h1.min <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> (h2.min <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> h2.min.key &lt; h1.min.key):</span><br><span class="line">        h.min = h2.min</span><br><span class="line">    h.n = h1.n + h2.n  <span class="comment"># 结点数目相加</span></span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    h1, h2 = FibHeap(), FibHeap()</span><br><span class="line">    key1, key2 = [<span class="number">23</span>, <span class="number">7</span>, <span class="number">21</span>, <span class="number">3</span>, <span class="number">17</span>, <span class="number">24</span>, <span class="number">18</span>], [<span class="number">52</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">26</span>, <span class="number">46</span>, <span class="number">39</span>, <span class="number">41</span>, <span class="number">35</span>]</span><br><span class="line">    [h1.insert(Node(i)) <span class="keyword">for</span> i <span class="keyword">in</span> key1]</span><br><span class="line">    [h2.insert(Node(i)) <span class="keyword">for</span> i <span class="keyword">in</span> key2]</span><br><span class="line">    print(<span class="string">'h1:'</span>, h1)</span><br><span class="line">    print(<span class="string">'h2:'</span>, h2)</span><br><span class="line">    h = union(h1, h2)  <span class="comment"># union，合并根链表</span></span><br><span class="line">    print(<span class="string">'h:'</span>, h)</span><br><span class="line">    print(<span class="string">'&#123;0:&lt;3s&#125; &#123;1:&lt;6s&#125;'</span>.format(<span class="string">'pop'</span>, <span class="string">'h'</span>))</span><br><span class="line">    <span class="keyword">while</span> h.n &gt; <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">'&#123;0:&lt;3d&#125; &#123;1:&lt;6s&#125;'</span>.format(h.pop().key, str(h)))</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h1: 18, 24, 17, 3, 21, 7, 23</span><br><span class="line">h2: 35, 41, 39, 46, 26, 30, 38, 52</span><br><span class="line">h: 18, 24, 17, 3, 21, 7, 23, 35, 41, 39, 46, 26, 30, 38, 52</span><br><span class="line">pop h</span><br><span class="line">3   &#123;7: [&#123;17: [&#123;18: [24]&#125;, 21]&#125;, &#123;35: [41]&#125;, 23]&#125;, &#123;26: [&#123;39: [46]&#125;, 30]&#125;, &#123;38: [52]&#125;</span><br><span class="line">7   23, &#123;35: [&#123;38: [52]&#125;, 41]&#125;, &#123;17: [&#123;26: [&#123;39: [46]&#125;, 30]&#125;, &#123;18: [24]&#125;, 21]&#125;</span><br><span class="line">17  &#123;18: [&#123;26: [&#123;39: [46]&#125;, 30]&#125;, &#123;21: [23]&#125;, 24]&#125;, &#123;35: [&#123;38: [52]&#125;, 41]&#125;</span><br><span class="line">18  24, &#123;21: [23]&#125;, &#123;26: [&#123;35: [&#123;38: [52]&#125;, 41]&#125;, &#123;39: [46]&#125;, 30]&#125;</span><br><span class="line">21  &#123;23: [24]&#125;, &#123;26: [&#123;35: [&#123;38: [52]&#125;, 41]&#125;, &#123;39: [46]&#125;, 30]&#125;</span><br><span class="line">23  24, &#123;26: [&#123;35: [&#123;38: [52]&#125;, 41]&#125;, &#123;39: [46]&#125;, 30]&#125;</span><br><span class="line">24  &#123;26: [&#123;35: [&#123;38: [52]&#125;, 41]&#125;, &#123;39: [46]&#125;, 30]&#125;</span><br><span class="line">26  30, &#123;39: [46]&#125;, &#123;35: [&#123;38: [52]&#125;, 41]&#125;</span><br><span class="line">30  &#123;39: [46]&#125;, &#123;35: [&#123;38: [52]&#125;, 41]&#125;</span><br><span class="line">35  41, &#123;38: [&#123;39: [46]&#125;, 52]&#125;</span><br><span class="line">38  &#123;39: [&#123;41: [52]&#125;, 46]&#125;</span><br><span class="line">39  46, &#123;41: [52]&#125;</span><br><span class="line">41  &#123;46: [52]&#125;</span><br><span class="line">46  52</span><br><span class="line">52</span><br></pre></td></tr></table></figure><h1 id="应用">应用</h1><ul><li>Dijkstra算法</li><li>Prim算法</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Algorithms </tag>
            
            <tag> data structures </tag>
            
            <tag> heap </tag>
            
            <tag> fibonacci heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斯特灵近似公式</title>
      <link href="/further-mathematics/stirling-s-approximation/"/>
      <url>/further-mathematics/stirling-s-approximation/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zh.wikipedia.org/wiki/%E6%96%AF%E7%89%B9%E9%9D%88%E5%85%AC%E5%BC%8F" target="_blank" rel="noopener">斯特灵公式</a>（Stirling's approximation or Stirling's formula）是一条用来取n阶乘近似值的数学公式。一般来说，当n很大的时候，n阶乘的计算量十分大，所以斯特灵公式十分好用。而且，即使在n很小的时候，斯特灵公式的取值已经十分准确。</p><p><span class="math display">\[n! \approx \sqrt{2\pi{n}}(\frac{n}{e})^n\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> formula </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/notes/introduction-to-algorithms/quicksort/"/>
      <url>/notes/introduction-to-algorithms/quicksort/</url>
      
        <content type="html"><![CDATA[<h1 id="快速排序">快速排序</h1><p>快速排序（Quicksort）是一种高效的比较型排序算法，于1961年由瑞典科学家<a href="https://en.wikipedia.org/wiki/Tony_Hoare" target="_blank" rel="noopener">Tony Hoare</a>发表。与<a href="/algorithm/Merge-sort">归并排序</a>类似，快速排序也是一种分治算法。快速排序是常用的排序算法，一个好的快速排序的实现，甚至可以比归并排序和堆排序快两到三倍。快速排序不是稳定排序，但它是原址排序。排序n个数的<strong>平均</strong>时间代价是<span class="math inline">\(O(n\log{n})\)</span>。最坏情况下，它的时间代价是<span class="math inline">\(O(n^2)\)</span>，这种情况很少出现。快速排序的示例图（来自<a href="https://en.wikipedia.org/wiki/Quicksort" target="_blank" rel="noopener">维基百科：Quicksort</a>）如下：</p><p><img src="/uploads/image/introduction-to-algorithms/sorting-quicksort-anim.gif" title="快速排序动态过程"></p><a id="more"></a><h1 id="实现">实现</h1><p>快速排序同样遵循分治模式，每层递归是有三个步骤：</p><ul><li>分解（Divide）：数组<code>A[p...r]</code>被划分为两个（可能为空）子数组<code>A[p...q-1]</code>和<code>A[q+1...r]</code>，使得<span class="math inline">\(A[i]\le{A[q]}\le{A[j]}, i\in[p,q-1], j\in[q+1,r]\)</span>。其中，计算下标q也是划分过程的一部分。</li><li>解决（Conquer）：通过递归调用快速排序，对子数组<code>A[p...q-1]</code>和<code>A[q+1...r]</code>进行排序。</li><li>合并（Combine）：快速排序不需要合并操作，数组<code>A[p...r]</code>已经有序。</li></ul><p>与归并排序不同，快速排序的比较过程发生在分解阶段，且快速排序是原址排序，所以快速排序不需要合并操作。</p><p>实现快速排序的过程如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">quicksort(A, p, r):</span><br><span class="line">    <span class="keyword">if</span> p &lt; r:</span><br><span class="line">        q = partition(A, p, r)</span><br><span class="line">        quicksort(A, p, q - <span class="number">1</span>)</span><br><span class="line">        quicksort(A, q + <span class="number">1</span>, r)</span><br></pre></td></tr></table></figure><p>快速排序的关键部分是partition过程，它实现了对子数组<code>A[p...r]</code>的原址排序。</p><h2 id="lomuto划分">Lomuto划分</h2><p>Lomuto划分的效率不高，但它易于理解。它通常选择最后一个元素x=A[r]作为<strong>主元</strong>（pivot），并围绕它来划分子数组<code>A[p...r]</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lomuto_partition(A, p, r):</span><br><span class="line">    x = A[r]</span><br><span class="line">    i = p - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j = p to r - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> A[j] &lt;= x</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">            exchange A[i] <span class="keyword">with</span> A[j]</span><br><span class="line">    exchange A[i+<span class="number">1</span>] <span class="keyword">with</span> A[r]</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>        // q的最终位置</span><br></pre></td></tr></table></figure><p>随着划分过程的进行，数组被划分成4个（可能有空的）区域。分别为小于等于x的部分，大于x的部分，未比较部分，和主元x。将这些性质作为循环不变量：</p><blockquote><p>在循环体的每一轮迭代开始时，对任意数组下标k，有：</p><ol type="1"><li>小于x的部分：若<span class="math inline">\(p\le{k}\le{i}\)</span>，则<span class="math inline">\(A[k]\le{x}\)</span>。</li><li>大于x的部分：若<span class="math inline">\(i+1\le{k}\le{j-1}\)</span>，则<span class="math inline">\(A[k]\ge{x}\)</span>。</li><li>等于x的部分：若k=r，则A[k]=x。</li></ol></blockquote><p>上述坐标之外的区域<code>A[j...r-1]</code>对应为比较部分。Lomuto划分的一个示例如下：</p><p>数组的四个部分分别是 (小于主元的元素) (大于等于主元的元素) (未划分元素) (主元)。</p><table><thead><tr class="header"><th><code>array[p...r]</code></th><th>A[i]</th><th>A[j]</th></tr></thead><tbody><tr class="odd"><td>() () (2871356) (4)</td><td>null（i=p-1）</td><td>2</td></tr><tr class="even"><td>x=array[r]=4</td><td></td><td>2&lt;4，i=i+1; exchange 2 with 2; j=j+1</td></tr><tr class="odd"><td>(2) () (871356) (4)</td><td>2</td><td>8</td></tr><tr class="even"><td></td><td></td><td>8&gt;=4，j=j+1</td></tr><tr class="odd"><td>(2) (8) (71356) (4)</td><td>2</td><td>7</td></tr><tr class="even"><td></td><td></td><td>7&gt;=4，j=j+1</td></tr><tr class="odd"><td>(2) (87) (1356) (4)</td><td>2</td><td>1</td></tr><tr class="even"><td></td><td></td><td>1&lt;4，i=i+1; exchange 8 with 1; j=j+1</td></tr><tr class="odd"><td>(21) (78) (356) (4)</td><td>1</td><td>3</td></tr><tr class="even"><td></td><td></td><td>3&lt;4，i=i+1; exchange 7 with 3; j=j+1</td></tr><tr class="odd"><td>(213) (87) (56) (4)</td><td>3</td><td>5</td></tr><tr class="even"><td></td><td></td><td>5&gt;=4，j=j+1</td></tr><tr class="odd"><td>(213) (875) (6) (4)</td><td>3</td><td>6</td></tr><tr class="even"><td></td><td></td><td>6&gt;=4，j=j+1</td></tr><tr class="odd"><td>(213) (8756) () (4)</td><td>3</td><td>4</td></tr><tr class="even"><td></td><td></td><td>j==r，退出循环，exchange 8 with 4</td></tr><tr class="odd"><td>213 4 7568</td><td>3</td><td>return i+1，是主元位置</td></tr></tbody></table><h2 id="hoare划分">Hoare划分</h2><p>Hoare划分比Lomuto划分更加高效。在选择了主元之后，它使用两个下标i和j，i从前往后、j从后往前移动。当找到<span class="math inline">\(A[i]\ge{x}\)</span>、<span class="math inline">\(A[j]\le{x}\)</span>且i&lt;j的两个坐标i和j之后，交换它们的元素。当i和j相遇（<span class="math inline">\(i\ge{j}\)</span>）后，划分过程停止。平均情况下，Hoare划分比Lomuto划分少3次交换次数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hoare_partition(A, p, r):</span><br><span class="line">    x = A[r]                           <span class="comment"># 最后一个元素作为主元</span></span><br><span class="line">    i = p</span><br><span class="line">    j = r - <span class="number">1</span>                          <span class="comment"># 最后一位是主元</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">while</span> i &lt; r <span class="keyword">and</span> A[i] &lt;= x:     <span class="comment"># 找到大于主元的元素或i=r（主元的位置）时停止</span></span><br><span class="line">            i = i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= p <span class="keyword">and</span> A[j] &gt;=x:     <span class="comment"># 找到小于主元的元素或j&lt;p（超出了边界）时停止</span></span><br><span class="line">            j = j<span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; j:                      <span class="comment"># i与j相遇，i是主元应处的位置</span></span><br><span class="line">            <span class="keyword">if</span> i != r:</span><br><span class="line">                swap A[i] <span class="keyword">with</span> A[r]</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        swap A[i] <span class="keyword">with</span> A[j]</span><br></pre></td></tr></table></figure><p>Hoare划分的一个示例如下：</p><p>数组的四个部分分别是 (小于等于主元的元素) (未划分元素) (大于等于主元的元素) (主元)。</p><table><thead><tr class="header"><th></th><th><code>array[p...r]</code></th><th>A[i]</th><th>A[j]</th></tr></thead><tbody><tr class="odd"><td>初始</td><td>() (2871356) () (4)</td><td>2</td><td>6</td></tr><tr class="even"><td>寻找下一对交换元素</td><td>主元x=4</td><td>8</td><td>3，交换</td></tr><tr class="odd"><td>继续寻找</td><td>(23) (71) (856) (4)</td><td>7</td><td>1，交换</td></tr><tr class="even"><td>继续寻找</td><td>(231) () (7856) (4)</td><td>7</td><td>1，相遇，交换A[i]与主元，return i</td></tr><tr class="odd"><td></td><td>231 4 8567</td><td>4</td><td>7</td></tr></tbody></table><h2 id="主元的选择">主元的选择</h2><p>不论Lomuto划分还是Hoare划分，主元的选择方式都会直接影响到划分结果。例如上述Hoare划分过程的示例，若选择主元x=1，正好是数组中最小的元素，划分过程很快就结束，并产生了两个长度相差较大的子数组[1]和[2, 8, 7, 2, 3, 5, 6, 4]。同理若正好选择了最大的元素，也会产生类似的结果。称这种划分为不平衡划分（Unbalanced partitioning）。</p><p>在Lomuto划分中，总是选择最右侧元素作为主元。若输入数组是已排序的，排序算法将总是产生不平衡划分，触发最坏情况。幸运的是，可以通过一些策略来优化，使得对任何输入都比较好。例如随机选择，后文将分析随机选择主元的快速排序的期望运行时间为<span class="math inline">\(O(n\log{n})\)</span>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">random(A, left, right):</span><br><span class="line">    select an integer i <span class="keyword">in</span> [left, right] randomly</span><br><span class="line">    <span class="keyword">if</span> i != right:</span><br><span class="line">        swap A[i] <span class="keyword">with</span> A[right]</span><br><span class="line">    <span class="keyword">return</span> A[right]</span><br></pre></td></tr></table></figure><p>还有一种模式：选择左中右元素的中位数（Median-of-three，mo3）。随机选择模式下，快速排序的比较次数的期望是<span class="math inline">\(1.386n\log{n}\)</span>，mo3模式下，期望可下降至<span class="math inline">\(1.188n\log{n}\)</span>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">median_of_three(A, left, right):</span><br><span class="line">    mid = (left + right) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> A[mid] &lt; A[left]:</span><br><span class="line">        swap A[left] <span class="keyword">with</span> A[mid]    <span class="comment"># A[left] &lt;= A[mid]</span></span><br><span class="line">    <span class="keyword">if</span> A[right] &lt; A[left]:</span><br><span class="line">        swap A[left] <span class="keyword">with</span> A[right]  <span class="comment"># A[left] &lt;= A[right]</span></span><br><span class="line">    <span class="keyword">if</span> A[mid] &lt; A[right]:</span><br><span class="line">        swap A[mid] <span class="keyword">with</span> A[right]   <span class="comment"># A[right] &lt;= A[mid]</span></span><br><span class="line">    pivot = A[right]</span><br></pre></td></tr></table></figure><p>通过上述代码，使得<span class="math inline">\(A[mid]\ge{A[right]}\ge{A[left]}\)</span>，此时再选择最右侧元素，实际上是左中右元素的中位数。当输入数组的排序情况未知时，相比总是直接选择左右侧元素，该方法性能更好。对于更长的数组，可以扩展mo3规则至更强的ninther。</p><p><code>ninther(A)=middle(mo3(first 1/3 of A), mo3(middle 1/3 of A), mo3(final 1/3 of A))</code></p><p><strong>注意</strong>：mid = (left + right) / 2可能会发生越界情况（没搞懂），可以用mid = left + (right - left) / 2来代替。</p><h1 id="分析">分析</h1><h2 id="最坏情况">最坏情况</h2><p>以Lomuto划分为例，当划分操作总是得到一个大小为0、另一个大小为n-1的数组时（还有一个元素是主元），假设T(n)是quicksort在输入规模为n的数据集合上所花费的时间，则有递归式：</p><p><span class="math display">\[T(n)=T(0)+T(n-1)+\Theta(n)\]</span></p><p>递归树深度为n，容易得到<span class="math inline">\(T(n)=O(n^2)\)</span>。</p><p>利用代入法证明：</p><p><span class="math display">\[T(n)=\max_{0\le{q}\le{n-1}}(T(q)+T(n-q-1)+\Theta(n))\]</span></p><p>q和n-q-1分别是两个子数组的规模。设<span class="math inline">\(T(n)\le{cn^2}\)</span>成立，将其带入上式 <span class="math display">\[\begin{aligned}T(n)&amp;\le{\max_{0\le{q}\le{n-1}}(cq^2+c(n-q-1)^2)+\Theta(n)}\\&amp;=c\max_{0\le{q}\le{n-1}}(q^2+(n-q-1)^2)+\Theta(n)\end{aligned}\]</span></p><p><span class="math inline">\(q^2+(n-q-1)^2\le(n-1)^2=n^2-2n+1\)</span>（在端点处取得最大值），将其带入上式，得到</p><p><span class="math display">\[T(n)\le{cn^2-c(2n-1)+\Theta(n)}\le{cn^2}\]</span></p><p><span class="math inline">\(\therefore{T(n)=O(n^2)}\)</span>。</p><h2 id="最佳情况">最佳情况</h2><p>若划分操作总是得到两个规模相等的子数组时，触发最佳情况。</p><p><span class="math display">\[T(n)=2T(\frac{n}{2})+\Theta(n)\]</span></p><p>递归树深度为<span class="math inline">\(\log_2{n}\)</span>，可得<span class="math inline">\(T(n)=O(n\log(n))\)</span>。</p><h2 id="平均情况">平均情况</h2><p>对于规模为n的无重复元素的数组，若主元的选择是独立且随机的，则快速排序的期望运行时间为<span class="math inline">\(O(n\log(n))\)</span>。</p><p>证明：</p><p>考虑输入数组的一个随机序列<span class="math inline">\((x_1,x_2,...,x_n)\)</span>，定义C表示比较次数，<span class="math inline">\(c_{ij}\)</span>为指示器随机变量。有</p><p><span class="math display">\[c_{ij}=\begin{cases}1&amp;x_i与x_j发生比较\\0&amp;x_i与x_j不发生比较&amp;&amp;\end{cases}C=\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}c_{i,j}\]</span></p><p>对C取期望，有</p><p><span class="math display">\[E[C]=\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}E(c_{ij})=\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}Pr(c_{ij})\]</span></p><p>在划分操作中，只有主元会与其他元素发生比较，因此</p><p><span class="math display">\[Pr(c_{ij})=Pr(x_i\text{或}x_j\text{被选为主元)}\]</span></p><p>在一次划分中，<span class="math inline">\(x_i\)</span>与<span class="math inline">\(x_j\)</span>不可能同时被选为主元，且主元的选择是独立的，因此</p><p><span class="math display">\[Pr(c_{ij})=2*Pr(x_i被选为主元)=\frac{2}{j-i+1}\]</span></p><p>令<span class="math inline">\(k=j-i\)</span>，代入<span class="math inline">\(E[C]\)</span>得</p><p><span class="math display">\[\begin{aligned}E[C]&amp;=\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}\frac{2}{j-i+1}\\&amp;=\sum_{i=1}^{n-1}\sum_{k=1}^{n-i}\frac{2}{k+1}\\&amp;&lt;\sum_{i=1}^{n-1}\sum_{k=1}^{n}\frac{2}{k}\\&amp;=\sum_{i=1}^{n-1}O(\log{n})\\&amp;=O(n\log{n})\end{aligned}\]</span></p><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(a, i, j)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> i != j:</span><br><span class="line">        a[i], a[j] = a[j], a[i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">median_of_three</span><span class="params">(a, left, right)</span>:</span></span><br><span class="line">    <span class="string">"""选择左中右三元素的中位数作为pivot"""</span></span><br><span class="line">    mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> a[mid] &lt; a[left]:</span><br><span class="line">        exchange(a, left, mid)  <span class="comment"># now: a[left] &lt;= a[mid]</span></span><br><span class="line">    <span class="keyword">if</span> a[right] &lt; a[left]:</span><br><span class="line">        exchange(a, left, right)  <span class="comment"># now: a[left] &lt;= a[right]</span></span><br><span class="line">    <span class="keyword">if</span> a[mid] &lt; a[right]:</span><br><span class="line">        exchange(a, mid, right)  <span class="comment"># now: a[right] &lt;= a[mid]</span></span><br><span class="line">    <span class="comment"># now: a[left&#125; &lt;= a[right] &lt;= a[mid]</span></span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hoare_partition</span><span class="params">(a, left, right)</span>:</span></span><br><span class="line">    <span class="string">"""Hoare's scheme is more efficient than Lomuto's partition scheme</span></span><br><span class="line"><span class="string">    because it does three times fewer swaps on average."""</span></span><br><span class="line">    pivot, i, j = a[right], left, right - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">while</span> i &lt; right <span class="keyword">and</span> a[i] &lt;= pivot:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= left <span class="keyword">and</span> a[j] &gt;= pivot:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; j:  <span class="comment"># i, j 相遇</span></span><br><span class="line">            exchange(a, i, right)</span><br><span class="line">            <span class="keyword">return</span> i  <span class="comment"># pivot位置</span></span><br><span class="line">        exchange(a, i, j)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lomuto_partition</span><span class="params">(a, left, right)</span>:</span></span><br><span class="line">    pivot, i = a[right], left</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(left, right):</span><br><span class="line">        <span class="keyword">if</span> a[j] &lt; pivot:  <span class="comment"># 小于pivot的元素被划分到左边，大于等于pivot的元素被划分到右边</span></span><br><span class="line">            exchange(a, i, j)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    exchange(a, i, right)</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">q_sort</span><span class="params">(a, left, right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; right:</span><br><span class="line">        p_idx = random.randint(left, right)  <span class="comment"># 随机选择pivot</span></span><br><span class="line">        <span class="comment"># p_idx = median_of_three(a, left, right)  # 选择左中右元素的中位数</span></span><br><span class="line">        q = partition(a, left, right, p_idx)</span><br><span class="line">        q_sort(a, left, q - <span class="number">1</span>)</span><br><span class="line">        q_sort(a, q + <span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(a, left, right, p_idx)</span>:</span>  <span class="comment"># 增加参数，p_idx指示所用主元在数组中的位置</span></span><br><span class="line">    <span class="keyword">if</span> p_idx &lt; left <span class="keyword">or</span> p_idx &gt; right:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">"主元位置越界"</span>)</span><br><span class="line">    exchange(a, p_idx, right)</span><br><span class="line">    <span class="keyword">return</span> hoare_partition(a, left, right)</span><br><span class="line">    <span class="comment"># return lomuto_partition(a, left, right)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="string">"""排序整个列表"""</span></span><br><span class="line">    q_sort(a, <span class="number">0</span>, len(a) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">16</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">11</span>, <span class="number">15</span>]</span><br><span class="line">    quick_sort(arr)</span><br><span class="line">    print(arr)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort </tag>
            
            <tag> Introduction to Algorithms </tag>
            
            <tag> algorithms </tag>
            
            <tag> divide and conquer </tag>
            
            <tag> comparison sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/notes/introduction-to-algorithms/merge-sort/"/>
      <url>/notes/introduction-to-algorithms/merge-sort/</url>
      
        <content type="html"><![CDATA[<h1 id="归并排序">归并排序</h1><p>归并排序（Merge sort）是一种比较高效的比较型排序算法，由<a href="https://en.wikipedia.org/wiki/John_von_Neumann" target="_blank" rel="noopener">John von Neumann</a>于1945年提出。归并排序算法是运用分治策略（Divide-and-conquer）的典型算法，它有许多中不同的实现，且大多数实现是稳定排序。归并排序的示意图（出自<a href="https://en.wikipedia.org/wiki/Merge_sort#Top-down_implementation_using_lists" target="_blank" rel="noopener">维基百科：Merge sort</a>）如下：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/cc/Merge-sort-example-300px.gif/220px-Merge-sort-example-300px.gif" title="归并排序动态示意图"></p><a id="more"></a><h1 id="实现">实现</h1><p>归并排序在每层递归时有三个步骤（遵循分治模式）：</p><ul><li><p>分解（Divide）：分解待排序的n个元素的序列成各局n/2个元素的两个子序列。</p></li><li><p>解决（Conquer）：使用归并排序递归地排序两个子序列。</p></li><li><p>合并（Combine）：合并两个已排序的子序列以产生已排序的答案。</p></li></ul><h2 id="合并">合并</h2><p>合并过程是归并排序的关键操作。通过调用一个辅助过程merge(A, p, q, r)来完成，其中A是一个数组，p、q和r是数组下标，满足<span class="math inline">\(p\le{q}&lt;r\)</span>。假设子数组<code>A[p...q]</code>和<code>A[q+1...r]</code>都已经排好序。该过程合并这两个子数组形成单一的已排好序的数组来代替当前的数组<code>A[p...r]</code>。</p><p>合并时需要注意要时刻判断两个子数组是否为空，当某个子数组为空时，则无需比较，只需要将另一个子数组中的元素取出即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">merge(A, p, q, r):</span><br><span class="line">    创建新数组B[<span class="number">0.</span>.r-p]</span><br><span class="line">    将A[p..r]复制到B[<span class="number">0.</span>.r-p]</span><br><span class="line">    i = p</span><br><span class="line">    j = q</span><br><span class="line">    <span class="keyword">for</span> k = p to r:</span><br><span class="line">        <span class="keyword">if</span> i &lt; q <span class="keyword">and</span> (j &gt;= r <span class="keyword">or</span> B[i] &lt;= B[j]):  <span class="comment"># 用 i &lt; q 和 j &gt;=r 时刻判断非空</span></span><br><span class="line">            A[k] = B[i]</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            A[k] = B[j]</span><br><span class="line">            j = j + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>为了避免每次检查非空以简化代码，可以通过在子数组末尾放置一个哨兵（sentinel）元素。使用<span class="math inline">\(\infty\)</span>作为哨兵元素的值。当有效数组元素为空时，哨兵元素显露出来，它不可能小于其他非哨兵元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">merge(A, p, q, r):</span><br><span class="line">    <span class="comment"># --------准备工作-------------</span></span><br><span class="line">    创建两个新数组L[<span class="number">0.</span>.p-q+<span class="number">1</span>]和R[<span class="number">0.</span>.r-q]</span><br><span class="line">    将A[p..q]复制到L[<span class="number">0.</span>.p-q]</span><br><span class="line">    将B[q+<span class="number">1.</span>.r]复制到R[<span class="number">0.</span>.r-q<span class="number">-1</span>]</span><br><span class="line">    L[p-q+<span class="number">1</span>] = inf</span><br><span class="line">    R[r-q] = inf</span><br><span class="line">    <span class="comment"># -----------end--------------------</span></span><br><span class="line">    <span class="comment"># ---------比较------------</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k = p to r:</span><br><span class="line">        <span class="keyword">if</span> L[i] &lt; R[j]:</span><br><span class="line">            A[k] = L[i]</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            A[k] = R[j]</span><br><span class="line">            j = j + <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="自顶向下的实现">自顶向下的实现</h2><p>自顶向下的归并排序递归地将序列分解成子序列，直到子序列只有1个元素。当待排序的序列长度为1时，递归“开始回升”，此时无需合并，因为长度为1的每个序列是已排序的。之后合并这些子序列生成已排序的序列。上述示意图描述的就是自顶向下的归并排序算法的排序过程。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">merge_sort_top_down(A, p, r):</span><br><span class="line">    <span class="keyword">if</span> p &lt; r:    <span class="comment"># 当元素个数大于1时</span></span><br><span class="line">        q = (p + q) / <span class="number">2</span></span><br><span class="line">        merge_sort_top_down(A, p, q)</span><br><span class="line">        merge_sort_top_down(A, q + <span class="number">1</span>, r)</span><br><span class="line">        merge(A, p, q, r)</span><br></pre></td></tr></table></figure><h2 id="自底向上的实现">自底向上的实现</h2><p>自底向上的归并排序将原数组视为n个长度为1的子数组，然后依次合并两个相邻子数组，得到长度为2，4，6.…的已排序数组，直到整个数组。自底向上的归并排序的排序过程如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input:  6  5  3  1  8  7  2  4</span><br><span class="line">1st:    56  31  78  24</span><br><span class="line">2nd:    1356  2478</span><br><span class="line">3rd:    12345678</span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">merge_sort_bottom_up(A):</span><br><span class="line">    n = A.length</span><br><span class="line">    <span class="keyword">for</span> (width = <span class="number">1</span>; width &lt; n; width = <span class="number">2</span> * width):</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i = i + <span class="number">2</span> * width):</span><br><span class="line">            merge(A, i, min(i + width, n) - <span class="number">1</span>, min(i + <span class="number">2</span> * width, n) - <span class="number">1</span>)  <span class="comment"># 合并相邻数组</span></span><br></pre></td></tr></table></figure><h1 id="自然归并排序">自然归并排序</h1><p>自然归并排序（Natural merge sort）类似于自底向上的归并排序。自底向上的归并排序的出发点是1（将长度为n的数组视为n个长度为1的子数组，这n个子数组是已排序的）。而输入数组可能包含已排序的子数组，这些子数组可通过一遍遍历找出。自然归并排序将依次合并这些子数组。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Start:          3421758906</span><br><span class="line">Select runs:    34  2  17  589  06</span><br><span class="line">Merge:          234  15789  06</span><br><span class="line">Merge:          12345789  06</span><br><span class="line">Merge:          0123456789</span><br></pre></td></tr></table></figure><h1 id="分析">分析</h1><p>合并过程只需要一次遍历即可完成，运行时间是<span class="math inline">\(\Theta(n)\)</span>，n是合并后数组的长度。归并排序的<strong>平均</strong>和<strong>最坏</strong>情况下的时间复杂度是<span class="math inline">\(O(n\lg{n})\)</span>。</p><p>设T(n)为归并排序对长度为n的数组进行排序的运行时间，则归并排序的时间复杂度可以描述为<span class="math inline">\(T(n)=2T(n/2)+\Theta(n)\)</span>。可解得<span class="math inline">\(T(n)=O(n\lg{n})\)</span>。</p><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort_top_down</span><span class="params">(array, p, r)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> p &lt; r:</span><br><span class="line">        q = (p + r) // <span class="number">2</span></span><br><span class="line">        merge_sort_top_down(array, p, q)  <span class="comment"># 递归调用</span></span><br><span class="line">        merge_sort_top_down(array, q + <span class="number">1</span>, r)  <span class="comment"># 递归调用</span></span><br><span class="line">        merge(array, p, q, r)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort_bottom_up</span><span class="params">(array)</span>:</span></span><br><span class="line">    width, n = <span class="number">1</span>, len(array)</span><br><span class="line">    <span class="keyword">while</span> width &lt; n:</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            merge(array, i, min(i + width, n) - <span class="number">1</span>, min(i + (width &lt;&lt; <span class="number">1</span>), n) - <span class="number">1</span>)</span><br><span class="line">            i += (width &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        width = width &lt;&lt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(array, p, q, r)</span>:</span></span><br><span class="line">    <span class="string">"""合并array[p..q]与array[q+1..r]"""</span></span><br><span class="line">    left, right = array[p:q + <span class="number">1</span>], array[q + <span class="number">1</span>:r + <span class="number">1</span>]</span><br><span class="line">    left.append(float(<span class="string">"inf"</span>))</span><br><span class="line">    right.append(float(<span class="string">"inf"</span>))</span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(p, r + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">            array[k] = left[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            array[k] = right[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line">    merge_sort_top_down(arr, <span class="number">0</span>, len(arr) - <span class="number">1</span>)</span><br><span class="line">    print(arr)</span><br><span class="line">    arr = [<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line">    merge_sort_bottom_up(arr)</span><br><span class="line">    print(arr)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 2, 3, 4, 7, 8, 9, 10, 14, 16]</span><br><span class="line">[1, 2, 3, 4, 7, 8, 9, 10, 14, 16]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort </tag>
            
            <tag> Introduction to Algorithms </tag>
            
            <tag> algorithms </tag>
            
            <tag> divide and conquer </tag>
            
            <tag> comparison sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python列表推导</title>
      <link href="/programming/python-list-comprehensions/"/>
      <url>/programming/python-list-comprehensions/</url>
      
        <content type="html"><![CDATA[<h1 id="列表推导">列表推导</h1><p>列表推导（List comprehensions）提供了一种更简洁的方式来创建集合。例如创建一个平方和的列表：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>    squares.append(x**<span class="number">2</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><p>可以看到在循环结束后，x仍然存在。利用列表推导，可以摆脱这种“副作用”。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = list(map(<span class="keyword">lambda</span> y: y**<span class="number">2</span>, range(<span class="number">10</span>)))</span><br></pre></td></tr></table></figure><p>等价于，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = [z**<span class="number">2</span> <span class="keyword">for</span> z <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br></pre></td></tr></table></figure><p>最后一种方法更加简洁，可读性也更好。</p><a id="more"></a><h1 id="扩展">扩展</h1><p>一个列表推导语句至少要有一对内含for语句的括号（例如<code>[x for x in range(9)]</code>），for语句后面可以跟其他for或if语句。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] <span class="keyword">if</span> x != y]</span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">1</span>, <span class="number">5</span>), (<span class="number">1</span>, <span class="number">6</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">2</span>, <span class="number">6</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure><p>将for和if语句按序拆开，上述语句等价于</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>combs = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">if</span> x != y:</span><br><span class="line"><span class="meta">... </span>                    combs.append((x, y))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>combs</span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">1</span>, <span class="number">5</span>), (<span class="number">1</span>, <span class="number">6</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">2</span>, <span class="number">6</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure><p>要注意，当表达式是元组（tuple）时，必须要包含在括号内。如上例中的(x, y)。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x, x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    [x, x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line">               ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><h1 id="嵌套">嵌套</h1><p>列表推导自身可以嵌套使用，用来创建一个多维列表。下面是求转置矩阵的例子。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">    [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">    [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],</span><br><span class="line">    [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>],</span><br><span class="line">]</span><br><span class="line">// 以下<span class="number">3</span>中方法等价，只是写法不同</span><br><span class="line">// 方法<span class="number">1</span>：两个comprehensions嵌套</span><br><span class="line">transposed = [[row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br><span class="line">// 方法<span class="number">2</span>：一个comprehension</span><br><span class="line">transposed = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    transposed.append([row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix])</span><br><span class="line">// 方法<span class="number">3</span>：原生</span><br><span class="line">transposed = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    transposed_row = []</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> matrix:</span><br><span class="line">        transposed_row.append(row[i])</span><br><span class="line">    transposed.append(transposed_row)</span><br><span class="line"></span><br><span class="line">// 结果</span><br><span class="line">[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>], [<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>]]</span><br></pre></td></tr></table></figure><p>实际使用时，更倾向于内建方法。如zip()方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(*matrix))</span><br><span class="line">[(<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>), (<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>), (<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>), (<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>)]</span><br></pre></td></tr></table></figure><h1 id="创建集合和字典">创建集合和字典</h1><p>类似的操作同样适用于创建集合和字典。可以称之为集合推导（Set comprehensions）和字典推导（Dictionary comprehensions）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;s <span class="keyword">for</span> s <span class="keyword">in</span> <span class="string">'hello world'</span>&#125;</span><br><span class="line">&#123;<span class="string">'w'</span>, <span class="string">'o'</span>, <span class="string">'r'</span>, <span class="string">'h'</span>, <span class="string">'l'</span>, <span class="string">' '</span>, <span class="string">'d'</span>, <span class="string">'e'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;k:v <span class="keyword">for</span> k, v <span class="keyword">in</span> enumerate([<span class="string">'zero'</span>, <span class="string">'first'</span>, <span class="string">'second'</span>])&#125;</span><br><span class="line">&#123;<span class="number">0</span>: <span class="string">'zero'</span>, <span class="number">1</span>: <span class="string">'first'</span>, <span class="number">2</span>: <span class="string">'second'</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python循环技巧</title>
      <link href="/programming/python-looping-techniques/"/>
      <url>/programming/python-looping-techniques/</url>
      
        <content type="html"><![CDATA[<h1 id="同时遍历key和value">同时遍历key和value</h1><p>使用items()方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic = &#123;<span class="string">'name'</span>: <span class="string">'chen'</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> dic.items():</span><br><span class="line"><span class="meta">... </span>    print(k, v)</span><br><span class="line">...</span><br><span class="line">name chen  </span><br><span class="line">gender male</span><br></pre></td></tr></table></figure><h1 id="同时遍历index和value">同时遍历index和value</h1><p>使用enumerate()方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate([<span class="string">'zero'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]):</span><br><span class="line"><span class="meta">... </span>    print(i, v)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> zero</span><br><span class="line"><span class="number">1</span> one</span><br><span class="line"><span class="number">2</span> two</span><br><span class="line"><span class="number">3</span> three</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="同时遍历多个数组">同时遍历多个数组</h1><p>使用zip()方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>eng = [<span class="string">'zero'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n, e <span class="keyword">in</span> zip(nums, eng):</span><br><span class="line"><span class="meta">... </span>    print(n, e)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> zero</span><br><span class="line"><span class="number">1</span> one</span><br><span class="line"><span class="number">2</span> two</span><br></pre></td></tr></table></figure><h1 id="反序遍历">反序遍历</h1><p>使用reversed()方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(<span class="number">2</span>, <span class="number">11</span>, <span class="number">2</span>)):</span><br><span class="line"><span class="meta">... </span>    print(i, end=<span class="string">' '</span>)</span><br><span class="line">...</span><br><span class="line"><span class="number">10</span> <span class="number">8</span> <span class="number">6</span> <span class="number">4</span> <span class="number">2</span> &gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h1 id="排序和去重">排序和去重</h1><p>使用sorted()和set()方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>basket = [<span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'apple'</span>, <span class="string">'banana'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> f <span class="keyword">in</span> sorted(set(basket)):</span><br><span class="line"><span class="meta">... </span>    print(f)</span><br><span class="line">...</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br></pre></td></tr></table></figure><h1 id="循环里面的else">循环里面的else</h1><p>退出循环时执行else块中代码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">if</span> n % x == <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>                    print(n, <span class="string">'equals'</span>, x, <span class="string">'*'</span>, n//x)</span><br><span class="line"><span class="meta">... </span>                    <span class="keyword">break</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>            print(n, <span class="string">'is a prime number'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="number">2</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">3</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">4</span> equals <span class="number">2</span> * <span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">6</span> equals <span class="number">2</span> * <span class="number">3</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">8</span> equals <span class="number">2</span> * <span class="number">4</span></span><br><span class="line"><span class="number">9</span> equals <span class="number">3</span> * <span class="number">3</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性时间排序</title>
      <link href="/notes/introduction-to-algorithms/sorting-in-linear-time/"/>
      <url>/notes/introduction-to-algorithms/sorting-in-linear-time/</url>
      
        <content type="html"><![CDATA[<h1 id="计数排序">计数排序</h1><p>计数排序于1954年由Harold H. Seward提出，是一种线性时间排序算法。它是稳定排序算法，这个性质很重要，是它可以作为基数排序子过程的前提。但不是原址排序算法，即需要额外的随输入规模增大的辅助空间。计数排序不是比较排序，摆脱了比较排序的下界<span class="math inline">\(\Omega(n\lg{n})\)</span>，可以在线性时间内完成排序。</p><p>计数排序先“数”出不同元素值的个数，之后通过算数运算求出不同元素值排序后的位置。它的运行时间是O(max-min) 。计数排序比较适用于，输入数组中最大值和最小值的差不特别大于元素个数的情况。但计数排序可以用作别的排序的子过程，例如<a href="/algorithm/Radix-sort">基数排序</a>，基数排序可以很好的处理上述情况。</p><h2 id="实现">实现</h2><p>计数排序假设，输入数组是一组从0开始，最大值不超过k（即小于等于k）的整型数组。在某些情况下，k可能已知，比如十进制数的基数排序中k=9。在未知的时候，需要通过遍历数组，得出k的值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">counting_sort(A, B, k):   <span class="comment"># A：输入；B：输出 ；k：A中的最大值</span></span><br><span class="line">    C = new array[k+<span class="number">1</span>]    <span class="comment"># C：辅助数组</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to A.length - <span class="number">1</span>:</span><br><span class="line">        C[A[i]] = C[A[i]] + <span class="number">1</span></span><br><span class="line">    <span class="comment"># C[i] now means that A has C[i] elements equal to i</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to k:</span><br><span class="line">        C[i] = C[i] + C[i + <span class="number">1</span>]</span><br><span class="line">    <span class="comment"># C[i] now means that A has C[i] elements equal to or less than i</span></span><br><span class="line">    <span class="keyword">for</span> j = A.length - <span class="number">1</span> to <span class="number">0</span>:</span><br><span class="line">        B[C[A[i]] - <span class="number">1</span>] = A[i]</span><br><span class="line">        C[A[i]] = C[A[i]] - <span class="number">1</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>通过一个简单的例子来理解这段伪代码。</p><table><thead><tr class="header"><th>序号</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr class="odd"><td>数组A</td><td>2</td><td>5</td><td>3</td><td>0</td><td>2</td><td>3</td><td>0</td><td>3</td></tr><tr class="even"><td>第一个循环后C的值</td><td>2</td><td>0</td><td>2</td><td>3</td><td>0</td><td>1</td><td></td><td></td></tr><tr class="odd"><td>第二个循环后C的值</td><td>2</td><td>2</td><td>4</td><td>7</td><td>7</td><td>8</td><td></td><td></td></tr><tr class="even"><td>j=7，C[A[7]]=C[3]=7，有7个数小于3，则B[6]=A[7]</td><td></td><td></td><td></td><td></td><td></td><td></td><td>3</td><td></td></tr><tr class="odd"><td>C[3]-=1</td><td>2</td><td>2</td><td>4</td><td>6</td><td>7</td><td>8</td><td></td><td></td></tr><tr class="even"><td>j=6，……</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>Q: 为什么不在第一个循环之后借助数组C直接输出排序后的数组？</p><p>A: 保证计数排序算法的稳定性（如果不要求排序结果的稳定性可以这样做）。在下面的基数排序算法中，计数排序通常作为子排序过程出现，而且为了保证基数排序是正确的，子排序过程必须是稳定的。</p><h2 id="分析">分析</h2><p>计数排序的代码只有三个循环，第一个和第三个循环执行n次，第二个循环执行k次，每个循环的单次运行时间都是<span class="math inline">\(\Theta(1)\)</span>。所以总运行时间是<span class="math inline">\(T(n)=2\Theta(n)+\Theta(k)=\Theta(k+n)\)</span>。当<span class="math inline">\(k=\Theta(n)\)</span>的时候，即数组中的最大值随数组大小线性变化时，<span class="math inline">\(T(n)=\Theta(n)\)</span>，计数排序可以在线性时间内完成排序。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counting_sort</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    c = [<span class="number">0</span>] * (max(a) + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">        c[a[i]] += <span class="number">1</span>  <span class="comment"># C[i] now contains the number of elements equal to i.</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(c)):</span><br><span class="line">        c[i] += c[i - <span class="number">1</span>]  <span class="comment"># C[i] now contains the number of elements less than or equal to i.</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        b[c[a[i]] - <span class="number">1</span>] = a[i]</span><br><span class="line">        c[a[i]] -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="基数排序">基数排序</h1><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字（位数不足的数字高位补零），然后按每个位数分别比较。基数排序最初是应用在卡片排序机上的算法，可以被“机械编程”。</p><h2 id="实现-1">实现</h2><p>基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital）。LSD即从最低位开始比较，MSD相反，从最高位开始比较。</p><ul><li><p>MSD的排序过程：按最高有效位进行排序，按最高位分别放入“容器0-9”，然后按下一个最高位递归的对每个容器中的数进行排序。</p><p>使用MSD排序一组数的例子如下，表中省略了没有数的容器：</p></li></ul><table><colgroup><col style="width: 18%"><col style="width: 20%"><col style="width: 20%"><col style="width: 20%"><col style="width: 18%"></colgroup><thead><tr class="header"><th>输入数组</th><th>按最高位排序后</th><th>递归排序容器0和1</th><th>递归排序容器0</th><th>按序收集</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\begin{aligned}004\\178\\045\\009\\135\end{aligned}\)</span></td><td><span class="math inline">\(\begin{aligned}&amp;容器0\begin{cases}004\\045\\009\end{cases}\\&amp;容器1\begin{cases}178\\135\end{cases}\end{aligned}\)</span></td><td><span class="math inline">\(\begin{aligned}&amp;容器0\begin{cases}容器0\begin{cases}004\\009\end{cases}\\容器4：045\\\end{cases}\\&amp;容器1\begin{cases}容器3：135\\容器7：178\end{cases}\end{aligned}\)</span></td><td><span class="math inline">\(\begin{aligned}&amp;容器0\begin{cases}容器0\begin{cases}容器4：004\\容器9：009\end{cases}\\容器4：045\end{cases}\\&amp;容器1\begin{cases}容器3：135\\容器7：178\end{cases}\end{aligned}\)</span></td><td><span class="math inline">\(\begin{aligned}004\\009\\045\\135\\178\end{aligned}\)</span></td></tr></tbody></table><ul><li><p>LSD的排序过程：按最低有效位进行排序，将排序结果放入同一个”容器“，然后按下一个最低位重复排序，再收集，直至最高位排序完成。</p><p>同样的输入，使用LSD排序的例子如下（注意稳定性）：</p></li></ul><table><colgroup><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"></colgroup><thead><tr class="header"><th>输入数组</th><th>按最低位排序后</th><th>第二低位</th><th>第三低位</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\begin{aligned}004\\178\\045\\009\\135\end{aligned}\)</span></td><td><span class="math inline">\(\begin{aligned}004\\045\\135\\178\\009\end{aligned}\)</span></td><td><span class="math inline">\(\begin{aligned}004\\009\\135\\045\\178\end{aligned}\)</span></td><td><span class="math inline">\(\begin{aligned}004\\009\\045\\135\\178\end{aligned}\)</span></td></tr></tbody></table><hr><p>在MSD排序中，例如第二列中，为了排序容器0中的数，容器1-9中的数必须先放一边保存起来，每次递归都需要额外准备10个“容器”用来保存排序结果。如果递归深度比较大，MSD会占用非常多的空间。</p><p>相比之下，LSD只需要10个“容器”，在下一次循环开始前，“容器”中的数被收集起来，“容器”可以重复使用。</p><p>因此基数排序采用LSD进行排序，也因此要求子过程必须是稳定的。即高位的比较结果不能破坏低位的比较结果。</p><p>例如004和009：</p><p>在最低位上通过排序确定了004在009之前（4&lt;9）。</p><p>下一个最低有效位都是0，004和009之间的次序应该由较低位（即上一次排序结果）决定。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">radix_sort(A, d):</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to d:  <span class="comment"># d 是有效位数</span></span><br><span class="line">        use a stable sort to sort array A on i</span><br></pre></td></tr></table></figure><p>对于十进制数字来说，每一位只会出现10种数字（0-9），因此计数排序是一个好的选择。</p><h2 id="分析-1">分析</h2><p>基数排序的时间代价依赖于所使用的稳定的排序算法。如果子过程是计数排序的话，则基数排序的时间复杂度可以描述为<span class="math inline">\(d\Theta(n+k)=\Theta(d(n+k))\)</span>。当d为常数（位数固定）且k=O(n)（每位数字都在0到k-1区间内）时，基数排序具有线性时间代价。</p><h2 id="代码-1">代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="string">"""十进制数的基数排序算法"""</span></span><br><span class="line">    c, b = [], [<span class="literal">None</span>] * len(a)  <span class="comment"># b is an auxiliary list, c share the same meaning with list c in counting sort</span></span><br><span class="line">    digit, _max = <span class="number">1</span>, max(a)</span><br><span class="line">    <span class="keyword">while</span> _max // digit &gt; <span class="number">0</span>:</span><br><span class="line">        c = [<span class="number">0</span>] * <span class="number">10</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">            c[(a[i] // digit) % <span class="number">10</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(c)):</span><br><span class="line">            c[i] += c[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(len(a))):</span><br><span class="line">            target = (a[i] // digit) % <span class="number">10</span></span><br><span class="line">            b[c[target] - <span class="number">1</span>] = a[i]</span><br><span class="line">            c[target] -= <span class="number">1</span></span><br><span class="line">        a[:] = b[:]</span><br><span class="line">        digit *= <span class="number">10</span></span><br></pre></td></tr></table></figure><h1 id="桶排序">桶排序</h1><p>桶排序（Bucket sort）或箱排序，工作原理是将数组分到有限数量的桶里。每个桶再个别排序。</p><p>计数排序假设输入数据都属于一个小区间内的整数，桶排序也对输入作了某种假设。桶排序假设输入服从均匀分布，平均情况下时间代价为O(n)。</p><h2 id="实现-2">实现</h2><p>桶排序将[0,1)区间划分为k个大小相同的子区间，或称为桶。然后，将n个输入数分别放到各个桶中。对每个桶中的数进行排序，然后遍历每个桶，按照次序把各个桶中的元素列出来即可。因为输入是均匀、独立地分布在[0,1)区间上，所以一般不会出现很多数落在同一个桶中的情况。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bucket_sort(A):</span><br><span class="line">    n = A.length</span><br><span class="line">    B = new array[k]</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to k - <span class="number">1</span>:</span><br><span class="line">        make B[i] an empty list        <span class="comment"># make k buckets</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to n - <span class="number">1</span>:</span><br><span class="line">        insert A[i] into list B[floor(k * A[i])]</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to k - <span class="number">1</span>:</span><br><span class="line">        sort list B[i] <span class="keyword">with</span> insertion sort</span><br><span class="line">    concatenate the lists B[<span class="number">0</span>], B[<span class="number">1</span>],...,B[k<span class="number">-1</span>] together <span class="keyword">in</span> order</span><br></pre></td></tr></table></figure><p>例如k=10时，排序一组数的过程如下：</p><table><thead><tr class="header"><th>输入</th><th>所属桶<span class="math inline">\(\lfloor{k * A[i]}\rfloor\)</span></th><th>桶序号</th><th>桶中元素</th><th>排序后桶中元素</th></tr></thead><tbody><tr class="odd"><td>0.78</td><td>7（<span class="math inline">\(\lfloor10 * 0.78\rfloor=7\)</span>）</td><td>0</td><td></td><td></td></tr><tr class="even"><td>0.17</td><td>1</td><td>1</td><td>0.17、0.12</td><td>0.12、0.17</td></tr><tr class="odd"><td>0.39</td><td>3</td><td>2</td><td>0.26、0.21、0.23</td><td>0.21、0.23、0.26</td></tr><tr class="even"><td>0.26</td><td>2</td><td>3</td><td>0.39</td><td>0.39</td></tr><tr class="odd"><td>0.72</td><td>7</td><td>4</td><td></td><td></td></tr><tr class="even"><td>0.94</td><td>9</td><td>5</td><td></td><td></td></tr><tr class="odd"><td>0.21</td><td>2</td><td>6</td><td>0.68</td><td>0.68</td></tr><tr class="even"><td>0.12</td><td>1</td><td>7</td><td>0.78、0.72</td><td>0.72、0.78</td></tr><tr class="odd"><td>0.23</td><td>2</td><td>8</td><td></td><td></td></tr><tr class="even"><td>0.68</td><td>6</td><td>9</td><td>0.94</td><td>0.94</td></tr></tbody></table><p>遍历桶中元素即可得到排序结果。</p><h2 id="分析-2">分析</h2><p>除去调用插入排序的代码，其他代码可以在<span class="math inline">\(\Theta(1)\)</span>时间内完成。已知插入排序的时间复杂度为<span class="math inline">\(O(n^2)\)</span>，n为元素个数。桶排序对每个桶都调用了插入排序，桶中有多少元素直接影响到时间代价。设桶i中的元素个数为<span class="math inline">\(n_i\)</span>，则桶排序的时间代价可以描述为：</p><p><span class="math display">\[T(n)=\Theta(n)+\sum_{i=0}^{k-1}{O(n_i^2)}\]</span></p><p>虽然无法准确直到每个桶中元素个数，从而无法计算上述时间代价。但可以计算其期望。通过对上式求期望：</p><p><span class="math display">\[\begin{aligned}E[T(n)]&amp;=E[\Theta(n)+\sum_{i=0}^{k-1}{O(n_i^2)}]\\&amp;=\Theta(n)+\sum_{i=0}^{k-1}{E[O(n_i^2)]}\\&amp;=\Theta(n)+\sum_{i=0}^{k-1}{O(E[n_i^2])}\end{aligned}\]</span></p><p>桶排序假设输入服从均匀分布，因此可以认为元素落到每个桶的概率是相同的，为1/k。n个元素分到k个桶（设为随机变量X），X服从参数为n和1/k的二项分布，即<span class="math inline">\(X\sim{b(n,1/k)}\)</span>。通过二项分布的期望和方差可以快速计算出<span class="math inline">\(E(n_i^2)\)</span>。</p><p><span class="math display">\[\begin{aligned}E(n_i^2)&amp;=E(X^2)\\&amp;=V(X)+(E(X))^2\\&amp;=n\frac{1}{k}(1-\frac{1}{k})+(n\frac{1}{k})^2\\&amp;=\frac{n^2+nk-n}{k^2}\end{aligned}\]</span></p><p>由此可以得出桶排序的期望时间代价为</p><p><span class="math display">\[\begin{aligned}E[T(n)]&amp;=\Theta(n)+\sum_{i=0}^{k-1}{O(E[n_i^2])}\\&amp;=\Theta(n)+kO(\frac{n^2+nk-n}{k^2})\\&amp;=\Theta(n)+O(\frac{n^2}{k}+n)\end{aligned}\]</span></p><p>如果桶的个数<span class="math inline">\(k=\Theta(n)\)</span>，则上式等于O(n)，桶排序可以在线性时间内结束。如果k=n，则桶排序近似等价于计数排序。</p><p>总结：虽然插入排序的时间复杂度是<span class="math inline">\(O(n^2)\)</span>，但在n比较小的时候同其他比较排序的差距并不明显。桶排序就是将原数组分到不同的桶中，使得各个桶中的元素个数比较小且桶之间满足次序关系，再对桶中元素使用插入排序。</p><h2 id="代码-2">代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> insertion_sort <span class="keyword">import</span> insertion_sort</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucket_sort</span><span class="params">(a)</span>:</span></span><br><span class="line">    b = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a))]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">        b[math.floor(len(a) * a[i])].append(a[i])</span><br><span class="line">    a.clear()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(b)):</span><br><span class="line">        insertion_sort(b[i])</span><br><span class="line">        a.extend(b[i])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort </tag>
            
            <tag> Introduction to Algorithms </tag>
            
            <tag> algorithms </tag>
            
            <tag> non-comparison sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插入排序、选择排序和冒泡排序</title>
      <link href="/notes/introduction-to-algorithms/insertion-sort-selection-sort-and-bubble-sort/"/>
      <url>/notes/introduction-to-algorithms/insertion-sort-selection-sort-and-bubble-sort/</url>
      
        <content type="html"><![CDATA[<h1 id="插入排序">插入排序</h1><p>对于少量元素的排序，插入排序（Insertion sort）是一个有效的算法。插入排序的工作方式像许多人排序一手扑克牌。开始时左手为空，每次从桌子上拿走一张牌并将它插入左手中正确的位置。插入排序将输入数组分成未排序部分和已排序部分两个子数组，初始时已排序部分为空（或者有一个，因为一个数的数组是已排序的），每次迭代从未排序数组中选择一个元素，将其放入已排序数组中的合适位置。</p><p>插入排序示意图（出自<a href="https://en.wikipedia.org/wiki/Insertion_sort" target="_blank" rel="noopener">维基百科：Insertion sort</a>）：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif" title="插入排序动态示意图"></p><h2 id="实现">实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">insertion_sort(A):</span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">1</span> to A.length - <span class="number">1</span>:</span><br><span class="line">        key = A[j]</span><br><span class="line">        <span class="comment"># Insert A[j] into the sorted sequence A[1...j-1]</span></span><br><span class="line">        i = j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> A[i] &gt; key:</span><br><span class="line">            A[i + <span class="number">1</span>] = A[i]</span><br><span class="line">            i = i - <span class="number">1</span></span><br><span class="line">        A[i + <span class="number">1</span>] = key</span><br></pre></td></tr></table></figure><a id="more"></a><p>循环不变式（<a href="https://en.wikipedia.org/wiki/Loop_variant" title="Loop variant" target="_blank" rel="noopener">Loop variant</a>）用来帮助理解算法的正确性。关于循环不变式，必须证明三条性质。</p><ul><li>初始化：循环的第一次迭代前，它为真。</li><li>保持：如果循环的某次迭代前它为真，那么下次迭代前它仍为真。</li><li>终止：在循环终止时，不变式提供一个有用的性质，该性质有助于证明算法是正确的。</li></ul><p>（类似于数学归纳法）</p><p>用下面的循环不变式证明插入排序算法的正确性。</p><blockquote><p>在for循环的每次迭代开始前，子数组<code>A[0...(j-1)]</code>由原来在<code>A[0...(j-1)]</code>中的元素组成，但已按序排列。</p></blockquote><ul><li>初始化：循环的第一次迭代前，j=1，子数组只包含A[0]，它为真。</li><li>保持：for循环里面嵌套了一个while循环，同样可以用另一个循环不变式证明它。但对于简单的循环，同样可以通过非形式化的分析证明其正确性。非形式化地，while循环将 A[j-1], A[j-2]等向右移动一个位置，直到找到A[j]的适当位置。最后将A[j]插入该位置。此时，子数组<code>A[0...(j)]</code>由原来在 <code>A[0...(j)]</code>中的元素组成，但已按序排列。那么下一次迭代增加j，上述循环不变式为真。</li><li>终止：循环终止时j=A.length，则根据循环不变式子数组<code>A[0...(A.length-1)]</code>由原来在<code>A[0...(A.length-1)]</code>中的元素组成，但已按序排列。此时<code>A[0...(A.length-1)]</code>就是整个数组。因此该算法正确。</li></ul><h2 id="分析">分析</h2><p>在for循环内部，除去while循环的语句执行时间均为<span class="math inline">\(\Theta(1)\)</span>（即常数时间内），for循环执行n-1次。while循环的运行时间与数组的已排序程度有关系。若输入数组已按递增序排好，则导致最佳情况。若输入数组已反向排序，即按递减序排好，则导致最坏情况。在while循环处，必须将每个元素 A[j]与整个已排序子数组<code>A[0...(j-1)]</code>中每个元素进行比较。</p><table><thead><tr class="header"><th>j</th><th>最佳时比较元素</th><th>比较次数</th><th>最坏时比较元素</th><th>比较次数</th></tr></thead><tbody><tr class="odd"><td>1</td><td>A[0]</td><td>1</td><td>A[0]</td><td>1</td></tr><tr class="even"><td>2</td><td>A[1]</td><td>1</td><td>A[0, 1]</td><td>2</td></tr><tr class="odd"><td><span class="math inline">\(\vdots\)</span></td><td><span class="math inline">\(\vdots\)</span></td><td><span class="math inline">\(\vdots\)</span></td><td><span class="math inline">\(\vdots\)</span></td><td><span class="math inline">\(\vdots\)</span></td></tr><tr class="even"><td>n-1</td><td>A[n-2]</td><td>1</td><td><code>A[0...(n-2)]</code></td><td>n-1</td></tr></tbody></table><p>最佳情况下，while循环的执行时间为<span class="math inline">\(\sum_{n=1}^{n-1}1=n-1\)</span>。</p><p>最佳运行时间为<span class="math inline">\(T(n)=(n-1)\Theta(1)+n-1=\Theta(n)\)</span>。它是n的线性函数。</p><p>最坏情况下，while循环的执行时间为<span class="math inline">\(\sum_{n=1}^{n-1}n=\frac{n(n-1)}{2}\)</span>。</p><p>所以，插入排序的最坏情况运行时间为<span class="math inline">\(T(n)=(n-1)\Theta(1)+\frac{n(n-1)}{2}\le{n^2}=O(n^2)\)</span>。此时它是n的二次函数。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(a)):</span><br><span class="line">        key = a[j]</span><br><span class="line">        i = j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> a[i] &gt; key:</span><br><span class="line">            a[i + <span class="number">1</span>] = a[i]</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        a[i + <span class="number">1</span>] = key</span><br></pre></td></tr></table></figure><h2 id="最坏最佳与平均情况">最坏、最佳与平均情况</h2><p>最坏情况比最佳情况更加有用，算法导论给出了三点理由。</p><ul><li>一个算法的最坏情况运行时间给出了任何输入的运行时间的一个上界。知道了这个界，就能确保该算法绝不需要更长的时间。</li><li>对某些算法，最坏情况经常出现。例如，当数据库中检索一条特定信息时，若该信息不在数据库中出现，则检索算法的最坏情况会出现。在某些应用中，对缺失信息的检索可能是频繁的。</li><li>“平均情况”往往与最坏情况大致一致。假定随机选择n个数并应用插入排序。平均来说，<code>A[0...(j-1)]</code>中的一般元素小于A[j]，一半元素大于A[j]。所以，平均来说，每次while循环的比较次数大约为j/2。导致平均情况运行时间结果像最坏情况运行时间一样，也是输入规模的一个二次函数。</li></ul><p>在某些特定情况下，会对一个算法的平均情况运行时间感兴趣。平均情况分析的范围有限，因为对于特定的问题，什么构成一种“平均”输入并不明显。</p><h1 id="选择排序">选择排序</h1><p>如果说插入排序是拿一张牌去找在左手中的位置，那么选择排序就是找出最小的牌，放到左手的末位（或者找最大的牌，放到左手的首位）。与插入排序类似，选择排序也将输入数组分成已排序和未排序两个子数组，每次迭代选择未排序数组中最小（或最大，取决于排序规则）的元素，将其与未排序子数组的第一位元素交换，然后扩展已排序数组的边界加一。</p><p>选择排序示意图（出自<a href="https://en.wikipedia.org/wiki/Selection_sort" title="Selection sort" target="_blank" rel="noopener">维基百科：Selection sort</a>）：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif" title="选择排序动态示意图"></p><h2 id="实现-1">实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">selection_sort(A):</span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">0</span> to A.length - <span class="number">2</span>:</span><br><span class="line">        i_min = j</span><br><span class="line">        <span class="keyword">for</span> i = j + <span class="number">1</span> to A.length - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> A[i] &lt; A[i_min]:</span><br><span class="line">                i_min = i</span><br><span class="line">        <span class="keyword">if</span> i_min != j:</span><br><span class="line">            exchange A[i_min] <span class="keyword">with</span> A[j]</span><br></pre></td></tr></table></figure><h2 id="分析-1">分析</h2><p>外层循环执行n-1次，单次运行时间为<span class="math inline">\(\Theta(1)\)</span>。内层循环寻找下一个最小的数执行n-1-j次，单次运行时间也是<span class="math inline">\(\Theta(1)\)</span>。</p><p>总运行时间为：</p><p><span class="math display">\[\begin{aligned}T(n)&amp;=n-1+\sum_{j=0}^{n-2}n-i-j \\&amp;=n-1+\sum_{i=1}^{n-1}n-i \\&amp;=n-1+\frac{n(n-1)}{2} \\&amp;=O(n^2)\end{aligned}\]</span></p><h2 id="代码-1">代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(a) - <span class="number">1</span>):</span><br><span class="line">        i_min = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(j + <span class="number">1</span>, len(a)):</span><br><span class="line">            <span class="keyword">if</span> a[i] &lt; a[i_min]:</span><br><span class="line">                i_min = i</span><br><span class="line">        <span class="keyword">if</span> i_min != j:</span><br><span class="line">            a[i_min], a[j] = a[j], a[i_min]</span><br></pre></td></tr></table></figure><h1 id="冒泡排序">冒泡排序</h1><p>冒泡排序（Bubble sort）通过依次比较两个相邻的元素，如果它们的顺序关系是错误的，就交换它们。正如它的命名一样，比较大的元素先浮到数组顶端。</p><p>冒泡排序示意图（出自<a href="https://en.wikipedia.org/wiki/Bubble_sort" title="冒泡排序" target="_blank" rel="noopener">维基百科：Bubble sort</a>）：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif" title="冒泡排序动态示意图"></p><h2 id="实现-2">实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bubble_sort(A):</span><br><span class="line">    n = A.length</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to n - <span class="number">1</span>:       <span class="comment"># 每次循环将下一个最大元素冒泡到正确位置</span></span><br><span class="line">        swapped = false</span><br><span class="line">        <span class="keyword">for</span> j = <span class="number">1</span> to n - i:   <span class="comment"># 后i位元素大于之前的元素且已经排好序</span></span><br><span class="line">            <span class="keyword">if</span> A[j - <span class="number">1</span>] &gt; A[j]:</span><br><span class="line">                exchange A[j] <span class="keyword">with</span> A[j - <span class="number">1</span>]</span><br><span class="line">                swapped = true</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> swapped:       <span class="comment"># 结束排序</span></span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h3 id="优化">优化</h3><p>与其记录swapped=true or false，不如记录下最后发生交换的位置i，之后没有发生交换意味着i之后的元素全部大于i之前的元素且已经按序排好。那么在下次冒泡前，结束位置可以直接跳到i。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bubble_sort(A):</span><br><span class="line">    target = A.length</span><br><span class="line">    <span class="keyword">while</span> target &gt; <span class="number">1</span>:</span><br><span class="line">        last_swap = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j = <span class="number">1</span> to target - <span class="number">1</span>:   <span class="comment"># target及target之后的元素大于之前的元素且已经排好序</span></span><br><span class="line">            <span class="keyword">if</span> A[j - <span class="number">1</span>] &gt; A[j]:</span><br><span class="line">                exchange A[j] <span class="keyword">with</span> A[j - <span class="number">1</span>]</span><br><span class="line">                last_swap = j</span><br><span class="line">        target = last_swap</span><br></pre></td></tr></table></figure><h2 id="分析-2">分析</h2><p>冒泡排序的平均时间和最坏时间复杂度为<span class="math inline">\(O(n^2)\)</span>。在实际应用中，时间复杂度同样是<span class="math inline">\(O(n^2)\)</span>的插入排序一般比冒泡排序要快，更不用说还有其他更快的排序算法。</p><p>冒泡排序可以用来检测一个数组是否已经排好序，即冒泡排序的最佳情况运行时间O(n)。插入排序同样可以在O(n)时间内检测一个数组是否排好序，且比冒泡排序好。</p><h2 id="代码-2">代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(a)</span>:</span></span><br><span class="line">    target = len(a)</span><br><span class="line">    <span class="keyword">while</span> target &gt; <span class="number">1</span>:</span><br><span class="line">        last_swapped = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, target):</span><br><span class="line">            <span class="keyword">if</span> a[j - <span class="number">1</span>] &gt; a[j]:</span><br><span class="line">                a[j - <span class="number">1</span>], a[j] = a[j], a[j - <span class="number">1</span>]</span><br><span class="line">                last_swapped = j</span><br><span class="line">        target = last_swapped</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort </tag>
            
            <tag> Introduction to Algorithms </tag>
            
            <tag> algorithms </tag>
            
            <tag> comparison sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆和堆排序</title>
      <link href="/notes/introduction-to-algorithms/heaps-and-heapsort/"/>
      <url>/notes/introduction-to-algorithms/heaps-and-heapsort/</url>
      
        <content type="html"><![CDATA[<h1 id="堆">堆</h1><p>堆（Heap）始于<a href="https://en.wikipedia.org/wiki/J._W._J._Williams" target="_blank" rel="noopener">J. W. J. Williams</a>在 1964 年发表的堆排序（heap sort）。</p><p>堆是一种基于树的数据结构，一棵满足以下性质的完全树可称为堆。</p><blockquote><p>给定堆中任意节点 <code>P</code> 和 <code>C</code>，若 <code>P</code> 是 <code>C</code> 的母节点，那么 <code>P</code> 的值小于等于（或大于等于）<code>C</code> 的值。</p><ol type="1"><li>若 <code>P</code> 的值小于等于 <code>C</code> 的值，称为最小堆（min heap）。</li><li>若 <code>P</code> 的值大于等于 <code>C</code> 的值，称为最大堆（max heap）。</li></ol></blockquote><p>在堆中最顶端的节点称为根节点（root node），根节点本身没有母节点（parent node）。</p><p>常见的堆有二叉堆、斐波那契堆等。</p><a id="more"></a><h1 id="操作">操作</h1><p>一个堆应该支持以下常见操作（参考了<a href="https://en.wikipedia.org/wiki/Heap_(data_structure)" title="Heap" target="_blank" rel="noopener">维基百科</a>）。</p><ul><li><code>peek()</code>：返回堆顶元素。</li><li><code>pop()</code>：返回并移除堆顶元素，需要调整堆。</li><li><code>append(x)</code>：添加一个新的元素​，需要调整堆以满足堆的性质。</li><li><code>replace()</code>：相当于一次 <code>pop</code> 之后 <code>append</code>。但比分别执行更效率，因为只需要调整一次堆。</li></ul><hr><ul><li><code>heapify()</code>：创建一个堆。只需要调用一次。</li><li><code>merge(other)</code>：合并 other 中的元素到堆。</li></ul><hr><ul><li><code>size()</code>：返回堆中元素个数。</li><li><code>is_empty()</code>：返回是否是空堆。</li></ul><hr><ul><li><code>increase_key(i, x)</code>：增大元素的值。</li><li><code>decrease_key(i, x)</code>：减小元素的值。</li><li><code>delete(i)</code>：删除指定的一个元素。</li><li><code>sift_up(i)</code>：不断上移元素，直到满足最小堆的性质。</li><li><code>sift_down(i)</code>：不断下移元素，直到满足最大堆的性质。</li></ul><h1 id="实现">实现</h1><p>堆通常用数组（静态或动态）实现，并且不需要保存指针。</p><p>树的根节点是 <code>A[0]</code>，给定一个节点的下标 <code>i</code>，通过计算可以得到它的母节点、左孩子和右孩子节点。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parent(i):</span><br><span class="line">    <span class="keyword">return</span> floor((i<span class="number">-1</span>) / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">left_child(i):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">right_child(i):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">2</span></span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-algorithms/heap-and-array.png"></p><h2 id="维护堆的性质">维护堆的性质</h2><p>以最大堆为例，如何维护一个数组使之满足最大堆性质。考虑下面这种情况。</p><ul><li>前提条件：<strong>根节点</strong>为 <code>left_child(i)</code> 和 <code>right_child(i)</code> 的二叉树都是最大堆。</li></ul><p><code>A[i]</code> 有可能小于其孩子节点，这违背了最大堆的性质。<code>sift_down()</code> 方法通过让 <code>A[i]</code> 在最大堆中“逐级下降”，从而使下标为 <code>i</code> 的子树重新遵循最大堆的性质。</p><p><img src="/uploads/image/introduction-to-algorithms/heap-sift-down.png"></p><p>关于逐级下降正确性的思考：满足前提条件的情况下，</p><p>假设根节点 <code>i</code> 有子节点 <code>x, y</code>，其中值最大的是子节点 <code>x</code>。交换 <code>i</code> 与 <code>x</code> 的值，现在 <code>A[i] &gt; A[x]</code>，满足最大堆的性质。但 <code>x</code> 的值相比交换前变小了，所以可能小于其子节点的值。</p><p>现在节点 <code>x</code> 可能小于其子节点的值，其子节点均大于或等于下一层子节点的值。符合前提条件，所以对 <code>x</code> 递归调用 <code>sift_down</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sift_down(A, i):</span><br><span class="line">    l = left_child(i)</span><br><span class="line">    r = right_child(i)</span><br><span class="line">    <span class="keyword">if</span> l &lt; size() <span class="keyword">and</span> A[l] &gt; A[i]:  <span class="comment"># 找最大值</span></span><br><span class="line">        largest = l</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        largest = i</span><br><span class="line">    <span class="keyword">if</span> r &lt; size() <span class="keyword">and</span> A[r] &gt; A[largest]:</span><br><span class="line">        largest = r</span><br><span class="line">    <span class="keyword">if</span> largest != i:              <span class="comment"># 违反最大堆性质</span></span><br><span class="line">        exchange A[i] <span class="keyword">with</span> A[largest]</span><br><span class="line">        sift_down(A, largest)     <span class="comment"># 递归</span></span><br></pre></td></tr></table></figure><p><code>sift_down</code> 的时间复杂度：</p><p>在一棵大小为 <code>n</code> ​的子树上，运行 <code>sift_down</code> 的时间 <code>T(n)</code> 包括：比较三个节点大小关系以及交换值的时间代价 <span class="math inline">\(\Theta(1)\)</span>，加上在一棵子树上运行 <code>sift_down</code> 的时间。子树的大小至多为 <code>2n/3</code>（最底层正好半满的时候，即最后一层左子树节点填满，右子树节点是空的），由此可以得到刻画程序运行时间的递归式：<span class="math inline">\(T(n)\le\Theta(1)+T(2n/3)\)</span>。解得 <span class="math inline">\(T(n)=O(\lg{n})\)</span>。</p><p>也就是说，对于一棵树高为 <code>h</code> 的节点来说，<code>sift_down</code> 的时间复杂度是 <span class="math inline">\(O(h)\)</span>。</p><p>关于一棵子树的大小至多为 <code>2n/3</code> 的由来。</p><p>首先明确关于树的两个性质：</p><ol type="1"><li>如果以某个节点为根节点的树是完全树，那么它的左子树大小大于等于右子树大小。因为完全树的最后一层是从左到右填入的。</li><li>如果一棵满二叉树的最后一层节点数目为 <code>n</code>，那么这个树的大小为 <code>2n-1</code>。因为满二叉树第 <code>i(i&gt;=0)</code> 层节点数量是 <span class="math inline">\(2^i\)</span>。</li></ol><p>根据性质 1，只需要考虑左子树最多为母树的几分之几即可。</p><p>假设一个完全树的大小为 <code>n</code>，它的左子树大小为 <code>i</code>，比值 <code>i/n</code> 根据最底层节点数目而变动。观察最底层节点数目从 0 逐渐增长时该比值的变化情况。</p><ul><li><p>当新增节点属于左子树时，比值由 <code>i/n</code> 变成 <code>(i+1)/(n+1)</code>，比值增大。</p></li><li><p>当新增节点属于右子树时，比值由 <code>i/n</code> 变成 <code>i/(n+1)</code>，比值减小。</p></li></ul><p>因此当左子树恰好填满（最底层恰好半满）时，比值最大。</p><p>设此时最低层节点个数为 <code>x</code>，注意这 <code>x</code> 个节点正好填满左子树最底层，则根据性质 2，<code>i=2x-1</code>，<span class="math inline">\(n=2*i+1-x=3x-1\)</span>。</p><p>所以得到 <span class="math inline">\(i/n=(2x-1)/(3x-1)\le2/3\)</span>。即大小为 <code>n</code> 的树中，子树的大小至多为 <code>2n/3</code>。</p><h2 id="建堆">建堆</h2><p>同样以最大堆为例，可以用<strong>自底向上</strong>的方法调用过程 <code>sift_down</code>，将一个数组转换为最大堆。过程 <code>heapify</code> 对树中非叶子节点都调用一次 <code>sift_down</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">heapify(A):</span><br><span class="line">    <span class="keyword">for</span> i = parent(size()<span class="number">-1</span>) downto <span class="number">0</span>:</span><br><span class="line">        sift_down(A, i)</span><br></pre></td></tr></table></figure><p>可以使用如下的循环不变量验证该过程的正确性。</p><blockquote><p>每一次 <code>for</code> 循环开始前，节点 <code>i, i+1, ..., size()</code> 都是一个最大堆的根节点。</p></blockquote><p>需要证明此循环不变量在循环开始前，迭代时以及结束后都成立。</p><ul><li>初始化：第一次迭代前，<code>i</code> 之后的节点都是叶节点，因此它们都是最大堆的根节点。</li><li>保持：注意到节点 <code>i+1</code>​ 始终比i先调用 <code>sift_down</code> 过程，根据循环不变量，它们都是最大堆的根节点。</li><li>终止：终止时 <code>i=-1​</code>，根据循环不变量节点 <code>0,1,...,size()</code> 都是最大堆的根节点，特别的，0 是堆的顶点。</li></ul><p>之前分析了 <code>sift_down(A, i)</code> 的运行时间与节点 <code>i</code> 所处高度有关，在建堆过程中，不同的节点所处高度可能不同，想准确计算建堆的时间复杂度利用了下面所示的树的特性。</p><ul><li>一棵含有 <code>n</code> 个元素的完全树，在高度 <code>h</code> 处，最多有 <span class="math inline">\(\lceil{n/2^{h+1}}\rceil\)</span> 个元素。根节点所处高度为 0。</li></ul><p>根据这条性质，运行时间可以刻画为</p><p><span class="math display">\[\begin{aligned}T(n)&amp;=\sum_{h=0}^{\lfloor\log_{2}n\rfloor}\lceil{n/2^{h+1}}\rceil*O(h)\\&amp;=O(n\sum_{h=0}^{\lfloor\log_{2}n\rfloor}\frac{h}{2^h})\end{aligned}\\\begin{aligned}\because&amp;\sum_{k=0}^{\infty}kx^k=\frac{x}{(1-x)^2}(|x|\le1)\\\therefore&amp;\sum_{h=0}^{\infty}\frac{h}{2^h}=\frac{1/2}{(1-\frac{1}{2})^2}=2\end{aligned}\]</span></p><p>将其带入可得</p><p><span class="math display">\[\begin{aligned}T(n)&amp;=O(n\sum_{h=0}^{\infty}\frac{h}{2^h})\\&amp;=O(n)\end{aligned}\]</span> 由此可得出结论，<code>heapify</code> 可以在线性时间内将一个数组转换成一个堆。</p><h2 id="其他方法">其他方法</h2><ul><li><code>sift_up</code>：与 <code>sift_down</code> 相反，当节点 <code>i</code> 的值大于其母节点的值，而其他节点均满足堆的性质时，通过此过程将节点i不断上移，直到满足堆的性质。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sift_up(A, i):</span><br><span class="line">    <span class="keyword">while</span> i&gt;<span class="number">1</span> <span class="keyword">and</span> A[parent(i)] &lt; A[i]:</span><br><span class="line">        exchange A[parent(i)] <span class="keyword">with</span> A[i]</span><br><span class="line">        i = parent(i)</span><br></pre></td></tr></table></figure><ul><li><code>increase_key</code>：当堆中某个节点的值变大时，可能大于其母节点，与上述情况相同。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">increase_key(A, i):</span><br><span class="line">    sift_up(A, i)</span><br></pre></td></tr></table></figure><ul><li><code>decrease_key</code>：与<code>sift_down</code>的情况相同。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">decrease_key(A, i):</span><br><span class="line">    sift_down(A, i)</span><br></pre></td></tr></table></figure><ul><li><code>replace</code>：更新后的值大于原来的值，调用 <code>increase_key</code>；小于原来的值，调用 <code>decrease_key</code>。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">replace(A, i, x):</span><br><span class="line">    <span class="keyword">if</span> A[i] &lt; x:</span><br><span class="line">        increase_key(A, i)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> A[i] &gt; x:</span><br><span class="line">        decrease_key(A, i)</span><br></pre></td></tr></table></figure><ul><li><code>append</code>：先添加一个值为无穷小的元素到堆的末尾，然后调用 <code>increase_key</code> 修改值。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">append(A, x):</span><br><span class="line">    A.heap_size = A.heap_size + <span class="number">1</span></span><br><span class="line">    A[A.heap_size - <span class="number">1</span>] = -inf</span><br><span class="line">    increase_key(A, A.heap_size - <span class="number">1</span>, x)</span><br></pre></td></tr></table></figure><hr><ul><li><code>peek</code>：第一个元素就是堆顶元素，直接返回即可。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">peek():</span><br><span class="line">    <span class="keyword">return</span> A[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><ul><li><code>pop</code>：将堆顶元素保存，然后用最后一个元素替换堆顶元素，删除最后一个元素。此时堆顶元素可能违背堆的性质，对其调用 <code>sift_down</code>。或者调用 <code>decrease_key</code> 将堆顶元素的值减小到最后一个元素值，两者调用的过程时一样的。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pop():</span><br><span class="line">    r = A[<span class="number">0</span>]</span><br><span class="line">    A[<span class="number">0</span>] = A[A.lenght - <span class="number">1</span>]</span><br><span class="line">    A.heap_size = A.heap_size - <span class="number">1</span></span><br><span class="line">    sift_down(A, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure><ul><li><code>delete</code>：与 <code>pop</code> 过程相同，<code>pop</code> 就是特殊的 <code>delete</code> 过程。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delete(A, i):</span><br><span class="line">    A[i] = A[A.lenght - <span class="number">1</span>]</span><br><span class="line">    A.heap_size = A.heap_size - <span class="number">1</span></span><br><span class="line">    sift_down(A, i)</span><br></pre></td></tr></table></figure><hr><ul><li><code>merge</code>：逐次调用 <code>append</code> 添加另一个堆中的元素。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">merge(A, o):</span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> o:</span><br><span class="line">        append(A, e)</span><br></pre></td></tr></table></figure><ul><li><code>meld</code>：取出两个堆中的元素，合并成新的列表，调用 <code>heapify</code> 创建堆。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">meld(A, B, C):</span><br><span class="line">    C = A + B</span><br><span class="line">    heapify(C)</span><br></pre></td></tr></table></figure><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parent</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="string">"""计算元素i的母节点位置"""</span></span><br><span class="line">    <span class="keyword">return</span> math.floor((i - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">left_child</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="string">"""计算元素i的左孩子节点位置"""</span></span><br><span class="line">    <span class="keyword">return</span> (i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">right_child</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="string">"""计算元素i的右孩子节点位置"""</span></span><br><span class="line">    <span class="keyword">return</span> (i &lt;&lt; <span class="number">1</span>) + <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(a, i, j)</span>:</span></span><br><span class="line">    <span class="string">"""交换元素i和j的值"""</span></span><br><span class="line">    a[i], a[j] = a[j], a[i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heap</span>:</span></span><br><span class="line">    <span class="string">"""最小堆"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回堆顶元素"""</span></span><br><span class="line">        <span class="keyword">return</span> self.value[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""删除并返回堆顶元素"""</span></span><br><span class="line">        <span class="keyword">if</span> self.size() &gt; <span class="number">1</span>:  <span class="comment"># 堆中元素多于2个时，pop()之后需要调整堆</span></span><br><span class="line">            m = self.value[<span class="number">0</span>]</span><br><span class="line">            self.value[<span class="number">0</span>] = self.value.pop(self.size() - <span class="number">1</span>)  <span class="comment"># 将堆尾元素移动到堆顶</span></span><br><span class="line">            self.sift_down(<span class="number">0</span>)  <span class="comment"># 调整堆</span></span><br><span class="line">            <span class="keyword">return</span> m</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 堆中元素少于2个时，直接调用list的pop()方法</span></span><br><span class="line">            <span class="keyword">return</span> self.value.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""添加元素"""</span></span><br><span class="line">        self.value.append(x)</span><br><span class="line">        self.decrease_key(self.size() - <span class="number">1</span>, x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replace</span><span class="params">(self, i, x)</span>:</span></span><br><span class="line">        <span class="string">"""替换元素的值，替换堆顶元素时指定i=0"""</span></span><br><span class="line">        <span class="keyword">if</span> self.value[i] &lt; x:</span><br><span class="line">            self.increase_key(i, x)</span><br><span class="line">        <span class="keyword">elif</span> self.value[i] &gt; x:</span><br><span class="line">            self.decrease_key(i, x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heapify</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""建堆"""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(parent(self.size() - <span class="number">1</span>), <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            self.sift_down(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="string">"""合并堆"""</span></span><br><span class="line">        self.value.extend(other)</span><br><span class="line">        self.heapify()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回堆的大小"""</span></span><br><span class="line">        <span class="keyword">return</span> len(self.value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""判断是否是空堆"""</span></span><br><span class="line">        <span class="keyword">return</span> self.size() == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increase_key</span><span class="params">(self, i, x)</span>:</span></span><br><span class="line">        <span class="string">"""增加元素的值"""</span></span><br><span class="line">        self.value[i] = x</span><br><span class="line">        self.sift_down(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decrease_key</span><span class="params">(self, i, x)</span>:</span></span><br><span class="line">        <span class="string">"""减小元素的值"""</span></span><br><span class="line">        self.value[i] = x</span><br><span class="line">        self.sift_up(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="string">"""删除元素"""</span></span><br><span class="line">        last = self.value.pop(self.size() - <span class="number">1</span>)  <span class="comment"># pop堆尾元素</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; self.size():  <span class="comment"># 防止删除堆中唯一元素时越界</span></span><br><span class="line">            self.decrease_key(i, last)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sift_up</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="string">"""上滤，将元素放到正确位置"""</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> self.value[parent(i)] &gt; self.value[i]:</span><br><span class="line">            exchange(self.value, parent(i), i)</span><br><span class="line">            i = parent(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sift_down</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="string">"""下滤，将元素放到正确位置"""</span></span><br><span class="line">        l, r = left_child(i), right_child(i)</span><br><span class="line">        <span class="keyword">if</span> l &lt; self.size() <span class="keyword">and</span> self.value[l] &lt; self.value[i]:</span><br><span class="line">            smallest = l</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            smallest = i</span><br><span class="line">        <span class="keyword">if</span> r &lt; self.size() <span class="keyword">and</span> self.value[r] &lt; self.value[smallest]:</span><br><span class="line">            smallest = r</span><br><span class="line">        <span class="keyword">if</span> smallest != i:</span><br><span class="line">            exchange(self.value, i, smallest)</span><br><span class="line">            self.sift_down(smallest)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span><span class="params">(Heap)</span>:</span></span><br><span class="line">    <span class="string">"""最大堆"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.append(x)</span><br><span class="line">        self.increase_key(self.size() - <span class="number">1</span>, x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increase_key</span><span class="params">(self, i, x)</span>:</span></span><br><span class="line">        self.value[i] = x</span><br><span class="line">        self.sift_up(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decrease_key</span><span class="params">(self, i, x)</span>:</span></span><br><span class="line">        self.value[i] = x</span><br><span class="line">        self.sift_down(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sift_down</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        l, r = left_child(i), right_child(i)</span><br><span class="line">        <span class="keyword">if</span> l &lt; self.size() <span class="keyword">and</span> self.value[l] &gt; self.value[i]:</span><br><span class="line">            largest = l</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            largest = i</span><br><span class="line">        <span class="keyword">if</span> r &lt; self.size() <span class="keyword">and</span> self.value[r] &gt; self.value[largest]:</span><br><span class="line">            largest = r</span><br><span class="line">        <span class="keyword">if</span> largest != i:</span><br><span class="line">            exchange(self.value, i, largest)</span><br><span class="line">            self.sift_down(largest)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sift_up</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> self.value[self.value.parent(i)] &lt; self.value[i]:</span><br><span class="line">            exchange(self.value, parent(i), i)</span><br><span class="line">            i = parent(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    min_heap = Heap([<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">7</span>])</span><br><span class="line">    min_heap.heapify()</span><br><span class="line">    print(<span class="string">'min heap'</span>, min_heap.value)</span><br><span class="line"></span><br><span class="line">    max_heap = MaxHeap([<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">7</span>])</span><br><span class="line">    max_heap.heapify()</span><br><span class="line">    print(<span class="string">'max heap'</span>, max_heap.value)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">min heap [1, 2, 3, 4, 7, 9, 10, 14, 8, 16]</span><br><span class="line">max heap [16, 14, 10, 8, 7, 9, 3, 2, 4, 1]</span><br></pre></td></tr></table></figure><h1 id="应用">应用</h1><ul><li>堆排序</li><li>优先队列</li></ul><h1 id="堆排序">堆排序</h1><p>堆排序（Heapsort）是一种比较排序算法。堆排序在 1964 年首次被<a href="https://en.wikipedia.org/wiki/J._W._J._Williams" target="_blank" rel="noopener">J. W. J. Williams</a>提出，同时也是堆这种数据结构首次出现。堆排序是一种原址（In-place）、非稳定（NOT stable）排序算法。</p><p>堆排序可以看作是选择排序的优化版本。堆排序与选择排序类似，将数组分成两个部分，未排序部分和已排序部分。算法每次从未排序部分提取最大值放入已排序部分，当未排序部分为空时，排序结束。</p><p>选择排序通过一次数组遍历（时间复杂度 <span class="math inline">\(\Theta(n)\)</span> 获取最大值。而堆排序通过堆这种数据结构快速获取最大值。获取的时间复杂度是 <span class="math inline">\(\Theta(1)\)</span>，但获取之后要花费 <span class="math inline">\(\Theta(\lg{n})\)</span> 时间调整堆，因此总运行时间为 <span class="math inline">\(\Theta(1)+\Theta(\lg{n})=\Theta(\lg{n})\)</span>。由此可以看出堆排序相比于选择排序改进的点。</p><p>下面是一幅关于堆排序的示意图（出自<a href="https://en.wikipedia.org/wiki/Heapsort" title="Heapsort" target="_blank" rel="noopener">维基百科</a>）。</p><p><img src="/uploads/image/introduction-to-algorithms/sorting-heapsort-anim.gif"></p><h2 id="实现-1">实现</h2><p>有了堆和堆支持的一些基础操作后，可定义堆排序的过程如下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">heapsort(A):</span><br><span class="line">    heapify(A)                         <span class="comment"># Build a max heap with array A</span></span><br><span class="line">    <span class="keyword">for</span> i=A.length<span class="number">-1</span> downto <span class="number">1</span>:</span><br><span class="line">        exchange A[<span class="number">0</span>] <span class="keyword">with</span> A[i]</span><br><span class="line">        A.heap_size = A.heap_size - <span class="number">1</span></span><br><span class="line">        sift_down(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>在关于堆的介绍中，所有在 <code>heap.data</code> 中的数都被认为是堆中的元素，但是堆排序算法为了节省空间被设计成原址算法，<code>heap.data</code> 中需要同时存储堆（未排序部分）和非堆（已排序部分），因此需要做点小修改，保证 <code>size()</code> 函数返回堆的边界，当超出边界时，即使存在对应数据也不被认为是堆中元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">size():</span><br><span class="line">    <span class="keyword">return</span> heap_size</span><br></pre></td></tr></table></figure><p>堆排序的运行时间分为两部分，建堆的时间 <span class="math inline">\(O(n)\)</span> 和 <code>n-1</code> 次调整堆的时间 <span class="math inline">\(O(\lg{n})\)</span>。所以总的运行时间是</p><p><span class="math inline">\(T(n)=O(n)+(n-1)O(\lg{n})=O(n\lg{n})\)</span>。</p><h2 id="代码-1">代码</h2><p>继承并重写了堆的代码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> data_structure.heap <span class="keyword">import</span> MaxHeap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span><span class="params">(MaxHeap)</span>:</span></span><br><span class="line">    <span class="string">"""基于最大堆的堆排序实现，它是原址排序"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, a)</span>:</span></span><br><span class="line">        MaxHeap.__init__(self, a)</span><br><span class="line">        self.heap_size = len(a)  <span class="comment"># 增加heap_size变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""重写方法"""</span></span><br><span class="line">        <span class="keyword">return</span> self.heap_size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""排序过程主体"""</span></span><br><span class="line">        self.heapify()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.size() - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            self.value[<span class="number">0</span>], self.value[i] = self.value[i], self.value[<span class="number">0</span>]</span><br><span class="line">            self.heap_size -= <span class="number">1</span></span><br><span class="line">            self.sift_down(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [16, 14, 8, 10, 4, 7, 9, 3, 2, 1]</span><br><span class="line">Output: [1, 2, 3, 4, 7, 8, 9, 10, 14, 16]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Algorithms </tag>
            
            <tag> data structures </tag>
            
            <tag> binary tree </tag>
            
            <tag> heap </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
