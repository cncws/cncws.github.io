<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>162. Find Peak Element</title>
      <link href="/programming/leetcode/find-peak-element/"/>
      <url>/programming/leetcode/find-peak-element/</url>
      
        <content type="html"><![CDATA[<p>A peak element is an element that is greater than its neighbors.</p><p>Given an input array nums, where <code>nums[i] != nums[i+1]</code>, find a peak element and return its index.</p><p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p><p>You may imagine that <code>nums[-1] = nums[n] = -inf</code>.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,2,3,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 3 is a peak element and your function should return the index number 2.</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,2,1,3,5,6,4]</span><br><span class="line">Output: 1 or 5</span><br><span class="line">Explanation: Your function can return either index number 1 where the peak element is 2, </span><br><span class="line">             or index number 5 where the peak element is 6.</span><br></pre></td></tr></table></figure><p>Follow up: Your solution should be in logarithmic complexity.</p><h1 id="linear-scan">Linear Scan</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span><span class="params">(self, nums: <span class="string">'List[int]'</span>)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[i + <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> len(nums) - <span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="binary-search">※ Binary Search</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case 1: nums[m] &gt; nums[m + 1]</span><br><span class="line">        4</span><br><span class="line">         \</span><br><span class="line">          3</span><br><span class="line">        search in [l .. m]</span><br><span class="line"></span><br><span class="line">case 2: nums[m] &lt; nums[m + 1]</span><br><span class="line">          4</span><br><span class="line">         /</span><br><span class="line">        3</span><br><span class="line">        search in [m + 1 .. r]</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span><span class="params">(self, nums: <span class="string">'List[int]'</span>)</span> -&gt; int:</span></span><br><span class="line">        l, r = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            m = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] &gt; nums[m + <span class="number">1</span>]:  <span class="comment"># peak in left</span></span><br><span class="line">                r = m</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># peak in right</span></span><br><span class="line">                l = m + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure><p>Same Problem: <strong>852. Peak Index in a Mountain Array</strong></p><p>Let's call an array A a mountain if the following properties hold:</p><ul><li><code>A.length &gt;= 3</code></li><li>There exists some <code>0 &lt; i &lt; A.length - 1</code> such that <code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code></li></ul><p>Given an array that is definitely a mountain, return any i such that <code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code>.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [0,1,0]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [0,2,1,0]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p>Note:</p><ul><li><code>3 &lt;= A.length &lt;= 10000</code></li><li><code>0 &lt;= A[i] &lt;= 10^6</code></li><li><code>A</code> is a mountain, as defined above.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 事务</title>
      <link href="/notes/inside-mysql/mysql-transactions/"/>
      <url>/notes/inside-mysql/mysql-transactions/</url>
      
        <content type="html"><![CDATA[<p>理论上说，事务必须同时满足 ACID（原子性、一致性、隔离性、持久性） 四个特性，但是数据库厂商出于各种目的，并没有严格去满足。例如，对于 Oracle 数据库来说，其默认的隔离级别为 READ COMMITTED，不满足隔离性的要求。</p><p>对于 InnoDB 而言，其默认的隔离级别为 REPEATABLE READ，完全满足事务的 ACID 特性。</p><h1 id="分类">分类</h1><p>从事务理论的角度来说，可以把事务分为以下几种类型：</p><ul><li><p>扁平事务（Flat Transactions）</p><p>扁平事务最为简单，但使用得最为频繁。要么全部提交，要么全部回滚，不能提交或回滚某一部分。</p></li><li><p>带有保存点的扁平事务（Flat Transactions with Savepoints）</p><p>某些事务中出现的错误不会导致所有操作都无效，放弃整个事务不合理，开销也太大。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">action 1</span><br><span class="line">savepoint a;</span><br><span class="line">action 2</span><br><span class="line">savepoint b;</span><br><span class="line">action 3</span><br><span class="line">rollback to a;  # 回滚至保存点 a，事务并未结束</span><br><span class="line">action 4</span><br><span class="line">commit;         # 提交 action 1、4。若是 rollback; 则回滚全部操作</span><br></pre></td></tr></table></figure></li><li><p>链事务（Chained Transactions）</p><p>链事务可视为保存点模式的一种变种。保存点是易失的（volatile），而非持久的（persistent）。当发生系统崩溃时，所有的保存点都将消失。这意味着当进行恢复时，事务需要从开始处重新执行，而不能从最近的一个保存点继续进行。</p><p>链事务的思想是：在提交一个事务时，释放不需要的数据对象，将必要的上下文隐式地传给下一个要开始的事务。注意，<strong>提交事务操作和开始下一个事务操作将合并为一个原子操作</strong>。</p></li><li><p>嵌套事务（Nested Transactions）</p><p>嵌套事务是一个层次结构框架。在 Moss 理论中，实际的工作交由叶子节点来完成，而高层的事务仅负责逻辑控制，决定何时调用相关的子事务。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">顶层事务     子事务           子事务</span><br><span class="line"></span><br><span class="line">begin;</span><br><span class="line">subtrx 1</span><br><span class="line">            begin;</span><br><span class="line">            subtrx 1.1</span><br><span class="line">                            begin;</span><br><span class="line">                            action</span><br><span class="line">                            commit;</span><br><span class="line">            commit;</span><br><span class="line">subtrx 2</span><br><span class="line">            begin</span><br><span class="line">            action</span><br><span class="line">            commit;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p>子事务既可以提交也可以回滚，<strong>但是它的提交操作并不马上生效，除非其父事务已经提交</strong>。任意一个事务的回滚会引起它的所有子事务一同回滚，故子事务保留 ACI 特性，不具有 D 的特性。</p><p>即使一个系统不支持嵌套事务，用户也可以通过保存点技术来模拟嵌套事务。</p><ul><li>在回滚时，采用保存点比嵌套具有更大的灵活性。</li><li>在锁的持有方面，嵌套查询中不同的子事务在数据库对象上持有的锁是不同的。用户可以选择哪些锁需要被子事务继承，哪些需要被父事务保留。</li></ul><p>然而，如果系统支持在嵌套事务中并行地执行各个子事务，采用保存点来模拟嵌套事务就不切实际了。</p></li><li><p>分布式事务（Distributed Transactions）</p><p>分布式事务通常是一个在分布式环境下运行的扁平事务，需要根据数据所在位置访问网络中不同的节点。例如在不同的银行之间转账。</p></li></ul><p>InnoDB 支持扁平事务、带有保存点的扁平事务、链事务、分布式事务。对于嵌套事务，其并不原生支持。</p><a id="more"></a><h1 id="事务的实现">事务的实现</h1><h2 id="redo">redo</h2><p>重做日志用来实现事务的持久性，其由两部分组成：一是内存中的重做日志缓冲（redo log buffer），是易失的；二是重做日志文件（redo log file），是持久的。</p><p>InnoDB 通过 Force Log at Commit 机制实现事务的持久性，当事务提交时，必须先将事务的所有日志写入到重做日志文件进行持久化，待事务的 COMMIT 操作完成才算完成。</p><p>为了确保每次日志都写入重做日志文件，在每次将重做日志缓冲写入重做日志文件（实际上写入的是文件系统缓存）后，InnoDB 都需要调用一次 fsync 操作，确保重做日志文件写入磁盘。fsync 的效率取决于磁盘的性能。</p><p>参数 innodb_flush_log_at_trx_commit 用来控制重做日志刷新到磁盘的策略。</p><table><colgroup><col style="width: 14%"><col style="width: 85%"></colgroup><thead><tr class="header"><th>取值</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>0</td><td>事务提交时不写入重做日志文件，该操作仅在 master thread 中完成，在 master thread 中每 1 秒会进行一次重做日志文件的 fsync 操作</td></tr><tr class="even"><td>1（默认值）</td><td>事务提交时必须调用一次 fsync</td></tr><tr class="odd"><td>2</td><td>事务提交时写入重做日志文件，但仅写入文件系统的缓存，不进行 fsync 操作。在这个设置下，当数据库发生宕机而操作系统不发生宕机时，并不会导致事务的丢失。</td></tr></tbody></table><h3 id="binlog">binlog</h3><p>在 MySQL 数据库中还有一种二进制日志（binlog），其用来进行 POINT-IN-TIME 的恢复及主从复制。binlog 与 redo log 有非常大的不同。</p><p>首先，<strong>重做日志是在 InnoDB 存储引擎层产生，而二进制日志是在 MySQL 数据库的上层产生的</strong>，并且二进制日志不仅仅针对于 InnoDB，任何存储引擎对于数据库的更改都会产生二进制日志。</p><p>其次，两种日志记录的内容形式不同。<strong>二进制日志是一种逻辑日志，记录的是对应的 SQL 语句。而重做日志是物理格式日志，记录的是对于每个页的修改</strong>。</p><p>此外，两种日志记录写入磁盘的时间点不同。<strong>二进制日志只在事务提交完成后进行一次写入，而重做日志在事务进行中不断地被写入</strong>，这表现为重做日志并不是随事务提交的顺序写入的。</p><h3 id="log-block">log block</h3><p>在 InnoDB 中，重做日志缓存、重做日志文件都是以块（大小为 512 字节）的方式进行存储的，称之为重做日志块（redo log block）。重做日志块的大小和磁盘扇区大小一样，写入可以保证原子性。</p><p>重做日志块由三部分组成，依次为日志块头（12 字节）、日志内容（492 字节）、日志块尾（8 字节）。</p><p>log block header 由 4 部分组成，</p><table><colgroup><col style="width: 25%"><col style="width: 12%"><col style="width: 62%"></colgroup><thead><tr class="header"><th>字段</th><th>字节</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>LOG_BLOCK_HDR_NO</td><td>4</td><td>log buffer 是由 log block 组成，log buffer 好似一个数组，LOG_BLOCK_HDR_NO 用来标记这个数组中的位置。其是递增并且循环使用的，第 1 位是 flush bit，实际最大的值为 2G（2^31 bit）。</td></tr><tr class="even"><td>LOG_BLOCK_HDR_DATA_LEN</td><td>2</td><td>表示 log block 所占用的大小。当 log block 被写满时，该值为 512。</td></tr><tr class="odd"><td>LOG_BLOCK_FIRST_REC_GROUP</td><td>2</td><td>表示 log block 中第一个日志所在的偏移量。如果该值与 LOG_BLOCK_HDR_DATA_LEN 相同，则表示当前块中不包含新的日志。</td></tr><tr class="even"><td>LOG_BLOCK_CHECKPOINT_NO</td><td>4</td><td>表示该 log block 最后被写入时的检查点</td></tr></tbody></table><p>log block tailer 只由 1 个部分组成，LOG_BLOCK_TRL_NO，占用 4 个字节，且其值和 LOG_BLOCK_HDR_NO 相同。（尾部剩下 4 个字节是空的？）</p><p>在 InnoDB 运行过程中，log buffer 根据一定的规则将内存中的 log block 刷新到磁盘，这个规则具体是：</p><ul><li>事务提交时（可通过参数 innodb_flush_log_at_trx_commit 更改）</li><li>当 log buffer 中有一半的内存空间已经被使用时</li><li>log checkpoint 时</li></ul><p>log block 以追加的方式写入 redo log file，当一个 redo log file 被写满时，会接着写入下一个 redo log file。</p><p>redo log file 除了保存 log block，还保存一些其他的信息。第一个 redo log file 前 2KB 的部分保存以下 4 个 512 字节大小的块：log file header、checkpoint1、空、checkpoint2。其余的 redo log file 仅保留这些空间，不保存信息。追加新的 log block 时，还需要更新这部分信息。这些信息对于 InnoDB 的恢复操作来说至关重要。</p><p>checkpoint 保存检查点值，其设计是交替写入，目的是避免因介质失败导致无法找到可用的 checkpoint。</p><h3 id="重做日志格式">重做日志格式</h3><p>不同的操作有不同的重做日志格式，但是它们有着通用的头部格式，由以下 3 部分组成：</p><ul><li>redo_log_type ：重做日志类型</li><li>space ：表空间 ID</li><li>page_no ：页的偏移量</li></ul><h3 id="日志序列号">日志序列号</h3><p>日志序列号（Log Sequence Number，LSN）占用 8 字节，并且单调递增。其表示的含义有：</p><ul><li>重做日志写入的总量，单位是字节。例如当前重做日志的 LSN 为 1000，有一个事务写入了 100 字节的重做日志，那么 LSN 就变为了 1100。</li><li>checkpoint 的位置。</li><li>页的版本。LSN 不仅记录在重做日志中，还存在于每个页中。在每个页的头部，有一个值 FIL_PAGE_LSN，表示该页刷新时 LSN 的大小，该值用来判断页是否需要进行恢复操作。例如，页 P1 的 LSN 为 10000，而数据库启动时，InnoDB 检测到重做日志中的 LSN 为 13000，那么数据库需要进行恢复操作。</li></ul><p>通过命令 SHOW ENGINE INNODB STATUS 可以查看 LSN 的情况。Log sequence number 表示当前的 LSN，Log flushed up to 表示刷新到重做日志文件的 LSN，Last checkpoint at 表示刷新到磁盘的 LSN。</p><h3 id="恢复">恢复</h3><p>InnoDB 在启动时不管上次是否正常关闭，都会尝试进行恢复操作。重做日志记录的是物理日志，恢复的速度比逻辑日志，如二进制日志，要快很多。与此同时，InnoDB 也对恢复进行了一定程度的优化，如顺序读取及并行应用重做日志，进一步提高数据库恢复的速度。</p><p>checkpoint 表示已经刷新到磁盘的 LSN，因此在恢复过程中仅需恢复 checkpoint 开始的日志部分。</p><p>重做日志是物理日志，记录的是每个页上的变化。对于下面的表和 SQL 语句：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t (a <span class="built_in">int</span>, b <span class="built_in">int</span>, primary <span class="keyword">key</span>(a), <span class="keyword">key</span>(b));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">select</span> <span class="number">1</span>, <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>由于需要对聚集索引页和辅助索引页进行操作，其记录的重做日志大致为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">page(2,3), offset 32, value 1,2  # 聚集索引</span><br><span class="line">page(2,4), offset 64, avlue 2    # 辅助索引</span><br></pre></td></tr></table></figure><p>若插入涉及 B+ 树的 split，可能会有更多的页需要记录日志。此外，由于是物理日志，重做日志是幂等的。幂等的概念是 <code>f( f(x) ) = f(x)</code>。重复执行的结果不变。逻辑日志，如二进制日志，就不是幂等的。重复执行可能会插入（对于 INSERT）多条重复的记录。</p><h2 id="undo">undo</h2><p>事务有时还需要回滚，这时就需要 undo。因此在对数据库进行修改时，InnoDB 不但会产生 redo，还会产生一定量的 undo。当事务执行失败，或者用户用 ROLLBACK 请求回滚，就可以利用 undo 将数据回滚到修改前的样子。</p><p>与 redo 不同，undo 存放在数据库内部的一个特殊字段中，这个段成为 undo 段，undo 段位于共享表空间中。</p><p>undo 是逻辑日志，因此只是将数据库逻辑地恢复到原来的样子。InnoDB 回滚时，实际上做的是与先前相反的工作，对于每个 INSERT/DELETE，InnoDB 会完成一个 DELETE/INSERT；对于每个 UPDATE，InnoDB 会执行一个相反的 UPDATE，将修改前的行放回去。</p><p>除了回滚操作，undo 的另一个作用是 MVCC，MVCC 的实现是通过 undo 来完成。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过 undo 读取之前的行版本信息，以此实现非锁定读取。</p><p>最后也是最为重要的一点是，<strong>undo log 会产生 redo log</strong>。因为 undo log 也需要持久性的保护。</p><h3 id="undo-log-格式">undo log 格式</h3><p>InnoDB 中，undo log 分为 insert undo log 和 update undo log。</p><p>insert undo log 是指在 insert 操作中产生的 undo log。因为 insert 的记录，只对事务本身可见，故该 undo log 可以在事务提交后直接删除，不需要进行 purge 操作。</p><p>update undo log 记录的是对 delete 和 update 产生的 undo log。该 undo log 可能需要提供 MVCC 机制，因此不能在事务提交时就进行删除。提交时放入 undo log 链表，等待 purge 线程进行最后的删除。</p><h2 id="purge">purge</h2><p>purge 用于最终完成 delete 和 update 操作，这样设计的目的是支持 MVCC。</p><p>InnoDB 中有一个 histroy 列表，它根据事务提交的顺序，将 undo log 进行链接，先提交的事务在尾端。</p><p>为节省空间，一个页上允许多个事务的 undo log 存在。若按照列表中的顺序依次清理 undo log，需要做随机读（不同事务的 undo log 可能在不同页上），降低了 purge 的效率。</p><p>因此 purge 清理 undo log 的操作是：InnoDB 先从列表中找到第一个可以被清理的记录（尾部记录），清理之后在其所在的页中继续寻找是否存在可以被清理的记录。若页中其他记录被全部清理，则该 undo page 可以被重用。若有记录被其他事务所引用而不能被清理，则去 history list 中重新寻找可被清理的记录。</p><table><colgroup><col style="width: 25%"><col style="width: 75%"></colgroup><thead><tr class="header"><th>全局动态参数（默认值）</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>innodb_purge_batch_size (300)</td><td>每次 purge 操作需要清理的 undo page 数量。</td></tr><tr class="even"><td>innodb_max_purge_lag (0)</td><td>控制 history list 的长度。当 InnoDB 存储引擎的压力非常大时，并不能高效地进行 purge 操作，那么 history list 会越来越长。若长度大于该参数，InnoDB 会延缓 DML 的操作。默认值为 0 表示不对 history list 做任何限制。</td></tr><tr class="odd"><td>innodb_max_purge_lag_delay (0)</td><td>控制延缓的最大毫秒数。避免由于 purge 操作缓慢导致其他 SQL 线程出现无限制的等待。</td></tr></tbody></table><h3 id="group-commit">group commit</h3><p>对于 InnoDB 来说，事务提交时会进行两个阶段的操作：</p><ol type="1"><li>修改内存中事务对应的信息，并且将日志写入重做日志缓冲。</li><li>调用 fsync 确保日志写入磁盘。</li></ol><p>当有事务进行步骤 2 时，其他事务可以进行步骤 1 的操作。完成提交操作后，再次进行步骤 2 时，可以将多个事务的重做日志通过一次 fsync 刷新到磁盘，这样就大大地减少了磁盘的压力，从而提高了数据库的整体性能。对于更新较为频繁的操作，group commit 的效果尤为明显。（看不懂，没有例子）</p><p>然而在 InnoDB 1.2 版本之前，在开启二进制日志后，group commit 功能会失效，导致性能的下降。在线环境多使用 replication，因此二进制日志的选项基本都为开启状态，因此这个问题尤为显著。</p><p>导致这个问题的原因是在开启二进制日志后，为了保证存储引擎层中的事务和二进制日志的一致性，二者之间使用了两阶段事务，步骤如下：</p><ol type="1"><li>当事务提交时 InnoDB 进行 prepare 操作。</li><li>MySQL 数据库上层写入二进制文件。</li><li>InnoDB 存储引擎层将日志写入重做日志文件。<ol type="1"><li>修改内存中事务对应的信息，并且将日志写入重做日志缓冲。</li><li>调用 fsync 确保日志写入磁盘。</li></ol></li></ol><p>一旦步骤 2 中的操作完成，就确保了事务的提交（即使在步骤 3 时数据库发生了宕机）。此外，步骤 2、3 都需要一次 fsync 操作，保证上下两层数据的一致性。步骤 2 的 fsync 由参数 sync_binlog 控制，步骤 3 的 fsync 由 innodb_flush_log_at_trx_commit 控制。</p><p>为了保证 MySQL 数据库上层二进制日志的写入顺序和 InnoDB 层的事务提交顺序一致，MySQL 数据库内部使用了 prepare_commit_mutex 这个锁。在启用这个锁之后，步骤 3.1 不可以在其他事务执行步骤 3.2 时进行，从而导致了 group commit 失效。</p><p>MySQL 5.6 采用 Binary Log Group Commit（BLGC）解决这一问题。不但 MySQL 数据库上层的二进制日志写入是 group commit 的，InnoDB 存储引擎层也是 group commit 的。此外，还移除了原先的 prepare_commit_mutex 锁。</p><p>在 MySQL 数据库上层进行提交时，首先按顺序将其放入一个队列中，队列中的第一个事务称为 leader，其他事务称为 follower，leader 控制着 follower 的行为。BLGC 的步骤为：</p><ol type="1"><li>Flush 阶段，将每个事务的二进制日志写入文件。</li><li>Sync 阶段，将内存中的二进制日志刷新到磁盘，若队列中有多个事务，那么仅一次 fsync 操作就完成了二进制日志的写入，这就是 BLGC。</li><li>Commit 阶段，leader 根据顺序调用存储引擎层事务的提交，InnoDB 本身就支持 group commit，因此修复了原先由于 prepare_commit_mutex 锁导致 group commit 失效的问题。</li></ol><p>当有一组事务在进行 Commit 阶段时，其他事务可以进行 Flush 阶段，从而使 group commit 不断生效。当然 group commit 的效果由队列中事务的数量决定，当提交的事务越多时，group commit 的效果越明显，数据库性能的提升也就越大。</p><p>参数 binlog_max_flush_queue_time 用来控制 Flush 阶段中等待的时间，即使之前的一组事务完成提交，当前的一组事务也不马上进入 Sync 阶段，而是至少等待一段时间。这样做的好处是 group commit 的事务数量更多，然而这也可能会导致事务的响应时间变慢。该参数的默认值为 0，且推荐设置依然为 0。</p><h1 id="事务控制语句">事务控制语句</h1><table><thead><tr class="header"><th>语句</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>start transaction | begin</code></td><td>显式地开启一个事务</td></tr><tr class="even"><td><code>commit [work]</code></td><td>提交事务</td></tr><tr class="odd"><td><code>rollback [work]</code></td><td>回滚事务</td></tr><tr class="even"><td><code>savepoint p</code></td><td>创建一个保存点</td></tr><tr class="odd"><td><code>release savepoint p</code></td><td>删除一个保存点，当没有 <code>p</code> 这个保存点时，会抛出一个异常</td></tr><tr class="even"><td><code>rollback to p</code></td><td>回滚到保存点，当没有 <code>p</code> 这个保存点时，会抛出一个异常</td></tr><tr class="odd"><td><code>set transaction</code></td><td>设置事务的隔离级别</td></tr></tbody></table><p>start transaction 和 begin 都可以在命令行下显式地开启一个事务。但是在存储过程中，分析器会将 begin 识别为 begin...end，因此在存储过程中只能使用 start transaction 来开启一个事务。</p><p>commit 和 commit work 基本是一致的。不同之处在于 commit work 用来控制事务结束后的行为。用户可以通过参数 completion_type 控制。</p><table><thead><tr class="header"><th>取值</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>0（默认值）</td><td>没有任何操作，此时 commit 和 commit work 是完全等价的</td></tr><tr class="even"><td>1</td><td>马上自动开启一个相同隔离级别的事务，等同于 commit and chain（链事务）</td></tr><tr class="odd"><td>2</td><td>提交后自动断开与服务器的连接</td></tr></tbody></table><p>rollback 和 rollback work 与 commit 和 commit work 的工作方式一样。</p><h1 id="隐式提交的-sql-语句">隐式提交的 SQL 语句</h1><p>以下这些 SQL 语句会产生一个隐式的提交操作，即执行完成后，会有一个隐式的 COMMIT，因此这些操作无法被回滚。</p><ul><li>DDL 语句：ALTER ..., CREATE ..., DROP ..., RENAME TABLE, TRUNCATE TABLE 等等</li><li>用来隐式地修改 MySQL 架构的操作：CREATE USER, DROP USER, RENAME USER, GRANT, REVOKE, SET PASSWORD。</li><li>管理语句：ANALYZE TABLE, CACHE INDEX, CHECK TABLE, LOAD INDEX INTO CACHE, OPTIMIZE TABLE, REPAIR TABL。</li></ul><p>TRUNCATE TABLE 语句是 DLL，虽然和对整张表执行 DELETE 的结果一样，但它是不能回滚的。</p><h1 id="对于事务操作的统计">对于事务操作的统计</h1><p>计算每秒事务处理的能力（Transaction Per Second，TPS）的方法是：<code>(com_commit + com_rollback) / time</code>。但是利用这种方法进行计算的前提是：所有的事务必须是显示提交的，如果存在隐式提交地事务和回滚，不会计算到 com_commit 和 com_rollback 全局变量中。</p><h1 id="事务的隔离级别">事务的隔离级别</h1><p>InnoDB 的默认隔离级别是 REPEATABLE READ，但与标准 SQL 不同的是，使用 Next-Key Lock 算法，避免幻读的产生。</p><p>InnoDB 在 REPEATABLE READ 隔离级别下就可以达到 SERIALIABLE 的隔离，因此一般不在本地事务中使用 SERIALIABLE 的隔离级别。SERIALIABLE 隔离级别主要用于分布式事务。</p><h1 id="分布式事务">分布式事务</h1><p>InnoDB 通过 XA 事务来支持分布式事务的实现。分布式事务指的是允许多个独立的事务资源参与到一个全局的事务中。使用分布式事务时，InnoDB 的事务隔离级别必须设置为 SERIALIABLE。</p><p>分布式事务可能在银行系统的转账中比较常见。通常来说，都是通过编程语言来完成分布式事务的操作的。</p><p>MySQL 数据库中存在一种分布式事务，在存储引擎与插件之间，又或者在存储引擎与存储引擎之间，称之为内部 XA 事务。最为常见的内部 XA 事务存在于 binlog 与 InnoDB 之间。在事务提交事务，先写二进制日志，再写 InnoDB 的重做日志。二进制日志和重做日志必须同时写入，若二进制日志先写了，而在写入重做日志时发生了宕机，那么 slave 可能会接收到 master 传过去的二进制日志并执行，最终导致主从不一致的情况。</p><h1 id="不好的事务习惯">不好的事务习惯</h1><ul><li>在循环中提交，不论是显式的还是隐式的提交。</li><li>使用自动提交。</li><li>使用自动回滚，例如在一个存储过程中 <code>declare exit handler for sqlexception rollback;</code>。</li></ul><h1 id="长事务">长事务</h1><p>长事务（Long-Lived Transaction）就是执行时间长的事务。对于长事务的问题，有时可以通过转化为小批量的事务来解决。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> Inside MySQL </tag>
            
            <tag> transaction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>128. Longest Consecutive Sequence</title>
      <link href="/programming/leetcode/longest-consecutive-sequence/"/>
      <url>/programming/leetcode/longest-consecutive-sequence/</url>
      
        <content type="html"><![CDATA[<p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p><p>Your algorithm should run in <code>O(n)</code> complexity.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [100, 4, 200, 1, 3, 2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest consecutive elements sequence is [1, 2, 3, 4].</span><br><span class="line">             Therefore its length is 4.</span><br></pre></td></tr></table></figure><h1 id="dynamic-programming">Dynamic Programming</h1><p>Define <code>dp[n] = length of LCS start or end at n</code>.</p><p>Base case: <code>dp[i] = 0</code>.</p><p>Induction rule: <code>dp[j] = dp[j - dp[j - 1]] = dp[j + dp[j + 1]] = dp[j - 1] + dp[j + 1] + 1</code>.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1, 2, 3, 5, 6, 4]</span><br><span class="line"></span><br><span class="line">num  dp</span><br><span class="line"></span><br><span class="line">1    1:1         (dp[1] = dp[1 - 0] = dp[1 + 0] = dp[0] + dp[2] + 1)</span><br><span class="line">2    1:2, 2:2    (dp[2] = dp[2 - 1] = dp[2 + 0] = dp[1] + dp[3] + 1)</span><br><span class="line">3    1:3, 2:2, 3:3</span><br><span class="line">5    1:3, 2:2, 3:3, 5:1</span><br><span class="line">6    1:3, 2:2, 3:3, 5:2, 6:2</span><br><span class="line">4    1:6, 2:2, 3:3, 5:2, 6:6, 4:6</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span><span class="params">(self, nums: <span class="string">'List[int]'</span>)</span> -&gt; int:</span></span><br><span class="line">        dp = defaultdict(int)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> dp[n]:  <span class="comment"># n not repeated</span></span><br><span class="line">                dp[n] = dp[n - dp[n - <span class="number">1</span>]] = dp[n + dp[n + <span class="number">1</span>]] \</span><br><span class="line">                      = dp[n - <span class="number">1</span>] + dp[n + <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                ans = max(ans, dp[n])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h1 id="hashset-and-intelligent-sequence-building">HashSet and Intelligent Sequence Building</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        longest_streak = <span class="number">0</span></span><br><span class="line">        num_set = set(nums)  <span class="comment"># HashSet</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> num_set:</span><br><span class="line">            <span class="keyword">if</span> num - <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> num_set:  <span class="comment"># Intelligent</span></span><br><span class="line">                current_num = num</span><br><span class="line">                current_streak = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> current_num + <span class="number">1</span> <span class="keyword">in</span> num_set:  <span class="comment"># Sequence Building</span></span><br><span class="line">                    current_num += <span class="number">1</span></span><br><span class="line">                    current_streak += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                longest_streak = max(longest_streak, current_streak)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest_streak</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
            <tag> hash table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>160. Intersection of Two Linked Lists</title>
      <link href="/programming/leetcode/intersection-of-two-linked-list/"/>
      <url>/programming/leetcode/intersection-of-two-linked-list/</url>
      
        <content type="html"><![CDATA[<p>Write a program to find the node at which the intersection of two singly linked lists begins.</p><p>For example, the following two linked lists:</p><p><img src="/uploads/image/leetcode/160-statement.png"></p><p>begin to intersect at node c1.</p><a id="more"></a><p>Example 1:</p><p><img src="/uploads/image/leetcode/160-example-1.png"></p><p><code>Output: Reference of the node with value = 8</code></p><p>Example 2:</p><p><img src="/uploads/image/leetcode/160-example-2.png"></p><p><code>Output: Reference of the node with value = 2</code></p><p><img src="/uploads/image/leetcode/160-example-3.png"></p><p><code>Output: null</code></p><p>Notes:</p><ul><li>If the two linked lists have no intersection at all, return <code>null</code>.</li><li>The linked lists must retain their original structure after the function returns.</li><li>You may assume there are no cycles anywhere in the entire linked structure.</li><li>Each value on each linked list is in the range <code>[1, 10^9]</code>.</li><li>Your code should preferably run in <code>O(n)</code> time and use only <code>O(1)</code> memory.</li></ul><h1 id="two-pointers">Two pointers</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">headA:        a1 -&gt; a2 -&gt; c1 -&gt; c2 -&gt; c3, m = 5</span><br><span class="line">headB:  b1 -&gt; b2 -&gt; b3 -&gt; c1 -&gt; c2 -&gt; c3, n = 6</span><br><span class="line"></span><br><span class="line">Two pointers pa = a1, pb = b1,</span><br><span class="line">pb moves (n - m) steps forward, i.e., pb = b2.</span><br><span class="line"></span><br><span class="line">Move pa and pb 1 step a time, when pa == pb, pa/pb is the intersection.</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(m + n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA: ListNode, headB: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">length</span><span class="params">(head)</span>:</span></span><br><span class="line">            cur, size = head, <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                size += <span class="number">1</span></span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="keyword">return</span> size</span><br><span class="line"></span><br><span class="line">        m, n = length(headA), length(headB)</span><br><span class="line"></span><br><span class="line">        pa, pb = headA, headB</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n - m):</span><br><span class="line">            pb = pb.next</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(m - n):</span><br><span class="line">            pa = pa.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> pa <span class="keyword">and</span> pb:</span><br><span class="line">            <span class="keyword">if</span> pa == pb:</span><br><span class="line">                <span class="keyword">return</span> pb</span><br><span class="line">            pa, pb = pa.next, pb.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>Two pointers can performed in another way.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">headA:        a1 -&gt; a2 -&gt; c1 -&gt; c2 -&gt; c3</span><br><span class="line">headB:  b1 -&gt; b2 -&gt; b3 -&gt; c1 -&gt; c2 -&gt; c3</span><br><span class="line"></span><br><span class="line">Two pointers pa = a1, pb = b1,</span><br><span class="line"></span><br><span class="line">Move pa and pb forward until reach the end.</span><br><span class="line">If pa reach the end, let pa = b1.</span><br><span class="line">If pb reach the end, let pb = a1.</span><br><span class="line">When pa == pb, pa/pb is the intersection.</span><br><span class="line"></span><br><span class="line">Path of pointers:</span><br><span class="line">pa: a1 -&gt; a2 -&gt; c1 -&gt; c2 -&gt; c3 -&gt; b1 ~&gt; b2 -&gt; b3 -&gt; c1</span><br><span class="line">pb: b1 -&gt; b2 -&gt; b3 -&gt; c1 -&gt; c2 -&gt; c3 ~&gt; a1 -&gt; a2 -&gt; c1</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(m + n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA: ListNode, headB: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> headA <span class="keyword">or</span> <span class="keyword">not</span> headB:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        pa, pb = headA, headB</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> count &lt; <span class="number">2</span>:</span><br><span class="line">            pa, pb = pa.next, pb.next</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pa:</span><br><span class="line">                pa = headB</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pb:</span><br><span class="line">                pb = headA</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> pa <span class="keyword">or</span> pb:</span><br><span class="line">            <span class="keyword">if</span> pa == pb:</span><br><span class="line">                <span class="keyword">return</span> pa</span><br><span class="line">            pa, pb = pa.next, pb.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>234. Palindrome Linked List</title>
      <link href="/programming/leetcode/palindrome-linked-list/"/>
      <url>/programming/leetcode/palindrome-linked-list/</url>
      
        <content type="html"><![CDATA[<p>Given a singly linked list, determine if it is a palindrome.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>Follow up: Could you do it in <code>O(n)</code> time and <code>O(1)</code> space?</p><h1 id="using-array">Using array</h1><p>Take values from linked list to an array, then determine if it is a palindrome.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, head: ListNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># linked list -&gt; array</span></span><br><span class="line">        arr, cur = [], head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            arr.append(cur.val)</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="comment"># check if is palindrome?</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(arr) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> arr[i] == arr[j]:</span><br><span class="line">            i, j = i + <span class="number">1</span>, j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i &gt;= j</span><br></pre></td></tr></table></figure><h1 id="o1-space">※ O(1) space</h1><ol type="1"><li>Find the mid node in linked list. Split input into two parts.</li><li>Reverse the second part. See problem <a href="/programming/leetcode/reverse-linked-list/" title="Reverse Linked List">Reverse Linked List</a>.</li><li>Compare two parts one by one.</li><li>Restore the input if needed.</li></ol><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        curr, prev = head, <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            prev, prev.next, curr = curr, prev, curr.next</span><br><span class="line">        <span class="keyword">return</span> prev</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, head: ListNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 1. split</span></span><br><span class="line">        slow, fast = head, head.next</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">        mid, slow.next = slow.next, <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 2. reverse</span></span><br><span class="line">        mid = self.reverseList(mid)</span><br><span class="line">        <span class="comment"># 3. compare</span></span><br><span class="line">        p, q = head, mid</span><br><span class="line">        <span class="keyword">while</span> q <span class="keyword">and</span> p.val == q.val:</span><br><span class="line">            p, q = p.next, q.next</span><br><span class="line">        <span class="keyword">return</span> q <span class="keyword">is</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h1 id="recursion">Recursion</h1><p>Using two pointers <code>p</code> and <code>q</code>. <code>p</code> moves forward by <code>p = p.next</code> while <code>q</code> moves backward by recursion stack.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1 -&gt; 2 -&gt; 2 -&gt; 1</span><br><span class="line"></span><br><span class="line">p = 1, q = 1</span><br><span class="line"></span><br><span class="line">compareWith(q = 1):</span><br><span class="line">    compareWith(q = 2):</span><br><span class="line">        compareWith(q = 2):</span><br><span class="line">            compareWith(q = 1):</span><br><span class="line">                p == q</span><br><span class="line">                p = p.next</span><br><span class="line">                return True</span><br><span class="line">            p == q</span><br><span class="line">            p = p.next</span><br><span class="line">            return True</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>There are two problems makes recursion slow:</p><ul><li>Recurion stack is 'expensive'.</li><li>Compared at most two times for each pair.</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, head: ListNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        p = head</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(q)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> p</span><br><span class="line">            <span class="keyword">if</span> q:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> helper(q.next):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> p.val != q.val:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                p = p.next</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(head)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> linked list </tag>
            
            <tag> palindrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>141. Linked List Cycle</title>
      <link href="/programming/leetcode/linked-list-cycle/"/>
      <url>/programming/leetcode/linked-list-cycle/</url>
      
        <content type="html"><![CDATA[<p>Given a linked list, determine if it has a cycle in it.</p><p>Follow up: Can you solve it using O(1) (i.e. constant) memory?</p><h1 id="using-hash-table">Using hash table</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head: ListNode)</span> -&gt; bool:</span></span><br><span class="line">        visited = set()</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            visited.add(cur)</span><br><span class="line">            cur = cur.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="two-pointers">※ Two pointers</h1><p>A slow pointer and a fast pointer. The slow pointer moves one step at a time while the fast pointer moves two steps at a time.</p><p>If there is no cycle in the list, the fast pointer will eventually reach the end and we can return false in this case.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head: ListNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        slow, fast = head, head.next</span><br><span class="line">        <span class="keyword">while</span> slow != fast:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> fast <span class="keyword">or</span> <span class="keyword">not</span> fast.next:  <span class="comment"># fast reach the end</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> linked list </tag>
            
            <tag> hash table </tag>
            
            <tag> two pointers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2. Add Two Numbers</title>
      <link href="/programming/leetcode/add-two-numbers/"/>
      <url>/programming/leetcode/add-two-numbers/</url>
      
        <content type="html"><![CDATA[<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in <strong>reverse</strong> order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 = 807.</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: (4 -&gt; 3) + (1 -&gt; 8)</span><br><span class="line">Output: 5 -&gt; 1 -&gt; 1</span><br><span class="line">Explanation: 34 + 81 = 115.</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(max(m, n))</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        hair = ListNode(<span class="number">0</span>)</span><br><span class="line">        cur, p, q = hair, l1, l2</span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">or</span> q:</span><br><span class="line">            a = p.val <span class="keyword">if</span> p <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            b = q.val <span class="keyword">if</span> q <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            c = a + b + carry</span><br><span class="line">            carry = c // <span class="number">10</span></span><br><span class="line"></span><br><span class="line">            cur.next = ListNode(c % <span class="number">10</span>)</span><br><span class="line">            cur = cur.next</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> p:</span><br><span class="line">                p = p.next</span><br><span class="line">            <span class="keyword">if</span> q:</span><br><span class="line">                q = q.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> carry:  <span class="comment"># be careful</span></span><br><span class="line">            cur.next = ListNode(carry)</span><br><span class="line">        <span class="keyword">return</span> hair.next</span><br></pre></td></tr></table></figure><p>Follow up:</p><p>What if the the digits in the linked list are stored in non-reversed order? For example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(3 -&gt; 4 -&gt; 2) + (4 -&gt; 6 -&gt; 5) = (8 -&gt; 0 -&gt; 7)</span><br></pre></td></tr></table></figure><p>Reverse the linked list, add them, retrun reversed result.</p><p>See problem <a href="/programming/leetcode/reverse-linked-list/" title="Reverse Linked List">Reverse Linked List</a>.</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>440. K-th Smallest in Lexicographical Order</title>
      <link href="/programming/leetcode/k-th-smallest-in-lexicographical-order/"/>
      <url>/programming/leetcode/k-th-smallest-in-lexicographical-order/</url>
      
        <content type="html"><![CDATA[<p>Given integers n and k, find the lexicographically k-th smallest integer in the range from 1 to n.</p><p>Note: <code>1 &lt;= k &lt;= n &lt;= 10^9</code>.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n=13, k=2</span><br><span class="line">Output: 10</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9],</span><br><span class="line">so the second smallest number is 10.</span><br></pre></td></tr></table></figure><h1 id="trie-tree-perfix-tree">Trie Tree (Perfix Tree)</h1><p>Create a trie tree then visit in preorder.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">          (root, no value)</span><br><span class="line">        /      |  ...  |   \</span><br><span class="line">       1       2       8    9</span><br><span class="line">  /  |  |  \</span><br><span class="line">10  11  12  13</span><br></pre></td></tr></table></figure><p>If we want get the 7-th value, visit in preorder: <code>1, 10, 11, 12, 13, 2, 3 (target)</code>.</p><p>Could we speed it up? Yes.</p><p>Tree 1 has 4 descendents, so we know the next tree 2 is 6-th nodes. We need not to visit tree 1's descendents one by one, just go directly to it's next brother.</p><p>The procedure to find 7-th is like:</p><ol type="1"><li>Tree 1 is the 1-st node, it has 4 descendents, 7-th nodes not in this subtree. Go to tree 2.</li><li>Tree 2 is the 6-th node, it has 0 descendents, 7-th nodes not in this subtree too. Go to tree 3.</li><li>Tree 3 is the 7-th node, return it's value 3.</li></ol><p>Now, <strong>the most important thing is how to calculate the number of descendents of a tree?</strong></p><p>The procedure is count nodes layer by layer. For example, given a trie tree below, count the number of it's descendents. Note that value is end at 1301, i.e., the last level is not full.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">          13</span><br><span class="line">        /    \</span><br><span class="line">     130 ...  139</span><br><span class="line">    /  |</span><br><span class="line">1300  1301</span><br><span class="line"></span><br><span class="line">count = 0 saves the result.</span><br><span class="line"></span><br><span class="line">cur = 13, next = cur + 1 = 14</span><br><span class="line"></span><br><span class="line">* next - cur is the number of nodes in current level.</span><br><span class="line">* Be careful the last level may not full.</span><br><span class="line"></span><br><span class="line">cur    next   count</span><br><span class="line">13     14     1  (0 + 14 - 13)</span><br><span class="line">130    140    11 (1 + 140 - 130)</span><br><span class="line">1300   1400   13 (11 + min(1301 - 1300 + 1, 1400 - 1300))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(log(n))</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthNumber</span><span class="params">(self, n: int, k: int)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">numberOfDescendents</span><span class="params">(root_val, max_val)</span>:</span></span><br><span class="line">            cur, nxt = root_val, root_val + <span class="number">1</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> cur &lt;= max_val:</span><br><span class="line">                count += min(nxt, max_val + <span class="number">1</span>) - cur</span><br><span class="line">                cur *= <span class="number">10</span>  <span class="comment"># next level</span></span><br><span class="line">                nxt *= <span class="number">10</span></span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">        prefix = <span class="number">1</span></span><br><span class="line">        order = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> order &lt; k:</span><br><span class="line">            count = numberOfDescendents(prefix, n)</span><br><span class="line">            <span class="keyword">if</span> order + count &lt;= k:  <span class="comment"># k-th node not in this subtree</span></span><br><span class="line">                prefix += <span class="number">1</span>   <span class="comment"># go to it's next brother tree</span></span><br><span class="line">                order += count</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># in this subtree</span></span><br><span class="line">                prefix *= <span class="number">10</span>  <span class="comment"># go to it's first child</span></span><br><span class="line">                order += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prefix</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> trie tree </tag>
            
            <tag> perfix tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>560. Subarray Sum Equals k</title>
      <link href="/programming/leetcode/subarray-sum-equals-k/"/>
      <url>/programming/leetcode/subarray-sum-equals-k/</url>
      
        <content type="html"><![CDATA[<p>Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:nums = [1,1,1], k = 2</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p>Constraints:</p><ul><li>The length of the array is in range <code>[1, 20000]</code>.</li><li>The range of numbers in the array is <code>[-1000, 1000]</code> and the range of the integer k is <code>[-1e7, 1e7]</code>.</li></ul><h1 id="using-hash-table">Using hash table</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|&lt; sum = cum-k &gt;|&lt; sum = k &gt;|</span><br><span class="line">|&lt;          sum = cum      &gt;|</span><br></pre></td></tr></table></figure><p>Using a hash table, <code>table[m] = number of subarrays whose sum equals to m</code>.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraySum</span><span class="params">(self, nums: <span class="string">'List[int]'</span>, k: int)</span> -&gt; int:</span></span><br><span class="line">        table = defaultdict(int)</span><br><span class="line">        table[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        count, cum = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            cum += n</span><br><span class="line">            <span class="keyword">if</span> (cum - k) <span class="keyword">in</span> table:</span><br><span class="line">                count += table[cum - k]</span><br><span class="line">            table[cum] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p>Similar Problem: <a href="/programming/leetcode/continuous-subarray-sum/" title="Continuous Subarray Sum">Continuous Subarray Sum</a>.</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
            <tag> array </tag>
            
            <tag> hash table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 索引</title>
      <link href="/notes/inside-mysql/mysql-indexes/"/>
      <url>/notes/inside-mysql/mysql-indexes/</url>
      
        <content type="html"><![CDATA[<h1 id="b-树">B+ 树</h1><p>B+ 树的创造者 Rudolf Bayer 没有解释 B 代表什么。最常见的观点是 B 代表平衡（balanced），因为所有的叶子节点在树中都在相同的级别上。</p><p>B+ 树是通过二叉查找树（BST），再由平衡二叉树，B 树（B-tree）演化而来。</p><ul><li><p>二叉查找树：平均查找速度较快，但最坏查找次数和顺序查找差不多。若想最大性能地构造一棵二叉查找树，需要这棵树是平衡的。</p></li><li><p>平衡二叉树：平衡二叉树的查找性能比较高，但不是最高的。因为维护一棵平衡二叉树的代价是非常大的。</p></li><li><p>B 树：B 树是一种自平衡的二叉查找树，其允许存储超过 2 个的子节点。</p><p><img src="/uploads/image/inside-mysql/b-tree.svg"></p><p>一棵 m 阶的 B 树需要满足以下性质：</p><ul><li>节点最多拥有 m - 1 个关键字。（对比二叉查找树不难理解）</li><li>根节点最少拥有 1 个关键字，非根节点最少拥有 <code>ceil(m/2) - 1</code> 个关键字。（例如，上图是一个 5 阶 B 树，非根节点最少拥有 2 个关键字）</li><li>节点中的关键字按照大小从左到右排序，每个关键字的左子树中的所有关键字都小于它，右子树中的所有关键字都大于它。</li><li>所有叶子节点都位于同一层，即根节点到每个叶子节点的长度都相同。</li></ul></li><li><p>B+ 树：通常用于数据库和操作系统的文件系统中。通过最大化在每个内部节点内的子节点的数目，减小树的高度，平衡操作不经常发生，而且效率增加了。通常需要每个节点在次级存储（如硬盘）中占据完整的磁盘块或近似的大小。</p><p>B+ 树有两种实现，关键字数 = 子节点数；关键字数 = 子节点数 - 1。原理是相同的，MySQL 技术内幕讨论的是第二种。</p><p><img src="/uploads/image/inside-mysql/b+tree.svg"></p><p>B+ 树中的节点通常被表示为一组有序的元素和指针。与 B 树不同的是：</p><ul><li>B+ 树的内部节点（也叫索引节点）不保存数据，只保存索引。所有记录都保存在叶子节点中。</li><li>所有叶子节点都在同一层（与 B 树相同），且按关键字大小自小而大顺序连接（与 B 树不同）。</li></ul></li></ul><h2 id="b-树的插入操作">B+ 树的插入操作</h2><p>B+ 树插入的三种情况</p><table><colgroup><col style="width: 25%"><col style="width: 25%"><col style="width: 50%"></colgroup><thead><tr class="header"><th>Leaf Page 满</th><th>Index Page 满</th><th>操作</th></tr></thead><tbody><tr class="odd"><td>No</td><td></td><td>直接将记录插入到叶子节点</td></tr><tr class="even"><td>Yes</td><td>No</td><td>1) 拆分 Leaf Page<br>2) 将中间的节点放到 Index Page 中<br>3) 小于中间节点的记录放左边 <br>4) 大于等于中间节点的记录放右边</td></tr><tr class="odd"><td>Yes</td><td>Yes</td><td>1) 拆分 Leaf Page<br>2) 小于中间节点的记录放左边<br>3) 大于等于中间记录的放右边<br> 4) 拆分 Index Page<br>5) 小于中间节点的记录放左边<br>6) 大于等于中间记录的放右边<br>7) 中间节点放入上一层 Index Page（若上一层已满，继续拆分）</td></tr></tbody></table><a id="more"></a><ul><li><p>Leaf Page 未满</p><p><img src="/uploads/image/inside-mysql/b+tree-insert-28.svg"></p><p>插入节点 28。（为简化作图，省略了叶子节点的前后指针）</p></li><li><p>Leaf Page 已满，Index Page 未满</p><p>在上图中插入节点 70。根据中间节点 60 进行拆分叶子节点。</p><p><img src="/uploads/image/inside-mysql/b+tree-insert-70.svg"></p></li><li><p>Leaf Page 已满，Index Page 已满</p><p>在上图中插入节点 95。先根据中间节点 85 拆分叶子节点。此时内部节点也需要拆分，按其中间节点 60 进行拆分。</p><p><img src="/uploads/image/inside-mysql/b+tree-insert-95.svg"></p></li></ul><p>为了保持平衡，对于新加入的键值可能需要做大量的拆分页操作。因为 B+ 树主要用于磁盘，页的拆分意味着磁盘的操作，所以应该在尽可能的情况下减少页的拆分操作。因此，B+ 树同样提供了类似于平衡二叉树的旋转（rotation）操作。</p><p><strong>旋转发生在 Leaf Page 已满，但是其左右兄弟节点未满的情况下</strong>。这是 B+ 树不会去做拆分页的操作，而是将记录移到所在页的兄弟节点上。</p><p>例如，插入 70 时若应用旋转操作，插入后的 B+ 树为：</p><p><img src="/uploads/image/inside-mysql/b+tree-insert-70-rotation.svg"></p><h2 id="b-树的删除操作">B+ 树的删除操作</h2><p>B+ 树使用填充因子（fill factor）来控制树的删除变化，50% 是填充因子可设的最小值。（书中的例子就是以 50% 为填充因子的，当填充因子更大时，如 60%，两个兄弟节点该如何合并，书中并未说明）</p><table><colgroup><col style="width: 25%"><col style="width: 25%"><col style="width: 50%"></colgroup><thead><tr class="header"><th>Leaf Page 小于填充因子</th><th>Index Page 小于填充因子</th><th>操作</th></tr></thead><tbody><tr class="odd"><td>No</td><td></td><td>直接将记录从叶子节点删除，若该节点在 Index Page 中有索引，还需要更新索引</td></tr><tr class="even"><td>Yes</td><td>No</td><td>合并叶子节点和它的兄弟节点，同时更新索引</td></tr><tr class="odd"><td>Yes</td><td>Yes（合并叶子节点导致的）</td><td>1) 合并叶子节点和它的兄弟节点<br>2) 更新 Index Page<br>3) 合并 Index Page 和 它的兄弟节点<br>4) 更新 Index Page 的 Index Page</td></tr></tbody></table><ul><li><p>Leaf Page 不小于填充因子</p><p>删除 70 时不需要更新内部节点；删除 25 时，因为它是叶子的第一个值，删除后需要将它之后的值 28 更新到内部节点。</p><p><img src="/uploads/image/inside-mysql/b+tree-delete-70.svg"> <img src="/uploads/image/inside-mysql/b+tree-delete-25.svg"></p></li><li><p>Leaf Page 和 Index Page 都小于填充因子</p><p>继续删除节点 60，叶子节点小于填充因子，将剩余节点移动到左兄弟，更新内部节点的索引。</p><p>索引更新后也小于填充因子，同样将剩余节点移动到左兄弟，更新上一层内部节点的索引。（怎么实现的？内部节点有没有前后指针？有没有父节点指针？）</p><p><img src="/uploads/image/inside-mysql/b+tree-delete-60.svg"></p></li></ul><h1 id="b-树索引">B+ 树索引</h1><p>B+ 树索引就是传统意义上的索引，是目前关系型数据库中查找最为常用、最有有效的索引。B+ 树索引的本质就是 B+ 树在数据库中的实现。B+ 树索引在数据库中的一个特点是高扇出性，因此在数据库中，B+ 树的高度一般都在 2～4 层，这也就是说，查找某一键值的行记录最多只需要 2 到 4 次 IO。</p><p><strong>B+ 树索引并不能找到一个给定键值的具体行。B+ 树索引能找到的只是被查找数据行所在的页，然后数据库通过把页读入到内存，再在内存中进行二分查找，最后得到要查找的数据。</strong></p><h2 id="索引的分类">索引的分类</h2><p>数据库中的 B+ 树索引可以分为<strong>聚集索引</strong>（clustered index）和<strong>辅助索引</strong>（secondary index）。与辅助索引不同的是，聚集索引在叶子节点存放的是一整行的信息。</p><ul><li><p>聚集索引</p><p>聚集索引就是按照每张表的主键构造一棵 B+ 树，同时叶子节点（聚集索引的叶子节点也称为数据页）存放的是行记录数据。表中数据也是聚集索引的一部分。</p><p>实际的数据页只能按照一棵 B+ 树进行排序，因此每张表只能拥有一个聚集索引。在多数情况下，查询优化器倾向于采用聚集索引，因为聚集索引能在叶子节点上直接找到数据。</p><p>此外，由于定义了数据的逻辑顺序，聚集索引对于主键的排序查找和范围查找非常快。</p></li><li><p>辅助索引，也称非聚集索引</p><p>辅助索引的叶子节点不包含行记录的全部数据。叶子节点除了包含键值以外，还包括一个书签（bookmark），用来告诉 InnoDB 如何找到对应的行数据。该书签就是聚集索引的键。</p><p>辅助索引的存在并不影响数据在聚集索引中的组织，因此每张表上可以有多个辅助索引。当通过辅助索引来寻找数据时，InnoDB 会遍历辅助索引并通过叶节点获得对应行数据的主键，然后再通过主键索引（即聚集索引）来找到一个完整的行记录。</p></li></ul><h2 id="索引的分裂">索引的分裂</h2><p>B+ 树索引页的分裂并不总是从页的中间记录开始，例如下面的记录：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、2、3、4、5、6、7、8、9</span><br></pre></td></tr></table></figure><p>插入是根据自增顺序进行的，若插入 10 这条记录后需要进行页的分裂操作，那么根据之前的分裂方法，会将记录 5 作为分裂点，分裂后得到下面两个页：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P1: 1、2、3、4</span><br><span class="line">P2: 5、6、7、8、9、10</span><br></pre></td></tr></table></figure><p>然而由于插入是顺序的，P1 这个页中将不会再有记录被插入，从而导致空间的浪费。（旋转能填充兄弟节点，但旋转也有开销，应该尽量避免）</p><p>InnoDB 的 Page Header 中有几个部分用来保存插入的顺序信息，通过这些信息，InnoDB 决定是向左还是向右分裂，同时决定哪一个记录为分裂点。若插入是随机的，则取页的中间记录作为分裂点。</p><h2 id="索引的管理">索引的管理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table user(name char(6), gender boolean, address varchar(100), birthday date)engine=innodb;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line"># ===== 查看表中的索引 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; show index from user;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># ===== 创建/删除 主键索引 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table user drop primary key;</span><br><span class="line">ERROR 1091 (42000): Can&apos;t DROP &apos;PRIMARY&apos;; check that column/key exists</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table user add primary key (name);</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line"># ===== 创建/删除 辅助索引 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table user add key idx_addr (address);</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table user drop key idx_addr;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line"># ===== 也可以只索引一个列的开头部分数据 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table user add key idx_addr (address(2));  # 只索引开头</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table user add key idx_birth_name (birthday, name);  # 联合索引</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line"># ===== SHOW INDEX 各列含义 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; show index from user\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">        Table: user     # 索引所在的表</span><br><span class="line">   Non_unique: 0        # 非唯一索引，主键索引是唯一的，值为 0</span><br><span class="line">     Key_name: PRIMARY  # 索引的名字</span><br><span class="line"> Seq_in_index: 1        # 列在索引中的位置，看联合索引比较直观</span><br><span class="line">  Column_name: name     # 列的名字</span><br><span class="line">    Collation: A        # 列以什么方式存储在索引中。A（排序的） 或 NULL</span><br><span class="line">  Cardinality: 0        # 索引中唯一值的数目（估计值）</span><br><span class="line">     Sub_part: NULL     # 是否是部分被索引</span><br><span class="line">       Packed: NULL     # 关键字如何被压缩</span><br><span class="line">         Null:          # 列中是否含有 NULL 值</span><br><span class="line">   Index_type: BTREE    # 索引类型，InnoDB 只支持 B+ 树索引</span><br><span class="line">      Comment:          # 注释</span><br><span class="line">Index_comment:</span><br><span class="line">      Visible: YES</span><br><span class="line">   Expression: NULL</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">        Table: user</span><br><span class="line">   Non_unique: 1         # 辅助索引不是唯一的，值为 1</span><br><span class="line">     Key_name: idx_addr</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: address</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: 2         # 只对前 2 个字符进行索引</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: YES</span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment:</span><br><span class="line">Index_comment:</span><br><span class="line">      Visible: YES</span><br><span class="line">   Expression: NULL</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">        Table: user</span><br><span class="line">   Non_unique: 1         # birthday 是索引 (birthday, name) 的第 1 个列</span><br><span class="line">     Key_name: idx_birth_name</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: birthday</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: YES</span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment:</span><br><span class="line">Index_comment:</span><br><span class="line">      Visible: YES</span><br><span class="line">   Expression: NULL</span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">        Table: user</span><br><span class="line">   Non_unique: 1</span><br><span class="line">     Key_name: idx_birth_name</span><br><span class="line"> Seq_in_index: 2</span><br><span class="line">  Column_name: name</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null:</span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment:</span><br><span class="line">Index_comment:</span><br><span class="line">      Visible: YES</span><br><span class="line">   Expression: NULL</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="cardinality">Cardinality</h2><p>Cardinality: the number of elements in a set or other grouping, as a property of that grouping.</p><p>并不是所有的列都需要添加索引。</p><ul><li><p>低选择性</p><p>对于性别、地区、类型字段，它们可取的范围很小，称为低选择性。比如，按性别进行查询时，可取的值的范围一般只有 'M', 'F'，因此 <code>select * from student where sex='F';</code> 得到结果可能是表中 50% 的数据（假设男女比例 1:1），这时添加性别索引是完全没有必要的。</p></li><li><p>高选择性</p><p>如果某个字段的取值范围很广，几乎没有重复，即属于高选择性。此时使用 B+ 树索引是最合适的。例如，对于姓名字段，基本上在一个应用中不允许重名的出现。</p></li></ul><p>Cardinality 值表示索引中不重复记录数量的预估值，注意，是预估值而不是准确值。在实际应用中，<code>Cardinality / n_rows_in_table</code> 应尽可能地接近 1。</p><p>数据库是如何统计 Cardinality 信息的呢？因为每种存储引擎对于 B+ 树索引的实现各不相同，所以对 Cardinality 的统计是放在存储引擎层进行的。</p><p>在生产环境中，索引的更新操作可能是非常频繁的。如果每次更新时就进行 Cardinality 的统计，那么将会给数据库带来很大的负担。此外，如果一张表的数据非常大，那么一次统计 Cardinality 信息所需的时间可能非常长。因此，<strong>数据库对 Cardinality 的统计都是采用采样（sample）的方式来完成的</strong>。</p><p>在 InnoDB 中，Cardinality 的更新发生在两个操作中：INSERT 和 UPDATE。不可能每次都发生 INSERT 和 UPDATE 都更新，InnoDB 更新 Cardinality 信息的策略为：</p><ul><li>表中 1/16 的数据已发生过改变</li><li><code>stat_modified_counter &gt; 2 000 000 000</code></li></ul><p>第二种情况考虑的是，如果对表中某一行数据频繁地进行更新操作，发生变化的是这一行数据，此时第一种更新策略无法适用。</p><p>采样方法：InnoDB 随机选择 8 个叶子节点，统计每个页不同记录的数目，记为 <code>P1, ..., P8</code>。设 A 是叶子节点的数目，则<code>Cardinality = (P1 + ... + P8) * A / 8</code>。</p><p>语句 <code>SHOW INDEX FROM</code> 会触发 MySQL 数据库对 Cardinality 的统计，统计是通过随机采样完成的。因此，即使没有改变表中的内容，Cardinality 的值还是可能发生变化。</p><h1 id="联合索引">联合索引</h1><p>从本质上来说，联合索引也是一棵 B+ 树，不同的是联合索引的键值的数量不止一个。</p><p>例如，一个联合索引为 <code>(a, b)</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">               +-+-------+-+</span><br><span class="line">               | | (2,4) | |</span><br><span class="line">               +-+-------+-+</span><br><span class="line">               /           \</span><br><span class="line">(1,1)、(1,2)、(2,1)       (2,4)、(3,1)、(3,2)</span><br></pre></td></tr></table></figure><p>可以使用该联合索引的语句：</p><ul><li><code>select * from t where a=1;</code></li><li><code>select * from t where a=1 and b=2;</code></li><li><code>select * from t where a=1 order by b;</code></li></ul><p>不可以使用该联合索引的语句：</p><ul><li><code>select * from t where b=2;</code></li><li><code>select * from t order by b;</code></li></ul><p>因为在叶子节点上，<code>(a)</code> 和 <code>(a, b)</code> 都是排序的，而 <code>(b)</code> 的值不是排序的。</p><p>看一个例子。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ===== 准备测试表 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; create table buy_log(</span><br><span class="line">    -&gt;   userid int unsigned not null,</span><br><span class="line">    -&gt;   buy_date date</span><br><span class="line">    -&gt; )engine=innodb;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into buy_log values</span><br><span class="line">    -&gt; (1,&apos;2009-01-01&apos;),</span><br><span class="line">    -&gt; (2,&apos;2009-01-01&apos;),</span><br><span class="line">    -&gt; (3,&apos;2009-01-01&apos;),</span><br><span class="line">    -&gt; (1,&apos;2009-02-01&apos;),</span><br><span class="line">    -&gt; (3,&apos;2009-02-01&apos;),</span><br><span class="line">    -&gt; (1,&apos;2009-03-01&apos;),</span><br><span class="line">    -&gt; (1,&apos;2009-04-01&apos;);</span><br><span class="line">Query OK, 7 rows affected (0.00 sec)</span><br><span class="line">Records: 7  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line"># ===== 创建了两个索引 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table buy_log add key(userid);</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table buy_log add key(userid, buy_date);</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p>如果只对 userid 进行查询，既可以使用 userid 这个索引，也可以使用 (userid, buy_date) 这个联合索引。优化器最终的选择是索引 userid，因为该索引包含单个键值，所以理论上一个页能存放的记录更多。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from buy_log where userid=2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: buy_log</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: userid,userid_2  # 可使用的索引</span><br><span class="line">          key: userid           # 优化器选择了 userid 索引</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>如果要取出 userid=1 的最近 3 次记录，这次优化器使用了联合索引，因为在联合索引中 buy_date 已经排好序了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from buy_log where userid=1 order by buy_date desc limit 3\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: buy_log</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: userid,userid_2</span><br><span class="line">          key: userid_2                # 优化器选择了联合索引</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 4</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Backward index scan; Using index  # 索引扫描</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line"># ===== 若强制使用 userid 索引 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from buy_log force index(userid) where userid=1 order by buy_date desc limit 3\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: buy_log</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: userid</span><br><span class="line">          key: userid          # 强制使用 userid</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 4</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using filesort  # 需要一次排序</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><h1 id="覆盖索引">覆盖索引</h1><p>覆盖索引（covering index，或称索引覆盖）即从辅助索引中就可以得到查询的记录，而不需要再次查询聚集索引。（覆盖索引不是一种索引，而是一种使用索引的方法）</p><p>使用覆盖索引的一个好处是，辅助索引不包含行记录的所有信息，故其大小要远小于聚集索引，因此可以减少 I/O 操作。</p><p>辅助索引的另一个好处是对某些统计问题而言的。<strong>列 Extra 的 Using index 代表优化器进行了覆盖索引操作</strong>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ===== 统计所有记录数 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select count(*) from buy_log\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: buy_log</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index</span><br><span class="line">possible_keys: NULL      # 可使用索引为 NULL</span><br><span class="line">          key: userid    # 实际选择了 userid 这个辅助索引</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 7</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>表 buy_log 中有 (userid, buy_date) 联合索引，一般情况下，只根据列 buy_date 进行条件查询是不能使用联合索引的（这里就不是一般情况），因为联合索引中记录不是按 buy_date 排序的。</p><p>这里不一般是因为表只有两个列，且全部包含在联合索引中，所以使用该联合索引能覆盖要查询的整行信息。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ===== 只针对列 buy_date 进行条件查询 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from buy_log where buy_date&gt;=&apos;2011-01-01&apos; and buy_date&lt;=&apos;2011-02-01&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: buy_log</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index</span><br><span class="line">possible_keys: userid_2</span><br><span class="line">          key: userid_2  # 使用联合索引</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 7</span><br><span class="line">     filtered: 14.29</span><br><span class="line">        Extra: Using where; Using index</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line"># ===== 随便加一个列 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table buy_log add price decimal;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line"># ===== 再次针对 buy_date 进行条件查询 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from buy_log where buy_date&gt;=&apos;2011-01-01&apos; and buy_date&lt;=&apos;2011-02-01&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: buy_log</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL    # 联合索引中没有 price 的值</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 7</span><br><span class="line">     filtered: 14.29</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>但是，若查询是针对 buy_date 的统计操作：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ===== 统计某段时间内的记录数 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select count(*) from buy_log where buy_date&gt;=&apos;2011-01-01&apos; and buy_date&lt;=&apos;2011-02-01&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: buy_log</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index</span><br><span class="line">possible_keys: userid_2</span><br><span class="line">          key: userid_2    # 使用联合索引</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 7</span><br><span class="line">     filtered: 14.29</span><br><span class="line">        Extra: Using where; Using index  # 使用了覆盖索引</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><h1 id="不使用索引的情况">不使用索引的情况</h1><p>在某些情况下，当执行 EXPLAIN 命令进行 SQL 语句的分析时，会发现优化器没有选择（辅助）索引去查找数据，而是通过扫描聚集索引，也就是直接进行全表扫描来得到数据。这种情况多发生于范围查找、JOIN 链接操作等情况下。</p><p>原因在于用户要选取的数据，不能被（辅助）索引完全覆盖。<strong>在使用（辅助）索引查到指定数据后，还需要一次书签访问来查找缺少的信息，而书签查找的数据则是无序的，因此变为了磁盘上的离散读操作</strong>。如果访问的数据量很小，优化器会选择辅助索引，但是当访问的数据占整个表的蛮大一部分时（一般是 20% 左右），优化器会选择通过聚集索引来查找数据。因为顺序读要远远快于离散读。（如何知道占比？）</p><p>若用户使用的磁盘是固态硬盘，随机读操作非常快，同时有足够的自信确认使用辅助索引可以带来更好的性能，那么可以使用 FORCE INDEX 强制使用某个索引。</p><h1 id="索引提示">索引提示</h1><p>MySQL 支持使用索引提示，显示地告诉优化器使用哪个索引。以下两种情况可能需要用到索引提示：</p><ul><li>优化器错误地选择了某个索引，导致 SQL 语句运行的很慢。这种情况非常非常的少见，优化器在绝大部分情况下工作得非常正确和有效。</li><li>某 SQL 语句可以选择的索引非常多，这是优化器执行的开销可能会大于 SQL 语句本身。例如，优化器分析 Range 查询本身就是比较耗时的操作。</li></ul><p>如果用户确定指定某个索引来完成查询，最可靠的是使用 FORCE INDEX：</p><ul><li><code>USE INDEX(idx)</code>：告诉优化器可以使用 idx 索引（设置的是 possible_keys 列的值），优化器还会再根据自己的判断进行选择，即不一定最终选择 idx。</li><li><code>FORCE INDEX(idx)</code>：强制使用 idx 索引（设置的是 key 列的值）。</li></ul><h1 id="multi-range-read-优化">Multi-Range Read 优化</h1><p>MySQL 5.6 开始支持 Multi-Range Read（MRR）优化。MRR 优化的目的是为了减少磁盘的随机访问，并且将随机访问转化为较为顺序的数据访问，这对 IO-bound 类型的 SQL 查询语句可带来性能极大的提升。MRR 优化可适用于 range, ref, eq_ref 类型的查询。</p><p>对于 InnoDB 和 MyISAM 的范围查询和 JOIN 查询，MRR 的工作方式如下：</p><ul><li>将查询得到的索引键值存放于一个缓存中。</li><li>将缓存中的键值根据 RowID 进行排序。</li><li>根据 RowID 的排序顺序来访问实际的数据文件。</li></ul><p>MRR 优化有以下几个好处：</p><ul><li>使数据访问变得较为顺序。顺序读快于离散读。</li><li>减少缓冲池中页被替换的次数。若存储引擎的缓冲池不够大，频繁的离散读操作会导致缓存中的页被替换出缓冲池，然后又有可能被再次读入。若按照主键顺序进行访问，则可以将此重复行为降至最低。</li><li><p>批量处理对键值的查询操作。MRR 可以将某些范围查询，拆分成键值对，以此来进行批量的数据查询。这样做的好处是可以在拆分过程中，<strong>直接过滤一些不符合查询条件的数据</strong>。</p><p>例如，<code>select * from t where key1 &gt;= 1000 and key1 &lt; 2000 and key2 = 10000;</code>。表中有 <code>(key1, key2)</code> 的联合索引，若没有 MRR，此时查询类型为 Range，优化器会先将 <code>key1 &gt;= 1000 and key1 &lt; 2000</code> 的数据都取出，再根据 <code>key2 = 10000</code> 进行过滤。这会导致无用数据被取出。</p><p>若启用了 MRR 优化，优化器会先将查询条件进行拆分，就上述查询语句而言，优化器会将查询条件拆分为 <code>(1000, 10000), (1001, 10000), ..., (1999, 10000)</code>，然后再根据拆分出的条件进行数据的查询。</p></li></ul><p>是否启用了 MRR 优化可以通过参数 optimizer_switch 中的标记来控制。</p><ul><li>mrr：是否启用 MRR优化。</li><li>mrr_cost_based：是否通过 cost based 的方式启用 MRR 优化。若 <code>mrr=on,mrr_cost_based=off</code> 则总是启用 MRR 优化。</li></ul><p>参数 read_rnd_buffer_size 用来控制键值的缓冲区大小，默认值是 256K。当缓存大于该值时，则执行器对已经缓存的数据根据 RowID 进行排序，并通过 RowID 来取得行数据。</p><h1 id="index-condition-pushdown-优化">Index Condition Pushdown 优化</h1><p>Index Condition Pushdown（ICP）同样是 MySQL 5.6 开始支持的一种根据索引进行查询的优化方式。在这之前，当进行索引查询时，首先根据索引来查找记录，再根据 WHERE 条件来过滤记录。<strong>支持 ICP 后，MySQL 会在取出索引的同时，判断是否可以进行 WHERE 条件的过滤</strong>，将 WHERE 的部分过滤操作放在了存储引擎层。在某些查询下，可以大大减少上层 SQL 层对记录的索取（fetch），从而提高数据库的整体性能。</p><p>ICP 优化支持 range, ref, eq_ref, ref_or_null 类型的查询，当前（书中用的版本挺老了，可能是 5.x）支持 MyISAM 和 InnoDB 存储引擎。当优化器选择 ICP 优化时，可在执行计划的列 Extra 看到 Using index condition 提示。</p><p>假设某张表有联合索引 <code>(zip_code, last_name, first_name)</code>，并且查询语句为</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> people</span><br><span class="line"><span class="keyword">where</span> zip_code=<span class="string">'95054'</span></span><br><span class="line"><span class="keyword">and</span> lastname <span class="keyword">like</span> <span class="string">'%etrunia%'</span></span><br><span class="line"><span class="keyword">and</span> address <span class="keyword">like</span> <span class="string">'%Main Street%'</span>;</span><br></pre></td></tr></table></figure><p>若不支持 ICP 优化，则数据库先通过索引取出所有 <code>zip_code='95054'</code> 的记录，再按后两个条件过滤。若支持 ICP 优化，则在索引取出时，就会进行 WHERE 条件的过滤，然后再去获取记录。这将大大地提高查询的效率。当然，过滤的条件要在该索引可以覆盖的范围（address 必须在取到完整记录后才能过滤）。</p><h1 id="哈希算法">哈希算法</h1><p>InnoDB 使用哈希算法进行查找，其冲突机制采用链接法（chaining），对于缓冲池页的哈希表来说，每个页都有一个 chain 指针，指向相同哈希函数值的页。</p><p>哈希函数采用除法散列（<code>h(k) = k % m</code>）方式，m 的取值为略大于 2 倍页数量的质数。例如：当 innodb_buffer_pool_size 的大小为 10M，则共有 640 个 16K 的页，哈希表中需要分配 640x2=1280 个槽，但是由于 1280 不是质数，需要取比 1280 略大的一个质数，应该是 1399。</p><p>如何计算页的 k 呢？InnoDB 的表空间都有一个 space_id，用户所要查询的应该是某个表空间的某个连续 16KB 的页，即偏移量 offset。InnoDB 将 space_id 左移 20 位，然后加上这个 space_id 和 offset，即 <code>k = (space_id &lt;&lt; 20) + space_id + offset</code>，再通过除法散列到各个槽中。</p><h2 id="自适应哈希索引">自适应哈希索引</h2><p>自适应哈希索引采用上述哈希表的方式实现。不同的是，<strong>这仅是数据库自身创建并使用的，DBA 并不能对其进行干预</strong>。自适应哈希索引经哈希函数映射到一个哈希表中，对于等值查询非常快速，如 <code>select * from t where key='xxx';</code>。但是对于范围查询就无能为力了。</p><p>通过命令 <code>show engine innodb status</code> 可以看到当前自适应索引的使用情况。</p><h1 id="全文检索">全文检索</h1><p>B+ 树索引支持通过字段的前缀进行查找，例如 <code>select * from blog where content like 'xxx%';</code> 可以查询内容以 xxx 开头的文章，并且只要 content 添加了 B+ 树索引，就能利用索引进行快速查询。</p><p>然而实际这种查询不符合用户的需求，因为在更多的情况下，用户需要查询的是博客内容包含某个单词 xxx 的文章，即 <code>select * from blog where content like '%xxx%';</code>。</p><p>全文检索（Full-Text Search）是将存储于数据库中的整本书或整篇文章中的任意内容信息检索出来的技术。它可以根据需要获得全文中的章、节、段、句、词等信息，也可以进行各种统计和分析。</p><p>从 InnoDB 1.2.x 版本开始，InnoDB 开始支持全文检索，其支持 MyISAM 存储引擎的全部功能，并且还支持其他的一些特性。</p><h2 id="倒排索引">倒排索引</h2><p>全文检索通常使用倒排索引（inverted index）来实现。倒排索引在辅助表中存储了单词与单词自身在一个或多个文档中所在位置之间的映射。这通常利用关联数组实现，其拥有两种表现形式：</p><ul><li>inverted file index，表现形式为 <code>(单词, 单词所在文档的 ID)</code>。</li><li>full inverted index，表现形式为 <code>(单词, 单词所在文档的 ID, 在文档中的具体位置)</code>。full inverted index 占用更多的空间，但是能更好地定位数据，并扩充一些其他的搜索特性。</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ===== 表 =====</span><br><span class="line"></span><br><span class="line">Id  Text</span><br><span class="line">1   Pease porridge hot, pease porridge cold</span><br><span class="line">2   Pease porridge in the pot</span><br><span class="line">3   Nine days old</span><br><span class="line"></span><br><span class="line"># ===== inverted file index =====</span><br><span class="line"></span><br><span class="line">Id  Text      Document</span><br><span class="line">1   code      1        # code 存在于文档 1 中</span><br><span class="line">2   days      3</span><br><span class="line">3   hot       1</span><br><span class="line">4   in        2</span><br><span class="line">5   nine      3</span><br><span class="line">6   old       3</span><br><span class="line">7   pease     1,2      # pease 存在于文档 1 和 2 中</span><br><span class="line">8   porridge  1,2</span><br><span class="line">9   pot       2</span><br><span class="line">10  the       2</span><br><span class="line"></span><br><span class="line"># ===== full inverted index =====</span><br><span class="line"></span><br><span class="line">Id  Text      Document</span><br><span class="line">1   code      (1,6)        # code 是文档 1 中的第 6 个单词</span><br><span class="line">2   days      (3,2)</span><br><span class="line">3   hot       (1,3)</span><br><span class="line">4   in        (2,3)</span><br><span class="line">5   nine      (3,1)</span><br><span class="line">6   old       (3,3)</span><br><span class="line">7   pease     (1,1), (1,4), (2,1)</span><br><span class="line">8   porridge  (1,2), (1,5), (2,2)</span><br><span class="line">9   pot       (2,5)</span><br><span class="line">10  the       (2,4)</span><br></pre></td></tr></table></figure><h2 id="innodb-全文检索">InnoDB 全文检索</h2><p>InnoDB 采用 full inverted index 的方式。由于存放了 word 的 position 信息，故可以进行 Proximity Search（临近查询，临近指的是两个单词之间的距离）。</p><p>倒排索引需要将 word 存放到一张表中，称为辅助表（Auxiliary Table）。在 InnoDB 中，为了提高全文检索的并行性能，共有 6 张辅助表，每张表根据 word 的 Latin 编码进行分区。</p><p>辅助表是持久的表，存放于磁盘上。在全文索引中，还有一个重要的概念 FTS Index Cache（全文检索索引缓存，以下简称 FTSIC），其用来提高全文检索的性能。</p><p>全文检索索引缓存是一个红黑树结构，其根据 <code>(word, (documentId, position))</code> 进行排序。InnoDB 会批量对辅助表进行更新，向源数据表中插入记录后，将通过分词得到的 full inverted index 存入 FTSIC，而不是更新辅助表。当进行全文检索时，首先将 FTSIC 中对应的 word 字段合并到辅助表，再进行查询。</p><p>InnoDB 允许用户查看指定倒排索引的辅助表中分词的信息，通过设置全局参数 innodb_ft_aux_table 指定想查看的表，之后查询 information_schema 架构下的 INNODB_FT_INDEX_TABLE 即可看到分词信息。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; set global innodb_ft_aux_table=&apos;test/fts&apos;;    # test 架构下的 fts 表</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.innodb_ft_index_table;  # 查看分词信息</span><br></pre></td></tr></table></figure><p>当数据库关闭时，FTSIC 中的数据会同步到辅助表。然而，当数据库发生宕机时，一些数据可能未被同步到磁盘上，那么下次重启数据库时，当用户进行全文检索（查询或者插入）时，InnoDB 会自动读取未完成的文档，然后进行分词操作，再将分词的结果放入 FTSIC 中。参数 innodb_ft_cache_size 用来控制 FTSIC 的大小，默认值为 32M。增大该参数可以提高全文检索的性能，但是在宕机后，可能需要更长的时间恢复。</p><h3 id="fts-document-id">FTS Document ID</h3><p>FTS Document ID 是另一个重要的概念。为了支持全文检索，必须有一个列与 word 进行映射，在 InnoDB 中这个列被命名为 FTS_DOC_ID，其类型必须是 BIGINT UNSIGNED NOT NULL，并且 InnoDB 会在该列上加上一个名为 FTS_DOC_ID_INDEX 的 Unique Index（我没看到，还是自己加上该索引吧）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table fts(FTS_DOC_ID bigint unsigned not null, body text);</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show index from fts;</span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure><p>对于删除操作，不删除辅助表中的记录，而只是删除 FTSIC 中的记录。对于被删除的记录，InnoDB 会记录其 FTS Document ID，并将其保存在 ”删除辅助表“ 中。由于 DML 操作不会删除索引中的数据，因此索引会变得非常大。为此，InnoDB 允许用户通过命令 OPTIMIZE TABLE 手工地将已经删除的记录从索引中彻底删除。OPTIMIZE TABLE 还会进行一些其他的操作，如 Cardinality 的重新统计，若用户希望仅对倒排索引进行操作，可以通过全局参数 innodb_optimize_fulltext_only 进行设置。</p><p>若被删除的文档非常多，那么 OPTIMIZE TBALE 操作可能需要占用非常多的时间，这会影响应用程序的并发行，并极大地降低用户的响应时间。可以通过设置参数 innodb_ft_num_word_optimize 来限制每次实际删除的分词数量。默认值为 2000。</p><h3 id="例子">例子</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ===== 准备测试表 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; create table fts(</span><br><span class="line">    -&gt;   FTS_DOC_ID bigint unsigned not null auto_increment,  # 添加自增属性</span><br><span class="line">    -&gt;   body text,</span><br><span class="line">    -&gt;   primary key(FTS_DOC_ID)                              # 加上主键索引</span><br><span class="line">    -&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts(body) values</span><br><span class="line">    -&gt; (&apos;Pease porridge in the pot&apos;),</span><br><span class="line">    -&gt; (&apos;Pease porridge hot, pease porridge cold&apos;),</span><br><span class="line">    -&gt; (&apos;Nine days old&apos;);</span><br><span class="line">Query OK, 3 rows affected (0.00 sec)</span><br><span class="line">Records: 3  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; create fulltext index idx_fts on fts(body);  # 添加全文索引</span><br><span class="line">Query OK, 0 rows affected (0.04 sec)                # 先插入数据，再创建索引，是一种比较推荐的方式</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from fts;</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">| FTS_DOC_ID | body                                    |</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">|          1 | Pease porridge in the pot               |</span><br><span class="line">|          2 | Pease porridge hot, pease porridge cold |</span><br><span class="line">|          3 | Nine days old                           |</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># ===== 查看辅助表 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; set global innodb_ft_aux_table=&apos;test/fts&apos;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.innodb_ft_index_table;</span><br><span class="line">+----------+--------------+-------------+-----------+--------+----------+</span><br><span class="line">| WORD     | FIRST_DOC_ID | LAST_DOC_ID | DOC_COUNT | DOC_ID | POSITION |</span><br><span class="line">+----------+--------------+-------------+-----------+--------+----------+</span><br><span class="line">| cold     |            2 |           2 |         1 |      2 |       35 |</span><br><span class="line">| days     |            3 |           3 |         1 |      3 |        5 |</span><br><span class="line">| hot      |            2 |           2 |         1 |      2 |       15 |</span><br><span class="line">| nine     |            3 |           3 |         1 |      3 |        0 |</span><br><span class="line">| old      |            3 |           3 |         1 |      3 |       10 |</span><br><span class="line">| pease    |            1 |           2 |         2 |      1 |        0 |</span><br><span class="line">| pease    |            1 |           2 |         2 |      2 |        0 |</span><br><span class="line">| pease    |            1 |           2 |         2 |      2 |       20 |</span><br><span class="line">| porridge |            1 |           2 |         2 |      1 |        6 |</span><br><span class="line">| porridge |            1 |           2 |         2 |      2 |        6 |</span><br><span class="line">| porridge |            1 |           2 |         2 |      2 |       20 |</span><br><span class="line">| pot      |            1 |           1 |         1 |      1 |       22 |</span><br><span class="line">+----------+--------------+-------------+-----------+--------+----------+</span><br><span class="line">12 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>可以看到每个 word 都对应了一个 DOC_ID 和 POSITION（单位是字符）。此外，还记录了 FIRST_DOC_ID（第一次出现的文档 ID）、LAST_DOC_ID（最后一次出现的文档 ID）及 DOC_COUNT（在多少个文档内出现）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ===== 删除一条记录 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; delete from fts where FTS_DOC_ID=3;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.innodb_ft_deleted;</span><br><span class="line">+--------+</span><br><span class="line">| DOC_ID |</span><br><span class="line">+--------+</span><br><span class="line">|      3 |</span><br><span class="line">+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.innodb_ft_index_table;  # 辅助表中文档 3 依然存在</span><br><span class="line">+----------+--------------+-------------+-----------+--------+----------+</span><br><span class="line">| WORD     | FIRST_DOC_ID | LAST_DOC_ID | DOC_COUNT | DOC_ID | POSITION |</span><br><span class="line">+----------+--------------+-------------+-----------+--------+----------+</span><br><span class="line">| cold     |            2 |           2 |         1 |      2 |       35 |</span><br><span class="line">| days     |            3 |           3 |         1 |      3 |        5 |</span><br><span class="line">| hot      |            2 |           2 |         1 |      2 |       15 |</span><br><span class="line">| nine     |            3 |           3 |         1 |      3 |        0 |</span><br><span class="line">| old      |            3 |           3 |         1 |      3 |       10 |</span><br><span class="line">| pease    |            1 |           2 |         2 |      1 |        0 |</span><br><span class="line">| pease    |            1 |           2 |         2 |      2 |        0 |</span><br><span class="line">| pease    |            1 |           2 |         2 |      2 |       20 |</span><br><span class="line">| porridge |            1 |           2 |         2 |      1 |        6 |</span><br><span class="line">| porridge |            1 |           2 |         2 |      2 |        6 |</span><br><span class="line">| porridge |            1 |           2 |         2 |      2 |       20 |</span><br><span class="line">| pot      |            1 |           1 |         1 |      1 |       22 |</span><br><span class="line">+----------+--------------+-------------+-----------+--------+----------+</span><br><span class="line">12 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global innodb_optimize_fulltext_only=1;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; optimize table fts;</span><br><span class="line">+----------+----------+----------+----------+</span><br><span class="line">| Table    | Op       | Msg_type | Msg_text |</span><br><span class="line">+----------+----------+----------+----------+</span><br><span class="line">| test.fts | optimize | status   | OK       |</span><br><span class="line">+----------+----------+----------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.innodb_ft_index_table;</span><br><span class="line">+----------+--------------+-------------+-----------+--------+----------+</span><br><span class="line">| WORD     | FIRST_DOC_ID | LAST_DOC_ID | DOC_COUNT | DOC_ID | POSITION |</span><br><span class="line">+----------+--------------+-------------+-----------+--------+----------+</span><br><span class="line">| cold     |            2 |           2 |         1 |      2 |       35 |</span><br><span class="line">| hot      |            2 |           2 |         1 |      2 |       15 |</span><br><span class="line">| pease    |            1 |           2 |         2 |      1 |        0 |</span><br><span class="line">| pease    |            1 |           2 |         2 |      2 |        0 |</span><br><span class="line">| pease    |            1 |           2 |         2 |      2 |       20 |</span><br><span class="line">| porridge |            1 |           2 |         2 |      1 |        6 |</span><br><span class="line">| porridge |            1 |           2 |         2 |      2 |        6 |</span><br><span class="line">| porridge |            1 |           2 |         2 |      2 |       20 |</span><br><span class="line">| pot      |            1 |           1 |         1 |      1 |       22 |</span><br><span class="line">+----------+--------------+-------------+-----------+--------+----------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from  information_schema.innodb_ft_deleted;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from  information_schema.innodb_ft_being_deleted;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into fts values(3, &apos;Nine days old&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>以下是 MySQL 8 与原文中的不同之处：</p><ul><li>优化后 information_schema.innodb_ft_deleted 表中的记录也被删除了。</li><li>删除的文档 ID 3 没有被记录到 information_schema.innodb_ft_being_deleted 表中。</li><li>可以再次插入 ID 为 3 的记录。</li></ul><h3 id="stopword">stopword</h3><p>stopword 列表中的单词不需要对其进行索引分词操作。例如，对于 the 这个单词，由于其不具有具体的意义，将其视为 stopword。InnoDB 有一张默认的 stopword 列表，位于 <code>information_schema.innodb_ft_default_stopword</code>，默认有 36 个 stopword。用户可以通过参数 innodb_ft_server_stopword_table 来指定 stopword 列表。</p><p>当前 InnoDB 的全文检索还存在以下的限制：</p><ul><li>每张表只能有一个全文检索的索引。（MySQL 8 可以）</li><li>由多列组合而成的全文检索索引，列必须使用相同的字符集与排序规则。（没测试）</li><li>不支持没有单词定界符的语言，如中文、日语、韩语等。（MySQL 8 也不支持）</li></ul><h2 id="全文检索查询">全文检索查询</h2><p>MySQL 通过 <code>MATCH(...) AGAINST(...)</code> 语法支持全文检索查询。MATCH 指定了需要被查询的列，AGAINST 指定了使用何种方法进行查询。</p><h3 id="natural-language-mode">Natural Language Mode</h3><p>全文检索默认采用 Natural Language 模式，表示查询带有指定 word 的文档。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from fts;</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">| FTS_DOC_ID | body                                    |</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">|          1 | Pease porridge in the pot               |</span><br><span class="line">|          2 | Pease porridge hot, pease porridge cold |</span><br><span class="line">|          3 | Nine days old                           |</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from fts where body like &apos;%pease%&apos;;</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">| FTS_DOC_ID | body                                    |</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">|          1 | Pease porridge in the pot               |</span><br><span class="line">|          2 | Pease porridge hot, pease porridge cold |</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># ===== 查询单词 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from fts</span><br><span class="line">    -&gt; where match(body)    # in natural language mode 可省略</span><br><span class="line">    -&gt; against(&apos;pease&apos; in natural language mode);</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">| FTS_DOC_ID | body                                    |</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">|          2 | Pease porridge hot, pease porridge cold |</span><br><span class="line">|          1 | Pease porridge in the pot               |</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from fts where match(body) against(&apos;pease&apos;)\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: fts</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: fulltext</span><br><span class="line">possible_keys: idx_fts</span><br><span class="line">          key: idx_fts     # 使用全文索引</span><br><span class="line">      key_len: 0</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where; Ft_hints: sorted</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>在 WHERE 条件中使用 MATCH 函数，查询返回的结果是根据相关性进行降序排序的，0 表示没有相关性。上述查询中，由于 pease 在文档 2 中出现了两次，因而具有更高的相关性，故第一个显示。</p><p>为了统计 MATCH 函数得到的结果数量，可以用下列 SQL 语句：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">as</span> <span class="keyword">count</span> <span class="keyword">from</span> fts <span class="keyword">where</span> <span class="keyword">match</span>(<span class="keyword">body</span>) against(<span class="string">'pease'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">if</span>(<span class="keyword">match</span>(<span class="keyword">body</span>) against(<span class="string">'pease'</span>), <span class="number">1</span>, <span class="literal">null</span>)) <span class="keyword">as</span> <span class="keyword">count</span> <span class="keyword">from</span> fts;</span><br></pre></td></tr></table></figure><p>两句 SQL 得到的逻辑结果是相同的，但是从内部运行来看，第二句的执行速度可能更快些。因为第一句还需要进行相关性的排序统计，而第二句不需要。用户可以查看相关性（即 SELECT MATCH 函数的返回结果，而不是将其作为 WHERE 的条件）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select fts_doc_id as id, body,</span><br><span class="line">    -&gt;   match(body) against (&apos;pease&apos;) as relevance</span><br><span class="line">    -&gt; from fts;</span><br><span class="line">+----+-----------------------------------------+----------------------------+</span><br><span class="line">| id | body                                    | relevance                  |</span><br><span class="line">+----+-----------------------------------------+----------------------------+</span><br><span class="line">|  1 | Pease porridge in the pot               | 0.000000001885928302414186 |</span><br><span class="line">|  2 | Pease porridge hot, pease porridge cold | 0.000000003771856604828372 |</span><br><span class="line">|  3 | Nine days old                           |                          0 |</span><br><span class="line">+----+-----------------------------------------+----------------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>InnoDB 的全文检索，还需要考虑以下的因素：</p><ul><li>忽略 stopword 列表中的单词。</li><li>只查询长度在 <code>[innodb_ft_min_token_size, innodb_ft_max_token_size]</code> 内的单词，默认值是 <code>[3, 84]</code>。</li></ul><h3 id="boolean-mode">Boolean Mode</h3><p>Boolean 全文检索支持以下操作符：</p><table><thead><tr class="header"><th>布尔操作符</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>+</code></td><td>必须存在，例如 <code>+pease</code> 表示 pease 必须存在</td></tr><tr class="even"><td><code>-</code></td><td>必须被排除</td></tr><tr class="odd"><td>无操作符</td><td>可选的，但是如果出现，其相关性会更高</td></tr><tr class="even"><td><code>@</code></td><td>临近查询，例如 <code>&quot;pease pot&quot;@30</code> 将查询 pease 和 pot 距离在 30 个字符内的文章</td></tr><tr class="odd"><td><code>&gt;</code></td><td>出现时增加相关性</td></tr><tr class="even"><td><code>&lt;</code></td><td>出现时降低相关性</td></tr><tr class="odd"><td><code>~</code></td><td>出现时相关性为负</td></tr><tr class="even"><td><code>*</code></td><td>词尾通配符，例如 <code>lik*</code> 可以匹配 <code>lik</code>、<code>like</code></td></tr><tr class="odd"><td><code>&quot; &quot;</code></td><td>定义短语，例如 <code>'&quot;like hot&quot;'</code> 将 like hot 视为一个短语，而不是两个单词</td></tr></tbody></table><p>例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ===== 查询同时包含 pease 和 hot 的文章 ====</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from fts</span><br><span class="line">    -&gt; where match(body) against (&apos;+pease +hot&apos; in boolean mode);</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">| FTS_DOC_ID | body                                    |</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">|          2 | Pease porridge hot, pease porridge cold |</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># ===== 临近搜索 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from fts</span><br><span class="line">    -&gt; where match(body) against (&apos;&quot;pease pot&quot;@30&apos; in boolean mode);</span><br><span class="line">+------------+---------------------------+</span><br><span class="line">| FTS_DOC_ID | body                      |</span><br><span class="line">+------------+---------------------------+</span><br><span class="line">|          1 | Pease porridge in the pot |</span><br><span class="line">+------------+---------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># ===== 查询短语 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from fts where match(body) against (&apos;&quot;porridge hot&quot;&apos; in boolean mode);</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">| FTS_DOC_ID | body                                    |</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">|          2 | Pease porridge hot, pease porridge cold |</span><br><span class="line">+------------+-----------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="query-expansion">Query Expansion</h3><p>MySQL 全文检索支持扩展查询。这种查询通常在查询的关键词太短，用户需要隐含知识时进行。例如，对于单词 database 查询，用户可能希望查询的不仅仅是包含 database 的文章，可能还指那些包含 MySQL、Oracle 的文章。这时可以使用 Query Expansion 模式。</p><p>通过在查询短语中添加 WITH QUERY EXPANSION 或 IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION 可以开启 blind query expansion（又称为 automatic relevance feedback）。该查询分为两个阶段：</p><ol type="1"><li>根据搜索的单词进行全文检索查询。</li><li>根据第一阶段产生的分词再进行一次全文检索的查询。</li></ol><p>例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table articles(</span><br><span class="line">    -&gt;   id int unsigned auto_increment primary key,</span><br><span class="line">    -&gt;   title varchar(200),</span><br><span class="line">    -&gt;   body text,</span><br><span class="line">    -&gt;   fulltext (title, body)    # InnoDB 会自动添加 FTS_DOC_ID 列</span><br><span class="line">    -&gt; )engine=innodb;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into articles (title,body) values</span><br><span class="line">    -&gt; (&apos;MySQL Tutorial&apos;, &apos;DBMS stands for DataBase ...&apos;),</span><br><span class="line">    -&gt; (&apos;How To Use MySQL Well&apos;, &apos;After you went through a ...&apos;),</span><br><span class="line">    -&gt; (&apos;Optimizing MySQL&apos;, &apos;In this tutorial we will show ...&apos;),</span><br><span class="line">    -&gt; (&apos;1001 MySQL Tricks&apos;, &apos;1. Never run mysqld as root. 2. ...&apos;),</span><br><span class="line">    -&gt; (&apos;MySQL vs. YourSQL&apos;, &apos;In the following database comparison ...&apos;),</span><br><span class="line">    -&gt; (&apos;MySQL Security&apos;, &apos;When configured properly, MySQL ...&apos;),</span><br><span class="line">    -&gt; (&apos;IBM History&apos;, &apos;DB2 history for IBM ...&apos;);</span><br><span class="line">Query OK, 7 rows affected (0.01 sec)</span><br><span class="line">Records: 7  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from articles</span><br><span class="line">    -&gt; where match(title, body) against(&apos;database&apos;);</span><br><span class="line">+----+-------------------+------------------------------------------+</span><br><span class="line">| id | title             | body                                     |</span><br><span class="line">+----+-------------------+------------------------------------------+</span><br><span class="line">|  1 | MySQL Tutorial    | DBMS stands for DataBase ...             |</span><br><span class="line">|  5 | MySQL vs. YourSQL | In the following database comparison ... |</span><br><span class="line">+----+-------------------+------------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from articles</span><br><span class="line">    -&gt; where match(title, body) against(&apos;database&apos; with query expansion);</span><br><span class="line">+----+-----------------------+------------------------------------------+</span><br><span class="line">| id | title                 | body                                     |</span><br><span class="line">+----+-----------------------+------------------------------------------+</span><br><span class="line">|  5 | MySQL vs. YourSQL     | In the following database comparison ... |</span><br><span class="line">|  1 | MySQL Tutorial        | DBMS stands for DataBase ...             |</span><br><span class="line">|  3 | Optimizing MySQL      | In this tutorial we will show ...        |</span><br><span class="line">|  6 | MySQL Security        | When configured properly, MySQL ...      |</span><br><span class="line">|  2 | How To Use MySQL Well | After you went through a ...             |</span><br><span class="line">|  4 | 1001 MySQL Tricks     | 1. Never run mysqld as root. 2. ...      |</span><br><span class="line">+----+-----------------------+------------------------------------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>Query Expansion 的全文检索可能带来许多非相关性的查询，因此在使用时需要非常谨慎。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> Inside MySQL </tag>
            
            <tag> index </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 锁</title>
      <link href="/notes/inside-mysql/mysql-locking/"/>
      <url>/notes/inside-mysql/mysql-locking/</url>
      
        <content type="html"><![CDATA[<h1 id="并发控制">并发控制</h1><p>锁（locking）机制用于管理对<strong>共享资源</strong>（这里说的是共享资源而不仅仅是行记录）的并发访问。</p><h2 id="锁粒度">锁粒度</h2><p>一种提高共享资源并发性的方式就是让锁定对象更具选择性。尽量只锁定需要修改的部分数据，而不是所有的资源。更理想的方式是，只对会修改的数据片进行精确的锁定。</p><p>问题是加锁也要消耗资源。锁的各种操作，包括获得锁、检查锁是否已经解除、释放锁等，都会增加系统的开销。</p><p>所谓的<strong>锁策略</strong>，就是在锁的开销和数据的安全性之间寻求平衡。</p><ul><li>表级锁（table lock），锁定整张表，开销最小。一个用户在对表进行写操作（插入、删除、更新等）前，需要先获得 X 锁，这会阻塞其他用户对该表的所有读写操作。只有 S 锁和 S 锁之间不相互阻塞（称为锁兼容）。</li><li>行级锁（row lock），可以最大程度地支持并发处理，同时也带来了最大的锁开销。</li></ul><h2 id="读写锁">读写锁</h2><p>InnoDB 存储引擎（之后简称为 InnoDB）实现了两种标准的行级锁：</p><ul><li>共享锁（S，Shared lock），也叫读锁（read lock）</li><li>排他锁（X，eXclusive lock），也叫写锁（write lock）</li></ul><p>若 T1 获得了某行的 S 锁，这时 T2 也可以获得该行的 S 锁，因为读取不会改变行记录，称这种情况为<strong>锁兼容</strong>（lock compatible）。</p><table><thead><tr class="header"><th></th><th><strong>X</strong></th><th><strong>S</strong></th></tr></thead><tbody><tr class="odd"><td><strong>X</strong></td><td>不兼容</td><td>不兼容</td></tr><tr class="even"><td><strong>S</strong></td><td>不兼容</td><td>兼容</td></tr></tbody></table><h2 id="意向锁">意向锁</h2><p>InnoDB 支持多粒度锁定，允许事务在行级上和表级上的锁同时存在。为了支持在不同的粒度上进行加锁操作，InnoDB 支持一种额外的锁方式，称为<strong>意向锁</strong>（intention lock）。意向锁意味着事务希望在更细粒度上进行加锁。</p><p>意向锁为表级别的锁，设计目的是在一个事务中揭示下一行将被请求的锁类型。有两种意向锁：</p><ul><li>意向共享锁（IS），事务打算对表中的某几行加共享锁</li><li>意向排他锁（IX），事务打算对表中的某几行加排他锁</li></ul><p>意向锁之间是相互兼容的，意向锁与读写锁之间只有 IS 和 S 相互兼容。</p><table><thead><tr class="header"><th></th><th><strong>IS</strong></th><th><strong>IX</strong></th><th><strong>S</strong></th><th><strong>X</strong></th></tr></thead><tbody><tr class="odd"><td><strong>IS</strong></td><td>兼容</td><td>兼容</td><td>兼容</td><td>不兼容</td></tr><tr class="even"><td><strong>IX</strong></td><td>兼容</td><td>兼容</td><td>不兼容</td><td>不兼容</td></tr></tbody></table><p>意向锁是 InnoDB 自动加的，供 MySQL 内部使用，不需用户干预。</p><a id="more"></a><h1 id="事务">事务</h1><p>数据库事务是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。</p><h2 id="acid">ACID</h2><p>ACID，是指数据库管理系统在写入或更新资料的过程中，为保证事务是正确可靠的，所必须具备的四个特性：原子性（atomicity）、一致性（consistency）、隔离性（isolation）和持久性（durability）。</p><ul><li>原子性： 个事务必须被视为一个不可分割的最小工作单元，整个事务中的操作要么全部成功提交，要不全部失败回滚，不可能只执行其中的一部分。</li><li>一致性：数据库总是从一个一致性的状态转换到另一个一致性的状态。</li><li>隔离性：通常来说（见隔离级别），一个事务所做的修改在最终提交以前，对其他事务是不可见的。</li><li>持久性：一旦事务提交，则其所做的修改就会永久保存到数据库中。</li></ul><h2 id="隔离级别">隔离级别</h2><p>SQL 标准中定义了四种隔离级别：</p><ul><li><p>READ UNCOMMITTED（未提交读）</p><p>在 READ UNCOMMITTED 级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这称为<strong>脏读</strong>（dirty read）。这个级别会导致很多问题，从性能上来说，不会比其他的级别好太多，但却缺乏其他级别的很多好处。在实际应用中一般很少使用。</p></li><li><p>READ COMMITTED（提交读）</p><p>READ COMMITTED 满足隔离性的简单定义：一个事务开始时，只能“看见”已提交的事务所做的修改。这个级别有时候也叫做<strong>不可重复读</strong>（nonrepeatable read），因为两次执行同样的查询，可能会得到不一样的结果。一般来说，不可重复读的问题是可以接受的，因为其读到的是已经提交的数据。因此，很多 DBMS 的默认隔离级别是 READ COMMITTED（但 MySQL 不是）。</p></li><li><p>REPEATABLE READ（可重复读）</p><p>该级别保证了在同一个事务中多次读取同样的记录的结果是一致的。但是理论上，还是无法解决另外一个<strong>幻读</strong>（phantom read）的问题：当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的纪录，当之前的事务再次读取该范围的记录时，会产生幻行。</p><p>幻读可以看作是不可重复读的一种特例。一般来说，不可重复读针对 UPDATE、DELETE，而幻读针对 INSERT。</p></li><li><p>SERIALIZABLE （可串行化）</p><p>SERIALIZABLE 是最高的隔离级别。它通过强制事务串行执行，避免了前面的幻读问题。简单来说，SERIALIZABLE 会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的的问题。实际应用中也很少用到这个隔离级别。</p></li></ul><table><thead><tr class="header"><th>隔离级别</th><th>脏读可能性</th><th>不可重复读可能性</th><th>幻读可能性</th><th>加锁读</th></tr></thead><tbody><tr class="odd"><td>READ UNCOMMITTED</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td></tr><tr class="even"><td>READ COMMITTED</td><td>No</td><td>Yes</td><td>Yes</td><td>No</td></tr><tr class="odd"><td>REPEATABLE READ</td><td>No</td><td>No</td><td>Yes</td><td>No</td></tr><tr class="even"><td>SERIALIZABLE</td><td>No</td><td>No</td><td>No</td><td>Yes</td></tr></tbody></table><p>InnoDB 支持所有的隔离级别，默认的级别为 REPEATABLE READ。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ===== 懒……语句都是用的小写 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@version;</span><br><span class="line">+-----------+</span><br><span class="line">| @@version |</span><br><span class="line">+-----------+</span><br><span class="line">| 8.0.20    |</span><br><span class="line">+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># =========== 查询隔离级别 ===========</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@session.transaction_isolation;</span><br><span class="line">+---------------------------------+</span><br><span class="line">| @@session.transaction_isolation |</span><br><span class="line">+---------------------------------+</span><br><span class="line">| REPEATABLE-READ                 |</span><br><span class="line">+---------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;transaction_isolation&apos;;</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| Variable_name         | Value           |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| transaction_isolation | REPEATABLE-READ |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># ===== 设置隔离级别，四个级别都支持 ====</span><br><span class="line"># read uncommitted | read committed | repeatable read | serializable</span><br><span class="line"></span><br><span class="line">mysql&gt; set session transaction isolation level read uncommitted;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="隔离级别与锁">隔离级别与锁</h2><table><thead><tr class="header"><th>隔离级别</th><th>脏读可能性</th><th>不可重复读可能性</th><th>幻读可能性</th><th>加锁读</th></tr></thead><tbody><tr class="odd"><td>READ UNCOMMITTED</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td></tr><tr class="even"><td>READ COMMITTED</td><td>No</td><td>Yes</td><td>Yes</td><td>No</td></tr><tr class="odd"><td>REPEATABLE READ</td><td>No</td><td>No</td><td>Yes (InnoDB 通过 MVCC 在此级别下避免了幻读)</td><td>No</td></tr><tr class="even"><td>SERIALIZABLE</td><td>No</td><td>No</td><td>No</td><td>Yes</td></tr></tbody></table><p>本节是对上述表格中部分内容的测试验证。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ===== 创建一个存储过程用来查询一个表上的锁 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; delimiter //</span><br><span class="line">mysql&gt; create procedure showlocks(in db varchar(20), in tb varchar(20))</span><br><span class="line">    -&gt; begin</span><br><span class="line">    -&gt;   select index_name, lock_type, lock_mode, lock_status, lock_data</span><br><span class="line">    -&gt;   from performance_schema.data_locks</span><br><span class="line">    -&gt;   where object_schema=db and object_name=tb;</span><br><span class="line">    -&gt; end //</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; delimiter ;</span><br><span class="line"></span><br><span class="line"># ========== 创建测试表 ==========</span><br><span class="line"></span><br><span class="line">mysql&gt; create table t1 (a int primary key);</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t1 values(1), (2), (5);</span><br><span class="line">Query OK, 3 rows affected (0.00 sec)</span><br><span class="line">Records: 3  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p>首先看看，在 READ UNCOMMITTED 隔离级别下，脏读、不可重复读、幻读是如何发生的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ===== 开启会话 A 和 B，并设置隔离级别，开启事务 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; set session transaction isolation level read uncommitted;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; use test;</span><br><span class="line">Reading table information for completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup with -A</span><br><span class="line"></span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"># ===== 会话 A =====</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t1 where a&gt;=2;  # 不 显式加 S 锁</span><br><span class="line">+---+</span><br><span class="line">| a |</span><br><span class="line">+---+</span><br><span class="line">| 2 |</span><br><span class="line">| 5 |</span><br><span class="line">+---+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; call showlocks(&apos;test&apos;, &apos;t1&apos;);  # InnoDB 没有隐式加 S 锁</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"># ===== 会话 B =====</span><br><span class="line"></span><br><span class="line">mysql&gt; update t1 set a=3 where a=2;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0   # 修改成功</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t1 select 4;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Records: 1  Duplicates: 0  Warnings: 0  # 插入成功</span><br><span class="line"></span><br><span class="line">mysql&gt; call showlocks(&apos;test&apos;, &apos;t1&apos;);   # 因为没有 S 锁，所以在 a=2 上可以获得 X 锁</span><br><span class="line">+------------+-----------+---------------+-------------+-----------+</span><br><span class="line">| index_name | lock_type | lock_mode     | lock_status | lock_data |</span><br><span class="line">+------------+-----------+---------------+-------------+-----------+</span><br><span class="line">| NULL       | TABLE     | IX            | GRANTED     | NULL      |</span><br><span class="line">| PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 2         |</span><br><span class="line">+------------+-----------+---------------+-------------+-----------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"># ====== 回到会话 A =====</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t1 where a&gt;=2;</span><br><span class="line">+---+</span><br><span class="line">| a |</span><br><span class="line">+---+</span><br><span class="line">| 3 |     # a=3 是会话 B 中未提交的数据，脏读</span><br><span class="line">| 4 |     # a=4 是会话 B 中未提交、新插入的数据，也被查询出来了，脏读 + 幻读</span><br><span class="line">| 5 |     # 两次查询结果不一样，不可重复读</span><br><span class="line">+---+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># ===== 会话 A 和 B =====</span><br><span class="line"></span><br><span class="line">mysql&gt; rollback;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>接下来看在 READ COMMITTED 隔离级别下如何防止脏读，以及可不重复读是如何发生的。关于幻读不再展示。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ===== 会话 A 和 B，设置隔离等级，开启一个事务 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; set session transaction isolation level read committed;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"># ===== 会话 A =====</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t1 where a=1;</span><br><span class="line">+---+</span><br><span class="line">| a |</span><br><span class="line">+---+</span><br><span class="line">| 1 |</span><br><span class="line">+---+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; call showlocks(&apos;test&apos;, &apos;t1&apos;);  # 同样没有隐式加锁</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"># ===== 会话 B =====</span><br><span class="line"></span><br><span class="line">mysql&gt; update t1 set a=11 where a=1;  # 更新成功</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; call showlocks(&apos;test&apos;, &apos;t1&apos;);  # 同样的，加了一个 X 锁</span><br><span class="line">+------------+-----------+---------------+-------------+-----------+</span><br><span class="line">| index_name | lock_type | lock_mode     | lock_status | lock_data |</span><br><span class="line">+------------+-----------+---------------+-------------+-----------+</span><br><span class="line">| NULL       | TABLE     | IX            | GRANTED     | NULL      |</span><br><span class="line">| PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 1         |</span><br><span class="line">+------------+-----------+---------------+-------------+-----------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"># ===== 会话 A =====</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t1 where a=1;  # 查询结果不变，没有脏读</span><br><span class="line">+---+                               # 通过一致性非锁定读保证，后面会详细说明</span><br><span class="line">| a |</span><br><span class="line">+---+</span><br><span class="line">| 1 |</span><br><span class="line">+---+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># ===== 会话 B =====</span><br><span class="line"></span><br><span class="line">mysql&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)  # 提交修改</span><br><span class="line"></span><br><span class="line"># ===== 会话 A =====</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t1 where a=1;  # 查询结果发生变化，不可重复读</span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure><p>在 REPEATABLE READ 隔离级别下，上述示例中最后一次查询的结果不会改变，保证了可重复读。原理见一致性非锁定读一节。</p><p>InnoDB 如何在 REPEATABLE READ 隔离级别下预防幻读，见锁的算法一节。</p><h2 id="mysql-中的事务">MySQL 中的事务</h2><h3 id="自动提交">自动提交</h3><p>MySQL 默认采用自动提交（autocommit）模式。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;autocommit&apos;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| autocommit    | ON    |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set autocommit = 0;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure><p>当 autocommit=0 时，所有的查询都是在一个事务中，直到显示地执行 commit 提交或者 rollback 回滚，该事务结束，同时又开始了另一个新事务。<strong>修改 autocommit 对非事务型的表，比如 MyISAM 或者内存表，不会有任何影响</strong>，对这类表来说，没有 commit 或者 rollback 的概念。</p><p><strong>另外还有一些命令，在执行之前会强制执行 commit 提交当前的活动事务</strong>。典型的例子，在数据定义语言（DDL）中，alter table 就是如此。另外还有 lock tables 等其他语句也会导致同样的结果。</p><h3 id="在事务中混合使用存储引擎">在事务中混合使用存储引擎</h3><p>在同一个事务中，使用多种存储引擎是不可靠的。如果在事务中混合使用了事务型和非事务型的表，在正常提交的情况下不会有什么问题。但如果该事务需要回滚，非事务型的表上的变更就无法撤销，这会导致数据库处于不一致的状态。</p><h3 id="隐式和显式锁定">隐式和显式锁定</h3><p>InnoDB 采用的是两阶段锁定协议（two-phase locking protocol），在事务执行过程中，随时都可以执行锁定，锁只有在 commit 或者 rollback 的时候才会释放，并且所有的锁是在同一时刻被释放。</p><p>InnoDB 会根据隔离界别在需要的时候自动加锁。另外，也支持通过特定的语句进行显式锁定，这些语句不属于 SQL 规范。</p><ul><li><code>select ... lock in share mode;</code></li><li><code>select ... for update;</code></li></ul><h1 id="多版本并发控制">多版本并发控制</h1><p>MySQL 的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，它们一般都同时实现了多版本并发控制（MVCC）。</p><p>可以认为 MVCC 是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。</p><p>MVCC 的实现，是通过保存数据在某个时间点的快照来实现的。也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。</p><p>不同存储引擎的 MVCC 实现是不同的，典型的有乐观（optimistic）并发控制和悲观（pessimistic）并发控制。</p><p>InnoDB 的 MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录进行比较。</p><p>下面看一下在 REPEATABLE READ 隔离级别下，MVCC 具体是如何操作的。</p><ul><li>SELECT：InnoDB 会根据以下两个条件检查每行记录：<ul><li>行的系统版本号小于或等于事务的系统版本号，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。</li><li>行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未删除。</li></ul>只有符合以上两个条件的记录，才能返回作为查询结果。</li><li>INSERT：InnoDB 为新插入的每一行保存当前系统版本号作为行版本号。</li><li>DELETE：InnoDB 为删除的每一行保存当前系统版本号作为行删除标识。</li><li>UPDATE：InnoDB 插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识。</li></ul><p>保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护操作。</p><p><strong>MVCC 只能在 REPEATABLE READ 和 READ COMMITTED 两个隔离级别下工作</strong>。其他两个隔离界别都和 MVCC 不兼容，因为 READ UNCOMMITTED 总是读取最新的数据行，而不是符合当前事务版本的数据行。而 SERIALIZABLE 则会对所有读取的行都加锁。</p><h1 id="一致性非锁定读">一致性非锁定读</h1><p>一致性非锁定读（consistent nonlocking read）是指 InnoDB 通过 MVCC 的方式读取当前执行时间数据库中行的数据。非锁定读机制极大地提高了数据库的并发行，这是 InnoDB 存储引擎默认的读取方式。但是在不同的事务隔离级别下，读取的方式不同，如上所述，<strong>MVCC 只能在 REPEATABLE READ 和 READ COMMITTED 两个隔离级别下工作</strong>。此外，即使都是使用非锁定的一致性读，对于快照数据的定义也各不相同。</p><ul><li>在 READ COMMITTED 事务隔离级别下，总是读取被锁定行的最新一份快照数据</li><li>在 REPEATABLE READ 事务隔离级别下，总是读取事务开始时的行数据版本</li></ul><table><colgroup><col style="width: 11%"><col style="width: 44%"><col style="width: 44%"></colgroup><thead><tr class="header"><th>时间</th><th>会话 A</th><th>会话 B</th></tr></thead><tbody><tr class="odd"><td>1</td><td><code>begin;</code></td><td></td></tr><tr class="even"><td>2</td><td><code>select * from parent where id=1;</code> (1 row in set)</td><td></td></tr><tr class="odd"><td>3</td><td></td><td><code>begin;</code></td></tr><tr class="even"><td>4</td><td></td><td><code>update parent set id=2 where id=1;</code></td></tr><tr class="odd"><td>5</td><td><code>select * from parent where id=1;</code> (1 row in set)</td><td></td></tr><tr class="even"><td>6</td><td></td><td><code>commit;</code></td></tr><tr class="odd"><td>7</td><td><code>select * from parent where id=1;</code><br>READ COMMITTE 级别下结果为 Empty set<br>REPEATABLE READ 级别下结果为 1 row in set</td><td></td></tr><tr class="even"><td>8</td><td><code>commit;</code></td><td></td></tr></tbody></table><h1 id="自增长与锁">自增长与锁</h1><p>官方文档：<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html" target="_blank" rel="noopener">15.6.1.6 AUTO_INCREMENT Handling in InnoDB</a></p><p>InnoDB 对每个含有自增长值的表都有一个自增长计数器，当对含有自增长计数器的表进行插入操作时，执行 <code>select max(ai_col) from table_name for update;</code> 得到计数器的值，再加 1 赋予新行的自增长列。这个实现方式称作 AUTO-INC Locking。为了提高插入的性能，这种锁采用一种特殊的表锁机制，锁不是在事务完成后才释放，而是在完成 SQL 语句后立即释放。</p><p>虽然 AUTO-INC Locking 从一定程度上提高了并发插入的效率，但还是存在一些性能上的问题，事务必须等待前一个插入的完成（虽然不用等待事务的完成）。</p><p>从 MySQL 5.1.22 版本开始，InnoDB 提供了一种轻量级互斥锁（Mutex）的自增实现机制。在讨论它之前，需要对插入进行分类。</p><table><colgroup><col style="width: 28%"><col style="width: 71%"></colgroup><thead><tr class="header"><th>插入类型</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>insert-like</td><td>指所有的插入语句，包括 <code>INSERT, INSERT ... SELECT, REPLACE, REPLACE ... SELECT, LOAD DATA</code>。</td></tr><tr class="even"><td>simple inserts</td><td>插入前就能确定插入行数的语句，包括单行（或多行但不嵌套查询）的 <code>INSERT, REPLACE</code> 语句，但不包括 <code>INSERT ... ON DUPLICATE KEY UPDATE</code>。</td></tr><tr class="odd"><td>bulk inserts</td><td>插入前不能确定插入行数的语句，包括 <code>INSERT ... SELECT, REPLACE ... SELECT, LOAD DATA</code>。</td></tr><tr class="even"><td>mixed-mode inserts</td><td>插入中有一部分的自增长值是指定的，例如 <code>INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d');</code>。</td></tr></tbody></table><p>InnoDB 提供了一个参数 innodb_autoinc_lock_mode 来控制自增长的模式。</p><table><colgroup><col style="width: 16%"><col style="width: 83%"></colgroup><thead><tr class="header"><th>参数取值</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>0</td><td>传统锁定模式 AUTO-INC Locking</td></tr><tr class="even"><td>1 (default)</td><td>连续锁定模式，对于 simple inserts 使用 Mutex，对于 bulk inserts 使用 AUTO-INC Locking</td></tr><tr class="odd"><td>2</td><td>交错锁定模式，对于所有 insert-like 都通过 Mutex，效率最高，但是 statement-base replication 会出现问题。因此，使用这个模式，任何时候都应该使用 row-base replication。</td></tr></tbody></table><h1 id="外键和锁">外键和锁</h1><p>外键主要用于引用完整性的约束检查。<strong>对于外键值的插入或更新，首先需要查询父表中的记录，但是对于父表的 select 操作，不是使用一致性非锁定读的方式</strong>，因为这样会发生数据不一致的问题。</p><h1 id="锁的算法">锁的算法</h1><p>InnoDB 有 3 种行锁的算法：</p><ul><li>Record Lock：锁定单行记录，如果建表时没有设置任何索引，InnoDB 会使用隐式的主键来进行锁定</li><li>Gap Lock：间隙锁，锁定一个范围，但不包含记录本身</li><li>Next-Key Lock：Gap Lock + Record Lock，锁定一个范围，并且锁定记录本身。例如一个索引有 10, 11, 13, 20 这四个值，那么该索引可能被 Next-Key Locking 的区间为：<ul><li><code>(-inf, 10]</code></li><li><code>(10, 11]</code></li><li><code>(11, 13]</code></li><li><code>(13, 20]</code></li><li><code>(20, +inf)</code></li></ul></li></ul><h2 id="next-key-lock-降级">Next-Key Lock 降级</h2><p>当查询的索引含有唯一（比如主键）属性时，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，从而提高应用的并发行。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ========== 测试表 ==========</span><br><span class="line"></span><br><span class="line">mysql&gt; truncate t1;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t1 values(1), (2), (5);</span><br><span class="line">Query OK, 3 rows affected (0.00 sec)</span><br><span class="line">Records: 3  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line"># ========== Session A 和 B ==========</span><br><span class="line"></span><br><span class="line">mysql&gt; set session transaction isolation level repeatable read;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"># ========== Session A ==========</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t1 where a=5 for update;  # 加 X 锁</span><br><span class="line">+---+</span><br><span class="line">| a |</span><br><span class="line">+---+</span><br><span class="line">| 5 |</span><br><span class="line">+---+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; call showlocks(&apos;test&apos;, &apos;t1&apos;);    # 锁住的是 单行</span><br><span class="line">+------------+-----------+---------------+-------------+-----------+</span><br><span class="line">| index_name | lock_type | lock_mode     | lock_status | lock_data |</span><br><span class="line">+------------+-----------+---------------+-------------+-----------+</span><br><span class="line">| NULL       | TABLE     | IX            | GRANTED     | NULL      |</span><br><span class="line">| PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 5         |</span><br><span class="line">+------------+-----------+---------------+-------------+-----------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"># ========== Session B ==========</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t1 select 4;       # 插入 a=4</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Records: 1  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)  # 成功，不需要等待</span><br><span class="line"></span><br><span class="line"># ========== Session A ==========</span><br><span class="line"></span><br><span class="line">mysql&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure><p><strong>Next-Key Lock 降级为 Record Lock 仅在查询的列是唯一索引的情况下</strong>。若是辅助索引，情况则会不同。创建如下测试表，并通过辅助索引进行查询：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ========== 创建测试表 ==========</span><br><span class="line"></span><br><span class="line">mysql&gt; create table t2 (a int, b int, primary key(a), key(b));</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t2 values(1,1), (3,1), (5,3), (7,6), (10,8);</span><br><span class="line">Query OK, 5 rows affected (0.00 sec)</span><br><span class="line">Records: 5  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line"># ========== Session A 和 B ==========</span><br><span class="line"></span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"># ========== Session A ==========</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t2 where b=3 for update;  # 通过辅助索引 b 进行查询</span><br><span class="line">+---+------+</span><br><span class="line">| a | b    |</span><br><span class="line">+---+------+</span><br><span class="line">| 5 |    3 |</span><br><span class="line">+---+------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; call showlocks(&apos;test&apos;, &apos;t2&apos;);</span><br><span class="line">+------------+-----------+---------------+-------------+-----------+</span><br><span class="line">| index_name | lock_type | lock_mode     | lock_status | lock_data |</span><br><span class="line">+------------+-----------+---------------+-------------+-----------+</span><br><span class="line">| NULL       | TABLE     | IX            | GRANTED     | NULL      |</span><br><span class="line">| b          | RECORD    | X             | GRANTED     | 3, 5      |</span><br><span class="line">| PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 5         |</span><br><span class="line">| b          | RECORD    | X,GAP         | GRANTED     | 6, 7      |</span><br><span class="line">+------------+-----------+---------------+-------------+-----------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>如上所示：对于聚集索引，仅对 a=5 的索引加上 Record Lock，而对于辅助索引，加上的是 Next-Key Lock，锁定的范围是 3 及其左右两边的区间 <code>(1,3), (3,6)</code>。（会话 A 在索引 b 上进行的也是等值查询，加上 gap lock 的目的是什么？）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ========== Session B ==========</span><br><span class="line">mysql&gt; set session innodb_lock_wait_timeout = 1;    # 设置一个短的超时时间</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"># ===== 超时 =====</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t2 where a=5 lock in share mode;    # 超时，a=5 上有 X 锁</span><br><span class="line">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br><span class="line">mysql&gt; select * from t2 where b=3 lock in share mode;    # 超时，b=3 上有 X 锁</span><br><span class="line">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br><span class="line">mysql&gt; insert into t2 select 4, 2;    # 超时，索引 b 上有 gap lock (1, 6)</span><br><span class="line">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br><span class="line">mysql&gt; insert into t2 select 4, 5;</span><br><span class="line">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br><span class="line"></span><br><span class="line">select * from t2 where a=5 lock in share mode;  # 主键 a=5 上有 X 锁</span><br><span class="line">select * from t2 where b=3 lock in share mode;  # 辅助索引 b=3 上也有 X 锁</span><br><span class="line">insert into t2 select 4, 2;                     # (1, 6) 上有 gap lock</span><br><span class="line"></span><br><span class="line"># ==== 能执行 =====</span><br><span class="line"># 只有在主键 a 不重复，且辅助索引 b 的值在 (1, 6) 之外时，才能插入</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t2 select 0, 1;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Records: 1  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t2 select 8, 6;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Records: 1  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line"># ===== Session A 和 B =====</span><br><span class="line"></span><br><span class="line">mysql&gt; rollback;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>最后需要再次提醒的是，Next-Key Lock 降级为 Record Lock 仅存在于查询唯一索引列。若唯一所有列由多个列组成，而查询仅查找其中一个，那么查询其实是 range 类型查询，而不是 point 类型查询，故 InnoDB 依然使用 Next-Key Lock 进行锁定。</p><h2 id="解决幻读问题">解决幻读问题</h2><p>在 REPEATABLE READ 隔离级别下，InnoDB 采用 Next-Key Locking 机制来避免幻读问题。对于 SQL 语句 <code>select * from t2 where a&gt;5 for update;</code>，InnoDB 对 <code>(5, +inf)</code> 这个范围加了 X 锁。因此任何对于这个范围的插入都是不被允许的，从而避免了幻读。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ===== READ COMMITTED =====</span><br><span class="line"></span><br><span class="line">mysql&gt; set session transaction isolation level read committed;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t2 where a&gt;5 for update;</span><br><span class="line">+----+------+</span><br><span class="line">| a  | b    |</span><br><span class="line">+----+------+</span><br><span class="line">|  7 |    6 |</span><br><span class="line">| 10 |    8 |</span><br><span class="line">+----+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; call showlocks(&apos;test&apos;, &apos;t2&apos;);  # 只加了 Record Lock</span><br><span class="line">+------------+-----------+---------------+-------------+-----------+</span><br><span class="line">| index_name | lock_type | lock_mode     | lock_status | lock_data |</span><br><span class="line">+------------+-----------+---------------+-------------+-----------+</span><br><span class="line">| NULL       | TABLE     | IX            | GRANTED     | NULL      |</span><br><span class="line">| PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 7         |</span><br><span class="line">| PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 10        |</span><br><span class="line">+------------+-----------+---------------+-------------+-----------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"># ===== REPEATABLE READ =====</span><br><span class="line"></span><br><span class="line">mysql&gt; set session transaction isolation level repeatable read;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t2 where a&gt;5 for update;</span><br><span class="line">+----+------+</span><br><span class="line">| a  | b    |</span><br><span class="line">+----+------+</span><br><span class="line">|  7 |    6 |</span><br><span class="line">| 10 |    8 |</span><br><span class="line">+----+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; call showlocks(&apos;test&apos;, &apos;t2&apos;);  # 加了Gap Lock（你可以将 supremum pseudo-record 理解为 +inf）</span><br><span class="line">+------------+-----------+-----------+-------------+------------------------+</span><br><span class="line">| index_name | lock_type | lock_mode | lock_status | lock_data              |</span><br><span class="line">+------------+-----------+-----------+-------------+------------------------+</span><br><span class="line">| NULL       | TABLE     | IX        | GRANTED     | NULL                   |</span><br><span class="line">| PRIMARY    | RECORD    | X         | GRANTED     | supremum pseudo-record |</span><br><span class="line">| PRIMARY    | RECORD    | X         | GRANTED     | 7                      |</span><br><span class="line">| PRIMARY    | RECORD    | X         | GRANTED     | 10                     |</span><br><span class="line">+------------+-----------+-----------+-------------+------------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="next-key-lock-与唯一性检查">Next-Key Lock 与唯一性检查</h2><p>此外，用户可以通过 Nexy-Key Locking 机制在应用层面实现<strong>唯一性</strong>的检查（如果有唯一性的需求，为什么不用唯一索引呢？）。用户通过索引查询一个值，并对该行加上一个 S 锁，那么即使查询的值不存在，其锁定的也是一个范围，因此若没有返回任何行，那么新插入的值一定是唯一的。</p><table><colgroup><col style="width: 11%"><col style="width: 44%"><col style="width: 44%"></colgroup><thead><tr class="header"><th>时间</th><th>会话 A</th><th>会话 B</th></tr></thead><tbody><tr class="odd"><td>1</td><td><code>begin;</code></td><td><code>begin;</code></td></tr><tr class="even"><td>2</td><td><code>select * from t2 where b=4 lock in share mode;</code>（S 锁）</td><td><code>select * from t2 where b=4 lock in share mode;</code>（S 锁）</td></tr><tr class="odd"><td>3</td><td><code>insert into t2 select 4,4;</code> (阻塞)</td><td></td></tr><tr class="even"><td>4</td><td>获得锁，插入成功</td><td><code>insert into t2 select 4,4;</code> (死锁，回滚)</td></tr></tbody></table><h1 id="阻塞">阻塞</h1><p>因为不同锁之间的兼容性关系，在有些时刻一个事务中的锁需要等待另一个事务中的锁释放它所占用的资源，这就是阻塞。</p><p>在 InnoDB 中，参数 innodb_lock_wait_timeout 用来控制等待时间，默认 50 秒。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_lock_wait_timeout&apos;;</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">| Variable_name            | Value |</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">| innodb_lock_wait_timeout | 50    |</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set session innodb_lock_wait_timeout=10;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>当发生超时，数据库会抛出一个 1205 错误。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into t2 select 4, 5;</span><br><span class="line">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br></pre></td></tr></table></figure><p>需要注意的是，<strong>在默认情况下 InnoDB 不会回滚超时引发的错误异常</strong>。其实 InnoDB 在<strong>大部分情况下</strong>都不会对异常进行回滚。因此，用户必须判断是否需要 COMMIT 还是 ROLLBACK。</p><p>参数 innodb_rollback_on_timeout 用来设定是否在等待超时后进行回滚。<strong>innodb_rollback_on_timeout 是静态的，不可在启动时进行修改。</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_rollback_on_timeout&apos;;</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">| Variable_name              | Value |</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">| innodb_rollback_on_timeout | OFF   |</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set session innodb_rollback_on_timeout=1;</span><br><span class="line">ERROR 1238 (HY000): Variable &apos;innodb_rollback_on_timeout&apos; is a read only variable</span><br></pre></td></tr></table></figure><h1 id="死锁">死锁</h1><p>死锁是指两个或者多个事务在同一资源上相互占用，并请求对方占用的资源，从而导致恶性循环的现象。当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。多个事务同时锁定同一个资源时，也会产生死锁。</p><ul><li><p>超时</p><p>解决死锁最简单的一种方法是超时。通过超时后对事务进行回滚的方式来处理死锁。</p><p>超时机制虽然简单，但它是根据 FIFO 的顺序选择回滚事务，若超时的事务所占权重比较大（如事务操作更新了很多行，占用了较多的 undo log），这时采用 FIFO 就不合适了，因为回滚这个事务的时间可能会更多（相对其他事务）。</p></li><li><p>等待图</p><p>InnoDB 采用 wait-for graph 的方式进行死锁检测。这是一种更为主动的死锁检测方式。</p><p>在等待图中节点代表事务。事务 T1 指向 T2 边的定义为事务 T1 等待事务 T2 所占用的资源。在每个事务请求锁并发生等待时都会判断等待图中是否存在回路，若存在则有死锁。<strong>通常来说</strong>，InnoDB 选择 undo 量最小的事务进行回滚。</p></li></ul><p>事务发生死锁的概率与以下几点因素有关：</p><ul><li>系统中事务的数量，正比</li><li>每个事务操作的数据量，正比</li><li>操作数据的集合，反比</li></ul><h2 id="ab-ba-死锁">AB-BA 死锁</h2><p>下面演示死锁的一种经典的情况，A 等待 B，B 等待 A。这种死锁问题被称为 AB-BA 死锁。</p><table><colgroup><col style="width: 11%"><col style="width: 44%"><col style="width: 44%"></colgroup><thead><tr class="header"><th>时间</th><th>事务 A（会话 A 中的事务，以下简称事务 A）</th><th>事务 B</th></tr></thead><tbody><tr class="odd"><td>1</td><td><code>begin;</code></td><td><code>begin;</code></td></tr><tr class="even"><td>2</td><td><code>select * from t1 where a=1 for update;</code>（获得一个 X 锁）</td><td><code>update t1 set a=22 where a=2;</code>（获得了一个 X 锁）</td></tr><tr class="odd"><td>3</td><td><code>select * from t1 where a=2 for update;</code>（阻塞）</td><td></td></tr><tr class="even"><td>4</td><td>事务获得锁，正常执行</td><td><code>select * from t1 where a=2 for update;</code>（阻塞，检测到死锁，InnoDB 选择回滚 undo 量较小的事务 A）</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ===== Session A 和 B =====</span><br><span class="line"></span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"># =====  Session A =====</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t1 where a=1 for update;</span><br><span class="line">+---+</span><br><span class="line">| a |</span><br><span class="line">+---+</span><br><span class="line">| 1 |</span><br><span class="line">+---+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># =====  Session B =====</span><br><span class="line"></span><br><span class="line">mysql&gt; update t1 set a=22 where a=2;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; call showlocks(&apos;test&apos;, &apos;t1&apos;);    # 查看表中的锁，可以看到有两个事务分别加了两个 X 锁</span><br><span class="line">+-----------------------+------------+-----------+---------------+-------------+-----------+</span><br><span class="line">| engine_transaction_id | index_name | lock_type | lock_mode     | lock_status | lock_data |</span><br><span class="line">+-----------------------+------------+-----------+---------------+-------------+-----------+</span><br><span class="line">|                  2575 | NULL       | TABLE     | IX            | GRANTED     | NULL      |</span><br><span class="line">|                  2575 | PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 2         |</span><br><span class="line">|                  2574 | NULL       | TABLE     | IX            | GRANTED     | NULL      |</span><br><span class="line">|                  2574 | PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 1         |</span><br><span class="line">+-----------------------+------------+-----------+---------------+-------------+-----------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"># =====  Session A =====</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t1 where a=2 for update;  # 在此处阻塞</span><br><span class="line"></span><br><span class="line"># =====  Session B =====</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t1 where a=1 for update;  # B 请求 a=1 的 X 锁，成功了，回到 Session A</span><br><span class="line">+---+</span><br><span class="line">| a |</span><br><span class="line">+---+</span><br><span class="line">| 1 |</span><br><span class="line">+---+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># =====  Session A =====</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t1 where a=2 for update;  # InnoDB 检测到死锁，并回滚了事务 A（根据 undo 量）</span><br><span class="line">ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</span><br><span class="line"></span><br><span class="line">mysql&gt; call showlocks(&apos;test&apos;, &apos;t1&apos;);    # 此时再查看表锁，事务 A（2574） 因为回滚，释放了所有的锁</span><br><span class="line">+-----------------------+------------+-----------+---------------+-------------+-----------+</span><br><span class="line">| engine_transaction_id | index_name | lock_type | lock_mode     | lock_status | lock_data |</span><br><span class="line">+-----------------------+------------+-----------+---------------+-------------+-----------+</span><br><span class="line">|                  2575 | NULL       | TABLE     | IX            | GRANTED     | NULL      |</span><br><span class="line">|                  2575 | PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 2         |</span><br><span class="line">|                  2575 | PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 1         |</span><br><span class="line">+-----------------------+------------+-----------+---------------+-------------+-----------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"># ===== Session A 和 B =====</span><br><span class="line"></span><br><span class="line">mysql&gt; rollback;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>记得之前说过的吗？InnoDB 在<strong>大部分情况下</strong>都不会对异常进行回滚。但是死锁除外。发现死锁后，InnoDB 会马上回滚一个事务（以释放事务占有的资源）。因此，如果在应用程序中捕获了 1213 这个错误，其实并不需要对其进行回滚。</p><h2 id="gap-lock-引起的死锁">Gap Lock 引起的死锁</h2><table><colgroup><col style="width: 11%"><col style="width: 44%"><col style="width: 44%"></colgroup><thead><tr class="header"><th>时间</th><th>事务 A</th><th>事务 B</th></tr></thead><tbody><tr class="odd"><td>1</td><td><code>begin;</code></td><td><code>begin;</code></td></tr><tr class="even"><td>2</td><td><code>select * from t1 where a=4 for update;</code>（获得了一个 X 锁）</td><td></td></tr><tr class="odd"><td>3</td><td></td><td><code>select * from t1 where a&lt;=4 lock in share mode;</code>（获得了小于 4 的间隙锁，但是在 a=4 处阻塞）</td></tr><tr class="even"><td>4</td><td><code>insert into t1 values(3);</code>（检测到死锁，InnoDB 选择回滚事务 A）</td><td>事务获得所有锁，正常执行</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; truncate t1;</span><br><span class="line">Query OK, 0 rows affected (8.23 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t1 values(1), (2), (4), (5);</span><br><span class="line">Query OK, 4 rows affected (0.00 sec)</span><br><span class="line">Records: 4  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line"># ===== Session A 和 B =====</span><br><span class="line"></span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"># ===== Session A =====</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t1 where a=4 for update;  # 对 a=4 加上 X 锁</span><br><span class="line">+---+</span><br><span class="line">| a |</span><br><span class="line">+---+</span><br><span class="line">| 4 |</span><br><span class="line">+---+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># ===== Session B =====</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t1 where a&lt;=4 lock in share mode;  # 阻塞，等待 a=4 上的锁被释放</span><br><span class="line"></span><br><span class="line"># ===== Session A =====</span><br><span class="line"></span><br><span class="line">mysql&gt; call showlocks(&apos;test&apos;, &apos;t1&apos;);  # 查看此时的表锁，可以看到 Session B 被阻塞的原因</span><br><span class="line">+-----------------------+------------+-----------+---------------+-------------+-----------+</span><br><span class="line">| engine_transaction_id | index_name | lock_type | lock_mode     | lock_status | lock_data |</span><br><span class="line">+-----------------------+------------+-----------+---------------+-------------+-----------+</span><br><span class="line">|                  2597 | NULL       | TABLE     | IX            | GRANTED     | NULL      |</span><br><span class="line">|                  2597 | PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 4         |</span><br><span class="line">|       422069462880360 | NULL       | TABLE     | IS            | GRANTED     | NULL      |</span><br><span class="line">|       422069462880360 | PRIMARY    | RECORD    | S             | GRANTED     | 1         |</span><br><span class="line">|       422069462880360 | PRIMARY    | RECORD    | S             | GRANTED     | 2         |</span><br><span class="line">|       422069462880360 | PRIMARY    | RECORD    | S             | WAITING     | 4         |</span><br><span class="line">+-----------------------+------------+-----------+---------------+-------------+-----------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t1 values(3);  # 若插入 a=3 就会触发死锁，a=3 被 Session B 的间隙锁占用（看不懂上表）</span><br><span class="line">ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</span><br><span class="line"></span><br><span class="line"># ===== Session B =====</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t1 where a&lt;=4 lock in share mode;  # 再回到 Session B，阻塞消失，成功加上 S 锁</span><br><span class="line">+---+</span><br><span class="line">| a |</span><br><span class="line">+---+</span><br><span class="line">| 1 |</span><br><span class="line">| 2 |</span><br><span class="line">| 4 |</span><br><span class="line">+---+</span><br><span class="line">3 rows in set (22.45 sec)</span><br><span class="line"></span><br><span class="line"># ===== Session A 和 B =====</span><br><span class="line"></span><br><span class="line">mysql&gt; rollback;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>事务 A 和 B 的 undo 量相同（都为 0），此时 InnoDB 回滚哪个？结果告诉我们是回滚事务 A，因为若事务 A 的 insert 3 执行成功，则事务 B 还要获得记录为 3 的锁（这不应该发生，因为插入记录 3 这一动作是在事务 B 开始之后发生的，隔离性要求事务 B “看不见” 记录 3）。</p><p>MySQL 技术内幕一书中关于此处的描述太过简单暧昧。总之，记住一点就行，<strong>发生死锁时，InnoDB 选择 undo 量较小的事务进行回滚</strong>。上述示例，若事务 A 在 insert 3 之前执行了 insert 6，那么事务 B 的 undo 量就较小了。此时，InnoDB 会回滚事务 B。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ===== Session A 和 B =====</span><br><span class="line"></span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"># ===== Session A =====</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t1 where a=4 for update;</span><br><span class="line">+---+</span><br><span class="line">| a |</span><br><span class="line">+---+</span><br><span class="line">| 4 |</span><br><span class="line">+---+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># ===== Session B =====</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t1 where a&lt;=4 lock in share mode;  # 阻塞</span><br><span class="line"></span><br><span class="line"># ===== Session A =====</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t1 values(6);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)  # 成功，没有阻塞发生</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t1 values(3);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)  # 成功，有死锁，但 InnoDB 选择回滚了事务 B</span><br><span class="line"></span><br><span class="line"># ===== Session B =====</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t1 where a&lt;=4 lock in share mode;  # 回到会话 B</span><br><span class="line">ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</span><br><span class="line"></span><br><span class="line"># ===== Session A 和 B =====</span><br><span class="line"></span><br><span class="line">mysql&gt; rollback;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><h1 id="锁升级">锁升级</h1><p>锁升级（lock escalation）是指锁的粒度变粗。举例来说，把一个表的 1000 个行锁升级为一个页锁，或者将页锁升级为表锁。</p><p>锁升级可以减少锁的数量，在一定程度上保护了系统资源，防止系统使用太多的内存来维护锁，在一定程度上提高了效率。但是带来的问题是并发性能的降低。</p><p>InnoDB 不存在锁升级的问题。因为 InnoDB 是根据每个事务访问的每个页对锁进行管理的，采用的是位图的方式。不管一个事务锁住页中一个记录还是多个记录，其开销通常是一致的。（关于位图，原文无更详细的介绍）</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> Inside MySQL </tag>
            
            <tag> High Performance MySQL </tag>
            
            <tag> lock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reverse Nodes in k-Group</title>
      <link href="/programming/leetcode/reverse-nodes-in-k-group/"/>
      <url>/programming/leetcode/reverse-nodes-in-k-group/</url>
      
        <content type="html"><![CDATA[<p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p><p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br><span class="line">For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</span><br><span class="line">For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</span><br></pre></td></tr></table></figure><p><strong>Note</strong>:</p><ul><li>Only constant extra memory is allowed.</li><li>You may not alter the values in the list's nodes, only nodes itself may be changed.</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1-&gt;2-&gt;3-&gt;4-&gt;5, k = 2</span><br><span class="line"></span><br><span class="line">    Use a sentinel to simplify implement:</span><br><span class="line">    0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5</span><br><span class="line"></span><br><span class="line">1.  Find a piece with k nodes</span><br><span class="line">    0-&gt; 1-&gt;2 -&gt;3-&gt;4-&gt;5</span><br><span class="line"></span><br><span class="line">    Reverse the piece, then fix the pointers</span><br><span class="line">    0-&gt; 2-&gt;1 -&gt;3-&gt;4-&gt;5</span><br><span class="line"></span><br><span class="line">2.  Find next piece with k nodes</span><br><span class="line">    0-&gt;2-&gt;1-&gt; 3-&gt;4 -&gt;5</span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 翻转一个子链表，并且返回新的头与尾</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, head: ListNode, tail: ListNode)</span>:</span></span><br><span class="line">        prev = tail.next</span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> prev != tail:</span><br><span class="line">            nex = p.next</span><br><span class="line">            p.next = prev</span><br><span class="line">            prev = p</span><br><span class="line">            p = nex</span><br><span class="line">        <span class="keyword">return</span> tail, head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        hair = ListNode(<span class="number">0</span>)  <span class="comment"># 添加一个辅助结点</span></span><br><span class="line">        hair.next = head  <span class="comment"># 使得算法能等同对待第一个k组</span></span><br><span class="line">        pre = hair</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            tail = pre</span><br><span class="line">            <span class="comment"># 查看剩余部分长度是否大于等于 k</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">                tail = tail.next</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> tail:</span><br><span class="line">                    <span class="keyword">return</span> hair.next</span><br><span class="line">            nex = tail.next</span><br><span class="line">            head, tail = self.reverse(head, tail)</span><br><span class="line">            <span class="comment"># 把子链表重新接回原链表</span></span><br><span class="line">            pre.next = head</span><br><span class="line">            tail.next = nex</span><br><span class="line">            pre = tail</span><br><span class="line">            head = tail.next</span><br><span class="line">        <span class="keyword">return</span> hair.next</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> linked list </tag>
            
            <tag> reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Search in Rotated Sorted Array</title>
      <link href="/programming/leetcode/search-in-rotated-sorted-array/"/>
      <url>/programming/leetcode/search-in-rotated-sorted-array/</url>
      
        <content type="html"><![CDATA[<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e., <code>[0,1,2,4,5,6,7]</code> might become <code>[4,5,6,7,0,1,2]</code>).</p><p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p><p>You may assume no duplicate exists in the array.</p><p>Your algorithm's runtime complexity must be in the order of O(log n).</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><h1 id="binary-search">Binary Search</h1><p>Time complexity in O(log n)? There must be binary search.</p><p>The key is, we split an array into two parts, there must exist a part is sorted (because is rotated only once). The another part could be sorted or unsored.</p><p>We can easily check target is in the sorted part or not. If in, find in sorted part. If not, find in another part.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(log(n))</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: <span class="string">'List[int]'</span>, target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        l, r = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="comment"># left is sorted</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= nums[<span class="number">0</span>]:  <span class="comment"># must be &gt;= (considering mid = 0)</span></span><br><span class="line">                <span class="keyword">if</span> nums[<span class="number">0</span>] &lt;= target &lt; nums[mid]:  <span class="comment"># in left</span></span><br><span class="line">                    r = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[<span class="number">-1</span>]:  <span class="comment"># in right</span></span><br><span class="line">                    l = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line"></span><br><span class="line">pointers: l = 0, r = 6, mid = 3</span><br><span class="line">nums:         4      2        7</span><br><span class="line">nums[mid] &gt; nums[l]:</span><br><span class="line">    4 &lt; 0 &lt; 7 is not True, l = mid + 1 = 4</span><br><span class="line"></span><br><span class="line">pointers: l = 4, r = 6, mid = 5</span><br><span class="line">nums:         0      2        1</span><br><span class="line">nums[mid] &gt; nums[l]:</span><br><span class="line">    0 &lt; 1 &lt; 2 is True, r = mid - 1 = 4</span><br><span class="line"></span><br><span class="line">pointers: l = 4, r = 4, mid = 4</span><br><span class="line">nums[mid] == target == 0, return 4.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> array </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Path Sum</title>
      <link href="/programming/leetcode/path-sum/"/>
      <url>/programming/leetcode/path-sum/</url>
      
        <content type="html"><![CDATA[<h1 id="path-sum-i">112. Path Sum I</h1><p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p><p>Note: A leaf is a node with no children.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given the below binary tree and sum = 22,</span><br><span class="line"></span><br><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \      \</span><br><span class="line">7    2      1</span><br><span class="line">return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.</span><br></pre></td></tr></table></figure><h2 id="bfs">BFS</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        queue = deque([(root, <span class="number">0</span>), ])</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node, sm = queue.popleft()  <span class="comment"># it's BFS when popleft, DFS when popright</span></span><br><span class="line">            sm += node.val</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:  <span class="comment"># is leaf node</span></span><br><span class="line">                <span class="keyword">if</span> sm == sum:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append((node.left, sm))</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append((node.right, sm))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="recursion">Recursion</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n), worst case, tree is a list.</span></span><br><span class="line"><span class="comment">#   Average O(log(n)), is tree's height.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> root.val == sum</span><br><span class="line">        sum -= root.val</span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left, sum) <span class="keyword">or</span> \</span><br><span class="line">               self.hasPathSum(root.right, sum)</span><br></pre></td></tr></table></figure><h1 id="path-sum-ii">113. Path Sum II</h1><p>Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.</p><p>Note: A leaf is a node with no children.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given the below binary tree and sum = 22,</span><br><span class="line"></span><br><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \    / \</span><br><span class="line">7    2  5   1</span><br><span class="line">Return:</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="bfs-1">BFS</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; list:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = deque([(root, <span class="number">0</span>, []), ])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node, sm, path = stack.pop()</span><br><span class="line">            sm += node.val</span><br><span class="line">            path.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                <span class="keyword">if</span> sm == sum:</span><br><span class="line">                    res.append(path)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append((node.right, sm, path[:]))</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append((node.left, sm, path[:]))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="recursion-1">Recursion</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; list:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(node, sm, path, res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            path.append(node.val)  <span class="comment"># tracing path</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:  <span class="comment"># leaf node</span></span><br><span class="line">                <span class="keyword">if</span> node.val == sm:</span><br><span class="line">                    res.append(path[:])</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                helper(node.left, sm - node.val, path, res)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                helper(node.right, sm - node.val, path, res)</span><br><span class="line">            <span class="keyword">del</span> path[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        r = []</span><br><span class="line">        helper(root, sum, [], r)</span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure><h1 id="path-sum-iii">437. Path Sum III</h1><p>You are given a binary tree in which each node contains an integer value.</p><p>Find the number of paths that sum to a given value.</p><p>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p><p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</span><br><span class="line"></span><br><span class="line">      10</span><br><span class="line">     /  \</span><br><span class="line">    5   -3</span><br><span class="line">   / \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> / \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">Return 3. The paths that sum to 8 are:</span><br><span class="line"></span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3. -3 -&gt; 11</span><br></pre></td></tr></table></figure><h2 id="double-recursion">Double Recursion</h2><p>Double recursion is easy to understand. Since we don't know which node could be the start node, we simply check each node.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2), not surely, but it's very slow compared to second solution.</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># check paths from root</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSumHelper</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        sum -= root.val</span><br><span class="line">        <span class="keyword">return</span> int(<span class="number">0</span> == sum) + \</span><br><span class="line">               self.pathSumHelper(root.left, sum) + \</span><br><span class="line">               self.pathSumHelper(root.right, sum)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self.pathSumHelper(root, sum) + \</span><br><span class="line">               self.pathSum(root.left, sum) + \</span><br><span class="line">               self.pathSum(root.right, sum)</span><br></pre></td></tr></table></figure><h2 id="single-recursion">※ Single Recursion</h2><p>This is a smarter way. Through an example to see how it works.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      10</span><br><span class="line">     /  \</span><br><span class="line">    5   -3</span><br><span class="line">   / \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> / \   \</span><br><span class="line">3  -2   1</span><br></pre></td></tr></table></figure><p>Keep a variable <code>curSum = 0</code>. First, check the node root, <code>curSum += 10</code>. It's not what we want. Then, we <strong>take a memo</strong> (<code>map[10] = map.get(10, 0) + 1</code>), which means <strong>there is a path with sum 10</strong>. Then, go to check it's chidren. We check node 5, <code>curSum += 5</code>, now <code>curSum = 15</code>...</p><p>Check node 3, now <code>curSum = 18</code>. Here, we find that <code>map[18 - 8] = map[10] = 1</code>, means there exist a path with sum 10, and if we remove that path from current path, we get a path with sum 8.</p><p>Be careful about that we need decrease <code>map[10]</code> by 1 after we explored it's descendants.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; int:</span></span><br><span class="line">        hashMap = defaultdict(int)</span><br><span class="line">        hashMap[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root, curSum)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            curSum += root.val</span><br><span class="line">            hashMap[curSum] += <span class="number">1</span>  <span class="comment"># current path's sum</span></span><br><span class="line">            leftCount = helper(root.left, curSum)</span><br><span class="line">            rightCount = helper(root.right, curSum)</span><br><span class="line">            hashMap[curSum] -= <span class="number">1</span>  <span class="comment"># backtracking</span></span><br><span class="line">            count = hashMap[curSum - sum]</span><br><span class="line">            <span class="keyword">return</span> count + leftCount + rightCount</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(root, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
            <tag> recursion </tag>
            
            <tag> binary tree </tag>
            
            <tag> leetcode </tag>
            
            <tag> path </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Check Completeness of a Binary Tree</title>
      <link href="/programming/leetcode/check-completeness-of-a-binary-tree/"/>
      <url>/programming/leetcode/check-completeness-of-a-binary-tree/</url>
      
        <content type="html"><![CDATA[<p>Given a binary tree, determine if it is a complete binary tree.</p><p>Definition of a complete binary tree from <a href="http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees" target="_blank" rel="noopener">Wikipedia</a>:</p><blockquote><p>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2^h nodes inclusive at the last level h.</p></blockquote><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6]</span><br><span class="line">     1</span><br><span class="line">   /   \</span><br><span class="line">  2     3</span><br><span class="line"> / \   /</span><br><span class="line">4   5 6</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3,4,5,null,7]</span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \   \</span><br><span class="line">4   5   7</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The node with value 7 isn&apos;t as far left as possible.</span><br></pre></td></tr></table></figure><p>Note: The tree will have between 1 and 100 nodes.</p><h1 id="bfs">BFS</h1><p>Accroding complete tree's definition.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isCompleteTree</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        queue = deque([root])</span><br><span class="line">        prev = root</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> prev <span class="keyword">and</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">            prev = node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h1 id="attach-indices">Attach indices</h1><p>At the root node, we will associate it with the code <code>1</code>. Then, for each node with code <code>v</code>, we will associate its left child with code <code>2 * v</code>, and its right child with code <code>2 * v + 1</code>. (Like heap, heap is a complete tree)</p><a id="more"></a><p>We can find the codes of every node in the tree in &quot;reading order&quot; (top to bottom, left to right) sequence using a breadth first search. (We could also use a depth first search and sort the codes later.)</p><p>Then, we check that the codes are the sequence <code>1, 2, 3, ...</code> with no gaps. Actually, we only need to check that the last code is correct, since the last code is the largest value.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isCompleteTree</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        nodes = [(root, <span class="number">1</span>)]</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(nodes):</span><br><span class="line">            node, v = nodes[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> node:  <span class="comment"># if there is a None, the indices will be orderless</span></span><br><span class="line">                nodes.append((node.left, <span class="number">2</span> * v))</span><br><span class="line">                nodes.append((node.right, <span class="number">2</span> * v + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  nodes[<span class="number">-1</span>][<span class="number">1</span>] == len(nodes)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binary tree </tag>
            
            <tag> leetcode </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Merge Sorted Array</title>
      <link href="/programming/leetcode/merge-sorted-array/"/>
      <url>/programming/leetcode/merge-sorted-array/</url>
      
        <content type="html"><![CDATA[<p>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.</p><p>Note:</p><p>The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is equal to m + n) to hold additional elements from nums2.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line">Output: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure><p>Constraints:</p><ul><li><code>-10^9 &lt;= nums1[i], nums2[i] &lt;= 10^9</code></li><li><code>nums1.length == m + n</code></li><li><code>nums2.length == n</code></li></ul><h1 id="two-pointers-backward">Two Pointers: backward</h1><p>Merge array in-place.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(m + n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1: <span class="string">'List[int]'</span>, m: int, nums2: <span class="string">'List[int]'</span>, n: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        i, j = m - <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line">        t = m + n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> nums1[i] &gt; nums2[j]:</span><br><span class="line">                nums1[t] = nums1[i]</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[t] = nums2[j]</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            t -= <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Longest Substrings Without Repeating Characters</title>
      <link href="/programming/leetcode/longest-substrings-without-repeating-characters/"/>
      <url>/programming/leetcode/longest-substrings-without-repeating-characters/</url>
      
        <content type="html"><![CDATA[<p>Given a string, find the length of the longest substring without repeating characters.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;abcabcbb&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;abc&quot;, with the length of 3.</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;bbbbb&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The answer is &quot;b&quot;, with the length of 1.</span><br></pre></td></tr></table></figure><p>Example 3:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;pwwkew&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;wke&quot;, with the length of 3.</span><br><span class="line">             Note that the answer must be a substring,</span><br><span class="line">             &quot;pwke&quot; is a subsequence and not a substring.</span><br></pre></td></tr></table></figure><h1 id="slinding-window">Slinding Window</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(min(n, m)), m is the size of the charset/alphabet.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        left = right = res = <span class="number">0</span></span><br><span class="line">        hSet = set()</span><br><span class="line">        <span class="keyword">while</span> right &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> s[right] <span class="keyword">not</span> <span class="keyword">in</span> hSet:</span><br><span class="line">                hSet.add(s[right])</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">                res = max(res, len(hSet))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hSet.remove(s[left])</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="sliding-window-optimized">Sliding Window Optimized</h1><p>The above solution requires at most 2n steps. In fact, it could be optimized to require only n steps. Instead of using a set to tell if a character exists or not, we could define a mapping of the characters to its index. Then we can skip the characters immediately when we found a repeated character.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(min(n, m)), m is the size of the charset/alphabet.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        left = res = <span class="number">0</span></span><br><span class="line">        hMap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> right, c <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> hMap <span class="keyword">and</span> hMap[c] &gt;= left:  <span class="comment"># hMap[c] &gt;= left</span></span><br><span class="line">                left = hMap[c] + <span class="number">1</span></span><br><span class="line">            res = max(res, right - left + <span class="number">1</span>)</span><br><span class="line">            hMap[c] = right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> hash table </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Binary Tree Maximum Path Sum</title>
      <link href="/programming/leetcode/binary-tree-maximum-path-sum/"/>
      <url>/programming/leetcode/binary-tree-maximum-path-sum/</url>
      
        <content type="html"><![CDATA[<p>Given a <strong>non-empty</strong> binary tree, find the maximum path sum.</p><p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree <strong>along the parent-child connections</strong>. The path must contain <strong>at least one node</strong> and does not need to go through the root.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      / \</span><br><span class="line">     2   3</span><br><span class="line"></span><br><span class="line">Output: 6</span><br><span class="line">Explanation: sum of path 2 - 1 - 3</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [-10,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">   -10</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">Output: 42</span><br><span class="line">Explanation: sum of path 15 - 20 - 7</span><br></pre></td></tr></table></figure><h1 id="before-coding">Before coding</h1><p>From examples, we know that the maximum path sum have two cases:</p><ol type="1"><li>connected a node with it's left or right child. (<code>a -&gt; a.left</code> or <code>a -&gt; a.right</code>)</li><li>connected a node with it's both left and right child. (<code>a.left -&gt; a -&gt; a.right</code>)</li></ol><p>The key difference between 1 and 2 is case 1 can connect <code>a</code> with it's parent (if exists), but 2 can't.</p><p>Take away the case 2. It would be much easier to design an algorithm solving it. Here gives the recursion algrithm.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = float(<span class="string">'-inf'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>  <span class="comment"># return 0 when node is None</span></span><br><span class="line">    left_sum = max(helper(node.left), <span class="number">0</span>)  <span class="comment"># recursively</span></span><br><span class="line">    right_sum = max(helper(node.right), <span class="number">0</span>)</span><br><span class="line">    <span class="comment"># the max path sum start from node downward to it's child</span></span><br><span class="line">    case1 = node.val + max(left_sum, right_sum)</span><br><span class="line">    <span class="comment"># record result (max path sum)</span></span><br><span class="line">    res = max(res, case1)</span><br><span class="line">    <span class="keyword">return</span> case1</span><br></pre></td></tr></table></figure><p>By recursion, each node is visited once and calculated the max path sum from it. Then greater one is saved to <code>res</code>.</p><h1 id="recursion">Recursion</h1><p>Now, what if put case 2 back. Obviously, we need consider one more case: <code>a.left -&gt; a -&gt; a.right</code>. Luckily, it's max path sum can be calculated by <code>left_sum + node.val + right_sum</code>. There is the revised algorithm.</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = float(<span class="string">'-inf'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>  <span class="comment"># return 0 when node is None</span></span><br><span class="line">    left_sum = max(helper(node.left), <span class="number">0</span>)  <span class="comment"># recursively</span></span><br><span class="line">    right_sum = max(helper(node.right), <span class="number">0</span>)</span><br><span class="line">    case1 = node.val + max(left_sum, right_sum)</span><br><span class="line">    res = max(res, case1)</span><br><span class="line">    <span class="comment"># ----- case 2 here ---------</span></span><br><span class="line">    case2 = node.val + left_sum + right_sum</span><br><span class="line">    res = max(res, case2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> case1</span><br></pre></td></tr></table></figure><p><strong>It also return <code>node.val + max(left_sum, right_sum)</code>, the max path sum of case 1.</strong> And, we found <code>case2 &gt;= case1</code>, so two lines can be eliminated in the function.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        max_sum = float(<span class="string">'-inf'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="string">"""Return the max path sum start from node downward to it's child."""</span></span><br><span class="line">            <span class="keyword">nonlocal</span> max_sum</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>  <span class="comment"># None</span></span><br><span class="line">            left_sum = max(helper(node.left), <span class="number">0</span>)</span><br><span class="line">            right_sum = max(helper(node.right), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># case 1: node.left -&gt; node -&gt; node.right</span></span><br><span class="line">            max_sum = max(max_sum, node.val + left_sum + right_sum)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># case 2: node -&gt; node.left or node -&gt; node.right</span></span><br><span class="line">            <span class="keyword">return</span> node.val + max(left_sum, right_sum)</span><br><span class="line"></span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> max_sum</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursion </tag>
            
            <tag> binary tree </tag>
            
            <tag> leetcode </tag>
            
            <tag> path </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3 Sum Closest</title>
      <link href="/programming/leetcode/3-sum-closest/"/>
      <url>/programming/leetcode/3-sum-closest/</url>
      
        <content type="html"><![CDATA[<p>Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums = [-1,2,1,-4], target = 1</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</span><br></pre></td></tr></table></figure><p>Constraints:</p><ul><li><code>3 &lt;= nums.length &lt;= 10^3</code></li><li><code>-10^3 &lt;= nums[i] &lt;= 10^3</code></li><li><code>-10^4 &lt;= target &lt;= 10^4</code></li></ul><h1 id="sorting-two-pointers">Sorting + Two Pointers</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2)</span></span><br><span class="line"><span class="comment"># Space: O(log(n)) to O(n),</span></span><br><span class="line"><span class="comment">#   depending on the implementation of the sorting algorithm.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums: <span class="string">'List[int]'</span>, target: int)</span> -&gt; int:</span></span><br><span class="line">        nums.sort()  <span class="comment"># O(n log(n))</span></span><br><span class="line">        best = float(<span class="string">'inf'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">2</span>):  <span class="comment"># O(n^2)</span></span><br><span class="line">            l, r = i + <span class="number">1</span>, len(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                sum_ = nums[i] + nums[l] + nums[r]</span><br><span class="line">                <span class="keyword">if</span> sum_ == target:  <span class="comment"># target found</span></span><br><span class="line">                    <span class="keyword">return</span> target</span><br><span class="line">                <span class="keyword">if</span> abs(best - target) &gt; abs(sum_ - target):</span><br><span class="line">                    best = sum_</span><br><span class="line">                <span class="keyword">if</span> sum_ &gt; target:</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] == nums[r + <span class="number">1</span>]:  <span class="comment"># skip equal num (optional)</span></span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] == nums[l - <span class="number">1</span>]:</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> best</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Min Stack</title>
      <link href="/programming/leetcode/min-stack/"/>
      <url>/programming/leetcode/min-stack/</url>
      
        <content type="html"><![CDATA[<p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p><ul><li><code>push(x)</code> -- Push element x onto stack.</li><li><code>pop()</code> -- Removes the element on top of the stack.</li><li><code>top()</code> -- Get the top element.</li><li><code>getMin()</code> -- Retrieve the minimum element in the stack.</li></ul><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span><br><span class="line">[[],[-2],[0],[-3],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[null,null,null,null,-3,null,0,-2]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin(); // return -3</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();    // return 0</span><br><span class="line">minStack.getMin(); // return -2</span><br></pre></td></tr></table></figure><p><strong>Constraints</strong>: Methods pop, top and getMin operations will always be called on non-empty stacks.</p><h1 id="two-stacks">Two stacks</h1><p>One stack to store values. To get min in constant time, we need another stack to store min values of current stack. (Or we can save (val, min) in one stack).</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push  3, 2, 4, 1, 5, 0</span><br><span class="line"></span><br><span class="line">stack         min_stack</span><br><span class="line">3             3</span><br><span class="line">3,2           3,2</span><br><span class="line">3,2,4         3,2,2    &lt;- push 2</span><br><span class="line">3,2,4,1       3,2,2,1</span><br><span class="line">3,2,4,1,5     3,2,2,1,1</span><br><span class="line">3,2,4,1,5,0   3,2,2,1,1,0</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.min_stack = [float(<span class="string">'inf'</span>)]  <span class="comment"># careful about IndexError</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.stack.append(x)</span><br><span class="line">        self.min_stack.append(min(x, self.getMin()))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.stack.pop()</span><br><span class="line">        self.min_stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.min_stack[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="min-value-variable">Min value variable</h1><p>In previous approach if we push values which are greater than min value <code>n</code> times, we also need push min value <code>n</code> times too.</p><ul><li>Push: We can use a variable recode current min value. If a greater value pushed, we won't push min value again.</li><li>Pop: When poped a value, we compare it with current min value, pop min stack if and only if they are equal.</li></ul><p>However, when pushing values which are equal to min value many times, wo also need push min value repeatedly. Otherwise, we can't preserve the min value after pop a value.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push  4, 1, 3, 9</span><br><span class="line">stack         min_stack      min_value</span><br><span class="line">4             4              4</span><br><span class="line">4,1           4,1            1</span><br><span class="line">4,1,3         4,1            1</span><br><span class="line">4,1,3,9       4,1            1</span><br><span class="line"></span><br><span class="line">pop  9, 3, 1, 4</span><br><span class="line">stack         min_stack      min_value</span><br><span class="line">4,1,3         4,1            1</span><br><span class="line">4,1           4,1            1</span><br><span class="line">4             4              4</span><br><span class="line">_             _              _</span><br><span class="line"></span><br><span class="line">======================================</span><br><span class="line"></span><br><span class="line">push  2, 2, 2</span><br><span class="line">stack         min_stack      min_value</span><br><span class="line">2             2              2</span><br><span class="line">2,2           2,2            2</span><br><span class="line">2,2,2         2,2,2          2</span><br><span class="line"></span><br><span class="line">pop  2, 2, 2</span><br><span class="line">stack         min_stack      min_value</span><br><span class="line">2,2           2,2            2</span><br><span class="line">2             2              2</span><br><span class="line">_             _              _</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.min_stack = [float(<span class="string">'inf'</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.stack.append(x)</span><br><span class="line">        <span class="keyword">if</span> x &lt;= self.min_stack[<span class="number">-1</span>]:</span><br><span class="line">            self.min_stack.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        v = self.stack.pop()</span><br><span class="line">        <span class="keyword">if</span> v == self.min_stack[<span class="number">-1</span>]:</span><br><span class="line">            self.min_stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.min_stack[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stack </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Continuous Subarray Sum</title>
      <link href="/programming/leetcode/continuous-subarray-sum/"/>
      <url>/programming/leetcode/continuous-subarray-sum/</url>
      
        <content type="html"><![CDATA[<p>Given a list of <strong>non-negative</strong> numbers and a target integer <code>k</code>, write a function to check if the array has a continuous subarray of size at least 2 that sums up to a multiple of <code>k</code>, that is, sums up to <code>n*k</code> where <code>n</code> is also an integer.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [23, 2, 4, 6, 7],  k=6</span><br><span class="line">Output: True</span><br><span class="line">Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [23, 2, 6, 4, 7],  k=6</span><br><span class="line">Output: True</span><br><span class="line">Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.</span><br></pre></td></tr></table></figure><p><strong>Constraints</strong>:</p><ul><li>The length of the array won't exceed 10,000.</li><li>You may assume the sum of all the numbers is in the range of a signed 32-bit integer.</li></ul><h1 id="broute-forse-optimized">Broute Forse Optimized</h1><p>Enumerate all subarray <code>a[i .. j]</code>. Calculate sum... By calcualte cumulative sum of array, we can get sum of any subarray in O(1). See problem <a href="/programming/leetcode/range-sum-query/" title="Range Sum Query">Range Sum Query</a>.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkSubarraySum</span><span class="params">(self, nums: <span class="string">'List[int]'</span>, k: int)</span> -&gt; bool:</span></span><br><span class="line">        accumulated = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            accumulated.append(accumulated[<span class="number">-1</span>] + num)</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n):  <span class="comment"># ensure j &gt; i</span></span><br><span class="line">                <span class="comment"># sum of nums[i .. j], at least two elements</span></span><br><span class="line">                sum_ = accumulated[j + <span class="number">1</span>] - accumulated[i]</span><br><span class="line">                <span class="keyword">if</span> sum_ == k <span class="keyword">or</span> (k != <span class="number">0</span> <span class="keyword">and</span> sum_ % k == <span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="hash-table">Hash Table</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Define nums[i .. j] as the sum of nums[i:j+1].</span><br><span class="line"></span><br><span class="line">If nums[i .. j] % k = 0, then:</span><br><span class="line">nums[0 .. j] % k = (nums[0 .. i-1] + nums[i .. j]) % k</span><br><span class="line">                 = nums[0 .. i-1] % k + nums[i .. j] % k</span><br><span class="line">                 = nums[0 .. i-1] % k + 0</span><br></pre></td></tr></table></figure><a id="more"></a><p>So, there is the algorithm to solve this problem using above property.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(min(n, k))</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkSubarraySum</span><span class="params">(self, nums: <span class="string">'List[int]'</span>, k: int)</span> -&gt; bool:</span></span><br><span class="line">        sum_ = <span class="number">0</span></span><br><span class="line">        hMap = &#123;<span class="number">0</span>: <span class="number">-1</span>&#125;  <span class="comment"># special for the case that subarray start from 0</span></span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            sum_ += n</span><br><span class="line">            <span class="keyword">if</span> k != <span class="number">0</span>:</span><br><span class="line">                sum_ %= k</span><br><span class="line">            <span class="keyword">if</span> sum_ <span class="keyword">in</span> hMap:</span><br><span class="line">                <span class="keyword">if</span> i - hMap[sum_] &gt; <span class="number">1</span>:  <span class="comment"># at least 2 elements</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># if not in, record it in map</span></span><br><span class="line">                hMap[sum_] = i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> array </tag>
            
            <tag> hash table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Merge Intervals</title>
      <link href="/programming/leetcode/merge-intervals/"/>
      <url>/programming/leetcode/merge-intervals/</url>
      
        <content type="html"><![CDATA[<p>Given a collection of intervals, merge all overlapping intervals.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">Output: [[1,6],[8,10],[15,18]]</span><br><span class="line">Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [[1,4],[4,5]]</span><br><span class="line">Output: [[1,5]]</span><br><span class="line">Explanation: Intervals [1,4] and [4,5] are considered overlapping.</span><br></pre></td></tr></table></figure><h1 id="sorting">Sorting</h1><p>If we sort the intervals by their start value, then each set of intervals that can be merged will appear as a contiguous &quot;run&quot; in the sorted list.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:  [(1, 9), (2, 5), (19, 20), (10, 11), (12, 20), (0, 3), (0, 1), (0, 2)]</span><br><span class="line">Sorted: [(0, 3), (0, 1), (0, 2), (1, 9), (2, 5), (10, 11), (12, 20), (19, 20)]</span><br><span class="line">         --------------------------------------  --------  ------------------</span><br><span class="line">        [                (0, 9),                 (10, 11),       (12, 20)    ]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n log(n))</span></span><br><span class="line"><span class="comment"># Space: O(1) or O(n), depending on sort algorithm</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals: <span class="string">'List[List[int]]'</span>)</span> -&gt; 'List[List[int]]':</span></span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">or</span> res[<span class="number">-1</span>][<span class="number">1</span>] &lt; x[<span class="number">0</span>]:</span><br><span class="line">                res.append(x)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[<span class="number">-1</span>][<span class="number">1</span>] = max(res[<span class="number">-1</span>][<span class="number">1</span>], x[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="counting-sort">Counting Sort</h1><p>This approach works like counting sort. Create a long enough array <code>a</code>:</p><ol type="1"><li>Scan each interval, for start value, <code>a[start] += 1</code>; for end value, <code>a[end] -= 1</code>.</li><li>Calculate cumulative sum of <code>a</code>. The merged interval always end at <code>j</code> where <code>a[j] == 0</code>. However, it can start from <code>i</code> where <code>a[i] == 0</code> also. That's a special interval we need to consider.</li></ol><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">         Overlapping                Containing   Special</span><br><span class="line">Input:  [[3,5],[4,6], [0,1],[1,2], [7,10],[8,9], [11,11]]</span><br><span class="line"></span><br><span class="line">index:  0  1  2  3  4  5  6  7  8  9  10  11</span><br><span class="line">array:  x  x  x  x  x  x  x  x  x  x   x   x   # x means no value</span><br><span class="line"> scan:  1  0 -1  1  1 -1 -1  1  1 -1  -1   0</span><br><span class="line"> accu:  1  1  0  1  2  1  0  1  2  1   0   0</span><br><span class="line">        &lt;     &gt;  &lt;        &gt;  &lt;         &gt;   &lt;&gt;</span><br><span class="line">merge: [ [0,2],    [3,6],     [7,10],      [11,11]  ]</span><br></pre></td></tr></table></figure><p><strong>This variation only works with non-negative values</strong>, you know the reason.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(max(n, m)), m is the greatest end-value of all intervals</span></span><br><span class="line"><span class="comment"># Space: O(m)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals: <span class="string">'List[List[int]]'</span>)</span> -&gt; 'List[List[int]]':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> intervals <span class="keyword">or</span> len(intervals) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> intervals</span><br><span class="line">        <span class="comment"># find max end, or pre-define a large enough value</span></span><br><span class="line">        max_bd = max(end <span class="keyword">for</span> _, end <span class="keyword">in</span> intervals)  <span class="comment"># &lt;-- O(n)</span></span><br><span class="line"></span><br><span class="line">        arr = [<span class="literal">None</span>] * (max_bd + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># a helper function return 0 when value is None</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">read_arr</span><span class="params">(i)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> arr[i] <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> arr[i]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># scan</span></span><br><span class="line">        <span class="keyword">for</span> start, end <span class="keyword">in</span> intervals:  <span class="comment"># &lt;-- O(n)</span></span><br><span class="line">            arr[start] = read_arr(start) + <span class="number">1</span></span><br><span class="line">            arr[end] = read_arr(end) - <span class="number">1</span></span><br><span class="line">        <span class="comment"># accumulate</span></span><br><span class="line">        acc = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(arr):  <span class="comment"># &lt;-- O(m)</span></span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                acc += x</span><br><span class="line">                arr[i] = acc</span><br><span class="line">        <span class="comment"># merge</span></span><br><span class="line">        res = []</span><br><span class="line">        i = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(arr)):  <span class="comment"># &lt;-- O(m)</span></span><br><span class="line">            <span class="keyword">if</span> arr[j] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    i = j</span><br><span class="line">                <span class="keyword">if</span> arr[j] == <span class="number">0</span>:</span><br><span class="line">                    res.append([i, j])</span><br><span class="line">                    i = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="counting-sort-using-dict">Counting Sort using Dict</h1><p>Using dict instead of list, the above method can process negative values. However, can't process decimal values.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(max(n, m)), m is the greatest end-value of all intervals</span></span><br><span class="line"><span class="comment"># Space: O(min(2n, p)), p = len(set(v for v in itv for itv in intervals)),</span></span><br><span class="line"><span class="comment">#        i.e., p is the number of distinct values</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals: <span class="string">'List[List[int]]'</span>)</span> -&gt; 'List[List[int]]':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> intervals <span class="keyword">or</span> len(intervals) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> intervals</span><br><span class="line"></span><br><span class="line">        arr = &#123;&#125;</span><br><span class="line">        min_bd, max_bd = float(<span class="string">'inf'</span>), float(<span class="string">'-inf'</span>)</span><br><span class="line">        <span class="comment"># scan</span></span><br><span class="line">        <span class="keyword">for</span> start, end <span class="keyword">in</span> intervals:  <span class="comment"># &lt;-- O(n)</span></span><br><span class="line">            arr[start] = arr.get(start, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            arr[end] = arr.get(end, <span class="number">0</span>) - <span class="number">1</span></span><br><span class="line">            min_bd = min(min_bd, start)</span><br><span class="line">            max_bd = max(max_bd, end)</span><br><span class="line">        <span class="comment"># accumulate</span></span><br><span class="line">        acc = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(min_bd, max_bd + <span class="number">1</span>):  <span class="comment"># &lt;-- O(m)</span></span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> arr:</span><br><span class="line">                acc += arr[i]</span><br><span class="line">                arr[i] = acc</span><br><span class="line">        <span class="comment"># merge</span></span><br><span class="line">        res = []</span><br><span class="line">        i = min_bd</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(min_bd, max_bd + <span class="number">1</span>):  <span class="comment"># &lt;-- O(m)</span></span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">in</span> arr:</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    i = j  <span class="comment"># j not +1 in this case</span></span><br><span class="line">                <span class="keyword">if</span> arr[j] == <span class="number">0</span>:</span><br><span class="line">                    res.append([i, j])</span><br><span class="line">                    i = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="summary">Summary</h1><table style="width:100%;"><colgroup><col style="width: 16%"><col style="width: 16%"><col style="width: 16%"><col style="width: 16%"><col style="width: 16%"><col style="width: 16%"></colgroup><thead><tr class="header"><th>Method or Algorithm</th><th>Time</th><th>Space</th><th>Can process<br>non-negative values?</th><th>Can process<br>negative values?</th><th>Can process<br>decimal values?</th></tr></thead><tbody><tr class="odd"><td>Sorting</td><td><code>O(n log(n))</code></td><td><code>O(1) or O(n)</code></td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr class="even"><td>Counting Sort</td><td><code>O(max(n, m))</code></td><td><code>O(m)</code></td><td>Yes</td><td>No</td><td>No</td></tr><tr class="odd"><td>Counting Sort using Dict</td><td><code>O(max(n, m))</code></td><td><code>O(min(2n, p))</code></td><td>No</td><td>No</td><td>No</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort </tag>
            
            <tag> leetcode </tag>
            
            <tag> counting sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kth Largest Element in an Array</title>
      <link href="/programming/leetcode/kth-largest-element-in-an-array/"/>
      <url>/programming/leetcode/kth-largest-element-in-an-array/</url>
      
        <content type="html"><![CDATA[<p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,2,1,5,6,4] and k = 2</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,2,3,1,2,4,5,5,6] and k = 4</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p>Note: You may assume k is always valid, <code>1 &lt;= k &lt;= array.length</code>.</p><h1 id="quick-sort">Quick Sort</h1><p>kth largest is the (n-k)th element in ordered array.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(log(n))</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, nums, left, right)</span>:</span></span><br><span class="line">        pivot = nums[right]</span><br><span class="line">        i, j = left, right - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># i &lt; hi, j &gt;= lo, can avoid the case i == j after loops</span></span><br><span class="line">            <span class="comment"># i == j will cause infinite loop</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; right <span class="keyword">and</span> nums[i] &lt;= pivot:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= left <span class="keyword">and</span> nums[j] &gt;= pivot:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; j:</span><br><span class="line">                nums[i], nums[right] = nums[right], nums[i]</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="comment"># There is another variation of partition,</span></span><br><span class="line">        <span class="comment"># which is eaiser but not as efficiently as above.</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        pivot, i = a[right], left</span></span><br><span class="line"><span class="string">        for j in range(left, right):</span></span><br><span class="line"><span class="string">            if a[j] &lt; pivot:</span></span><br><span class="line"><span class="string">                a[i], a[j] = a[j], a[i]</span></span><br><span class="line"><span class="string">                i += 1</span></span><br><span class="line"><span class="string">        a[i], a[right] = a[right], a[i]</span></span><br><span class="line"><span class="string">        return i</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">randomizedPartition</span><span class="params">(self, nums, lo, hi)</span>:</span></span><br><span class="line">        i = randint(lo, hi)</span><br><span class="line">        nums[i], nums[hi] = nums[hi], nums[i]</span><br><span class="line">        <span class="keyword">return</span> self.partition(nums, lo, hi)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quickSelect</span><span class="params">(self, nums, lo, hi, t)</span>:</span></span><br><span class="line">        q = self.randomizedPartition(nums, lo, hi)</span><br><span class="line">        <span class="keyword">if</span> q == t:</span><br><span class="line">            <span class="keyword">return</span> nums[t]</span><br><span class="line">        <span class="keyword">elif</span> q &lt; t:</span><br><span class="line">            <span class="keyword">return</span> self.quickSelect(nums, q + <span class="number">1</span>, hi, t)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># q &gt; k</span></span><br><span class="line">            <span class="keyword">return</span> self.quickSelect(nums, lo, q - <span class="number">1</span>, t)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: list, k: int)</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">return</span> self.quickSelect(nums, <span class="number">0</span>, n - <span class="number">1</span>, n - k)</span><br></pre></td></tr></table></figure><h1 id="heap">Heap</h1><p>Using a max heap, pop k-1 times from heap, the current top element is the kth largest element.</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(nlog(n))</span></span><br><span class="line"><span class="comment"># Space: O(log(n)), recursion stack during sift_down</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sift_down</span><span class="params">(self, nums, heap_size, i)</span>:</span></span><br><span class="line">        l, r = (i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>, (i &lt;&lt; <span class="number">1</span>) + <span class="number">2</span></span><br><span class="line">        largest = i</span><br><span class="line">        <span class="keyword">if</span> l &lt; heap_size <span class="keyword">and</span> nums[l] &gt; nums[largest]:</span><br><span class="line">            largest = l</span><br><span class="line">        <span class="keyword">if</span> r &lt; heap_size <span class="keyword">and</span> nums[r] &gt; nums[largest]:</span><br><span class="line">            largest = r</span><br><span class="line">        <span class="keyword">if</span> largest != i:</span><br><span class="line">            nums[largest], nums[i] = nums[i], nums[largest]</span><br><span class="line">            self.sift_down(nums, heap_size, largest)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heapify</span><span class="params">(self, nums, heap_size)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(heap_size &lt;&lt; <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            self.sift_down(nums, heap_size, i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: list, k: int)</span> -&gt; int:</span></span><br><span class="line">        size = len(nums)</span><br><span class="line">        self.heapify(nums, size)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k - <span class="number">1</span>):</span><br><span class="line">            nums[<span class="number">0</span>], nums[size - <span class="number">1</span>] = nums[size - <span class="number">1</span>], nums[<span class="number">0</span>]</span><br><span class="line">            size -= <span class="number">1</span></span><br><span class="line">            self.sift_down(nums, size, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursion </tag>
            
            <tag> heap </tag>
            
            <tag> leetcode </tag>
            
            <tag> array </tag>
            
            <tag> quick sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lowest Common Ancestor</title>
      <link href="/programming/leetcode/lowest-common-ancestor/"/>
      <url>/programming/leetcode/lowest-common-ancestor/</url>
      
        <content type="html"><![CDATA[<h1 id="lca-of-a-binary-tree">LCA of a Binary Tree</h1><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p><p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="noopener">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we <strong>allow a node to be a descendant of itself</strong>).”</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4]</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">   /    \</span><br><span class="line">  5      1</span><br><span class="line"> / \    / \</span><br><span class="line">6   2  0   8</span><br><span class="line">   / \</span><br><span class="line">  7   4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: p = 5, q = 1</span><br><span class="line">Output: 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: p = 5, q = 4</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><p>Note:</p><ul><li>All of the nodes' values will be unique.</li><li><code>p</code> and <code>q</code> are different and both values will exist in the binary tree.</li></ul><h2 id="resursion">Resursion</h2><ul><li><code>left = True</code> if <code>p</code> or <code>q</code> in it's left subtree.</li><li><code>right = True</code> if <code>p</code> or <code>q</code> in it's right subtree.</li><li><code>mid = True</code> if itself is <code>p</code> or <code>q</code></li></ul><p>A node is a LCA of <code>p</code> and <code>q</code> if <code>left + right + mid == 2</code> (two of three become True).</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     3</span><br><span class="line">   /    \</span><br><span class="line">  5      1</span><br><span class="line"> / \    / \</span><br><span class="line">6   2  0   8</span><br><span class="line">   / \</span><br><span class="line">  7   4</span><br><span class="line"></span><br><span class="line">3 is LCA of 5 and 1.      (left == right == True)</span><br><span class="line">5 is LCA of 5 and 4.      (mid == right == True)</span><br><span class="line">5 is LCA of 5 and 6.      (mid == left == True)</span><br><span class="line">5 is not LCA of 2 and 4.  (right == True)</span><br><span class="line"></span><br><span class="line">left == right == mid == Ture never happens.</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n), maximum recursion stack</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: TreeNode, p: TreeNode, q: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        ans = root</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># Left recursion.</span></span><br><span class="line">            left = helper(node.left)</span><br><span class="line">            <span class="comment"># Right recursion.</span></span><br><span class="line">            right = helper(node.right)</span><br><span class="line">            mid = node <span class="keyword">in</span> (p, q)</span><br><span class="line">            <span class="comment"># If any two of the three flags left, right or mid become True.</span></span><br><span class="line">            <span class="keyword">if</span> left + mid + right &gt;= <span class="number">2</span>:</span><br><span class="line">                ans = node</span><br><span class="line">            <span class="keyword">return</span> left <span class="keyword">or</span> mid <span class="keyword">or</span> right</span><br><span class="line"></span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="iterative-using-parent-pointers">Iterative using parent pointers</h2><p>In recursion, the recursion stack let us go back to parent when children are visited. In iteration, we using parent pointers.</p><p>The procedure of iteration:</p><ol type="1"><li>Find path's from root to <code>p</code> and from root to <code>q</code>.</li><li>Backtracking from <code>p</code> to root using parent pointers.</li><li>Backtracking from <code>q</code> to root, the first common node is LCA of <code>p</code> and <code>q</code>.</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: TreeNode, p: TreeNode, q: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        stack, parent = [root], &#123;root: <span class="literal">None</span>&#125;</span><br><span class="line">        <span class="comment"># find paths</span></span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">not</span> <span class="keyword">in</span> parent <span class="keyword">or</span> q <span class="keyword">not</span> <span class="keyword">in</span> parent:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">                parent[node.right] = node</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">                parent[node.left] = node</span><br><span class="line">        <span class="comment"># backtracking p ~&gt; root</span></span><br><span class="line">        ancestors = set()</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            ancestors.add(p)</span><br><span class="line">            p = parent[p]</span><br><span class="line">        <span class="comment"># backtracking q ~&gt; root</span></span><br><span class="line">        <span class="keyword">while</span> q <span class="keyword">not</span> <span class="keyword">in</span> ancestors:</span><br><span class="line">            q = parent[q]</span><br><span class="line">        <span class="keyword">return</span> q</span><br></pre></td></tr></table></figure><h2 id="without-parent-pointers">Without parent pointers</h2><p>When we find one node of <code>p</code> or <code>q</code>, tracking a variable <code>lca</code> to indicate the node where we &quot;split&quot; our path.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     3</span><br><span class="line">   /    \</span><br><span class="line">  5      1</span><br><span class="line"> / \    / \</span><br><span class="line">6   2  0   8</span><br><span class="line">   / \</span><br><span class="line">  7   4</span><br><span class="line"></span><br><span class="line">Input: p = 6, q = 4</span><br><span class="line"></span><br><span class="line">3 -&gt; 5 -&gt; 6.       One node found. lca = 6</span><br><span class="line">3 -&gt; 5             Backtracking.  lca = 5  (lca only move left along the path)</span><br><span class="line">3 -&gt; 5 -&gt; 2 -&gt; 7.</span><br><span class="line">3 -&gt; 5 -&gt; 2</span><br><span class="line">3 -&gt; 5 -&gt; 2 -&gt; 4.  Another node found. return lca = 5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Input: p = 5, q = 4</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">3 -&gt; 5 -&gt; 2 -&gt; 4.  One node found. lca = 4</span><br><span class="line">3 -&gt; 5 -&gt; 2.       Backtracking. lca = 2</span><br><span class="line">3 -&gt; 5.            Another node found. lca = 5</span><br></pre></td></tr></table></figure><h3 id="iteration">Iteration</h3><p>To do this, we need a &quot;path&quot; save the nodes from root to current. We made a little change with stack: add a flag to represent current node's visit state.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: TreeNode, p: TreeNode, q: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        PENDING, HALF_DONE, DONE = <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        stack = [(root, PENDING)]</span><br><span class="line">        one_found, lca_ind = <span class="literal">False</span>, <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node, state = stack[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> state != DONE:</span><br><span class="line">                <span class="keyword">if</span> state == PENDING:  <span class="comment"># PENDING</span></span><br><span class="line">                    <span class="keyword">if</span> node <span class="keyword">in</span> (p, q):</span><br><span class="line">                        <span class="keyword">if</span> one_found:</span><br><span class="line">                            <span class="keyword">return</span> stack[lca_ind][<span class="number">0</span>]</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            one_found = <span class="literal">True</span></span><br><span class="line">                            lca_ind = len(stack) - <span class="number">1</span></span><br><span class="line">                    child = node.left</span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># HALF_DONE</span></span><br><span class="line">                    child = node.right</span><br><span class="line"></span><br><span class="line">                <span class="comment"># update state</span></span><br><span class="line">                stack.pop()</span><br><span class="line">                stack.append((node, state - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> child:</span><br><span class="line">                    stack.append((child, PENDING))</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># DONE</span></span><br><span class="line">                stack.pop()  <span class="comment"># backtracking on path</span></span><br><span class="line">                <span class="keyword">if</span> one_found <span class="keyword">and</span> lca_ind == len(stack):  <span class="comment"># need move left</span></span><br><span class="line">                    lca_ind -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="recursion">Recursion</h3><p>It's easier to keep a path during recursive DFS:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: TreeNode, p: TreeNode, q: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        find_another, lca = <span class="literal">False</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(node, path)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> find_another, lca</span><br><span class="line"></span><br><span class="line">            path.append(node)  <span class="comment"># add current node</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">in</span> (p, q):</span><br><span class="line">                find_another = <span class="keyword">not</span> find_another</span><br><span class="line">                <span class="keyword">if</span> find_another:</span><br><span class="line">                    lca = path[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                helper(node.left, path)  <span class="comment"># go deeper</span></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                helper(node.right, path)</span><br><span class="line">            backed = path.pop()  <span class="comment"># remove current node</span></span><br><span class="line">            <span class="keyword">if</span> find_another <span class="keyword">and</span> lca == backed:</span><br><span class="line">                lca = path[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        helper(root, [])</span><br><span class="line">        <span class="keyword">return</span> lca</span><br></pre></td></tr></table></figure><h1 id="lca-of-binary-search-tree">LCA of Binary Search Tree</h1><p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given binary search tree: root = [6,2,8,0,4,7,9,null,null,3,5]</span><br><span class="line"></span><br><span class="line">     6</span><br><span class="line">   /    \</span><br><span class="line">  2      8</span><br><span class="line"> / \    / \</span><br><span class="line">0   4  7   9</span><br><span class="line">   / \</span><br><span class="line">  3   5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: p = 2, q = 8</span><br><span class="line">Output: 6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: p = 2, q = 4</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Constraints</strong>:</p><ul><li>All of the nodes' values will be unique.</li><li><code>p</code> and <code>q</code> are different and both values will exist in the BST.</li></ul><h2 id="before-coding">Before coding</h2><p>We can solve this using the approaches to find LCA in a binary tree.</p><p>But, binary search tree's property could be utilized, to come up with a better algorithm.</p><p>Lets review properties of a BST:</p><blockquote><ol type="1"><li>Left subtree of a node N contains nodes whose values are lesser than or equal to node N's value.</li><li>Right subtree of a node N contains nodes whose values are greater than node N's value.</li><li>Both left and right subtrees are also BSTs.</li></ol></blockquote><p>The LCA's position:</p><ol type="1"><li>If current node's value lesser than value of <code>p</code> and <code>q</code>, the LCA must exist in current node's right subtree.</li><li>If current node's value greater than value of <code>p</code> and <code>q</code>, the LCA must exist in current node's left subtree.</li><li>If both 1 and 2 are not True, the current node is the LCA.</li></ol><p>The algorithm is based on an important constraint: <code>p</code> and <code>q</code> are different and both values will exist in the BST.</p><h2 id="recursion-1">Recursion</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: TreeNode, p: TreeNode, q: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        min_, max_ = min(p.val, q.val), max(p.val, q.val)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">lca</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> node.val &gt; max_:</span><br><span class="line">                <span class="keyword">return</span> lca(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.val &lt; min_:</span><br><span class="line">                <span class="keyword">return</span> lca(node.right)</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lca(root)</span><br></pre></td></tr></table></figure><h2 id="iteration-1">Iteration</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: TreeNode, p: TreeNode, q: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        min_, max_ = min(p.val, q.val), max(p.val, q.val)</span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            <span class="keyword">if</span> node.val &gt; max_:</span><br><span class="line">                node = node.left</span><br><span class="line">            <span class="keyword">elif</span> node.val &lt; min_:</span><br><span class="line">                node = node.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> node</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binary tree </tag>
            
            <tag> leetcode </tag>
            
            <tag> BST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Coin Change</title>
      <link href="/programming/leetcode/coin-change/"/>
      <url>/programming/leetcode/coin-change/</url>
      
        <content type="html"><![CDATA[<p>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: coins = [1, 2, 5], amount = 11</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: coins = [2], amount = 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p>Note: You may assume that you have an infinite number of each kind of coin.</p><h1 id="bottom-up-dp">Bottom-Up DP</h1><p>Let's define <code>dp[s]</code> as the minimum number of coins needed to make change for amount <code>s</code> using coins <code>c</code>.</p><p>Base case: <code>dp[0] = 0</code>.</p><p>Induction rule: <code>dp[s] = ?</code>. If we take a coin <code>c[i]</code> first, then we need <code>dp[s - c[i]] + 1</code> coins. So, <code>dp[s] = min(dp[s - c[i]] | i = 0, 1, ..., n - 1) + 1</code>, i.e., we try every coin.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n * s), n = len(coins), s = amount</span></span><br><span class="line"><span class="comment"># Space: O(s)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: list, amount: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> amount &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dp = [float(<span class="string">'inf'</span>)] * (amount + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(coin, amount + <span class="number">1</span>):  <span class="comment"># x start from coin</span></span><br><span class="line">                dp[x] = min(dp[x], dp[x - coin] + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != float(<span class="string">'inf'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="top-down-dp">Top-Down DP</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n * s), n = len(coins), s = amount</span></span><br><span class="line"><span class="comment"># Space: O(s)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: list, amount: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> amount &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x: int, dp: list)</span> -&gt; int:</span></span><br><span class="line">            <span class="keyword">if</span> x == <span class="number">0</span> <span class="keyword">or</span> dp[x] != <span class="number">0</span>:  <span class="comment"># base case</span></span><br><span class="line">                <span class="keyword">return</span> dp[x]</span><br><span class="line">            <span class="comment"># induction rule</span></span><br><span class="line">            dp[x] = float(<span class="string">'inf'</span>)</span><br><span class="line">            <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">                <span class="keyword">if</span> x &gt;= coin:</span><br><span class="line">                    dp[x] = min(dp[x], helper(x - coin, dp) + <span class="number">1</span>)</span><br><span class="line">            <span class="string">'''</span></span><br><span class="line"><span class="string">            dp[x] = min((helper(x - coin, dp) + 1 for coin in coins</span></span><br><span class="line"><span class="string">                        if x &gt;= coin), default=float('inf'))</span></span><br><span class="line"><span class="string">            '''</span></span><br><span class="line">            <span class="keyword">return</span> dp[x]</span><br><span class="line"></span><br><span class="line">        dp = [<span class="number">0</span>] * (amount + <span class="number">1</span>)</span><br><span class="line">        helper(amount, dp)</span><br><span class="line">        <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != float(<span class="string">'inf'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Add Strings</title>
      <link href="/programming/leetcode/add-strings/"/>
      <url>/programming/leetcode/add-strings/</url>
      
        <content type="html"><![CDATA[<p>Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.</p><p><strong>Note</strong>:</p><ul><li>The length of both num1 and num2 is &lt; 5100.</li><li>Both num1 and num2 contains only digits 0-9.</li><li>Both num1 and num2 does not contain any leading zero.</li><li>You must not use any built-in BigInteger library or convert the inputs to integer directly.</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(max(n1, n2)), n1, n2 are the length of num1, num2</span></span><br><span class="line"><span class="comment"># Space: O(max(n1, n2))</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addStrings</span><span class="params">(self, num1: str, num2: str)</span> -&gt; str:</span></span><br><span class="line">        res = []</span><br><span class="line">        i, j, carry = len(num1) - <span class="number">1</span>, len(num2) - <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">or</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            n1 = int(num1[i]) <span class="keyword">if</span> i &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            n2 = int(num2[j]) <span class="keyword">if</span> j &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            tmp = n1 + n2 + carry</span><br><span class="line">            carry = tmp // <span class="number">10</span></span><br><span class="line">            res.append(tmp % <span class="number">10</span>)</span><br><span class="line">            i, j = i - <span class="number">1</span>, j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> carry &gt; <span class="number">0</span>:</span><br><span class="line">            res.append(carry)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(str(x) <span class="keyword">for</span> x <span class="keyword">in</span> reversed(res))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Longest Chunked Palindrome Decomposition</title>
      <link href="/programming/leetcode/longest-chunked-palindrome-decomposition/"/>
      <url>/programming/leetcode/longest-chunked-palindrome-decomposition/</url>
      
        <content type="html"><![CDATA[<p>Return the largest possible <code>k</code> such that there exists <code>a_1, a_2, ..., a_k</code> such that:</p><ul><li>Each <code>a_i</code> is a non-empty string;</li><li>Their concatenation <code>a_1 + a_2 + ... + a_k</code> is equal to text;</li><li>For all <code>1 &lt;= i &lt;= k</code>, <code>a_i = a_{k+1 - i}</code>.</li></ul><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: text = &quot;ghiabcdefhelloadamhelloabcdefghi&quot;</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: We can split the string on &quot;(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)&quot;.</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: text = &quot;merchant&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: We can split the string on &quot;(merchant)&quot;.</span><br></pre></td></tr></table></figure><p>Example 3:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: text = &quot;antaprezatepzapreanta&quot;</span><br><span class="line">Output: 11</span><br><span class="line">Explanation: We can split the string on &quot;(a)(nt)(a)(pre)(za)(tpe)(za)(pre)(a)(nt)(a)&quot;.</span><br></pre></td></tr></table></figure><p>Example 4:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: text = &quot;aaa&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: We can split the string on &quot;(a)(a)(a)&quot;.</span><br></pre></td></tr></table></figure><p>Constraints:</p><ul><li>text consists only of lowercase English characters.</li><li><code>1 &lt;= text.length &lt;= 1000</code></li></ul><h1 id="greedy">Greedy</h1><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: abcdefabc</span><br><span class="line"></span><br><span class="line">1. is a == c ? No</span><br><span class="line">2. is ab == bc ? No</span><br><span class="line">3. is abc == abc ? Yes, res += 2</span><br><span class="line">4. is d == f ? No</span><br><span class="line">5. is de == ef ? No</span><br><span class="line">6. is def == def ? Yes, res += 1</span><br><span class="line"></span><br><span class="line">We must be careful about the case that</span><br><span class="line">a substring crossing the middle point.</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2)</span></span><br><span class="line"><span class="comment"># Space: O(n), the max length of substring we compared can be n/2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestDecomposition</span><span class="params">(self, text: str)</span> -&gt; int:</span></span><br><span class="line">        n = len(text)</span><br><span class="line">        i = res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n // <span class="number">2</span>):  <span class="comment"># move forward end point</span></span><br><span class="line">            <span class="keyword">if</span> text[i:j + <span class="number">1</span>] == text[n - j - <span class="number">1</span>:n - i]:</span><br><span class="line">                res += <span class="number">2</span></span><br><span class="line">                i = j + <span class="number">1</span>  <span class="comment"># new start point</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">2</span> * i &lt; n:  <span class="comment"># middle chunk</span></span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="recursion">Recursion</h1><p>Same procedure implemented by recursion.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2)</span></span><br><span class="line"><span class="comment"># Space: O(n), as much as n/2 recursion depth</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestDecomposition</span><span class="params">(self, text: str)</span> -&gt; int:</span></span><br><span class="line">        n = len(text)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n // <span class="number">2</span> + <span class="number">1</span>):  <span class="comment"># j is the length of substrings we compared</span></span><br><span class="line">            <span class="keyword">if</span> text[<span class="number">0</span>:j] == text[n - j:n]:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">2</span> * j &lt; n:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">2</span> + self.longestDecomposition(text[j:n-j])</span><br><span class="line">                <span class="keyword">elif</span> <span class="number">2</span> * j == n:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># 2 * j &gt; n, substring crossed middle point</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>  <span class="comment"># not matched</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursion </tag>
            
            <tag> leetcode </tag>
            
            <tag> palindrome </tag>
            
            <tag> greedy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络层</title>
      <link href="/notes/computer-networking/network-layer/"/>
      <url>/notes/computer-networking/network-layer/</url>
      
        <content type="html"><![CDATA[<p>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网络层不提供服务质量的承诺。如果主机中的进程之间的通信需要是可靠的，那么就由网络的主机中的运输层负责（包括差错处理、流量控制）。采用这种设计思路的好处是：网络造价大大降低，运行方式灵活，能够适应多种应用。</p><h1 id="网际协议-ip">网际协议 IP</h1><p>与 IP 协议配套使用的还有三个协议：</p><ul><li>地址解析协议 ARP（Address Resolution Protocol）</li><li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li><li>网际组管理协议（Internet Group Management Protocol）</li></ul><p>IP 协议使用 ARP 协议。ICMP 和 IGMP 使用 IP 协议。</p><p>将网络互相连接起来要使用一些<strong>中间设备</strong>。根据中间设备所在的层次，可以有以下四种不同的中间设备：</p><ol type="1"><li>物理层使用的中间设备叫做<strong>转发器</strong>（repeater）。</li><li>数据链路层使用的中间设备叫做<strong>网桥</strong>或<strong>桥接器</strong>（bridge）。</li><li>网络层使用的中间设备叫做<strong>路由器</strong>（router）。</li><li>在网络层以上使用的中间设备叫做<strong>网关</strong>（gateway）。用网关连接两个不兼容的系统需要在高层进行协议的转换。</li></ol><p>当中间设备是转发器或网桥时，这仅仅是把一个网络扩大了，而从网络层的角度看，这仍然是一个网络，一般并不称为网络互连。网关由于比较复杂，目前使用得较少。因此讨论网络互连时，都是指用路由器进行网络互连和路由选择。路由器其实就是一台专用计算机，用来在互联网中进行路由选择。由于历史的原因，许多有关 TCP/IP 的文献曾经把网络层使用的路由器称为网关，本书有时也这样用。</p><h1 id="ip-地址">IP 地址</h1><p>整个的互联网就是一个单一的、抽象的网络。IP 地址就是给互联网上的每一台主机（或路由器）的每一个接口分配一个在全世界范围内唯一的 32 位的标识符。IP 地址的编址方式经过了三个历史阶段。</p><ol type="1"><li>分类的 IP 地址。最基本的编址方法。</li><li>子网的划分。对最基本的编址方法的改进。</li><li>构成超网。无分配编址方法。已被广泛使用。</li></ol><h1 id="分类的-ip-地址">分类的 IP 地址</h1><table><tr><th>网络类别</th><th>类别位</th><th>网络号</th><th>主机号</th></tr><tr><td>A</td><td>0</td><td>8 位</td><td>24 位</td></tr><tr><td>B</td><td>10</td><td>16 位</td><td>16 位</td></tr><tr><td>C</td><td>110</td><td>24 位</td><td>8 位</td></tr><tr><td>D</td><td>1110</td><td colspan="2" style="text-align: center;">多播地址</td></tr><tr><td>E</td><td>1111</td><td colspan="2" style="text-align: center;">保留为今后使用</td></tr></table><a id="more"></a><p>申请 IP 地址时，实际上是获得了具有同样网络号的一块地址。其中具体的各台主机号则由单位自行分配，只要做到在该单位管辖的范围内无重复的主机号即可。</p><p>A 类地址的网络号的第一位固定为 0，因此 A 类地址空间共有 2^31 个地址，占整个 IP 地址空间的 50%。同理，B 类占 25%，C 类占 12.5%。</p><p>全 0 的主机号字段表示该 IP 地址是“本主机”所连接到的<strong>一个网络的地址</strong>（例如，一主机的 IP 地址为 5.6.7.8，则该主机所在的网络地址就是 5.0.0.0），而全 1 表示“<strong>所有的</strong>”，全 1 的主机号字段表示该网络上的所有主机。</p><table><thead><tr class="header"><th>网络类别</th><th>最大可指派网络数</th><th>不指派网络号</th><th>第一个可指派的网络号</th><th>最后一个可指派的网络号</th><th>最大主机数</th></tr></thead><tbody><tr class="odd"><td>A</td><td>2^7 - 2</td><td>0 和 127</td><td>1</td><td>126</td><td>2^24 - 2</td></tr><tr class="even"><td>B</td><td>2^14 - 1</td><td>128.0</td><td>128.1</td><td>191.255</td><td>2^16 - 2</td></tr><tr class="odd"><td>C</td><td>2^21 - 1</td><td>192.0.0</td><td>192.0.1</td><td>223.255.255</td><td>2^8 - 2</td></tr></tbody></table><p>A 类地址的网络号有 7 位可用，但可指派的网络号是 2^7 - 2 = 126 个。减 2 的原因是：第一，网络号字段全 0 的 IP 地址是个保留地址，意思是”<strong>本网络</strong>“；第二，网络号为 127（即 01111111）保留作为本地软件<strong>环回测试</strong>（loopback test）本主机的进程之间的通信之用。若主机发送一个目的地址为环回地址（例如 127.0.0.1）的 IP 数据报，则本主机中的协议软件就会处理数据报中的数据，而不会把数据报发送到任何网络。目的地址为环回地址的 IP 数据报永远不会出现在任何网络上，因为网络号为 127 的地址根本不是一个网络地址。</p><p>IP 地址具有以下一些重要特点。</p><ol type="1"><li>每一个 IP 地址都由网络号和主机号两部分组成。这样做有两个好处：第一，<strong>方便 IP 地址的管理</strong>，IP 地址管理机构在分配 IP 地址时只分配网络号，而主机号由单位自行分配。第二，路由器仅<strong>根据目的主机所连接的网络号来转发分组</strong>，这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间以及查找路由表的时间。</li><li>实际上 IP 地址是标志一台主机（或路由器）和一条链路的<strong>接口</strong>。当一台主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号必须是不同的。这种主机称为<strong>多归属主机</strong>（multihomed host）。<strong>由于一个路由器至少应当连接到两个网络，因此一个路由器至少应当有两个不同的 IP 地址</strong>。</li><li>按照互联网的观点，一个网络是指具有相同网络号的主机的集合。因此，用转发器或网桥连接起来的若干个局域网仍为一个网络。具有不同网络号的局域网必须使用路由器进行连接。</li><li>在 IP 地址中，所有分配到网络号的网络都是<strong>平等</strong>的。所谓平等，只是互联网同等对待每一个 IP 地址。</li></ol><h2 id="ip-地址和硬件地址">IP 地址和硬件地址</h2><p>硬件地址（物理地址，MAC 地址）是数据链路层和物理层使用的地址，而 IP 地址是网络层和以上各层使用的地址，是一种逻辑地址，是用软件实现的。</p><p><img src="/uploads/image/computer-networking/ip-address-and-hardware-address.jpeg"></p><p>路由器同时连接到两个网络上时，必须具有两个不同的 IP 地址，也要有两个硬件地址。</p><p>在网络层只能看到 IP 数据报，数据报被转发时，首部中的源地址和目的地址始终不变。在链路层只能看到 MAC 帧，IP 数据报被封装在 MAC 帧中。MAC 帧在不同的网络上传送时，其首部中的源地址和目的地址要发生变化。</p><h2 id="地址解析协议-arp">地址解析协议 ARP</h2><p>由于是 IP 地址使用了 ARP 协议，因此通常就把 ARP 协议划归网络层。</p><p>每一台主机都设有一个 ARP 高速缓存，里面有<strong>本局域网</strong>上的各主机和路由器的 IP 地址到硬件地址的映射表。注意，ARP 是解决同一个局域网上的主机和路由器的 IP 地址和硬件地址的映射问题。主机不需要知道远程主机的硬件地址，只需要知道它的 IP 地址。IP 数据报通过连在同一个局域网的路由器来转发，最终到达目标网络的路由器上，再用类似方法解析出目的主机的硬件地址并交付。</p><p>当主机 A 要向<strong>本局域网</strong>上的主机 B 发送 IP 数据报时，先在 ARP 高速缓存中查看有无主机 B 的 IP 地址。如有，就查出其对应的硬件地址，再把这个硬件地址写入 MAC 帧，然后通过局域网发送该 MAC 帧。若无，主机 A 按以下步骤找出主机 B 的硬件地址。</p><ol type="1"><li>在本局域网上<strong>广播</strong>发送一个 ARP 请求分组，主要内容是：“我的 IP 地址是 ... 硬件地址是 ... 我想知道 IP 地址为 .. 的主机的硬件地址。“</li><li>在本局域网上的所有主机都收到此 ARP 请求分组。若主机的 IP 地址与 ARP 请求分组中要查询的 IP 地址不一致，就不理睬这个请求分组。（也有可能理睬一下，更新自己的 ARP 缓存，写入主机 A 的 IP 地址和硬件地址）</li><li>主机 B 的 IP 地址与请求分组中要查询的 IP 地址一致，就收下这个请求分组（同时更新 ARP 缓存写入主机 A 的 IP 地址和硬件地址），并向主机 A 发送 ARP 响应分组（<strong>单播</strong>），在这个响应分组中写入自己的硬件地址。</li><li>主机 A 收到响应分组后，就在其 ARP 高速缓存中写入主机 B 的 IP 地址到硬件地址的映射。</li></ol><p>ARP 对保存在高速缓存中的每一个映射地址都设置<strong>生存时间</strong>。当硬件地址发生改变时，能通过 ARP 再次查询新的地址。</p><h2 id="ip-数据报的格式">IP 数据报的格式</h2><p><img src="/uploads/image/computer-networking/ip-header.jpeg"></p><ul><li>版本：4（IPv4）或 6（IPv6）</li><li>首部长度：单位是 4 字节，因此最小值是 5（只有固定首部，没有数据），最大值 15，即 60 字节。当首部长度不是 4 字节的整数倍时，必须利用填充字段加以填充（全 0）。</li><li><p>总长度：单位是字节，因此数据报的最大长度为 2^16 - 1 = 65535 字节。然而传送这样长的数据报在现实中极少遇到。IP 层下面的每一种数据链路层协议都规定了一个数据帧中的<strong>数据字段的最大长度</strong>，称为<strong>最大传送单元</strong> MTU（Maximum Transfer Unit）。当一个 IP 数据报封装成链路层的帧时，总长度不能超过 MTU，否则必须把过长的数据报进行分片处理。</p><p>使用尽可能长的 IP 数据报会使传输效率得到提高，但数据报短些也有好处。每一个 IP 数据报越短，路由器转发的速度就越快。为此， IP 协议规定，在互联网中所有的主机和路由器，必须能够接受长度不超过 576 字节的数据报。这是假定上层交下来的数据长度有 512 字节（合理的长度），加上最长的 IP 首部 60 字节，再加上 4 字节的富余量，就得到 576 字节。当主机需要发送长度超过 576 字节的数据报时，应当先了解一下，目的主机能否接受所要发送的数据报长度。否则，就要进行分片。</p></li><li><p>标识、标志、片偏移：这三个字段与分片有关。</p><p>标识：IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加 1，并将此值赋给标识字段。</p><p>标志：MF（More Fragment），MF = 1 表示后面还有分片的数据报。MF = 0 表示这已经是最后一个分片。DF（Don't Fragment），DF = 1 表示不要分片。只有当 DF = 0 时才允许分片。</p><p>片偏移：以 8 个字节为偏移单位。也就是说，每个分片的长度一定是 8 字节的整数倍。</p><table><thead><tr class="header"><th></th><th>总长度（20 字节首部）</th><th>标识</th><th>MF</th><th>DF</th><th>片偏移</th></tr></thead><tbody><tr class="odd"><td>原始数据报</td><td>3820</td><td>12345</td><td>0</td><td>0</td><td>0</td></tr><tr class="even"><td>数据报片 1</td><td>1420</td><td>12345</td><td>1</td><td>0</td><td>0</td></tr><tr class="odd"><td>数据报片 2</td><td>1420</td><td>12345</td><td>1</td><td>0</td><td>175</td></tr><tr class="even"><td>数据报片 3</td><td>1020</td><td>12345</td><td>0</td><td>0</td><td>350</td></tr></tbody></table></li><li>生存时间：TTL（Time To Live），现在指<strong>跳数</strong>，表明数据报在网络中的寿命，防止无法交付的数据报无限制地在互联网中兜圈子。若 TTL = 1，就表示这个数据报只能在本局域网中传送。</li><li><p>协议：指出此数据报携带的数据是使用何种协议，以便使目的主机的 IP 层知道应将数据部分上交给哪个协议进行处理。</p><table><thead><tr class="header"><th>协议名</th><th>ICMP</th><th>IGMP</th><th>IP</th><th>TCP</th><th>EGP</th><th>IGP</th><th>UDP</th><th>IPv6</th><th>ESP</th><th>OSPF</th></tr></thead><tbody><tr class="odd"><td>协议字段值</td><td>1</td><td>2</td><td>4</td><td>6</td><td>8</td><td>9</td><td>17</td><td>41</td><td>50</td><td>89</td></tr></tbody></table></li><li><p>首部检验和：只检验数据报首部，数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化）。</p><p><img src="/uploads/image/computer-networking/ip-header-validation.jpeg"></p></li></ul><h2 id="转发分组的流程">转发分组的流程</h2><p>在互联网上转发分组时，是从一个路由器转发到下一个路由器。</p><p>在路由表中，对每一条路由最重要的是以下两个信息：(目的网络地址，下一跳地址)</p><p>虽然互联网所有的分组转发都是<strong>基于目的主机所在的网络</strong>*，但在大多数情况下都允许有这样的特例，即对特定的目的主机指明一个路由。这种路由叫做<strong>特定主机路由</strong>。采用特定主机路由可使网络管理人员更<strong>方便地控制网络和测试网络</strong>（对网络的连接或路由表进行排错），同时也可在需要<strong>考虑某种安全问题</strong>时采用这种特定主机路由。</p><p>路由器还可采用<strong>默认路由</strong>（default route）以减小路由表所占用的空间和搜索路由表所用的时间。这种转发方式在一个网络只有很少的对外连接时是很有用的。主机在发送每一个 IP 数据报时都要查找自己的路由表，如果一台主机连接在一个小网络上，而这个网络只用一个路由器和互联网连接，那么在这种情况下使用默认路由是非常合适的。</p><p><img src="/uploads/image/computer-networking/ip-default-route.jpeg"></p><p>IP 数据报中没有下一跳路由器的 IP 地址，那么待转发的数据报怎样能够找到下一跳路由器呢？</p><p>当路由器收到一个待转发的数据报，从路由表中得出下一跳路由器的 IP 地址后，不是把这个地址填入 IP 数据报，而是<strong>送交数据链路层的网络接口软件</strong>。网络接口软件负责把下一跳路由器的 IP 地址转换成硬件地址（使用 ARP），并将此硬件地址放在链路层的 MAC 帧的首部，然后根据这个硬件地址找到下一跳路由器。</p><p>分组转发算法如下：</p><ol type="1"><li>从数据报首部提取目的主机的 IP 地址 D，得出目的网络地址 N。</li><li>若网络 N 与此路由器直接相连，则进行<strong>直接交付</strong>，把数据报交付目的主机（查找 D 的硬件地址，封装 MAC 帧，发送）。否则就是<strong>间接交付</strong>。</li><li>若路由表中有 D 的特定主机路由，则交付特定路由指明的下一跳路由器。</li><li>若路由表中有 N 的路由，交付给指定的下一跳路由器。</li><li>若路由表中有 默认路由，交付给默认路由器。</li><li>否则，报告转发分组出错。</li></ol><h1 id="划分子网">划分子网</h1><h2 id="从两级-ip-到三级-ip">从两级 IP 到三级 IP</h2><ol type="1"><li>IP 地址空间的利用率有时很低。有的单位申请到了一个 B 类地址，但所连接的主机数并不多，可是又不愿意申请一个足够使用的 C 类地址，理由是考虑到今后可能的扩展。IP 地址的浪费，使 IP 地址空间的资源过早地被用完。</li><li>给每一个物理网络分配一个网络号会<strong>使路由表变得太大</strong>（需要更多的存储空间）因而使网络性能变坏（查找路由耗费更多的时间）。</li><li>两级 IP 地址不够灵活。一个单位需要在新的地点开通一个新的网络。但是在申请到一个新的 IP 地址之前，新增加的网络是不可能连接到互联网上工作的。我们希望有一种方法，使一个单位能随时灵活地增加本单位的网络，而不必去申请新的网络号。</li></ol><p>为解决上述问题，从 1985 年起在 IP 地址中又增加了一个“子网号字段”，使两级 IP 地址变为三级 IP 地址（网络号，子网号，主机号）。子网号是从原来的主机号借用若干位，而原来的主机号相应减少了同样的位数。</p><p>从其他网络发送给本网络某台主机的 IP 数据报，仍然是根据<strong>网络号</strong>找到连接在本网络上的路由器。但此路由器在收到 IP 数据报后，再按<strong>子网号</strong>找到目的子网，交付目的主机（子网与该路由器直接相连）或与子网连接的路由器。</p><h2 id="子网掩码">子网掩码</h2><p>现在剩下的问题是，路由器无法看出子网号有几位。IP 地址本身以及数据报首部都没有关于子网划分的信息。因此必须另外想办法，这就是使用子网掩码（subnet mask）。</p><p><img src="/uploads/image/computer-networking/ip-subnet-mask.jpeg"></p><p>虽然没有规定子网掩码中的一串 1 必须是连续的，但却极力推荐在子网掩码中选用连续的 1，以免出现差错。</p><p>使用子网掩码的好处是：不管网络有没有划分子网，只要把子网掩码和 IP 地址进行“与”运算，就立即得出网络地址来。这样在路由器处理到来的分组时就可采用同样的算法。</p><p>现在互联网的标准规定：所有的网络都必须使用子网掩码（便于查找路由表），同时<strong>在路由器的路由表中也必须有子网掩码这一栏</strong>。如果一个网络不划分子网，那么该网络的子网掩码就使用默认子网掩码。默认子网掩码中 1 的位置和 IP 地址中的网络号字段正好相对应。A 类：255.0.0.0。 B 类：255.255.0.0。 C 类：255.255.255.0。</p><p>路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。在路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。若一个路由器连接在两个子网上就拥有两个网络地址和两个子网掩码。</p><p>划分子网增加了灵活性，但却减少了网络上能连接的最大主机总数。</p><h2 id="使用子网时分组的转发">使用子网时分组的转发</h2><p>使用子网后，路由表必须包含以下三项内容：（目的网络地址，子网掩码，下一跳地址）。</p><ol type="1"><li>从收到的数据报首部提取目的 IP 地址 D。</li><li>判断是否可以直接交付：对路由器直接连接的网络逐个进行检查，用各网络的子网掩码和 D 相与，看结果是否和相应的网络地址匹配。若匹配，则直接交付（查找物理地址，封装成帧，发送）。否则是间接交付。</li><li>若有目的地址为 D 的特定主机路由，交付下一跳路由。</li><li>对路由表中每一行，用 D 与子网掩码相与，其结果为 N。若 N 与目的网络地址匹配，交付下一跳路由器。</li><li>若有默认路由，交付默认路由器。</li><li>报告转发分组出错。</li></ol><h1 id="无分类编址构造超网">无分类编址（构造超网）</h1><h2 id="网络前缀">网络前缀</h2><p>无分类域间路由选择 CIDR（Classless Inter-Domain Routing，读音是 “sider”）最主要的特点有两个：</p><ol type="1"><li><p>CIDR 消除了传统的 A、B、C 类地址以及划分子网的概念，能更加有效地分配 IPv4 的地址空间。</p><p>CIDR 使 IP 地址又回到了两级编址：（网络前缀，主机号）。</p><p>CIDR 使用斜线记法，在 IP 地址后面加上斜线 “/”，然后写上网络前缀所占的位数。</p></li><li><p>CIDR 把网络前缀都相同的连续的 IP 地址组成一个“CIDR 地址块”。只要知道地址块中的任何一个地址，就可以知道这个地址块的起始地址（即最小地址）和最大地址，以及地址块中的地址数。</p><p>例如，128.14.35.7/20，前 20 位是网络前缀，即子网掩码的前 20 位是 1，后 16 位是 0。</p><p>128.14.35.7/20 = <u>10000000 00001110 0010</u>0011 00000111</p><p>最小地址：128.14.32.0 = <u>10000000 00001110 0010</u>0000 00000000</p><p>最大地址：128.14.47.255 = <u>10000000 00001110 0010</u>1111 11111111</p><p>当然，一般并不使用以上这两个特殊的主机号。上面的地址块可记为 128.14.32.0/20。</p></li></ol><p>“CIDR 不使用子网”是指 CIDR 并没有在 32 位地址中指明若干位作为子网字段。但分配到一个 CIDR 地址块的单位，仍然可以根据需要划分出一些子网。这些子网也都只有一个网络前缀和一个主机号，但子网的网络前缀比地址块的网络前缀要长些。</p><p>由于一个 CIDR 地址块中有很多地址，所以在路由表中就利用 CIDR 地址块来查找目的网络。这种地址的聚合常称为<strong>路由聚合</strong>（route aggregation），它使得路由表中的一个项目可以表示传统分类地址的很多个路由。</p><p>常用的 CIDR 地址块</p><table><colgroup><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"></colgroup><thead><tr class="header"><th>CIDR 前缀长度</th><th>点分十进制</th><th>包含的地址数</th><th>相当于</th></tr></thead><tbody><tr class="odd"><td>/13</td><td>255.248.0.0</td><td>512 K ~ 2^(32 - 13) 个</td><td>8 个 B 类（2^16 个地址）或 2048 个 C 类（2^8 个地址）</td></tr><tr class="even"><td>/14</td><td>255.252.0.0</td><td>256 K</td><td>4 个 B 类或 1024 个 C 类</td></tr><tr class="odd"><td>...</td><td>...</td><td>...</td><td>...</td></tr><tr class="even"><td>/23</td><td>255.255.254.0</td><td>512</td><td>2 个 C 类</td></tr><tr class="odd"><td>/24</td><td>255.255.255.0</td><td>256</td><td>1 个 C 类</td></tr><tr class="even"><td>/25</td><td>255.255.255.128</td><td>128</td><td>1/2 个 C 类</td></tr><tr class="odd"><td>/26</td><td>255.255.255.192</td><td>64</td><td>1/4 个 C 类</td></tr><tr class="even"><td>/27</td><td>255.255.255.224</td><td>32</td><td>1/8 个 C 类</td></tr></tbody></table><p>路由聚合也称为<strong>构成超网</strong>（supernetting）。除最后几行外，CIDR 地址块都包含了多个 C 类地址，这就是“构成超网”这一名次的来源。</p><p>使用 CIDR 的一个好处就是可以更加有效地分配 IPv4 的地址空间，可根据客户的需要分配适当大小的地址块。而在分类地址中，只能以 /8（A 类），/16（B 类），/24（C 类）来分配，很不灵活。</p><h2 id="最长前缀匹配">最长前缀匹配</h2><p>在使用 CIDR 时，查找路由表时可能会得到不止一个匹配结果，<strong>应当从匹配结果中选择具有最长网络前缀的路由</strong>。这叫做<strong>最长前缀匹配</strong>（longest-perfix matching）。因为网络前缀越长，路由就越具体。</p><p>例如，路由表中有以下两个项目：206.0.68.0/22 和 206.0.71.128/25。现在假定收到一个数据报，其目的 IP 地址为 D=206.0.71.130。D 与这两个目的网络都匹配，根据最长前缀匹配，应当选择后者。因为 206.0.71.128/25 是 206.0.68.0/22 的子网，它更具体。</p><p>采用 CIDR，我们可以按照网络所在的地理位置来分配地址块，这样就可大大减少路由表中的路由项目。例如，可以将世界划分为四大地区，每一地区分配一个 CIDR 地址块：</p><ul><li>地址块 194/7（194.0.0.0 至 195.255.255.255）分配给欧洲。</li><li>地址块 198/7（198.0.0.0 至 199.255.255.255）分配给北美洲。</li><li>地址块 200/7（200.0.0.0 至 201.255.255.255）分配给中美洲和南美洲。</li><li>地址块 202/7（202.0.0.0 至 203.255.255.255）分配给亚洲和太平洋地区。</li></ul><p>上面的每一个地址块包含约 3200 万个地址。凡是发往北美的 IP 数据报（目的 IP 地址的前 7 位是十进制 194）都先送交位于美国的一个路由器，因此在路由表中使用一个项目就行了。</p><h2 id="使用二叉线索查找路由">使用二叉线索查找路由</h2><p>使用 CIDR 后，由于要寻找最长前缀匹配，使路由表的查找过程变得更加复杂了。为了进行更加有效的查找，通常是把无分类编址的路由表放在一种层次的数据结构中，然后自上而下地按层次进行查找。这里最常用的就是<strong>二叉线索</strong>（binary trie），它是一种特殊结构的树。IP 地址中从左到后的比特值决定了从根节点逐层向下层延伸的路径。</p><p>为了简化二叉线索的结构，可以先找出对应与每一个 IP 地址的<strong>唯一前缀</strong>（unique prefix）。所谓唯一前缀就是在表中所有的 IP 地址中，该前缀是唯一的。进行查找时，只要能够和唯一前缀相匹配就行了。</p><p><img src="/uploads/image/computer-networking/ip-binary-trie.jpeg"></p><p>由于唯一前缀一般都小于 32 位，因此用唯一前缀构造的二叉线索的深度往往不到 32 层。二叉线索的每个叶节点代表一个唯一前缀。例如有一个地址是 10011011 ...，需要查找该地址是否在此二叉线索中。从左边开始查起，查到第三个字符时，找不到匹配的，说明这个地址不在这个二叉线索中。</p><p>目的地址<strong>与某一前缀匹配不意味着一定与网络前缀匹配</strong>。要将二叉线索用于路由表中，还必须使每一个叶节点包含所对应的网络前缀和子网掩码。当搜索到一个叶节点时，就必须将目的地址和子网掩码进行“与”运算，看结果是否与对应的网络前缀相匹配。若匹配，就按下一跳的接口转发分组。否则，就丢弃该分组。</p><p>为了提高二叉线索的查找速度，广泛使用了各种<strong>压缩技术</strong>。例如，图中的最后两个地址，其最前面 4 位都是 1011.因此，只要有一个地址的前 4 位是 1011，就可以跳过前面 4 位（即压缩了 4 个层次）而直接从第 5 位开始比较。当然，制作经过压缩的二叉线索需要更多的计算，但由于每一次查找路由时都可以提高查找速度，这样做还是值得的。</p><h1 id="网际控制报文协议-icmp">网际控制报文协议 ICMP</h1><p>为了更有效地转发 IP 数据报和提高交付成功的机会，在网际层使用了 网际控制报文协议 ICMP（Internet Control Message Protocol）。ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。</p><p>ICMP 报文是<strong>封在 IP 数据报</strong>中，作为其中的数据部分。看起来像高层协议，其实不是，而是 IP 层的协议。</p><p>ICMP 报文有两种：<strong>ICMP 差错报告报文</strong> 和 <strong>ICMP 询问报文</strong>。</p><p>ICMP 报文的前 4 个字节是统一的格式，类型（1）、代码（1）和检验和（2）。接着的 4 个字节的内容与 ICMP 的类型有关。最后面是数据字段。</p><table><tr><th>ICMP 报文种类</th><th>类型的值</th><th>类型</th></tr><tr><td rowspan="4">差错报告控制报文</td><td>3</td><td>终点不可达</td></tr><tr><td>11</td><td>时间超过</td></tr><tr><td>12</td><td>参数问题</td></tr><tr><td>5</td><td>改变路由（Redirect）</td></tr><tr><td rowspan="2">询问报文</td><td>8 或 0</td><td>回送（Echo）请求或回答</td></tr><tr><td>13 或 14</td><td>时间戳（Timestamp）请求或回答</td></tr></table><h2 id="差错报告报文">差错报告报文</h2><ul><li>终点不可达：当路由器或主机不能交付数据报时，向源点发送此报文。</li><li>时间超过：当路由器收到生存时间为零的数据报时，除丢弃该数据报以外，还要向源点发送此报文。当终点在规定时间内不能收到一个数据报的全部数据报片时，就把已收到的都丢弃，并向源点发送此报文。</li><li>参数问题：当路由器或主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送此报文。</li><li><p>改变路由：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）。</p><p>在互联网的主机中也要有一个路由表。当主机要发送数据报时，首先要查找主机自己的路由表，看应当从哪一个接口把数据报发送出去。在互联网中，主机的数量远大于路由器的数量，出于效率的考虑，这些主机不和路由器定期交换路由信息。在主机刚开始工作时，一般都在路由表中设置一个默认路由器的 IP 地址。这个默认路由器（通过和其他路由器交换路由信息）知道到每一个目的地址的最佳路由。如果默认路由器发现主机发往某个目的地址的数据报的最佳路由应当经过网络上的另一个路由器时，就用改变路由报文把这情况告诉主机。于是，该主机就在其路由表中增加一个项目：到某目的地址应经过某路由器（而不是默认路由器）。</p></li></ul><p>所有的 ICMP 差错报告报文中的数据字段都具有同样的格式。</p><p><img src="/uploads/image/computer-networking/icmp-data.jpeg"></p><p>提取收到的数据报的数据字节的前 8 个字节（TCP 或 UDP 的首部的前 8 个字节）是为了得到运输层的端口号（对于 TCP 和 UDP）以及运输层报文的发送序号（对于 TCP）。整个 ICMP 报文作为 IP 数据报的数据字段发送给源点。</p><p>下面是不应该发送 ICMP 差错报告报文的几种情况。</p><ul><li>对 ICMP 差错报告报文，不再发送 ICMP 差错报告报文。</li><li>对第一个分片的数据报片的所有后续数据报片，都不发送。</li><li>对具有多播地址的数据报，都不发送。</li><li>对具有特殊地址（如 127.0.0.0 或 0.0.0.0）的数据报，不发送。</li></ul><h2 id="询问报文">询问报文</h2><ul><li>回送请求和回答：由主机或路由器向一个特定的目的主机发出询问，收到此报文的主机必须给源主机或路由器发送 ICMP 回送回答报文。这种询问报文用来<strong>测试目的站是否可达</strong>以及<strong>了解有关状态</strong>。</li><li>时间戳请求和回答：请某台主机或路由器回答当前的日期和时间。可用于时钟同步和时间测量。</li></ul><h2 id="icmp-应用举例">ICMP 应用举例</h2><ul><li><p>分组网间探测 PING（Packet InterNet Groper），用来测试两台主机之间的连通性。</p><p>PING 使用 ICMP 回送请求和回送回答报文（<strong>ICMP 询问报文</strong>）。<strong>PING 是应用层直接使用网络层 ICMP 的一个例子。它没有通过运输层的 TCP 或 UDP</strong>。</p></li><li><p>traceroute（这是 UNIX 操作系统中的名字）或 tracert（Windows 操作系统中的名字），用来跟踪一个分组从源点到终点的路径。</p><p>traceroute 从源主机向目的主机发送一连串的 IP 数据报，数据报中<strong>封装的是无法交付（使用了非法的端口）的 UDP 用户数据报</strong>。第一个数据报的生存时间 TTL 设置为 1。路由器收下后把 TTL 的值减 1，由于 TTL 等于 0 了，就丢弃报文并向源主机发送一个 <strong>ICMP 时间超过</strong>差错报告报文。</p><p>源主机接着发送第二个数据报，并把 TTL 设置为 2 ... 这样一直继续下去，当最后一个数据报刚刚到达目的主机时，数据报的 TTL 是 1。主机不转发数据报，但因 IP 数据报中封装的是无法交付的 UDP 用户数据报，因此目的主机要向源点发送 <strong>ICMP 终点不可达</strong>差错报告报文。</p></li></ul><h1 id="路由选择协议">路由选择协议</h1><p>路由表中的路由（行）是怎样得出的。</p><h2 id="理想的路由算法">理想的路由算法</h2><ol type="1"><li>正确性和完整性。正确的含义是：沿着各路由表所指引的路由，分组一定能够最终到达目的网络和目的主机。</li><li>计算上应简单，不应使网络增加太多的额外开销。</li><li>自适应性，能适应通信量和网络拓扑的变化。也称稳健性（robustness）。</li><li>稳定性，算法应收敛于一个可以接受的解，而不应使得路由不停地变化。</li><li>公平性，对所有用户（除对少数优先级高的用户）都是平等的。</li><li>最佳的，使得分组平均时延最小而网络的吞吐量最大。虽然我们希望得到”最佳“的算法，但这并不总是最重要的。对于某些网络，网络的可靠性有时要比最小的分组平均时延或最大吞吐量更加重要。因此，所谓最佳只能是相对于某一种特定要求下得出的较为合理的选择而已。</li></ol><p>若从路由算法能否虽网络的通信量或拓扑自适应地进行调整来区分，则只有两大类：</p><ul><li>静态路由选择策略，也叫做非自适应路由选择。其特点是简单和开销小，但不能及时适应网络状态的变化。对于很简单的小网络，完全可以采用静态路由选择，用人工配置每一条路由。</li><li>动态路由选择策略，也叫做自适应路由选择。其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。因此，动态路由选择适用于较复杂的大网络。</li></ul><h2 id="分层次的路由选择协议">分层次的路由选择协议</h2><p>互联网采用的主要是<strong>自适应的、分布式</strong>路由选择协议。而采用分层次的路由选择协议有以下两个原因：</p><ol type="1"><li>互联网的规模非常大。如果让所有的路由器知道所有的网络应怎样到达，则这种路由表将非常大，处理起来也太花时间。而所有这些路由器之间交换路由信息所需的带宽就会使互联网的通信链路饱和。</li><li>许多单位不愿意外界了解自己单位网络的布局细节和本部门所采用的路由选择协议，但同时还希望连接到互联网上。</li></ol><p>为此，可以把整个互联网划分为许多较小的<strong>自治系统</strong> AS（autonomous system）。AS 是在单一技术管理下的一组路由器，这些路由器使用一种自治系统内部的路由选择协议和共同的度量。一个 AS 对其他 AS 表现出的是<strong>一个单一的和一致的路由选择策略</strong>。</p><p>互联网把路由选择协议划分为两大类：</p><ol type="1"><li><strong>内部网关协议</strong> IGP（Interior Gateway Protocol） 即在一个自治系统内部使用的路由选择协议。目前这类路由选择协议使用得最多，如 RIP 和 OSPF 协议。</li><li><strong>外部网关协议</strong> EGP（External Gateway Protocol） 若源主机和目的主机处在不同的自治系统中（这两个自治系统可能使用不同的内部网关协议），当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。目前使用最多的外部网关协议是 BGP-4（BGP的版本 4）。</li></ol><p>每个自治系统自己决定在本自治系统内部运行哪一个内部路由选择协议（RIP 或 OSPF）。但每个自治系统都有一个或多个路由器除运行本系统的内部路由选择协议之外，还要运行自治系统间的路由选择协议（BGP-4）。</p><p>网关是旧称，就是网络层的路由器。因此有的书把 IGP 和 EGP 分别改为 IRP 和 ERP。</p><h2 id="内部网关协议-rip">内部网关协议 RIP</h2><p>RIP（Routing Information Protocol）是内部网关协议 IGP 中最先得到广泛使用的协议。RIP 是一种<strong>分布式的基于距离向量</strong>的路由选择协议，其最大的优点是<strong>简单</strong>。</p><p>RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录（因此，这是一组距离，即“距离向量”）。RIP 协议的“距离”也称“跳数”（hop count），因为每经过一个路由器，跳数就加 1。RIP 认为好的路由就是它通过的路由器的数目少，即“距离短”。RIP 允许一条路径最多只能包含 15 个路由器，因此“距离”等于 16 时即相当于不可达。可见 RIP 只适用于小型互联网。</p><p>RIP 不能在两个网络之间使用多条路由。RIP 选择一条具有最少路由器的路由，哪怕还存在另一条高速（低时延）但路由器较多的路由。</p><p>我们一定要弄清以下三个要点，即<strong>和哪些路由器交换信息？交换什么信息？在什么时候交换</strong>？</p><p>RIP 协议的特点是：</p><ol type="1"><li>仅和相邻路由器交换信息。如果两个路由器之间的通信不需要经过另一个路由器，那么这两个路由器就是相邻的。不相邻的路由器不交换信息。</li><li>交换的信息是当前本路由器所知道的全部信息，即自己现在的路由表。</li><li>按固定的时间间隔交换路由信息。例如，每隔 30 秒。</li></ol><h3 id="距离向量算法">距离向量算法</h3><p>距离向量算法的基础是 Bellman-Ford 算法，原理是最短路径具有最优子结构性质。</p><p>对每一个相邻路由器发送过来的 RIP 报文，进行以下步骤。</p><ol type="1"><li><p>对地址为 X 的相邻路由器发来的 RIP 报文，先修改此报文中的所有项目：把“下一跳”字段中的地址都改为 X，并把所有的“距离”字段的值都加 1。修改后每一个项目都由三个关键数据，即：目的网络 N，距离 d，下一跳路由器 X。（即 X 把它的路由表传给我了，我要比较我的路由表和它的路由表，看看应该按我的路由表传，还是它的。这一步的修改动作就是为接下来的比较做准备，N 是目的网络，d 就是我把分组传给 X 再由 X 续传到 N 的总距离）</p></li><li><p>对修改后的每一个项目，进行以下步骤：</p>若路由表中没有目的网络 N，添加该项目到路由表中。否则，路由表中有网络 N，就要比较距离了：<ul><li>若下一跳路由器地址也是 X，则更新距离 d。（注意，是更新。因为网络的距离是可能发生变化的，要以最新的消息为准）</li><li>若下一跳路由器的地址不是 X，则保留距离较小的那一项。</li></ul></li><li><p>若 3 分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达路由器，即把距离置为 16。</p></li></ol><h3 id="rip-协议的报文格式">RIP 协议的报文格式</h3><p>下图是 RIP2（版本 2）的报文格式。</p><p><img src="/uploads/image/computer-networking/rip-header.jpeg"></p><p>RIP 协议使用运输层的 UDP 进行传送，使用的端口是 520。命令字段指出报文的意义。例如， 1 表示请求路由信息，2 表示对 1 的响应或主动发出的路由更新报文。首部的“必为 0”是填充字段，为了 4 字节的对齐。</p><p>RIP2 具有简单的鉴别功能。若使用鉴别功能，则将原来写入第一个路由信息的位置用作鉴别。这时应将地址族标识符置为全 1，而路由标记写入鉴别类型，剩下的 16 字节为鉴别数据。在鉴别数据之后才写入路由信息，但这时最多只能再放入 24 个路由信息。</p><p>RIP 存在的一个问题是<strong>当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器</strong>。举个简单的例子，</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">N1 ----- R1 ------------ R2 ----- N2</span><br><span class="line">    N1, 1, 直接       N1, 2, R1</span><br><span class="line"></span><br><span class="line">N1 -xxx- R1 ------------ R2 ----- N2</span><br><span class="line">    N1, 16, 直接      N1, 2, R1</span><br></pre></td></tr></table></figure><p>现在假定 R1 到 N1 的链路除了故障。于是 R1 更新自己的路由表为 N1, 16, 直接。但是，很可能要经过 30 秒后才把更新后的信息发给 R2。（这么憨的吗？不能立即发送吗？）然而，R1 在发送之前收到了来自 R2 的更新信息。根据算法，R1 需要更新自己的路由为 N1, 2, R2。即 R1 误以为可以通过 R2 将到达 N1。R1 经过一段时间，将 N1, 2, R2 发送给 R2，R2 根据算法将自己的路由表更新为 N1, 3, R1。（你也这么憨的吗？更新前不看看发来的路由的下一跳就是自己）……这样的更新一直持续下去，直到距离增大到 16 为止，R1 和 R2 才知道 N1 是不可达的。RIP 协议的这一特点叫做：<strong>好消息传播得快，而坏消息传播得慢。</strong>但如果一个路由器发现了更短的路由，那么这种更新信息就传播得很快。</p><p>总之，RIP 协议最大的优点就是<strong>实现简单，开销较小</strong>。但缺点也很多。</p><ul><li>首先，RIP 限制了网络的规模，它能使用的最大距离为 15。</li><li>其次，路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</li><li>最后，坏消息传播得慢，使更新过程的收敛时间过长。</li></ul><p>因此，对于规模较大的网络就应当使用 OSPF 协议。然而目前在规模较小的网络中，使用 RIP 协议的仍占多数。</p><h2 id="内部网关协议-ospf">内部网关协议 OSPF</h2><p>这个协议的名字是<strong>开放最短路径优先</strong> OSPF（Open Shortest Path First），是为了克服 RIP 的缺点被开发出来的。”开放“指的是 OSPF 协议不是受某一家厂商控制，而是公开发表的。”最短路径优先“是因为使用了 Dijkstra 提出的<strong>最短路径算法</strong>。请注意：OSPF 只是一个协议的名字，并不表示其他的路由选择协议不是”最短路径优先“。实际上，所有的在自治系统内部使用的路由选择协议都是要寻找一条最短的路径。</p><p>OSPF 最主要的特征就是使用分布式的<strong>链路状态协议</strong>（link state protocol），而不是像 RIP 那样的距离向量协议。OSPF 协议的三个要点和 RIP 的都不一样：</p><ol type="1"><li>向本自治系统中<strong>所有路由器</strong>发送信息。使用的是<strong>洪泛法</strong>（flooding）：路由器通过所有输出端口向所有相邻的路由器发送信息。而每一个相邻的路由器又再将此信息发往其所有的相邻路由器（但不发给发来信息的那个路由器）。这样，最终整个区域中所有的路由器都得到了这个信息的一个副本。</li><li>发送的信息是<strong>与本路由器相邻的所有路由器的链路状态</strong>，但这只是路由器所知道的<strong>部分信息</strong>。所谓链路状态就是说明本路由器和哪些路由器相邻，以及该链路的<strong>度量</strong>（metric）。度量（费用、距离、时延、带宽等等）由网络管理人员来决定，因此较为灵活。</li><li>只有当链路状态<strong>发生变化</strong>时，路由器才向所有路由器用洪泛法发送此信息。</li></ol><h3 id="关于-rip-和-ospf-三个要点的总结">关于 RIP 和 OSPF 三个要点的总结</h3><table><colgroup><col style="width: 33%"><col style="width: 33%"><col style="width: 33%"></colgroup><thead><tr class="header"><th></th><th>RIP</th><th>OSPF</th></tr></thead><tbody><tr class="odd"><td>向谁发送？</td><td>相邻路由器</td><td>全部路由器（洪泛法，可以看做递归式地向相邻路由器发送）</td></tr><tr class="even"><td>发送什么？</td><td>本路由器的路由表（本路由器知道的全部信息）</td><td>与本路由器相邻的路由器的链路状态（本路由器知道的部分信息），链路状态可以等效看作是自定义的路由表的表项</td></tr><tr class="odd"><td>何时发送？</td><td>定期发送（如 30 秒）</td><td>链路状态发生变化时发送</td></tr></tbody></table><p>所有的路由器最终都能建立一个<strong>链路状态数据库</strong>（link-state database），这个数据库实际上就是<strong>全网的拓扑结构图</strong>。这个拓扑结构图在全网范围内是一致的（这称为链路状态数据库的同步）。每一个路由器使用链路状态数据库，构造出自己的路由表（例如，使用 Dijkstra 的最短路径路由算法）。</p><p>OSPF 的链路状态数据库能较快地进行更新，<strong>更新过程收敛得快</strong>是其重要优点。</p><h3 id="ospf-的区域划分">OSPF 的区域划分</h3><p>为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的范围，叫做<strong>区域</strong>（area），每一个区域都由一个 32 位的区域标识符（用点分十进制表示，和 IPv4 类似，但不是 IPv4）。一个区域不能太大，在一个区域内的路由器最好不超过 200 个。划分区域的好处是<strong>把利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统</strong>，这就减少了整个网络上的通信量。在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况。</p><p>为了使每一个区域能够和本区域以外的区域进行通信，OSPF 使用<strong>层次结构的区域划分</strong>。在上层的区域叫做<strong>主干区域</strong>（backbone area），标识符规定为 0.0.0.0。主干区域的作用是连通其他在下层的区域。在主干区域内的路由器叫做<strong>主干路由器</strong>（backbone router）。同时连接主干区域和其他区域的路由器叫做<strong>区域边界路由器</strong>（area border router）。主干区域内还要有一个路由器专门和本自治系统以外的的其他自治系统交换路由信息。这样的路由器叫做<strong>自治系统边界路由器</strong>。</p><p>采用分层次划分区域的方法，</p><ul><li>缺点是，使交换信息的种类增多了，同时也使 OSPF 协议更加复杂了。</li><li>优点是，使每一个区域内部交换路由信息的通信量大大减小，因而能用于规模很大的自治系统中。</li></ul><h3 id="ospf-协议的报文格式">OSPF 协议的报文格式</h3><p>OSPF 不用 UDP 而是<strong>直接用 IP 数据报传送</strong>，这样做可减少路由信息的通信量。数据报短的另一个好处是，可以不必将长的数据报分片传送。分片传送的数据报只要丢失一个，就无法组装成原来的数据报，而整个数据报就必须重传。</p><p><img src="/uploads/image/computer-networking/ospf-header.jpeg"></p><p>OSPF 使用 24 字节的固定长度首部：</p><ul><li>版本：当前的版本号是 2。</li><li>类型：可以是 5 种类型分组中的一种。<ul><li>问候（Hello）分组，用来发现和维持邻站的可达性。</li><li>数据库描述（Database Description）分组，向邻站给出自己的链路状态数据库的摘要信息。</li><li>链路状态请求（Link State Request）分组，向对方请求发送某些链路状态项目的详细信息。</li><li>链路状态更新（Link State Update）分组，用洪泛法对全网更新链路状态。这种分组是最复杂的，也是 OSPF 协议最核心的部分。</li><li>链路状态确认（Link State Acknowledgement）分组，对链路更新分组的确认。</li></ul></li><li>分组长度：包括首部在内的分组长度，以字节为单位。</li><li>路由器标识符：发送该分组的路由器的接口的 IP 地址。</li><li>鉴别类型：0（不用）和 1（口令）</li><li>鉴别：鉴别类型为 0 时就填入 0，鉴别类型为 1 时则填入 8 个字符的口令。</li></ul><p>OSPF 的特点：</p><ul><li>允许管理员给每条路由指派不同的代价（1 至 65535）。商用的网络在使用 OSPF 时，通常根据链路带宽来计算链路的代价。这种灵活性是 RIP 所没有的。</li><li>如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这叫做多路径间的<strong>负载平衡</strong>（load balancing）。在代价相同的多条路径上分配通信量是通信量工程中的简单形式。RIP 只能找出到某个网络的一条路径。</li><li>在 OSPF 路由器之间交换的分组都具有鉴别的功能，保证了仅在可信赖的路由器之间交换路由信息。（RIP 也具有简单的鉴别功能）</li><li>OSPF 支持可变长度的子网划分和无分类的编址 CIDR。（RIP2 也支持）</li><li>由于网络中的链路状态可能经常发生变化，因此 OSPF 让每一个链路状态都带上一个 32 位的序号，序号越大状态就越新。OSPF 规定，链路状态序号增长的速率不得超过 5 秒钟 1 次。这样，全部序号空间在 600 年内不会产生重复序号。</li></ul><h3 id="ospf-的工作过程">OSPF 的工作过程</h3><p>OSPF 规定，每两个相邻的路由器每隔 10 秒钟要交换一次「问候分组」，这样就能确知哪些邻站是可达的。在正常情况下，网络中传送的绝大多数 OSPF 分组都是问候分组。若有 40 秒钟没有收到某个相邻路由器发来的问候分组，则可认为该相邻路由器是不可达的，应立即修改链路状态数据库，并重新计算路由表。</p><p>其他的四种分组都是用来进行链路状态数据库的同步。所谓<strong>同步</strong>就是指不同路由器的链路状态数据库的内容是一样的。</p><p>当一个路由器开始工作时，它只能通过问候分组得知它有哪些相邻的路由器在工作，以及将数据发往相邻路由器所需的”代价“。如果所有的路由器都把自己的本地链路状态信息对全网进行广播，那么各路由器只要将这些信息综合起来就可得出链路状态数据库。但这样做开销太大，因此 OSPF 采用下面的办法。</p><p>OSPF 让每一个路由器用「数据库描述分组」和相邻路由器交换本数据库中已有的链路状态摘要信息。摘要信息主要就是指出有哪些路由器的链路状态信息（以及其序号）已经写入了数据库。之后，路由就使用「链路状态请求分组」向对方请求自己所缺少的某些链路状态项目的详细信息。通过一系列的这种分组交换，全网同步的链路数据库就建立了。</p><p>在网络运行的过程中，只要一个路由器的链路状态发生变化，该路由器就要使用「链路状态更新分组」，用洪泛法向全网更新链路状态。OSPF 使用的是<strong>可靠的洪泛法</strong>，可靠的洪泛法是在收到更新分组后要发送确认（收到重复的更新分组只需要发送一次确认）。</p><p><img src="/uploads/image/computer-networking/ospf-reliable-flooding.jpeg"></p><p>为了确保链路状态数据库与全网的状态保持一致，OSPF 还规定每隔一段时间，如 30 分钟，要刷新一次数据库中的链路状态。</p><p>由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此，当互联网规模很大时，OSPF 协议要比距离向量协议 RIP 好得多。</p><p>若 N 个路由器连接在一个以太网上，则每个路由器要向其他 N-1 个路由器发送链路状态信息，因而共有 N(N-1) 个链路状态要在这个以太网上传送。OSPF 协议对这种多点接入的局域网采用了<strong>指定的路由器</strong>（designated router）的方法，使广播的信息量大大减少。指定的路由器代表该局域网上所有的链路，向连接到该网络上的各路由器发送状态信息（?）。</p><h2 id="外部网关协议-bgp">外部网关协议 BGP</h2><p>在不同的 AS 之间不能使用内部网关协议（RIP 或 OSPF），主要有两个原因：</p><ol type="1"><li><strong>互联网的规模太大</strong>，使得 AS 之间的路由选择非常困难。连接在互联网主干网上的路由器，必须对任何有效的 IP 地址都能在路由表中找到匹配的目的网络。如果使用链路状态协议（如 OSPF），则每一个路由器必须维持一个很大的链路状态数据库。对于这样大的主干网用 Dijkstra 算法计算最短路径时花费的时间也太长。另外，由于 AS 使用的路径度量（代价）可能不同，因此，当一条路径通过几个不同的 AS 时，要计算出有意义的代价是不太可能的。比较合理的做法是在 AS 之间交换“可达性”信息。例如，“到达目的网络 N 可经过自治系统 ASx”。</li><li><strong>AS 之间的路由选择必须考虑有关策略</strong>。这些策略包括政治、安全或经济方面的考虑。例如，我国国内站点在互相传送数据报时不应经过国外兜圈子，特别是，不要经过某些对我国的安全有威胁的国家。这些策略都是由网络管理人员对每一个路由器进行设置的。</li></ol><p>由于上述情况，边界网关协议 BGP 只能是力求寻找一条能够到达目的网络且比较好的路由，而并非要寻找一条最佳路由。</p><h3 id="bgp-协议的三要点">BGP 协议的三要点</h3><p>在配置 BGP 时，每一个自治系统的管理员要选择至少一个路由器作为该自治系统的“BGP 发言人”。BGP 发言人往往就是 BGP 边界路由器（但也可以不是），每一个 BGP 发言人除了必须运行 BGP 协议外，还必须运行该自治系统所使用的内部网关协议（如 RIP 或 OSPF）。</p><p>一个 BGP 发言人与其他 AS 的 BGP 发言人要交换路由信息（因此，BGP 协议交换路由信息的结点数量级是自治系统个数的量级，这要比这些自治系统中的网络数少很多），要先建立 TCP 连接（端口 179），然后在此连接上交换 BGP 报文以建立 BGP 会话（session），利用 BGP 会话交换路由信息，如增加了新的路由，或撤销过时的路由，以及报告出差错的情况等等。使用 TCP 连接能提供可靠的服务，也简化了路由选择协议。使用 TCP 连接交换路由信息的两个 BGP 发言人，彼此成为对方的<strong>邻站</strong>（neighbor）或<strong>对等站</strong>（peer）。</p><p>在 BGP 刚开始运行时，BGP 的邻站是交换整个的 BGP 路由表。但以后只需要在发生变化时更新有变化的部分。这样做对节省网络带宽和减少路由器的处理开销方面都有好处。</p><p>BGP 采用了<strong>路径向量路由选择协议</strong>，它与距离向量协议（如 RIP）和链路状态协议（如 OSPF）都有很大的区别。下图给出一个 BGP 发言人交换路径向量的例子。AS2 的 BGP 发言人通过主干网的 BGP 发言人：“要到达网络 N1，N2，N3 和 N4 可经过 AS2。“主干网在收到这个通知后，就发出通知：”要到达网络 N1，N2，N3 和 N4 可沿路径（AS1, AS2）。“</p><p><img src="/uploads/image/computer-networking/bgp-path-vector-example.jpeg"></p><p>BGP 支持无分类域间路由选择 CIDR，因此 BGP 的路由表应当包括<strong>目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的自治系统序列</strong>。由于使用了路径向量，可以很容易地避免会兜圈子的路由：如果一个 BGP 发言人收到了一个路径通知，它要检查一下本自治系统是否在此通知的路径中。如果在这条路径中，就不能采用这条路径（因为会兜圈子）。</p><p>BGP 可以很容易地解决距离向量路由选择算法中的“坏消息传播得慢”这一问题。但某个路由器或链路出故障时，由于 BGP 发言人可以从不止一个邻站获得路由信息，因此很容易选择出新的路由。</p><h3 id="bgp-协议的报文格式">BGP 协议的报文格式</h3><p>通用首部：</p><p><img src="/uploads/image/computer-networking/bgp-path-vector-example.jpeg"></p><ul><li>标记：用来鉴别收到的 BGP 报文，当不使用鉴别时要置为全 1。</li><li>长度：以字节为单位，最小值是 19（只有首部），最大值是 4096。</li><li>类型：1 到 4，分别对应 4 种报文。<ul><li>OPEN 报文，用来与相邻的另一个 BGP 发言人建立关系，使通信初始化。如果对方接受，就用 KEEPALIVE 报文响应，这样，两个 BGP 发言人的邻站关系就建立了。</li><li>UPDATE 报文，BGP 协议的核心内容，BGP 发言人可以用 UPDATE 报文撤销它以前通知过的路由，也可以宣布增加新的路由。撤销路由可以一次撤销许多条，但增加新路由时，每个更新报文只能增加一条。</li><li>KEEPALIVE 报文，用来周期性地（一般是 30 秒）证实邻站的连通性。KEEPALIVE 报文只有 19 字节（首部），因此不会造成网络上太大的开销。</li><li>NOTIFICATION 报文，用来发送检测到的错误。</li></ul></li></ul><p>报文主体：</p><ul><li>OPEN：6 个字段，版本、本自治系统号、保持时间（秒）、BGP 标识符（通常就是该路由器的 IP 地址）、可选参数长度 和 可选参数。</li><li>UPDATE：5 个字段，不可行路由长度（指明下一字段的长度）、撤销的路由、路径属性总长度（指明下一字段的长度）、路径属性 和 网络层可达性信息（定义发出此报文的网络，包括网络前缀的位数、IP 地址前缀）。</li><li>KEEPALIVE：无字段，只有首部。</li><li>NOTIFICATION： 3 个字段，差错代码、差错子代码 和 差错数据。</li></ul><h1 id="路由器的构成">路由器的构成</h1><p>路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组。路由器的转发分组正是网络层的主要工作。</p><p><img src="/uploads/image/computer-networking/router-structure.jpeg"></p><p>整个路由器结构可划分为两大部分：<strong>路由选择</strong>部分和<strong>分组转发</strong>部分。路由选择部分也叫做控制部分，其核心构件是路由选择处理机。路由选择处理机的任务是根据所选定的协议构造路由表，并更新和维护路由表。（如前面介绍的那样）本节讨论分组转发部分，它由三部分组成：<strong>交换结构</strong>、一组<strong>输入端口</strong>和一组<strong>输出端口</strong>（这里指的是硬件端口）。</p><p>“转发”和“路由选择”是有区别的。“转发”就是路由器根据转发表把收到的 IP 数据报从合适的端口转发出去，仅仅涉及到一个路由器。但“路由选择”则涉及到很多路由器，路由表则是许多路由器协同工作的结果。</p><p>“转发表“和”路由表“也是有区别的。”路由表“一般包含从目的网络到下一跳（用 IP 地址表示）的映射，而”转发表“是从路由表得出的，包含完成转发功能所必需的信息：从目的网络到输出端口和某些 MAC 地址信息的映射（如下一跳的以太网地址）。将转发表和路由表用不同的数据结构实现会带来一些好处，因为在转发分组时，转发表的结构应当使查找过程最优化，但路由表则需要对网络拓扑变化的计算最优化。路由表总是用软件实现的，但转发表甚至可以用特殊的硬件来实现。请注意，<strong>在讨论路由选择的原理时，往往不去区分转发表和路由表的区别，笼统地使用路由表这一名词</strong>。</p><p>输入端口和输出端口里的方框 1、2 和 3 分别代表物理层、数据链路层和网络层的处理模块。</p><ul><li>物理层进行比特的接收。</li><li>数据链路层则按照链路层协议接收帧。在把帧的首部和尾部剥去后，分组就被送入网络层的处理模块。</li><li>若接收到的是交换路由信息的分组（如 RIP 或 OSPF 分组等），则交给路由选择处理机。若接收到的是数据分组，则按照分组首部中的目的地址查找转发表，根据得到的结果，分组就经过交换结构到达合适的输出端口。</li></ul><p>路由器必须以很高的速率转发分组。分组在输入端口和输出端口都可能会在队列中排队等候处理。若分组处理的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少到零，这就使后面再进入队列的分组被丢弃。以前讨论的分组丢失就是发生在路由器中的输入和输出队列产生溢出的时候。当然，设备或线路出故障也可能使分组丢失。</p><p><img src="/uploads/image/computer-networking/router-forwarding.jpeg"></p><p>交换结构是路由器的关键构件。正是这个交换结构把分组从一个输入端口转移到某个合适的输出端口。下图给出了三种常用的交换方法。</p><p><img src="/uploads/image/computer-networking/router-switching-fabric.jpeg"></p><ul><li>存储器：最早使用的路由器就是利用普通的计算机，用 CPU 作为路由器的路由选择处理机。分组从输入端口复制到存储器中，路由器处理机从分组首部提取目的地址，查找路由表，再将分组复制到合适的输出端口的缓存中。若存储器的带宽（读或写）为每秒 M 个分组，那么路由器的交换速率一定小于 M/2。因为存储器对分组的读和写需要花费的时间是同一个量级。许多现代的路由器也通过存储器进行交换，不同的是，目的地址的查找和分组在存储器中的缓存都是在输入端口进行的。</li><li>总线：数据报从输入端口通过共享的总线直接传送到合适的输出端口，而不需要路由选择处理机的干预（复制）。但是，由于总线是共享的，因此在同一时间只能有一个分组在总线上传送。路由器的转发带宽受总线速率的限制。</li><li><p>互连网络：通过纵横交换结构（crossbar switch fabric）进行交换，它有 2N 条总线，可以使 N 个输入端口和 N 个输出端口相连接，这取决于相应的交叉节点是使水平总线和垂直总线连通还是断开。</p><p>当输入端口收到一个分组时，就将它发送到与该输入端口相连的水平总线上。若通向所要转发的输出端口的垂直总线是空闲的，则在这个结点将垂直总线与水平总线接通，然后将该分组转发到这个输出端口。若垂直总线被占用，则被阻塞，必须在输入端口排队。</p></li></ul><h1 id="ipv6">IPv6</h1><p>IPv6 仍支持无连接的传送，但将协议数据单元 PDU 称为分组，而不是 IPv4 的数据报。方便起见，这里仍采用数据报这一名词。</p><p>IPv6 引进到主要变化：</p><ul><li>更大的地址空间。从 IPv4 的 32 位 增大到 128 位。</li><li>扩展的地址层次结构。由于地址空间很大，因此可以划分更多的层次。</li><li>灵活的首部格式。IPv6 的首部与 IPv4 的并不兼容。IPv6 定义了许多可选的扩充首部。</li><li>改进的选项。IPv6 的首部长度是固定的，选项放在有效载荷中。</li><li>允许协议继续扩充。</li><li>支持即插即用。因此 IPv6 不需要使用 DHCP。</li><li>支持资源的预分配。</li><li>首部改为 8 字节对齐。IPv4 是 4 字节对齐。</li></ul><h2 id="基本首部">基本首部</h2><p>IPv6 数据报由两大部分组成，即<strong>基本首部</strong>（base header）和<strong>有效载荷</strong>（payload）。有效载荷允许有零个或多个<strong>扩展首部</strong>（extension header），再后面是数据部分。注意，扩展首部并不属于 IPv6 数据报的首部。</p><p><img src="/uploads/image/computer-networking/ipv6-header.jpg"></p><p>与 IPv4 相比，IPv6 对首部中的某些字段进行了如下的更改：</p><ul><li>取消了首部长度字段，因为它的首部长度是固定的（40 字节）。</li><li>取消了服务类型字段，优先级和流标号字段实现了服务类型的功能。</li><li>取消了总长度字段，改用有效载荷长度字段。</li><li>取消了标识、标志和片偏移字段，这些功能包含在分片扩展首部中。</li><li>把 TTL 字段改称为跳数限制字段，意义不变。</li><li>取消了协议字段，改用下一个首部字段。</li><li>取消了检验和字段，不进行差错检测。</li><li>取消了选项字段，用扩展首部实现选项功能。</li></ul><p>基本首部：</p><ul><li>版本：6。</li><li>通信量类：区分不同的 IPv6 数据报的类别或优先级。</li><li>流标号：IPv6 的一个新的机制是<strong>支持资源预分配</strong>，并且允许路由器把每一个数据报与一个给定的资源分配相联系。IPv6 提出流（flow）的抽象概念。所谓<strong>流就是互联网上从特定源点到特定终点（单播或多播）的一系列数据报（如实时音频或视频传输），而在这个流所经过的路径上的路由器都保证指明的服务质量</strong>。所有属于同一个流的数据报都具有同样的流标号。因此，流标号对实时音频/视频数据的传送特别有用。对于传统的非实时数据（如电子邮件），流标号则没有用处，把它置 0 即可。</li><li>有效载荷长度：除基本首部以外的字节数。最大值是 64 KB（65535 字节）。</li><li>下一个首部：当没有扩展首部时，它的值指出了首部后面的数据应交付 IP 层上面的哪一个高层协议（例如：6 或 17 分别表示交付 TCP 或 UDP）。当有扩展首部时，它的值标识第一个扩展首部的类型。</li><li>跳数限制：最大 255 跳。</li></ul><p>扩展首部：6 种。（1）逐跳选项；（2）路由选择；（3）分片；（4）鉴别；（5）封装安全有效载荷；（6）目的站选项。每一个扩展首部都由若干个字段组成，它们的长度也各不同。但所有扩展首部的第一个字段都是 8 位的“下一个首部”字段。当使用多个扩展首部时，应按以上的顺序出现。高层首部总是放在最后面。</p><p>IPv4 的数据报如果在首部中使用了选项，那么沿着数据报传送的路径上的每一个路由器都必须对这些选项一一进行检查，这就降低了路由器处理数据报的速度。然而实际上很多的选项在途中的路由器上是不需要检查的（因为不需要使用这些选项的信息）。<strong>IPv6 把选项的功能都放在扩展首部中，并把扩展首部留给路径两端的源点和终点的主机来处理</strong>，而数据报途中经过的路由器不处理这些扩展首部（只有一个首部例外，即逐跳选项扩展首部），这样就<strong>大大提高了路由器的处理效率</strong>。</p><h2 id="ipv6-地址">IPv6 地址</h2><p>一般来讲，一个 IPv6 数据报的目的地址可以是以下三种基本类型地址之一：</p><ol type="1"><li>单播（unicast） 传统的点对点通信。</li><li>多播（multicast） 一点对多点通信，IPv6 没有采用广播的术语，而是将广播看作多播的一个特例。</li><li>任播（anycast） 任播的终点是一组计算机，但数据报只交付其中的一个，通常是距离最近的一个。</li></ol><p>IPv6 把实现 IPv6 的主机和路由器均称为<strong>结点</strong>。一个结点可能有多个与链路相连的接口，IPv6 给每个接口指派一个 IP 地址。一个结点可以有多个单播地址，而其中任何一个地址都可以当作到达该结点的目的地址。（IPv4 也是这么做的啊）</p><p>IPv6 使用<strong>冒号十六进制记法</strong>，它把每个 16 位的值用十六进制值表示，各值之间用冒号分隔。</p><ul><li>在十六进制记法中，允许把数字前面的 0 省略。例如，<code>FF05:0:0:0:0:0:0:B3</code>。</li><li>允许零压缩（zero compression），一连串连续的零可以为一对冒号取代。为了保证零压缩有一个不含混的解释，规定在一个地址中只能使用一次零压缩。例如，<code>FF05::B3</code>。</li><li>可结合使用点分十进制记法的后缀（冒号分隔的每个值是两个字节的量，点分隔的每个值是一个字节的量）。这种结合在 IPv4 向 IPv6 的转换阶段特别有用。例如，<code>：：128.10.2.1</code>。</li><li>CIDR 的斜线记法仍然可用。</li></ul><p>IPv6 的地址分类</p><table><thead><tr class="header"><th>地址类型</th><th>二进制前缀</th></tr></thead><tbody><tr class="odd"><td>未指明地址（1 个）</td><td>00...0（128 位），<code>::/128</code></td></tr><tr class="even"><td>环回地址（1 个）</td><td>00...1（128 位），<code>::1/128</code></td></tr><tr class="odd"><td>多播地址（地址总数的 1/256）</td><td>11111111（8 位），<code>FF00::/8</code></td></tr><tr class="even"><td>本地链路单播地址（地址总数的 1/1024）</td><td>1111111010（10 位），<code>FE80::/10</code></td></tr><tr class="odd"><td>全球单播地址</td><td>除上述四种以外，所有其他的二进制前缀</td></tr></tbody></table><p>本地链路单播地址（Link-Local Unicast Address） 有些单位的网络使用 TCP/IP 协议，但并没有连接到互联网上。连接在这样的网络上的主机都可以使用这种本地地址进行通信，但不能和互联网上的其他主机通信。</p><h2 id="从-ipv4-向-ipv6-过渡">从 IPv4 向 IPv6 过渡</h2><p>向 IPv6 过渡只能采用逐步演进的方法。</p><h3 id="双协议栈">双协议栈</h3><p>双协议栈（dual stack）是指在完全过渡到 IPv6 之前，使一部分主机（或路由器）装有双协议栈：一个 IPv4 和一个 IPv6。在和 IPv6 主机通信时采用 IPv6 地址，而和 IPv4 主机通信时则采用 IPv4 地址。双协议栈如何知道目的主机采用哪一种地址呢？使用域名系统 DNS 来查询。若 DNS 返回的是 IPv4 地址，双协议栈的源主机就使用 IPv4 地址。当返回的是 IPv6 地址，源主机就使用 IPv6 地址。</p><p>图示的情况是 A 和 F 都使用 IPv6，所以 A 向 F 发送 IPv6 数据报，路径是 <code>A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; F</code>。但 B 到 E 这段路径是 IPv4 网络，B 不能向 C 转发 IPv6 数据报。它要把 IPv6 数据报首部转换为 IPv4 数据报再发送给 C。C 再转发给 D。D 将 IPv4 数据报恢复成 IPv6 数据报再转发给 E。主要注意的是，IPv6 <strong>首部中的某些字段却无法恢复</strong>。这种信息的损失是使用首部转换方法所不可避免的。</p><p><img src="/uploads/image/computer-networking/ipv6-dual-stack.jpeg"></p><h3 id="隧道技术">隧道技术</h3><p>隧道技术（tunneling）的要点是，在 IPv6 数据报要进入 IPv4 网络时，把 IPv6 数据报封装成为 IPv4 数据报。整个 IPv6 数据报变成了 IPv4 数据报的数据部分。当 IPv4 数据报离开 IPv4 网络中的隧道时，再把数据部分交给主机的 IPv6 协议栈。请注意图中，在隧道中传送的数据报的源地址是 B 而目的地址是 E。</p><p>要使双协议栈的主机知道 IPv4 数据报里封装的是 IPv6 数据报，必须把 IPv4 首部的协议字段置为 41。</p><p><img src="/uploads/image/computer-networking/ipv6-tunneling.jpeg"></p><h2 id="icmpv6">ICMPv6</h2><p>和 IPv4 一样，IPv6 也不保证数据报的可靠交付，因此 IPv6 也需要使用 ICMP 来反馈一些差错信息。新的版本称为 ICMPv6，它比 ICMPv4 要复杂得多。<strong>地址解析协议 ARP 和网际组管理协议 IGMP 的功能都已被合并到 ICMPv6 中</strong>。ICMPv6 是面向报文的协议，它利用报文来报告差错，获取信息，探测邻站或管理多播通信。</p><h1 id="ip-多播">IP 多播</h1><p>与单播相比，在一对多的通信中，多播可大大节约网络资源。</p><p><img src="/uploads/image/computer-networking/ip-unicast-and-multicast.jpeg"></p><p>在互联网范围的多播要靠路由器来实现，这些路由器必须增加一些能够识别多播数据报的软件。能够运行多播协议的路由器称为<strong>多播路由器</strong>（multicast router）。</p><p>在互联网上进行多播就叫做 IP 多播。IP 多播所传送的分组需要使用多播 IP 地址。显然，这个多播数据报的目的地址一定不能写入主机的 IP 地址。这是因为在同一时间可能有成千上万台主机加入到同一个多播组。多播数据报不可能在其首部写入这样多的主机的 IP 地址。<strong>在多播数据报的目的地址写入的是多播组的标识符</strong>，然后设法让加入到这个多播组的主机的 IP 地址与多播组的标识符关联起来。</p><p>其实多播组的标识符就是 IP 地址中的 D 类地址，前四位是 1110，因此范围是 224.0.0.0 到 239.255.255.255。这样，D 类地址共可标识 2^28 个多播组。多播数据报也是“尽最大努力交付“，不保证可靠性。因此，多播数据报和一般的 IP 数据报的区别就是它<strong>使用 D 类 IP 地址作为目的地址</strong>，并且首部中的<strong>协议值是 2，表明使用网际组管理协议 IGMP</strong>。</p><p>显然，<strong>多播地址只能用于目的地址，而不能用于源地址</strong>。此外，<strong>对多播数据报不产生 ICMP 差错报文</strong>。因此，若在 PING 命令后面键入多播地址，将永远不会收到响应。</p><p>IP 多播可以分为两种。一种是只在本地局域网上进行硬件多播，另一种则是在互联网的范围进行多播。前一种虽然比较简单，但很重要，因为现在大部分主机都是通过局域网接入到互联网的。在互联网上进行多播的最后阶段，还是要把多播数据报在局域网上用硬件多播交付多播组的所有成员。</p><h2 id="硬件多播">硬件多播</h2><p>以太网地址块的高 24 位为 <code>00-00-5E</code>，因此 TCP/IP 协议使用的以太网多播地址块的范围是从 <code>00-00-5E-00-00-00</code> 到 <code>00-00-5E-FF-FF-FF</code>。<strong>以太网硬件地址字段中的第 1 字节的最低位为 1 时即为多播地址</strong>。因此，以太网多播地址的范围是从 <code>01-00-5E-00-00-00</code> 到 <code>01-00-5E-7F-FF-FF</code>（第 25 位的 0 哪来的？）。</p><p><img src="/uploads/image/computer-networking/ip-hardware-multicast.jpeg"></p><p>在每一个地址中，只有 23 位可用作多播，这只能和 D 类 IP 地址中的 23 位有一一对应的关系。D 类 IP 地址可供分配的有 28 位，可见前 5 位不能用来构成以太网硬件地址。例如，IP 多播地址 224.128.64.32（即 <code>E0-80-40-20</code>）和 224.0.64.32（即 <code>E0-00-40-20</code>）转换成以太网的硬件多播地址都是 <code>01-00-5E-00-40-20</code>。由于多播 IP 地址与以太网硬件地址的映射关系不是唯一的，因此收到多播数据报的主机，还要在 IP 层利用软件进行过滤，把不是本主机要接收的数据报丢弃。</p><h2 id="网际组管理协议-igmp">网际组管理协议 IGMP</h2><p>网际组管理协议 IGMP 并非是在互联网范围内对所有多播组成员进行管理的协议。IGMP 不知道 IP 多播组包含的成员数，也不知道这些成员都分布在哪些网络上，等等。IGMP 协议是让<strong>连接在本地局域网</strong>上的多播路由器知道<strong>本局域网上</strong>是否有主机（严格来讲，是主机上的某个进程）参加或退出了某个多播组。所以，IGMP 的使用范围是本地局域网。</p><p>仅有 IGMP 协议是不能完成多播任务的。连接在局域网上的多播路由器还必须和互联网上的其他多播路由器协同工作，以便把多播数据报用最小代价传送给所有的组成员。这就需要使用<strong>多播路由选择协议</strong>。然而多播路由选择协议要比单播路由选择协议复杂的多。</p><ul><li>多播转发必须动态地适应多播组成员的变化（这时网络拓扑并未发生变化）。单播路由选择通常是在网络拓扑发生变化时才需要更新路由。</li><li>多播路由器在转发多播数据报时，不能仅仅根据多播数据报中的目的地址，还要考虑这个多播数据报从什么地方来和要到什么地方去。原因是，没有加入多播组的主机、加入多播组 A 的主机、加入多播组 B 的主机<strong>都可以</strong>向多播组 B 发送多播数据报。</li><li>多播数据报可以由没有加入多播组的主机发出（同上），也可以通过没有组成员接入的网络（例如，两个网路距离很远，必须通过中间网络转发）。</li></ul><p>和 ICMP 相似，IGMP 使用 IP 数据报传递其报文，但它也向 IP 提供服务。</p><p>IGMP 的工作可分为两个阶段。</p><ol type="1"><li>当某台主机加入新的多播组时，该主机应向多播组的多播地址发送一个 IGMP 报文，声明自己要成为改组的成员。本地的多播路由器收到 IGMP 报文后，还要利用多播路由选择协议把这种组成员关系转发给互联网上的其他多播路由器。</li><li>组成员关系是动态的。本地多播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否还继续是组的成员。只要有一台主机对某个组响应，那么多播路由器就认为这个组是活跃的。但一个组在经过几次的探询后仍然没有一台主机响应，多播路由器就认为本网络上的主机已经离开了这个组，因此也就不再把这个组的成员关系转发给其他的多播路由器。</li></ol><p>IGMP 设计得很仔细，避免了多播控制信息给网络增加大量的开销。IGMP 采用的一些具体措施如下：</p><ul><li>在主机和多播路由器之间的所有通信都是使用 IP 多播。只要有可能，携带 IGMP 报文的数据报都用硬件多播来传送。</li><li>多播路由器在探询组成员关系时，只需要对所有的组发送一个请求信息的询问报文，而不需要对每一个组发送一个询问报文。默认的询问速率是每 125 秒一次。</li><li>当同一个网络上连接有几个多播路由器时，它们能够迅速和有效地选择其中的一个来探询主机的成员关系。</li><li>在 IGMP 的询问报文中有一个数值 N，它指明一个最长响应时间（默认 10 秒）。当收到询问时，主机在 0 到 N 之间随机选择发送响应所需经过的时延。若一台主机同时参加了几个多播组，则主机对每一个多播组选择不同的随机数。对应于最小时延的响应最先发送。</li><li>同一个组内的每一台主机都要监听响应（响应是 IP 多播发送的，因此同一个组内的所有成员都能收到），只要有本组的其他主机先发送了响应，自己就可以不再发送响应了。这样就抑制了不必要的通信量。</li></ul><p>多播路由器并不需要保留组成员关系的准确记录，因为向局域网上的组成员转发数据报是使用硬件多播。多播路由器只需要知道网络上是否有主机是本组成员即可。</p><p>如果一台主机上有多个进程都加入了某个多播，那么这台主机对发给这个多播组的每个多播数据报只接收一个副本，然后给主机中的每一个进程发送一个本地复制的副本。</p><p>最后强调，多播数据报的发送者和接收者都不知道（也无法找出）一个多播组的成员有多少，以及这些成员是哪些主机。任何应用进程都可以在任何时候向任何一个多播组发送多播数据报，而并不需要加入这个多播组。</p><h2 id="多播路由选择协议">多播路由选择协议</h2><p>多播协议已成为建议标准，但多播路由选择协议尚未标准化。</p><p>多播路由选择实际上就是要找出以源主机为根节点的<strong>多播转发树</strong>。对不同的多播组对应于不同的多播转发树。同一个多播组，对不同的源点也会有不同的多播转发树。</p><p>已有了多种实用的多播路由选择协议，它们在转发多播数据报时使用了以下的三种方法：</p><ol type="1"><li><p><strong>洪泛与剪除</strong>。这种方法适用于较小的多播组，而所有的组成员接入的局域网也是相邻的。</p><p>一开始，路由转发多播数据报使用洪泛的方法（广播）。为了避免兜圈子，采用了<strong>反向路径广播</strong> RPB（Reverse Path Broadcasting）的策略。RPB 的要点是：每一个路由器在收到一个多播数据报时，先检查数据报是否是从源点经最短路径传送来的。进行这种检查很容易，只要寻找从本路由器到源点的最短路径（反向路径）上的第一个路由器。若是刚才把多播数据报送来的路由器，就向所有其他方向转发收到的多播数据报。若不是，就丢弃。如果有好几个相邻路由器都处在最短路径上，那么只能选择一条最短路径，选择的准则是看谁的 IP 最小。</p><p>如果在多播转发树上的某个路由器发现它的下游树枝已没有该多播组的成员，就应把它和下游的树枝一起剪除。当某个树枝有新增加的组成员时，可以再接入到多播转发树上。</p><p><img src="/uploads/image/computer-networking/ip-multicast-rpb.jpeg"></p></li><li><p><strong>隧道技术</strong>（tunneling）。隧道技术适用于多播组的位置在地理上很分散的情况。</p><p>路由器对多播数据报进行再次封装，即加上普通数据报的首部，使之成为向单一目的站发送的单播（unicast）数据报，然后通过隧道发送。</p><p>单播数据报到达目的站的路由器后，再剥去首部，恢复成原来的数据报，继续向多个目的站转发。</p><p><img src="/uploads/image/computer-networking/ip-multicast-tunneling.jpeg"></p></li><li><p><strong>基于核心的发现技术</strong>。这种方法对于多播组的大小在较大范围内变化时都合适。这种方法对每一个多播组 G 指定一个核心路由器，给出它的 IP 单播地址。核心路由器创建出对应于多播组 G 的转发树。如果有一个路由器 R1 向核心路由器 R2 发送数据报，若发送的是多播数据报且目的地址是 G，则 R2 就转发这个数据报。若发送的是请求加入 G 的数据报，R2 就把这个信息加到它的路由中，并用隧道技术向 R1 转发每一个多播数据报的副本。这样，参加到多播组 G 的路由器就从核心向外增多了，扩大了多播转发树的覆盖范围。</p></li></ol><h1 id="vpn-和-nat">VPN 和 NAT</h1><h2 id="虚拟专用网-vpn">虚拟专用网 VPN</h2><p>假定在一个机构内部的计算机通信也是采用 TCP/IP 协议，那么从原则上讲，对于这些计算机可以由该机构自行分配 IP 地址。让这些计算机仅在本地使用的有效的 IP 地址称为<strong>本地地址</strong>，而向互联网的管理机构申请的全球唯一的 IP 地址称为<strong>全球地址</strong>。</p><p>使用本地地址可以大大节约宝贵的 IP 地址资源。但是，如果任意选择一些 IP 地址作为本地地址，那么在某种情况下可能会引起一些麻烦。例如，有时机构内部的某台主机需要和互联网连接，那么这种仅在内部使用的本地地址就有可能和互联网中某个 IP 地址重合。</p><p>为了解决这一问题，RFC 1918 指明了一些<strong>专用地址</strong>（private address）。这些地址只能用于一个机构的内部通信，而不能用于和互联网上的主机通信。在互联网中的所有路由器，对目的地址是专用地址的数据报一律不进行转发。</p><p>三个专用地址块分别是：</p><ol type="1"><li>10.0.0.0 到 10.255.255.255 （或记为 10.0.0.0/8，又称为 24 位块，相当于 1 个 A 类网络）</li><li>172.16.0.0 到 172.31.255.255（或记为 172.16.0.0/12，又称为 20 位块，相当于 16 个 B 类网络）</li><li>192.168.0.0 到 192.168.255.255 （或记为 192.168.0.0/16，又称为 16 位块，相当于 256 个 C 类网络）</li></ol><p>采用这样的专用 IP 地址的互联网络称为专用互联网或本地互联网，简称<strong>专用网</strong>。专用地址也叫做<strong>可重用地址</strong>（reusable address）。</p><p>有时一个很大的机构的许多部门分布的范围很广，这些部分经常要互相交换信息。这可以有两种方法。（1）租用电信公司的通信线路。简单方便但价格昂贵。（2）利用互联网作为本机构各专用网之间的通信载体（利用 IP 隧道技术），这样的专用网又称为<strong>虚拟专用网</strong> VPN（Virtual Private Network）。虚拟表示“好像是”，VPN 只是在效果上和真正的专用网一样。一个机构要构建自己的 VPN 就必须为它的每一个场所购买专门的硬件和软件，并进行配置，使每一个场所的 VPN 系统都知道其他场所的地址。</p><p><img src="/uploads/image/computer-networking/ip-vpn.jpeg"></p><h2 id="网络地址转换-nat">网络地址转换 NAT</h2><p>下面讨论另一种情况，专用网内部的一些主机想和互联网上的主机通信。</p><p>最简单的办法就是设法再申请一些全球 IP 地址。但这在很多情况下是很不容易做到的。目前采用得最多的方法是<strong>网络地址转换</strong> NAT（Network Address Translation）。</p><p>这种方法需要在专用网络连接到互联网的路由器上安装 NAT 软件。装有 NAT 软件的路由器叫做 NAT 路由器，它至少有一个（也可以有多个）有效的全球 IP 地址。所有使用本地地址的主机在和外界通信时，都要在 NAT 路由器上将其本地地址转换成全球 IP 地址。当 NAT 路由器具有 n 个全球 IP 地址时，专用网内部最多可以同时有 n 台主机接入到互联网。专用网内较多数量的主机，可以轮流使用 n 个全球 IP 地址。</p><p><img src="/uploads/image/computer-networking/ip-nat.jpeg"></p><p>显然，通过 NAT 路由器的通信必须由专用网内的主机发起（因为内部主机没有全球 IP 地址，而路由器不转发目的地址为本地地址的数据报）。因此，这种专用网内部的主机不能充当服务器用。</p><p>为了更加有效地利用 NAT 路由器上的全球 IP 地址，现在常用的 NAT 转换表把运输层的端口号也利用上。这样，就可以使多个拥有本地地址的主机，共用一个 NAT 路由器上的全球 IP 地址。使用端口号的 NAT 也叫做<strong>网络地址与端口转换</strong> NAPT（Network Address and Port Translation），但在许多文献中不做区分，都使用 NAT。</p><p>从层次的角度看，NAPT 的机制有些特殊。普通路由器在转发 IP 数据报时，对于源 IP 地址或目的 IP 地址都是不改变的。但 NAT 路由器在转发 IP 数据报时，一定要更换其 IP 地址。其次，普通路由器在转发分组时，是工作在网络层。但 NAPT 路由器还要查看和转换运输层的端口号，而这本来应当属于运输层的范畴。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Networking </tag>
            
            <tag> IP </tag>
            
            <tag> ICMP </tag>
            
            <tag> IGMP </tag>
            
            <tag> ARP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Convert Sorted List to Binary Serch Tree</title>
      <link href="/programming/leetcode/convert-sorted-list-to-binary-search-tree/"/>
      <url>/programming/leetcode/convert-sorted-list-to-binary-search-tree/</url>
      
        <content type="html"><![CDATA[<h1 id="sorted-array-to-balanced-bst">Sorted Array to Balanced BST</h1><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p><p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given the sorted array: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   -3   9</span><br><span class="line">   /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure><h2 id="recursion">Recursion</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n), visit each element once</span></span><br><span class="line"><span class="comment"># Space: O(log(n)), recursion stack depth</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(self, nums: list)</span> -&gt; TreeNode:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(left, right)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> left &gt; right:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            root = TreeNode(nums[mid])</span><br><span class="line">            root.left = helper(left, mid - <span class="number">1</span>)</span><br><span class="line">            root.right = helper(mid + <span class="number">1</span>, right)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h1 id="sorted-list-to-balanced-bst">Sorted List to Balanced BST</h1><p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p><p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given the sorted linked list: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   -3   9</span><br><span class="line">   /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="recursion-1">Recursion</h2><p>Since we are given a linked list and not an array, we don't really have access to the elements of the list using indexes. We want to know the middle element of the linked list.</p><p>We can use the two pointer approach for finding out the middle element of a linked list. Essentially, we have two pointers called <code>slow_ptr</code> and <code>fast_ptr</code>. The <code>slow_ptr</code> moves one node at a time whereas the <code>fast_ptr</code> moves two nodes at a time. By the time the <code>fast_ptr</code> reaches the end of the linked list, the <code>slow_ptr</code> would have reached the middle element of the linked list. For an even sized list, any of the two middle elements can act as the root of the BST.</p><p>Once we have the middle element of the linked list, we disconnect the portion of the list to the left of the middle element. The way we do this is by keeping a <code>prev_ptr</code> as well which points to one node before the <code>slow_ptr</code>.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n log(n)), O(n) to find mid</span></span><br><span class="line"><span class="comment"># Space: O(log(n)), recursion stack</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMiddle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="comment"># The pointer used to disconnect the left half from the mid node.</span></span><br><span class="line">        prevPtr = <span class="literal">None</span></span><br><span class="line">        slowPtr = head</span><br><span class="line">        fastPtr = head</span><br><span class="line">        <span class="comment"># Iterate until fastPr doesn't reach the end of the linked list.</span></span><br><span class="line">        <span class="keyword">while</span> fastPtr <span class="keyword">and</span> fastPtr.next:</span><br><span class="line">            prevPtr = slowPtr</span><br><span class="line">            slowPtr = slowPtr.next</span><br><span class="line">            fastPtr = fastPtr.next.next</span><br><span class="line">        <span class="comment"># Handling the case when slowPtr was equal to head.</span></span><br><span class="line">        <span class="keyword">if</span> prevPtr:</span><br><span class="line">            prevPtr.next = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> slowPtr</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span><span class="params">(self, head: ListNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># If the head doesn't exist, then the linked list is empty</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># Find the middle element for the list.</span></span><br><span class="line">        mid = self.findMiddle(head)</span><br><span class="line">        <span class="comment"># The mid becomes the root of the BST.</span></span><br><span class="line">        node = TreeNode(mid.val)</span><br><span class="line">        <span class="comment"># Base case when there is just one element in the linked list</span></span><br><span class="line">        <span class="keyword">if</span> head == mid:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        <span class="comment"># Recursively form balanced BSTs using the left and right halves of the original list.</span></span><br><span class="line">        node.left = self.sortedListToBST(head)</span><br><span class="line">        node.right = self.sortedListToBST(mid.next)</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure><h2 id="recursion-conversion-to-array">Recursion + Conversion to Array</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n), array O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(self, nums: list)</span> -&gt; TreeNode:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(left, right)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> left &gt; right:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            root = TreeNode(nums[mid])</span><br><span class="line">            root.left = helper(left, mid - <span class="number">1</span>)</span><br><span class="line">            root.right = helper(mid + <span class="number">1</span>, right)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mapListToValues</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            res.append(head.val)</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span><span class="params">(self, head: ListNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">return</span> self.sortedArrayToBST(self.mapListToValues(head))</span><br></pre></td></tr></table></figure><h2 id="inorder-simulation">Inorder Simulation</h2><p>Elements processed in the inorder fashion on a binary search tree turn out to be sorted in ascending order.</p><p>The critical idea based on the inorder traversal that we will exploit to solve this problem, is:</p><p>We know that the leftmost element in the inorder traversal has to be the head of our given linked list. Similarly, the next element in the inorder traversal will be the second element in the linked list and so on. This is made possible because the initial list given to us is sorted in ascending order.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(log(n)), recursion stack</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSize</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        ptr = head</span><br><span class="line">        c = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> ptr:</span><br><span class="line">            ptr = ptr.next</span><br><span class="line">            c += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span><span class="params">(self, head: ListNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        size = self.findSize(head)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(l, r)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> head  <span class="comment"># point the node to process (visit)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Invalid case</span></span><br><span class="line">            <span class="keyword">if</span> l &gt; r:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="comment"># We don't really find out the middle node of the linked list.</span></span><br><span class="line">            <span class="comment"># We just have a variable telling us the index of the middle element.</span></span><br><span class="line">            <span class="comment"># We simply need this to make recursive calls on the two halves.</span></span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">            left = convert(l, mid - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            node = TreeNode(head.val)  <span class="comment"># process current</span></span><br><span class="line">            node.left = left</span><br><span class="line">            head = head.next  <span class="comment"># process next</span></span><br><span class="line"></span><br><span class="line">            node.right = convert(mid + <span class="number">1</span>, r)</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> convert(<span class="number">0</span>, size - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> linked list </tag>
            
            <tag> balanced binary tree </tag>
            
            <tag> BST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rotate List</title>
      <link href="/programming/leetcode/rotate-list/"/>
      <url>/programming/leetcode/rotate-list/</url>
      
        <content type="html"><![CDATA[<p>Given a linked list, rotate the list to the right by k places, where k is non-negative.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2</span><br><span class="line">Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL</span><br><span class="line">rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4</span><br><span class="line">Output: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">rotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULL</span><br><span class="line">rotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULL</span><br><span class="line">rotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><ol type="1"><li>Connect the tail with head, <code>tail.next = head</code>.</li><li>From <code>head</code>, go forward <code>len - (k % len) - 1</code> steps. The next element is the new head.</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateRight</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        tail, n = head, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> tail.next:</span><br><span class="line">            tail = tail.next</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">        tail.next = head  <span class="comment"># connect</span></span><br><span class="line">        <span class="comment"># find (n - k % n - 1)th node</span></span><br><span class="line">        tail = head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n - k % n - <span class="number">1</span>):</span><br><span class="line">            tail = tail.next</span><br><span class="line">        new_head = tail.next</span><br><span class="line">        tail.next = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> new_head</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运输层</title>
      <link href="/notes/computer-networking/transport-layer/"/>
      <url>/notes/computer-networking/transport-layer/</url>
      
        <content type="html"><![CDATA[<p>只有主机的协议栈才有运输层，而路由器在转发分组时都只用到下三层（物理层、数据链路层和网络层）的功能。</p><p>从运输层的角度来看，通信的真正端点并不是主机而是主机中的进程。IP 协议虽然能把分组送到目的主机，但是这个分组没有交付主机中的应用进程。这表明，运输层有一个很重要的功能——<strong>复用</strong>（multiplexing）和<strong>分用</strong>（demultiplexing）。复用是指在发送方不同的应用进程都可以使用同一个运输层协议传送数据（当然需要加上适当的首部），而分用是指接收方的运输层在剥去报文的首部后能够把这些数据正确交付目的应用进程。</p><p>网络层为主机之间提供逻辑通信，而运输层<strong>为应用进程之间提供端到端的逻辑通信</strong>。</p><p>运输层还要对收到的报文进行<strong>差错检测</strong>。在网络层，IP 数据报首部中的检验和字段，只检验首部而不检查数据部分。</p><p>当运输层采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条全双工的可靠信道。但当采用无连接的 UDP 协议时，这种逻辑通信信道仍然是一条不可靠信道。</p><p>两个计算机中的进程要相互通信，不仅必须知道对方的 IP 地址（为了找到对方的计算机），而且还要知道对方的端口号（为了找到对方计算机中的应用进程）。TCP/IP 的运输层使用一个 16 位（可允许有 65535 个不同的端口，这个数目对一个计算机来说是足够用的）端口号来标志一个端口。</p><p>端口号分为下面两大类：</p><ul><li>服务器段使用的端口号<ul><li>孰知端口号，0～1023。这些端口号被指派给了 TCP/IP 最重要的一些应用程序。</li><li>登记端口号，1024～49151。使用这类端口号必须按照规定的手续登记，以防止重复。</li></ul></li><li>客户端使用的端口号，49152～65535。这类端口号尽在客户进程运行时才动态选择，因此又叫做短暂端口号。</li></ul><table><thead><tr class="header"><th>应用程序</th><th>FTP</th><th>TELNET</th><th>SMTP</th><th>DNS</th><th>TFTP</th><th>HTTP</th><th>HTTPS</th></tr></thead><tbody><tr class="odd"><td>孰知端口号</td><td>21</td><td>23</td><td>25</td><td>53</td><td>69</td><td>80</td><td>443</td></tr></tbody></table><p>运输层的两个主要协议：</p><ul><li>用户数据报协议 UDP（User Datagram Protocol）<ul><li>面向连接，可靠</li><li>一对一、全双工的，不提供广播或多播服务</li><li>面向字节流，根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少字节</li><li>流量控制，拥塞控制</li></ul></li><li>传输控制协议 TCP（Transmission Control Protocol）<ul><li>无连接的，不可靠，尽最大努力交付</li><li>支持一对一、一对多、多对一、多对多的交互通信</li><li>面向报文，对应用层交下来的报文，既不合并，也不拆分</li><li>没有拥塞控制</li><li>首部开销小，只有 8 个字节，有 4 个字段，每个字段的长度都是两个字节<ol type="1"><li>源端口，在需要对方回信时选用。不需要时可全为 0。</li><li>目的端口，若端口号不正确，就丢弃该报文，并由网际控制报文协议 ICMP 发送“端口不可达”差错报文给发送方。</li><li>长度，最小值是 8（仅有首部字段，没有数据字段）</li><li>检验和，检测数据报在传输中是否有错。有错就丢弃。</li></ol></li></ul></li></ul><a id="more"></a><h1 id="tcp-报文段">TCP 报文段</h1><p><img src="/uploads/image/computer-networking/tcp-header.jpeg"></p><ul><li>源端口和目的端口，各占 2 个字节，与 UDP 的分用类似，TCP 的分用功能也是通过端口实现的。</li><li>序号和确认号，各占 4 个字节。TCP 是面向字节流的，传送的字节流中的每一个字节都按顺序编号。序号是本报文段所发送的数据的第一个字节的序号；确认号是期望收到对方下一个报文段的第一个数据字节的序号。</li><li>数据偏移，占 4 位，数据起始距离报文段起始的偏移，因此也是报文段的首部长度。但应注意，数据偏移的单位是 32 位（即 4 字节）。由于 4 位二进制数能够表示的最大十进制数字是 15，因此数据偏移的最大值是 60 字节，这也是 TCP 首部的最大长度（即选项长度不能超过 40 字节）。</li><li>6 个控制位：紧急 URG，<strong>确认 ACK</strong>，推送 PSH，复位 RST，<strong>同步 SYN</strong>，<strong>终止 FIN</strong>。<strong>只有在 ACK = 1 时确认号字段才有意义</strong>。</li><li>窗口，占 2 个字节，指出现在允许对方发送的数据量（因为接收方的数据缓存空间是有限的）。窗口值经常在动态地变化着。</li><li>检验和，占 2 个字节。检验的范围包括<strong>首部和数据</strong>两部分。</li><li>选项，长度可变，最长 40 个字节。TCP 最初只规定了一种选项，即<strong>最大报文段长度</strong> MSS（Maximum Segment Size）。MSS 是<strong>数据字段的最大长度</strong>，不包括首部。随着互联网的发展，又陆续增加了几个选项，如<strong>窗口扩大</strong>选项、<strong>时间戳</strong>选项、<strong>选择确认（SACK）</strong>。</li></ul><p>为什么要规定一个最大报文段长度 MSS？</p><p>TCP 报文段的数据部分，至少要加上 40 字节（TCP 首部 20 字节和 IP首部 20 字节），才能组装成一个 IP 数据报。<strong>若选择较小的 MSS 值，网络的利用率就降低</strong>。反过来，若 MSS 非常大，那么在 IP 层传输时就有可能要分解成多个短数据报片。在终点要把收到的各个短数据报片装配成原来的 TCP 报文段。当传输出错时还要进行重传。这些也都会使开销增大。最佳的 MSS 是很难确定的。在连接建立的过程中，双方都把自己能够支持的 MSS 写入，两个传送方向可以有不同的 MSS 值。若主机未填写这一项，则 MSS 的默认值是 536 字节。</p><h1 id="可靠传输">可靠传输</h1><h2 id="滑动窗口">滑动窗口</h2><p>全双工通信的双方既是发送方也是接收方。因此，每一方都有自己的发送窗口和接收窗口。</p><p>TCP 的滑动窗口是以字节为单位的。</p><p>发送方的发送窗口大小不能超过接收方的接收窗口；发送窗口大小还要受到当时网络拥塞程度的制约。</p><p>发送窗口包含：</p><ol type="1"><li>已发送但未收到确认的数据</li><li>允许发送但尚未发送的数据</li></ol><p>接收窗口包含：</p><ol type="1"><li>未按序收到的数据（按序收到数据时窗口会向前滑动，因此按序收到的数据不会在接收窗口内）</li><li>允许接收的数据</li></ol><p>发送缓存包含：</p><ol type="1"><li>已发送但尚未收到确认的数据</li><li>准备发送的数据（可能位于发送窗口内，也可能不在窗口内）</li></ol><p>接收缓存包含：</p><ol type="1"><li>未按序收到的数据</li><li>按序到达，但尚未被接收应用程序读取的数据（位于接收窗口左侧）</li></ol><p>窗口通常只是缓存的一部分。</p><ul><li>虽然发送窗口是根据接收窗口设置的，但在同一时刻，它们并不总是一样大。这是因为通过网络传送窗口值需要经历一定的时间滞后，另外，发送方还可能根据拥塞情况适当减小自己的发送窗口大小。</li><li>对于不按序到达的数据应如何处理，TCP 标准并无明确规定。如果一律丢弃，那么接收窗口的管理将会比较简单，但对网络资源的利用不利。因此通常是先临时存放在接收窗口内，等缺少的字节收到后，再按序交付上层的应用进程。</li><li>TCP 要求接收方必须有<strong>累积确认</strong>的功能，这样可以减小传输开销。接收方可以在<strong>合适的时候</strong>发送确认，也可以在发送数据时<strong>捎带</strong>确认信息。但请注意两点。一是接收方不应过分推迟发送确认，否则会导致发送方不必要的重传，反而浪费了网络的资源。<strong>TCP 标准规定，确认推迟的时间不应超过 0.5 秒。若收到一连串具有最大长度的报文段，则必须每隔一个报文段就发送一个确认</strong>。二是捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。</li></ul><h2 id="超时重传时间">超时重传时间</h2><p>超时重传时间太短，就会引起很多不必要的重传，使网络负荷增大。太长，则又使网络的空闲时间增大，降低了传输效率。TCP 采用了一种<strong>自适应算法</strong>。</p><p>TCP 保留了 RTT 的一个加权平均往返时间 <span class="math inline">\(RTT_S\)</span>（S 表示 Smoothed）。</p><p><span class="math display">\[RTT_S^n=(1-\alpha)*RTT_S^{n-1}+\alpha*RTT^n\quad(0\le\alpha&lt;1)\]</span></p><p><span class="math inline">\(\alpha\)</span> 接近于 0，则新的 RTT 样本影响不大，<span class="math inline">\(RTT_S\)</span> 值更新较慢。推荐的 <span class="math inline">\(\alpha\)</span> 值为 1/8，即 0.125。</p><p><strong>超时重传时间</strong> RTO（Retransmission Time-Out）应略大于 <span class="math inline">\(RTT_S\)</span>，建议的公式为：</p><p><span class="math display">\[RTO=RTT_S+4*RTT_D\]</span></p><p><span class="math inline">\(RTT_D\)</span> 是 RTT 的偏差的加权平均值。<span class="math inline">\(\beta\)</span> 的推荐值是 1/4，即 0.25。</p><p><span class="math display">\[RTT_D^n=\begin{cases}0.5*RTT^1,\quad n=1\\ (1-\beta)*RTT_D^{n-1}+\beta*|RTT_S^n-RTT^n|,\quad n&gt;1\end{cases}\]</span></p><p>往返时间的测量实现起来相当复杂。试想，发送一个报文段，重传时间到了还没有收到确认，于是重传报文段。经过一段时间后，收到了确认报文段。现在的问题是：此报文段是对先发送的报文段的确认，还是对重传的报文段的确认？正确的判断对确定 <span class="math inline">\(RTT_S\)</span> 的值关系很大。</p><p>Karn 提出一个算法，只要报文段重传了，就不采用其往返时间成本。但这样，网络时延突然增大时，超时重传时间就无法更新。较为合理的策略是：<strong>报文段每重传一次，就把超时重传时间增大一些（典型做法是翻倍）。当不再发生重传时，才根据上面的公式计算超时重传时间</strong>。</p><h2 id="选择确认-sack">选择确认 SACK</h2><p>若收到的报文段无差错，只是未按序号，选择确认（Selective ACK）设法让发送方只传送缺少的数据而不重传已经正确到达接收方的数据。</p><p>接收到的数据字节流的序号不连续，就会形成一些不连续的字节块。接收方要把这些信息（字节块的边界）准确地告诉发送方，使发送方不要再重复发送这些数据。</p><p>如果要使用选择确认，那么在建立 TCP 连接时，就要在 TCP 首部的选项中加上“允许 SACK”选项，而双方必须都事先商定好。选项中只能报告最多 4 个字节块的边界信息。一个边界信息占 4 字节，共 8 个边界。此外，还需要 1 个字节指明是 SACK 选项和 1 字节指明这个选项要占用多少字节。总共 34 字节。TCP 首部选项的长度最多只有 40 字节。</p><h1 id="流量控制">流量控制</h1><h2 id="利用滑动窗口">利用滑动窗口</h2><p>TCP 通过让发送方维护一个称为接收窗口的变量 rwnd（receive window）来提供流量控制（flow control）。rwnd 用于给发送方（S）一个指示——接收方（R）还有多少可用的缓存空间。</p><p>S 通过将未确认的数据量控制在 rwnd 以内，就可以保证 R 的接收缓存不会溢出。现在有一个小小的问题，假设 R 的接收缓存已满，使得 rwnd = 0。R 在将 rwmd = 0 通告给 S 之后，还要假设 R 没有任何数据要发给 S。一段时间后，R 上的应用进程将缓存清空，但 TCP 仅在 R 有数据或者有确认要发时才会发送报文段给 S，这样，S 不可能知道 R 的接收缓存已经有新的空间了。</p><p>为了解决这个问题，TCP 规范要求：当 S 收到 R 的零窗口通知，就启动计时器。若计时器设置的时间到期，就发送一个零窗口<strong>探测报文段</strong>（只有一个字节数据的报文段），R 在确认这个报文段时给出新的 rwnd。</p><p>TCP 规定，即使设置为零窗口，也必须接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段。</p><h2 id="传输效率">传输效率</h2><p>应用进程把数据传送到 TCP 的发送缓存后，剩下的发送任务就由 TCP 来控制了。可以用不同的机制来控制 TCP 报文段的发送时机。 第一种机制，缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送。第二种机制，由应用进程指明要求发送报文段，即 TCP 支持的<strong>推送</strong>（push）操作。第三种机制，维持一个定时器，期限到了，就把当前已有的缓存数据装入报文段（但长度不能超过 MSS）发送出去。</p><p>在 TCP 的实现中广泛使用 Nagle 算法。算法如下：若发送应用进程要把数据<strong>逐个字节地发送到 TCP 的发送缓存</strong>（比如，一个交互式用户使用一条 TELNET 连接），则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。当发送方收到对第一个数据字节的确认后，再把发送缓存中的所有数据组装成一个报文段发送出去，同时继续对后续到达的数据进行缓存。只有在收到对前一个报文段的确认后才继续发送下一个报文段。Nagle 算法还规定，当到达的数据已达到发送窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段。当数据到达较快而网络速率较慢时，用这样的方法可以明显地减少所用的网络带宽。</p><p>试想另一种情况：接收方的缓存已满，而交互式的<strong>应用进程一次只从接收缓存读取一个字节</strong>，然后向发送方发送确认，并把窗口设置为 1 个字节。接着，发送方又发来 1 个字节的数据（注意，IP 数据报是 41 字节）。这样进行下去，使网络的效率很低。要解决这个问题，可以让接收方等待一段时间，使得接收缓存已有足够空间容纳一个最长的报文段，或者等到接收缓存已有一半空闲的空间，再发出确认报文并通知当前的窗口大小。接收方应 <strong>1. 适当推迟发回确认报文。 2. 尽量使用捎带确认。</strong></p><p>上述两种方法可配合使用。</p><h1 id="拥塞控制">拥塞控制</h1><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫做<strong>拥塞</strong>（congestion）。</p><p>拥塞常常趋于恶化。如果一个路由器没有足够的缓存空间，它就会丢弃一些新到的分组。但当分组被丢弃时，发送这一分组的源点就会重传这一分组，甚至可能还要重传多次。这样会引起更多的分组流入网络和被网络中的路由器丢弃。可见<strong>拥塞引起的重传并不会缓解拥塞，反而会加剧拥塞</strong>。</p><p>拥塞控制与流量控制的关系密切，但存在一些差别。拥塞控制就是<strong>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载</strong>。拥塞控制是一个<strong>全局性的过程</strong>，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制是指<strong>点对点通信量的控制</strong>，是个<strong>端到端</strong>的问题。流量控制要做的是抑制发送端发送数据的速率，以便使接收端来得及接收。</p><p>拥塞控制是很难设计的，因为它是一个动态的问题。分组的丢失是网络发生拥塞的征兆而不是原因。在许多情况下，甚至正是拥塞控制机制本身成为引起网络性能恶化甚至发生死锁（网络吞吐量下降到零，无法工作）的原因。</p><p>从大的方面看，拥塞控制可以分为<strong>开环控制和闭环控制</strong>两种方法。开环控制就是在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。但一旦整个系统运行起来，就不再中途进行改正了。闭环控制是基于<strong>反馈环路</strong>的概念，主要有以下几种措施：</p><ol type="1"><li>检测网络系统以便检测到拥塞在何处、何时发生。</li><li>把拥塞发生的信息传送到可采取行动的地方。</li><li>调整网络系统的运行以解决出现的问题。</li></ol><h2 id="tcp-的拥塞控制方法">TCP 的拥塞控制方法</h2><p>下面讨论的拥塞控制也叫做<strong>基于窗口</strong>的拥塞控制。发送方维持一个叫做<strong>拥塞窗口</strong> cwnd（congestion window）的状态变量，大小取决于网络的拥塞程度，并且动态地在变化。<strong>实际上 TCP 是用字节数作为窗口大小的单位</strong>。但为叙述方便起见，下面用报文段的个数作为窗口大小的单位。</p><p>TCP 进行拥塞控制的算法有四种，即<strong>慢开始</strong>（slow-start）、<strong>拥塞避免</strong>（congestion avoidance）、<strong>快重传</strong>（fast retransmit）和<strong>快恢复</strong>（fast recovery）。</p><h2 id="慢开始">慢开始</h2><p>当主机开始发送数据时，由于并不清楚网络的负荷情况，所以如果立即把大量数据字节注入网络，那么就有可能引起网络发生拥塞。经验证明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口。</p><p>在一开始发送方先设置 cwnd = 1，发送第一个报文段 M1，接收方收到后确认 M1。发送方收到确认后，把 cwnd 从 1 增大到 2，于是发送方接着发送 M2 和 M3。<strong>发送方每收到一个对新报文段的确认（重传的不算在内）就使拥塞窗口加 1</strong>，因此发送方在收到两个确认后，cwnd 就从 2 增大到 4。因此使用慢开始算法后，每经过一个传输轮次，拥塞窗口就加倍。（在 TCP 的实际运行中，发送方只要收到一个对新报文段的确认，其拥塞窗口就立即加 1，并可以立即发送新的报文段，而不需要等待这个轮次中所有的确认都收到后再发送新的报文段。）</p><h2 id="拥塞避免">拥塞避免</h2><p>为了防止拥塞窗口增长过大引起网络拥塞，还需要设置一个<strong>慢开始门限</strong> ssthresh：当 cwnd &lt; ssthres h时，使用慢开始算法；当 cwnd &gt; ssthresh时，该用拥塞避免算法；当 cwnd = ssthresh 时，既可以使用慢开始，也可以使用拥塞避免算法。</p><p>拥塞避免算法的思路是让拥塞窗口缓慢地增大，即每经过一个 RTT 就把拥塞窗口加 1，而不是加倍增长。当网络出现了超时，发送方判断为网络拥塞，调整门限值 ssthresh = cwnd / 2，同时设置拥塞窗口 cwnd = 1，进入慢开始阶段。</p><p>拥塞避免并非能够避免了拥塞，而是把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</p><h2 id="快重传">快重传</h2><p>有时，个别报文段会在网络中丢失，但实际上网络并未发生拥塞。如果发送方迟迟收不到确认，就会误认为网络发生了拥塞。这就导致发送方错误地启动慢开始，降低了传输效率。</p><p>采用快重传算法可以让发送方<strong>尽早知道发生了个别报文段的丢失</strong>。快重传算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要<strong>立即发送确认</strong>，即使收到了失序的报文段也要立即发出对已收到的报文段的<strong>重复确认</strong>。比如，接收方收到 M2，但没收到 M3。后续又收到了失序报文 M4～M6，本来，接收方可以直接丢弃失序报文。但按照快重传算法，接收方必须立即发送对 M2 的重复确认，以便让发送方及早知道接收方没有收到报文段 M3。快重传算法规定，发送方只要<strong>一连收到 3 个重复确认</strong>，应立即进行重传，这样就不会出现超时，发送方也就不会误认为出现了网络拥塞。</p><h2 id="快恢复">快恢复</h2><p>快重传发生时，发送方知道现在只是丢失了个别的报文段。于是不启动慢开始，而是执行快恢复算法：调整门限值 ssthresh = cwnd / 2，同时设置拥塞窗口 cwnd = ssthresh，并开始执行拥塞避免算法。</p><p>也有的快恢复实现是令 cwnd = ssthresh + 3 x MSS。这样做的理由是：既然发送方收到 3 个重复的确认，就表明有 3 个分组已经到达接收方的缓存中，可见现在网络中减少了 3 个分组。因此可以适当把拥塞窗口扩大些。</p><p>在拥塞避免阶段，拥塞窗口是按照线性规律增大的，这常称为<strong>加法增大</strong> AI（Additive Increase）。而一旦出现超时或 3 个重复的确认，就要把门限值设置为当前拥塞窗口值的一半，并大大减小拥塞窗口的数值，这常称为<strong>乘法减小</strong> MD（Multiplicative Decrease）。二者合在一起就是所谓的 <strong>AIMD</strong> 算法。</p><h2 id="结合流量控制">结合流量控制</h2><p>上面的讨论基于接收方总是有足够大的缓存空间的假定，但实际上接收方的缓存空间总是有限的。如果把拥塞控制和流量控制一起考虑，那么很显然，发送方的窗口的上限值应当取接收方窗口 rwnd 和拥塞窗口 cwnd 中较小的一个。</p><h2 id="全局同步">全局同步</h2><p>上节讨论的拥塞控制并没有和网络层采取的策略联系起来。网络层的策略对拥塞控制影响最大的就是<strong>路由器的分组丢弃策略</strong>。</p><p>在最简单的情况下，路由器的队列通常都是按照“先进先出” FIFO（First In First Out）的规则处理到来的分组。当队列已满时，以后再到达的分组都将被丢弃，这叫做“尾部丢弃策略”（tail-drop policy）。尾部丢弃往往会导致一连串分组的丢失，这就使发送方出现超时重传，使 TCP 进入慢开始状态。更为严重的是，在网络中通常有很多 TCP 连接，这些连接中的报文段通常是复用在网络层中的 IP 数据报中传送。在这种情况下，若发生了尾部丢弃，就可能会同时影响到很多条 TCP 连接，结果使这些连接在<strong>同一时间</strong>突然都进入慢开始状态。这在 TCP 术语中称为<strong>全局同步</strong>（global synchronization）。全局同步使得全网的通信量突然下降了很多，而在网络恢复正常后，其通信量又突然增大很多。</p><h2 id="主动队列管理-aqm">主动队列管理 AQM</h2><p>主动队列管理（Active Queue Management），所谓“主动”就是不要等到路由器的队列长度已经达到最大值时才不得不丢弃后面到达的分组。应当在队列长度到达某个值得警惕的数值时（即当网络拥塞有了某些征兆时），就主动丢弃到达的分组。这样就提醒了发送方放慢发送的速率，因而有可能使网络拥塞的程度减轻，甚至不出现。</p><p>AQM 可以有不同的实现方法，曾流行多年的就是<strong>随机早期检测</strong> RED（Random Early Detection）。实现 RED 时需要路由器维持两个参数，即队列长度的最小门限和最大门限。当每一个分组到达时，就按照规定的算法计算当前的平均队列长度，若平均队列长度</p><ol type="1"><li>小于最小门限，接收新到达的分组</li><li>大于最大门限，丢弃新到达的分组</li><li>介于两者之间，按照某一丢弃概率 p 丢弃新到达的分组</li></ol><p>在 RED 的操作中，最难处理的就是丢弃概率 p 的选择，因为 p 并不是一个常数。对每一个到达的分组，都必须计算 p 的数值。多年的实践证明，<strong>RED 的使用效果并不太理想</strong>。目前还没有一种算法能够成为 IEFT 标准。</p><h1 id="连接管理">连接管理</h1><p>运输连接有三个阶段：<strong>连接建立</strong>、<strong>数据传送</strong>和<strong>连接释放</strong>。在 TCP 连接建立过程中要解决以下三个问题：</p><ol type="1"><li>要使每一方都能确知对方的存在</li><li>要允许双方协商一些参数（如最大窗口值，是否使用窗口扩大选项和时间戳选项以及服务质量等）</li><li>能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配</li></ol><h2 id="连接建立">连接建立</h2><p>三次握手。握手开始前，服务器需处于 LISTEN 状态，等待客户的连接请求。</p><p><img src="/uploads/image/computer-networking/three-way-handshake.jpg"></p><ol type="1"><li>客户发出连接请求报文段，并进入 SYN-SENT 状态。请求报文不能携带数据，但要消耗一个序号 x。</li><li>服务器收到请求报文，如同意建立连接，则发送确认报文并进入 SYN-RCVD 状态。确认报文也不能携带数据，也要消耗一个序号 y。</li><li>客户收到确认后，还要发送对确认的确认，之后进入 ESTABLISHED 状态。这个报文可以携带数据。</li><li>服务器收到确认的确认后，也进入 ESTABLISHED 状态。</li></ol><p><strong>注意</strong>：第三次握手，客户可以携带数据，也可以不携带数据。但如果不携带数据则不消耗序号，下一个数据报文段的序号仍是 seq = x + 1。携带数据，则按照数据长度计算下一个报文段的序号。</p><p>为什么有第三次握手？这主要是为了<strong>防止已失效的连接请求报文突然又传送到了服务器</strong>，因而产生错误。考虑一种情况：C 发出连接请求，但迟迟没有收到 S 的确认。于是 C 重传一次请求，随后收到了确认，建立了连接。数据传输完毕后，就释放了连接。现在假定 C 的第一个请求报文段并没有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达 S。本来这应是一个失效的请求，但 S 收到后就误以为 C 又发起一次新的连接请求，于是向 C 发出确认报文，同意建立连接。如果没有第三次握手，新的连接就已经建立了。由于 C 没有发出新的请求，因此会丢弃确认报文。但 S 却以为新的连接已经建立了，并一直在等待 C 发来数据。S 的许多资源就这样白白浪费了。</p><h2 id="连接释放">连接释放</h2><p>四次挥手</p><p><img src="/uploads/image/computer-networking/four-way-handshake.jpg"></p><p>数据传输结束后，双方都可释放连接，下面假设客户先发起连接释放。</p><ol type="1"><li>客户发送释放报文（FIN = 1），进入 FIN-WAIT-1 状态。FIN 报文可以携带数据。即使不携带数据，也要消耗一个序号。</li><li>服务器收到后发出确认，进入 CLOSE-WAIT 状态。这时 TCP 处于半关闭状态。从服务器到客户端的连接并未关闭，这个状态可能会持续一段时间。</li><li>若服务器没有数据要发送，就释放连接。发送释放报文（FIN = 1），并进入 LAST-ACK 状态。</li><li>客户收到释放报文后，必须对此确认。注意 seq = u + 1，因为前一个客户发出的释放报文（这里假设未携带数据）要消耗一个序号。然后进入 TIMW-WAIT 状态。必须经过<strong>时间等待计时器</strong>（TIME-WAIT timer）设置的时间 2MSL 后，才进入到 CLOSED 状态。时间 MSL 叫做<strong>最长报文段寿命</strong>（Maximum Segment Lifetime）。</li></ol><p>为什么必须等待 2MSL 时间呢？这有两个理由：</p><ol type="1"><li>为了保证客户的最后一个 ACK 报文段能够到达服务器。这个 ACK 可能会丢失，服务器迟迟收不到就会重传 FIN + ACK 报文段，客户就能在 2MSL 时间内收到重传的 FIN + ACK 报文段。接着，发送确认并重置计时器。</li><li>防止“已失效的连接请求报文段”出现在本连接中。客户发出最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续时间内所产生的所有报文段都从网络上消失。这样，下一个新的连接中就不会出现旧的连接请求报文段。</li></ol><p>除了时间等待计时器，TCP 还设有一个<strong>保活计时器</strong>（keepalive timer）。服务器每收到一次客户的数据，就重置保活计时器，时间的设置通常是两小时。若两小时没有收到客户的数据，服务器就发送一个探测报文段，以后每隔 75 秒发送一次。若一连发送 10 个探测报文段后仍无客户的响应，服务器就认为客户端出了故障，接着就关闭这个连接。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Networking </tag>
            
            <tag> TCP </tag>
            
            <tag> UDP </tag>
            
            <tag> flow control </tag>
            
            <tag> congestion control </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reverse Linked List</title>
      <link href="/programming/leetcode/reverse-linked-list/"/>
      <url>/programming/leetcode/reverse-linked-list/</url>
      
        <content type="html"><![CDATA[<h1 id="revserse-linked-list-i">Revserse Linked List I</h1><p>Reverse a singly linked list.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><p>Follow up:</p><p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p><h2 id="iteration">Iteration</h2><p>Given a linked list <code>1 -&gt; 2 -&gt; 3</code>, we think it as <code>None .&gt; 1 -&gt; 2 -&gt; 3 -&gt; None</code>, then change the pointers from left. Thus, we need change three pointers for a linked list with size 3. Don't forget the <code>next</code> in new tail node need to be <code>None</code>.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Initial:  None .&gt; 1 -&gt; 2 -&gt; 3 -&gt; None</span><br><span class="line">           ^      ^</span><br><span class="line">          pre    cur</span><br><span class="line"></span><br><span class="line">Details when fix the pointers:</span><br><span class="line">    1. temp = cur.next</span><br><span class="line">    2. cur.next = pre</span><br><span class="line">    3. pre = cur</span><br><span class="line">    4. cur = temp</span><br><span class="line"></span><br><span class="line">(1)       None &lt;- 1    2 -&gt; 3 -&gt; None</span><br><span class="line">                  ^    ^</span><br><span class="line">                 pre  cur</span><br><span class="line"></span><br><span class="line">(2)       None &lt;- 1 &lt;- 2    3 -&gt; None</span><br><span class="line">                       ^    ^</span><br><span class="line">                      pre  cur</span><br><span class="line"></span><br><span class="line">(3)       None &lt;- 1 &lt;- 2 &lt;- 3    None</span><br><span class="line">                            ^     ^</span><br><span class="line">                           pre   cur</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        curr, prev = head, <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            prev, prev.next, curr = curr, prev, curr.next</span><br><span class="line">            <span class="string">'''</span></span><br><span class="line"><span class="string">            temp = curr.next</span></span><br><span class="line"><span class="string">            curr.next = prev</span></span><br><span class="line"><span class="string">            prev = curr</span></span><br><span class="line"><span class="string">            curr = temp</span></span><br><span class="line"><span class="string">            '''</span></span><br><span class="line">        <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="recursion">Recursion</h2><p>The recursive version is slightly trickier and the key is to work backwards. Assume that the rest of the list had already been reversed, now how do I reverse the front part? Let's assume the list is: <span class="math inline">\(n_1 \rightarrow \dots \rightarrow n_{k-1} \rightarrow n_k \rightarrow n_{k+1} \rightarrow \dots \rightarrow n_m \rightarrow \emptyset\)</span>.</p><p>Assume from node <span class="math inline">\(n_{k+1}\)</span> to <span class="math inline">\(n_m\)</span> had been reversed and you are at node <span class="math inline">\(n_k\)</span>: <span class="math inline">\(n_1 \rightarrow \dots \rightarrow n_{k-1} \rightarrow n_k \rightarrow n_{k+1} \leftarrow \dots \leftarrow n_m\)</span>.</p><p>We want <span class="math inline">\(n_{k+1}\)</span>’s next node to point to <span class="math inline">\(n_k\)</span>. So, <span class="math inline">\(n_k\)</span>.next.next = <span class="math inline">\(n_k\)</span>;</p><p>Be very careful that <span class="math inline">\(n_1\)</span>'s next must point to <span class="math inline">\(\emptyset\)</span>. If you forget about this, your linked list has a cycle in it. This bug could be caught if you test your code with a linked list of size 2.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n1 -&gt; n2 -&gt; n3 -&gt; None</span><br><span class="line"></span><br><span class="line">reverseList(n1):</span><br><span class="line">    reverseList(n2):</span><br><span class="line">        reverseList(n3):</span><br><span class="line">            return n3</span><br><span class="line">        p = n3</span><br><span class="line">        n2.next.next = n2</span><br><span class="line">        n2.next = None</span><br><span class="line">        return n3        (n1 -&gt; n2 &lt;- n3)</span><br><span class="line">                                |-&gt; None</span><br><span class="line">    p = n3</span><br><span class="line">    n1.next.next = n1</span><br><span class="line">    n1.next = None       (None &lt;- n1 &lt;- n2 &lt;- n3)</span><br><span class="line">    return n3</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        p = self.reverseList(head.next)  <span class="comment"># return new head</span></span><br><span class="line">        head.next.next = head  <span class="comment"># old head is the new tail</span></span><br><span class="line">        head.next = <span class="literal">None</span>  <span class="comment"># set tail.next to None</span></span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure><h1 id="reverse-linked-list-ii">Reverse Linked List II</h1><p>Reverse a linked list from position m to n. <strong>Do it in one-pass</strong>.</p><p>Note: <span class="math inline">\(1 \le m \le n \le\)</span> length of list.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4</span><br><span class="line">Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure><h2 id="iteration-1">Iteration</h2><p>Given a linked list initially with elements <code>7 -&gt; 9 -&gt; 2 -&gt; 10 -&gt; 1 -&gt; 8 -&gt; 6</code> and we need to reverse the list from node 3 throught 6.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  None .&gt; 7 -&gt; 9 -&gt; 2 -&gt; 10 -&gt; 1 -&gt; 8 -&gt; 6 -&gt; None</span><br><span class="line">   ^      ^</span><br><span class="line">  pre    cur</span><br><span class="line"></span><br><span class="line">Step forward until cur reach the node 3:</span><br><span class="line"></span><br><span class="line">  None .&gt; 7 -&gt; 9 -&gt; 2 -&gt; 10 -&gt; 1 -&gt; 8 -&gt; 6 -&gt; None</span><br><span class="line">               ^    ^</span><br><span class="line">              pre  cur</span><br><span class="line">              con  tail</span><br><span class="line"></span><br><span class="line">Fix connections until pre reach node 6:</span><br><span class="line"></span><br><span class="line">  None .&gt; 7 -&gt; 9 &lt;-&gt; 2 &lt;- 10 &lt;- 1 &lt;- 8    6 -&gt; None</span><br><span class="line">               ^     ^               ^    ^</span><br><span class="line">              con   tai             pre  cur</span><br><span class="line"></span><br><span class="line">Adjust connections:  con -&gt; pre  tail -&gt; cur</span><br><span class="line"></span><br><span class="line">  None .&gt; 7 -&gt; 9 -&gt; 8 -&gt; 1 -&gt; 10 -&gt; 2 -&gt; 6 -&gt; None</span><br><span class="line">               ^    ^               ^    ^</span><br><span class="line">              con  pre             tail cur</span><br><span class="line"></span><br><span class="line">Be careful that con is None when m = 1.</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head: ListNode, m: int, n: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Move the pointers until they reach the proper starting point</span></span><br><span class="line">        pre, cur = <span class="literal">None</span>, head</span><br><span class="line">        <span class="keyword">while</span> m &gt; <span class="number">1</span>:</span><br><span class="line">            pre, cur = cur, cur.next</span><br><span class="line">            m, n = m - <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># The two pointers that will fix the final connections</span></span><br><span class="line">        con, tail = pre, cur</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Iteratively reverse the nodes</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            pre, pre.next, cur = cur, pre, cur.next</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Adjust the final connections</span></span><br><span class="line">        <span class="keyword">if</span> con:</span><br><span class="line">            con.next = pre</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            head = pre</span><br><span class="line">        tail.next = cur</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h2 id="recursion-1">Recursion</h2><p>The recursive function to reverse a linked list:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        p = self.reverseList(head.next)  <span class="comment"># return new head</span></span><br><span class="line">        head.next.next = head  <span class="comment"># old head is the new tail</span></span><br><span class="line">        head.next = <span class="literal">None</span>  <span class="comment"># set tail.next to None</span></span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure><p>To reverse first n elements:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseN</span><span class="params">(self, head: ListNode, n: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        successor = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(head, n)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> successor</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">                successor = head.next</span><br><span class="line">                <span class="keyword">return</span> head  <span class="comment"># new tail</span></span><br><span class="line">            p = helper(head.next, n - <span class="number">1</span>)</span><br><span class="line">            head.next.next = head</span><br><span class="line">            head.next = successor</span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(head, n)</span><br></pre></td></tr></table></figure><p>Finally, solve the problem:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head: ListNode, m: int, n: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.reverseN(head, n)</span><br><span class="line">        head.next = self.reverseBetween(head.next, m - <span class="number">1</span>, n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursion </tag>
            
            <tag> linked list </tag>
            
            <tag> reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Populating Next Right Pointers in Each Node</title>
      <link href="/programming/leetcode/populating-next-right-pointers-in-each-node/"/>
      <url>/programming/leetcode/populating-next-right-pointers-in-each-node/</url>
      
        <content type="html"><![CDATA[<p>You are given a <strong>perfect binary tree</strong> where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p><p>Initially, all next pointers are set to <code>NULL</code>.</p><p><strong>Follow up</strong>:</p><ul><li>You may only use constant extra space.</li><li>Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.</li></ul><p>Example 1:</p><p><img src="/uploads/image/leetcode/connect_next.png"></p><p>Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B.</p><p>Constraints:</p><ul><li>The number of nodes in the given tree is less than 4096.</li><li><code>-1000 &lt;= node.val &lt;= 1000</code></li></ul><h1 id="level-order-traversal">Level Order Traversal</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        level = deque([root])</span><br><span class="line">        <span class="keyword">while</span> level:</span><br><span class="line">            n = len(level)</span><br><span class="line">            <span class="keyword">while</span> n:</span><br><span class="line">                cur = level.popleft()</span><br><span class="line">                n -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> n:  <span class="comment"># n &gt; 0 means level[0] and cur are in one level</span></span><br><span class="line">                    cur.next = level[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    level.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    level.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="without-extra-space">Without extra space</h1><p>Utilize the next pointers constructed before to visit a level from left to right. For each node visited:</p><ol type="1"><li>connect left child and right child.</li><li>connect right child and left child of next node.</li></ol><p>Then, go to next level. Repeat two steps for each node.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Initial:</span><br><span class="line"></span><br><span class="line">         1</span><br><span class="line">     /       \</span><br><span class="line">   2           3</span><br><span class="line"> /   \       /   \</span><br><span class="line">4     5     6     7</span><br><span class="line"></span><br><span class="line">cur = root, fix the pointers of root&apos;s children:</span><br><span class="line"></span><br><span class="line">         1</span><br><span class="line">     /       \</span><br><span class="line">   2    --&gt;    3</span><br><span class="line"> /   \       /   \</span><br><span class="line">4     5     6     7</span><br><span class="line"></span><br><span class="line">Fix the pointers of node 2:</span><br><span class="line"></span><br><span class="line">         1</span><br><span class="line">     /       \</span><br><span class="line">   2    --&gt;    3</span><br><span class="line"> /   \       /   \</span><br><span class="line">4 --&gt; 5 --&gt; 6    7</span><br><span class="line"></span><br><span class="line">Fix the pointers of node 3:</span><br><span class="line"></span><br><span class="line">         1</span><br><span class="line">     /       \</span><br><span class="line">   2    --&gt;    3</span><br><span class="line"> /   \       /   \</span><br><span class="line">4 --&gt; 5 --&gt; 6 --&gt; 7</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root: Node)</span> -&gt; Node:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        level = root</span><br><span class="line">        <span class="keyword">while</span> level.left:  <span class="comment"># 进行到倒数第二层，修改下一层的指针</span></span><br><span class="line">            cur = level</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                <span class="comment"># 连接节点的左右孩子节点</span></span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    cur.left.next = cur.right</span><br><span class="line">                <span class="comment"># 连接右节点与下一个兄弟节点的左节点</span></span><br><span class="line">                <span class="keyword">if</span> cur.next:</span><br><span class="line">                    cur.right.next = cur.next.left</span><br><span class="line">                cur = cur.next  <span class="comment"># 对下一个兄弟节点做同样操作</span></span><br><span class="line">            level = level.left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="recursion">Recursion</h1><p>For each node, we did two steps. This hint us recursion.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root: Node)</span> -&gt; Node:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> node.left:  <span class="comment"># 有子节点</span></span><br><span class="line">                node.left.next = node.right</span><br><span class="line">                <span class="keyword">if</span> node.next:  <span class="comment"># 有兄弟节点</span></span><br><span class="line">                    node.right.next = node.next.left</span><br><span class="line">                helper(node.left)  <span class="comment"># 递归其子节点</span></span><br><span class="line">                helper(node.right)</span><br><span class="line"></span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> leetcode </tag>
            
            <tag> traversal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Binary Tree Right Side View</title>
      <link href="/programming/leetcode/binary-tree-right-side-view/"/>
      <url>/programming/leetcode/binary-tree-right-side-view/</url>
      
        <content type="html"><![CDATA[<p>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3,null,5,null,4]</span><br><span class="line">Output: [1, 3, 4]</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">   1            &lt;---</span><br><span class="line"> /   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></table></figure><h1 id="level-order-traversal">Level Order Traversal</h1><p>Return the list that contains the last node in each order.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        level, res = deque([root]), []</span><br><span class="line">        node = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> level:</span><br><span class="line">            n = len(level)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">                node = level.popleft()</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    level.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    level.append(node.right)</span><br><span class="line">            res.append(node.val)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="preorder">Preorder</h1><p>Modify the pre order traversal, we visit the node first, then right child, finally left child.</p><p>The first node we visit at each level is the rightmost. So we need to save the depth for each node.</p><h2 id="iteration">Iteration</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack, res = [(root, <span class="number">1</span>)], []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node, depth = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> depth &gt; len(res):</span><br><span class="line">                res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append((node.left, depth + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append((node.right, depth + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="recursion">Recursion</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(node, depth, ans)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> depth &gt; len(ans):  <span class="comment"># meet the rightmost</span></span><br><span class="line">                ans.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                helper(node.right, depth + <span class="number">1</span>, ans)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                helper(node.left, depth + <span class="number">1</span>, ans)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        helper(root, <span class="number">1</span>, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binary tree </tag>
            
            <tag> leetcode </tag>
            
            <tag> traversal </tag>
            
            <tag> level order </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Balanced Binary Tree</title>
      <link href="/programming/leetcode/balanced-binary-tree/"/>
      <url>/programming/leetcode/balanced-binary-tree/</url>
      
        <content type="html"><![CDATA[<p>Given a binary tree, determine if it is height-balanced.</p><p>For this problem, a height-balanced binary tree is defined as:</p><blockquote><p>a binary tree in which the left and right subtrees of every node differ in height by no more than 1.</p></blockquote><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">       1</span><br><span class="line">      / \</span><br><span class="line">     2   2</span><br><span class="line">    / \</span><br><span class="line">   3   3</span><br><span class="line">  / \</span><br><span class="line"> 4   4</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><h1 id="top-down-recursion">Top-Down Recursion</h1><p>First, calculate max depth of children. Then, compare them, if balanced, check children recursively; if not, return False.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(nlog(n))</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        left_depth = self.maxDepth(root.left)</span><br><span class="line">        right_depth = self.maxDepth(root.right)</span><br><span class="line">        <span class="keyword">if</span> abs(left_depth - right_depth) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left_depth = self.maxDepth(root.left)</span><br><span class="line">        right_depth = self.maxDepth(root.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + max(left_depth, right_depth)</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="bottom-up-recursion">Bottom-Up Recursion</h1><p>Top-Down recursion is slower than Bottom-Up recursion.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(node)</span>:</span>  <span class="comment"># variation of maximum height</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            left_depth = helper(node.left)</span><br><span class="line">            <span class="keyword">if</span> left_depth == <span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>  <span class="comment"># -1 is a flag that a tree is not balanced</span></span><br><span class="line">            right_depth = helper(node.right)</span><br><span class="line">            <span class="keyword">if</span> right_depth == <span class="number">-1</span> <span class="keyword">or</span> abs(left_depth - right_depth) &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">return</span> max(left_depth, right_depth) + <span class="number">1</span>  <span class="comment"># return true depth when balanced</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(root) != <span class="number">-1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binary tree </tag>
            
            <tag> leetcode </tag>
            
            <tag> balanced binary tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LRU Cache</title>
      <link href="/programming/leetcode/lru-cache/"/>
      <url>/programming/leetcode/lru-cache/</url>
      
        <content type="html"><![CDATA[<p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.</p><p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. <code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p><p>The cache is initialized with a <strong>positive</strong> capacity.</p><p><strong>Follow up</strong>:</p><p>Could you do both operations in <code>O(1)</code> time complexity?</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LRUCache cache = new LRUCache( 2 /* capacity */ );</span><br><span class="line"></span><br><span class="line">cache.put(1, 1);</span><br><span class="line">cache.put(2, 2);</span><br><span class="line">cache.get(1);       // returns 1</span><br><span class="line">cache.put(3, 3);    // evicts key 2</span><br><span class="line">cache.get(2);       // returns -1 (not found)</span><br><span class="line">cache.put(4, 4);    // evicts key 1</span><br><span class="line">cache.get(1);       // returns -1 (not found)</span><br><span class="line">cache.get(3);       // returns 3</span><br><span class="line">cache.get(4);       // returns 4</span><br></pre></td></tr></table></figure><h1 id="hash-table-linked-list">Hash Table + Linked List</h1><p>Using double linked list to save the order. Define the node near the head is newer, near the tail is older. Used double linked list so we can move any node to the head.</p><p>Do get and put in <code>O(1)</code> time, we need a hash table.</p><p>When the size of linked list is large than capacity, remove the tail (oldest) node. We also need to remove the correspond key in hash table, so the key should be saved in linked list node.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DLinkedNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key=<span class="number">0</span>, value=<span class="number">0</span>, prev=None, next=None)</span>:</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br><span class="line">        self.prev = prev</span><br><span class="line">        self.next = next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity: int)</span>:</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.cache = dict()</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">        self.head, self.tail = DLinkedNode(), DLinkedNode()</span><br><span class="line">        self.head.next, self.tail.prev = self.tail, self.head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        node = self.cache[key]</span><br><span class="line">        self.move_to_head(node)</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key: int, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            node = DLinkedNode(key, value)</span><br><span class="line">            self.add_to_head(node)  <span class="comment"># 写缓存</span></span><br><span class="line">            self.cache[key] = node</span><br><span class="line">            self.size += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.size &gt; self.capacity:  <span class="comment"># 删缓存</span></span><br><span class="line">                node = self.remove_tail()</span><br><span class="line">                <span class="keyword">del</span> self.cache[node.key]</span><br><span class="line">                self.size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = self.cache[key]  <span class="comment"># 覆盖缓存</span></span><br><span class="line">            node.value = value</span><br><span class="line">            self.move_to_head(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_to_head</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        self.head.next.prev, node.next = node, self.head.next</span><br><span class="line">        self.head.next, node.prev = node, self.head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move_to_head</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.head.next != node:</span><br><span class="line">            self.remove_node(node)</span><br><span class="line">            self.add_to_head(node)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove_node</span><span class="params">(node)</span>:</span></span><br><span class="line">        node.prev.next = node.next</span><br><span class="line">        node.next.prev = node.prev</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove_tail</span><span class="params">(self)</span>:</span></span><br><span class="line">        node = self.tail.prev</span><br><span class="line">        self.remove_node(node)</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="ordereddict">OrderedDict</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span><span class="params">(collections.OrderedDict)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity: int)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.capacity = capacity</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        self.move_to_end(key)</span><br><span class="line">        <span class="keyword">return</span> self[key]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key: int, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self:</span><br><span class="line">            self.move_to_end(key)</span><br><span class="line">        self[key] = value</span><br><span class="line">        <span class="keyword">if</span> len(self) &gt; self.capacity:</span><br><span class="line">            self.popitem(last=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OrderedDict </tag>
            
            <tag> leetcode </tag>
            
            <tag> linked list </tag>
            
            <tag> hash table </tag>
            
            <tag> LRU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用层</title>
      <link href="/notes/computer-networking/application-layer/"/>
      <url>/notes/computer-networking/application-layer/</url>
      
        <content type="html"><![CDATA[<p>应用层的许多协议都是基于客户服务器模式。即使是 P2P 对等通信方式，实质上也是一种特殊的客户服务器方式。客户（client）和服务器（server）都是指通信中所涉及的两个应用进程。是服务请求方，服务器是服务提供方。</p><h1 id="dns">DNS</h1><p>域名系统 DNS（Domain Name System）用来把便于人们使用的机器名字转换为 IP 地址。</p><p>为什么机器在处理 IP 数据报时要使用 IP 地址而不使用域名呢？这是因为 IP 地址的长度是固定的（IPv4 固定 32 位，IPv6 固定 128 位），而域名的长度并不是固定的，机器处理起来比较困难。</p><p>DNS 被设计成为一个联机分布式数据库系统，并采用客服服务器方式。<strong>DNS 使大多数名字都在本地进行解析，仅少量解析需要在互联网上通信，因此 DNS 的效率很高</strong>。由于 DNS 是分布式系统，即使单个计算机出了故障，也不会妨碍整个 DNS 系统的正常运行。</p><h2 id="域名服务器">域名服务器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">根域名服务器                   根域名服务器</span><br><span class="line">                          /     |       \</span><br><span class="line">顶级域名服务器  org 域名服务器  com 域名服务器  edu 域名服务器  ...</span><br><span class="line">                                |</span><br><span class="line">权限域名服务器                 abc.com 域名服务器</span><br><span class="line">                                |</span><br><span class="line">                            y.abc.com 域名服务器</span><br></pre></td></tr></table></figure><ul><li>根域名服务器（root name server）知道所有的顶级域名服务器的域名和 IP 地址。本地域名服务器在对一个域名进行解析时，只要自己无法解析，就首先要求助于根域名服务器。<ul><li>根域名服务器采用<strong>任播</strong>（任播的 IP 数据报的终点是一组在不同地点的主机，但具有相同的 IP 地址。IP 数据报交付离源点最近的一台主机。）技术，当 DNS 客户向某个根域名服务器的 IP 地址发出查询报文时，路由能找到离这个 DNS 客户最近的一个根域名服务器。这样做不仅加快了 DNS 的查询过程，也更加合理地利用了互联网的资源。</li><li>根域名服务器并不直接把待查询的域名直接转换成 IP 地址（根域名服务器也没有存放这种信息），而是告诉本地域名服务器下一步应当找哪一个顶级域名服务器进行查询。</li></ul></li><li>顶级域名（TLD）服务器负责管理在该顶级域名服务器注册的所有二级域名。当收到 DNS 查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当找的域名服务器的 IP 地址）。</li><li>权限域名服务器是负责一个区的域名服务器。例如区 abc.com 和区 y.abc.com 各设有一个权限域名服务器。</li><li>本地域名服务器（local name server）不属于上面所示的域名服务器层次结构，但它对域名系统非常重要。当一台主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。每一个互联网服务提供者 ISP，或一个大学，甚至一个大学里的系，都可以拥有一个本地域名服务器，有时也称为默认域名服务器。</li></ul><h2 id="递归迭代-查询">递归/迭代 查询</h2><p>主机向本地域名服务器的查询一般都是采用<strong>递归查询</strong>（recursive query）。如果本地域名服务器无法解析，那么本地域名服务器就以 DNS 客户的身份，向根域名服务器发出查询请求报文。</p><p>本地域名服务器向根域名服务器的查询通常是采用<strong>迭代查询</strong>（iterative query）。根域名服务器通常是把自己知道的顶级域名服务器的 IP 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。</p><p>为了提高 DNS 查询效率，并减轻根域名服务器的负荷和减少互联网上的 DNS 查询报文数量，在域名服务器中广泛使用了<strong>高速缓存</strong>。名字到地址的绑定并不经常改变，为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器（例如，每个项目只存放两天）。</p><p>不但在本地域名服务器中需要高速缓存，在主机中也很需要。许多主机在启动时从本地域名服务器下载全部数据库。由于域名改动并不频繁，大多数网点不需花太多精力就能维护数据库的一致性。</p><a id="more"></a><h1 id="ftp">FTP</h1><p>文件传送协议 FTP（File Transfer Protocol）提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限。</p><p>基于 TCP 的 FTP 和基于 UDP 的 TFTP 都是文件共享协议中的一大类，即<strong>复制整个文件</strong>，其特点是：若要存取一个文件，就必须先获得一个本地的文件副本。如果要修改文件，只能对文件的副本进行修改，然后再将修改后的文件副本传回原节点。</p><p>文件共享协议中的另一大类是<strong>联机访问</strong>（on-line access），允许多个程序同时对一个文件进行存取，由操作系统提供对远地共享文件进行访问的服务，就如同对本地文件的访问一样。属于文件共享协议的有<strong>网络文件系统</strong> NFS（Network File System）。</p><p>FTP 的主要功能是减少或消除在不同操作系统下处理文件的不兼容性。</p><p>FTP 使用两个并行的 TCP 连接来传输文件，一个是<strong>控制连接</strong>（control connection，使用 21 号端口），一个是<strong>数据连接</strong>（data connection，使用 20 号端口）。控制连接用于传输控制信息，如用户标识、口令等。数据连接用于实际发送一个文件。因为 FTP 协议使用一个独立的控制连接，所以我们也称 FTP 的控制信息是<strong>带外</strong>（out-of-band）传送的。因此，HTTP 可以说是<strong>带内</strong>（in-band）发送控制信息的。</p><p>控制连接在整个会话期间一直保持打开，但是对会话中的每一次文件传输都需要建议一个新的数据连接（即数据连接是非持续的）。</p><h1 id="tftp">TFTP</h1><p>简单文件传送协议 TFTP（Trivial File Transfer Protocol）是一个很小且易于实现的文件传送协议。</p><ul><li>使用 UDP 数据报，因此 TFTP 需要有自己的差错改正措施。</li><li>只支持文件传输而不支持交互。</li><li>没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。</li></ul><p>TFTP 的主要优点有两个：</p><ol type="1"><li>可用于 UDP 环境。例如，当需要将程序或文件同时向许多机器下载时就往往需要使用 TFTP。</li><li>TFTP 代码所占的内存较小。这对较小的计算机或某些特殊用途的设备是很重要的。这些设备不需要硬盘，只需要固化了 TFTP、UDP 和 IP 的小容量只读存储器即可。当接通电源后，设备执行只读存储器中的代码，在网络上广播一个 TFTP 请求。网络上的 TFTP 服务器就发送响应，其中包括可执行二进制程序。设备收到此文件后将其放入内存，然后开始运行程序。这种方式增加了灵活性，也减少了开销。</li></ol><p>TFTP 的工作很像停止等待协议。发送完一个文件块后就等待对方的确认，确认时应指明所确认的块编号。</p><p>TFTP 客户进程发送一个读请求报文或写请求报文给 TFTP 服务器进程，其孰知<strong>端口号码为 69</strong>。TFTP 服务器进程要选择一个新的端口号和 TFTP 客户进程进行通信。若文件长度不是 512 字节的整数倍，则最后传送数据报文中的数据字段一定不满 512 字节，这正好可作为文件结束的标志。若文件长度恰好为 512 字节的整数倍，则在文件传送完毕后，还必须在最后发送一个只含首部而无数据的数据报文。</p><h1 id="telnet">TELNET</h1><p>TELNET 是一个简单的<strong>远程终端协议</strong>。TELNET 通过 TCP 连接到远地的另一台主机上。TELNET 能将用户的击键传到远地主机，同时也能将远地主机的输出通过 TCP 连接返回到用户屏幕。这种服务是透明的，因为用户感觉到好像键盘和显示器是直接连在远地主机上。因此，TELNET 又称为<strong>终端仿真协议</strong>。</p><p>TELNET 能够适应许多计算机和操作系统的差异。例如，对于文本中一行的结束，有的系统使用 ASCII 码的回车（CR），有的系统使用换行（LF），还有的系统使用两个字符（CRLF）。为了适应这种差异，TELNET 定义了数据和命令应怎样通过互联网。这些定义就是所谓的<strong>网络虚拟终端</strong> NVT（Network Virtual Terminal）。客户软件把用户的击键和命令转换成 NVT 格式，并送交服务器。服务器软件把收到的数据和命令从 NVT 格式转换成远地系统所需的格式。向用户返回数据时同理。</p><h1 id="http">HTTP</h1><p>超文本传输协议 HTTP（Hyper Text Transfer Protocol）是 Web 的核心，定义了 Web 客户向 Web 服务器请求 Web 页面的方式，以及服务器向客户传送 Web 页面的方式。</p><p>HTTP 使用了面向连接的 TCP 作为运输层协议，保证了数据的可靠传输。但是，<strong>HTTP 协议本身是无连接的</strong>。</p><p><strong>HTTP 协议是无状态的</strong>（stateless）。无状态特性简化了服务器的设计，使服务器更容易支持大量并发的 HTTP 请求。</p><h2 id="非持续持续-连接">非持续/持续 连接</h2><p>HTTP/1.0 的主要缺点，就是每请求一个文档就要有两倍 RTT（Round-Trip Time）的开销。若一个页面上有很多链接的对象（如图片等），那么每一次链接下载都导致 2 x RTT 的开销。另一种开销就是客户和服务器每一次建立新的 TCP 连接都要分配缓存和变量。这种<strong>非持续连接</strong>（non-persistent connection）会使服务器的负担很重。</p><p>HTTP/1.1 较好地解决了这个问题，它使用了<strong>持续连接</strong>（persistent connection），服务器在发送响应后仍然在一段时间内保持这条连接，使同一个客户和该服务器可以继续在这条连接上传送后续的 HTTP 请求报文和响应报文。这并不局限于传送同一个页面上链接的文档，而是只要这些文档都在同一个服务器上就行。</p><p>HTTP/1.1 的持续连接有两种工作方式，即非流水线方式（without pipelining）和流水线方式（with pipelining）。</p><h2 id="代理服务器">代理服务器</h2><p><strong>代理服务器</strong>（proxy server）是一种网络实体，又称为<strong>万维网高速缓存</strong>（Web cache）。代理服务器可在客户端或服务端工作，也可在中间系统上工作。</p><h2 id="请求响应-报文">请求/响应 报文</h2><p>HTTP 是面向文本的（text-oriented），有两类报文：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CRLF 代表 回车换行</span><br><span class="line"></span><br><span class="line">请求报文：</span><br><span class="line">          方法 URL 版本CRLF</span><br><span class="line">          首部字段名: 值CRLF</span><br><span class="line">            ...</span><br><span class="line">          首部字段名: 值CRLF</span><br><span class="line">          CRLF</span><br><span class="line">          实体主体（通常不用）</span><br><span class="line">例：</span><br><span class="line"></span><br><span class="line">GET /dir/index.htm HTTP/1.1</span><br><span class="line">Host: www.xyz.edu.cn</span><br><span class="line">Connection: close</span><br><span class="line">User-Agent: Mozilla/5.0</span><br><span class="line">Accept-Language: cn</span><br><span class="line"></span><br><span class="line">响应报文：</span><br><span class="line"></span><br><span class="line">          版本 状态码 短语CRLF</span><br><span class="line">          首部字段名: 值CRLF</span><br><span class="line">            ...</span><br><span class="line">          首部字段名: 值CRLF</span><br><span class="line">          CRLF</span><br><span class="line">          实体主体（有些响应报文不用）</span><br></pre></td></tr></table></figure><p>请求报文的一些方法：</p><table><thead><tr class="header"><th>方法（操作）</th><th>意义</th></tr></thead><tbody><tr class="odd"><td>OPTION</td><td>请求一些选项的信息</td></tr><tr class="even"><td>GET</td><td>请求读取由 URL 所标志的信息</td></tr><tr class="odd"><td>HEAD</td><td>请求读取由 URL 所标志的信息的首部</td></tr><tr class="even"><td>POST</td><td>给服务器添加信息</td></tr><tr class="odd"><td>PUT</td><td>在指明的 URL 下存储一个文档</td></tr><tr class="even"><td>DELETE</td><td>删除指明的 URL 所标志的资源</td></tr><tr class="odd"><td>TRACE</td><td>用来进行环回测试的请求报文</td></tr><tr class="even"><td>CONNECT</td><td>用于代理服务器</td></tr></tbody></table><p>状态码</p><ul><li>1xx 表示通知信息，如请求收到了或正在进行处理。</li><li>2xx 表示成功，如接受或知道了。</li><li>3xx 表示重定向，如要完成请求还必须采取进一步的行动（主流浏览器大都会自动完成）。</li><li>4xx 表示客户的差错，如请求中有错误的语法或不能完成。</li><li>5xx 表示服务器的差错，如服务器失效无法完成请求。</li></ul><p>常见的状态行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line"></span><br><span class="line">HTTP/1.1 202 Accepted</span><br><span class="line"></span><br><span class="line">HTTP/1.1 400 Bad Request</span><br><span class="line"></span><br><span class="line">HTTP/1.1 404 Not Found</span><br><span class="line"></span><br><span class="line">HTTP/1.1 301 Moved Permanently</span><br><span class="line">Location: new URL</span><br></pre></td></tr></table></figure><h2 id="cookie">Cookie</h2><p>万维网站点可以使用 Cookie 来跟踪用户。</p><p>当用户 A 浏览某个使用 Cookie 的网站时，该网站的服务器就为 A 产生一个唯一的识别码，并以此作为索引在服务器后端数据库中产生一个项目。接着在给 A 的响应报文中添加一个叫做 Set-cookie 的首部行。例如，<code>Set-cookie: 390ja3mi5o8a0e4w</code>。</p><p>当 A 收到这个响应时，其浏览器就在它管理的特定 Cookie 文件中添加一行，其中包括这个服务器的主机和 Set-cookie 后面给出的识别码。当 A 继续浏览这个网站时，每发送一个请求报文，就取出识别码并放到请求报文的首部行中：<code>Cookie: 390ja3mi5o8a0e4w</code>。</p><h1 id="电子邮件">电子邮件</h1><p>一个电子邮件系统有三个主要组成构件：</p><ol type="1"><li>用户代理 UA（User Agent）：是用户与电子邮件系统的接口，在大多数情况下是运行在用户电脑中的一个程序。因此又称为电子邮件客户端软件，例如 Outlook、Foxmail。</li><li>邮件服务器：发送和接收邮件，同时还要向发件人报告邮件传送的结果（已交付、被拒绝、丢失等）。邮件服务器需要使用两种不同的协议。</li><li>邮件发送协议（如 SMTP）和邮件读取协议（如 POP3，IMAP）</li></ol><h2 id="smtp">SMTP</h2><p>客户 SMTP （运行在发送邮件服务器上）在 <strong>25 号端口</strong>建立一个到服务器 SMTP（运行在接收邮件服务器上）的 TCP 连接。如果服务器没有开机，客户会在稍候继续尝试连接。SMTP 一般不使用中间邮件服务器发送邮件，即使这两个邮件服务器位于地球的两端也是这样。</p><p>与 HTTP 的比较：</p><p>持续的 HTTP 和 SMTP 都使用持续连接。HTTP 主要是一个<strong>拉协议</strong>（pull protocol），TCP 连接是由想接收文件的机器发起的；SMTP 基本上是一个<strong>推协议</strong>（push protocol），TCP 连接是由要发送文件的机器发起的。</p><p>简单邮件传送协议 SMTP（Simple Mail Transfer Protocol）存在着一些缺点：</p><ul><li>FROM 命令后面的地址可以任意填写。</li><li>SMTP 限于传送 7 位的 ASCII 码。</li><li>SMTP 传送的邮件是明文。</li></ul><h2 id="pop3-和-imap">POP3 和 IMAP</h2><p>常用的邮件读取协议有两个，即<strong>邮局协议第 3 版 POP3</strong>（Post Office Protocol version 3）和<strong>因特网邮件访问协议 IMAP</strong>（Internet Mail Access Protocol）。</p><p>POP3 是一个非常简单、但功能有限的邮件读取协议，<strong>孰知端口是 110</strong>。使用 POP3 的用户代理通常被用户配置为“下载并删除”或者“下载并保留”方式。使用“下载并删除”方式存在的问题是，邮件接收方可能希望从多个不同的机器访问他的邮件，如从办公室的 PC、家里的 PC。</p><p>IMAP 比 POP3 复杂得多，IMAP 是一个联机协议。用户可以根据需要为自己的邮箱创建便于分类管理的层次式的邮箱文件夹，并且能够将存放的邮件从某一个文件夹中移动到另一个文件夹中。用户也可按某种条件对邮件进行查找。在用户未发出删除邮件的命令之前，IMAP 服务器邮箱中的邮件一直保存着。</p><p>IMAP 的一个重要特性是允许只读取邮件中的某一个部分。例如，收到了一个带有附件（此文件可能很大）的邮件，而用户代理和服务器之间使用低宽带连接时，为了节省时间，可以先下载邮件的正文部分，待以后有时间再读取或下载这个很大的附件。</p><h2 id="基于-web-的电子邮件">基于 Web 的电子邮件</h2><p>使用万维网电子邮件不需要在计算机中再安装用户代理软件，浏览器本身可以向用户提供非常友好的电子邮件界面。</p><p>在浏览器和互联网上的邮件服务器之间传送邮件时，仍然使用 HTTP 协议。但是在各邮件服务器之间传送邮件时，则仍然使用 SMTP 协议。</p><h2 id="mime">MIME</h2><p>SMTP 有以下缺点：</p><ol type="1"><li>不能传送二进制对象。人们曾试图将二进制文件转换为 ASCII 文本，但未形成正式标准或事实上的标准。</li><li>限于传送 7 位的 ASCII 码。许多其他非英语国家的文字就无法传送。</li><li>服务器会拒绝超过一定长度的邮件。</li><li>某些 STMP 的实现并没有完全按照 SMTP 的互联网标准。常见的问题如下：<ul><li>回车、换行的删除和增加</li><li>超过 76 个字符时的处理：截断或自动换行</li><li>后面多余空格的删除</li><li>将制表符 tab 转换为若干个空格</li></ul></li></ol><p>通用互联网邮件扩充 MIME（Multipurpose Internet Mail Extensions）并没有改动或取代 SMTP。MIME 的意图是继续使用原来的邮件格式，但增加了邮件主体的结构，并定义了传送非 ASCII 码的编码标准。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用户              用户</span><br><span class="line"> | 非ASCII码       | 非ASCII码</span><br><span class="line">MIME             MIME</span><br><span class="line"> | 7位ASCII码      | 7位ASCII码</span><br><span class="line">SMTP &lt;---------&gt; SMTP</span><br></pre></td></tr></table></figure><h1 id="dhcp">DHCP</h1><p>动态主机配置协议 DHCP（Dynamic Host Configuration Protocol）提供了一种机制，称为<strong>即插即用联网</strong>（plug-and-play networking）。这种机制允许一台计算机加入新的网络和获取 IP 而不用手动参与。DHCP 很适合于经常移动位置的计算机。</p><p>DHCP 使用客户服务器方式。需要 IP 地址的主机在启动时就向 DHCP 服务器广播（将目的 IP 地址置为全 1，即 255.255.255.255；源 IP 地址置为全 0，因为这台主机目前还没有自己的 IP 地址）发送<strong>发现报文（DHCPDISCOVER）</strong>。在本地网络上所有主机都能够收到这个广播报文，但只有 DHCP 服务器才对此进行回答。DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池（address pool）中取一个地址分配给该计算机。DHCP 服务器的回答报文叫做<strong>提供报文（DHCPOFFER）</strong>。</p><p>凡收到 DHCP 发现报文的 DHCP 服务器都发出 DHCP 提供报文，因此 DHCP 客户可能收到多个 DHCP 提供报文。选择其中的一个，想所选择的 DHCP 服务器发送<strong>请求报文（DHCPREQUEST）</strong>。被选择的服务器收到后发送<strong>确认报文（DHCPACK</strong>），DHCP 客户就可以使用这个 IP 地址了。这种状态叫做已绑定状态。</p><p>DHCP 客户根据服务器提供的租用期 T 设置两个计时器，超时时间分别是 0.5T 和 0.875T。当超时时间到了就要发送请求报文（DHCPREQUEST）请求更新租用期。DHCP 服务器若同意，则发挥确认报文（DHCPACK）；若不同意，则发回<strong>否认报文（DHCPNACK）</strong>，这时 DHCP 客户必须立即停止使用原来的 IP 地址，重新申请 IP 地址（广播发送发现报文）。</p><p>DHCP 客户可以随时终止租用，只需向 DHCP 服务器发送释放报文（DHCPRELEASE）即可。</p><p><strong>DHCP 客户使用的 UDP 端口是 68，而 DHCP 服务器使用的 UDP 端口是 67</strong>。</p><p>在每一个网络上都设置一个 DHCP 服务器会使 DHCP 服务器数量太多。因此现在是使每一个网络至少有一个 DHCP 中继代理（relay agent），通常是一台路由器，它配置了 DHCP 服务器的 IP 地址信息。当 DHCP 中继代理收到主机以广播形式发送的发现报文后，就以单播的方式向 DHCP 服务器转发此报文。</p><p>DHCP 服务器分配给 DHCP 客户的 IP 地址是临时的，DHCP 协议称这段时间为租用期（lease period），数值由 DHCP 服务器自己决定。DHCP 客户也可在报文中（例如，发现报文）提出对租用期的要求。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Networking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k Sum</title>
      <link href="/programming/leetcode/k-sum/"/>
      <url>/programming/leetcode/k-sum/</url>
      
        <content type="html"><![CDATA[<h1 id="sum">2 Sum</h1><h2 id="input-is-an-array">Input is an array</h2><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the same element twice.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure><h3 id="hash-table">Hash Table</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: list, target: int)</span> -&gt; list:</span></span><br><span class="line">        table = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> target - n <span class="keyword">in</span> table:</span><br><span class="line">                <span class="keyword">return</span> [table[target - n], i]</span><br><span class="line">            table[n] = i</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="input-array-is-sorted">Input array is sorted</h2><p>Given an array of integers that is already <strong>sorted in ascending order</strong>, find two numbers such that they add up to a specific target number.</p><p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.</p><p><strong>Note</strong>:</p><ul><li>Your returned answers (both index1 and index2) are <strong>not zero-based</strong>.</li><li>You may assume that each input would have exactly one solution and you may not use the same element twice.</li></ul><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: numbers = [2,7,11,15], target = 9</span><br><span class="line">Output: [1,2]</span><br><span class="line">Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.</span><br></pre></td></tr></table></figure><h3 id="two-pointers">Two Pointers</h3><p>Since nums is sorted, we can make use of this property. Prepare two pointers <code>i, j</code>,</p><ul><li>if <code>nums[i] + nums[j] == target</code>, return <code>[i + 1 ,j + 1]</code>.</li><li>if <code>nums[i] + nums[j] &lt; target</code>, <code>i = i + 1</code>, so that <code>nums[i]</code> is larger than previous.</li><li>if <code>nums[i] + nums[j] &gt; target</code>, <code>j = j - 1</code>.</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, numbers: list, target: int)</span> -&gt; list:</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(numbers) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            current = numbers[i] + numbers[j]</span><br><span class="line">            <span class="keyword">if</span> current == target:</span><br><span class="line">                <span class="keyword">return</span> [i + <span class="number">1</span>, j + <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> current &lt; target:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><h2 id="input-is-a-bst">Input is a BST</h2><p>Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  3   6</span><br><span class="line"> / \   \</span><br><span class="line">2   4   7</span><br><span class="line"></span><br><span class="line">Target = 9</span><br><span class="line"></span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  3   6</span><br><span class="line"> / \   \</span><br><span class="line">2   4   7</span><br><span class="line"></span><br><span class="line">Target = 28</span><br><span class="line"></span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure><h3 id="traversal-hash-set">Traversal + Hash Set</h3><p>Input can be any binary tree.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n). The entire tree is traversed only once in the worst case.</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTarget</span><span class="params">(self, root: TreeNode, k: int)</span> -&gt; bool:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(node, hSet)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> k - node.val <span class="keyword">in</span> hSet:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            hSet.add(node.val)</span><br><span class="line">            <span class="keyword">return</span> helper(node.left, hSet) <span class="keyword">or</span> helper(node.right, hSet)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(root, set())</span><br></pre></td></tr></table></figure><h3 id="inorder-two-pointers">Inorder + Two Pointers</h3><p>Only for BST since we used the property of BST.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTarget</span><span class="params">(self, root: TreeNode, k: int)</span> -&gt; bool:</span></span><br><span class="line">        nums = []</span><br><span class="line">        self.inorder(root, nums)</span><br><span class="line">        i, j = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            current = nums[i] + nums[j]</span><br><span class="line">            <span class="keyword">if</span> current == k:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> current &lt; k:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(self, root, res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            self.inorder(root.left, res)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            self.inorder(root.right, res)</span><br></pre></td></tr></table></figure><h1 id="sum-1">3 Sum</h1><p>Given an array nums of n integers, are there elements a, b, c in nums such that <code>a + b + c = 0</code>? Find <strong>all unique</strong> triplets in the array which gives the sum of zero.</p><p><strong>Note</strong>: The solution set must not contain duplicate triplets.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given array nums = [-1, 0, 1, 2, -1, -4],</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="sorting-two-pointers">Sorting + Two Pointers</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2)</span></span><br><span class="line"><span class="comment"># Space: O(1) or O(n) depending on extra memory needed for sorting</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: list)</span> -&gt; list:</span></span><br><span class="line">        res = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i, a <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> a == nums[i - <span class="number">1</span>]:  <span class="comment"># skip same value</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            l, r = i + <span class="number">1</span>, len(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                threeSum = a + nums[l] + nums[r]</span><br><span class="line">                <span class="keyword">if</span> threeSum &gt; <span class="number">0</span>:</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> threeSum &lt; <span class="number">0</span>:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append([a, nums[l], nums[r]])</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> nums[l] == nums[l - <span class="number">1</span>] <span class="keyword">and</span> l &lt; r:</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="sum-2">4 Sum</h1><p>Given an array <code>nums</code> of n integers and an integer target, are there elements a, b, c, and d in nums such that <code>a + b + c + d = target</code>? Find <strong>all unique</strong> quadruplets in the array which gives the sum of target.</p><p><strong>Note</strong>: The solution set must not contain duplicate quadruplets.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>If an interviewer asks you to solve 4Sum, they can follow-up with 5Sum, 6Sum, and so on. What they are really expecting at this point is a kSum solution.</p><h2 id="sorting-recursion">Sorting + Recursion</h2><p>The two pointers pattern requires the array to be sorted, so we do that first. Also, it's easier to deal with duplicates if the array is sorted: repeated values are next to each other and easy to skip.</p><p>For 3Sum, we enumerate each value in a single loop, and use the two pointers pattern for the rest of the array. For kSum, we will have <code>k - 2</code> nested loops.</p><p>We can implement <code>k - 2</code> loops using a recursion. We will pass the starting point and k as the parameters. When <code>k == 2</code>, we will call twoSum, terminating the recursion.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^(k - 1)) for k sum</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums: list, target: int)</span> -&gt; list:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> self.kSum(nums, target, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kSum</span><span class="params">(self, nums: list, target: int, k: int)</span> -&gt; list:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span> <span class="keyword">or</span> nums[<span class="number">0</span>] * k &gt; target <span class="keyword">or</span> target &gt; nums[<span class="number">-1</span>] * k:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> self.twoSum(nums, target)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> nums[i - <span class="number">1</span>] != nums[i]:</span><br><span class="line">                <span class="keyword">for</span> other <span class="keyword">in</span> self.kSum(nums[i + <span class="number">1</span>:], target - nums[i], k - <span class="number">1</span>):</span><br><span class="line">                    res.append([nums[i]] + other)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Two Pointers</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: list, target: int)</span> -&gt; list:</span></span><br><span class="line">        res = []</span><br><span class="line">        lo, hi = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            current = nums[lo] + nums[hi]</span><br><span class="line">            <span class="keyword">if</span> current &lt; target <span class="keyword">or</span> (lo &gt; <span class="number">0</span> <span class="keyword">and</span> nums[lo] == nums[lo - <span class="number">1</span>]):</span><br><span class="line">                lo += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> current &gt; target <span class="keyword">or</span> (hi &lt; len(nums) - <span class="number">1</span> <span class="keyword">and</span> nums[hi] == nums[hi + <span class="number">1</span>]):</span><br><span class="line">                hi -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append([nums[lo], nums[hi]])</span><br><span class="line">                lo += <span class="number">1</span></span><br><span class="line">                hi -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="sorting-hash-set">Sorting + Hash Set</h2><p>The code will only differ in the twoSum implementation.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hash set</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: list, target: int)</span> -&gt; list:</span></span><br><span class="line">    res = []</span><br><span class="line">    s = set()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">if</span> len(res) == <span class="number">0</span> <span class="keyword">or</span> res[<span class="number">-1</span>][<span class="number">1</span>] != nums[i]:  <span class="comment"># skip same value</span></span><br><span class="line">            <span class="keyword">if</span> target - nums[i] <span class="keyword">in</span> s:</span><br><span class="line">                res.append([target - nums[i], nums[i]])</span><br><span class="line">        s.add(nums[i])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursion </tag>
            
            <tag> leetcode </tag>
            
            <tag> traversal </tag>
            
            <tag> hash table </tag>
            
            <tag> BST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Contruct Binary Tree from Traversal</title>
      <link href="/programming/leetcode/contruct-binary-tree-from-traversal/"/>
      <url>/programming/leetcode/contruct-binary-tree-from-traversal/</url>
      
        <content type="html"><![CDATA[<h1 id="from-preorder-and-inorder">From Preorder and Inorder</h1><p>Given preorder and inorder traversal of a tree, construct the binary tree.</p><p><strong>Note</strong>: You may assume that duplicates do not exist in the tree.</p><p>For example, given</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">preorder = [3,9,20,15,7]</span><br><span class="line">inorder = [9,3,15,20,7]</span><br></pre></td></tr></table></figure><p>Return the following binary tree:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><h2 id="recursion">Recursion</h2><p>The key point to solve such problems is to undertand:</p><ol type="1"><li>PreOrder: <code>[root, m nodes in left subtree, n nodes in right subtree] (m, n &gt;= 0)</code>.</li><li>InOrder: <code>[m nodes in left subtree, root, n nodes in right subtree]</code>.</li><li>PostOrder: <code>[m nodes in left subtree, n nodes in right subtree, root]</code>.</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n),</span></span><br><span class="line"><span class="comment"># Space: O(n), we copied preorder and inorder at each recursion</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder: list, inorder: list)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder <span class="keyword">and</span> <span class="keyword">not</span> inorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root_val = preorder[<span class="number">0</span>]</span><br><span class="line">        ind = inorder.index(root_val)</span><br><span class="line">        left = self.buildTree(preorder[<span class="number">1</span>:ind + <span class="number">1</span>], inorder[:ind])</span><br><span class="line">        right = self.buildTree(preorder[ind + <span class="number">1</span>:], inorder[ind + <span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> TreeNode(root_val, left, right)</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="from-inorder-and-postorder">From Inorder and Postorder</h1><p>Given inorder and postorder traversal of a tree, construct the binary tree.</p><p><strong>Note</strong>: You may assume that duplicates do not exist in the tree.</p><p>For example, given</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inorder = [9,3,15,20,7]</span><br><span class="line">postorder = [9,15,7,20,3]</span><br></pre></td></tr></table></figure><p>Return the following binary tree:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, inorder: list, postorder: list)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> inorder <span class="keyword">and</span> <span class="keyword">not</span> postorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root_val = postorder[<span class="number">-1</span>]</span><br><span class="line">        ind = inorder.index(root_val)</span><br><span class="line">        left = self.buildTree(inorder[:ind], postorder[:ind])</span><br><span class="line">        right = self.buildTree(inorder[ind + <span class="number">1</span>:], postorder[ind:<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> TreeNode(root_val, left, right)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursion </tag>
            
            <tag> tree </tag>
            
            <tag> leetcode </tag>
            
            <tag> traversal </tag>
            
            <tag> preorder </tag>
            
            <tag> inorder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maximum Depth of Binary Tree</title>
      <link href="/programming/leetcode/maximum-depth-of-binary-tree/"/>
      <url>/programming/leetcode/maximum-depth-of-binary-tree/</url>
      
        <content type="html"><![CDATA[<p>Given a binary tree, find its maximum depth.</p><p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><p><strong>Note</strong>: A leaf is a node with no children.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><h1 id="recursion">Recursion</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left_depth = self.maxDepth(root.left)</span><br><span class="line">        right_depth = self.maxDepth(root.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + max(left_depth, right_depth)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursion </tag>
            
            <tag> tree </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Symmetric Tree and Same Tree</title>
      <link href="/programming/leetcode/symmetric-and-same-tree/"/>
      <url>/programming/leetcode/symmetric-and-same-tree/</url>
      
        <content type="html"><![CDATA[<h1 id="symmetric-tree">Symmetric Tree</h1><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p><p>For example, this binary tree is symmetric:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure><p>But the following is not:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure><p><strong>Follow up</strong>: Solve it both recursively and iteratively.</p><h2 id="recursion">Recursion</h2><p>Define a function <code>helper(t1, t2)</code>, then return true if <code>t1</code> and <code>t2</code> is symmetric. A tree <code>root</code> is symmetric only if <code>root.left</code> and <code>root.right</code> are symmetric.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(t1, t2)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> t1 <span class="keyword">and</span> <span class="keyword">not</span> t2:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> t1 <span class="keyword">or</span> <span class="keyword">not</span> t2 <span class="keyword">or</span> t1.val != t2.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> helper(t1.left, t2.right) <span class="keyword">and</span> helper(t1.right, t2.left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(root.left, root.right)</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="iteration">Iteration</h2><p>The <code>helper(t1, t2)</code> is actually a recursive traversal function, which visit two trees at the same time. The order to visit <code>t1</code> is <code>node -&gt; left -&gt; right</code> (preorder), but the order to visit <code>t2</code> is <code>node -&gt; right -&gt; left</code> (modified preorder).</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        stack = [(root, root)]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            n1, n2 = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> n1 <span class="keyword">and</span> <span class="keyword">not</span> n2:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> n1 <span class="keyword">or</span> <span class="keyword">not</span> n2 <span class="keyword">or</span> n1.val != n2.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            stack.append((n1.left, n2.right))</span><br><span class="line">            stack.append((n1.right, n2.left))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h1 id="same-tree">Same Tree</h1><p>Given two binary trees, write a function to check if they are the same or not.</p><p>Two binary trees are considered the same if they are structurally identical and the nodes have the same value.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          /           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p>Example 3:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><h2 id="recursion-1">Recursion</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p: TreeNode, q: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">or</span> <span class="keyword">not</span> q <span class="keyword">or</span> p.val != q.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.isSameTree(p.left, q.left) <span class="keyword">and</span> self.isSameTree(p.right, q.right)</span><br></pre></td></tr></table></figure><h2 id="iteration-1">Iteration</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p: TreeNode, q: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        stack = [(p, q)]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            np, nq = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> np <span class="keyword">and</span> <span class="keyword">not</span> nq:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> np <span class="keyword">or</span> <span class="keyword">not</span> nq <span class="keyword">or</span> np.val != nq.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            stack.append((np.right, nq.right))</span><br><span class="line">            stack.append((np.left, nq.left))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursion </tag>
            
            <tag> tree </tag>
            
            <tag> leetcode </tag>
            
            <tag> traversal </tag>
            
            <tag> preorder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式总结</title>
      <link href="/notes/head-first-design-patterns/summary-of-design-patterns/"/>
      <url>/notes/head-first-design-patterns/summary-of-design-patterns/</url>
      
        <content type="html"><![CDATA[<h1 id="定义设计模式">定义设计模式</h1><blockquote><p>设计模式是一套<strong>被反复使用</strong>的、多数人知晓的、经过分类编目的代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。</p><p>——《设计模式：可复用面性对象软件的基础》</p></blockquote><blockquote><p>模式是在某情境下，针对某问题的某种解决方案。</p><p>情景就是应用某个模式的情况。这应该是会<strong>不断出现</strong>的情况。</p><p>问题就是你想在某情境下达到的目标，但也可以是某情境下的约束。</p><p>解决方案就是你追求的：一个通用的设计，用来解决约束，达到目标。</p><p>——《Head First设计模式》</p></blockquote><p>一般而言，一个模式有四个基本要素：</p><ol type="1"><li>模式名称（pattern name）：通过一两个词来为模式命名，以便我们更好地理解模式并方便开发人员之间交流。</li><li>问题（problem）：描述了应该在何时使用模式，它包含了设计中存在的问题以及问题存在的原因。</li><li>解决方案（solution）：描述了一个设计模式的组成部分，以及这些组成部分之间的相互关系、各自的职责和协作方式，通常解决方案通过UML类图和核心代码进行描述。</li><li>效果（consequences）：描述了模式的优缺点以及在使用模式时应权衡的问题。</li></ol><blockquote><p>符合模式并不表示做得对。</p><p>—— Ralph Johnson，《设计模式：可复用面性对象软件的基础》的作者之一</p></blockquote><blockquote><p>虽然设计模式与语言无关，但这并不意味着每一个模式都能在每一门语言中使用。1996 年，Peter Norvig 在题为“<a href="http://norvig.com/design-patterns/" target="_blank" rel="noopener">Design Patterns in Dynamic Languages</a>”的演讲中指出，Gamma 等人合著的《设计模式：可复用面向对象软件的基础》一书中有 23 个模式，其中有 16 个在动态语言中“不见了，或者简化了”（参见第 9 张幻灯片）。他讨论的是 Lisp 和 Dylan，不过很多相关的动态特性在 Python 中也能找到。</p><p>——《流畅的Python》第6章</p></blockquote><a id="more"></a><h1 id="组织编目">组织编目</h1><table><tr><th colspan="2" rowspan="2"></th><th colspan="3">目的</th></tr><tr><th>创建型</th><th>结构型</th><th>行为型</th></tr><tr><th rowspan="2">范围</th><th>类</th><td>工厂方法</td><td>适配器（类）</td><td>解释器<br>模板方法</td></tr><tr><th>对象</th><td>抽象工厂<br>生成器<br>原型<br>单例</td><td>适配器（对象）<br>桥接<br>组成<br>装饰<br>外观<br>享元<br>代理</td><td>职责链<br>命令<br>迭代器<br>中介者<br>观察者<br>状态<br>策略<br>访问者</td></tr></table><p>根据两条准则对模式进行分类。第一是目的准则，即模式是用来完成什么工作的。依据其目的可分为创建型（creational）、结构型（structural）或行为型（behavioral）三种。创建型模式与对象的创建有关；结构型模式处理类或对象的组合；行为型模式对类或对象怎样交互和怎样分配职责进行描述。</p><p>第二准则是范围，指定模式主要是用于类还是用于对象。<strong>类模式处理类和子类之间的关系，这些关系通过继承建立，是静态的，在编译时刻便确定下来了。对象模式处理对象间的关系，这些关系在运行时刻是可以变化的，更具动态性</strong>。从某种意义上来说，几乎所有模式都适用继承机制，所以”类模式“只指那些集中于处理类间关系的模式，而大部分模式都属于对象模式的范畴。</p><h1 id="oo-基础">OO 基础</h1><p>抽象，封装，多态，继承</p><h1 id="oo-原则">OO 原则</h1><table><colgroup><col style="width: 33%"><col style="width: 66%"></colgroup><thead><tr class="header"><th>名称或内容</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>封装变化</td><td>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</td></tr><tr class="even"><td>针对接口编程，不针对实现编程</td><td>“针对接口编程”真正的意思是“针对超类型（supertype）编程，可以更明确地说成”变量的声明类型应该是超类型，通常是一个抽象类或者是一个接口，如此，只要是具体实现此超类型的类所产生的对象，都可以指定给这个变量。这也意味着，声明类时不用理会以后执行时的真正对象类型！”。</td></tr><tr class="odd"><td>多用组合，少用继承</td><td>使用组合建立系统具有很大的弹性。（大多数模式都是用于对象）</td></tr><tr class="even"><td>为交互对象之间的松耦合设计而努力</td><td>当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节。只要它们之间的接口仍被遵守，我们可以自由地改变它们，改变其中一方，并不会影响另一方。</td></tr><tr class="odd"><td>开闭原则（Open-Closed Principle）</td><td>类应该对扩展开放，对修改关闭。</td></tr><tr class="even"><td>依赖倒置原则（Dependency Inversion Principle）</td><td>要依赖抽象，不要依赖具体类。很像“针对接口编程，不针对实现编程“，然而这里更强调”抽象“。不能让高层组件依赖低层组件，而且，不管高层或低层组件，都应该依赖于抽象。</td></tr><tr class="odd"><td>最少知识原则（Least Knowledge Principle）<br>也叫做迪米特法则（Law of Demeter）</td><td>只和你的密友谈话。这个原则提供了一些方针：就任何对象而言，在该对象的方法内，我们只应该调用属于以下范围的方法：该对象本身；被当作方法的参数而传递进来的对象；此方法所创建或实例化的任何对象；对象的任何组件。</td></tr><tr class="even"><td>好莱坞原则</td><td>别调用我们，我们会调用你。</td></tr><tr class="odd"><td>单一责任原则（Single Responsibility Principle）</td><td>一个类应该只有一个引起变化的原因。</td></tr></tbody></table><h1 id="oo-模式">OO 模式</h1><table><thead><tr class="header"><th>模式</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><a href="/notes/head-first-design-patterns/strategy-pattern/" title="策略">策略</a></td><td>定义算法族，分别封装起来，让它们之间可以<strong>互相替换</strong>，此模式让算法的变化独立于使用算法的客户。</td></tr><tr class="even"><td><a href="/notes/head-first-design-patterns/observer-pattern/" title="观察者">观察者</a></td><td>在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知，并自动更新。</td></tr><tr class="odd"><td><a href="/notes/head-first-design-patterns/decorator-pattern/" title="装饰者">装饰者</a></td><td>动态地将责任附加到对象上。想要扩展功能，装饰者提供有别于继承的另一种选择。</td></tr><tr class="even"><td><a href="/notes/head-first-design-patterns/factory-pattern/" title="简单工厂">简单工厂</a></td><td>简单工厂其实不是一个设计模式，反而比较像是一种编程习惯。</td></tr><tr class="odd"><td><a href="/notes/head-first-design-patterns/factory-pattern/" title="工厂方法">工厂方法</a></td><td>定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。</td></tr><tr class="even"><td><a href="/notes/head-first-design-patterns/factory-pattern/" title="抽象工厂">抽象工厂</a></td><td>提供一个接口，用于创建相关或依赖对象的<strong>家族</strong>，而不需要明确指定具体类。</td></tr><tr class="odd"><td><a href="/notes/head-first-design-patterns/singleton-pattern/" title="单件">单件</a></td><td>确保一个类只有一个实例，并提供一个全局访问点。</td></tr><tr class="even"><td><a href="/notes/head-first-design-patterns/command-pattern/" title="命令">命令</a></td><td>将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。</td></tr><tr class="odd"><td><a href="/notes/head-first-design-patterns/adapter-pattern-and-facade-pattern/" title="适配器">适配器</a></td><td>将一个类的接口，转换成客户期望的另一个接口。适配器让那个原本接口不兼容的类可以合作无间。</td></tr><tr class="even"><td><a href="/notes/head-first-design-patterns/adapter-pattern-and-facade-pattern/" title="外观">外观</a></td><td>提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</td></tr><tr class="odd"><td><a href="/notes/head-first-design-patterns/template-method-pattern/" title="模板方法">模板方法</a></td><td>在一个方法中定义了一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。</td></tr><tr class="even"><td><a href="/notes/head-first-design-patterns/iterator-pattern-and-composite-pattern/" title="迭代器">迭代器</a></td><td>提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。</td></tr><tr class="odd"><td><a href="/notes/head-first-design-patterns/iterator-pattern-and-composite-pattern/" title="组合">组合</a></td><td>允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。</td></tr><tr class="even"><td><a href="/notes/head-first-design-patterns/state-pattern/" title="状态">状态</a></td><td>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</td></tr><tr class="odd"><td><a href="/notes/head-first-design-patterns/proxy-pattern/" title="代理">代理</a></td><td>为另一个对象提供一个替身或占位符以控制对这个对象的访问。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Head First Design Patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复合模式</title>
      <link href="/notes/head-first-design-patterns/compound-pattern/"/>
      <url>/notes/head-first-design-patterns/compound-pattern/</url>
      
        <content type="html"><![CDATA[<p>模式通常被一起使用，并被组合在同一个设计解决方案中。复合模式（Compound Pattern）在一个解决方案中结合两个或多个模式，已解决一般或重复发生的问题。但是我们将某些模式结合使用，并不代表这些模式就够资格称为复合模式。<strong>复合模式必须够一般性，适合解决许多问题才行</strong>。</p><h1 id="定义复合模式">定义复合模式</h1><p>复合模式结合两个或以上的模式，组成一个解决方案，解决一再发生的一般性问题。</p><h1 id="导入与鸭子重聚">导入：与鸭子重聚</h1><p>我们将从头重建我们的鸭子模拟器，并通过使用一堆模式来赋予它一些有趣的能力。动工了……</p><a id="more"></a><h1 id="从-quackable-开始">从 Quackable 开始</h1><p>这一次，我们不研究鸭子的飞行、呱呱叫等行为，我们让鸭子实现 Quackable 接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Quackable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MallardDuck</span> <span class="keyword">implements</span> <span class="title">Quackable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Quack"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DuckCall</span>  <span class="keyword">implements</span> <span class="title">Quackable</span> </span>&#123;  <span class="comment">// 鸭鸣器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Kwak"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RubberDuck</span> <span class="keyword">implements</span> <span class="title">Quackable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Squeak"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DuckSimulator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DuckSimulator simulator = <span class="keyword">new</span> DuckSimulator();</span><br><span class="line">        simulator.simulate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">simulate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Quackable mallardDuck = <span class="keyword">new</span> MallardDuck();</span><br><span class="line">        Quackable duckCall = <span class="keyword">new</span> DuckCall();</span><br><span class="line">        Quackable rubberDuck = <span class="keyword">new</span> RubberDuck();</span><br><span class="line"></span><br><span class="line">        simulate(mallardDuck);</span><br><span class="line">        simulate(duckCall);</span><br><span class="line">        simulate(rubberDuck);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">simulate</span><span class="params">(Quackable duck)</span> </span>&#123;</span><br><span class="line">        duck.quack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ java DuckSimulator</span><br><span class="line">Quack</span><br><span class="line">Kwak</span><br><span class="line">Squeak</span><br></pre></td></tr></table></figure><h1 id="有一只鹅出现了">有一只鹅出现了</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Goose</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">honk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Honk"</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它希望自己像一个 Quackable。所以我们利用<strong>适配器模式</strong>，将鹅适配成 Quackable。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GooseAdapter</span> <span class="keyword">implements</span> <span class="title">Quackable</span> </span>&#123;</span><br><span class="line">    Goose goose;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GooseAdapter</span><span class="params">(Goose goose)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.goose = goose;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        goose.honk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DuckSimulator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DuckSimulator simulator = <span class="keyword">new</span> DuckSimulator();</span><br><span class="line">        simulator.simulate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">simulate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Quackable duckCall = <span class="keyword">new</span> DuckCall();</span><br><span class="line">        Quackable rubberDuck = <span class="keyword">new</span> RubberDuck();</span><br><span class="line">        Quackable gooseDuck = <span class="keyword">new</span> GooseAdapter(<span class="keyword">new</span> Goose());  <span class="comment">// 鹅出现</span></span><br><span class="line"></span><br><span class="line">        simulate(mallardDuck);</span><br><span class="line">        simulate(duckCall);</span><br><span class="line">        simulate(rubberDuck);</span><br><span class="line">        simulate(gooseDuck);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">simulate</span><span class="params">(Quackable duck)</span> </span>&#123;</span><br><span class="line">        duck.quack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ java DuckSimulator</span><br><span class="line">Quack</span><br><span class="line">Kwak</span><br><span class="line">Squeak</span><br><span class="line">Honk</span><br></pre></td></tr></table></figure><h1 id="计算呱呱家次数">计算呱呱家次数</h1><p>呱呱叫学家决定要计算呱呱叫声的次数。所以我们使用<strong>装饰者模式</strong>，添加一个名为 QuackCounter 的装饰者。它用来追踪 <code>quack()</code> 被调用的次数，并将调用委托给它所装饰的 Quackable 对象。通过把鸭子包装进装饰者对象，给鸭子一些新行为（计算次数）。我们不必修改鸭子的代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuackCounter</span> <span class="keyword">implements</span> <span class="title">Quackable</span> </span>&#123;</span><br><span class="line">    Quackable duck;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> numberOfQuacks;  <span class="comment">// 利用静态变量追踪所有呱呱叫次数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QuackCounter</span> <span class="params">(Quackable duck)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.duck = duck;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        duck.quack();</span><br><span class="line">        numberOfQuacks++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getQuacks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numberOfQuacks;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DuckSimulator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DuckSimulator simulator = <span class="keyword">new</span> DuckSimulator();</span><br><span class="line">        simulator.simulate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">simulate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Quackable mallardDuck = <span class="keyword">new</span> QuackCounter(<span class="keyword">new</span> MallardDuck());</span><br><span class="line">        Quackable duckCall = <span class="keyword">new</span> QuackCounter(<span class="keyword">new</span> DuckCall());</span><br><span class="line">        Quackable rubberDuck = <span class="keyword">new</span> QuackCounter(<span class="keyword">new</span> RubberDuck());  <span class="comment">// 装饰所有鸭子</span></span><br><span class="line">        Quackable gooseDuck = <span class="keyword">new</span> GooseAdapter(<span class="keyword">new</span> Goose());  <span class="comment">// 鹅就算了</span></span><br><span class="line"></span><br><span class="line">        simulate(mallardDuck);</span><br><span class="line">        simulate(duckCall);</span><br><span class="line">        simulate(rubberDuck);</span><br><span class="line">        simulate(gooseDuck);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"The ducks quacked "</span> + QuackCounter.getQuacks()</span><br><span class="line">            + <span class="string">" times"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">simulate</span><span class="params">(Quackable duck)</span> </span>&#123;</span><br><span class="line">        duck.quack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ java DuckSimulator</span><br><span class="line">Quack</span><br><span class="line">Kwak</span><br><span class="line">Squeak</span><br><span class="line">Honk</span><br><span class="line">The ducks quacked 3 times</span><br></pre></td></tr></table></figure><h1 id="呱呱叫学家担心忘记计数">呱呱叫学家担心忘记计数</h1><p>我们需要一些质量控制来确保鸭子一定是被包装起来的。我们要建造一个工厂，创建装饰过的鸭子。此工厂应该生产各种不同类型的鸭子的产品家族，所以我们要用<strong>抽象工厂模式</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDuckFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Quackable <span class="title">createMallardDuck</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Quackable <span class="title">createDuckCall</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Quackable <span class="title">createRubberDuck</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DuckFactory</span> <span class="keyword">extends</span> <span class="title">AbstractDuckFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Quackable <span class="title">createMallardDuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MallardDuck();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Quackable <span class="title">createDuckCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DuckCall();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Quackable <span class="title">createRubberDuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RubberDuck();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountingDuckFactory</span> <span class="keyword">extends</span> <span class="title">AbstractDuckFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Quackable <span class="title">createMallardDuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> QuackCounter(<span class="keyword">new</span> MallardDuck());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Quackable <span class="title">createDuckCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> QuackCounter(<span class="keyword">new</span> DuckCall());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Quackable <span class="title">createRubberDuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> QuackCounter(<span class="keyword">new</span> RubberDuck());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DuckSimulator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DuckSimulator simulator = <span class="keyword">new</span> DuckSimulator();</span><br><span class="line">        AbstractDuckFactory duckFactory = <span class="keyword">new</span> CountingDuckFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过传入不同的工厂，我们就会得到不同的产品家族</span></span><br><span class="line">        simulator.simulate(duckFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">simulate</span><span class="params">(AbstractDuckFactory duckFactory)</span> </span>&#123;  <span class="comment">// 需要一个工厂作为参数</span></span><br><span class="line">        Quackable mallardDuck = duckFactory.createMallardDuck();</span><br><span class="line">        Quackable duckCall = duckFactory.createDuckCall();</span><br><span class="line">        Quackable rubberDuck = duckFactory.createRubberDuck();  <span class="comment">// 使用工厂生产鸭子</span></span><br><span class="line">        Quackable gooseDuck = <span class="keyword">new</span> GooseAdapter(<span class="keyword">new</span> Goose());  <span class="comment">// 鹅就算了</span></span><br><span class="line"></span><br><span class="line">        simulate(mallardDuck);</span><br><span class="line">        simulate(duckCall);</span><br><span class="line">        simulate(rubberDuck);</span><br><span class="line">        simulate(gooseDuck);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"The ducks quacked "</span> + QuackCounter.getQuacks()</span><br><span class="line">            + <span class="string">" times"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">simulate</span><span class="params">(Quackable duck)</span> </span>&#123;</span><br><span class="line">        duck.quack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ java DuckSimulator</span><br><span class="line">Quack</span><br><span class="line">Kwak</span><br><span class="line">Squeak</span><br><span class="line">Honk</span><br><span class="line">The ducks quacked 3 times</span><br></pre></td></tr></table></figure><p>我们仍然依赖具体类来直接实例化鹅。你能够为鹅写一个抽象工厂吗？创建“内鹅外鸭”的对象时，你怎么处理？</p><h1 id="又是鸭子又是鹅">又是鸭子又是鹅</h1><p>我们需要将鸭子视为一个集合，甚至是子集合（subcollection），如果我们一次命令，就能让整个鸭子听命行事，那就太好了。<strong>组合模式</strong>允许我们像对待单个对象一样对待对象集合。</p><p>我们孩偷偷用了<strong>迭代器模式</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Flock</span> <span class="keyword">implements</span> <span class="title">Quackable</span> </span>&#123;</span><br><span class="line">    ArrayList quackers = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Quackable quacker)</span> </span>&#123;</span><br><span class="line">        quackers.add(quacker);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterator iterator = quackers.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Quackable quacker = (Quackable)iterator.next();</span><br><span class="line">            quacker.quack();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DuckSimulator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DuckSimulator simulator = <span class="keyword">new</span> DuckSimulator();</span><br><span class="line">        AbstractDuckFactory duckFactory = <span class="keyword">new</span> CountingDuckFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过传入不同的工厂，我们就会得到不同的产品家族</span></span><br><span class="line">        simulator.simulate(duckFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">simulate</span><span class="params">(AbstractDuckFactory duckFactory)</span> </span>&#123;</span><br><span class="line">        Quackable mallardDuck = duckFactory.createMallardDuck();</span><br><span class="line">        Quackable duckCall = duckFactory.createDuckCall();</span><br><span class="line">        Quackable rubberDuck = duckFactory.createRubberDuck();  <span class="comment">// 使用工厂生产鸭子</span></span><br><span class="line">        Quackable gooseDuck = <span class="keyword">new</span> GooseAdapter(<span class="keyword">new</span> Goose());  <span class="comment">// 鹅就算了</span></span><br><span class="line"></span><br><span class="line">        Flock flockOfDucks = <span class="keyword">new</span> Flock();  <span class="comment">// 主群</span></span><br><span class="line">        flockOfDucks.add(mallardDuck);</span><br><span class="line">        flockOfDucks.add(duckCall);</span><br><span class="line">        flockOfDucks.add(rubberDuck);</span><br><span class="line"></span><br><span class="line">        Flock flockOfGooses = <span class="keyword">new</span> Flock();  <span class="comment">// 子群：鹅群</span></span><br><span class="line">        flockOfGooses.add(<span class="keyword">new</span> GooseAdapter(<span class="keyword">new</span> Goose()));</span><br><span class="line">        flockOfGooses.add(<span class="keyword">new</span> GooseAdapter(<span class="keyword">new</span> Goose()));</span><br><span class="line"></span><br><span class="line">        flockOfDucks.add(flockOfGooses);  <span class="comment">// 将鹅群加入鸭群</span></span><br><span class="line"></span><br><span class="line">        simulate(flockOfDucks);</span><br><span class="line">        System.out.println(<span class="string">"The ducks quacked "</span> + QuackCounter.getQuacks()</span><br><span class="line">            + <span class="string">" times"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">simulate</span><span class="params">(Quackable duck)</span> </span>&#123;</span><br><span class="line">        duck.quack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ java DuckSimulator</span><br><span class="line">Quack</span><br><span class="line">Kwak</span><br><span class="line">Squeak</span><br><span class="line">Honk</span><br><span class="line">Honk</span><br><span class="line">The ducks quacked 3 times</span><br></pre></td></tr></table></figure><p>安全性 vs. 透明性</p><p>你或许还记得，在组合模式章节中，组合（菜单）和叶节点（菜单项）具有一组相同的方法，其中包括了 <code>add()</code> 方法。这么设计的好处是，叶节点和组合之间是“透明的”。客户根本不用管究竟是组合节点还是叶节点，客户只是调用两者的同一个方法。</p><p>但是在这里，我们决定把组合维护孩子的方法和叶节点分开，也就是说，我们打算只让 Flock 具有 <code>add()</code> 方法。这样的设计比较“安全”，你不会调用无意义的方法，但是透明性比较差。现在，客户如果想调用 <code>add()</code>，得先确定该 Quackable 对象是 Flock 才行。</p><p>在 OO 设计的过程中，折衷一直都是避免不了的，在创建你自己的组合时，你需要考虑这些。</p><h1 id="追踪个别的鸭子">追踪个别的鸭子</h1><p>呱呱叫学家想要观察个别鸭子的行为，有一个模式可以观察对象的行为：<strong>观察者模式</strong>。</p><p>被观察者（主题）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">QuackObservable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>;  <span class="comment">// 为了保持简单，省略了删除观察者的接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Observable辅助类，这次我们通过组合的方式使用观察者模式。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span> <span class="keyword">implements</span> <span class="title">QuackObservable</span> </span>&#123;</span><br><span class="line">    ArrayList observers = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    QuackObservable duck;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Observable</span><span class="params">(QuackObservable duck)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.duck = duck;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterator iterator = observers.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Observer observer = (Observer)iterator.next();</span><br><span class="line">            <span class="comment">// 把鸭子对象传过去，好让观察者知道是哪个鸭子在呱呱叫</span></span><br><span class="line">            observer.update(duck);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察者：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(QuackObservable duck)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体的观察者：呱呱叫学家</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quackologist</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(QuackObservable duck)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Quackologist: "</span> + duck + <span class="string">" just quacked."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 确保所有的Quackable都实现此接口，所以我们干脆让Quackable来扩展此接口。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Quackable</span> <span class="keyword">extends</span> <span class="title">QuackObservable</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整合Observable辅助类和Quackable类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MallardDuck的实现，其他鸭子（包括GooseAdapter，QuackCounter）同理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MallardDuck</span> <span class="keyword">implements</span> <span class="title">Quackable</span> </span>&#123;</span><br><span class="line">    Observable observable;  <span class="comment">// 持有一个主题引用</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MallardDuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将自身传入主题</span></span><br><span class="line">        observable = <span class="keyword">new</span> Observable(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Quack"</span>);</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 委托给辅助类执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observable.registerObserver(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        observable.notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Mallard Duck"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuackCounter</span> <span class="keyword">implements</span> <span class="title">Quackable</span> </span>&#123;</span><br><span class="line">    Quackable duck;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> numberOfQuacks;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QuackCounter</span> <span class="params">(Quackable duck)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.duck = duck;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        duck.quack();</span><br><span class="line">        numberOfQuacks++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getQuacks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numberOfQuacks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 委托给鸭子</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        duck.registerObserver(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        duck.notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Flock</span> <span class="keyword">implements</span> <span class="title">Quackable</span> </span>&#123;</span><br><span class="line">    ArrayList quackers = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Quackable quacker)</span> </span>&#123;</span><br><span class="line">        quackers.add(quacker);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterator iterator = quackers.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Quackable quacker = (Quackable)iterator.next();</span><br><span class="line">            quacker.quack();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 委托给每一只鸭子（或鸭群）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        Iterator iterator = quackers.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Quackable duck = (Quackable)iterator.next();</span><br><span class="line">            duck.registerObserver(observer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterator iterator = quackers.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Quackable duck = (Quackable)iterator.next();</span><br><span class="line">            duck.notifyObservers();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DuckSimulator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DuckSimulator simulator = <span class="keyword">new</span> DuckSimulator();</span><br><span class="line">        AbstractDuckFactory duckFactory = <span class="keyword">new</span> CountingDuckFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过传入不同的工厂，我们就会得到不同的产品家族</span></span><br><span class="line">        simulator.simulate(duckFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">simulate</span><span class="params">(AbstractDuckFactory duckFactory)</span> </span>&#123;</span><br><span class="line">        Quackable mallardDuck = duckFactory.createMallardDuck();</span><br><span class="line">        Quackable duckCall = duckFactory.createDuckCall();</span><br><span class="line">        Quackable rubberDuck = duckFactory.createRubberDuck();  <span class="comment">// 使用工厂生产鸭子</span></span><br><span class="line">        Quackable gooseDuck = <span class="keyword">new</span> GooseAdapter(<span class="keyword">new</span> Goose());  <span class="comment">// 鹅就算了</span></span><br><span class="line"></span><br><span class="line">        Flock flockOfDucks = <span class="keyword">new</span> Flock();  <span class="comment">// 主群</span></span><br><span class="line">        flockOfDucks.add(mallardDuck);</span><br><span class="line">        flockOfDucks.add(duckCall);</span><br><span class="line">        flockOfDucks.add(rubberDuck);</span><br><span class="line"></span><br><span class="line">        Flock flockOfGooses = <span class="keyword">new</span> Flock();  <span class="comment">// 子群：鹅群</span></span><br><span class="line">        flockOfGooses.add(<span class="keyword">new</span> GooseAdapter(<span class="keyword">new</span> Goose()));</span><br><span class="line">        flockOfGooses.add(<span class="keyword">new</span> GooseAdapter(<span class="keyword">new</span> Goose()));</span><br><span class="line"></span><br><span class="line">        flockOfDucks.add(flockOfGooses);  <span class="comment">// 将鹅群加入鸭群</span></span><br><span class="line"></span><br><span class="line">        Quackologist quackologist = <span class="keyword">new</span> Quackologist();  <span class="comment">// 创建观察者</span></span><br><span class="line">        flockOfDucks.registerObserver(quackologist);  <span class="comment">// 观察这个族群</span></span><br><span class="line"></span><br><span class="line">        simulate(flockOfDucks);</span><br><span class="line">        System.out.println(<span class="string">"The ducks quacked "</span> + QuackCounter.getQuacks()</span><br><span class="line">            + <span class="string">" times"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">simulate</span><span class="params">(Quackable duck)</span> </span>&#123;</span><br><span class="line">        duck.quack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ java DuckSimulator</span><br><span class="line">Quack</span><br><span class="line">Quackologist: Mallard Duck just quacked.</span><br><span class="line">Kwak</span><br><span class="line">Quackologist: Duck Call just quacked.</span><br><span class="line">Squeak</span><br><span class="line">Quackologist: Rubber Duck just quacked.</span><br><span class="line">Honk</span><br><span class="line">Quackologist: Goose pretending to be a Duck just quacked.</span><br><span class="line">Honk</span><br><span class="line">Quackologist: Goose pretending to be a Duck just quacked.</span><br><span class="line">The ducks quacked 3 times</span><br></pre></td></tr></table></figure><h1 id="问答">问答</h1><ul><li><p><strong>问</strong>：这就是复合模式？</p><p><strong>答</strong>：不，这只是一群模式携手合作。所谓的复合模式，是指一群模式被结合起来使用，以解决<strong>一般性问题</strong>。复合模式是由数个模式结合起来而形成的模式，<strong>一再地被用于解决许多设计问题</strong>。例如，大名鼎鼎的 Model-View-Controllor（模型-视图-控制器）模式。</p></li><li><p><strong>问</strong>：所以，设计模式真正漂亮的地方在于，遇到问题时，我可以拿模式逐一地解决问题，直到所有的问题都被解决。我这样说对吗？</p><p><strong>答</strong>：错！有时候，用好 OO 设计原则就可以解决问题，这其实就够了。采用模式时必须要考虑到这么做是否有意义。绝对不能为了使用模式而使用模式。有了这样的观念，鸭子模拟器的设计看起来就显得做作。</p></li></ul><h1 id="模型-视图-控制器">模型-视图-控制器</h1><img src="http://www.plantuml.com/plantuml/svg/NLB9Ki904Btp5LFSiShjmi4luM8f1wimM89wdI1OGI0HLnOL4IEvA9HBW4JYnvZk6Kx-WfCCudB98VssVjEPx6esIQAyUm1DBqfMCsHt8xaN9-pKmYiJgXhJ-sYruRhqGNCIDQ4D60vPyoMXe6xwhYxd_l01Z7FmBk1nVt99-RsADO_TEGc5DVBiq4Qg-aCTp_fOUHHQaOnqHhqBcWrrApHVIolPxNGgbToE4waM1D46Ge9x9r0mOMJpReVtt8G21Hjw8sakvfWta5xzLWudeUncUZsPYXFv1yigNXQnICKtu4qJgJAZq3qkCwi4ZZ6XBlUgGd7AUse7l6TBE0cKrfTr2FXiXy-tCg-FMTuM7Q1nb51yh-ax1tXIOSvh0EnGzd8hZG9htGIZ8qX2RcI3KPryfy3J4HWrqJHhcSojysuEUYrE2y5wmGEHsCvMRELFNVDpH7O5QWDRHxvh-qufyeCWCK6O5h4mHwI3TFkFaYUm-0sIxnW9kMGsNX9ZhGg39-OQ4YSsdOQR6Is787aE_lZcvnBUswZslW00"><p><strong>问</strong>：控制器可以变成模型的观察者吗？</p><p><strong>答</strong>：当然。在某些设计中，控制器会向模型注册，模型一有改变就通知控制器。当模型直接影响到用户界面时，就会这么做。比方说，模型内的某些状态可以支配界面的某些项目变成有效或者无效，如果这样，要求视图更新相应显示其实就是控制器的事。</p><h1 id="mvc-中的模式">MVC 中的模式</h1><p>模型实现了<strong>观察者模式</strong>，当状态改变时，相关对象将持续更新。使用观察者模式可以让模型完全独立于视图和控制器，同一个模型可以使用不同的视图，甚至可以同时使用多个视图。</p><p>视图内部使用<strong>组合模式</strong>来管理窗口、按钮以及其他显示组件。每个显示组件如果不是组合节点，就是叶节点。当控制器告诉视图更新时，只需告诉视图最顶层的组件即可，组合会处理其余的事。</p><p>视图和控制器实现了经典的<strong>策略模式</strong>：视图是一个对象，可以被调整使用不同的策略（换一个控制器），而控制器提供了策略。视图只关心系统中可视的部分，对于任何界面行为，都委托给控制器处理。使用策略模式也可以让视图和模型之间的关系解耦，因为控制器负责和模型交互来传递用户的请求。对于工作是怎么完成的，视图毫不知情。</p><p>这些模式携手合作，把 MVC 模型的三层解耦，这样可以保持设计干净又有弹性。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Head First Design Patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Recover Binary Search Tree</title>
      <link href="/programming/leetcode/recover-binary-search-tree/"/>
      <url>/programming/leetcode/recover-binary-search-tree/</url>
      
        <content type="html"><![CDATA[<p>Two elements of a binary search tree (BST) are swapped by mistake.</p><p>Recover the tree without changing its structure.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">   1</span><br><span class="line">  /</span><br><span class="line"> 3</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">   3</span><br><span class="line">  /</span><br><span class="line"> 1</span><br><span class="line">  \</span><br><span class="line">   2</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">1   4</span><br><span class="line">   /</span><br><span class="line">  2</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">1   4</span><br><span class="line">   /</span><br><span class="line">  3</span><br></pre></td></tr></table></figure><p>Follow up:</p><ul><li>A solution using <code>O(n)</code> space is pretty straight forward.</li><li>Could you devise a constant space solution?</li></ul><h1 id="using-inorder-traversal">Using inorder traversal</h1><p>It would be very easy if you think about this problem:</p><p>Two elements in a sorted array are swapped by mistake, design an algorithm to fix it.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1, 2, 23, 8, 9, 11, 5, 25</span><br><span class="line">      ^             ^</span><br><span class="line">23 &gt; 8: this is the first wrong location</span><br><span class="line">11 &gt; 5: this is the second wrong location</span><br></pre></td></tr></table></figure><p>We can fit the sorted array by swap 23 (the first element on the first wrong location) and 5 (the second element on the second wrong location).</p><p>And there is a special case, only one wrong location exists. In this case, sorted array can be fixed by swap that two elements.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1, 2, 5, 9, 8, 11, 23, 25</span><br><span class="line">         ^  ^</span><br><span class="line">9 &gt; 8</span><br></pre></td></tr></table></figure><a id="more"></a><p>Now, BST can be fixed by similar procedure as long as you know <strong>the inorder traversal</strong> of a BST gives a sorted list.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recoverTree</span><span class="params">(self, root: TreeNode)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.first = self.second = self.prev = <span class="literal">None</span></span><br><span class="line">        self.inOrder(root)</span><br><span class="line">        <span class="keyword">if</span> self.first <span class="keyword">and</span> self.second:</span><br><span class="line">            self.first.val, self.second.val = self.second.val, self.first.val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inOrder</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.inOrder(node.left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.prev:</span><br><span class="line">            <span class="keyword">if</span> node.val &lt;= self.prev.val:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> self.first:</span><br><span class="line">                    self.first = self.prev</span><br><span class="line">                self.second = node</span><br><span class="line"></span><br><span class="line">        self.prev = node  <span class="comment"># record node after visit</span></span><br><span class="line">        self.inOrder(node.right)</span><br></pre></td></tr></table></figure><h1 id="using-morris-traversal">Using morris traversal</h1><p>Of course you can use stack instead of recursion, which make algorithm a little bit faster. But also takes <code>O(n)</code> time complexity. A constant space solution can be realized by using Morris Traversal. See section &quot;Smarter morris traversal&quot; in <a href="/programming/leetcode/binary-tree-traversal/" title="Binary Tree Traversal">Binary Tree Traversal</a> for more details.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recoverTree</span><span class="params">(self, root: TreeNode)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        first = second = prev = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># morris traversal</span></span><br><span class="line">        curr = root</span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            <span class="keyword">if</span> curr.left:</span><br><span class="line">                p = curr.left</span><br><span class="line">                <span class="keyword">while</span> p.right <span class="keyword">and</span> p.right != curr:</span><br><span class="line">                    p = p.right</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> p.right:</span><br><span class="line">                    p.right = curr</span><br><span class="line">                    curr = curr.left</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    p.right = <span class="literal">None</span></span><br><span class="line">            <span class="comment"># compare value when visit a node</span></span><br><span class="line">            <span class="keyword">if</span> prev <span class="keyword">and</span> curr.val &lt;= prev.val:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> first:</span><br><span class="line">                    first = prev</span><br><span class="line">                second = curr</span><br><span class="line">            <span class="comment"># visit next</span></span><br><span class="line">            prev = curr</span><br><span class="line">            curr = curr.right</span><br><span class="line"></span><br><span class="line">        <span class="comment"># fix BST</span></span><br><span class="line">        <span class="keyword">if</span> first <span class="keyword">and</span> second:</span><br><span class="line">            first.val, second.val = second.val, first.val</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> leetcode </tag>
            
            <tag> traversal </tag>
            
            <tag> morris </tag>
            
            <tag> inorder </tag>
            
            <tag> BST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>保护代理</title>
      <link href="/notes/head-first-design-patterns/protection-proxy/"/>
      <url>/notes/head-first-design-patterns/protection-proxy/</url>
      
        <content type="html"><![CDATA[<h1 id="java-动态代理">Java 动态代理</h1><p>Java 在 <code>java.lang.reflect</code> 包中有自己的代理支持，利用这个包你可以在运行时动态地创建一个代理类，实现一个或多个接口，并将方法的调用转发到你所指定的类。因为实际代理类是在运行时创建的，我们称这个 Java 技术为：动态代理。</p><p>就和真实世界中大多数的事物一样，它和代理模式的传统定义有一点出入。</p><img src="http://www.plantuml.com/plantuml/svg/VP4zJy906CVtVeeBamwG22lfB4v6Ht4uoXcgxO7jGIH8GaGO3066OWmQ9GAHI4I83fKNlupN5YU_WgKKhE5bVPxV_L-UY_1X190O8qaW8Z6492OocN2yn0c8uJ51qX7a4DYFXuuHHu3VFv-nB4Wn0AHWI2OIv4WQIEWqZcIoiSca7Ky3E17b8E6ZU1lYi82azIAyYPyWIuCJe2o3FGI5cVs4TRfCYLqfUfPSiLjm3uWnmM8THlDsvnxFLEt_o161ML9dWYprOQR9tEoAjREQ-y2yV1ZXGzPEWAC40HSTr8rotYXsjRkMLiXfvJPL6rHzDdg3hyo52q0Pu2sRjTxfDw-6qjk12KZxJuRoO5GlVuQ581vd2bHLjCwzgKNxUQrJq2llvZA8xGHwiQcLwdDHxop0gAQNolJpTg629MjvKlNALAA30HrLzEiF_QqoxcODfHN4tzaH7LR7Zsqwh6cvflxIS0RtsGSoxsUMMFvLqzqVvrt3-Nu1"><p>因为 Java 已经为你创建了 Proxy 类，所以你需要有办法来告诉 Proxy 类你要做什么。你不能像以前一样把代码放在 Proxy 类中，因为 Proxy 不是你直接实现的。要把代码放在 InvocationHandler 中。InvocationHandler 的工作是相应代理的任何调用。你可以把 InvocationHandler 想成是代理收到方法调用后，请求做实际工作的对象。</p><a id="more"></a><h1 id="导入对象村的配对">导入：对象村的配对</h1><p>你负责帮对象村实现约会服务系统。你的服务系统涉及到一个 Person bean，允许设置或取得一个人的信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonBean</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getGender</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getInterests</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHotOrNotRating</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setGender</span><span class="params">(String gender)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setInterests</span><span class="params">(String interests)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setHotOrNotRating</span><span class="params">(<span class="keyword">int</span> rating)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonBeanImpl</span> <span class="keyword">implements</span> <span class="title">PersonBean</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 其他变量</span></span><br><span class="line">    <span class="keyword">int</span> rating;</span><br><span class="line">    <span class="keyword">int</span> ratingCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHotOrNotRating</span><span class="params">()</span> </span>&#123;  <span class="comment">// 计算平均值</span></span><br><span class="line">        <span class="keyword">if</span> (ratingCount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (rating/ratingCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHotOrNotRating</span><span class="params">(<span class="keyword">int</span> rating)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rating += rating;</span><br><span class="line">        ratingCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们的约会服务中，我们希望顾客可以设置自己的信息，同时又防止他人更改这些信息。HotOrNot 评分则相反，你不能更改自己的评分，但是他人可以设置你的评分。我们在 PersonBean 中已经有许多 getter 方法了，每个方法都是公开的，任何顾客都可以调用它们。</p><h1 id="为-personbean-创建动态代理">为 PersonBean 创建动态代理</h1><p>我们有一些问题要修正：顾客不可以改变自己的 HotOrNot 评分，也不可以改变其他顾客的个人信息。要修正这些问题，你必须创建两个代理：一个访问你自己的 PersonBean 对象，另一个访问另一顾客的 PersonBean 对象。这样，代理就可以控制在每一种情况下允许哪一种请求。</p><h2 id="创建-invocationhandler">创建 InvocationHandler</h2><p>我们需要写两个 InvocationHandler（调用处理器），其中一个给拥有者使用，另一个给非拥有者使用。当代理的方法被调用时，代理就会把这个调用转发给 InvocationHandler。InvocationHandler 接口只有一个名为 <code>invoke()</code> 的方法，不管代理别调用的是何种方法，处理器被调用的一定是 <code>invoke()</code> 方法。让我们看看这是如何工作的：</p><ol type="1"><li>假设 proxy 的 <code>setHotOrNotRating()</code> 方法被调用。</li><li>proxy 会接着调用 InvocationHandler 的 <code>invoke()</code> 方法。</li><li>handler 决定要如何处置这个请求。</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy.setHotOrNotRating(9);</span><br><span class="line"></span><br><span class="line">// proxy 对象被传入 proxy</span><br><span class="line">// setHotOrNotRating 方法对象被传入 method</span><br><span class="line">// 参数 9 被传入 args</span><br><span class="line"></span><br><span class="line">invoke(Object proxy, Method method, Object[] args) &#123;</span><br><span class="line">  return method.invoke(person, args);   // 在person对象上调用method代表的方法，参数为args</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>OwnerInvocationHandler.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OwnerInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    PersonBean person;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OwnerInvocationHandler</span><span class="params">(PersonBean person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String name = method.getName();</span><br><span class="line">            <span class="keyword">if</span> (name.equals(<span class="string">"setHotOrNotRating"</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalAccessException();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.startsWith(<span class="string">"set"</span>) || name.startsWith(<span class="string">"get"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> method.invoke(person, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  <span class="comment">// 如果调用其他方法，一律不理，返回null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建-proxy-类并实例化-proxy-对象">创建 Proxy 类并实例化 Proxy 对象</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">PersonBean <span class="title">getOwnerProxy</span><span class="params">(PersonBean person)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (PersonBean) Proxy.newProxyInstance(  <span class="comment">// 利用Proxy的静态方法创建代理</span></span><br><span class="line">      person.getClass().getClassLoader(),  <span class="comment">// 将PersonBean的类载入器当作参数...</span></span><br><span class="line">      person.getClass().getInterfaces(),   <span class="comment">// 代理需要实现的接口...</span></span><br><span class="line">      <span class="keyword">new</span> OwnerInvocationHandler(person)   <span class="comment">// 自定义的调用处理器</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PersonBean <span class="title">getNonOwnerProxy</span><span class="params">(PersonBean person)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (PersonBean) Proxy.newProxyInstance(</span><br><span class="line">        person.getClass().getClassLoader(),</span><br><span class="line">        person.getClass().getInterfaces(),</span><br><span class="line">        <span class="keyword">new</span> NonOwnerInvocationHandler(person)  <span class="comment">// 细微区别在于handler</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试配对服务">测试配对服务</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MatchMakingTestDrive</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MatchMakingTestDrive().drive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PersonBean joe = <span class="keyword">new</span> PersonBeanImpl();</span><br><span class="line">        joe.setName(<span class="string">"joe"</span>);</span><br><span class="line">        PersonBean jane = <span class="keyword">new</span> PersonBeanImpl();</span><br><span class="line">        jane.setName(<span class="string">"jane"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自己是joe</span></span><br><span class="line">        PersonBean ownerProxy = getOwnerProxy(joe);</span><br><span class="line">        PersonBean nonOwnerProxy = getNonOwnerProxy(jane);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试getter，不打印内容</span></span><br><span class="line">        ownerProxy.getName();</span><br><span class="line">        ownerProxy.getHotOrNotRating();</span><br><span class="line">        nonOwnerProxy.getName();</span><br><span class="line">        nonOwnerProxy.getHotOrNotRating();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试ownerProxy</span></span><br><span class="line">        ownerProxy.setName(<span class="string">"Joe"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ownerProxy.setHotOrNotRating(<span class="number">9</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Can't set rating from owner proxy"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试nonOwnerProxy</span></span><br><span class="line">        nonOwnerProxy.setHotOrNotRating(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            nonOwnerProxy.setName(<span class="string">"Demon"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Can't set name from non owner proxy"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">PersonBean <span class="title">getOwnerProxy</span><span class="params">(PersonBean person)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 省略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">PersonBean <span class="title">getNonOwnerProxy</span><span class="params">(PersonBean person)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ java MatchMakingTestDrive</span><br><span class="line">Can&apos;t set rating from owner proxy</span><br><span class="line">Can&apos;t set name from non owner proxy</span><br></pre></td></tr></table></figure><h1 id="类图约会系统设计">类图：约会系统设计</h1><img src="http://www.plantuml.com/plantuml/svg/bL9DJy904BttLynH3vIx8JruaWjo5mzBEz16kakswmU19eI8uS21HC54kH0k64sCCI61XlXZR4lz5u8OBC4Y7kVDUs_UpAvkQ0Xe5aK9J3Ipo2LzZgW6Lmie6LGWpn4L8OtSOdGV2OL4OWah2fGbW3B9Me8JLTYGHv4Y9kxihi9M63PHw4op8Hu7hpvqdOxV6VclRSaEpKlICwOIOJ1wGAXMGBvvh36ZdypjRKaj4Ck2mtEAVDraBWkjiYPBCVflPVWq5Lc6D6SNfNLqMIVDOa7wPR-AV5gK8u97yoCJIryvG9OL-9EmmMGbDYHYCTYUkRLjx6ZswpIanyhtzQBV8KIDyAPC870ZhmjWkONV7dZTGV3M2dfD_tReDUuzP-mw_Mdhoky-1UF7zsejGxt6m_Hcy56jUPFhwTtbekyrwq6_dg6kuxYJzazixtaKlFHckay0"><h1 id="问答">问答</h1><ul><li><p><strong>问</strong>：到底“动态代理”动态在哪里？是不是指在运行时才将它实例化并和 handler 联系起来？</p><p><strong>答</strong>：不是的。动态代理之所以被称为动态，是因为运行时才将它的类<strong>创建</strong>出来。代码开始执行时，还没有 Proxy 类，它是根据需要从你传入的接口集创建的。</p></li><li><p><strong>问</strong>：有没有办法知道某个类是不是代理类呢？</p><p><strong>答</strong>：可以。代理类有一个静态方法，叫做 <code>isProxyClass()</code>。此方法的返回值如果为 true，表示这是一个动态代理类。</p></li><li><p><strong>问</strong>：对于我能传入 <code>newProxyInstance()</code> 的接口类型，有没有什么限制？</p><p><strong>答</strong>：是有一些限制。首先，我们总是传给 <code>newProxyInstance()</code> 一个接口数组，此数组内只能有接口，不能有类。如果接口不是 public，就必须属于同一个 package，不同的接口内不可以有名称和参数完全一样的方法。还有一些比较细微的限制，你应该好好研读一下 javadoc 的文件。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Head First Design Patterns </tag>
            
            <tag> dynamic proxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟代理</title>
      <link href="/notes/head-first-design-patterns/virtual-proxy/"/>
      <url>/notes/head-first-design-patterns/virtual-proxy/</url>
      
        <content type="html"><![CDATA[<h1 id="导入显示-cd-封面">导入：显示 CD 封面</h1><p>我们打算建立一个应用程序，用来战羡你最喜欢的 CD 封面。如果你使用 Swing，可以创建一个 Icon 接口从网络上加载图像。唯一的问题是，<strong>限于连接带宽和网络负载，下载可能需要一些时间，所以在等待图像加载的时候，应该显示一些东西。我们也不希望在等待图像时真个应用程序被挂起</strong>。一旦图像被加载完成，刚才显示的东西应该消失，图像显示出来。</p><p>想做到这样，简单的方式就是利用虚拟代理。虚拟代理可以代理 Icon，管理背景的加载，并在加载未完成时显示“CD 封面加载中，请稍候……”，一旦加载完成，代理就把显示的职责委托给 Icon。</p><img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYoW2996SM9UUaScNcbQGMfIKcfofu9kVdATZOm0Nix1IgkHGKgXEJYakA4fDBQXNIKqj0Yi8pKqeoD3InodcaPgPdbA1B5YG2JGL90oLgkP9p4ekB5Jnp4zDJmNQ2RC4m6jCyd8O45ELNL99d2iJFDNfw2EUWYu5DvqAuraONITnAeRWqAIirkOGhBxyaLI4dDQr48JyD79HM2Y_sptmsOtrmUMPU-lDPBI2nPtrBd_OlVh-d9oRlwPmLpwUiUDQn_VdKdfTp5ptPqVLinhxdItOzdRtlQNF_uuOcD1DXzbifP2MM9LRe5OECrOCBWyryigFXoOvLoEO0xNs-SJVSj29GCC2DW_e0uind7HEVx5u3LFzaz-Bd4zg0MW00"><a id="more"></a><h1 id="编写-imageproxy">编写 ImageProxy</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageProxy</span> <span class="keyword">implements</span> <span class="title">Icon</span> </span>&#123;  <span class="comment">// 实现Icon接口</span></span><br><span class="line">    ImageIcon imageIcon;    <span class="comment">// 真正的图像</span></span><br><span class="line">    URL imgaeURL;</span><br><span class="line">    Thread retrievalThread;</span><br><span class="line">    <span class="keyword">boolean</span> retrieving = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageProxy</span><span class="params">(URL url)</span> </span>&#123;  <span class="comment">// 将图像URL传入构造器</span></span><br><span class="line">        imgaeURL = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIconWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (imageIcon != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> imageIcon.getIconWidth();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">800</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIconHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (imageIcon != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> imageIcon.getIconHeight();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">600</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当需要绘制图像时，调用此方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paintIcon</span><span class="params">(<span class="keyword">final</span> Component c, Graphics g, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (imageIcon != <span class="keyword">null</span>) &#123;     <span class="comment">// 如果已经有icon，告诉它画出自己</span></span><br><span class="line">            imageIcon.paintIcon(c, g, x, y);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            g.drawString(<span class="string">"Loading CD cover, please wait..."</span>, x+<span class="number">300</span>, y+<span class="number">190</span>);</span><br><span class="line">            <span class="keyword">if</span> (!retrieving) &#123;</span><br><span class="line">                retrieving = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 我们不希望挂起整个用户界面，所以用另一个线程取出图像。</span></span><br><span class="line">                retrievalThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            imageIcon = <span class="keyword">new</span> ImageIcon(imgaeURL, <span class="string">"CD cover"</span>);</span><br><span class="line">                            <span class="comment">// 当图像准备好时，我们告诉Swing，需要重绘。</span></span><br><span class="line">                            c.repaint();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                retrievalThread.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="http://www.plantuml.com/plantuml/svg/AyxEp2j8B4hCLN3AhmX8J4d9p4jNC3JWAeQB1-MNvgKuvnVbfHOfc78bvLSeA3ddPARcbIXn0HMKP2Pd5YJcbIX0n524F7CJqrC3Yl8hAZ65FPFpyxXIyr8KW0P230KBAmId5fMb5g4Q3H63guROfA1hXsI1bK91OcPU2SXK3KsO2XjT51NFPknxlcJNeuOvJxiMlDYxzycEjOyQvZxRrl6iSJqNGXtSN91PLWfFryrxig_xQSyqXAiJaqioon9BKf4y0cU1T4ES2zJQF-tfx7rFc_kHf85EGf6U1rM1vcA8tSXUoii7MfWFr8ZYfQTpLi3LlrYq-cd7xAUxTpsTqFT-JqzCtfCTtS_MB7oneVdvb1LFEpOWcVPi-ZQ8YjsBdqzeUxfXuzFbKvvrpe0RfQ7vOl_i5mjx7ZSq4H7QECCEJvHWA000"><h1 id="问答">问答</h1><ul><li><p><strong>问</strong>：对我来说，远程服务器和虚拟服务器差异非常大，它们真的是一个模式吗？</p><p><strong>答</strong>：在真实的世界中，代理模式有许多变体，这些变体都有共通点：都会将客户对主题（Subject）施加的方法调用拦截下来。这种间接的级别让我们可以做许多事，包括将请求分发到远程主题；给创建开销大的对象提供代表；提供某些级别的保护，这种保护能决定哪些客户能调用哪些方法……一般的代理形式还可以以许多形式使用。</p></li><li><p><strong>问</strong>：ImageProxy 在我看来好像是 Decorator（装饰者）。我的意思是，我们基本上都是用一个对象把另一个对象包起来，然后把调用委托给 ImageIcon。我这样说有什么问题吗？</p><p><strong>答</strong>：有时候这两者的确看起来很像，但是<strong>它们的目的是不一样的。装饰者为对象增加行为，而代理是控制对象的访问</strong>。你可能会说：“显示‘加载中’消息，难道就不是在增加行为？”，从某方面来说，这的确可以算是，但是，更重要的，ImageProxy 是控制 ImageIcon 的访问，如何控制呢？试想：代理将客户从 ImageIcon 解耦了，如果它们之间没有解耦，客户就必须等到每幅图像都被取回，然后才能把它绘制在界面上。代理控制 ImageIcon 的访问，以便在图像完全创建之前提供屏幕上的代表。一旦 ImageIcon 被创建，代理就允许访问 ImageIcon。</p></li><li><p><strong>问</strong>：我要如何让客户使用代理，而不是真正的对象？</p><p><strong>答</strong>：好问题，一个常用的技巧是提供一个工厂，实例化并返回主题。因为这是在工厂方法内发生的，我们可以用代理包装主题再返回，而客户不知道也不在乎他使用的是代理还是真东西。</p></li><li><p><strong>问</strong>：代理和适配器也很类似。</p><p><strong>答</strong>：代理和适配器都是挡在其他对象的前面，并负责将请求转发给它们。适配器会改变对象适配的接口，而代理则实现相同的接口。</p><p>有一个额外相似性牵涉到保护代理（Protection Proxy）。保护代理可以根据客户的角色来决定是否允许客户访问特定的方法。所以保护代理可能只提供给客户部分接口，这就和某些适配器很相像了。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Head First Design Patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>远程代理</title>
      <link href="/notes/head-first-design-patterns/remote-proxy/"/>
      <url>/notes/head-first-design-patterns/remote-proxy/</url>
      
        <content type="html"><![CDATA[<h1 id="导入糖果机状态监视器">导入：糖果机状态监视器</h1><p>糖果公司 CEO 需要在远程监控糖果机。我们已经得到了可以取得糖果数量的 <code>getCount()</code> 方法和取得糖果机状态的 <code>getState()</code> 方法。我们所需要做的事，就是创建一份能打印出来的报告，然后把它递送给 CEO。让我们现在就开始编码。</p><p>先为 GumballMachine 加上处理位置的支持：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GumballMachine</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 其他实例变量</span></span><br><span class="line">    String location;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GumballMachine</span><span class="params">(String location, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构造器内的其他代码</span></span><br><span class="line">        <span class="keyword">this</span>.location = location;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter等其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建另一个类：GumballMonitor（糖果监视器），以便取得机器的位置、糖果的库存量以及当前机器的状态，并打印成一份可爱的报告。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GumballMonitor</span> </span>&#123;</span><br><span class="line">    GumballMachine machine;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GumballMonitor</span><span class="params">(GumballMachine machine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.machine = machine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 打印报告</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们给 GumballMonitor 一个糖果机的引用，它给我们一份报告。<strong>问题在于监视器和糖果机必须在同一个 JVM 上面执行，但是 CEO 希望在他的桌面上远程监控这些机器</strong>。你不能取得另一个堆的对象的引用，换句话说，你不可以这么写：<code>Duck d = &lt;另一个堆的对象&gt;</code>。变量 d 只能引用当前代码语句的同一堆空间的对象。那该怎么办？</p><p>我们需要<strong>远程代理</strong>（remote proxy）。所谓的代理，就是代表某个真实的对象。在这个案例中，代理就像是糖果机一样，但其实幕后是它利用网络和一个远程的真正糖果机沟通。</p><a id="more"></a><h1 id="远程方法-101">远程方法 101</h1><p>假如我们想要设计一个系统，能够调用本地对象，然后将每个请求转发到远程对象上进行。要如何设计？我们需要一些辅助对象，帮我们真正进行沟通。这些辅助对象使客户就像在调用本地对象的方法（事实也是如此）一样。客户调用客户辅助对象上的方法，仿佛客户辅助对象就是真正的服务。客户辅助对象再负责为我们转发这些请求。</p><img src="http://www.plantuml.com/plantuml/svg/RP5DIm916CVlyoa6JtKGwj15eeETEWXXtMDr1rtAcMLs3RrjcQ9IK6YHPP85OH5PU4XPqEzYExFxCHhSTNNLupppU_ulCzgnWbM9IXaO9RbzIPOLd8AR6q3pvt6InV8keHXHk0Mah4vmDfD052H83eROrmil_xBdKWW8N5UIYYfXtPzt1yvFEmGb3IPF58JrLP0pBBBg-nogKfBB0uHbA2nS6zwyOjKsQtIMdUAnFKXHIj5qcf-iJmz1p5LOyj8GFKNqA8rEL55fnSOIwmV3H4UGY8aRE0ATKOFVTtdvnZ8_xOSBotorhqj_nZbmkyFmZfyj0bdNv9NXs6Z6yWSJtR7n12P2S3iynpcZEdjikLfpGfwbJA9AwZ0jFcrjtTiMbu5IaUaxyqBFUJjplWjslMFr3Ql_mUy6l7SR0W5-9h0W7wH4o2bbcpNUQix2BzZpIerT5Zt8Qo0ehu4x_mS0"><ol type="1"><li>客户对象先从 RMI registry 中取得注册名为 ”MyServer“ 的代理。</li><li>RMI registry 返回指定的代理，代理与服务对象具有相同的接口，因此可以替代客户端希望使用的服务对象。</li><li>客户对象调用客户辅助程序的 <code>doBigThing()</code> 方法。</li><li>客户辅助对象打包调用信息（变量、方法名称等），然后通过网络将它运给服务辅助对象（通过 Socket 连接）。</li><li>服务辅助对象把来自客户辅助对象的信息解包，找出被调用的方法（以及在哪个对象内），然后调用<strong>真正</strong>的服务对象上的<strong>真正</strong>方法。</li><li>服务对象上的方法被调用，将结果返回给服务辅助对象。</li><li>服务辅助对象把调用的返回信息打包，然后通过网络运回给客户辅助对象（通过网络 Socket 的输出流）。</li><li>客户辅助对象把返回信息解包，返回给客户对象。对于客户来说，这是完全透明的。</li></ol><h1 id="java-rmi-概观">Java RMI 概观</h1><p>现在你已经知道远程方法如何工作的要点，你要需要了解如何利用 RMI 进行远程方法调用。</p><p>RMI 提供了<strong>客户辅助对象和服务辅助对象</strong>，为客户辅助对象创建和服务对象相同的方法。RMI 的好处在于你不必亲自写任何网络或 I/O 代码。客户程序调用远程方法就和在本地 JVM 上对对象进行方法调用一样。</p><p>RMI 也提供了所有运行时的基础设施，好让这一切正常工作。这包括了查找服务（lookup service），这个服务用来寻找和访问远程对象。</p><p>关于 RMI 调用和本地的方法调用，有一个不同点。<strong>虽然调用远程方法就如同调用本地方法一样，但是客户辅助对象会通过网络发送方法调用，所以网络和 I/O 的确是存在的。我们知道网络和 I/O 是有风险的，容易失败的，所以随时都可能抛出异常。</strong></p><p><strong>RMI 将客户辅助对象称为 stub（桩），服务辅助对象称为 skeleton（骨架）。</strong></p><h1 id="制作远程服务">制作远程服务</h1><p>这里又用来制作远程服务的五个步骤的概要。这些步骤将一个普通的对象变成可以被远程客户调用的远程对象。我们稍后会把这些步骤应用于 GumballMachine。</p><h2 id="制作远程接口">制作远程接口</h2><p>远程接口定义出可以让客户远程调用的方法。客户将用它作为服务的类类型。</p><ol type="1"><li><p>扩展 <code>java.rmi.Remote</code>。</p><p>Remote 是一个“记号”接口，所以 Remote 不具有方法。对于 RMI 来说，Remote 接口具有特别的意义，所以我们必须遵守规则。请注意，我们这里说的是“扩展”（extends），因为接口可以“扩展”另一个接口。</p></li><li><p>声明所有的方法都会抛出 RemoteException。</p><p>客户会调用实现远程接口的 Stub 上的方法，而 Stub 底层用到了网络和 I/O，所以各种坏事情都有可能会发生。客户必须认识到风险，通过处理或声明远程异常来解决。</p></li><li><p>确定变量和返回值是属于原语（primitive）类型或者可序列化（Serializable）类型。</p><p>远程方法的变量必须被打包并通过网络运送，这要靠序列化来完成。如果你使用原语类型，字符串和许多 API 中内定的类型（包括数组和集合），都不会有问题。如果你传送自己定义的类，就必须保证你的类实现了 Serializable。</p></li></ol><figure class="highlight java"><figcaption><span>server/MyRemote.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.*;  <span class="comment">// Remote接口在java.rmi中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyRemote</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="制作远程的实现">制作远程的实现</h2><p>这是做实际工作的类，为远程接口中定义的远程方法提供了真正的实现。这就是客户真正想要调用方法的对象（例如，我们的 GumballMachine）。</p><ol type="1"><li><p>实现远程接口。</p><p>你的服务必须实现远程接口，也就是客户将要调用的方法的接口。</p></li><li><p>扩展 UnicastRemoteObject。</p><p>为了要成为远程服务对象，你的对象需要某些“远程的”功能。最简单的方式是扩展 <code>java.rmi.server.UnicastRemoteObject</code>，让超类帮你做这些工作。</p></li><li><p>设计一个不带变量的构造器，并声明 RemoteException。</p><p>你的新超类 UnicastRemoteObject 带来一个小问题：它的构造器抛出 RemoteException。唯一解决这个问题的方法就是为你的远程实现声明一个构造器，这样就有了一个声明 RemoteException 的地方。</p></li><li><p>用 RMI Registry 注册此服务。</p><p>现在你已经有一个远程服务了，必须让它可以被远程客户调用。你要做的是将此服务实例化，然后放进 RMI registry中（确定 RMI Registry 正在运行，否则注册会失败）。当注册这个实现对象时，RMI 系统其实注册的是 stub，因为这是客户整整需要的。注册服务使用了 <code>java.rmi.Naming</code> 类的静态 <code>rebind()</code> 方法。</p></li></ol><figure class="highlight java"><figcaption><span>server/MyRemoteImpl.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.*;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRemoteImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">MyRemote</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Server says, 'Hey'"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRemoteImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MyRemote service = <span class="keyword">new</span> MyRemoteImpl();</span><br><span class="line">            <span class="comment">// 客户将使用你所注册的名称 RemoteHello 在RMI registry中寻找它。</span></span><br><span class="line">            Naming.rebind(<span class="string">"RemoteHello"</span>, service);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="产生-stub-和-skeleton">产生 Stub 和 Skeleton</h2><p>这就是客户和服务的辅助类。你不需自己创建这些类，当你运行 rmic 工具时，会自动处理。</p><ol type="1"><li><p>在远程实现类（不是远程接口）上执行rmic。</p><p>rmic 是 JDK 内的一个工具，用来为一个服务类产生 stub 和 skeleton。命名习惯是在远程实现的名字后面加上 _Stub 或 _Skel。rmic 有一些选项可以调整，甚至使用 IIOP 作为协议。我们这里使用常用的方式，将类产生在当前目录下。请注意，rmic 必须看到你的实现类，所以你可能会从你的远程实现所在的目录执行 rmic（为了简单起见，我们这里不用 package。但是在真实世界中，你必须注意 package 的目录结构和名称问题）。</p></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server admin$ javac MyRemote.java         # 编译接口</span><br><span class="line">server admin$ javac MyRemoteImpl.java     # 编译实现</span><br><span class="line">server admin$ rmic MyRemoteImpl           # 在实现上运行rmic工具</span><br><span class="line">警告: 为 JRMP 生成和使用骨架及静态存根</span><br><span class="line">已过时。骨架不再必要, 而静态存根</span><br><span class="line">已由动态生成的存根取代。建议用户</span><br><span class="line">不再使用rmic来生成骨架和静态存根。</span><br><span class="line">请参阅 java.rmi.server.UnicastRemoteObject 的文档。</span><br></pre></td></tr></table></figure><h2 id="启动-rmi-registry">启动 RMI registry</h2><p>rmiregistry 就像是电话薄，客户可以从中查到代理的位置（也就是客户的 stub helper 对象）。</p><ol type="1"><li><p>开启一个终端，启动 rmiregistry。</p><p>确定启动目录必须可以访问你的类。最简单的做法是从你的 “classes” 目录启动。</p></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server admin$ rmiregistry</span><br></pre></td></tr></table></figure><h2 id="启动远程服务">启动远程服务</h2><p>你必须让服务对象开始运行。你的服务实现类会去实例化一个服务的实例，并将这个服务注册到 RMI registry。注册之后，这个服务就可以供客户调用了。</p><ol type="1"><li><p>开启另一个终端，启动服务。</p><p>从哪里启动？可能是从你的远程实现类中的 <code>main()</code> 方法，也可能是从一个独立的启动类。在这个简单的例子中，我们是从实现类中的 <code>main()</code> 方法启动的，先实例化一个服务对象（<code>new MyRemoteImpl()</code>），然后到 RMI registry 中注册（<code>Naming.rebind()</code>）。</p></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server admin$ java MyRemoteImpl   # 在服务端注册服务</span><br></pre></td></tr></table></figure><h1 id="客户如何取得-stub-对象">客户如何取得 stub 对象</h1><p>客户必须取得 stub 对象（我们的代理）以调用其中的方法。所以我们就需要 RMI registry 的帮忙。</p><figure class="highlight java"><figcaption><span>client/MyRemoteClient.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.*;  <span class="comment">// 用来lookup的Naming类在rmi包中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRemoteClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyRemoteClient().go();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 返回值是Object类型，要转换类型</span></span><br><span class="line">            <span class="comment">// 你需要IP地址或主机名，以及服务被绑定/重绑定时用的名称</span></span><br><span class="line">            MyRemote service = (MyRemote) Naming.lookup(<span class="string">"rmi://127.0.0.1/RemoteHello"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 和一般的方法调用没什么两样（除了必须注意RemoteException之外）。</span></span><br><span class="line">            String s = service.sayHello();</span><br><span class="line"></span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># MyRemoteClient也需要MyRemote接口</span><br><span class="line">client admin$ cp ../server/MyRemote.class MyRemote.class</span><br><span class="line"></span><br><span class="line"># rmic工具生成的MyRemoteImpl_Stub.class是客户端所需要的</span><br><span class="line">client admin$ mv ../server/MyRemoteImpl_Stub.class MyRemoteImpl_Stub.class</span><br><span class="line"></span><br><span class="line">client admin$ javac MyRemoteClient.java</span><br><span class="line">client admin$ java MyRemoteClient</span><br><span class="line">Server says, &apos;Hey&apos;</span><br></pre></td></tr></table></figure><blockquote><p>客户如何取得 stub 类？</p><p>现在我们有一个有趣的问题。不管怎样，客户在做 lookup 时必须有 stub 类（之前利用 rmic 产生的），否则 stub 在客户端就无法被反序列化，一切也就告吹。客户端也需要调用远程对象方法所返回的序列化对象的类（例如调用 <code>sayHello()</code> 返回的 String）。如果是一个简单的系统，可以简单地把这些类移交给客户端。</p><p>还有一种更酷的方式，这个酷方法是“动态类下载”（dynamic class downloading），利用动态类下载，序列化的对象（像 stub）可以被“贴”上一个 URL，告诉客户的 RMI 系统去寻找对象的类文件。如果 RMI 没有在本地发现类，就会利用 HTTP 的 GET 从该 URL 取得类文件。所以你需要一个简单的 Web 服务器来提供这些类文件，也需要修改客户端的安全参数。关于动态类下载，还有一些值得注意的主题，但是我们这里只是简述一下。</p><p>特别对于 stub 对象，客户还有另外一种方法可以取得类，但是只有 Java 5 才支持。Java 5 的 RMI 和动态代理搭配使用，动态代理动态产生 stub，远程对象的 stub 是 <code>java.lang.reflect.Proxy</code> 实例（连同一个调用处理器），它是自动产生的，来处理所有把客户的本地调用变成远程调用的细节。所以，你不再需要使用 rmic，客户和远程对象沟通的一切都在幕后处理掉了。</p><p>动态代理的相关内容见<a href="/notes/head-first-design-patterns/protection-proxy/" title="保护代理">保护代理</a>。</p></blockquote><p>对于 RMI，程序员最常犯的三个错误是：</p><ol type="1"><li>忘了在启动远程服务之前先启动 rmiregistry（要用 <code>Naming.rebind()</code> 注册服务，rmiregistry 必须是运行的）。</li><li>忘了让变量和返回值的类型成为可序列化的类型（这种错误无法在编译时期发现，只会在运行时发现）。</li><li>忘了给客户提供 stub 类。</li></ol><h1 id="回到-gumballmachine">回到 GumballMachine</h1><h2 id="服务器端">服务器端</h2><p>制作远程接口：</p><figure class="highlight java"><figcaption><span>server/GumballMachineRemote.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.*;  <span class="comment">// Remote接口在java.rmi中。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GumballMachineRemote</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLocation</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="comment">// 所有的返回类型都必须是原语类型或可序列化类型。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>server/State.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*; <span class="comment">// Serializable在java.io包内。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只需要扩展Serializable接口（此接口没有方法）。</span></span><br><span class="line"><span class="comment">// 现在所有子类中的State就可以在网络上传送了。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">State</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertQuarter</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ejectQuarter</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnCrank</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispense</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>server/NoQuarterState.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作为示例，这里只列出NoQuarteState的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoQuarterState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对于State的每个实现，我们都在GumballMachine实例变量</span></span><br><span class="line">    <span class="comment">// 前面加上transient关键字，这样就告诉JVM不要序列化这个字段。</span></span><br><span class="line">    <span class="keyword">transient</span> GumballMachineRemote machine;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NoQuarterState</span><span class="params">(GumballMachineRemote machine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.machine = machine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertQuarter</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ejectQuarter</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnCrank</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispense</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"waiting for quarter"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>制作远程实现：</p><figure class="highlight java"><figcaption><span>server/GumballMachine.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.*;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GumballMachine要继承UnicastRemoteObject，以成为一个远程服务。</span></span><br><span class="line"><span class="comment">// GumballMachine也需要实现远程接口GumballMachineRemote。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GumballMachine</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">GumballMachineRemote</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    State noQuarterState;</span><br><span class="line">    State soldOutState;</span><br><span class="line">    <span class="comment">// 这里有其他状态。</span></span><br><span class="line">    State state;</span><br><span class="line">    String location;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器需要抛出RemoteException，因为超类是这么做的。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GumballMachine</span><span class="params">(String location, <span class="keyword">int</span> count)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        noQuarterState = <span class="keyword">new</span> NoQuarterState(<span class="keyword">this</span>);</span><br><span class="line">        soldOutState = <span class="keyword">new</span> SoldOutState(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 这里实例化其他状态。</span></span><br><span class="line">        <span class="keyword">this</span>.location = location;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            state = noQuarterState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            state = soldOutState;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;  <span class="comment">// 这里不需要改！</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> location;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里有其他的方法。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与示例的 MyRemoteImpl 不同，这次启用一个新的测试类，用来注册 GumballMachine。</p><figure class="highlight java"><figcaption><span>server/GumballMachineTestDrive.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GumballMachineTestDrive</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GumballMachineRemote gumballMachine = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">if</span> (args.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"GumballMachine &lt;IP&gt; &lt;name&gt; &lt;inventory&gt;"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count = Integer.parseInt(args[<span class="number">2</span>]);</span><br><span class="line">            gumballMachine = <span class="keyword">new</span> GumballMachine(args[<span class="number">1</span>], count);</span><br><span class="line">            Naming.rebind(<span class="string">"//"</span> + args[<span class="number">0</span>] + <span class="string">"/"</span> + args[<span class="number">1</span>], gumballMachine);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器端所需文件列表：</p><figure class="highlight plain"><figcaption><span>server/</span></figcaption><table><tr><td class="code"><pre><span class="line">State.java</span><br><span class="line">SoldOutState.java</span><br><span class="line">NoQuarterState.java</span><br><span class="line">GumballMachineTestDrive.java</span><br><span class="line">GumballMachineRemote.java</span><br><span class="line">GumballMachine.java</span><br></pre></td></tr></table></figure><p>在 RMI registry 中注册（不需要 rmic，所有工作）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server admin$ javac *.java</span><br><span class="line">server admin$ rmiregistry</span><br><span class="line"></span><br><span class="line"># 新建一个终端</span><br><span class="line">server admin$ java GumballMachineTestDrive 127.0.0.1 A 100</span><br><span class="line"># 新建一个终端</span><br><span class="line">server admin$ java GumballMachineTestDrive 127.0.0.1 B 0</span><br></pre></td></tr></table></figure><h2 id="客户端">客户端</h2><p>监视器实现：</p><figure class="highlight java"><figcaption><span>client/GumballMonitor.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GumballMonitor</span> </span>&#123;</span><br><span class="line">    GumballMachineRemote machine;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依赖远程接口，而不是具体的GumballMachine类。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GumballMonitor</span><span class="params">(GumballMachineRemote machine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.machine = machine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Gumball Machine: "</span> + machine.getLocation());</span><br><span class="line">            System.out.println(<span class="string">"Current inventory: "</span> + machine.getCount() +</span><br><span class="line">                <span class="string">" gumball"</span> + (machine.getCount() &gt; <span class="number">1</span> ? <span class="string">"s"</span> : <span class="string">""</span>));</span><br><span class="line">            System.out.println(<span class="string">"Current state: "</span> + machine.getState());</span><br><span class="line">        <span class="comment">// 当我们试图调用那些最终要通过网络发生的方法时，我们需要捕获所有可能发生的远程异常。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试程序：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GumballMonitorTestDrive</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] location = &#123;<span class="string">"rmi://127.0.0.1/A"</span>,</span><br><span class="line">                             <span class="string">"rmi://127.0.0.1/B"</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 监视器的数组</span></span><br><span class="line">        GumballMonitor[] monitor = <span class="keyword">new</span> GumballMonitor[location.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; location.length; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                GumballMachineRemote machine =</span><br><span class="line">                        (GumballMachineRemote) Naming.lookup(location[i]);</span><br><span class="line">                <span class="comment">// 创建监视器，把要监视的机器传给它。</span></span><br><span class="line">                monitor[i] = <span class="keyword">new</span> GumballMonitor(machine);</span><br><span class="line">                System.out.println(monitor[i]);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; monitor.length; i++) &#123;</span><br><span class="line">            monitor[i].report();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">client admin$ cp ../server/GumballMachineRemote.class GumballMachineRemote.class</span><br><span class="line">client admin$ cp ../server/State.class State.class</span><br><span class="line">client admin$ javac *.java          # 编译依赖上述两个接口</span><br><span class="line"></span><br><span class="line">client admin$ cp ../server/NoQuarterState.class NoQuarterState.class</span><br><span class="line">client admin$ cp ../server/SoldOutState.class SoldOutState.class</span><br><span class="line">client admin$ java GumballMonitorTestDrive         # 测试依赖两个具体状态</span><br><span class="line">GumballMonitor@31cefde0</span><br><span class="line">GumballMonitor@7daf6ecc</span><br><span class="line">Gumball Machine: A</span><br><span class="line">Current inventory: 100 gumballs</span><br><span class="line">Current state: waiting for quarter</span><br><span class="line">Gumball Machine: B</span><br><span class="line">Current inventory: 0 gumball</span><br><span class="line">Current state: waiting for refill</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Head First Design Patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理模式</title>
      <link href="/notes/head-first-design-patterns/proxy-pattern/"/>
      <url>/notes/head-first-design-patterns/proxy-pattern/</url>
      
        <content type="html"><![CDATA[<p>代理要做的：控制和管理访问。你将看到，代理的方式有许多种。代理以通过 Internet 为它们的代理对象搬运的整个方法调用而出名，它也可以代替某些懒惰的对象做一些事情。</p><h1 id="定义代理模式">定义代理模式</h1><p>代理模式为另一个对象提供一个替身或占位符以控制对这个对象的访问。</p><p>使用代理模式创建代表（representative）对象。让代表对象控制某对象的访问，被代理的对象可以是远程的对象、创建开销大的对象或需要安全控制的对象。</p><img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYoW2996SM9UUaScNcbQGMfIKcfoe4boPbfIQNADZOmCNix1IgkHGKgXEJYakA4fDBQXMAKWjBKujBD3IvQhcISnABYnK2Yl8hAi7AWb8JSs26527OG1bCNSXggz5Km1rIewU7h11L0cml5x8vDhfGmRpyabI5eipqZ1A5_3I8c9N2ivx6PtCweMgVpsfvkcVgyoahtk_fYSbxkh_rnRB6PzEtFTtGzcBzzcSRcrxiNVDyzqoeOW00"><p>Subject 为 RealSubject 和 Proxy 提供了接口。通过实现同一接口，Proxy 在 RealSubject 出现的地方取代它。</p><p>RealSubject 是真正做事的对象，它是被 Proxy 代理和控制访问的对象。</p><p>Proxy 持有 RealSubject 的引用。在某些例子中，Proxy 还会负责 RealSubject 对象的创建与销毁。客户和 RealSubject 的交互都必须通过 Proxy。Proxy 也控制了对 RealSubject 的访问，在某些情况下，我们可能需要这样的控制。这些情况包括 RealSubject 是远程对象、RealSubject 创建开销大，或 RealSubject 需要被保护。</p><h1 id="远程代理">远程代理</h1><p>远程代理可以作为另一个 JVM 上对象给的本地代表。调用代理的方法，会被代理利用网络转发到远程执行，并且结果会通过网络返回给代理，再由代理将结果转给客户。</p><a href="/notes/head-first-design-patterns/remote-proxy/" title="前往文章">前往文章</a><a id="more"></a><img src="http://www.plantuml.com/plantuml/svg/AyxEp2j8B4hCLN3AhmX8J4d9p4jNC3JWIiglu0AAbsGcPnOavfKeEETafkQLe0W55ELNL7AbvgKeW1IZQmXAJSm9BatAIaqkWQk16AAWQmVHQwLGb5fOcbfSeg791HO0oI3fGv870000"><h1 id="虚拟代理">虚拟代理</h1><p>虚拟代理作为创建开销大的对象的代表。虚拟代理经常直到我们真正需要一个对象的时候才创建它。当对象在创建前和创建中时，由虚拟代理来扮演对象的替身。对象创建后，代理就会将请求直接委托给对象。</p><a href="/notes/head-first-design-patterns/virtual-proxy/" title="前往文章">前往文章</a><img src="http://www.plantuml.com/plantuml/svg/AyxEp2j8B4hCLN3AhmX8J4d9p4jNC3JWAeQB1-MNvgKuvnVbfHOfc78bvLTm0SLBCfCp2nBpIXISSp9JyqfGX0AAyYigKKI2KXDpWakJibAJIxXIyr8KG8RavPUaAkIN0Gr5ahL2vZnTl_F5neKnUSzdjJpjcFrqzwwdUnfUJcbukcGv5yHM1LqxY6LM2aMfXQMfnIKQcbnW0P0CYh5Fvwnukh_rnRB6PzEtlT_J0p4FISNZXgQOlAVBcfxDcuFiWksRdk_kXoX-igiDg16eQCF6PrrTBzPlVxQnwUdoASywPppVFHFL9000"><h1 id="保护代理">保护代理</h1><p>保护代理基于权限控制对资源的访问。</p><a href="/notes/head-first-design-patterns/protection-proxy/" title="前往文章">前往文章</a><h1 id="其他代理">其他代理</h1><table><colgroup><col style="width: 22%"><col style="width: 44%"><col style="width: 33%"></colgroup><thead><tr class="header"><th>代理</th><th>描述</th><th>栖息地</th></tr></thead><tbody><tr class="odd"><td>防火墙代理（Firewall Proxy）</td><td>控制网络资源的访问，保护主题免于“坏客户”的侵害。</td><td>公司的防火墙系统</td></tr><tr class="even"><td>智能引用代理（Smart Reference Proxy）</td><td>当主题被引用时，进行额外的动作，例如计算一个对象被引用的次数。</td><td>垃圾收集器</td></tr><tr class="odd"><td>缓存代理（Caching Proxy）</td><td>为开销大的运算结果提供暂时存储，它也允许多个客户共享结果，以减少计算或网络延迟。</td><td>Web服务器代理，内容管理与出版系统</td></tr><tr class="even"><td>同步代理（Synchronization Proxy）</td><td>在多线程的情况下为主题提供安全的访问。</td><td>出没于JavaSpaces，为分散式环境内的潜在对象集合提供同步访问控制。</td></tr><tr class="odd"><td>复杂隐藏代理（Complexity Hiding Proxy）</td><td>用来隐藏一个类的复杂集合的复杂度，并进行访问控制。有时候也称为外观代理（Facade Proxy），这不难理解。复杂隐藏代理和外观模式是不一样的，因为代理控制访问，而外观模式只提供另一组接口。</td><td></td></tr><tr class="even"><td>写入时复制代理（Copy-On-Write Proxy）</td><td>用来控制对象的复制，方法是延迟对象的复制，直到客户真的需要为止。这是虚拟代理的变体。</td><td>Java 5 的 CopyOnWriteArrayList</td></tr></tbody></table><h1 id="要点">要点</h1><ul><li>代理模式为另一个对象提供代表，以便控制客户对对象的访问，管理访问的方式有许多种。</li><li>远程代理管理客户和远程对象之间的交互。</li><li>虚拟代理控制访问实例化开销大的对象。</li><li>保护代理基于调用者控制对象方法的访问。</li><li>代理模式有许多变体，例如：缓存代理、同步代理、防火墙代理和写入时复制代理。</li><li>代理在结构上类似装饰者，但是目的不同。</li><li>装饰者模式为对象加上行为，而代理则是控制访问。</li><li>Java 内置的代理支持，可以根据需要建立动态代理，并将所有调用分配到所选的处理器。</li><li>就和其他的包装着（wrapper）一样，代理会造成你的设计中类的数目增加。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Head First Design Patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态模式</title>
      <link href="/notes/head-first-design-patterns/state-pattern/"/>
      <url>/notes/head-first-design-patterns/state-pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="导入糖果机">导入：糖果机</h1><p>我们认为糖果机的控制器需要如下图般的工作。希望你能用 Java 语言帮我们实现它，而且需要让设计能够尽量有弹性而且好维护，因为将来我们可能要为它增加更多的行为。</p><img src="http://www.plantuml.com/plantuml/svg/Aov9B4bLK7gsQU6pEPr6fayxsbvEsgYaa5Yia9SVNrYQM5IIMiHL35M4fY8ZiHYe91LPoTCfwvwsxtg-UTgpUNF0QehpSr9WaX1Xe9BdUrlWal7vfILSI2OfwDeXMMsbyBAXuUdiUJ1xkH1I88L8-gmKddLDVTgw5AuInKoWMf1bLWelzgvvshNYsUnDp-QtS8645A1I87TOAK2S-6pgXkUprzaQG1MK5g2v2LcLdG40"><h1 id="状态机-101">状态机 101</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GumballMachine</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> SOLD_OUT = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NO_QUARTER = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> HAS_QUARTER = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> SOLD = <span class="number">3</span>;  <span class="comment">// 四个状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> state = SOLD_OUT;       <span class="comment">// 当前状态</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;              <span class="comment">// 糖果数量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GumballMachine</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            state = NO_QUARTER;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertQuarter</span><span class="params">()</span> </span>&#123;  <span class="comment">// 投入25分钱</span></span><br><span class="line">        <span class="comment">// 利用条件语句决定在每个状态内什么行为是恰当的</span></span><br><span class="line">        <span class="keyword">if</span> (state == HAS_QUARTER) &#123;</span><br><span class="line">            System.out.println(<span class="string">"You can't insert another quarter"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == NO_QUARTER) &#123;</span><br><span class="line">            state = HAS_QUARTER;</span><br><span class="line">            System.out.println(<span class="string">"You inserted a quarter"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == SOLD_OUT) &#123;</span><br><span class="line">            System.out.println(<span class="string">"You can't insert a quarter, the machine is sold out"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == SOLD) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Please wait, we're already giving you a gumball"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ejectQuarter</span><span class="params">()</span> </span>&#123; <span class="comment">/* 退回25分钱 */</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnCrank</span><span class="params">()</span> </span>&#123; <span class="comment">/* 转动曲柄 */</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispense</span><span class="params">()</span> </span>&#123; <span class="comment">/* 发放糖果 */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="该来的躲不掉变更请求">该来的躲不掉：变更请求</h1><p>我们认为，将“购买糖果”变成是一个游戏，可以大大地增加我们的销售量。当曲柄被转动时，有 10% 的几率掉下来的是两颗糖果。当个赢家！10 人有 1 人可以得到免费糖果。</p><a id="more"></a><img src="http://www.plantuml.com/plantuml/svg/Aov9B4bLK7gsQU6pEPr6fayxsbvEsgYaa5Yia9SVNrYQM5IIMiHL35M4fY8ZiHYe91LPoTCfwvwsxtg-UTgpUNF0QehpSr9WaX1Xe9BdUrlWal7vfIKm1I-sBdgwRXjOgZmpBo-ro4hXQV_4PrFsFTcnvEMYwH3zN4ZMAkZQ8RdJIk5bGyFJsVDWZkH2I84K8kcpKdZMDVLfwrAuIXGpWMfXrh_Ok-PfrufdipSzcz_oVayFq85FThLXg0Rv0qCjC4Y1ohb0Sd158CzQAK3yyMpgXkUprzaQG5MK5g3v1LcLdG4Nn4NuJOAf8M0M0000"><p>使用一种考虑周详的方法编写糖果机的代码，并不意味着这份代码就容易扩展。事实上，当你回顾这些代码，并开始考虑要如何修改它时……</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> SOLD_OUT = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NO_QUARTER = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> HAS_QUARTER = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> SOLD = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 首先，你必须加上一个新的状态，称为“赢家”。这还不算太麻烦……</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertQuarter</span><span class="params">()</span> </span>&#123; <span class="comment">/*投币代码*/</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ejectQuarter</span><span class="params">()</span> </span>&#123; <span class="comment">/*退币代码*/</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnCrank</span><span class="params">()</span> </span>&#123; <span class="comment">/*转动曲柄代码*/</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispense</span><span class="params">()</span> </span>&#123; <span class="comment">/*发放糖果代码*/</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后呢，你必须在每个方法中加入一个新的条件判断</span></span><br><span class="line"><span class="comment">// 来处理“赢家“状态：这可有你忙的了。</span></span><br><span class="line"><span class="comment">// turnCrank()尤其会变得一团乱，因为你必须加上代码</span></span><br><span class="line"><span class="comment">// 来检查目前的顾客是否是赢家，然后再决定是切换到</span></span><br><span class="line"><span class="comment">// 赢家状态还是售出糖果状态。</span></span><br></pre></td></tr></table></figure><p>我们实现的状态：</p><ul><li>代码没有遵守开放-关闭原则。</li><li>设计其实不符合面向对象。</li><li>状态转换被埋藏在条件语句中，所以并不明显。</li><li>没有把会改变的那部分包装起来。</li><li>未来加入的代码很有可能会导致 bug。</li></ul><h1 id="新的设计">新的设计</h1><p>我们的计划是这样的：不要维护我们现有的代码，我们重写它以便于将状态对象封装在各自的类总，然后在动作发生时委托给当前状态。</p><img src="http://www.plantuml.com/plantuml/svg/lLF1RjD04BtxArOzbKDRzOgY7E005q2e1ow-REo1cDhhohi6eHB98I0QLDLK2X5AGoLK8I4acbGLg2bj-HZYjNlgBx3EkexjkDTSREkzqNiputbrGmS4rWPxXIomQk0ezHZH34SpGJ480-SfrW2jCSm0LIefKgsYJGMXJLoZpC4QQo23K73OOnSxecJnLfw4vw3Tn37N8NSTJDQBX6xG3H2g0cyeceafHMksgSjUOlTxhbN3fla0QtM30BBaMn2plSmqa7UzmUgHo-Razj1EokVaTn_J-He-CGYPcrb1FFQJpZJvgU8xnKXkzIbSpsye9v57Nav7KwPbIOb83D9ibp3n_S8sz9Bv9l3Ca1CqF-a4eY1lSZ7Zav8Ec80ft173opHPmEgsta0hA-WPCA4T_cppxeWVVnBBIbBzUdbv6gmYU1s1B9u_rYnJEAiibJa0PHhZoj9IjV2xRgFmms_kDOF1A3hwEhxu4ltgXiTTlj_d_TEhissLN7gzwE_xQDWAEzzJ9koz7PzuuzCzEPvAU6SK-9-b5j_g1lukxrp8yd_U6oMNx_8shgMJ7jgZuB2d4gbuTTRZsqtUR_Es9vug2Vn1r3eNNKW-jYY4kiH4AUQmh2ORdJAUs89Ou0D_VF93cb-speDXCpfunxS-gYHUYs2E_eZboQgOFzmFTuOgcSZodM-1Vo1QNa2O8hAga5MKFOh_"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoQuarterState</span> <span class="keyword">implements</span> </span>&#123; <span class="comment">// 其他状态类类似</span></span><br><span class="line">    GumballMachine machine;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NoQuarterState</span><span class="params">(GumballMachine machine)</span> </span>&#123;  <span class="comment">// 传入糖果机的引用</span></span><br><span class="line">        <span class="keyword">this</span>.machine = machine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertQuarter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"You inserted a quarter"</span>);</span><br><span class="line">        machine.setState(machine.getHasQuarterState());  <span class="comment">// 改变机器状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ejectQuarter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"You haven't inserted a quarter"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnCrank</span><span class="params">()</span> </span>&#123; <span class="comment">/*省略*/</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispense</span><span class="params">()</span> </span>&#123; <span class="comment">/*省略*/</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GumballMachine</span> </span>&#123;</span><br><span class="line">    State soldOutState;</span><br><span class="line">    <span class="comment">// 其他状态</span></span><br><span class="line">    State state = soldOutState;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GumballMachine</span><span class="params">(<span class="keyword">int</span> numberGumballs)</span> </span>&#123;</span><br><span class="line">        soldOutState = <span class="keyword">new</span> SoldOutState(<span class="keyword">this</span>);  <span class="comment">// 创建状态实例，并传入此机器的引用</span></span><br><span class="line">        <span class="comment">// 初始化其他状态</span></span><br><span class="line">        <span class="keyword">this</span>.count = numberGumballs;</span><br><span class="line">        <span class="keyword">if</span> (numberGumballs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            state = noQuarterState;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertQuarter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.insertQuarter();  <span class="comment">// 委托给当前状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ejectQuarter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.ejectQuarter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们不需要在GumballMachine中准备一个dispense()的动作方法，</span></span><br><span class="line">    <span class="comment">// 因为这只是一个内部的动作：用户不可以直接要求机器发放糖果。</span></span><br><span class="line">    <span class="comment">// 我们是在turnCrank()方法中调用当前状态对象的dispense()方法的。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnCrank</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.turnCrank();</span><br><span class="line">        state.dispense();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;  <span class="comment">// 允许状态对象改变机器的当前状态</span></span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">releaseBall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A gumball comes rolling out the slot..."</span>);</span><br><span class="line">        <span class="keyword">if</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter等其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问</strong>：我们为什么需要 WinnerState？为什么不直接在 SoldState 中发放两颗糖果？</p><p><strong>答</strong>：这是一个好问题。这两个状态几乎一样，唯一的差别在于，WinnerState 状态会发放两颗糖果。你当然可以将发放两颗糖果的代码放在 SoldState 中，当然这么做有缺点，因为你等于是将两个状态用一个状态类来代表。这样做你牺牲了状态类的清晰易懂来减少一些冗余代码。你也应该考虑到：一个类，一个责任。将 WinnerState 状态的责任放进 SoldState 状态中，等于是让 SoldState 状态具有两个责任。那么促销方案结束后或者赢家的几率改变之后，你又该怎么办呢？所以，这必须用你的智慧来做折衷。</p><p>你现在有了一个糖果机的实现，它在结构上和前一个版本差异颇大，但是功能上却是一样的。通过从结构上改变实现，你已经做到了以下几点：</p><ul><li>将每个状态的行为局部化到它自己的类中。</li><li>将容易产生问题的 if 语句删除，以方便日后的维护。</li><li>让每一个状态“对修改关闭”，让糖果机“对扩展开放”，因为可以加入新的状态类。</li><li>创建一个新的代码基和类结构，更容易阅读和理解。</li></ul><p>在推出我们的黄金版本之前，让我们再检查看看 GumballMachine 还有哪些方面需要改进：</p><ul><li>我们在售出糖果和赢家状态中，有许多重复的代码。我们必须把这部分清理一下。要怎么做呢？我们可以把 State 设计成抽象类，然后把方法的默认行为放在其中；毕竟，像是“你已经投入 25 分钱”这类的消息，不会被顾客看见。所以，所有的“错误响应”行为都可以写的具有通用性，并放在抽象的 State 类中供子类继承。</li><li><code>dispense()</code> 方法即使是在没有 25 分钱时曲柄被转动的情况下也总是会被调用。我们可以轻易地修改这部分，做法是让 <code>turnCrank()</code> 返回一个布尔值，或者引入异常。</li><li>状态转换的所有智能被放在状态类中，这可能导致什么问题？（类的数目增多）我们要将逻辑移进糖果机中吗？这有什么优缺点？（违反开放-关闭原则，详细解释见问答一节）</li><li>你会实例化许多的 GumballMachine 对象吗？如果是的话，你可能想要将状态的实例转移到静态的实例变量中共享。这需要对 GumballMachine 和 State 做怎样的改变？（State 不能拥有内部状态，即糖果机，只提供行为。GumballMachine 委托行为时要传入自己的引用，详细解释见问答一节）</li></ul><h1 id="定义状态模式">定义状态模式</h1><p>状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</p><p>在内部状态改变时改变它的行为：这个模式将状态封装成独立的类，并将动作委托到代表当前状态的对象，我们知道行为会随着内部状态而改变。</p><p>对象看起来好像修改了它的类：从客户的视角来看，如果说你使用的对象能够完全改变它的行为，那么你会觉得，这个对象实际上是从别的类实例化而来的。然而，实际上，你知道我们是在使用组合通过简单引用不同的状态对象来造成类改变的假象。</p><img src="http://www.plantuml.com/plantuml/svg/VSv12i8m40NG_PnYbhg85r04wn4yGJhza49IDHd1KdDtsvHiXBeR_dy3t_KT6E6X8mU45f7SaaWVnODicpHQKRwfLV14p5FDCZixT1wxFMKIRrFYwtsG24NHbyB_csRJADvQoeZd2sc-EIqVXugFd6TVfJcl4saTUleOyxDcisc-"><h1 id="状态模式和策略模式">状态模式和策略模式</h1><p><strong>策略模式和状态模式的类图是一样的，这两个模式的差别在于它们的“意图”。</strong></p><img src="http://www.plantuml.com/plantuml/svg/XOyn3eCm34NtdC8Z3EK2HP5AZz0JXDGKfAH4naEZaBit80XIEx1Pt_zzV_V34m6jOmyMROia-aNH0sc3GXirJN0VtumVXY007aoAyULXseQaEQHk95kK4B9SAUUCByehH175a0AeKneFlgwpAEKQ7LIxq9eZR70YSmDDoBZJjnKuSpK_hlsFYymrnD5dhgh_EoVxvWi0"><p>以状态模式而言，我们将一群行为封装在状态对象中，context 的行为随时可委托到那些状态中的一个。随着时间的流逝，当前状态在状态对象集合中游走改变，以反映出 context 内部的状态，因此，context 的行为也会跟着改变。但是 context 的客户对于状态对象了解不多，甚至根本是浑然不觉。</p><p>而以策略模式而言，客户通常主动指定 Context 所要组合的策略对象是哪一个。现在，固然策略模式让我们具有弹性，能够在运行时改变策略，但对于某个 context 对象来说，通常都只有一个最适当的策略对象。</p><p>一般来说，我们<strong>把策略模式想成是除了继承之外的一种弹性替代方案</strong>。如果你使用继承定义了一个类的行为，你将被这个行为困住，甚至要修改它都很难。有了策略模式，你可以通过组合不同的对象来改变行为。</p><p>我们<strong>把状态模式想成是不用在 context 中放置许多条件判断的替代方案</strong>。通过将行为包装进状态对象中，你可以通过在 context 内简单地改变状态对象来改变 context 的行为。</p><h1 id="问答">问答</h1><ul><li><p><strong>问</strong>：在 GumballMachine 中，状态决定了下一个状态应该是什么。ConcreteState 总是决定接下来的状态是什么吗？</p><p><strong>答</strong>：不，并非总是如此，Context 也可以决定状态转换的流向。</p><p><strong>一般来讲，当状态转换是固定的时候，就适合放在 Context中；然而，当转换是更动态的时候，通常就会放在状态类中</strong>。</p><p><strong>将状态转换放在状态类中的缺点是：状态类之间产生了依赖</strong>。在我们的 GumballMachine 实现中，我们试图通过使用 Context 上的 getter 方法把依赖减到最小，而不是显式硬编码具体状态类。</p><p>请注意，<strong>在做这个决策的同时，也等于是在为另一件事情做决策：当系统进化时，究竟哪个类是对修改封闭（Context 还是状态类）的</strong>。</p></li><li><p><strong>问</strong>：客户会直接和状态交互吗？</p><p><strong>答</strong>：不会。状态是用在 Context 中来代表它的内部状态以及行为的，所以只有 Context 才会对状态提出请求。客户不会直接改变 Context 的状态。<strong>全盘了解状态是 Context 的工作，客户根本不了解，所以不会直接和状态联系。</strong></p></li><li><p><strong>问</strong>：如果在我的程序中 Context 有许多实例，这些实例之间可以共享状态对象吗？</p><p><strong>答</strong>：是的，绝对可以，事实上这是很常见的做法。<strong>但唯一的前提是，你的状态对象不能持有它们自己的内部状态；否则就不能共享</strong>。</p><p>想要共享状态，你需要把每个状态都指定到静态的实例变量中，如果你的状态需要利用到 Context 中的方法或者实例变量，你还必须在每个 <code>handler()</code> 方法内传入一个 context 的引用。</p></li><li><p><strong>问</strong>：使用状态模式似乎总是增加我们设计中类的数目。</p><p><strong>答</strong>：没错，在个别的状态类中封装状态的行为，结果总是增加这个设计中类的数目。<strong>这就是为了要获取弹性而付出的代价</strong>。除非你的代码是一次性的，可以用完就扔掉，那么状态模式的设计是绝对值得的。其实真正重要的是你暴露给客户的类数目，而且我们有办法将这些额外的状态类全部隐藏起来。</p></li><li><p><strong>问</strong>：状态模式类图显示 State 是一个抽象类，但你不是使用接口实现的糖果机状态的吗？</p><p><strong>答</strong>：是的。如果我们没有共同的功能可以放进抽象类中，就会使用接口。在你实现状态模式时，很可能想使用抽象类。这么一来，当你以后需要在抽象类中加入新的方法时就很容易，不需要打破具体状态的实现（子类会继承抽象类中的新方法）。</p></li></ul><h1 id="要点">要点</h1><ul><li>状态模式允许一个对象基于内部状态而拥有不同的行为。</li><li>Context 会将行为委托给当前状态对象。</li><li>通过将每个状态封装进一个类，我们把以后需要做的任何改变局部化了。</li><li>状态模式和策略模式有相同的类图，但是它们的意图不同。</li><li>策略模式通常会用行为或算法来配置 Context 类。</li><li>状态模式允许 Context 随着状态的改变而改变行为。</li><li>状态变换可以由 State 类或 Context 类控制。</li><li>使用状态模式通常会导致设计中类的数目大量增加。</li><li>状态类可以被多个 Context 实例共享。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Head First Design Patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Validate Binary Search Tree</title>
      <link href="/programming/leetcode/validate-binary-search-tree/"/>
      <url>/programming/leetcode/validate-binary-search-tree/</url>
      
        <content type="html"><![CDATA[<p>Given a binary tree, determine if it is a valid binary search tree (BST).</p><p>Assume a BST is defined as follows:</p><ul><li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node's key.</li><li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node's key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  1   3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  1   4</span><br><span class="line">     / \</span><br><span class="line">    3   6</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><h1 id="recursion">Recursion</h1><p>For each node <code>l</code> in left subtree, we check if <code>l.val &lt; root.val</code> or not; And for each node <code>r</code> in right subtree, we check <code>r.val &gt; root.val</code>. Then, same procedure applied on subtrees.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(node, lower=float<span class="params">(<span class="string">'-inf'</span>)</span>, upper=float<span class="params">(<span class="string">'inf'</span>)</span>)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            val = node.val</span><br><span class="line">            <span class="keyword">if</span> val &gt;= upper <span class="keyword">or</span> val &lt;= lower:  <span class="comment"># check root and it's two children</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> helper(node.left, lower, val):  <span class="comment"># check left subtree recursively</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> helper(node.right, val, upper):  <span class="comment"># check right subtree recursively</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(root)</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="iteration">Iteration</h1><p>The above recursion could be converted into iteration, with the help of stack. DFS would be better than BFS since it works faster here.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        stack = [(root, float(<span class="string">'-inf'</span>), float(<span class="string">'inf'</span>)), ]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            root, lower, upper = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            val = root.val</span><br><span class="line">            <span class="keyword">if</span> val &lt;= lower <span class="keyword">or</span> val &gt;= upper:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            stack.append((root.right, val, upper))</span><br><span class="line">            stack.append((root.left, lower, val))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h1 id="inorder-traversal">Inorder traversal</h1><p><img src="/uploads/image/leetcode/traversal.png"></p><p>Here the nodes are enumerated in the order you visit them, and you could follow <code>1-2-3-4-5</code> to compare different strategies.</p><p><code>Left -&gt; Node -&gt; Right</code> order of inorder traversal means for BST that each element should be smaller than the next one.</p><p>Hence the algorithm with <code>O(n)</code> time complexity and <code>O(n)</code> space complexity could be simple:</p><ul><li><p>Compute inorder traversal list inorder.</p></li><li><p>Check if each element in inorder is smaller than the next one.</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        stack, inorder = [], float(<span class="string">'-inf'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            root = stack.pop()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># If next element in inorder traversal</span></span><br><span class="line">            <span class="comment"># is smaller than the previous one</span></span><br><span class="line">            <span class="comment"># that's not BST.</span></span><br><span class="line">            <span class="keyword">if</span> root.val &lt;= inorder:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            inorder = root.val</span><br><span class="line">            root = root.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursion </tag>
            
            <tag> tree </tag>
            
            <tag> leetcode </tag>
            
            <tag> BST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代器模式和组合模式</title>
      <link href="/notes/head-first-design-patterns/iterator-pattern-and-composite-pattern/"/>
      <url>/notes/head-first-design-patterns/iterator-pattern-and-composite-pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="迭代器模式封装遍历">迭代器模式：封装遍历</h1><h2 id="导入餐厅和煎饼屋合并了">导入：餐厅和煎饼屋合并了</h2><img src="http://www.plantuml.com/plantuml/svg/TP31Im915CRl-rUyOnt4UqGGT2We23gAXt7dwGxjpiZiA8XuKoWoaqY3yY8KU0cA81IB_XbdL_-BTjSSK-dulddVz_lcEOmYe5TK5V3Gow6qd5YncRHTj6oN-3wS82yTAVIWQW6SASbu0JZnS3bHz6t9Yee97eavuRf8E9InW8f8HcAHYbBEHIXAPgDL-qq-9TmcvtWeIZx6b8ImBoMf73DVHOtcO3zIou9H89J6yzRsobf4MLJqawUgXyeHj0RfDEZ6nsJS3RgZuBrZk0UCepJ0XJcJJOZiF-AVlJLapJ8tsasbDhwr-chWrh96AXETdIBFxcsQkL08aXKS1I9lIkp0xAcjMmrzsmmRhTdpftwx2dgNuUDGjvlXGtrwqzFNdLb_jEPVZzy1OzUzmTmr6RvClhx3ku6-k9_s1_C45_D9W2bj6cpOWivhEAx_0000"><p>真是个好消息！现在我们可以在同一个地方，享用煎饼屋美味的煎饼早餐，和好吃的餐厅午餐了。但是，好像有一点小麻烦……有两种不同的菜单表现方式，这会带来什么问题？</p><p>假设你已经被合组的新公司雇佣。你的工作是要创建一个 Java 版本的女招待。</p><img src="http://www.plantuml.com/plantuml/svg/ROxDIiD058NtUOfPrbNVGLmeABZIzNLwQuOcOvYPBAGKYWWsOaX1nRzG5RLGDt7XeehWotIcoSfNS6e8qkhkt7FFT-znMGC9-e7Q9pxwEoWST-PG9gY73lL0Ih8DJ0cqekqGiWcSGWjNzqA96yX34YmODhF2E8gVPQDIrWq4usgcQqkaJUfrOg9J7R_ee_SyINLyFXaVJwyFJPPCnjtY_erqAcPP8BIQ8ETWdJoNlBaO5O_zEM0zvDJzDwpZtc9u2tTHWM30_tOpKTUaaMqrVRqh7cxBdXNDv9f2_nUlSV2nUZWyC8Cqpvvis5nc9VxrSP9_dkcRWGe5sa7tXxftLLfDy2JQivrl"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ArrayList breakfastItems = pancakeHouseMenu.getMenuItems();</span><br><span class="line">    MenuItem[] launchItems = dinerMenu.getMenuItems();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; breakfastItems.size(); i++) &#123;</span><br><span class="line">        MenuItem menuItem = (MenuItem)breakfastItems.get(i);</span><br><span class="line">        <span class="comment">// 打印menuItem</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lunchItems.length; i++) &#123;</span><br><span class="line">        MenuItem menuItem = lunchItems[i];</span><br><span class="line">        <span class="comment">// 打印menuItem</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现其他方法，做法也类似。我们总是需要处理两个菜单，并且用两个循环遍历。如果还有第三家餐厅以不同的实现出现，我们就需要有三个循环。</p><a id="more"></a><p>根据我们的 <code>printMenu()</code> 实现：</p><ul><li>我们是针对 PancakeHouseMenu 和 DinerMenu 的具体实现编码，而不是针对接口。</li><li>如果我们决定从 DinerMenu 切换到另一种菜单，此菜单的项使用 Hashtable 来存放的，我们会因此需要修改女招待中的许多代码。</li><li>女招待需要知道每个菜单如何表达内部的菜单项集合，这违反了封装。</li><li>我们有重复的代码：<code>printMenu()</code> 方法需要两个循环，来遍历两种不同的菜单。如果我们加上第三种菜单，我们就需要第三个循环。</li></ul><p>如果你从本书中学习了一件事情，那就是封装变化的部分。很明显，在这里发生变化的是：由不同的集合（collection）类型所造成的遍历。</p><h2 id="应用迭代器模式">应用迭代器模式</h2><img src="http://www.plantuml.com/plantuml/svg/ZPDDIm916CVl-oa6JtNO1QyY2q67Wenk7Sp3k3xYaZihCoCava5AyL84lK1vAF3Y9GWIeaJyCeultwBnRNRTRSdJxlwV__DxNcQsOES0WLFY5UI0amMg5UQAPLEh29fLn8oXKsnp2lAbgY5KeZRXAI3bdLsjjZASO6BXSpXmompceOLnZr9SER8Pbs1IFkJWCAdA9yNSfSYYW3ciFtsmVPi0LPJKAZUTMM3iBJ2oFw1vR87dIYQLQ9eBRXLd6QVOuZLKmEmOBhZCtP39KekQKR7dD3yYaAV6-Jz1xLdNTJDKC11MN4ytJ3Mnver-QHX6PFT1NwXRBNIsXXbDyyxECFzW4PS3AaAU8pUlRbK2ZGR3oKDtxPhLRyHjSzPkYhkMQ5nDUc-RUS7YYT0TcFPUfxtE6H6jjkZ_YCRNQ70_URcU3jz7_OvuxYvvCV5HdtOQiijLczAoh3r--Xv_FiOGPeZ4DH97sor6JyjV9mSaupySRoE-SDJ-VW40"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Waitress &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他变量和方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterator pancakeIterator = pancakeHouseMenu.createIterator();</span><br><span class="line">        Iterator dinerIterator = dinerMenu.createIterator();</span><br><span class="line">        printMenu(pancakeIterator);</span><br><span class="line">        printMenu(dinerIterator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printMenu</span><span class="params">(Iterator iterator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            MenuItem menuItem = (MenuItem)iterator.next();</span><br><span class="line">            <span class="comment">// 打印menuItem</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DinerMenuIterator</span> </span>&#123;</span><br><span class="line">    MenuItem[] items;  <span class="comment">// 餐厅菜单</span></span><br><span class="line">    <span class="keyword">int</span> position = <span class="number">0</span>; <span class="comment">// 记录当前遍历的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DinerMenuIterator</span><span class="params">(MenuItems[] items)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.items = items;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MenuItem menuItem = items[position];</span><br><span class="line">        position++;</span><br><span class="line">        <span class="keyword">return</span> menuItem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (position &gt;= item.length || items[position] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DinerMenu</span> </span>&#123;</span><br><span class="line">    MenuItem[] menuItems;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他变量和方法</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DinerMenuIterator(menuItems);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="做一些改良">做一些改良</h2><p>两份菜单要必须实现 <code>createIterator()</code> 方法，但我们没有为它们设计一个共同的接口。所以，接下来就要这么做。</p><p>为社么我们不使用 Java 的 Iterator 接口呢——我们之所以这么做，是为了要让你了解如果从头创建一个迭代器，我们自己定义了 Iterable 接口。现在我们的目的已经达到了，所以就要改变做法，开始使用 Java 的 Iterator 接口。</p><img src="http://www.plantuml.com/plantuml/svg/VP9DImCn48Rl-HN1KtjemQjAGV2WekBDG_MGRaSRx6ObcnPBBLGHLB0LGSMFwi5I4L6hA5W_m1_ZxdOz-HTClx8hhRqbxypxJ2Op2He73FgAo60Tz1Xmb6We6kLQ4f2M9AQ9vmWL7EGXYp1UuPI9QM2fG13bsWcpX6ba6SQDb0cDK3Dnb7EIcQAca62McX2WcrBLE101yiQ9C7WWYBEOWqXnvcM5gOeEuvmgCaOPS4MVRcT75vf6-WzUkkLpWIyI3PeUF3AYX4YaYSgIc2auqKIklxqZzqSaY3a3gq9w_yYiXyP1DzBW-qVLeYhLWFk92kFpjjeAgJ6rXRLmk6imlf1N3AdvXYEgIUHrsyZkUXdonY5TtU6kbGX5vMB5WItuiX4p161Ebn826ukgzX2U96bIFzti2FFCALRilRBxUUoKTgnQtghTpBFE5pX7hyxJuLT-euKRK8kdSjtF0_liedE-izxBzicrv7kBfXYoLE7ItgkurNEt-lppiUjixrlljrQjy5tAkrVhLkrDyUtxYthnmTswiLyU9KsH9MO04nEpGSG6SOyn_080"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DinerMenuIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    MenuItem[] list;</span><br><span class="line">    <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他变量和方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// next()方法和hasNext()方法保持不变</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加remove()方法的实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (position &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException</span><br><span class="line">                (<span class="string">"You can't remove an item until you've done at least one next()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list[position-<span class="number">1</span>] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = position-<span class="number">1</span>; i &lt; (list.length-<span class="number">1</span>); i++) &#123;</span><br><span class="line">                list[i] = list[i+<span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            list[list.length-<span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>问</strong>：如果我不想让客户具备删除的能力，该怎么办？</p><p><strong>答</strong>：<code>remove()</code> 方法其实是可有可无的，不一定要提供删除的功能。但是，很明显的，你需要提供这样的方法，因为毕竟它被声明在 Iterator 接口中，如果你不允许 <code>remove()</code> 的话，可以抛出一个 <code>java.lang.UnsupportedOperationException</code> 运行时异常。</p><p><strong>Iterator 的 API 文件提到可以让 <code>remove()</code> 方法抛出这样的异常，而任何良好的客户程序只要调用了 <code>remove()</code> 方法，就应该检查是否会发生这个异常</strong>。</p></li><li><p><strong>问</strong>：在多线程的情况下，可能会有多个迭代器引用同一个对象集合。<code>remove()</code> 会造成怎样的影响？</p><p><strong>答</strong>：后果并没有指明，所以很难预料。当你的程序在多线程的代码中使用到迭代器时，必须特别小心。</p></li></ul><h2 id="定义迭代器模式">定义迭代器模式</h2><p>迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。</p><p>这个模式给你提供了一个方法，<strong>可以顺序访问一个聚集对象中的元素，而又不用知道内部是如何表示的</strong>。</p><p>另一个对你的设计造成重要影响的，是<strong>迭代器模式把在元素之间游走的责任交给迭代器，而不是聚合对象</strong>。这不仅让聚合的接口和实现变得更简洁，而可以让聚合更专注在它所应该专注的事情上面（也就是管理对象集合），而不必去理会遍历的事情。</p><img src="http://www.plantuml.com/plantuml/svg/VP3BJi9068NtVOfPweO7C8R4k7BZ4x0fTMX9Q6k6YT4W2HT1Y4XDC1YLS95B20b5t1J2xM7ib7R5ApYbePH0t9vpvfpl7o5y1G4Kh_4T4A4OX8WHR8KB8ou2cR248Ggn70HdF8yWps88JazTrUy7CGQ061kCOiHoE0uu16dcWleibj7HCHFtT6pa_oi4Dde9Rp5zkoDB1pG4HVa6hbUu21kDWdDPeWGORcdjyWDGkt4Np4vxzzrHpvBd9-vzllr9Pdkcrz-ep3wZpx-NEW54hUhp9r8ewwE4FkgHZARFIW79NFJrIPEyTrVJWfcUaLRDIZwJOZOWaS7O73QiponvoQscEVEnHxJXQffd99bkH6080pcqZsilVHavZNHIHhLYLH9c9-bMgcawOxpLgRoijQraYIhBZmVRgIwBtqPvJAOAZH2bvqG24WsvZ3Hg5Dj4QVucKWu62lF2ccDxg9icYupLc3ZD0Sdejvotj5wVrOaoq2UqNfyjbgzTelqObJojjyrnZVAiRUTcKvsRQiFvDZhy1m00"><p>迭代器模式的类图看起来很像我们所学的另一个模式，你知道是哪个模式吗？提示：子类决定要创建哪个对象。（工厂方法模式）</p><h2 id="问答">问答</h2><ul><li><p><strong>问</strong>：我听说过“内部的”迭代器和“外部的”迭代器。这是什么？我们在前面的例子中实现的是哪一种？</p><p><strong>答</strong>：我们实现的是外部迭代器，也就是说，客户通过调用 <code>next()</code> 取得下一个元素。<strong>而内部的迭代器则是由迭代器自己控制。在这种情况下，因为是由迭代器自行在元素之间游走，所以你必须高速迭代器在游走的过程中，要做些什么事情，也就是说，你必须将操作传入给迭代器</strong>。因为客户无法控制遍历的过程，所以内部迭代器比外部迭代器更没有弹性。然而，某些人可能认为内部的迭代器比较容易使用，因为只需将操作告诉它，它就会帮你做完所有事情。</p></li><li><p><strong>问</strong>：你说可以用迭代器写出“多态的代码”，可以再多做一些解释吗？</p><p><strong>答</strong>：当我们写了一个需要以迭代器当作参数的方法时，其实就是在使用多态的迭代。也就是说，我们所写出的代码，可以在不同的集合中游走，只要这个集合支持迭代器即可。我们不在乎这个集合是如何被实现的，但依然可以编程在它内部的元素之间游走。</p></li></ul><h1 id="单一责任和内聚">单一责任和内聚</h1><p>当我们郧西一个类不但要完成自己的事情（管理某种聚合），还同时要负担更多的责任（例如遍历）时，我们就给了这个类两个变化的原因。如果这个集合改变的话，这个类必须改变；如果我们遍历的方式改变的话，这个类也必须改变。</p><blockquote><p>一个类应该只有一个引起变化的原因。</p></blockquote><p>这个原则告诉我们将一个责任只指派给一个类。这听起来很容易，但其实做起来并不简单：<strong>区分设计中的责任，是最困难的事情之一</strong>。我们的大脑很习惯看着一大群的行为，然后将它们集中在一起，尽管它们可能属于两个或多个不同的责任。想要成功的唯一方法，就是努力不懈地检查你的设计，随着系统的成长，随时观察有没有迹象显示某个类改变的原因超出一个。</p><p>内聚（cohesion）这个术语用来度量一个类或模块紧密地达到单一目的或责任。当一个模块被设计成只支持一组相关的功能时，我们说它具有高内聚；反之，当被设计成支持一组不相关的功能时，我们说它具有低内聚。</p><p>内聚是一个比单一责任原则更普遍的概念，但两者其实关系是很密切的。遵守这个原则的类容易具有很高的凝聚力，而且比背负许多责任的低内聚类更容易维护。</p><h1 id="组合模式迎接新的菜单">组合模式：迎接新的菜单</h1><p>我们花了很多时间在女招待 Waitress 上，但还是得承认，程序中调用两次 <code>printMenu()</code> 看起来有点丑。每次我们一有新菜单加入，就必须打开 Waitress 并加入更多的代码。这算不算是“违反开放-关闭原则“？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator pancakeIterator = pancakeHouseMenu.createIterator();</span><br><span class="line">    Iterator dinerIterator = dinerMenu.createIterator();</span><br><span class="line">    Iterator cafeIterator = cafeMenu.createIterator();  <span class="comment">// 添加咖啡厅菜单</span></span><br><span class="line">    printMenu(pancakeIterator);</span><br><span class="line">    printMenu(dinerIterator);</span><br><span class="line">    printMenu(cafeIterator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这不是女招待的错。对于将她从菜单的实现上解耦和提取遍历动作到迭代器，我们都做的很好。但我们让然将菜单处理成分离而独立的对象——我们需要一种一起管理它们的方法。</p><h2 id="将菜单打包进-arraylist">将菜单打包进 ArrayList</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Waitress</span> </span>&#123;</span><br><span class="line">    ArrayList menus;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Waitress</span><span class="params">(ArrayList menus)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.menus = menus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterator menuIterator = menus.iterator(); <span class="comment">// 遍历菜单</span></span><br><span class="line">        <span class="keyword">while</span> (menuIterator.hasNext()) &#123;</span><br><span class="line">            Menu menu = (Menu)menuIterator.next();</span><br><span class="line">            printMenu(menu.createIterator());  <span class="comment">// 遍历并打印菜单项</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printMenu</span><span class="params">(Iterator iterator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            MenuItem menuItem = (MenuItem)iterator.next();</span><br><span class="line">            <span class="comment">// 打印菜单项内容</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来相当不错，虽然我们失去了菜单的名字，但是可以把名字加进每个菜单中。</p><p>正当我们认为这很安全的时候，现在他们希望能够加上一份餐后甜点的“子菜单”。根据现有的实现，根本做不到。<strong>我们需要让餐厅菜单持有一份子菜单，但是不能真的把它赋值给菜单项数组，因为类型不同，所以不能这么做</strong>。</p><p>该是做决策来改写厨师的实现以符合所有菜单的需求的时候了。在我们的新设计中，真正需要些什么呢？</p><ul><li>我们需要某种<strong>树形结构，可以容纳菜单、子菜单和菜单项</strong>。</li><li>我们需要确定能够在每个菜单的各个项之间游走，而且至少要像现在用迭代器一样方便。</li><li>我们也需要能够更有弹性地菜单项之间游走。比方说，可能只需要遍历甜品菜单，或者可以遍历餐厅的整个餐单（包括甜品菜单在内）。</li></ul><h2 id="定义组合模式">定义组合模式</h2><p>我们要介绍另一个模式解决这个难题。我们并没有放弃迭代器——它仍然是我们解决方案中的一部分——然而，管理菜单的问题已经到了一个迭代器无法解决的新维度。</p><p>组合模式允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。</p><img src="http://www.plantuml.com/plantuml/svg/TP7BJjj058RtVefPbaNw05759jk-GTs5IIR4aZsE7AjIHP7IN5329QuAHPH4XRHKGPLmsY9WR8ZoCCoClUihz7WiNuZ4RdoEv_ilqz1h666pwRn79ZOtiAqquabLjwi6LhIDbcDhLGTLBBDf4KmSjAKWj9NEjv7LnBRcw1PviVPqeTLggoCRczOxl3hTn4wbeHlntzjArT1QBVGQQtKfLAIdIscbfJjO_f7A5DW5u2gXOkXnXfVhUI0bZ_RgGwaajLTdcMHnyMGk7PVUG7SrJDwk5pR40gS6hZl8ggD4luouzrqCxjXY6HvTPaYLYD5FxluGXmTiCGdlU_pJWD6hyBJ7vtxqP_hOxYGqMzzi9BZqQZa_CXeKhm9qs1QJOOBWtYdpXuos6VsLYFrxs5S9emUXDnKdy-Hcj3o1CtTlezrEsF4ptJH571Oof7lcduNtCp5Sic27Trtv8e_jZof9tuH_ti_VH2NHygiulmDlujWNrr_00KnOC4u-LG9MCxOO74SU5N-d447qN33_J0jnr-Ny29wuzoqS_GPFG4nnuPZo_dKiBJi65Ypxjr0LyEDQm8NSS7SUTHVI2mj66JQn80lZ5pDmpiVdukg2JoxZ2D1fjmztTcuOtKi8B9Y5HsVyeSCf1RN_"><p><strong>利用组合结构，我们能把相同的操作应用在组合和个别对象上。换句话说，在大多数情况下我们可以忽略对象组合和个别对象之间的差别。</strong></p><p><strong>问</strong>：这和迭代器有什么关系？</p><p><strong>答</strong>：我们现在在采取一个新的方法，打算用新的方案——组合模式，来重新实现菜单。不要认为迭代器和组合之间有什么神奇的转换。我们可以说，这两者可以合作无间，你很快就会看到我们可以在组合的实现中使用迭代器，而且做法还不止一种。</p><h2 id="利用组合设计菜单">利用组合设计菜单</h2><img src="http://www.plantuml.com/plantuml/svg/fLDDIyD04BtdLyon7eft4K7q8gW8WXxKmpQPjWl9fcnMGMf1j2gA6X7RYlKYedYGUX2AiKf_ZDaq_HUkBVtIIYlUTcTVthnvRvAa1W9QAR495benv5hogw9JhfkeaPWZED45p25RdxAjbCsG2KXh00aKyyJ2o0YaONGKWgEYF7WDgsVXpN5GACkt7Vdo0facS1eTdTEKe3OR2h_0gJu4CtMMKA49fsG8tXIdJ0o64SE8T2R5WNYEbhs1V_f4QPvAKjE8A4501y0pccuInsaaC2FGQfY_ADGm2M0g07LBnocQHkQBHUwL_KfUkfVr0xSxf3uvz5ZzmysEOUgaSoG2LNTEXCrLgLjK7q6Jd9FDMUe8jLDTU-FyHsj7pVU4-eVmq-V-WomJAZYgMQ8JlLkkzUxy-5OqsWxXjxVlzUvo8xpeYlgz36HhpMOQimM2YN41TXnQKiR0Vw_MBXv2zrgUv6gLh5yf1wTtqhrTPM6fMY-KcY_o_BXvgDzu7zixlMIjbcFGnhJnuVr-hPZtN_TNcNpoP6dNhpm6ruT1rlMzmzfLDiXxmNDEKNu2"><p><strong>所有的组件都必须实现 MenuComponent 接口，然而，叶节点和组合节点的角色不同，所以有些方法可能并不适合某种节点。面对这种情况，有时候，你最好是抛出运行时异常。</strong></p><h2 id="实现菜单项和菜单">实现菜单项和菜单</h2><p>本节重点关注 <code>print()</code> 方法。观察组合模式是如何让 Waitress 能够忽略 MenuItem 和 Menu 的差别。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MenuItem</span> <span class="keyword">extends</span> <span class="title">MenuComponent</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 其他变量和方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;  <span class="comment">// 打印菜单项</span></span><br><span class="line">        System.out.print(<span class="string">"  "</span> + getName());</span><br><span class="line">        <span class="keyword">if</span> (isVegetarian()) &#123;</span><br><span class="line">            System.out.print(<span class="string">"(v)"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">", "</span> + getPrice());</span><br><span class="line">        System.out.println(<span class="string">"     -- "</span> + getDescription());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Menu</span> <span class="keyword">extends</span> <span class="title">MenuComponent</span> </span>&#123;</span><br><span class="line">    ArrayList menuComponents = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他方法和变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;  <span class="comment">// 打印菜单的名字和描述</span></span><br><span class="line">        System.out.print(<span class="string">"\n"</span> + getName());</span><br><span class="line">        System.out.println(<span class="string">", "</span> + getDescription());</span><br><span class="line">        System.out.println(<span class="string">"---------------------"</span>);</span><br><span class="line">        <span class="comment">// 我们如何打印菜单里每个菜单项的内容：我们可以让每个组件打印自己。</span></span><br><span class="line">        Iterator iterator = menuComponents.itertor();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="comment">// menuComponent可能是菜单，也可能是菜单项。无论如何，都有一个print()方法。</span></span><br><span class="line">            MenuComponent menuComponent = (MenuComponent)iterator.next();</span><br><span class="line">            menuComponent.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Waitress</span> </span>&#123;</span><br><span class="line">    MenuComponent allMenus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他方法和变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paintMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只需要调用最顶层菜单的print()，就可以打印整个菜单。</span></span><br><span class="line">        allMenus.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单一责任和组合模式">单一责任和组合模式</h1><p>你告诉我们“一个类，一个责任”，现在却给我们一个让一个类有两个责任的模式。组合模式不但要管理层次结构，而且还要执行菜单的操作。</p><p>你的观察有几分真实性。我们可以这么说，组合模式以单一责任设计原则换取透明性（transparency）。什么是透明性？通过让组件接口同时包含一些管理子节点和叶节点的操作，客户就可以将组合节点和叶节点一视同仁。也就是说，<strong>一个元素究竟是组合还是叶节点，对客户是透明的</strong>。</p><p>现在，我们在 MenuComponent 类中同时具有两种类型的操作。因为客户有机会对一个元素做一些不恰当或是没有意义的操作（例如试图把菜单添加到菜单项），所以我们失去了一些“安全性”。这是设计上的抉择：我们当然也可以采用另一种方向的设计，将责任区分开来放在不同的接口中。这么一来，设计上就比较安全，但我们也因此失去了透明性，客户的代码将必须用条件语句和 instanceof 操作符处理不同类型的节点。</p><p>所以，回到你的问题，<strong>这是一个很典型的折衷案例。尽管我们受到设计原则的指导，但是，我们总是需要观察某原则对我们的设计所造成的影响</strong>。有时候，我们会故意做一些违反原则的事情。然而，在某些例子中，这是观点的问题；比方说，让管理孩子的操作（例如 <code>add()</code>、<code>remove()</code>、<code>getChild()</code>）出现在叶节点中，似乎很不恰当。但是换个角度来看，你可以把叶节点视为没有孩子的节点。</p><h1 id="组合迭代器遍历组合菜单">组合迭代器：遍历组合菜单</h1><p>我们答应过会告诉你怎样用组合来使用迭代器。我们其实已经在 <code>print()</code> 方法内部的实现中使用了迭代器，除此之外，如果有需要，我们也能使用迭代器遍历整个组合。比方说，游走整个菜单，挑出素食项。</p><p><em>遍历打印菜单和遍历菜单是不同的。前者我们已经实现；后者要求客户能取出每一个菜单项，而不单单是显示其内容。后面我们会解释，这是内部迭代器和外部迭代器的区别。</em></p><p>想要实现一个组合迭代器，让我们为每个组件都加上 <code>createIterator()</code> 方法。</p><img src="http://www.plantuml.com/plantuml/svg/fLDDIyD04BtdL-on7Xh_W1IaNWGjWg3dxMRQB6GtONOhbZGNGGeYr9CAdlmJfQZWdp6b_WktgSr74qcBnxnvy_9ctgpB7I0W0Zqa0aGNq7AN2EF8FB1eLscaJ9DJa8EsBm9VWjGaj0ZfW-vG0Oqz4fBzVJA_Uud7RulFXyNh_Vnf6d_SnBCPYLR48r0CUQ2vBxVYdo5dMoXpTG66JP7JBNG3v5BNqwZZDB99ePQF8FmhsAd5U6wxt7CQnX3XjNI6G3KSQq2gVQoR8BAOHvLA4ZCz8WdhN9lX-qIQmCnNsEFWET5I9RwTVhq_nfFdx_4a7sf5ReLeIjlF5bpXk62gmj0X8XsUSAND3URkJFt7Q-PcCz7gqCgvL0zYQe0zoe2iuMIWSFrK8k9IrO7hrRzpiAp0Vdra2qeSAPxzCn7FAwOofTxEmFDsQhkaN2EOJhjLVE1MyRaVZ9hDz9x-gctYQxWyaMsFMkdoh8BhOYazOTiOpFEIIeAMr7D3sPdK3m00"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Menu</span> <span class="keyword">extends</span> <span class="title">MenuComponent</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 其他部分的代码不需要修改</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// CompositeIterator可以遍历组合菜单（包括子菜单）</span></span><br><span class="line">        <span class="comment">// 我们将目前组合的迭代器传入它的构造器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CompositeIterator(menuComponents.iterator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MenuItem</span> <span class="keyword">extends</span> <span class="title">MenuComponent</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 其他部分的代码不需要修改</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NullIterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CompositeIterator 是一个不容小觑的迭代器。它的工作是遍历组件内的菜单项，而且确保所有的子菜单（以及子子菜单……）都被包括进来。注意：跟着我默念“递归是我的朋友，递归是我的朋友……”</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositeIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    Stack stack = <span class="keyword">new</span> Stack();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CompositeIterator</span><span class="params">(Iterator iterator)</span> </span>&#123;</span><br><span class="line">        stack.push(iterator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hasNext()) &#123;</span><br><span class="line">            Iterator iterator = (Iterator) stack.peek();</span><br><span class="line">            MenuComponent component = (MenuComponent) iterator.next();</span><br><span class="line">            <span class="comment">// 如果元素是一个菜单，将它丢进堆栈中</span></span><br><span class="line">            <span class="comment">// 下次next()被调用的时候，就能从子菜单中取出元素</span></span><br><span class="line">            <span class="keyword">if</span> (component <span class="keyword">instanceof</span> Menu) &#123;</span><br><span class="line">                stack.push(component.createIterator());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> component</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Iterator iterator = (Iterator) stack.peek();</span><br><span class="line">            <span class="comment">// 若当前栈顶的迭代器为空，则丢弃它，再次检查栈顶</span></span><br><span class="line">            <span class="keyword">if</span> (!iterator.hasNext()) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">return</span> hasNext(); <span class="comment">// 递归调用hasNext()</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不打算支持删除操作</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真是不可小觑的代码……究竟为什么遍历组合好像比以前为 MenuComponent 类的 <code>print()</code> 写过的遍历代码复杂？</p><p>在我们写 MenuComponent 类的 <code>print()</code> 方法的时候，我们利用了一个迭代器来遍历组件内的每个项。如果遇到的是菜单，我们就会递归地调用 <code>print()</code> 方法处理它。换句话说，MenuComponent 是在“内部”自行处理遍历。</p><p>但是在上面的代码中，我们实现的是一个“外部”的迭代器，所以有许多需要追踪的事情。外部迭代器必须维护它在遍历中的位置，以便外部客户可以通过调用 <code>hasNext()</code> 和 <code>next()</code> 来驱动遍历。在这个例子中，我们的代码也必须维护组合递归结构的位置。</p><h2 id="空迭代器">空迭代器</h2><p>菜单项内没什么可以遍历的，对吧？那么我们要如何实现菜单项的 <code>createIterator()</code> 方法呢？有两种选择：</p><ul><li><p>选择一：返回 null</p><p>我们可以让 <code>createIterator()</code> 方法返回 null，但是如果这么做，我们的客户代码就需要条件语句来判断返回值是否为 null。</p></li><li><p>选择二：返回一个迭代器，而这个迭代器的 <code>hasNext()</code> 永远返回 false</p><p>这似乎是一个更好的方案。我们依然可以返回一个迭代器，客户不用再担心返回值是否为 null。我们等于是创建了一个迭代器，其作用是“没作用”。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NullIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="给我素食菜单">给我素食菜单</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Waitress</span> </span>&#123;</span><br><span class="line">    MenuComponent allMenus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printVegetarianMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterator iterator = allMenus.createIterator();</span><br><span class="line">        System.out.println(<span class="string">"\nVEGETARIAN MENU\n----"</span>);</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            MenuComponent menuComponent = (MenuComponent)iterator.next();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (menuComponent.isVegetarian()) &#123;</span><br><span class="line">                    menuComponent.print();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnsupportedOperationException e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>printVegetarianMenu()</code> 方法内使用了 try/catch 来处理那些不支持 <code>isVegetarian()</code> 方法的菜单的逻辑。</p><p>try/catch 是一种错误处理的方法，而不是程序逻辑的方法。如果不这么做，我们还有哪些选择呢？<strong>我们可以在调用 <code>isVegetarian()</code> 方法之前，用 instanceof 来检查菜单组件的运行时类型，以确定它是菜单项。但是这么做，我们就会因为无法统一处理菜单和菜单项而失去透明性</strong>。</p><p>我们也可以改写 Menu 的 <code>isVegetarian()</code> 方法，让它返回 false。这提供了一个简单的解决方案，同时也保持了透明性。</p><p>我们的解决方案是为了要清楚地表示我们的想法。<strong>我们真正想要传达的是：<code>isVegetarian()</code> 是 Menu 没有支持的操作（这和说 <code>isVegetarian()</code> 是 false 意义不等同）。这样的做法也允许后来人为 Menu 实现一个合理的 <code>isVegetarian()</code> 方法，而我们不必为此在修改这里的代码了</strong>。</p><h1 id="要点">要点</h1><ul><li>迭代器允许访问聚合的元素，而不需要暴露它的内部结构。</li><li>迭代器将遍历聚合的工作封装进一个对象中。</li><li>当使用迭代器的时候，我们依赖聚合提供遍历。（这很合理，避免我们去拷贝聚合的内容，节省了空间。但是我们是不是没有在 UML 类图中加上 ConcreateIterator 指向 Iterator 的依赖箭头？）</li><li>迭代器提供了一个通用的接口，让我们遍历聚合的项，当我们编码使用聚合的项时，就可以使用多态机制。</li><li>我们应该努力让一个类只分配一个责任。</li><li>组合模式提供一个结构，可同时包容个别对象和组合对象。</li><li>组合模式允许客户对个别对象以及组合对象一视同仁。</li><li>组合结构内的任意对象称为组件，组件可以是组合，也可以是叶节点。</li><li>在实现组合模式时，有许多设计上的折衷。你要根据需要平衡透明性（一个类两个责任）和安全性（组件同时实现组合的接口和叶节点的接口）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Head First Design Patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python str.title 方法</title>
      <link href="/documentation/python-str-title-function/"/>
      <url>/documentation/python-str-title-function/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://devdocs.io/python~3.6/library/stdtypes#str.title" target="_blank" rel="noopener"><code>str.title()</code></a></p></blockquote><p>Return a titlecased version of the string where words start with an uppercase character and the remaining characters are lowercase.</p><p>For example:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello world'</span>.title()</span><br><span class="line"><span class="string">'Hello World'</span></span><br></pre></td></tr></table></figure><p>The algorithm uses a simple language-independent definition of a word as groups of consecutive letters. The definition works in many contexts but it means that apostrophes in contractions and possessives form word boundaries, which may not be the desired result:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"they're bill's friends from the UK"</span>.title()</span><br><span class="line"><span class="string">"They'Re Bill'S Friends From The Uk"</span></span><br></pre></td></tr></table></figure><p>A workaround for apostrophes can be constructed using regular expressions:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">titlecase</span><span class="params">(s)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> re.sub(<span class="string">r"[A-Za-z]+('[A-Za-z]+)?"</span>,</span><br><span class="line"><span class="meta">... </span>                  <span class="keyword">lambda</span> mo: mo.group(<span class="number">0</span>)[<span class="number">0</span>].upper() +</span><br><span class="line"><span class="meta">... </span>                             mo.group(<span class="number">0</span>)[<span class="number">1</span>:].lower(),</span><br><span class="line"><span class="meta">... </span>                  s)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>titlecase(<span class="string">"they're bill's friends."</span>)</span><br><span class="line"><span class="string">"They're Bill's Friends."</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板方法模式</title>
      <link href="/notes/head-first-design-patterns/template-method-pattern/"/>
      <url>/notes/head-first-design-patterns/template-method-pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="导入茶和咖啡">导入：茶和咖啡</h1><p>有些人没有咖啡就活不下去；有些人则离不开茶。两者共同的成分是什么？当然是咖啡因了！但还不只这样：茶和咖啡的冲泡方式非常相似。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">星巴兹咖啡冲泡法：</span><br><span class="line">1. 把水煮沸</span><br><span class="line">2. 用沸水冲泡咖啡</span><br><span class="line">3. 把咖啡倒进杯子</span><br><span class="line">4. 加糖和牛奶</span><br><span class="line"></span><br><span class="line">星巴兹茶冲泡法</span><br><span class="line">1. 把水煮沸</span><br><span class="line">2. 用沸水浸泡茶叶</span><br><span class="line">3. 把茶倒进杯子</span><br><span class="line">4. 加柠檬</span><br></pre></td></tr></table></figure><p>茶和咖啡的类：</p><img src="http://www.plantuml.com/plantuml/svg/ZOqx3i8m40Lxdy8b70Ce418qW4IziLyI2tzMQri88UwEar1IKCvezDxeB3G2bwSE21r4ZPCnJeo7CfvorhlKzu1-AQrPm2GumpZ6QjrCbvo_KO4i97Wi-LvSj7cMdAeSegay4rbxgGF99jgJy_Vctj-VA-Ylarm0Rl6MXj_xHuGKf-4F"><p>茶和咖啡的类存在着重复的代码。你会如何重新设计这些类来删除重复代码？</p><a id="more"></a><h1 id="封装算法">封装算法</h1><p>两份冲泡法都采用了相同的算法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 把水煮沸</span><br><span class="line">2. 用热水泡咖啡或茶</span><br><span class="line">3. 把饮料倒进杯子</span><br><span class="line">4. 在饮料内加入适当的调料</span><br></pre></td></tr></table></figure><p><code>brewCoffeeGrinds()</code> 和 <code>steepTeaBag()</code> 差异其实不大。我们给它一个新的方法名称，比方说 <code>brew()</code>，然后不管是泡茶或冲泡咖啡我们都用这个名称。类似地，加糖和牛奶也和加柠檬很相似。</p><img src="http://www.plantuml.com/plantuml/svg/XO-nJW9148RxUuejeQ3GqbX9PMjCR6ZsxkPWaxkzozw2CKX2r8942pM2WX2r824gK9YOKr4UnjqzhNW5Lq0b4cCty___V3EJ8pOWy0A-XJpmJ616xbEn2BDSC2mNXo5A-uu3W8e6GYQ3pKHI5zYsqpwrYGUKXrefJRFhWFyBOZFa35iSfR7c4WehK026ivCD1P_Oo24KkoXW4606Qs2H0COmqoVk1kR0nbtWvzagjVB1k2j-SKi_osUq-JlcrYzlfrBJP_ymzNS6zJaWHh8vZdndxeUbtrUhixwg78cdsxYnfpfNgZLKjGTrLtqjxsIeFByKqUDeqCZGn48IgNurlhcGlLqz9AAoYAvdied59D9MVD8Hpys96_TEjViD7WqEPBFpDgnhAqF5oxxi7egeg-L9K5Frj6grPULUC-HnJLQlz0dlxPwgrJNc0m00"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">final</span> <span class="title">prepareRecipe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boilWater();</span><br><span class="line">    brew();</span><br><span class="line">    pourInCup();</span><br><span class="line">    addCondiments();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="定义模板方法模式">定义模板方法模式</h1><p>模板方法模式在一个方法中定义了一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。</p><p>什么是模板？如你所见的，模板就是一个方法。更具体地说，这个方法将算法定义成一组步骤，其中的任何步骤都可以是抽象的，由子类负责实现。这可以确保算法的结构保持不变，同时由子类提供部分实现。</p><img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYoW2996SM9UUaSYKc5PSK9IQNA3X26SuvYSN52jLS2WebG4qvYIMflgab6Vaf6feArGe5HPcvcIMPPQd-1Qb5YIMP-Nc66fhM2dfwUWgrG1tLCDDgiQiafCG8gAIMAndi0kVylEIYr99KX7jm6OdB75GVsTG07ObYA5TUVacgGb5cUaQ9GduQQW1OAJphsljYuyBdirgURzpzVa_FqvxMfnDMFzdLzcp5mcTpzp-RjlFPvgcF6vhG346nm4hXQV_w5yrxdytfVB5knzCbivxiMFMqTVkJlPCXPZvRt_zaHmDGC2RlPVFUf-lcFU_RW6R3iyw6btCQWAvushhYPVEAPvDxd-oT0m00"><h1 id="对模板方法进行挂钩">对模板方法进行挂钩</h1><p>钩子（hook）是一种被声明在抽象类中的方法，但只有空的或者默认的实现。钩子的存在，可以让子类有能力对算法的不同点进行挂钩。要不要挂钩，由子类自行决定。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CaffeineBeverage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prepareRecipe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        boilWater();</span><br><span class="line">        brew();</span><br><span class="line">        pourInCup();</span><br><span class="line">        <span class="keyword">if</span> (customerWantsCondiments()) &#123;</span><br><span class="line">            addCondiments();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这就是一个钩子，子类可以覆盖这个方法，但不见得一定要这么做</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">customerWantsCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子不一定恰当，但你必须认识到，钩子能作为条件控制，影响抽象类中的算法流程。</p><ul><li><p><strong>问</strong>：当我创建一个模板方法时，怎么才能知道什么时候该使用抽象方法，什么时候使用钩子呢？</p><p><strong>答</strong>：当你的子类“必须”提供算法中某个方法或步骤的实现时，就是用抽象方法。如果算法的这个部分是可选的，就用钩子。</p></li><li><p><strong>问</strong>：使用钩子真正的目的是什么？</p><p><strong>答</strong>：钩子有几种用法。如我们之前所说的，钩子可以让子类实现算法中的可选部分，或者在钩子对于子类的实现并不重要的时候，子类可以对此钩子置之不理。钩子的另一个用法，是让子类能够有机会对模板方法中某些即将发生的（或刚刚发生的）步骤作出反应。比方说，名为 <code>justReOrderedList()</code> 的钩子方法允许子类在内部列表重新组织后执行某些动作（例如在屏幕上重新现实数据）。</p></li><li><p><strong>问</strong>：似乎我应该保持抽象方法的数目越少越好，否则，在子类中实现这些方法将会很麻烦。</p><p><strong>答</strong>：是的，当你在些模板方法的时候，心里要随时记得这一点。想要做到这一点，<strong>可以让算法内的步骤不要切割得太细，但是如果步骤太少的话，会比较没有弹性，所以要看情况折衷</strong>。</p><p>也请记住，某些步骤是可选的，所以你可以将这些步骤实现成钩子，而不是实现成抽象方法，这样就可以让抽象类的子类的负荷减轻。</p></li></ul><h1 id="好莱坞原则">好莱坞原则</h1><blockquote><p>别调用（打电话给）我们，我们会调用（打电话给）你。</p></blockquote><p>好莱坞原则可以给我们一种防止“依赖腐败”的方法。在好莱坞原则之下，我们允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎样使用这些低层组件。换句话说，高层组件对低层组件的方式是“别调用我们，我们会调用你”。</p><p>好莱坞原则和模板方法之间的连接其实还算明显。</p><img src="http://www.plantuml.com/plantuml/svg/XP3BJi9058RtVOfPwe8N8CQ5hDmQ4nVYOcWFqgIqpL0q1aaG204Z5nCH59IOU26e298Gj5uUniwqh7m5Xu8k8CJTp7--y__dd90i0OAmRkoXC8G3G8JGI15b8YeWu43485Wqa0y7Wo2hi08xGF0se9Y0a4v0nmJMG9HrM5ZaIa2JbGri075_kXObgwelghk_sAzP70K8x4vhM99ycYh9OL2D22_61L71aGZoQJnvdFVNDezT1_mVEBF8qhx7CmcPK-IkmcGApoQ_ZWJgrhAhgfe1I86WWRJWp8cyCmghFh7iiMK-sEVfuNsLTfEscRRC_lVRaL-bxPIJUgVN3LQueza-pJoptXNhbJbhjolymIbQRB5wZjQRmth2kJtWJOybkslIzgLTwB16oHgqsEaBPrbbPCfoUQUJia-QO-mhaPoQs5tAYvpFC-krDl4gjknsWkRBl8rTtFXLLYnP7pLha1WXRf1jPfp397Vx0G00"><p>还有哪些模式采用了好莱坞原则？（工厂方法、观察者）</p><p><strong>问</strong>：低层组件不可以调用高层组件中的方法吗？</p><p><strong>答</strong>：并不尽然。事实上，低层组件在结束时，常常会调用从超类中继承来的方法。我们所要做的是，<strong>避免让高层和低层组件之间有明显的环状依赖</strong>。</p><table><thead><tr class="header"><th>模式</th><th>叙述</th></tr></thead><tbody><tr class="odd"><td>模板方法</td><td>子类决定如何实现算法中的步骤</td></tr><tr class="even"><td>策略</td><td>封装可互换的行为，然后使用委托来决定要采用哪一个行为</td></tr><tr class="odd"><td>工厂方法</td><td>由子类决定实例化哪个具体类</td></tr></tbody></table><h1 id="荒野中的模板方法">荒野中的模板方法</h1><h2 id="排序">排序</h2><p>模板方法模式是一个很常见的模式，到处都是。尽管如此，你必须拥有一双锐利的眼睛，因为模板方法有许多实现，而它们看起来并不一定和书上所讲的设计一致。</p><p>我们经常用数组做什么事情？对了！排序。Java 数组类的设计者提供了我们一个方便的模板方法用来排序。让我们看看这个方法如何运行：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sort()只是一个辅助方法，用来创建一个数组的拷贝，然后调用排序算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    Object aux[] = (Object[])a.clone();</span><br><span class="line">    mergeSort(aux, a, <span class="number">0</span>, a.length, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mergeSort()包含排序算法，此算法依赖于compareTo()方法的实现来完成算法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(Object src[], Object dest[],</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> off)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=low; i&lt;hight; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&gt;low &amp;&amp;</span><br><span class="line">             ((Comparable)dest[j-<span class="number">1</span>]).compareTo((Comparable)dest[j])&gt;<span class="number">0</span>; j--) &#123;</span><br><span class="line">               swap(dest, j, j-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要实现 <code>compareTo()</code> 方法，“填补”模板方法的缺憾。</p><p><strong>问</strong>：我们不是应该要继承什么东西吗？我认为这才是模板方法的关键所在。数组无法继承，所以我不知道要如何使用 <code>sort()</code>。</p><p><strong>答</strong>：事情是这样的：<code>sort()</code> 的设计者希望这个方法能使用于所有的数组，所以他们把 <code>sort()</code> 变成是静态的方法，这样一来，任何数组都可以使用这个方法。它使用起来和它被定义在超类中是一样的。因为 <code>sort()</code> 并不是真正定义在超类中，所以 <code>sort()</code> 方法需要知道你已经实现了这个 <code>compareTo()</code> 方法，否则就无法进行排序。</p><p>要达到这一点，设计者利用了 Ccomparable 接口。你须实现这个接口，提供这个接口所声明的方法，也就是 <code>compareTo()</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        Duck other = (Duck)object;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.weight &lt; other.weight) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.weight == other.weight) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序鸭子时，调用Array类的静态方法sort()</span></span><br><span class="line"><span class="comment">// Array.sort(ducks)</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>问</strong>：这真的是一个模板方法模式吗？</p><p><strong>答</strong>：这个<strong>模式的重点在于提供一个算法，并让子类实现某些步骤</strong>。荒野中的模式并非总是如同教科书例子一般地中规中矩，为了符合当前的环境和实现的约束，它们总是要被适当地修改。</p><p>通常我们无法设计一个类继承 Java 数组，而 <code>sort()</code> 方法希望能够适用于所有的数组（每个数组都是不同的类）。所以他们定义了一个静态方法，而由被排序的对象内的每个元素自行提供比较大小的算法部分。所以，这虽然不是教科书上的模板方法，但它的实现仍然符合模板方法模式的精神。再者，由于不需要继承数组就可以使用这个算法，这样使得排序变得更有弹性，更有用。</p></li><li><p><strong>问</strong>：排序的实现看起来更像是策略模式，而不是模板方法模式。为什么我们要将它归为模板方法？</p><p><strong>答</strong>：你之所以会这么认为，可能是因为策略模式使用对象组合。在某种程度上，你是对的——我们使用数组对象排序我们的数组，这部分和策略模式非常相似。但是请记住，<strong>在策略模式中，你所组合的类实现了整个算法</strong>。数组所实现的排序算法并不完整，它需要一个类填补 <code>compareTo()</code> 方法的实现。因此，我们认为这更像模板方法。</p></li><li><p><strong>问</strong>：在 Java API 中，还有其他模板方法的例子吗？</p><p><strong>答</strong>：有的，你可以在一些地方看到它们。比方说 <code>java.io.InputStream</code> 类有一个 <code>read()</code> 方法，是由子类实现的，而这个方法又会被 <code>read(byte b[], int off, int len)</code> 模板方法使用。</p></li></ul><p>想一想另一个模式，它是模板方法的一种特殊情况，原语操作用来创建并返回对象。（工厂方法模式）</p><h2 id="jframe">JFrame</h2><p>JFrame 是最基本的 Swing 容器，继承了一个 <code>paint()</code> 方法。在默认状态下，<code>paint()</code> 是不做事情的，因为它是一个“钩子”！通过覆盖 <code>paint()</code>，你可以将自己的代码插入 JFrame 的算法中，显示出你所想要的画面。</p><h2 id="applet">Applet</h2><p>applet 就是一个能够在网页上面执行的小程序。任何 applet 都必须继承自 Applet 类，而 Applet 类中提供了很多钩子。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// init钩子用来进行applet的初始化动作，</span></span><br><span class="line"><span class="comment">// 它会在applet一开始的时候被调用一次。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// start钩子可以在applet正要被</span></span><br><span class="line"><span class="comment">// 显示在网页上时，让applet做一些动作。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果用户跳到别的网页，这个stop钩子会被调用，</span></span><br><span class="line"><span class="comment">// 然后applet就可以在这里做一些事情来停止它的行动。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当applet即将被销毁（例如：关闭浏览器）时，</span></span><br><span class="line"><span class="comment">// destroy钩子就会被调用。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们的老朋友paint()方法，</span></span><br><span class="line"><span class="comment">// applet也将这个方法当作钩子了。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="要点">要点</h1><ul><li>模板方法定义了算法的步骤，把这些步骤的实现延迟到子类。</li><li>模板方法的抽象类可以定义具体方法、抽象方法和钩子。</li><li>钩子是一种方法，它在抽象类中不做事，或者只做默认的事情，子类可以选择要不要去覆盖它。</li><li>为了防止子类改变模板方法中的算法，可以讲模板方法声明为 final。</li><li>好莱坞原则告诉我们，将决策权放在高层摩卡UI中哦那个，以便决定如何以及何时调用低层模块。</li><li>策略模式和模板方法模式都封装算法，一个用组合，一个用继承。</li><li>工厂方法是模板方法的一种特殊版本。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Head First Design Patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配器模式与外观模式</title>
      <link href="/notes/head-first-design-patterns/adapter-pattern-and-facade-pattern/"/>
      <url>/notes/head-first-design-patterns/adapter-pattern-and-facade-pattern/</url>
      
        <content type="html"><![CDATA[<p>还记得装饰者模式吗？我们将对象包起来，赋予它们新的职责。而现在则是以不同目的，包装某些对象：让它们的接口看起来不像自己而像是别的东西。为何要这样做？因为这样就可以在设计中，将类的接口转换成想要的接口。不仅如此，我们还要探讨另一个模式，将对象包装起来以简化接口。</p><h1 id="适配器模式转换接口">适配器模式：转换接口</h1><h2 id="我们周围的适配器">我们周围的适配器</h2><p>OO 适配器是什么，你一定不难理解，因为现实中到处都是。比方说：如果你需要在欧洲国家使用美国制造的笔记本电脑，你可能需要使用一个交流电的适配器。它位于美式插头和欧式插座的中间，它的工作是将欧式插座转换成美式插座，好让美式插头可以插进这个插座得到电力。</p><p>某些交流电适配器相当简单，它们只是改变插座的形状来匹配你的插头，直接把电流传送过去。但是有些适配器内部则是相当复杂，可能会改变电流以符合装置的需求。</p><h2 id="导入街头顽禽">导入：“街头顽禽”</h2><p>如果它走起路来像只鸭子，叫起来像只鸭子，那么它可能是一只包装了鸭子适配器的火鸡。</p><img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYoW2996SM9UUaScNcbQGMfIKcfogub2PdAzZOm0Nix1IgkHGKgXEJYakA4fDBQXKAInEJipKqKGNJSYg1GhL81eMK5cMdLk8tAZq_AIad5PTPoJc9nSKAleavEOb5AM1tWRH3hLUeLj3NLtWwSIC8zQzMg0LAWJL295vEtV-oOShBnVDUBEm1oi4C2y_CIO4w36GMp7weOPFMWn2cOS_dhyLc6CGWnvJ40g07mUP1ZIu1KoXkXGZfmIoqHbW1D0uIvZLwUiYUvO8584WSuMwuObJhhHIUhfltl6_3i-RDB_QkUTQxw5d7X9YyvxDQdc_S_NHUzxE-fK_x5tEXkbZN3ce60000"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TurkeyAdapter</span> <span class="keyword">implements</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    Turkey turkey;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TurkeyAdapter</span><span class="params">(Turkey turkey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.turkey = turkey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        turkey.gobble();  <span class="comment">// 完成转换</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;  <span class="comment">// 火鸡的飞行距离短，多调用几次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            turkey.fly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="问答">问答</h2><ul><li><p><strong>问</strong>：一个适配器需要做多少“适配”的工作？如果我需要实现一个很大的目标接口，似乎有“很多”工作要做。</p><p><strong>答</strong>：的确是如此。实现一个适配器所需要进行的工作，的确和目标接口的大小成正比。如果不用适配器，你就必须改写客户端的代码来调用这个新的接口，将会花许多力气来做大量的调查工作和代码改写工作。相比之下，提供一个适配器类，将所有的改变封装在一个类中，是比较好的做法。</p></li><li><p><strong>问</strong>：一个适配器只能封装一个类吗？</p><p><strong>答</strong>：虽然大多数的适配器模式所采取的例子都是让一个适配器包装一个被适配者，但我们都知道这个世界其实复杂多了，所以你可能遇到一些状况，需要让一个适配器包装多个被适配着。</p><p>这涉及另一个模式，被称为外观模式（Facade Pattern），人们常常将外观模式和适配器模式混为一谈。</p></li></ul><h2 id="定义适配器模式">定义适配器模式</h2><p>适配器模式将一个类的接口，转换成客户期望的另一个接口。适配器让那个原本接口不兼容的类可以合作无间。</p><p>通过创建适配器进行接口转换，让不兼容的接口变成兼容。这可以让客户从实现的接口解耦。如果在一段时间之后，我们<strong>想要改变接口</strong>，适配器可以将改变的部分封装起来，客户就不必为了应对不同的接口而每次跟着修改。</p><img src="http://www.plantuml.com/plantuml/svg/AyaioKbLK7gwVkUBZGkLNZOqlMpjVJfp1LT6PaggGcfkGKcbGcvgRb9g4KGaERCeEIULApEl9BKeBJ4vLI4aiIWzjKJ1nWOkP6UdKCsbe52Tc5HSKfION5AhK9HQM9fQNAAXoLNBbPoJM5oiu9YIM52IcWfMM5oGcfoPbfaSX4DL4LWLJ4SYX0QAm4rLg8Q9wc6OPQrG2pGEviWQFJsOeLOASBy-NJVlUT-6vxFNFLlG_gnlwTF-nLmmctNjO1OZgN-oe-_5ejKGxek6rkUxMvvEw83ReQVWd9EPcbTYfV1qtQ9d7TkVzgzwFgVxQGUA1G00"><p>这个适配器模式充满着良好的 OO 设计原则：使用对象组合，以修改的接口包装被适配者。这种做法还有额外的优点，那就是，被适配者的任何子类，都可以搭配适配者使用。</p><h2 id="对象和类的适配器">对象和类的适配器</h2><p>实际上有“两种”适配器：“对象”适配器和“类”适配器。“类”适配器需要多重继承才能够实现它，这在 Java 中是不可能的。但是当你在使用多重继承语言的时候，还是可能遇到这样的需求。</p><img src="http://www.plantuml.com/plantuml/svg/AyaioKbLK7g-SRVIouQcbwszJsUkuCh8J4bLICqjAAbKo4tDJKejWeWaPnObvwHo9USa5XShX2GMfQUMA5HpAIWKfHQMfXQNQ6XorK8b7LCI2qfIKy6onGMfoPbfcSb1E5GLePc1NGVKEfiQNLsOFYwOBIY2pZcPgNab2dfsK1TovUMNf2eKPQPdb2Zafy6KMIa0VGptyFFTovzrxe_9Ux5eDKJiHKFhqqazpsUlUxQW7QWG0000"><h2 id="真实世界的适配器">真实世界的适配器</h2><p>早期的 Java 集合（collection）类型（例如：Vecotr、Stack、Hashtable）都实现了一个名为 <code>elements()</code> 的方法。该方法会返回一个 Enumeration（举）。这个 Enumeration 接口可以逐一走过此集合内的每个元素，而无需知道它们在集合内是如何被管理的。</p><p>当 Sun 推出更新后的集合类时，开始使用了 Iterator（迭代器）接口，这个接口和枚举接口很像，都可以让你遍历此集合内的每个元素，但不同的是，迭代器还提供了删除元素的能力。</p><p>而今天……我们经常面对遗留代码，这些代码暴露出枚举接口，但我们又希望在新的代码中只是用迭代器。想解决这个问题，看来我们需要构造一个适配器。</p><img src="http://www.plantuml.com/plantuml/svg/XP0zJiD048NxFSMKKE03XCWDSa41L1nWindBbhm_sXsJ86C98IZfQ2YeQDBGqY38POn2Ri4w3iOHAz6DthwPxxtDyYa2IaEN855EqBAiLKHkHO4iLuGsvGBXs0-Sj8Nnk1VZ62e6KF698yi5rP1nTufpsjlVbLL0ioZr1Ngr7b0ILSgMaslrB-X4MqmAbAZ8XO3Rjmr15DovuVM-JdjtI4K_Uwal0fLFIgNjNg8_t4EelLs5l3iXEjzFQU-apEgPNvp1kNAbCTeIJi_CDaSo5sZyq2tMxFVxhw8eL8I5oXt4G-lWI0H7HUvpZQ3vU5hTlZRlozN3uclvqhmzVpukcDA4K61AeDCGRGJhwvlrtRttVWC0"><p>在这个例子中，适配器并不完美：客户必须小心潜在的异常（不支持 <code>remove()</code> 方法），但只要客户够小心，而且适配器的文档能做出说明，这也算是一个合理的解决方案。</p><h2 id="适配器装饰者外观">适配器、装饰者、外观</h2><p>某些交流电适配器所做的事情不只是改变接口，它们还加了一些其他的特性，例如：电涌保护、指示灯、警报声等。如果要你实现这类特性，你要使用什么模式？（装饰者模式）</p><table><thead><tr class="header"><th>模式</th><th>意图</th></tr></thead><tbody><tr class="odd"><td>装饰者</td><td>不改变接口，但加入新的责任</td></tr><tr class="even"><td>适配器</td><td>将一个接口转成另一个接口</td></tr><tr class="odd"><td>外观</td><td>让接口更简单</td></tr></tbody></table><h1 id="外观模式简化接口">外观模式：简化接口</h1><h2 id="导入甜蜜的家庭影院">导入：甜蜜的家庭影院</h2><p>一个热潮风行全美：建立自己的家庭影院。通过一番研究比较，你组装了一套杀手级的系统，内含 DVD 播放器、投影机、自动屏幕、环绕立体声，甚至还有爆米花机。</p><img src="http://www.plantuml.com/plantuml/svg/lL3BIiD05DtdAsQfYz2zY23r0mfkkucJ6n999aCI2wKKeY2s80sAbY8AWl6ni0iHn3RQVand4btv2qxIH-e3r8shU-wvTyuvTtH31GGMzQh80ci374bF6Mmus0G9cuhhebMBcePcW8Dg4a95jMGgLT7W2H3SMcLAgfMSNSSE045kLaHV4ngcMaU50kAx3ongyw3pkXU8YKqM5jEYQLbrmIkgKoIqCrYpmDFj-UTnknVV7qlrISnPi3HbdbcPegy-i0dOon1LjbmO8w7nEx_yw7yoBDaKsmuHXVx5bDhq9_rSHvPNPX_vYPxTEySlo_9twocThnFR0sI2veb87uzOGl5famyQF3n9xgAtf_qnBXFM3rd_K10lmuvOOOy-3w-JGLWcSUkI1nTYadIRoPaVDmvOT5icl1NnxXNhdO_yRVOyJ8vkHlxEEm00"><p>现在，你准备开始享受一部电影……想看电影，必须先执行一些任务。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">popper.on();</span><br><span class="line">popper.pop();  <span class="comment">// 打开爆米花机，开始爆米花</span></span><br><span class="line"></span><br><span class="line">lights.dim(<span class="number">10</span>);  <span class="comment">// 调暗灯光</span></span><br><span class="line"></span><br><span class="line">screen.down();  <span class="comment">// 降下屏幕</span></span><br><span class="line"></span><br><span class="line">projector.on();</span><br><span class="line">projector.setInput(dvd);</span><br><span class="line">projector.wideScreenMode();  <span class="comment">// 打开并设置投影仪</span></span><br><span class="line"></span><br><span class="line">amp.on();</span><br><span class="line">amp.setDvd();</span><br><span class="line">amp.setSurroundSound();</span><br><span class="line">amp.setVolume(<span class="number">5</span>);  <span class="comment">// 打开并设置功放</span></span><br><span class="line"></span><br><span class="line">dvd.on();</span><br><span class="line">dvd.play(movie);  <span class="comment">// 打开DVD播放机，可以看电影了</span></span><br></pre></td></tr></table></figure><p>还不止是这样……</p><ul><li>看完电影后，还要把一切都关掉。</li><li>如果要听 CD 或者广播，难道也会这么麻烦？</li><li>如果你决定升级你的系统，可能还必须重新学习一套稍微不同的操作过程。</li></ul><h2 id="使用外观模式">使用外观模式</h2><img src="http://www.plantuml.com/plantuml/svg/nLJBJjjG4DtxA-woNIJi4QfK1LNTL48josnS-mQxEBRbkAbG52a425K5X0MDGaW9eZmgAl8GRGYuQJwcldwi-WiTlvF6aSgggpipP-RCcV7rvNWM8voLrJMKnTdNMA4u9yBm2YDWYX7eN0uzbx9ucSEqYfLdD4C3NA0GIh5B0hs65SJu1iGMyq6GpKVH9Kbc94M4GmP4TWy8lwDLXdiXvNdyw36uM6GZH-1pAXQNfHGROBuL02zfbfS2B72A52NJp2gzWX6vtZTlD5DhkLgzEPvcPO7FyA31YSLFC6i6X5un2iOYohc76oa0by0MqTmS8bjzNQkHQjtUhhgO9BhYmCXaV2k7LNy8ruO-lbF8OfMJnecCsfrnyn70OYW-5EjfZsQX0sjMN_m6Cwflo_JR70viu7k8WcWn_qt2v4rwi0ouUl_MBU9C99w4gvy25lDno48Y4L_Y0559aPh-hnpIC7y67bB7mr63U7nYXJ4v2qcK4dWigfHte6Joxo9HKZ4IS4Q5rKu_3lF86XtgWojoLhCkosPF8zqAQVV9_JKPzkp3qxHeDZQjpe2SDKnjKzVwrcL57zphWn8KfSNmn_tzOySkDQpHjjNTC0--f4MVTWmtFfsJzh6vrqsBuu-9zob_bSgUKeLVuLofta3pYBHFZVUtklRPF5adrOwkdNij9bLw-etgllxp21HxfD3KAkteWrqoseAKogvV6OWA4w5xG47k-aRpojd2NWiKGqgOdXRjkcOt3gplju103Rae6yTDVNXYDqlMnVhOEc2H3ldHD_jhdVJAv4FBsXY276SlTQFUyGRHXoD7pbGZeFu3"><h2 id="问答-1">问答</h2><ul><li><p><strong>问</strong>：如果外观封装了子系统的类，那么需要低层功能的客户如何接触这些类？</p><p><strong>答</strong>：<strong>外观没有“封装”子系统的类，外观只提供简化的接口</strong>，所以客户如果觉得有必要，依然可以直接使用子系统的类。这是外观模式一个很好的特征：提供简化的接口的同时，依然将系统完整的功能暴露出来，以供需要的人使用。</p></li><li><p><strong>问</strong>：外观会新增功能吗，或者它只是将每一个请求转由子系统执行？</p><p><strong>答</strong>：外观可以附加“聪明的”功能，让使用子系统更方便。</p></li><li><p><strong>问</strong>：除了能提供一个比较简单的接口之外，外观模式还有其他的优点吗？</p><p><strong>答</strong>：<strong>外观不只是简化了接口，也将客户从组件的子系统中解耦</strong>。比方说，你想要升级你的家庭影院，采用全新的和以前不一样接口的组件，现在你不需要改变客户代码（依旧是 <code>homeTheater.watchMovie()</code>），只需要修改外观代码（而且有可能厂商会提供新版的外观代码）。</p></li><li><p><strong>问</strong>：我可不可以这样说，适配器模式和外观模式之间的差异在于：适配器包装一个类，而外观可以代表许多类？</p><p><strong>答</strong>：不对！适配器将一个或多个接口变成客户所期望的一个接口。虽然大多数例子中适配器只适配一个类，但是你可以适配许多类。类似地，一个外观也可以只针对一个拥有复杂接口的类提供简化的接口。</p><p><strong>两种模式的差异，不在于它们“包装”了几个类，而是在于它们的意图。适配器模式的意图是，“改变”接口符合客户的期望；而外观模式的意图是，提供子系统的一个简化接口。</strong></p></li></ul><h2 id="定义外观模式">定义外观模式</h2><p>外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</p><img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYoW2996SM9UUaSYNd91ONApZdPARcbN11A0KzEmMtnEJ4b5Gk2AMWgskd45oQ55nPN9AQwuXLr0ckMGzPhPN2qsLDp-RDUJQdy-d-rXVB6j_lwNcwRj6pZkrFTiv_sh_-oUwbCNbFzkv_FcN5qxKJdc_U_Npt_EUpMfxrBNtQl_XnGnDNNdv9ga9HPdf6YK9-6jHPLWhF-YSysJVxsOp9JtRrGNG3DG6rFjdH0DSA0000"><h1 id="最少知识原则">最少知识原则</h1><p>只和你的密友谈话。</p><p>当你正在设计一个系统，不管是任何对象，你都要注意它所交互的类有哪些，并注意它和这些类是如何交互的。</p><p>这个原则希望我们在设计中，不要让太多的类耦合在一起，免得修改系统中一部分，会影响到其他部分。如果许多类之间相互依赖，那么这个系统就会变成一个易碎的系统，它需要花许多成本维护，也会因为太复杂而不容易被其他人了解。</p><p>究竟要怎样才能避免这样呢？这个原则提供了一些方针：就任何对象而言，在该对象的方法内，我们只因该调用属于以下范围的方法：</p><ul><li>该对象本身</li><li>被当做方法的参数而传递进来的对象</li><li>此方法所创建或实例化的任何对象</li><li>对象的任何组件</li></ul><p>这些方针告诉我们，如果某对象是调用其他的方法的返回结果，不要调用该对象的方法。这听起来有点严厉，不是吗？如果调用从另一个调用中返回的对象的方法，会有什么害处呢？<strong>如果我们这样做，相当于向另一个对象的子部分发请求（而增加我们直接认识的对象数目）</strong>。在这种情况下，原则要我们改为要求该对象为我们做出请求，这么一来，我们就不需要认识该对象的组件了（让我们的朋友圈子维持在最小的状态）。比方说：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getTemp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thermometer thermometer = station.getThermometer();  <span class="comment">// 取得温度计</span></span><br><span class="line">    <span class="keyword">return</span> thermometer.getTemperature();  <span class="comment">// 从温度计对象取得温度</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 采用最少知识原则</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getTemp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> station.getTemperature();  <span class="comment">// 在气象站中加进一个方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>问</strong>：还有另一个原则，叫做得墨忒耳法则（Law of Demeter），它和最少知识原则有什么关系？</p><p><strong>答</strong>：其实两个名次指的是同一个原则。我们倾向于使用最少知识原则来称呼它是因为以下两个原因：（1）这个名字更直接。（2）法则（Law）给人的感觉是强制的。事实上，没有任何原则是法律，<strong>所有的原则都应该在有帮助的时候才遵守。所有的设计都不免需要折衷（在抽象和速度之间取舍，在空间和时间之间平衡……）</strong>。虽然原则提供了方针，但在采用原则之前，必须全盘考虑所有的因素。</p></li><li><p><strong>问</strong>：采用最少知识原则有什么缺点吗？</p><p><strong>答</strong>：是的，虽然这个原则减少了对象之间的依赖，研究显示这会减少软件的维护成本；但是<strong>采用这个原则也会导致更多的“包装”类被制造出来，以处理和其他组件的沟通，这可能会导致复杂度和开发时间的增加，并降低运行时的性能</strong>。</p></li></ul><h1 id="外观和最少知识原则">外观和最少知识原则</h1><img src="http://www.plantuml.com/plantuml/svg/TLBBBWDH6DxFK_pflariHIHI4JiMbjsCSUZ4t3ATI4GaDQMcYh9m7qgrBerM1LMgF8pvpuoLLt16QIF6wkHyb__xpYKkJX0WicRCWapaSQ9pSHyHH5sG2AVnmZG_HG0h6-vjqstcOOu342G-aO1HLHDKNM6Bnbm00x8cYPCYqI4SxeVenAZ4pmOGWpD1J5yu76pnYQvbdXjMPJ8M9xn1z25Uu5bLVsX7_m_V6HrCTmE2-Tz7_QlfYq1K4ebYS8fg4D35gRW1wkGts0lUwvxJA6ErGAq7p9MfdN4QIOPGEukvxCVpQan1-s9an7tUTY-oJgF2eD1VOIYcqDrhfrd7KijvojBKKZkFIHbQygwttCEaLxtil9RpcFTIhVU5UwnQr4vYRTFDCraQr_DexRqbJPPxPj8Z6tEx-BA3nJ8Mr-YXoU9PzDTslntjPkvfFODBzNQvcF9kdZgF5hKsdUPLEnuBHxXoJ0_kcCdTNyJYjdVkJy9QcbQABEcd5LffQctWyh5_9pSclJfXJKB09q3fuPGUY4Iw_-qJ"><h1 id="要点">要点</h1><ul><li>当需要使用一个现有的类而其接口并不符合你的需求时，就是用适配器。</li><li>当需要简化并统一一个很大的接口或者一群复杂的接口时，使用外观。</li><li>适配器将一个对象包装起来以改变其接口；装饰者将一个对象包装起来以增加新的行为和责任：而外观将一群对象“包装”起来以简化其接口。</li><li>实现一个适配器可能需要一番功夫，也可能不费工夫，视目标接口的大小和复杂度而定。</li><li>实现一个外观，需要将子系统组合进外观中，然后将工作委托给子系统执行。</li><li>适配器模式有两种形式：对象适配器和类适配器。类适配器需要用到多重继承。</li><li>你可以为一个子系统实现一个以上的外观。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Head First Design Patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令模式</title>
      <link href="/notes/head-first-design-patterns/command-pattern/"/>
      <url>/notes/head-first-design-patterns/command-pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="导入遥控器-api">导入：遥控器 API</h1><p>设计一个家电自动化遥控器的 API。这个遥控器具有七个可编程的插槽，每个插槽都有对应的开关按钮。这个遥控器还具备一个整体的撤销按钮。我们希望创建一组控制遥控器的 API，让每个插槽都能控制一个或一组装置。<strong>请注意，能够控制目前的装置和未来可能出现的装置，这一点是很重要的。</strong></p><img src="http://www.plantuml.com/plantuml/svg/VO_D2i8m48JlVOeSzJbQ544GhFGUcsqIIB8XFnOHtzqM4ngncjFiCFjbHqW61BGDTw91Ny5LOdPwwNe5LQ-ez-GekGZaKP7feTbits8O9lLCaHgKaeR_ISwAILtiNBhVIG_XO6mCjQ36W5hS3bNKK53sr54E3Q9Bj6ZpRpXci0-ONJMVU38VqrgL7JK9AAPCYcjWCkgyY-FNtHn2Qm5OmMi3EC2_LMkswEPM36VA9AwLVm40"><p>类的接口各有差异。麻烦还不只是这样，这些类以后还会越来越多。所以设计一个遥控器 API 变得很有挑战性。</p><p>遥控器应该知道如何解读按钮被按下的动作，然后发出正确的请求，但是遥控器不需知道这些家电自动化的细节。我们不想让遥控器包含一大堆 if 语句，例如 <code>if slot1 == Light then light.on(), else if slot1 == GarageDoor then garageDoor.up()</code>。大家都知道这样的设计很糟糕。</p><h1 id="命令模式">命令模式</h1><p>命令模式可将“动作的请求者”（遥控器）从“动作的执行者”（家电装置）对象中解耦。</p><p>怎么能将它们解耦？采用“命令对象”就可以办到。把请求（例如“打开电灯”）封装成一个特定对象。如果对每个按钮都存储一个命令对象，那么当按钮被按下的时候，就可以请”命令对象“做相关的工作。遥控器并不需要知道工作的内容是什么，只要有个命令对象能和正确的对象（即家电装置）沟通，把事情做好就可以了。</p><a id="more"></a><ul><li>实现命令接口</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现一个打开电灯的命令</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOnCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    Light light;  <span class="comment">// 执行命令的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightOnCommand</span><span class="params">(Light light)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// execute方法知道如何沟通家电装置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light.on();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用命令对象</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleRemoteControl</span> </span>&#123;</span><br><span class="line">    Command slot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleRemoteControl</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        slot = command;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遥控器不知道会发生什么，只知道按钮被按下时调用命令的execute方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buttonWasPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        slot.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>简单测试</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteControlTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleRemoteControl remote = <span class="keyword">new</span> SimpleRemoteControl();</span><br><span class="line">        Light light = <span class="keyword">new</span> Light();</span><br><span class="line">        LightOnCommand lightOn = <span class="keyword">new</span> LightOnCommand(light);</span><br><span class="line"></span><br><span class="line">        remote.setCommand(lightOn);  <span class="comment">// 组装</span></span><br><span class="line">        remote.buttonWasPressed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="定义命令模式">定义命令模式</h1><p>命令模式将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。</p><p>一个命令对象通过在特定接收者上绑定一组动作来封装一个请求。要达到这一点，命令对象将动作和接收者包进对象中。这个对象只暴露出一个 <code>execute()</code> 方法，当此方法被调用的时候，接收者就会进行这些动作。从外面来看，其他对象不知道究竟哪个接收者进行了哪些动作，只知道如果调用 <code>execute()</code> 方法，请求的目的就能达到。</p><img src="http://www.plantuml.com/plantuml/svg/VP11Im915CVl-odcM8Vy025UF7Njx6KTdxdapihkA8K9c-R142kmX912Cf2WL0nJDkd3j3kkfxv2quwEkK5xcUMzDx__xqr6Im42FKUFaGvw4ambyrF1cecpeE2iQbbeZnICGp1HKK7yYnkwhf8Kmk8CQXRGPNbhMoaf6g5WfbKCSZWQbRLOR0dQ1mnQWNFDvKzGBQf9YvegfYK4Hu3p53WorCYJb1442R-uGR0955PX_-4tcI6Gl288F4ipID2NU-oiNcCNiVefQzVSYUrEdhohcUjqlVxK7tQKi4yadukSn5PleSWK3WkDRa9Puv4rnxvTLOX10PdQGOOY8xqsy0ULURF71xxUwrwxn-ul-Qq4OQtnelKwBqz5NxWbYB2Rtvx9D-2ZDrCsklwqoo8Y2-aWOQrJixdEx-qMbHb7VLGN7STxkPit1kovoqMzYmT9aQ9_jXD2SY_kufttt5cR-xlE8tCw_dZazz_OiCnXtm00"><h1 id="实现遥控器">实现遥控器</h1><img src="http://www.plantuml.com/plantuml/svg/ZLD1RzCm5BxdL_Yu7TRTIzK3krQ0k73XagKEhPJOA76bebAfPTqeexHbR4ni73POjGd4sWbKsfNy6cAdEV4NSEBK96qEv63PttlvlkVlFPVAHGYW-PGy0oOqjw6bb094ArkQ0HNDK6qRF8Gc9d0B8s9X0zGKmBz2sIO0eoricYegsZ5CrnDWT00LLCJHFiHjIABZsde8O7ItGWX6ZrJxGSKkGOdhUdeWO5oDr9Ko8j3ILGrAxLnEOlbyT86QkcqJIzL87S0gr2e4HhInGA0GKWeV2kKd9N9_SMTf10U14QpXMPA1ca0p6Asjtm5rMNCyfEiYbfIG5lw_ne8eJGGbDUxX97kSRNCJkBE6EstxEuuxUKER9ykSgHc9yYFQG7RHmD34v1Xjv1VjoGBMQRAFhzn9mvkrsBuplpcdRnrtTg781ZxFP9RiJuj9tv91UM5bgOCRl8WGKfPz_nSHLHUmMeGMo2Jp9L6EgyGJL_XM4X3V0WFgmOD9Fh0iyAxFlVwUi4COyUTNXmrxr7d7Ejocrtpr3wuv-1ZHqSryjECTNdcd4tfxw9sqgjMLHy7UJzdtep3VF_x1kWE_SSRQ_Vbm8EZvNt88HExyqrT1-xln8grMSOiieErJEhiLB7GuvPtZAbvhJFlTeBOzkZkc-sTpnw7jaTySiEub_N35vLZlW5to-Vac-QrmTBY0d8femykblS-qts77Oywv-vDUlEJUk9ClOYP5mPpdBm00"><p>NoCommand 对象是一个空对象（null object）的例子。当你不想返回一个有意义的对象时，空对象就很有用。在许多设计模式中，都会看到空对象的使用。甚至有些时候，空对象本身也被爱视为一种设计模式。接下里看看 RemoteControl 的代码理解遥控器是如何记录并撤销上一个命令的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteControl</span> </span>&#123;</span><br><span class="line">    Command[] onCommands;</span><br><span class="line">    Commandp[] offCommands;</span><br><span class="line">    Command undoCommand;  <span class="comment">// 前一个命令将被记录在这里</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RemoteControl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        onCommands = <span class="keyword">new</span> Command[<span class="number">7</span>];</span><br><span class="line">        offCommands = <span class="keyword">new</span> Command[<span class="number">7</span>];</span><br><span class="line">        Command noCommand = <span class="keyword">new</span> NoCommand();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            onCommand[i] = noCommand;</span><br><span class="line">            offCommand[i] = noCommand;</span><br><span class="line">        &#125;</span><br><span class="line">        undoCommand = noCommand;  <span class="comment">// 初始时，撤销命令什么都不做</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(<span class="keyword">int</span> slot, Command onCommand, Command offCommand)</span> </span>&#123;</span><br><span class="line">        onCommands[slot] = onCommand;</span><br><span class="line">        offCommands[slot] = offCommand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onButtonWasPushed</span><span class="params">(<span class="keyword">int</span> slot)</span> </span>&#123;</span><br><span class="line">        onCommands[slot].execute();</span><br><span class="line">        undoCommand = onCommands[slot];  <span class="comment">// 记录前一个命令</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offButtonWasPushed</span><span class="params">(<span class="keyword">int</span> slot)</span> </span>&#123;</span><br><span class="line">        offCommands[slot].execute();</span><br><span class="line">        undoCommand = offCommands[slot];  <span class="comment">// 记录前一个命令</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undoButtonWasPushed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        undoCommand.undo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>电灯的撤销很容易。通常，想要实现撤销的功能，需要记录一些状态。比方说天花板上的吊扇，吊扇允许有多种转动速度，当然也允许被关闭。我们需要追踪吊扇的最后设置速度，如果 <code>undo()</code> 方法被调用了，就要恢复成之前吊扇速度的设置值。天花板吊扇有四个命令，分别对应“关闭”、“低速”、“中速”和“高速”四种操作。下面是 CeilingFanHighCommand 的代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CeilingFanHighCommand</span> </span>&#123;</span><br><span class="line">    CeilingFan ceilingFan;</span><br><span class="line">    <span class="keyword">int</span> prevSpeed;  <span class="comment">// 追踪最后设置速度</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CeilingFanHighCommand</span><span class="params">(CeilingFan ceilingFan)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ceilingFan = ceilingFan;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        prevSpeed = ceilingFan.getSpeed();  <span class="comment">// 记录状态</span></span><br><span class="line">        ceilingFan.high();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prevSpeed == CeilingFan.HIGH) &#123;</span><br><span class="line">            ceilingFan.high();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevSpeed == CeilingFan.MEDIUM) &#123;</span><br><span class="line">            ceilingFan.medium();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevSpeed == CeilingFan.LOW) &#123;</span><br><span class="line">            ceilingFan.low();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevSpeed == CeilingFan.OFF) &#123;</span><br><span class="line">            ceilingFan.off();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="party-模式宏命令">Party 模式：宏命令</h1><p>如果拥有了一个遥控器，却无法光凭按下一个按钮，就能同时弄按灯光、打开音响和电视、设置好 DVD，并让热水器开始加温，那么要这个遥控器还有什么意义？</p><p>我们可以做到这一点，而且完全不需要改变遥控器。</p><img src="http://www.plantuml.com/plantuml/svg/bLB1IiD05BplLpmyjOUsz6pfnQlYfVIUfXiRQ3QIR4MfWQhrK2c8e3s87Wg28egA89LO_HZJJM_-WadNfjbjA3M7aCpipBptzjNqAWPiRDCzCB1HmHQgXOYgMseT8vrGR6cAYc7DD0o5LA5GYB1Y4Pe8WgUfL6ngAIfr0EzYjK5nAYqJ3L8r0zH1QbsnRLZNjsfqaqnTkSy4X7hudln7Pj3aQDOagVGgE1EMEyueJUES6A5f_ywO6YM5436ZL1PxA9M1xY0GnY1r7aZ4cfRGyA9v0s49_2EiCsQxcDzGLCkKHs5JK3bapmqZbmFlyvezzCVFH_xvtVISDtXaJwVUu7vqDlJS6_-o7ObOxvszNiY3Mzg7Ao8J1qKhjv_DIWkJn4LJ5SdO5SqHoPAiC2mahMecK-I1I5wm6HDVYn0jbP5mxN-Ov5n8Jfx9vWx4SvB81L9YKWmhldlBEb_iP3X-wVEB-Fdeiku1k-fuWvRljaV7RvxRuzHtwt0551j87WdR55YJ_2y0"><h1 id="问答">问答</h1><ul><li><p><strong>问</strong>：接收者一定有必要存在吗？为何命令对象不直接实现 <code>execute()</code> 方法的细节？</p><p><strong>答</strong>：一般来说，我们尽量设计“傻瓜”命令对象，它只懂得调用一个接收者的一个行为，然而，有许多“聪明”命令对象会实现许多逻辑，直接完成一个请求。当然，你可以设计聪明的命令对象，只是这样一来，调用者和接收者之间的解耦成都是比不上“傻瓜”命令对象的，而且，你也不能够把接收者当作参数传给命令。</p></li><li><p><strong>问</strong>：如果能够实现多层次的撤销操作？</p><p><strong>答</strong>：不要只是记录最后一个被执行的命令，而是用一个堆栈记录操作过程的每一个命令。当按下了撤销按钮，从堆栈中取出最上层的命令，然后调用它的 <code>undo()</code> 方法。</p></li><li><p><strong>问</strong>：我可以创建一个 PartyCommand，然后在它的 <code>execute()</code> 方法中调用其他命令，利用这种做法实现 Party 模式吗？</p><p><strong>答</strong>：你可以这么做，然而，这等于把 Party 模式“硬编码”到 PartyCommand 中。为什么要这么麻烦呢？<strong>利用宏命令，你可以动态地决定 PartyCommand 是由哪些命令组成，所以宏命令在使用上更灵活。</strong>一般来说，宏命令的做法更优雅，也需要较少的代码。</p></li></ul><h1 id="命令模式的更多用途">命令模式的更多用途</h1><p>命令可以将运算块打包（一个接收者和一组动作），然后将它传来传去，就像是一般的对象一样。现在，即使在命令对象被创建许久之后，运算依然可以被调用。事实上，<strong>它甚至可以在不同的线程中被调用</strong>。我们可以利用这样的特性衍生一些应用。例如：日程安排、线程池、工作队列等。</p><h2 id="队列请求">队列请求</h2><p>想想有一个工作队列：你在某一端添加命令，然后另一段则是线程。线程进行下面的动作：从队列中取出一个命令，调用它的 <code>execute()</code> 方法，等待这个调用完成，然后将此命令对象丢弃，再取出下一个命令……</p><p>工作队列类和进行计算的对象之间完全是解耦的。此刻线程可能在进行财务计算，下一刻却在读取网络数据。工作队列对象不在乎到底做些什么，它们只知道取出命令对象，然后调用其 <code>execute()</code> 方法。类似地，只要是实现命令模式的对象，就可以放入队列里，当线程可用时，就调用对象的 <code>execute()</code> 方法。</p><h2 id="日志请求">日志请求</h2><p><strong>某些应用需要我们将所有的动作都记录在日志中，并能在系统死机之后，重新调用这些动作恢复到之前的状态。</strong>通过新增两个方法（<code>store(), load()</code>），命令模式就能够支持这一点。在 Java 中，我们可以利用对象的序列化（Serialization）实现这些方法，但是一般认为序列化最好还是只用在对象的持久化（persistence）上。</p><p>要怎么做呢？当我们执行命令的时候，将历史记录储存在磁盘中。一旦系统死机，我们就可以将命令对象重新加载，并成批地依次调用这些对象的 <code>execute()</code> 方法。</p><p>这种日志的方式对于遥控器来说没有意义，然而，<strong>有许多调用大型数据结构的动作的应用无法在每次改变发生时被快速地存储</strong>。通过使用记录日志，我们可以将上次检查点（checkpoint）之后的所有操作记录下来，如果系统出状况，从检查点开始应用这些操作。比方说，<strong>对于电子表格应用，我们可能想要实现的错误恢复方式是将电子表格的操作记录在日志中，而不是每次电子表格已有变化就记录整个电子表格</strong>。对更高级的应用而言，<strong>这些技巧可以被扩展应用到事物（transaction）处理中</strong>，一整群操作必须全部进行完成，或者没有进行任何的操作。</p><h1 id="要点">要点</h1><ul><li>命令模式将发生请求的对象和执行请求的对象解耦。</li><li>在被解耦的两者之间是通过命令对象进行沟通的。命令对象封装了接收者和一个或一组动作。</li><li>调用者可以接受命令当作参数，甚至在运行时动态地进行。</li><li>命令可以支持撤销，做法是实现一个 <code>undo()</code> 方法来回到 <code>execute()</code> 被执行前的状态。</li><li>宏命令是命令的一种简单的延伸，允许调用多个命令。宏方法也支持撤销。</li><li><strong>实际操作时，很常见使用”聪明“命令对象，也就是直接实现了请求，而不是将工作委托给接收者。</strong></li><li>命令也可以用来实现日志和事物系统。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Head First Design Patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单件模式</title>
      <link href="/notes/head-first-design-patterns/singleton-pattern/"/>
      <url>/notes/head-first-design-patterns/singleton-pattern/</url>
      
        <content type="html"><![CDATA[<p>有一些对象其实我们只需要一个，比方说：线程池（threadpool）、缓存（cache）、对话框、处理偏好设置和注册表（registry）的对象、日志对象，充当打印机、显卡等设备的驱动程序的对象。事实上，这类对象只能有一个实例，如果制造出多个实例，就会导致许多问题产生，例如：程序的行为异常、资源使用过量，或者是不一致的结果。</p><p>单件模式是经得起时间考验的方法，可以确保只有一个实例会被创建。单件模式也给了我们一个全局访问点，和全局变量一样方便，有没有全局变量的缺点。什么缺点？举例来说：如果将对象赋值给一个全局变量，那么你必须在程序已开始就创建好对象（这其实和实现有关。有些 JVM 的实现是：在用到的时候才创建对象），对吧？万一这个对象非常耗费资源，而程序在这次的执行过程中又一直没用到它，不就形成浪费了吗？</p><h1 id="定义单件模式">定义单件模式</h1><p>单件模式确保一个类只有一个实例，并提供一个全局访问点。</p><img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYoW2996SM9UUaSYNd91ONAmHdvgNdf9RavobKSoae51HbbYMMf2A9bkPb5fQcUkOLboJc9QU2b9GcvMGcAm3v9K0AeJ0zjGIcIaCJgAuwDxKa8p-bLa5VN-5fwxOdkwSzcxRpsUQfNBLS24swTWWJh1IUzJG-czFvedtLq-qRdyzgURfdwlCfAm00"><h1 id="经典的单件模式实现">经典的单件模式实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个版本有一个问题。有多个线程要执行 <code>Singleton.getInstance()</code> 时，可能会产生不同的对象。</p><table><thead><tr class="header"><th>线程一</th><th>线程二</th><th>uniqueInstance</th></tr></thead><tbody><tr class="odd"><td><code>public static Singleton getInstance() {</code></td><td></td><td><code>null</code></td></tr><tr class="even"><td></td><td><code>public static Singleton getInstance() {</code></td><td><code>null</code></td></tr><tr class="odd"><td><code>if (uniqueInstance == null) {</code></td><td></td><td><code>null</code></td></tr><tr class="even"><td></td><td><code>if (uniqueInstance == null) {</code></td><td><code>null</code></td></tr><tr class="odd"><td><code>uniqueInstance = new Singleton();</code></td><td></td><td><code>&lt;object1&gt;</code></td></tr><tr class="even"><td><code>return uniqueInstance;</code></td><td></td><td><code>&lt;object1&gt;</code></td></tr><tr class="odd"><td></td><td><code>uniqueInstance = new Singleton();</code></td><td><code>&lt;object2&gt;</code></td></tr><tr class="even"><td></td><td><code>return uniqueInstance;</code></td><td><code>&lt;object2&gt;</code></td></tr></tbody></table><a id="more"></a><h1 id="处理多线程">处理多线程</h1><p>只要把 <code>getInstance()</code> 变成同步（synchronized）方法，多线程灾难几乎就可以轻易地解决了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样可以解决问题，但是同步会降低性能。更严重的是：只有第一次执行此方法时，才真正需要同步。换句话说，一旦设置好 uniqueInstance 变量，就不再需要同步这个方法了。之后每次调用这个方法，同步都是一种累赘。</p><h1 id="改善多线程">改善多线程</h1><h2 id="用回经典的单件模式">用回经典的单件模式</h2><p>没错，如果你的应用程序可以接受 <code>getInstance()</code> 造成的额外负担，就忘了这件事吧。</p><h2 id="使用急切创建实例">使用“急切”创建实例</h2><p>如果应用程序总是创建并使用单件模式，或者在创建和运行时方面的负担不太繁重，你可能要想急切（eagerly）创建此单件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用这个做法，我们依赖 JVM 在加载这个类时马上创建此唯一的单件示例。JVM 保证在任何线程访问 uniqueInstance 静态变量之前，一定先创建此实例。</p><h2 id="双重检查加锁">双重检查加锁</h2><p>利用双重检查加锁（doule-checked locking），首先检查是否实例已经创建了，如果尚未创建，”才“进行同步。这样一来，只有第一次会同步，这正是我们想要的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// volatile 关键词确保，当uniqueInstance变量被初始化成实例时，</span></span><br><span class="line">    <span class="comment">// 多个线程正确地处理uniqueInstance变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;  <span class="comment">// 进入区块后，再检查一次</span></span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果性能是你关心的终点，那么这个做法可以帮你大大地减少 <code>getInstance()</code> 的时间耗费。</p><h2 id="iodh">IoDH</h2><p>一种被称为 Initialization Demand Holder（IoDH）的技术同样可以帮助我们达到双重锁定的效果。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HolderClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HolderClass.uniqueInstance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>加载 Singleton 时，由于 uniqueInstance 不是其成员变量，因此不会实例化。只有第一次调用 getInstance 时，才会加载内部类 HolderClass。其内部有一个 static 修饰的成员变量 uniqueInstance，此时会初始化这个成员变量，由 JVM 负责其线程安全性。</p><h1 id="问答">问答</h1><ul><li><p><strong>问</strong>：难道我不能创建一个类，把所有的方法和变量都定义为静态的，把类直接当做一个单件？</p><p><strong>答</strong>：如果你的类自给自足，而且不依赖于复杂的初始化，那么你可以这么做。但是，因为静态初始化的控制权是在 Java 手上，这么做有可能导致混乱，特别是当有许多类牵涉其中的时候。这么做常常会造成一些微妙的、不容易发现的和初始化有关的 bug。<strong>除非你有绝对的必要使用类的单件，否则还是建议使用对象的单件，比较保险。</strong></p></li><li><p><strong>问</strong>：听说两个类加载器（class loader）可能有机会各自创建自己的单件实例。</p><p><strong>答</strong>：是的。每个类加载器都定义了一个命名空间，如果有两个以上的类加载器，不同的类加载器可能会加载同一个类，从整个程序来看，同一个类会被加载多次。如果这样的事情发生在单件上，就会产生多个单件并存的怪异现象。所以，<strong>如果你的程序有多个类加载器又同时使用了单件模式，请小心。有一个解决办法：自行指定类加载器，并指定同一个类加载器。</strong></p></li><li><p><strong>问</strong>：单件有没有违反“一个类，一个责任”的原则呢？</p><p><strong>答</strong>：是违反了。单件类不只负责管理自己的实例，还在应用程序中担当角色，所以也可以被视为两个责任。尽管如此，由类管理自己的实例的做法并不少见。这可以让整体设计更简单。更何况，许多开发人员都已经熟悉了单件模式的这种做法。</p></li></ul><h1 id="要点">要点</h1><ul><li>单件模式确保程序中一个类最多只有一个实例。</li><li>单件模式也提供访问这个实例的全局点。</li><li>在 Java 中实现单件模式需要私有的构造器、一个静态方法和一个静态变量。</li><li>确定在性能和资源上的限制，然后小心地选择适当的方法来实现单件，以解决多线程问题（我们必须认定所有的程序都是多线程的）。</li><li>小心，你如果使用多个类加载器，可能导致单件失效而产生多个实例。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Head First Design Patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式</title>
      <link href="/notes/head-first-design-patterns/factory-pattern/"/>
      <url>/notes/head-first-design-patterns/factory-pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="导入比萨店">导入：比萨店</h1><p>身为比萨店的主人，你的代码可能这么写：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Pizza <span class="title">orderPizza</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Pizza pizza = <span class="keyword">new</span> Pizza();</span><br><span class="line"></span><br><span class="line">    pizza.prepare();</span><br><span class="line">    pizza.bake();</span><br><span class="line">    pizza.cut();</span><br><span class="line">    pizza.box();</span><br><span class="line">    <span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="当看到-new就会想到具体">当看到 &quot;new&quot;，就会想到具体</h2><p>是的，当使用 &quot;new&quot; 时，你的确是在实例化一个具体类，所以用的的确是实现，而不是接口。</p><p>当你需要更多比萨类型时，通常会写出这样的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Pizza <span class="title">orderPizza</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">    Pizza pizza;</span><br><span class="line">    <span class="comment">// 这是变化的部分，随着时间过去，比萨菜单改变，这里必须一改再改</span></span><br><span class="line">    <span class="keyword">if</span> (type.equals(<span class="string">"cheese"</span>)) &#123;</span><br><span class="line">        pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"greek"</span>)) &#123;</span><br><span class="line">        pizza = <span class="keyword">new</span> GreekPizza();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"pepperoni"</span>)) &#123;</span><br><span class="line">        pizza = <span class="keyword">new</span> PepperoniPizza();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里是不变的部分</span></span><br><span class="line">    pizza.prepare();</span><br><span class="line">    pizza.bake();</span><br><span class="line">    pizza.cut();</span><br><span class="line">    pizza.box();</span><br><span class="line">    <span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当代码使用大量的具体类时，等于是自找麻烦，因为一旦加入新的具体类，就必须修改代码。也就是说，你的代码并非“对修改关闭”。</p><a id="more"></a><h2 id="简单工厂">简单工厂</h2><img src="http://www.plantuml.com/plantuml/svg/TOun2i9044NxFSMKMcGFe68ZM0i1-yrcD8i92PCLZ1fGEq4yWQsD5z03cPp3JJP2X5ZjylwRcHye7m6ZH6SGOUGXiQ0YKf4CaSbGf2dCr7OhN1qJmeu1k2fAGgpXL4Y3CrZOruGn-KXrrkl3xXjmIIWqDdm8d7F8MTxixrXOtVcPCRBmKaqcjtrg9I5C1A690JoniX-vrXR4ctgkLTyPTnmRG7avbhVp-tLulnx5yrvSJwoZ4-TZc0I8gSN_b3akbwfHMZgCzevZgxEMqi8V"><ul><li><p><strong>问</strong>：这样做有什么好处？似乎只是把问题搬到另一个对象罢了，问题依然存在。</p><p><strong>答</strong>：SimplePizzaFactory 可以有许多的客户。虽然目前只看到 <code>orderPizza()</code> 方法是它的客户。我们也正把具体实例化的过程，从客户的代码中删除。当以后实现改变时，只需修改这个工厂类即可。</p></li><li><p><strong>问</strong>：我曾看过一个类似的设计方式，把工厂定义成一个静态的方法，这有何差别？</p><p><strong>答</strong>：利用静态方法定义一个简单的工厂，这是很常见的技巧，常被称为静态工厂。但请记住，这也有缺点，不能通过继承来改变创建方法的行为。</p></li></ul><p><strong>简单工厂其实不是一个设计模式，反而比较像是一种编程习惯。</strong>有些开发人员的确是把这个编程习惯误认为是“工厂模式”（Factory Pattern）。</p><h1 id="加盟比萨店">加盟比萨店</h1><p>身为加盟公司经营者，你希望确保加盟店营运的质量，所以希望这些店都是用你那些经过时间考验的代码（PizzaStore）。</p><p>但是区域的差异呢？每家加盟店都可能想要提供不同风味的比萨（比如说纽约、芝加哥、加州），这受到了开店地点及该地区比萨美食家口味的影响。</p><h2 id="多个简单工厂">多个简单工厂</h2><p>如果利用 SimplePizzaFactory，写出三种不同的工厂，分别是 NYPizzaFactory、ChicagoPizzaFactory、CaliforniaPizzaFactory，那么各地加盟店都有合适的工厂可以使用，这是一种做法。</p><img src="http://www.plantuml.com/plantuml/svg/ZPBDRi8m48JlVeezqWD-0IGkI1nH9KuSDsPfBEmwshXIWVBkzK_2J-88JebclXdlEgdrde1iuqzWoLR4eewAqgmC2MMmRU5Jdy-uzOu9BW9WgsrZA8bhL44-mI4_W-buJvoysGTSUaCg9lJKwGkGKi9LNBl-pUwfB9xnnD_0LQqLVhbtQJJwuFXRuyi0LgtduETL4z8mDSWKR80AZ_b5_VWikD-KUxYP-NmvM6Je5gOV8SMHnMQtgedQF700_vPvq6WOj2EvEsaYrBl5v6s0gV0TAEK7drBAU2aFLHD0NoLANpWouurUelVEyd-GsDAwRmRw_dy0"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NYPizzaFactory nyFactory = <span class="keyword">new</span> NYPizzaFactory();  <span class="comment">// 创建一个工厂</span></span><br><span class="line">PizzaStore nyStore = <span class="keyword">new</span> PizzaStore(nyFactory);   <span class="comment">// 建立一个比萨店，将纽约工厂的引用作为参数</span></span><br><span class="line">nyStore.orderPizza(<span class="string">"Cheese"</span>);  <span class="comment">// 制造纽约风味的比萨</span></span><br></pre></td></tr></table></figure><h2 id="更具弹性的设计">更具弹性的设计</h2><p>在推广 SimpleFactory 时，你发现加盟店的确是采用你的工厂创建比萨，但是其他部分，却开始采用他们自创的流程：烘烤的做法有些差异、不要切片、使用其他厂商的盒子。你希望能够给建立一个框架，把加盟店和创建比萨捆绑在一起的同时又保持一定的弹性。</p><p>我们先解决第一个问题：让你的加盟店可以采用各自的流程。很简单，提取出一个抽象比萨店即可。</p><img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYoW2996SM9UUaSYKc5PSK9IQNA0HaLbKb1fVa5wKgL7CfA0HdvXRaf885tO3I-KML2caG6YYPNvIIMWIMqz1Kg5RGrrTuldBNiwsDprTqF-kOzdBtZ1Vhba2u2hLSjLp9EOd5nGf-aS4bbL0ZoRRdQUls9tidOvZjd96Pd9YUJpiB_29HJ00Pd5oKcbYI2jMCxXA2gb737Qoae2Yr8B4e5IYje92Kc0rX99UMG0JoAy3wa7ndKwEhYncg62gmXmqNPdJewjgX-PCBHxY2L6BnAD1CvupKr6A8Kg2g6Zk8zq0IEOcv6C9GCt1eWibYquaM7tfw8ASZcOD30SmeBcpH15A3wIA2Ic5c0W00"><p>我们发现加盟店和工厂总是一一对应的，使用组合令整个系统有些过于复杂了。</p><p>现在解决我们的第二个问题：把加盟店和创建比萨捆“绑”在一起。做法是在比萨店中使用一个抽象的方法代替原来的工厂对象。</p><img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYoW2996SM9UUaSYKc5PSK9IQNA0HaLbKb1fVa5wKgL7CfAEGNfQGMWSKqD87SQfYwMeNaejJ4abIeb4ArWhw-mhEklIysBdm-g-NfzgLF-vgUJTlvRFDKXLgWleAYr8B4ebIm6Kc9sH16Sca9H22_0aZNSYNd91ONA_X51fTKvgJYTmSMov-sRd-oTp8soy7sG1Lrj3_hc02KUxft4L0EPgTpHcPoOde-jIs6-1IYoj3KuEckPS-RPpnlNc9ayBIZxUMa-M0Ne8Oys4wYGWl9dJOrkhgOuOQX0hilkVmYdJDIKuiXGWgwkZLs4AU0978ISp64eSRWq0IJnQOJCshrzEmKKEp7hGPc81UEo08fmtGQCQfX9WC0"><p>NYStylePizzaStore 的工厂方法应该像这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">    Pizza pizza;</span><br><span class="line">    <span class="keyword">if</span> (type.equals(<span class="string">"cheese"</span>)) &#123;</span><br><span class="line">        pizza = <span class="keyword">new</span> NYCheesePizza();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"clam"</span>)) &#123;</span><br><span class="line">        pizza = <span class="keyword">new</span> NYClamPizza();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义工厂方法">定义工厂方法</h2><p>工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。</p><p><strong>所谓的“决定”，并不是指模式允许子类本身在运行时做决定（工厂子类能生产的产品在编写时就已经固定了）</strong>，而是指在编写创建者 Creator 类时，不需要知道实际创建的产品是哪一个。选择了使用哪个子类，自然就决定了实际创建的产品是什么。</p><img src="http://www.plantuml.com/plantuml/svg/VL9DIm916BxlhnWyrQ6WQtHfEqVz02_hEgAWip9EXx1Waom3jS2IoZAZfF2WIHzkg-AFQTzPFVKNcdLNApCl0_EypzSxJ3WIn0Z7ucmRnN0iWAaKTX0rGjKebfH0Wb55PMYJQi4jbNq3QnGhJACeAI6K7A6xA2HEZMwlOnRMWdFpOgYGZJYc2ejeHDnt9JMg919eJICgnGnxDgj3dqdnFsJv7xBN4QtiB2oCDHwuAeqA_vgEugL9EbgPGfeL8CyCa2S3v2a1iaGqXb4KXnZIGgCdNqQM-G25FUYb1xTjg9Vj_5E_Ts4PDKWtuIJByrKullliPFr4mBpIiWoTNrS5O7LxzkcZmpLBheTzkUydThCDJqquRbZjAdJEF8fH-scaPoqZnyyRa6vPtO9GVEYft-sypil8RMIP1_n8vrT7l92ppLS_6GVouZj_FXlMEH2maNC5qAf2FkKEn-Q-lpD7A7hMouEBD6JU1de53atNNCZynDsZ_tBJVxc3J0dQfjZVsIPJXFlBuIivAumLFgGa45cI_dp0nSKfiEp2Nm00"><ul><li><p><strong>问</strong>：当只有一个 ConcreteCreator 的时候，工厂方法模式有什么优点？</p><p><strong>答</strong>：尽管只有一个具体创建者，工厂方法模式依然很有用，因为它<strong>帮助我们将产品的“实现”从“使用”中解耦</strong>。如果增加产品或者改变产品的实现，Creator 并不会受到影响（因为 Creator 与任何 ConcreteCreator 之间都不是紧耦合）。</p></li><li><p><strong>问</strong>：如果说纽约和芝加哥的商店是利用简单工厂创建的，这样的说法是否正确？看起来倒是很像。</p><p><strong>答</strong>：他们很类似，但用法不同。<strong>在工厂方法中，工厂是一个抽象的方法，由每个子类自行负责方法的行为。在简单工厂中，工厂是另一个对象。</strong></p></li></ul><h1 id="一个很依赖的比萨店">一个很依赖的比萨店</h1><p>假设你从未听过 OO 工厂。下面是一个不使用工厂模式的比萨店版本。数一数，这个类所以来的具体比萨对象有几种。如果又加了一种加州风味比萨到这个比萨店中，那么届时又会依赖几个对象？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependentPizzaStore</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String style, String type)</span> </span>&#123;</span><br><span class="line">        Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (style.equals(<span class="string">"NY"</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (type.equals(<span class="string">"cheese"</span>)) &#123;</span><br><span class="line">                pizza = <span class="keyword">new</span> NYCheesePizza();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"veggie"</span>)) &#123;</span><br><span class="line">                pizza = <span class="keyword">new</span> NYVeggiePizza();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (style.equals(<span class="string">"Chicago"</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (type.equals(<span class="string">"cheese"</span>)) &#123;</span><br><span class="line">                pizza = <span class="keyword">new</span> ChicagoCheesePizza();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"veggie"</span>)) &#123;</span><br><span class="line">                pizza = <span class="keyword">new</span> ChicagoVeggiePizza();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Error: invalid type of pizza"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你直接实例化一个对象时，就是在依赖它的具体类。如果把这个版本的比萨店和它依赖的对象画成一张图，看起来是这样的：</p><img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYoW2996SM9UUaSYNd91ONAmHaLbKbSkNbbwGg56McPvHOAJpPD_V5rcbFTlKzwsnuDgVp-QoMP-kdl9YmukdwdIysBdo_foScx-di1Kzsx7gwhldvx2tF-fO-xPZzTFUk5_jdFjar6rdjuuOcBh3v2dfwTWf-aSuPgQd5gH0RaSN3KjFJCp74dJCoanFJyx5hWaeYwGG0"><h2 id="依赖倒置原则">依赖倒置原则</h2><blockquote><p>要依赖抽象，不要依赖具体类。</p></blockquote><p>首先，这个原则听起来很像是“针对接口编程，不针对实现编程”，不是吗？的确很相似，然而<strong>这里更强调“抽象”。</strong>这个原则说明了：不能让高层组件依赖低层组件，而且，不管高层或低层组件，“两者”都应该依赖于抽象。</p><p>PizzaStore 是“高层组件”，而比萨实现是“低层组件”。非常依赖比萨店的主要问题在于：它依赖每个比萨类型。因为它是在自己的 <code>orderPizza()</code> 方法中，实例化这些具体类型的。</p><p>虽然我们创建了一个抽象，也就是 Pizza，但我们仍然在代码中，实际地创建了具体的 Pizza，所以，这个抽象没什么影响力。</p><p>如何在 <code>orderPizza()</code> 方法中，将这些实例化对象的代码独立出来？工厂方法刚好能派上用场。</p><img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYoW2996SM9UUaSYKc5PSK9IQNA0HaLbKb1fVa5wLovUMNf2eKPQPdb5WfFDatzyNMQKzsD3pPiUfPrzuN6nS-txWRJHSNGg-2dfuTig22JOskhe9Vf7D6QcfnAZQ9dCHS367dZCpanFHy79fWiZ2T0000"><p>在应用工厂方法之后，高层组件（PizzaStore）和低层组件（也就是这些比萨）都依赖了 Pizza 抽象。想要遵循依赖倒置原则，工厂方法并非是唯一的技巧，但却是最有威力的技巧之一。</p><h2 id="指导方针">指导方针</h2><p>下面的指导方针，能帮你避免在 OO 设计中违反依赖倒置原则：</p><ul><li>变量不可以持有具体类的引用。如果使用 new，就会持有具体类的引用。你可以改用工厂方法来避开这样的做法。</li><li>不要让类派生自具体类。如果派生自具体类，你就会依赖具体类。请派生自一个抽象（接口或抽象类）。</li><li>不要覆盖基类中已实现的方法。如果覆盖基类已实现的方法，那么你的基类就不是一个真正适合被继承的抽象。基类中已实现的方法，应该由所有的子类共享。</li></ul><p>要完全遵守这些指导方针不太可能，正如同我们的许多原则一样，应该尽量达到这个原则，而不是随时都要遵循这个原则。</p><p>如果你深入体验这些方针，将这些方针化成你思考的一部分，那么在设计时，你将知道何时有足够的理由违反这样的原则。比方说，如果有一个不像是会改变的类，那么在代码中直接实例化具体类也就没什么大碍。想想看，我们平常还不是在程序中不假思索地就实例化字符串对象吗？就没有违反这个原则？当然有！可以这么做吗？可以！为什么？因为字符串不可能改变。</p><p>另一方面，如果有个类可能改变，你可以采用一些好技巧（例如工厂方法）来封装改变。</p><h1 id="确保原料的一致">确保原料的一致</h1><p>比萨店成功的关键在于新鲜、高质量的原料，而且通过导入新的框架，加盟店将遵循你的流程，但是有一些加盟店，使用低价原料来增加利润。你必须采取一些手段，以免长此以往毁掉了比萨店的品牌。</p><p>你打算建造一家生产原料的工厂，并将原料运送到各家加盟店。对于这个做法，现在还剩下了一个问题：加盟店坐落在不同的区域，纽约的红酱料和芝加哥的红酱料是不一样的。</p><h2 id="原料家族">原料家族</h2><p>纽约使用一组原料，而芝加哥使用另一组原料。可能不久之后加州就有加盟店了，到时候又需要运送另一组区域的原料。想要行得通，必须先清楚如何处理原料家族。</p><img src="http://www.plantuml.com/plantuml/svg/RP8zJWCn48NxFSLSm3T0D45qaH2aGnGJPxIsuf_8zXOiuG9fgP5eu12HE4uKZW74krcFeTmte_dUUrwbLmHaD-aHBDabXKRzAb87QQZ1PKm1POAPGHkdppliP36zybshYcL55AdPe5nZIt3SVnxt7_3K04Y3CS9reAZonL6QOz0E0-R3exfGsir25rC6ZF8jjQr6vmVEyvdqjNizxDuEB-yCvdjod7PZEhlm5fF_mvFhVu1pt_SOo1Wy8qy7uM8hH1c7gHFtHCao3reCQa-L5n1YUpaKpMif9xoPF1airndOS8e0ulxd1rYHUn1r_SnwkLUzHv6ykiRAhGANgxNNRm00"><h2 id="建造原料工厂">建造原料工厂</h2><p>我们要建造一个工厂来生产原料，这个工厂将负责创建原来家族中的每一种原料。也就是说，工厂将需要生产面团、酱料、芝士等。开始先为工厂定义一个接口，这个接口负责创建所有的原料。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PizzaIngredientFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dough <span class="title">createDough</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sauce <span class="title">createSauce</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cheese <span class="title">createCheese</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Clams <span class="title">createClam</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span> Veggies[] createVeggies();    <span class="comment">// 这里还有新的原料</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pepperoni <span class="title">createPepperoni</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来要做的事情是：</p><ol type="1"><li>为每个区域建造一个工厂。你需要创建一个继承自 PizzaIngredientFactory 的子类来实现每一个创建方法。</li><li>实现一组原料类功工厂使用。这些类可以在合适的区域间共享。</li><li>然后你仍然需要将这一切组织起来，将新的原料工厂整合进旧的 PizzaStore 代码中。</li></ol><img src="http://www.plantuml.com/plantuml/svg/dLHDJnf16BxFhtYFzS3-04gvs3JfeOs9NfhQmxWCx4PsrWn36WKIDRL4WZHDQHE_earL6c-c1-YgvSUuimkd_eKEiw2movAsfytCyxpF-xmViuQP8K2iDRuE5h5M24F6u4OtcPud2AyKECCwXqLSrCUEJ-rYpa0cvOHbiKvWmTpOmCzfZf6CIIX_9ZasMuTKwfwIJaC90PH64XNG6S6SAAL7SzCWbLD25QJdSQ40Br-fD94i0zsms7I5USFKSSx-Vvc7ViWGea9YIiy6tsbrgOWn-M4wA8s2j8dxnr09EubGX_S3QgXRVsiKdW0bR-DwBANlFOpiLr3Sr1D1UvBWrRUyertHFXUDRV_WdRZvx3U_8rKNf3Gje25bVloiBAVAYOaQq0lCJ8eP3kY9H3aztCg5VD5QiYtCxGYq90U-Ei-A1HuaLL2ml1AYqv6uiihIOKn_ak1VjxpThbUxxLrz3GgUgJDh4r7SecjQ6YPjpwHED4mwR9wuJiljRFhEhUzSzByrnCSVed7YVTb7Cn_6G2lKuv5QhtOiQgVYq_c_gON64ftWQ_aJoX3w9agbDYV0p9p1mSw6qIIu7QU_rHKxU-BmbpYxx7MhNhlj_hpwVLDVfhtkVhzQ5nyk_UQrg3gkyzxjdFcjlS3stURs7m00"><h2 id="定义抽象工厂">定义抽象工厂</h2><p>抽象工厂模式提供一个接口，用于创建相关或依赖对象的<strong>家族</strong>，而不需要明确指定具体类。</p><p>抽象工厂允许客户使用抽象的接口来创建一组相关的产品，而不需要知道实际产出的具体产品是什么。这样一来，客户就从具体的产品中被解耦。</p><img src="http://www.plantuml.com/plantuml/svg/bLDDI-j05DtFhnXSwQ92iXGfD89hzzP5JASsq4ua7HUYGjGML4gLPnKjxob-eIX-50NZH-cFiJEfA_-2jpRMT5Bx51hAt7FlkMVkFPCo4mIJp3IRnHcIcIGsIZKZXcaRQOBqoIopTOFXCTjAp1WiXeU7JSg8dTGD4es6S4t2ZRIUpRQBrSwpfaYuTDPKrER2CR_JA7oMFTlP1yyXZES-nInWmoOw8v-q_GCzK0tG1R_lY4K1OyJleNpGTk7wAO7w2uBs94VI9g7ierA-SxBr3zcXQKJykY7Chmx5odszMlDAPtNNgRld_Fw45vUGJno9HDi3xXABeQzLpmyE1dRNFQwWhzK7ufhwJLm9Qs_2ykX_bAMYqCQ2jrDwmh4Gh7R0QazOwzRRDgTIR1pUJuBGYSX_rQgXYl0ElidG4BKOmMcIPDXAoaOPmcBL4NzNlNAEvy4Acoq7nEdhSfNNygy7J_ngpolUYCjZKJo9Kxv-zFPSQDHsmImGW2Clv26ySG46yfvoOlj1t6w1dyG_oFPA-_N7K_ZnpSKNPwbJYJmKa7AztlHWG0UeYDC6I3dUzxbSHspTGICWB-SavZwnLcrK3lnIfynT5vJmbPjMfAKDikLdnlyKv6ScTgw3HN1dhrJXbnjUnHy8qFHXFOkfWgY2mN3IODy1"><h2 id="工厂方法潜伏在抽象工厂里面">工厂方法潜伏在抽象工厂里面</h2><p>是的，抽象工厂的方法经常以工厂方法的方式实现。抽象工厂的任务是定义一个负责<strong>创建一组产品的接口</strong>（createProductA、createProductB）。这个接口内的<strong>每个方法</strong>都负责创建一个具体产品，同时我们利用抽象工厂的子类来提供这些具体的做法。所以，在抽象工厂中利用工厂方法实现生产方法是相当自然的做法。</p><h1 id="要点">要点</h1><ul><li>所有的工厂都是用来封装对象的创建。</li><li>简单工厂，虽然不是真正的设计模式，但仍不失为一个简单的方法，可以将客户程序从具体类中解耦。</li><li><strong>工厂方法使用继承：把对象的创建委托给子类，子类实现工厂方法来创建对象。</strong></li><li><strong>抽象工厂使用对象组合：对象的创建被是现在工厂接口所暴露出来的方法中。</strong></li><li>工厂方法允许类将实例化延迟到子类进行。</li><li>抽象工厂创建相关的对象家族，而不需要依赖它们的具体类。</li><li>依赖倒置原则，知道我们避免依赖具体类型，而要尽量依赖抽象类型。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Head First Design Patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰者模式</title>
      <link href="/notes/head-first-design-patterns/decorator-pattern/"/>
      <url>/notes/head-first-design-patterns/decorator-pattern/</url>
      
        <content type="html"><![CDATA[<p>本章可以成为 <strong>“给爱用继承的人一个全新的设计眼界”。</strong>我们即将再度探讨典型的继承滥用问题。你将在本章学到如何使用对象组合的方式，做到在运行时装饰类。一旦你熟悉了装饰的技巧，你将能够在不修改任何底层代码的情况下，给你的（或别人的）对象赋予新的职责。</p><h1 id="导入星巴兹咖啡">导入：星巴兹咖啡</h1><p>星巴兹（Starbuzz）是以扩张速度最快而闻名的咖啡连锁店。因为扩张速度实在太快了，他们准备更新订单系统，以合乎他们的饮料供应系统。他们原先的类设计是这样的……</p><img src="http://www.plantuml.com/plantuml/svg/ROyn2i90403xUyMMMaW-O1KYMFk3osKrmSGBjwSWCM2XXRrQYBNO2uBu6z7a6oPgeeR0DZV3xR2kvo1W4Eef11ZOg9YR4-4fuIFZDcd5XGOJ9wZu025Y00wIK5weFJdANWFKrXSqcXcAYdyn24dwpGBKhdHYC0nuBC_twpRPhzBrCTqjakqbEMrkyqCsB6R2vqJGbMD2qyUHysf-zXJMuchOavnqhKJ1-tMYGw528ldlojlQirRhfriHPRBAyrg55Q4d"><p>购买咖啡时，也可以要求在其中加入各种调料，例如：蒸奶（Steamed Milk）、豆浆（Soy）、摩卡（Mocha，也就是巧克力风味或覆盖奶泡（Whip）。星巴兹会根据所加入的调料收取不同的费用。所以订单系统必须考虑到这些调料部分。</p><p>利用实例变量和继承，追踪这些调料。</p><img src="http://www.plantuml.com/plantuml/svg/RL5DIyD04BtdLyonHThYiUYfLF3YHG-Ujvkn2KswOMUhb1WGr4EleX75YpTFHH4KwT-fIVqNJbgprk1fvhqt7szsFTz5m30oOmWnxA5sl8AHlfO1Eg97HWjfe8F7g4KV8NO0N2If_SZuQiWez8C11rBZ0YZf2OuddXznwAFf_XRNwan9HQPMXnXQBLXC7_FfRJOvonucY-VpBBtBxo_ci_UlgnT872xs1Etn-6KZeR4vymTgND9bMbGN-ssv1QmSigDI-CaPn24QJxb9uURpycq-IzbAVlt4FhBq8tkzSH971e88TjM8i1FWq5s-mUeCgtQ57kmhGMPDv1ircf4UmcQptOODe564khaIj_X0sunI7FqtTOSYZKJghsR_OlkqqLZpLH6ifIfVRAjmvQ9l"><p>当哪些需求或因素改变时会影响这个设计？</p><ul><li>调料价钱的改变会使我们更改现有代码。（这个比较好解决，增加设置调料价格的 <code>setter</code> 方法即可）</li><li>一旦出现新的调料，我们就需要加上新的方法，并改变超类中的 <code>cost()</code> 方法。（无解）</li><li>以后可能会开发处新饮料，对这些饮料而言（例如，冰茶），某些调料可能并不合适，但是在这个设计方式中，Tea 子类仍将继承哪些不适合的方法，例如：<code>hasWhip()</code>。</li><li>万一顾客想要双倍摩卡咖啡，怎么办？（这个也比较好解决，将 <code>soy</code> 的类型设置为 <code>int</code>）</li></ul><a id="more"></a><h1 id="开放-关闭原则">开放-关闭原则</h1><blockquote><p>类应该对扩展开放，对修改关闭。</p></blockquote><p>我们的目标是允许类容易扩展，在不修改现有代码的情况下，就可搭配新的行为。如果实现这样的目标，有什么好处呢？这样的设计具有弹性可以应对改变，可以接受新的功能来应对改变的需求。</p><p><strong>问</strong>：我如何让设计的每个部分都遵循开放-关闭原则？</p><p><strong>答</strong>：通常，你办不到。遵循开放-关闭原则，通常会引入新的抽象层次，增加代码的复杂度。你需要把注意力集中在设计中最有可能改变的地方，然后应用开放-关闭原则。</p><h1 id="定义装饰者模式">定义装饰者模式</h1><p>装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p><img src="http://www.plantuml.com/plantuml/svg/jPF1IiD048RlUOezwg7qBY9OlNlmQ3sawMWgxQPi5qLg8OZ1jbRZGOk8YhKKH4LRn5fDnNVHP9EU-Wfk6aoY5XN1Io3_plx_DpE9d4e2WaoMhg8CP1901DbLf1IHqY28YHmbeaJHb9B9AXWmHNa1eVoxNk2NgAma9qT6XyanJ_PU2YWQHPRMDeqggpwmstsX84XfCPVZvbWYGE5ZIDZvbtO-xZH82X6fGluJrm-P7AG4z2j4p6Q1G78ciVHD8nXMOY2Booc5_34uzdqmVm8V1i-PfIA5lyqqS1zVYqI-xkfpWGyNFWZhOuZTw6RdmgbhlKRJKRKNzOWTbSoEoiKNzJYE-zsYLT7ukQVrkoNRs32DzgkwBWIR_O0JxEB7YfY05Gee3GiKAGjV6nf3NfgbtvX6mzhUjxUkpATdU--ytwt4CIjMERDpTkdpkwntz-ouuLMvb8C4abgK1n6XreDBMilQhLZN9_PECuxjmmssqx3qUfILdvnMpMuPlirdqA3Li9q7MpurEsLMRNA_E7Pg5RFpw0vJF-Xjwb5lfNoQhlMGZpWont_z9E3vYI53UmC0"><h1 id="装饰我们的饮料">装饰我们的饮料</h1><p>装饰者模式完全遵循开放-关闭原则：我们以饮料为主体，然后在运行时以调料来”装饰“（decorate）饮料。比方说，如果顾客想要摩卡和奶泡深焙咖啡，那么，要做的是：</p><ol type="1"><li>拿一个深焙咖啡（DarkRoast）对象</li><li>以摩卡（Mocha）对象装饰它</li><li>以奶泡（Whip）对象装饰它</li><li>调用 <code>cost()</code> 方法，并依赖委托（delegate）将调料的价钱加上去</li></ol><img src="http://www.plantuml.com/plantuml/svg/XL8zJy9G5DtxA-w8CO2wWHy3ChYukAf3QI-qeUqZhmyJWqs8WKGZnaKOZ2uQ4gCccXWHKuq_njBYv5_mbK91FkBstZddzfnx-XHLHa2zmFP1Hps3L51yH5AffA4WPan6HOb12lUGYZc4aW0WeobHjS1KOl1R3bbw24JcE5GQp5aW4PC5c8vC8R85yJXqgYt7RhYNnzxvhNTHSHjlxdDTi0H94qqJDaZHn9I6XjnpwtzXmAP5cjyYeib6I2W1HLQa1Yp64ebbiBWwZBvE35dLqU0f9K95HcXlCjmeqpzmR58Q6Sfybu4MLY7Zs_nPTQA8GUHD8YdYJDFn5M9B2p0V2c817PZDTb2r_3y6qyT3_Sf1D3hI_1WHbZw6JnOs8fZA9w5JgtPlgawxxBJlkjVt_FpTVEgMgr_bGs7Al-hv-FlD9lrwXQ3aw3P_lZ8Qksl1Z44OWePP1YGRbfC4pwuuTgjpzkZOpSvftJjvS3u--MFyUQ_j6EvHWySPZUP7Vdbrhvg1YYVz1G00"><p>如果有一张单子点的是：“双倍摩卡豆浆奶泡拿铁咖啡”，它的价钱是？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">beverage = <span class="keyword">new</span> HouseBlend();</span><br><span class="line">beverage = <span class="keyword">new</span> Mocha(beverage); <span class="comment">// 用摩卡装饰</span></span><br><span class="line">beverage = <span class="keyword">new</span> Mocha(beverage); <span class="comment">// 用第二个摩卡装饰</span></span><br><span class="line">beverage = <span class="keyword">new</span> Soy(beverage);   <span class="comment">// 用豆浆装饰</span></span><br><span class="line">beverage = <span class="keyword">new</span> Whip(beverage);  <span class="comment">// 用奶泡装饰</span></span><br><span class="line">System.out.println(<span class="string">"$"</span> + beverage.cost());  <span class="comment">// 饮料的价格</span></span><br></pre></td></tr></table></figure><p>CondimentDecorator 扩展自 Beverage 类，这用到了继承。这么做的终点在于，<strong>装饰者和被装饰者必须是一样的类型</strong>，也就是有共同的超类，这相当关键的地方，因为装饰者必须能取代被装饰者。在这里，我们利用继承达到“类型匹配”，而不是利用继承获得“行为”。行为来自装饰者和基础组件，或与其他装饰者之间的组合关系。正是因为使用对象组合，可以把所有饮料和调料有弹性地加以混合。</p><h1 id="真实世界的装饰者java-io">真实世界的装饰者：Java I/O</h1><img src="http://www.plantuml.com/plantuml/svg/TPAnJiCm48PtFuNLFPNeY10I5KAgL24aHiJW99V6Qc8gsnaYCJ2GXPKdG8WT5XYglas1y1OaSHIvyNcB__y_t_dBfJm62lb6bpI7F0H9qbQ9k8mo82nKMh98quNO5FfQIs0v4NSQQ0Q9FgO_Jxlwu-Lt-xZVVf8eOqhH2vw1dJPgS-1YDI-I1AJhpaiDPrAoqhQ6tisD-h2gcq3oLJgCKBzMVs_lzKFLttXLg3HaqHhfrSq0iUkSCyrSTSa5N1Oj6Tkplkd9VH0uptO2FW9E48M1zHj1SHGJn4XueXWQJtJCoXF3uOrOqU2csRaOnEsfbv97jqjHRfXe5tbsQ_9TVUrtpsQn9vGfAeuEd67VZ3bptZITjYM-iOsB3jTRxg_ed1aPaUzL57Jl8HjWd7y0"><p>和星巴兹的设计相比，<code>java.io</code> 其实没有多大的差异。你会发现“输出”流的设计也是一样的。你可能还会发现 Reader/Writter 流（作为基于字符数据的输入和输出）和输入流/输出流的类相当类似（虽然有一些小差异和不一致之处，但是相当雷同，所以你应该可以了解这些类）。</p><p>Java I/O 也引出装饰者模式的一个“缺点”：利用装饰者模式，常常造成设计中有大量的小类，数量实在太多，可能会造成使用此 API 程序员的困扰。但是，现在你已经了解了装饰者的工作原理，以后当使用别人的大量装饰的 API 时，就可以很容易地辨别出他们的装饰者类是如何组织的，以方便用包装方式取得想要的行为。</p><h2 id="编写自己的-java-io-装饰者">编写自己的 Java I/O 装饰者</h2><p>编写一个装饰者，把输入流内的所有大写字符转成小写。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先，扩展FilterInputStream</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LowerCaseInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LowerCaseInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 针对字节的 read() 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="keyword">super</span>.read();</span><br><span class="line">        <span class="keyword">return</span> (c == -<span class="number">1</span> ? c : Character.toLowerCase((<span class="keyword">char</span>) c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 针对字节数组的 read() 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> offset, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="keyword">super</span>.read(b, offset, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = offset; i &lt; offset + result; i++) &#123;</span><br><span class="line">            b[i] = (<span class="keyword">byte</span>)Character.toLowerCase((<span class="keyword">char</span>)b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream in =</span><br><span class="line">                <span class="keyword">new</span> LowerCaseInputStream(</span><br><span class="line">                    <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>)));</span><br><span class="line">            <span class="keyword">while</span> ((c = in.read()) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println((<span class="keyword">char</span>)c);</span><br><span class="line">            &#125;</span><br><span class="line">            in.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="要点">要点</h1><ul><li>继承属于扩展形式之一，但不见得是达到弹性设计的最佳方案。</li><li>组合和委托可用于在运行时动态地加上新的行为。</li><li>装饰者模式意味着一群装饰者类，这些类用来包装具体组件。</li><li>装饰者类反映出被装饰的组件类型（事实上，他们具有相同的类型，都经过接口或继承实现）。</li><li>装饰者可以在被装饰者的行为前面与/或后面加上自己的行为，甚至将被装饰者的行为整个取代掉，而达到特定的目的。</li><li>可以用无数个装饰者包装一个组件。</li><li>装饰者一般对组件的客户是透明的，除非客户依赖于组件的具体类型。</li><li>装饰者会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Head First Design Patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式</title>
      <link href="/notes/head-first-design-patterns/observer-pattern/"/>
      <url>/notes/head-first-design-patterns/observer-pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="导入internet气象观测站">导入：Internet气象观测站</h1><p>气象站建立在 WeatherData 对象上，由 WeatherData 对象负责追踪目前的天气状况（温度、湿度、气压）。我们希望能建立一个应用，有三种布告板，分别显示目前的状况、气象统计以及简单的预报。当 WeatherData 对象获得最新的测量数据时，三种布告板必须实时更新。</p><p>而且，这是一个可以扩展的气象站，我们希望公布一组 API，好让其他开发人员可以写出自己的布告板，并插入此应用中。</p><img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYoW2996SM9UUaSYNd91ONAuId9fPaf1Qv99OaAbHpAIYafvQ40BMa5YMMb1QbQcX2X3nASpDJCaigOVo0ejJYOfXyRceYY9sRcbTIx9oHc9UUcgAXgL2jeA-ly6H7mxFfovvjcF9Yuy9dMxjVjlS_cxtbsRGDx_VqF5kxvDcqdSysJtsoPzQBHQjVR6X-FcM5GYrNBG00"><h2 id="错误示范">错误示范</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 实例变量声明</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measurementsChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">float</span> temp = getTemperature();</span><br><span class="line">      <span class="keyword">float</span> humidity = getHumidity();</span><br><span class="line">      <span class="keyword">float</span> pressure = getPressure();</span><br><span class="line"></span><br><span class="line">      currentConditionsDisplay.update(temp, humidity, pressure);</span><br><span class="line">      statisticsDisplay.update(temp, humidity, pressure);</span><br><span class="line">      forecastDisplay.update(temp, humidity, pressure);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他WeatherData方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个实现中，下列哪种说法正确？（多选）</p><ul><li>[x] A. 我们是针对具体实现编程，而非针对接口。（三个布告板都是实现）</li><li>[x] B. 对于每个新的布告板，我们都得修改代码。</li><li>[x] C. 我们无法在运行时动态地增加（或删除）布告板。</li><li>[ ] D. 布告板没有实现一个共同的接口。（<code>update(temp, humidity, pressure)</code> 看恰里像是一个统一的接口）</li><li>[x] E. 我们尚未封装改变的部分。（<code>display.update</code> 是会改变的部分）</li><li>[ ] F. 我们侵犯了 WeatherData 类的封装。</li></ul><a id="more"></a><h1 id="观察者模式">观察者模式</h1><p>我们看看报纸和杂志的订阅是怎么回事：</p><ol type="1"><li>报社的业务就是出版报纸。</li><li>向某家报社订阅报纸，只要他们有新报纸出版，就会给你送来。只要你是他们的订户，你就会一直收到新报纸。</li><li>当你不想再看报纸的时候，取消订阅，他们就不会再送新报纸来。</li><li>只要报社还在运营，就会一直有人（或单位）向他们订阅报纸或取消订阅报纸。</li></ol><p>出版者 + 订阅者 = 观察者模式</p><p>只要你了解报纸的订阅是怎么回事，其实就知道观察者模式是怎么回事，只是名称不太一样：出版者改称为“主题”（Subject），订阅者改称为“观察者”（Observer）。</p><h2 id="定义">定义</h2><p>观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖着都会收到通知并自动更新。</p><img src="http://www.plantuml.com/plantuml/svg/ZP71IiD048RlUOeX9oianNieY5V1Wq-msKpDIZTRPgU5K7EpJo3jeQzHK4HycxQ-XXjrrzfKyRJm___-ymrJgW81zPXhqAXpfAXi5Qb8ZZ1I5ICDXKIudkItA1coB6Y30SmYW9d8BPEGt03XZRBElSejqXJff7VeQpF5tzpAi1hMUswpDz_BVmDCneLW_FWgHy9Qk32L96Jq-6t-d4ZKbmuKp5UfTUfHzYF07Ke7e95BKpJGxyDs_hXvMRwjxhVpfythmsxvl5ilEZXXcvR7izdFrobXZVzrXxRuD8OiIHA8p-B3rIC_flKw8LyHKjbTcgQTZkyh_B2z_0u0"><h2 id="松耦合的威力">松耦合的威力</h2><p><strong>当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节。</strong>观察者模式提供了一种对象设计，让主题和观察者之间松耦合。改变主题或观察者其中一方，并不会影响另一方。因为两者是松耦合的，所以只要他们之间的接口仍被遵守（观察者实现了 Observer 接口），我们就可以自由地改变他们。</p><blockquote><p>为了交互对象之间的松耦合设计而努力。</p></blockquote><p><strong>松耦合的设计之所以能让我们建立有弹性的 OO 系统，能够应对变化，是因为对象之间的互相依赖降到了最低。</strong></p><h2 id="设计气象站">设计气象站</h2><img src="http://www.plantuml.com/plantuml/svg/hLDDIyD04BtdLynH3wrtARcqYWT1GS63UDXifirAFihkfX9geOWUL3pfeJUXLCIJNWJnwzUOsFuBDxL9qvZsv6tptkJDUxEp5ZCHq6dA01nq3EIQ5IEKSMgZnbo9l4uemevl72ALKAcacAv3MmFOP4A2PmZaBUH20MrY2Ca9bHtWs50iygq9lRISvnslXVDOrvEi7cJOJiPG0XSuIhmUMIWjv3KYoQomtpI9n9nWZOccJO8r6nrqYuAQlmNZtwXDX82zQOFYKHJcBmZz9wd26YXtrSKW9zBdE2vJq8RlC9F98FdUvYX4mZj8udFiNrGjuZRGpBYj-fmhfkgvIe1vhfWaNZ2pT52PzD26bHM8Uf_VWzVmupeylnhUdqJFbs7t7JffitMF8oL2_aEFmKFqT3FgdqONT-C6YKn9JvTW5PI7yF5ss3rBwKefGt-zl8twlIbtN2vdRq-RRbFCp9kKbj-HXSMpchc154hbQrA5qhvwbIQw1tfkJNy0"><h1 id="java-内置的观察者模式">Java 内置的观察者模式</h1><p><code>java.util</code> 包内包含最基本的 Observer 接口与 Observable 类，这和我们的 Observer 接口与 Subject 接口很相似。 Observer 接口与 Observable 类使用上更方便，因为许多功能都已经事先准备好了。你甚至可以用“推”（push）或“拉”（pull）的方式传送数据，稍后就会看到这样的例子。</p><img src="http://www.plantuml.com/plantuml/svg/hLD1JnD15BxlhvWZ7XRkJTDBaN0mmOE91_4mtNbb9zcTRMQc9arfiX8aW4KEAYczOB0DwWK98QaKzSUmEzkU_0kEMxfEDvMJj_U--VPxxttlhKi98F1hie5yy2l0BVSFub3kU60v7XO2hLK4y1UuuW5gMWWzeaAY8CM02mrWGjRkqeK7EYVWWOGPY0MILXjJIAIO05bsCTi0ejEMHPa4NiKEe2aD5OiPM2gbjOrMWYpKU1DNXEJOaIrKhn4i8IUvJ4NDmus77lZ0v1nXCY6adqscVkg2T84lOuddZxq1yebs3ZYMTGxfI1fQhVkKKDcOveyv235vdogNwvphBie1qqGQC77NtRqJPcCPlQ8cMbf2glCZwLt7tz_6UmUZiorrzJeERr0hAxSIS72maF-bIk-p-lfkVBgjzljf2KF8BcMRAo3TI7n-CWfVcOoYRJ2YmN1ysfbvthHjqtRhxo5iBYx-qpOhlznxoREQEM_cIkKvcOBzJFyh1DZpKkw-B7tkW3oeweEf6buNZ5XrpgD160s-91V3NpVjTJOAsz7W88FLctvy-F4st9eLC-mfe6HuflP-HjSxwl9JlDE-3L_6kn_6npqThBDns4rE-jaUakwsElgcBjzhoTy0"><p>Java 内置的观察者模式运作方式，和我们在气象站中的实现类似，但有一点小差异。最明显的差异是 WeatherData （也就是我们的主题）现在<strong>扩展</strong>自 Observable 类，并继承到一些增加、删除、通知观察者的方法（以及其他方法）。</p><h2 id="可观察者如何送出通知">可观察者如何送出通知</h2><ol type="1"><li>先调用 <code>setChanged()</code> 方法，标记状态已经改变的事实。</li><li>然后调用 <code>notifyObservers()</code> 或 <code>notifyObservers(Object arg)</code>。后者可以传送任何的数据对象给每一个观察者。</li></ol><h2 id="观察者如何接受通知">观察者如何接受通知</h2><p>观察者实现了更新的方法，但是方法的签名不太一样：<code>update(Observable o, Object arg)</code>。主题本身 o 当作第一个变量，好让观察者知道是哪个主题通知它的。arg 正是传入 <code>notifyObservers()</code> 的数据对象，如果没有说明则为空。</p><p>如果你想“推”（push）数据给观察者，你可以把数据当作对象传送给 <code>notifyObservers(arg)</code> 方法。否则，观察者就必须从可观察者对象中“拉”（pull）数据。</p><h2 id="setchanged-是怎么一回事"><code>setChanged()</code> 是怎么一回事</h2><p><code>setChanged()</code> 方法用来标记状态已经改变的事实，好让 <code>notifyObservers()</code> 知道当它被调用时应该通知观察者。让我们看看 Observable 内部，以了解这一切。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setChanged() &#123;</span><br><span class="line">    changed = <span class="keyword">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">notifyObservers(Object arg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">        <span class="keyword">for</span> every observer on the list &#123;</span><br><span class="line">            <span class="function">call <span class="title">update</span> <span class="params">(<span class="keyword">this</span>, arg)</span></span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">        changed </span>= <span class="keyword">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">notifyObservers() &#123;</span><br><span class="line">    notifyObservers(<span class="keyword">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做有其必要性。<code>setChanged()</code> 方法可以让你在通知观察者时，有更多的弹性。比方说，如果没有 <code>setChanged()</code> 方法，我们的气象站测量是如此敏锐，以致于温度计读数每十分之一度就会更新，这会造成 WeatherData 对象持续不断地通知观察者，我们并不希望看到这样的事情发生。如果我们希望半度以上才更新，就可以在温度差距达到半度时，调用 <code>setChanged()</code>，进行有效的更新。你也许不会经常用到此功能，但是把这样的功能准备好，当需要时马上就可以使用。</p><h2 id="java.util.observable-的黑暗面"><code>java.util.Observable</code> 的黑暗面</h2><p>可观察者是一个“类”而不是一个“接口”，更糟的是，它甚至没有实现一个接口。不幸的是，<code>java.util.Observable</code> 的实现有许多问题，限制了它的使用和复用。</p><ul><li><p>Observable 是一个类</p><p>首先，因为 Observable 是一个“类”，你必须设计一个类继承它。如果某类相同时具有 Observable 类和另一个超类的行为，就会陷入两难，毕竟 Java 不支持多重继承。再者，因为没有 Observable 接口，所以你无法建立自己的实现，和 Java 内置的 Observer API 搭配使用，也无法将 <code>java.util</code> 的实现换成另一套做法的实现。</p></li><li><p>Observable 将关键的方法保护起来</p><p><code>setChanged()</code> 方法被保护起来了（被定义成 protected）。这意味着：除非你继承自 Observable，否则你无法创建 Observable 实例并组合到你的对象中来。这个设计违反了“多用组合，少用继承”的设计原则。</p></li></ul><h1 id="jdk-中的观察者模式">JDK 中的观察者模式</h1><p>在 JDK 中，并非只有在 <code>java.util</code> 中才能找到观察者模式，其实在 JavaBeans 和 Swing 中，也都实现了观察者模式。让我们看看一个简单的 Swing API：JButton。如果你观察一下 JButton 的超类 AbstractButton，你会看到许多增加与删除倾听者（listener）的方法，这些方法可以让观察者感应到 Swing 组建的不同类型事件。比方说：ActionListener 让你“倾听”可能发生在按钮上的动作，例如按下按钮。你可以在 Swing API 中找到许多不同类型的倾听者。</p><h2 id="一个小的改变生活的程序">一个小的、改变生活的程序</h2><p>我们的程序很简单，你有一个按钮，上面写着 &quot;Should I do it?&quot;。当你按下按钮，倾听者（观察者）必须回答此问题。我们实现了两个倾听者，一个是天使（AngelListener），一个是恶魔（DevilListener）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwingObserverExample</span> </span>&#123;</span><br><span class="line">    JFrame frame;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SwingObserverExample example = <span class="keyword">new</span> SwingObserverExample();</span><br><span class="line">        example.go();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        frame = <span class="keyword">new</span> JFrame();</span><br><span class="line"></span><br><span class="line">        JButton button = <span class="keyword">new</span> JButton(<span class="string">"Should I do it?"</span>);</span><br><span class="line">        button.addActionListener(<span class="keyword">new</span> AngelListener());</span><br><span class="line">        button.addActionListener(<span class="keyword">new</span> DevilListener());</span><br><span class="line">        frame.getContentPane().add(BorderLayout.CENTER, button);</span><br><span class="line">        <span class="comment">// 在这里设置frame属性</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AngelListener</span> <span class="keyword">implements</span> <span class="title">ActionListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Dont't do it, you might regret it!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DevilListener</span> <span class="keyword">implements</span> <span class="title">ActionListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Come on, do it!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="要点">要点</h1><ul><li>观察者定义了对象之间一对多的关系。</li><li>主题（也就是可观察者）用一个共同的接口来更新观察者。</li><li>观察者和可观察者之间用松耦合（loosecoupling）方式结合，可观察者不知道观察者的细节，只知道观察者实现了观察者接口。</li><li>使用此模式时，你可从被观察者处推或拉数据。</li><li>有多个观察者时，不可以依赖特定的通知次序。如果我们的代码依赖这样的次序，就是错的。因为一旦观察者/可观察者的实现有所改变（比如为不同的观察者赋予优先级，按优先级大小次序推送），通知次序就会改变，很可能就会产生错误的结果。这绝对不是我们所认为的松耦合。</li><li>Java 有多种观察者模式的实现，包括了通用的 <code>java.util.Observable</code>。</li><li>要注意 <code>java.util.Observable</code> 实现上所带来的一些问题。</li><li>如果有必要的话，可以实现自己的 Observable，这并不难，不要害怕。</li><li>Swing 大量使用观察者模式，许多 GUI 框架也是如此。</li><li>此模式也被应用在许多地方，例如：JavaBeans、RMI。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Head First Design Patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略模式</title>
      <link href="/notes/head-first-design-patterns/strategy-pattern/"/>
      <url>/notes/head-first-design-patterns/strategy-pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="导入鸭子游戏">导入：鸭子游戏</h1><p>鸭子游戏：游戏中会出现各种鸭子，一边游泳戏水，一边呱呱叫。</p><img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYoW2996SM9UUaSYKc5PSK9IQNABYK9cShL7CfA1IM9YPdQsW2MSNbcRbWHZLCLQr2IcPnGKvY9KGuDxKa8p-bLa5VN-7bZhLFrqvuFglbQUks9xkdFPksyzdcgLorNCavYSN52hw9EJc9HIbmE-2cA5I3D3zTCkt5ygPdCzO_txt_wP8j2hLmZK6fAHcfYKHetBK8JMDf4j2hw9w2w7gnhEtvx6dFEYOydR0HXFfN0pNYDllPoeNFPwq3UX1iFDX8cnfTNMHF8OaYkHXP5EuS0000"><p>现在我们让鸭子会飞。只需要在 Duck 类中加上 <code>fly()</code> 方法，然后所有鸭子都会继承 <code>fly()</code>。</p><img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYoW2996SM9UUaSYKc5PSK9IQNABYK9cShL7CfA1IM9YPdQsW2MSNbcRbWXfPMMawbXgQM5f1T3TDHgv2IMLoGarW9LbATcrgIaPzIgw2lh_1onzgdQoSydzNoj7NRaztJdatR-MppLAvQhkISnE9Y1T_4d9p4eXIuVN1J5Af1cfykcVPYUTEp6UkVxzx_TCaMXLgung3Kb8pKH28qxbg4fh4q2UXjT0z2TBrOrlPyzhHd7HEUJjW8GlshWHfnc_rivSBdizO1FGWs7coaJOskBhAda4IHN8mi2dSELrv-IQf2JcfQYK9-6ZW6h1IURT_zj6i1EBmX0GS0"><p>但是，可怕的问题发生了，有很多“橡皮鸭子”飞来飞去。在超类中加上 <code>fly()</code>，就会导致所有的子类都具备 <code>fly()</code>，连那些不该具备 <code>fly()</code> 的子类也无法免除。</p><p><strong>当涉及“维护”时，为了“复用”（reuse）目的而使用继承，结局并不完美。</strong></p><a id="more"></a><h2 id="利用继承">利用继承</h2><img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYoW2996SM9UUaSYKc5PSK9IQNABYK9cShL7CfA1IM9YPdQsW2MSNbcRbWXfPMMawbXgQM5f1T3TDHgv2IMLoGarW9LbATcrgIaPzIgw2lh_1onzgdQoSydzNoj7NRaztJdatR-MppLAvQhkISnE9Y1T_4d9p4eXIuVN1J5Af1cfykcVPYUTEp6UkVxzx_TCaMXLgung3Kb8pKH28qxbg4fh4q2UXjT0z2TBrOrlPyzhHd7HEUJjW8GlshWHfnc_rivSBdizO1FGXM1GuLP7FUx-bvihlXoSwE9xkwNpRlVRAZzsdZB2INkAGcvrVYSmWk0p1Sz6BznfTBjvBX4B3jDZMwkiWHWIIA5Ch8el0WH1A4-mO0"><p>鸭子的行为在子类里不断地改变，并且让所有的子类都有这些行为是不恰当的。例子，橡皮鸭子不会飞，假鸭子不会飞也不会叫。每当有新的鸭子类出现，都要被迫检查并可能需要覆盖 <code>fly()</code> 和 <code>quark()</code>。</p><p>利用继承来提供 Duck 的行为，这会导致下列哪些缺点？（多选）</p><ul><li>[x] A. 代码在多个子类中重复。（RubberDuck 和 DecoyDuck 都不会飞）</li><li>[x] B. 运行时的行为不容易改变。（除非修改代码）</li><li>[ ] C. 我们不能让鸭子跳舞。（可以，就如我们让鸭子会“飞”）</li><li>[x] D. 很难知道所有鸭子的全部行为。（唐老鸭：我想说句话）</li><li>[ ] E. 鸭子不能同时又飞又叫。（MallardDuck 和 RedheadDuck 可以又飞又叫）</li><li>[x] F. 改变会牵一发动全身，造成其他鸭子不想要的改变。（橡皮鸭：我本不想飞）</li></ul><h2 id="利用接口">利用接口</h2><img src="http://www.plantuml.com/plantuml/svg/bL3B3W4n5DttA-wI1Nx0Kkmi-8CxxPLfj1vj9p9XTknjMFW7AuaGl-CHVy6C6FM8nAuzhtjoGYa8IFTT39fqG8Q5ASAbuOeO1jOPv0vg4U_0Y07OeTI5ukqnUd0926dx2kCxhCc5FP50fGANxUgucfsNa-DqSzWlJelTQJrd2PDTHwQDdA2kOWmKPSbjbIRuR3D2tidvGVhB55oXjT10fT28l9dVufxrwMcH20d_z4J1RPQlbdTfZNWl_g9CM0PMnwMINzj3lM8-cf_smFm8UwnN7PVBBxalX1_zNFJ3yqRzS3rRNG40"><p>Flyable 与 Quackable 接口一开始似乎还挺不错，解决了问题（只有会飞的鸭子才继承 Flyable），<strong>但是 Java 接口不具有实现代码，所以继承接口无法达到代码的复用。</strong>这意味着：无论何时你需要修改某个行为，你必须得往下追踪并在每一个定义此行为的类中修改它，一不小心，可能会造成新的错误。</p><h1 id="封装变化">封装变化</h1><blockquote><p>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</p></blockquote><p>我们知道 Duck 类内的 <code>fly()</code> 和 <code>quack()</code> 会随着鸭子的不同而改变。为了要把这两个行为从 Duck 类中分开，我们将把它们从 Duck 类中取出来，建立一组新类来代表每个行为。</p><img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYoW2996SM9UUaSYNd91ONAxZbL8PdbcI4P-Qb5ojKSoaefELKLjSgL2lewoiyNJVlUT-6bplMFbqxuUNYUIyMzYZKSjKYDFhbXoTMmZHfQ48qFTdTy6HdnylclKzsz3vjdFL-Jm-GyMJFBA01IBe3InEJiy5Q2q4icEQd4pU2KFzg9AN1XQMfYLZKFbkvyFciTH3NFPsm4OHGzFcMbgJYi0QN6w460000"><h1 id="针对接口编程">针对接口编程</h1><p>我们希望一切能有弹性，毕竟，正是因为一开始鸭子行为没有弹性，才让我们走上现在这条路。我们还想能够“指定”行为到鸭子实例。比方说，我们想要生产一个新的绿头鸭实例，并指定特定“类型”的飞行行为给它。干脆顺便让鸭子的行为可以动态地改变好了。换句话说，我们应该在鸭子类中包含设计行为的方法，这样就可以在“运行时”动态地“改变”绿头鸭的飞行行为。</p><blockquote><p>针对接口编程，而不是针对实现编程。</p></blockquote><p>“针对接口编程“真正的意思是”针对超类型（supertype）编程“。”针对接口编程“，关键就在于多态。利用多态，程序可以针对超类型编程，执行时会根据实际情况执行到真正的行为，不会被绑死在超类型的行为上。</p><p>我们利用接口代表每个行为，比方说，FlyBehavior 与 QuackBehavior 而行为的每个实现都将实现其中一个接口。</p><img src="http://www.plantuml.com/plantuml/svg/VL4zRi8m5DvzYZU60JW0b05Lx1p1SLuKYvWaZW55KJROMSh07PYG45MlmuzwYpfEIkqCtUplvttFdoCU8A18LG42XO-IH3N2k6Gn4hvKA4FA46PnCSM8hdaYOJn-uPC9b0GWZ0klHofBFrzHjlZ7aTMyyL0_Lv8o1UyhjZ2SdHN-dJNZJiticsRp3HTw943vExE2WETfJ0i3vwYiqPuJu_UWjCFWJMCZg1gRa-jrjZ1MPnTjpbfpgb-TI35ldjiL3jeQ7EsiBjFTPc0ARbIbG1KbGGN38NnVJ_VJ_ddStdUNszVXSVXyd3zqfvts-trJBd4-iGL_0000"><p>这样的做法迥异于以往，以前的做法是：行为来自 Duck 超类的具体实现，或是继承某个接口并由子类自行实现而来。这两种做法都是依赖于”实现“，我们被实现绑得死死的，没办法更改行为（除非写更多代码）。</p><p>在我们的新设计中，鸭子的子类将使用接口所表示的行为，所以实际的“实现”不会被绑死在鸭子的子类中。特定的具体行为编写在实现了 FlyBehavior 与 QuackBehavior 的类中。</p><h1 id="实现鸭子的行为">实现鸭子的行为</h1><p>在此，我们有两个接口，FlyBehavior 和 QuackBehavior，还有它们对应的类，负载实现具体的行为。</p><img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYoW2996SM9UUaScNcbQGMfIKcfoguvLGwfMOabcNc5odOsC35xUmKghaK5D9oAZKqkMgvadCIYuj1QiCpIpB2C_FIYs7IrRKArGhw-WfFryrxthVXvOwrJzTEUBbutek5FGgro1hzyiCJAn5cGZGzsTtmP6V7o-QzJtRqFcsSzNvF3v3nPCyie05WtGXd1fOc9cVZSMWXI1x9gM3ro39GLqxS24Bzgv4S5rnOcfg8HUspbGkVpre7yT7J2Hj124MVRsb9AWvhSFaBPW1AeDVewQ64B5PPSF1neOK2I0uiX4q2uYriCd270m00"><p>这样的设计，可以让飞行和呱呱叫的动作被其他的对象复用，因为这些行为已经与鸭子类无关了。</p><p>而我们可以新增一些行为，不会影响到既有的行为类，也不会影响“使用”到飞行行为的鸭子类。</p><p><strong>问</strong>：用一个类代表一个行为，感觉似乎有点奇怪。类不是应该代表某种“东西”吗？类不是应该同时具备状态“与”行为吗？</p><p><strong>答</strong>：在 OO 系统中，是的类代表的东西一般都是既有状态（实例变量）又有方法。只是在本例中，碰巧“东西”是个行为。但是即使是行为，也仍然可以有状态和方法，例如，飞行的行为可以具有实例变量，记录飞行行为的属性（每秒翅膀拍动几下，最大高度和速度等）。</p><h1 id="整体格局">整体格局</h1><img src="http://www.plantuml.com/plantuml/svg/ZLFBJi905DttA-vI5y0F41R6iDD4NR0Usi4sjhJqeMcWYKPDN8ZYGXSiID2LCHADYOBWtxGWAt_1wRIqCrgYoP2KS-uzzp5dP4N2W3N3Ta73MXMRWXmYecAAAXOC9EwXNGppkzvd_vmSV_WEJG50gTlOh24HGrbrrx2CzXNTX68nmKib6WTGKzsLLVBbaP-e8iiACogABLUK-gwL1ZKzQ4AX0C6WDxjucWyVWyTEL9QcSkcRUWMvh7wKweyF_T7P_FZ37xQ3e-xNXBJRzYTT8XDhUCb4mU1sUlP6DL3Liaqash3kY7knAZjLBVsct9P3D1AsmVwZl7MWQ7HaWEP2smD9iGmLkJ5Xa2tffaQbUAYiBc8iR3Djf21NVr58mxQiIrwuXcXti-v9SFhgZs-cDwFfopMtmWsagiYKc7dPxjAuRIp96FqZpgaIv_mPjev5tLqQnTpDrNDuBXyo3SUlFyjoZMIhQMsQnVEntnR5VjXif-5Wb9anlU_FkeDeoq7dEJo_iZSS6oyjkSodgOmdSC-gbSzphoQJfOz2-B6TaADG5X6DcCKaxGlqkegjN8ur3OCo5c7Hn10Cc5n_XELAx2kBiHn1kNw-0G00"><h1 id="多用组合少用继承">多用组合，少用继承</h1><p>每一鸭子都有一个 FlyBehavior 和一个 QuackBehavior，好将飞行和呱呱叫委托给它们代为处理。这就是组合（composition）。这种做法和“继承”不同的地方在于，鸭子的行为不是继承来的，而是和适当的行为对象“组合”来的。这是一个很重要的技巧。</p><blockquote><p>多用组合，少用继承。</p></blockquote><p>使用组合建立系统具有很大的弹性，不仅可将算法族封装成类，更可以“在运行时动态地改变行为”，只要组合的行为对象符合正确的接口标准即可。</p><h1 id="定义策略模式">定义策略模式</h1><p>策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p><img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYoW2996SM9UUaSYKc5PSK9IQNA0Ia5gNb5-Mc5YbKSoae10C5IrBJAnMAeGoWM3LCRQr20KInXYPNBLToJc9niO9pVbvoKMf9AgenoEhWDi7DhaOrDB6W8ASIYv4mzOvW3OHKEQ6fGZZ8faPN5zETI0fqxU1kir9GUZQdyycEXYSxLYbnmLsCOWJSNGJadRZoyajI5OeoqpDA5FBJaEnush_-oUwbpsQiVzQrzyN6XSytxdw_f-V9pla8yRwbJ_iNFsve0W00"><h1 id="要点">要点</h1><ul><li>知道 OO 基础（即<strong>抽象、封装、多态和继承</strong>），并不足以让你设计出良好的 OO 系统。</li><li>良好的 OO 设计必须具备<strong>可复用、可扩充、可维护</strong>三个特性。</li><li>模式可以让我们建造出具有良好 OO 设计质量的系统。</li><li>模式被认为是历经验证的 OO 设计经验。</li><li>模式不是代码，而是针对设计问题的通用解决方案。你可以把它们应用到特定的应用中。</li><li>大多数的模式和原则，都着眼于软件变化的主题。</li><li>大多数的模式都允许系统局部改变独立于其他部分。</li><li>我们常把系统中会变化的部分抽出来封装。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Head First Design Patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Range Sum Query</title>
      <link href="/programming/leetcode/range-sum-query/"/>
      <url>/programming/leetcode/range-sum-query/</url>
      
        <content type="html"><![CDATA[<h1 id="range-sum-query---immutable">Range Sum Query - Immutable</h1><p>Given an integer array <em>nums</em>, find the sum of the elements between indices <em>i</em> and <em>j (i ≤ j)</em>, inclusive.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums = [-2, 0, 3, -5, 2, -1]</span><br><span class="line"></span><br><span class="line">sumRange(0, 2) -&gt; 1</span><br><span class="line">sumRange(2, 5) -&gt; -1</span><br><span class="line">sumRange(0, 5) -&gt; -3</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol type="1"><li>You may assume that the array does not change.</li><li>There are many calls to <em>sumRange</em> function.</li></ol><h2 id="caching-on2-space">Caching: O(n^2) Space</h2><p>Imagine that <em>sumRange</em> is called one thousand times with the exact same arguments. How could we speed that up?</p><p>We could trade in extra space for speed. By pre-computing all range sum possibilities and store its results in a hash table, we can speed up the query to constant time.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2) time pre-computing + O(1) time per query</span></span><br><span class="line"><span class="comment"># Space: O(n^2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums: list)</span>:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        self.data = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            s = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):</span><br><span class="line">                s += nums[j]</span><br><span class="line">                self.data[i, j] = s</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span><span class="params">(self, i: int, j: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.data[i, j]</span><br></pre></td></tr></table></figure><h2 id="caching-on-space">Caching: O(n) Space</h2><p>Imagine that we pre-compute the cummulative sum from index <code>0</code> to <code>k</code>. Could we use this information to derive <code>sumRange(i, j)</code>?</p><p>Let us define <code>sum[k]</code> as the cumulative sum for <code>nums[0 .. k-1]</code>: <code>sumRange(i, j) = sum[j + 1] - sum[i]</code>.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n) time pre-computing and O(1) time per query</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums: list)</span>:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        self.sum = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">            self.sum[k + <span class="number">1</span>] = self.sum[k] + nums[k]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span><span class="params">(self, i: int, j: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.sum[j + <span class="number">1</span>] - self.sum[i]</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="range-sum-query-2d---immutable">Range Sum Query 2D - Immutable</h1><p>Given a 2D matrix <em>matrix</em>, find the sum of the elements inside the rectangle defined by its upper left corner <em>(row1, col1)</em> and lower right corner <em>(row2, col2)</em>.</p><p><img src="/uploads/image/leetcode/range_sum_query_2d.png"></p><p>The above rectangle (with the red border) is defined by (row1, col1) = <strong>(2, 1)</strong> and (row2, col2) = <strong>(4, 3)</strong>, which contains sum = <strong>8</strong>.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given matrix = [</span><br><span class="line">  [3, 0, 1, 4, 2],</span><br><span class="line">  [5, 6, 3, 2, 1],</span><br><span class="line">  [1, 2, 0, 1, 5],</span><br><span class="line">  [4, 1, 0, 1, 7],</span><br><span class="line">  [1, 0, 3, 0, 5]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">sumRegion(2, 1, 4, 3) -&gt; 8</span><br><span class="line">sumRegion(1, 1, 2, 2) -&gt; 11</span><br><span class="line">sumRegion(1, 2, 2, 4) -&gt; 12</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol type="1"><li>You may assume that the matrix does not change.</li><li>There are many calls to <em>sumRegion</em> function.</li><li>You may assume that <em>row1 ≤ row2</em> and <em>col1 ≤ col2</em>.</li></ol><h2 id="caching-rows">Caching Rows</h2><p>Remember from the 1D version, try to see the 2D matrix as <em>m</em> rows of 1D arrays. To find the region sum, we just accumulate the sum in the region row by row.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn) time pre-computing + O(m) time per query</span></span><br><span class="line"><span class="comment"># Space: O(mn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, matrix: list)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            m, n = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                self.dp[i][j + <span class="number">1</span>] = self.dp[i][j] + matrix[i][j]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRegion</span><span class="params">(self, row1: int, col1: int, row2: int, col2: int)</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row1, row2 + <span class="number">1</span>):</span><br><span class="line">            res += self.dp[i][col2 + <span class="number">1</span>] - self.dp[i][col1]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="caching-smarter">Caching Smarter</h2><p>We used a cumulative sum array in the 1D version. We notice that the cumulative sum is computed with respect to the origin at index 0. Extending this analogy to the 2D case, we could pre-compute a cumulative region sum with respect to the origin at (0, 0).</p><p><img src="/uploads/image/leetcode/sum_od.png"> <img src="/uploads/image/leetcode/sum_ob.png"> <img src="/uploads/image/leetcode/sum_oc.png"> <img src="/uploads/image/leetcode/sum_oa.png"></p><p><code>sum(A, D) = sum(O, D) - sum(O, B) - sum(O, C) + sum(O, A)</code></p><p>Let us define <code>dp[i][j] = sumRegion(0, 0, i - 1, j - 1)</code>, the sum of region that has upper left corner <code>(0, 0)</code> and lower right corner <code>(i - 1, j - 1)</code>.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn) time pre-computing and O(1) time per query</span></span><br><span class="line"><span class="comment"># Space: O(mn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, matrix: list)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            m, n = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                self.dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = self.dp[i + <span class="number">1</span>][j] + self.dp[i][j + <span class="number">1</span>] \</span><br><span class="line">                                        + matrix[i][j] - self.dp[i][j]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRegion</span><span class="params">(self, row1: int, col1: int, row2: int, col2: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.dp[row2 + <span class="number">1</span>][col2 + <span class="number">1</span>] - self.dp[row2 + <span class="number">1</span>][col1] \</span><br><span class="line">               - self.dp[row1][col2 + <span class="number">1</span>] + self.dp[row1][col1]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Longest Increasing Subsequence</title>
      <link href="/programming/leetcode/longest-increasing-subsequence/"/>
      <url>/programming/leetcode/longest-increasing-subsequence/</url>
      
        <content type="html"><![CDATA[<p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [10,9,2,5,3,7,101,18]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest increasing subsequence is [2,3,7,101], therefore the lenght is 4.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li>There may be more than on LIS combination, it is only necessary for you to return the length.</li><li>Your algorithm shoud run in O(n^2) complexity.</li></ul><p><strong>Follow up:</strong> Could you improve it to O(nlog(n)) time complexity?</p><h1 id="recursion">Recursion</h1><p>Define a function <code>helper(i)</code> returns the length of LIS that ends at <code>i</code>. Then answer of an input shoule be <code>max([helper(i) | 0 &lt;= i &lt; n])</code>.</p><p>To calculate <code>helper(i)</code>, we use a variable <code>res</code> which initialized to 1 to store the result. Then we find every number <code>nums[j] &lt; nums[i], 0 &lt;= j &lt; i</code>, let <code>res = max(res, helper(j) + 1)</code>.</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(2^n), every num is checked twice: included and not included.</span></span><br><span class="line"><span class="comment"># Space: O(n^2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: list)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(i)</span>:</span></span><br><span class="line">            res = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt; nums[i]:</span><br><span class="line">                    res = max(res, helper(j) + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(helper(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)))</span><br></pre></td></tr></table></figure><h1 id="dynamic-programming">Dynamic Programming</h1><p>Save results of <code>helper(i)</code>.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: list)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n, res = len(nums), <span class="number">1</span></span><br><span class="line">        dp = [<span class="number">1</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt; nums[i]:</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">            res = max(res, dp[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="dp-binary-search">DP + Binary Search</h1><p>In this approach, <code>dp</code> array stores the current longest increasing &quot;subsequence&quot;, and length of <code>dp</code> is 0 at the beginning. We scan the array from left to right, finding the correct position <code>i</code> for current item by binary search:</p><ul><li>If it happens to be the end of <code>dp</code> array (<code>i == len(dp)</code>), then we append it to then end of <code>dp</code> and increase our result <code>res</code> by 1, because we find a longer &quot;subsequence&quot;.</li><li>If not, just set current item to <code>dp[i]</code>, don't increase the <code>res</code>.</li></ul><p>Consider the example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [0, 8, 4, 12, 2, 13]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: LIS is [0, 4, 12, 13]</span><br><span class="line"></span><br><span class="line">dp: [0]             # i = 0, i is the insertion position of 0</span><br><span class="line">dp: [0, 8]          # i = 1</span><br><span class="line">dp: [0, 4]          # i = 1</span><br><span class="line">dp: [0, 4, 12]      # i = 2</span><br><span class="line">dp: [0, 2, 12]      # i = 1</span><br><span class="line">dp: [0, 2, 12, 13]  # i = 3</span><br><span class="line"></span><br><span class="line">dp is not a subsequence, but has the same length with LIS.</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> bisect</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time: O(n log(n))</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: list)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span>] * len(nums)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            i = bisect(dp, num, <span class="number">0</span>, res)</span><br><span class="line">            dp[i] = num</span><br><span class="line">            <span class="keyword">if</span> i == res:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> recursion </tag>
            
            <tag> leetcode </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Perfect Squares</title>
      <link href="/programming/leetcode/perfect-squares/"/>
      <url>/programming/leetcode/perfect-squares/</url>
      
        <content type="html"><![CDATA[<p>Given a positive integer <em>n</em>, find the least number of perfect square numbers (for example, <code>1, 4, 9, 16, ...</code>) which sum to <em>n</em>.</p><p>Example 1:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Input: n = <span class="number">12</span></span><br><span class="line">Output: <span class="number">3</span></span><br><span class="line">Explanation: <span class="number">12</span> = <span class="number">4</span> + <span class="number">4</span> + <span class="number">4.</span></span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Input: n = <span class="number">13</span></span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line">Explanation: <span class="number">13</span> = <span class="number">4</span> + <span class="number">9.</span></span><br></pre></td></tr></table></figure><h1 id="dynamic-programming">Dynamic Programming</h1><p>Let <code>dp[i]</code> denotes the least number of perfect square numbers which sum to <code>i</code>.</p><p>We can't find the largest square number <code>j &lt;= i</code>, then let <code>dp[i] = dp[i - j] + 1</code>. See example 1, the correct answer is <code>dp[12] = 3</code>. If we let <code>j = 9</code>, then <code>dp[12] = 1 + dp[12 - 9] = 1 + 3 = 4</code>, which is wrong. We should check every <code>j &lt;= i</code> like below.</p><p>If <code>1 &lt;= j &lt;= i</code> and <code>j</code> is a square number, then <code>i</code> can be summed by <code>j</code> and <code>i - j</code>, there are <code>1 + dp[i - j]</code> numbers.</p><a id="more"></a><p>Base case: <code>dp[0] = 0, dp[1] = 1</code>.</p><p>Induction rule: <code>dp[i] = min(dp[i - j] + 1 | 1 &lt;= j &lt;= i)</code>.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            j, res = <span class="number">1</span>, i</span><br><span class="line">            <span class="keyword">while</span> j * j &lt;= i:</span><br><span class="line">                res = min(res, dp[i - j * j] + <span class="number">1</span>)</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            dp.append(res)</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ugly Number</title>
      <link href="/programming/leetcode/ugly-number/"/>
      <url>/programming/leetcode/ugly-number/</url>
      
        <content type="html"><![CDATA[<h1 id="ugly-number-i">Ugly Number I</h1><p>Write a program to check whether a given number is an ugly number.</p><p>Ugly numbers are <strong>positive numbers</strong> whose prime factors only include <code>2, 3, 5</code>.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 6</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 6 = 2 * 3</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 8</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 8 = 2 * 2 * 2</span><br></pre></td></tr></table></figure><p>Example 3:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 14</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol type="1"><li><code>1</code> is typically treated as ugly number.</li><li>Input is within the 32-bit signed integer range: <code>[-2^31, 2^31 - 1]</code>.</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isUgly</span><span class="params">(self, num: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>):</span><br><span class="line">            <span class="keyword">while</span> num % x == <span class="number">0</span> &lt; num:</span><br><span class="line">                num /= x</span><br><span class="line">        <span class="keyword">return</span> num == <span class="number">1</span></span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="ugly-number-ii">Ugly Number II</h1><p>Write a program to find the <code>n</code>-th ugly number.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n = 10</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol type="1"><li><code>1</code> is typically treated as an ugly number.</li><li><code>n</code> <strong>does not exceed 1690.</strong></li></ol><h2 id="dynamic-programming">Dynamic Programming</h2><p>The first ugly number is 1. New ugly number can be computed by known ugly numbers.</p><p>For example, once we get a new ugly number <code>x</code>, then we add <code>x*2, x*3, x*5</code> to candidate set. And then pick the minimum number as the next ugly number, replace the procedure.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ugly_num, candidates = <span class="number">-1</span>, &#123;<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">    ugly_num = min(candidates)</span><br><span class="line">    candidates.remove(ugly_num)</span><br><span class="line">    candidates.update([ugly_num * <span class="number">2</span>, ugly_num * <span class="number">3</span>, ugly_num * <span class="number">5</span>])</span><br><span class="line"><span class="keyword">return</span> ugly_num</span><br></pre></td></tr></table></figure><p>If <code>n</code> is large, the <code>candidates</code> can be very large. We note that the candidates are <code>x * 2, y * 3, z * 5</code> where <code>x, y, z</code> are all ugly numbers. <code>x = y = z = 1</code> at the beginning. Once a candidate (say <code>2</code>) is chosen, we replace the corresponding ugly number (<code>x=1</code>) by the next ugly number (<code>x=2</code>).</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        ugly = [<span class="number">1</span>] * n</span><br><span class="line">        ind2, ind3, ind5 = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        can2, can3, can5 = <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            ugly[i] = min(can2, can3, can5)</span><br><span class="line">            <span class="keyword">if</span> can2 == ugly[i]:</span><br><span class="line">                ind2 += <span class="number">1</span></span><br><span class="line">                can2 = ugly[ind2] * <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> can3 == ugly[i]:</span><br><span class="line">                ind3 += <span class="number">1</span></span><br><span class="line">                can3 = ugly[ind3] * <span class="number">3</span></span><br><span class="line">            <span class="keyword">if</span> can5 == ugly[i]:</span><br><span class="line">                ind5 += <span class="number">1</span></span><br><span class="line">                can5 = ugly[ind5] * <span class="number">5</span></span><br><span class="line">        <span class="keyword">return</span> ugly[n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        ugly = [<span class="number">1</span>] * n</span><br><span class="line">        ind, fac = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], (<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">        can = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            ugly[i] = min(can)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(fac)):</span><br><span class="line">                <span class="keyword">if</span> can[j] == ugly[i]:</span><br><span class="line">                    ind[j] += <span class="number">1</span></span><br><span class="line">                    can[j] = ugly[ind[j]] * fac[j]</span><br><span class="line">        <span class="keyword">return</span> ugly[n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dungeon Game</title>
      <link href="/programming/leetcode/dungeon-game/"/>
      <url>/programming/leetcode/dungeon-game/</url>
      
        <content type="html"><![CDATA[<p>The demons had captured the princess (<strong>P</strong>) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists M x N rooms laid out in a 2D grid. Our valiant knight (<strong>K</strong>) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.</p><p>The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.</p><p>Some of the rooms are guarded by demons, so the knight loses health (<em>negative</em> integers) upon entering these rooms; other rooms are either empty (<em>0's</em>) or contain magic orbs that increase the knight's health (<em>positive</em> integers).</p><p>In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.</p><p><strong>Write a function to determine the knight's minimum initial health so that he is able to rescue the princess.</strong></p><p>For example, given the dungeon below, the initial health of the knight must be at least <strong>7</strong> if he follows the optimal path <code>RIGHT -&gt; RIGHT -&gt; DOWN -&gt; DOWN</code>.</p><table style="width: auto; text-align: center;"><tbody style="border-style: solid;"><tr><td>-2(K)</td><td>-3</td><td>3</td></tr><tr><td>-5</td><td>-10</td><td>1</td></tr><tr><td>10</td><td>30</td><td>-5(P)</td></tr></tbody></table><p><strong>Note:</strong></p><ul><li>The knight's health has no upper bound.</li><li>Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.</li></ul><h1 id="recursion">Recursion</h1><p>We use two variables <code>curr</code> and <code>init</code> to represent the current and minimum health. Define a function <code>helper(i, j, init, curr)</code> which returns the minimum health so that the knight can move from <code>(i, j)</code> to <code>(m, n)</code>.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculateMinimumHP</span><span class="params">(self, dungeon: list)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(i, j, init, curr)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i == len(dungeon) <span class="keyword">or</span> j == len(dungeon[i]):  <span class="comment"># reach the boundary</span></span><br><span class="line">                <span class="keyword">return</span> float(<span class="string">'inf'</span>)</span><br><span class="line">            curr = curr + dungeon[i][j]                    <span class="comment"># fight demons</span></span><br><span class="line">            <span class="keyword">if</span> curr &lt;= <span class="number">0</span>:</span><br><span class="line">                init = init - curr + <span class="number">1</span></span><br><span class="line">                curr = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == len(dungeon) - <span class="number">1</span> <span class="keyword">and</span> j == len(dungeon[i]) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> init</span><br><span class="line">            <span class="keyword">return</span> min(helper(i + <span class="number">1</span>, j, init, curr),</span><br><span class="line">                       helper(i, j + <span class="number">1</span>, init, curr))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="dynamic-programming">Dynamic Programming</h1><p>Denote <code>dp[i][j]</code> as the knight's minimum health if he start from room <code>(i, j)</code>.</p><p>It the knight positioned in <code>(i, j)</code>, he has two ways to go next: <code>(i + 1, j)</code> (downward) or <code>(i, j + 1)</code> (rightward).</p><ul><li>Downward: <code>dp[i][j] + dungeon[i][j] = dp[i + 1][j]</code>.</li><li>Rightward: <code>dp[i][j] + dungeon[i][j] = dp[i][j + 1]</code>.</li></ul><p>Pick the better one: <code>dp[i][j] + dungeon[i][j] = min(dp[i + 1][j], dp[i][j + 1])</code>.</p><p>So, <code>dp[i][j] = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]</code>, and we need it greater than 0.</p><p>Induction rule: <code>dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j])</code>.</p><p>Base cases: <code>dp[m][j] = dp[i][n] = inf</code>, but <code>dp[m][n - 1] = dp[m - 1][n] = 1</code> (At least 1 HP to be alive).</p><p>The last row and last column are meaningless, we add them to simplify the calculation.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      0    1    2    3</span><br><span class="line"></span><br><span class="line">0     K             inf</span><br><span class="line">1                   inf</span><br><span class="line">2               P    1</span><br><span class="line">3    inf  inf   1   inf</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(mn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculateMinimumHP</span><span class="params">(self, dungeon: list)</span> -&gt; int:</span></span><br><span class="line">        m, n = len(dungeon), len(dungeon[<span class="number">0</span>])</span><br><span class="line">        dp = [[float(<span class="string">'inf'</span>)] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">        dp[m][n - <span class="number">1</span>] = dp[m - <span class="number">1</span>][n] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                before = min(dp[i + <span class="number">1</span>][j], dp[i][j + <span class="number">1</span>]) - dungeon[i][j]</span><br><span class="line">                dp[i][j] = max(before, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculateMinimumHP</span><span class="params">(self, dungeon: list)</span> -&gt; int:</span></span><br><span class="line">        m, n = len(dungeon), len(dungeon[<span class="number">0</span>])</span><br><span class="line">        dp = [float(<span class="string">'inf'</span>)] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[n - <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                before = min(dp[j], dp[j + <span class="number">1</span>]) - dungeon[i][j]</span><br><span class="line">                dp[j] = max(before, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> recursion </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Palindrome Partitioning</title>
      <link href="/programming/leetcode/palindrome-partitioning/"/>
      <url>/programming/leetcode/palindrome-partitioning/</url>
      
        <content type="html"><![CDATA[<h1 id="palindrome-partitioning-i">Palindrome Partitioning I</h1><p>Given a string <em>s</em>, partition <em>s</em> such that every substring of the partition is a palindrome.</p><p>Return all possible palindrome partitioning of <em>s</em>.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;aab&quot;</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [&quot;aa&quot;, &quot;b&quot;],</span><br><span class="line">  [&quot;a&quot;, &quot;a&quot;, &quot;b&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="backtracking">Backtracking</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(2^n * n^2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, s: str)</span> -&gt; list:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(i, res, cur)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i == len(s):</span><br><span class="line">                res.append(cur[:])</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(s)):  <span class="comment"># O(n)</span></span><br><span class="line">                <span class="keyword">if</span> self.is_palindrome(s, i, j):  <span class="comment"># O(n)</span></span><br><span class="line">                    cur.append(s[i:j + <span class="number">1</span>])</span><br><span class="line">                    helper(j + <span class="number">1</span>, res, cur)</span><br><span class="line">                    cur.pop()</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        helper(<span class="number">0</span>, res, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_palindrome</span><span class="params">(s: str, l: int, r: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> l == r:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            <span class="keyword">if</span> s[l] != s[r]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            l, r = l + <span class="number">1</span>, r - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="dynamic-programming">Dynamic Programming</h2><p>Instead of checking <code>s[l .. r]</code> is a palindrome or not, we using dynamic programming to compute the result for each pair <code>(l, r)</code>. See <a href="/programming/leetcode/longest-palindromic-substring/" title="Longest Palindromic Substring">Longest Palindromic Substring</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, s: str)</span> -&gt; list:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> range(r + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[l] == s[r] <span class="keyword">and</span> (r - l &lt;= <span class="number">2</span> <span class="keyword">or</span> dp[l + <span class="number">1</span>][r - <span class="number">1</span>]):</span><br><span class="line">                    dp[l][r] = <span class="literal">True</span></span><br><span class="line">        res = []</span><br><span class="line">        self.helper(s, <span class="number">0</span>, dp, res, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, s, i, dp, res, cur)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i == len(s):</span><br><span class="line">            res.append(cur[:])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(s)):  <span class="comment"># O(n)</span></span><br><span class="line">            <span class="keyword">if</span> dp[i][j]:  <span class="comment"># O(1)</span></span><br><span class="line">                cur.append(s[i:j + <span class="number">1</span>])</span><br><span class="line">                self.helper(s, j + <span class="number">1</span>, dp, res, cur)</span><br><span class="line">                cur.pop()</span><br></pre></td></tr></table></figure><h1 id="palindrome-partitioning-ii">Palindrome Partitioning II</h1><p>Given a string <em>s</em>, partition <em>s</em> such that every substring of the partition is a palindrome.</p><p>Return the minimum cuts needed for a palindrome partitioning of <em>s</em>.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;aab&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><h2 id="dynamic-programming-1">Dynamic Programming</h2><p>Let <code>cut[i]</code> be the minimum cuts needed for substring <code>s[0 .. i]</code>.</p><p>Base case: <code>cut[i] = i - 1</code>. At most <code>i - 1</code> cuts needed for substring <code>s[0 .. i]</code>.</p><p>Induction rule: <code>cut[i] = min(cut[i], cut[j - 1] | 0 &lt;= j &lt;= i where s[j .. i] is a palindrome) + 1</code>.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0   1   2   3   4   5   6</span><br><span class="line">a   a   a   a   b   a   a</span><br><span class="line"></span><br><span class="line">cut[6] = min(cut[6], cut[1] + 1, cut[4] + 1)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2)</span></span><br><span class="line"><span class="comment"># Space: O(n^2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCut</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        cut = list(range(n))  <span class="comment"># initial, at most i-1 cuts for s[:i]</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> range(r + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[l] == s[r] <span class="keyword">and</span> (r - l &lt;= <span class="number">2</span> <span class="keyword">or</span> dp[l + <span class="number">1</span>][r - <span class="number">1</span>]):</span><br><span class="line">                    dp[l][r] = <span class="literal">True</span></span><br><span class="line">                    cut[r] = <span class="number">0</span> <span class="keyword">if</span> l == <span class="number">0</span> <span class="keyword">else</span> min(cut[r], cut[l - <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> cut[n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>If we let <code>cut[i]</code> be the minimum cuts needed for substring <code>s[0 .. i)</code> (<code>i</code> not included), and let <code>cut[0] = -1</code>, we can tackle with the boundary ingeniously.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2)</span></span><br><span class="line"><span class="comment"># Space: O(n^2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCut</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        cut = list(range(<span class="number">-1</span>, n))  <span class="comment"># tiny change</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> range(r + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[l] == s[r] <span class="keyword">and</span> (r - l &lt;= <span class="number">2</span> <span class="keyword">or</span> dp[l + <span class="number">1</span>][r - <span class="number">1</span>]):</span><br><span class="line">                    dp[l][r] = <span class="literal">True</span></span><br><span class="line">                    cut[r + <span class="number">1</span>] = min(cut[r + <span class="number">1</span>], cut[l] + <span class="number">1</span>)  <span class="comment"># tiny change</span></span><br><span class="line">        <span class="keyword">return</span> cut[n]  <span class="comment"># tiny change</span></span><br></pre></td></tr></table></figure><h2 id="using-on-space">Using O(n) space</h2><p>Let <code>cut[i]</code> be the minimum cuts needed for substring <code>s[0 .. i)</code>.</p><p>For each <code>0 &lt;= i &lt; n</code> we find every palindrome that centered at <code>i</code>. (See <a href="/programming/leetcode/longest-palindromic-substring/" title="Longest Palindromic Substring">Longest Palindromic Substring</a>: Expand Around Center)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    l     m     h</span><br><span class="line">... a  a  b  a  a ...</span><br><span class="line">    |&lt;--  y  --&gt;|</span><br><span class="line">|&lt;--    x    --&gt;|</span><br><span class="line"></span><br><span class="line">Say y is a palindrome around m.</span><br><span class="line">The minimum cuts needed for substring x is:</span><br><span class="line">cut[h + 1] = min(cut[h + 1], cut[l] + 1)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCut</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        cut = list(range(<span class="number">-1</span>, n))</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> l, h <span class="keyword">in</span> (m, m), (m - <span class="number">1</span>, m):</span><br><span class="line">                <span class="keyword">while</span> l &gt;= <span class="number">0</span> <span class="keyword">and</span> h &lt; n <span class="keyword">and</span> s[l] == s[h]:</span><br><span class="line">                    cut[h + <span class="number">1</span>] = min(cut[h + <span class="number">1</span>], cut[l] + <span class="number">1</span>)</span><br><span class="line">                    l, h = l - <span class="number">1</span>, h + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cut[n]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> recursion </tag>
            
            <tag> leetcode </tag>
            
            <tag> palindrome </tag>
            
            <tag> backtracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maximum Square</title>
      <link href="/programming/leetcode/maximum-square/"/>
      <url>/programming/leetcode/maximum-square/</url>
      
        <content type="html"><![CDATA[<p>Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [&apos;1&apos;, &apos;0&apos;, &apos;1&apos;, &apos;0&apos;, &apos;0&apos;],</span><br><span class="line">  [&apos;1&apos;, &apos;0&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;],</span><br><span class="line">  [&apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;],</span><br><span class="line">  [&apos;1&apos;, &apos;0&apos;, &apos;0&apos;, &apos;1&apos;, &apos;0&apos;]</span><br><span class="line">]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><h1 id="broute-force">Broute Force</h1><p>We use a variable to contain the size of the largest square found so far and another variable to store the size of the current, both initialized to 0.</p><p>Starting from the left uppermost point in the matrix, we search for a 1. No operation needs to be done for a 0.</p><p>Whenever a 1 is found, we try to find out the largest square that can be formed including that 1. For this, we move diagonally (right and downwards), i.e. we increment the row index and column index temporarily and then check whether all the elements of that row and column are 1 or not.</p><p>If all the elements happen to be 1, we move diagonally further as previously. If even one element turns out to be 0, we stop this diagonal movement and update the size of the largest square.</p><p>Now we, continue the traversal of the matrix from the element next to the initial 1 found, till all the elements of the matrix have been traversed.</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O((mn)^2)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span><span class="params">(self, matrix: list)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            m, n = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        max_sq = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] != <span class="string">'1'</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                sq, flag = <span class="number">1</span>, <span class="literal">True</span></span><br><span class="line">                <span class="keyword">while</span> sq + i &lt; m <span class="keyword">and</span> sq + j &lt; n <span class="keyword">and</span> flag:</span><br><span class="line">                    flag = all(matrix[sq + i][k] == <span class="string">'1'</span>  <span class="comment"># sq+i column</span></span><br><span class="line">                               <span class="keyword">for</span> k <span class="keyword">in</span> range(j, sq + j + <span class="number">1</span>)) <span class="keyword">and</span> \</span><br><span class="line">                           all(matrix[k][sq + j] == <span class="string">'1'</span>  <span class="comment"># sq+j row</span></span><br><span class="line">                               <span class="keyword">for</span> k <span class="keyword">in</span> range(i, sq + i + <span class="number">1</span>))</span><br><span class="line">                    <span class="keyword">if</span> flag:</span><br><span class="line">                        sq += <span class="number">1</span></span><br><span class="line">                max_sq = max(max_sq, sq)</span><br><span class="line">        <span class="keyword">return</span> max_sq ** <span class="number">2</span></span><br></pre></td></tr></table></figure><!-- more --><h1 id="dynamic-programming">Dynamic Programming</h1><p>We initialize another matrix (dp) with the same dimensions as the original one initialized with all 0's.</p><p><code>dp[i][j]</code> represents the side length of the maximum square whose bottom right corner is the cell with index <code>(i, j)</code> in the original matrix.</p><p>Starting from index <code>(0, 0)</code>, for every 1 found in the original matrix, we update the value of the current element as <code>dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1], dp[i][j - 1]) + 1</code>.</p><p>We also remember the size of the largest square found so far. In this way, we traverse the original matrix once and find out the required maximum size.</p><p>To understand how this solution works, see the figure below.</p><p><img src="/uploads/image/leetcode/maximal_square.png"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(mn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span><span class="params">(self, matrix: list)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            m, n = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">        max_sq = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="string">'1'</span>:</span><br><span class="line">                    dp[i][j] = min(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">                    max_sq = max(max_sq, dp[i][j])</span><br><span class="line">        <span class="keyword">return</span> max_sq ** <span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span><span class="params">(self, matrix: list)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            m, n = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        max_sq = prev = <span class="number">0</span>  <span class="comment"># prev = dp[i - 1][j - 1]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                temp = dp[j]</span><br><span class="line">                <span class="keyword">if</span> matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="string">'1'</span>:</span><br><span class="line">                    dp[j] = min(dp[j - <span class="number">1</span>], dp[j], prev) + <span class="number">1</span></span><br><span class="line">                    max_sq = max(max_sq, dp[j])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[j] = <span class="number">0</span></span><br><span class="line">                prev = temp</span><br><span class="line">        <span class="keyword">return</span> max_sq ** <span class="number">2</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>House Robber</title>
      <link href="/programming/leetcode/house-robber/"/>
      <url>/programming/leetcode/house-robber/</url>
      
        <content type="html"><![CDATA[<h1 id="house-robber-i">House Robber I</h1><p>You are a professional robber planning to rob houses along a streat. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have securtiy system connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night.</strong></p><p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police.</strong></p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3,1]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,7,9,3,1]</span><br><span class="line">Output: 12</span><br></pre></td></tr></table></figure><h2 id="dynamic-programming">Dynamic Programming</h2><p>Let <code>dp[i]</code> denotes the maximum amount money you can rob from <code>nums[0 .. i]</code>.</p><p>The action you can do is,</p><ul><li>Rob <code>nums[i]</code>, then <code>dp[i] = dp[i - 2] + nums[i]</code>.</li><li>Don't rob, then <code>dp[i] = dp[i - 1]</code>.</li></ul><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: list)</span> -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            dp.append(max(dp[<span class="number">-2</span>] + x, dp[<span class="number">-1</span>]))</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: list)</span> -&gt; int:</span></span><br><span class="line">        prev2 = prev1 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            temp = prev1</span><br><span class="line">            prev1 = max(prev2 + x, prev1)</span><br><span class="line">            prev2 = temp</span><br><span class="line">        <span class="keyword">return</span> prev1</span><br></pre></td></tr></table></figure><h1 id="house-robber-ii">House Robber II</h1><p>All houses at this place are <strong>arranged in a circle.</strong> That means the first house is the neighbor of the last one.</p><p>Determine the maximum amount of money you can rob tonight <strong>without alerting the police.</strong></p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,3,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3,1]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><h2 id="two-pass">Two Pass</h2><p>There are two cases: rob <code>nums[0]</code> or rob <code>nums[n - 1]</code>. So we can utilize the method of House Robber I, the maximum amount should be <code>max(rob(nums[:n-1], rob(nums[1:]))</code>.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: list)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(start, stop)</span>:</span></span><br><span class="line">            prev2 = prev1 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start, stop):</span><br><span class="line">                temp = prev1</span><br><span class="line">                prev1 = max(prev2 + nums[i], prev1)</span><br><span class="line">                prev2 = temp</span><br><span class="line">            <span class="keyword">return</span> prev1</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(helper(<span class="number">0</span>, len(nums) - <span class="number">1</span>),</span><br><span class="line">                   helper(<span class="number">1</span>, len(nums)))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maximum Product Subarray</title>
      <link href="/programming/leetcode/maximum-product-subarray/"/>
      <url>/programming/leetcode/maximum-product-subarray/</url>
      
        <content type="html"><![CDATA[<p>Given an integer array <code>nums</code>, find the contiguous subarray within an array (contaning at least one number) which has the largest product.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,3,-2,4]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [-2,0,-1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><h1 id="dynamic-programming">Dynamic Programming</h1><p>Let <code>dp_max[i]</code> be the maximum product of subarray and <code>dp_min[i]</code> be the minimum product of subarray that ends with <code>nums[i]</code>. The maximum value of array <code>dp_max</code> is the answer.</p><p>Base case: <code>dp_max[0] = dp_min[0] = nums[0]</code>.</p><p>Induction rules:</p><ul><li>If <code>nums[i] &gt;= 0</code>, <code>dp_max[i] = max(dp_max[i - 1] * nums[i], nums[i])</code>, <code>dp_min[i] = min(dp_min[i - 1] * nums[i], nums[i])</code>.</li><li>If <code>nums[i] &lt; 0</code>, <code>dp_max[i] = max(dp_min[i - 1] * nums[i], nums[i])</code>, <code>dp_min[i] = min(dp_max[i - 1] * nums[i], nums[i])</code>.</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums: list)</span> -&gt; int:</span></span><br><span class="line">        imax = imin = res = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; <span class="number">0</span>:</span><br><span class="line">                imax, imin = imin, imax</span><br><span class="line">            imax = max(imax * nums[i], nums[i])</span><br><span class="line">            imin = min(imin * nums[i], nums[i])</span><br><span class="line">            res = max(res, imax)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Word Break</title>
      <link href="/programming/leetcode/word-break/"/>
      <url>/programming/leetcode/word-break/</url>
      
        <content type="html"><![CDATA[<h1 id="word-break-i">Word Break I</h1><p>Given a <strong>non-empty</strong> string <em>s</em> and a dictionary <em>wordDict</em> containing a list of <strong>non-empty</strong> words, determine if <em>s</em> can be segmented into a space-separated sequence of one or more dictionary words.</p><p><strong>Note:</strong></p><ul><li>The same word in the dictionary may be reused multiple times in the segmentation.</li><li>You may assume the dictionary does not contain duplicate words.</li></ul><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>Example 3:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><h2 id="dynamic-programming">Dynamic Programming</h2><p>Let <code>dp[i]</code> denotes whether <code>s[0 .. i)</code> can be segmented into a space-separated sequence of one or more dictionary words.</p><a id="more"></a><p>Base case: <code>dp[0] = true</code>.</p><p>Induction rule:</p><p>For filling in the entry of <code>dp[i]</code>, if there exist any <code>j &lt; i</code> where <code>dp[j] = true</code> and <code>s[j .. i)</code> is contained in <code>wordDict</code>, then <code>dp[i] = true</code>.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s: str, wordDict: list)</span> -&gt; bool:</span></span><br><span class="line">        n, wordDict = len(s), set(wordDict)</span><br><span class="line">        dp = [<span class="literal">True</span>] + [<span class="literal">False</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = any(dp[j] <span class="keyword">and</span> s[j:i] <span class="keyword">in</span> wordDict</span><br><span class="line">                        <span class="keyword">for</span> j <span class="keyword">in</span> reversed(range(i)))  <span class="comment"># backward may improve performace a little bit</span></span><br><span class="line">            <span class="comment"># This is equivalent to:</span></span><br><span class="line">            <span class="string">'''</span></span><br><span class="line"><span class="string">            for j in reversed(range(i)):</span></span><br><span class="line"><span class="string">                if dp[j] and s[j:i] in wordDict:</span></span><br><span class="line"><span class="string">                    dp[i] = True</span></span><br><span class="line"><span class="string">                    break</span></span><br><span class="line"><span class="string">            '''</span></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><h1 id="word-break-ii">Word Break II</h1><p>Given a <strong>non-empty</strong> string <em>s</em> and a dictionary <em>wordDict</em> containing a list of <strong>non-empty</strong> words, add spaces in <em>s</em> to construct a sentence where each word is valid dictionary word. Return all such possible sentences.</p><p><strong>Note:</strong></p><ul><li>The same word in the dictionary may be reused multiple times in the segmentation.</li><li>You may assume the dictionary does not contain duplicate words.</li></ul><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;catsanddog&quot;</span><br><span class="line">wordDict = [&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  &quot;cats and dog&quot;,</span><br><span class="line">  &quot;cat sand dog&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;pineapplepenapple&quot;</span><br><span class="line">wordDict = [&quot;apple&quot;, &quot;pen&quot;, &quot;applepen&quot;, &quot;pine&quot;, &quot;pineapple&quot;]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  &quot;pine apple pen apple&quot;,</span><br><span class="line">  &quot;pineapple pen apple&quot;,</span><br><span class="line">  &quot;pine applepen apple&quot;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">```text</span><br><span class="line">Input:</span><br><span class="line">s = &quot;catsandog&quot;</span><br><span class="line">wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">Output:</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><h2 id="dynamic-programming-1">Dynamic Programming</h2><p>Just let <code>dp[i]</code> be the all such possible sentences of <code>s[0 .. i)</code>. The induction rule is absolutely the same with Word Break I.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s: str, wordDict: list)</span> -&gt; list:</span></span><br><span class="line">        n, wordDict = len(s), set(wordDict)</span><br><span class="line">        dp = [[<span class="string">""</span>]] + [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> dp[j] <span class="keyword">and</span> s[j:i] <span class="keyword">in</span> wordDict:</span><br><span class="line">                    dp[i].extend((x + <span class="string">' '</span> + s[j:i]).lstrip()</span><br><span class="line">                                 <span class="keyword">for</span> x <span class="keyword">in</span> dp[j])</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Best Time to Buy and Sell Stock</title>
      <link href="/programming/leetcode/best-time-to-buy-and-sell-stock/"/>
      <url>/programming/leetcode/best-time-to-buy-and-sell-stock/</url>
      
        <content type="html"><![CDATA[<h1 id="at-most-1-transaction">At most 1 transaction</h1><p>Say you have an array for which the <code>i</code>-th element is the price of a given stock on day <code>i</code>.</p><p>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p><p>Not that you cannnot sell a stock before you buy one.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [7,1,5,3,6,4]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><h2 id="broute-force">Broute Force</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: list)</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> sell <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            <span class="comment"># range(sell + 1) also works.</span></span><br><span class="line">            <span class="comment"># prices[sell] is the minimum price by far,</span></span><br><span class="line">            <span class="comment"># prices[sell] - prices[min_price] = 0,</span></span><br><span class="line">            <span class="comment"># hence, res = max(res, 0)</span></span><br><span class="line">            min_price = min(prices[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(sell))</span><br><span class="line">            res = max(res, prices[sell] - prices[min_price])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>We can use a variable to save the minimum price by far instead of computing repetitively.</p><a id="more"></a><h2 id="one-pass">One Pass</h2><p>Say the given array is <code>[7,1,5,3,6,4]</code>. If we plot the numbers of the given array on a graph, we get:</p><p><img src="/uploads/image/leetcode/maximum_profit_graph.png"></p><p><strong>The points of interest are the peaks and valleys in the given graph. We need to find the largest peak following the smallest valley.</strong> We can maintain two variables - <code>minprice</code> and <code>maxprofit</code> corresponding to the smallest valley and maximum profit obtained so far respectively.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: list)</span> -&gt; int:</span></span><br><span class="line">        min_price, max_profit = float(<span class="string">'inf'</span>), <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> prices:</span><br><span class="line">            min_price = min(min_price, p)</span><br><span class="line">            max_profit = max(max_profit, p - min_price)</span><br><span class="line">        <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure><h2 id="maximum-subarray">Maximum Subarray</h2><p>We can transform the problem to the Maximum Subarray problem. Here gives the Dynamic Programming solution of the Maximum Subarray problem, see <a href="/programming/leetcode/maximum-subarray/" title="Maximum Subarray">Maximum Subarray</a> for other solutions.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: list)</span> -&gt; int:</span></span><br><span class="line">        cur = res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            cur = max(cur, <span class="number">0</span>) + prices[i] - prices[i - <span class="number">1</span>]</span><br><span class="line">            res = max(res, cur)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="at-most-2-transactions">At most 2 transactions</h1><p>Design an algorithm to find the maximum profit. You may complete at most two transactions.</p><p><strong>Note:</strong> You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,3,5,0,0,3,1,4]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3,4,5]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p>Example 3:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><h2 id="one-pass-1">One Pass</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Variation 1</span></span><br><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: list)</span> -&gt; int:</span></span><br><span class="line">        profit1 = profit2 = <span class="number">0</span></span><br><span class="line">        min_price1 = min_price2 = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> prices:</span><br><span class="line">            profit2 = max(profit2, p - min_price2)</span><br><span class="line">            min_price2 = min(min_price2, p - profit1)</span><br><span class="line">            profit1 = max(profit1, p - min_price1)</span><br><span class="line">            min_price1 = min(min_price1, p)</span><br><span class="line">        <span class="keyword">return</span> profit2</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Variation 2</span></span><br><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: list)</span> -&gt; int:</span></span><br><span class="line">        profit1 = profit2 = <span class="number">0</span></span><br><span class="line">        min_price1 = min_price2 = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> prices:</span><br><span class="line">            min_price1 = min(min_price1, p)</span><br><span class="line">            profit1 = max(profit1, p - min_price1)</span><br><span class="line">            <span class="comment"># considering how much we can earned if we have `profit1`</span></span><br><span class="line">            min_price2 = min(min_price2, p - profit1)</span><br><span class="line">            profit2 = max(profit2, p - min_price2)</span><br><span class="line">        <span class="keyword">return</span> profit2</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e.g. prices = [1, 2, 0, 3, 1, 2, 0, 4]</span><br><span class="line">                     ^  ^        ^  ^</span><br><span class="line"></span><br><span class="line"> p                 1   2   0   3   1   2   0   4</span><br><span class="line">m1=min(m1, p)      1   1   0   0   0   0   0   0  &lt;- minimum price by far</span><br><span class="line">p1=max(p1, p-m1)   0   1   1   3   3   3   3   4  &lt;- maximum profit by far</span><br><span class="line">           p-p1    1   1  -1   0  -2  -1  -3   0  &lt;- the price we buy a stock if we&apos;ve earned p1</span><br><span class="line">m2=min(m2, p-p1)   1   1  -1  -1  -2  -2  -3  -3  &lt;- minimum price if we&apos;ve earned p1</span><br><span class="line">p2=max(p2, p-m2)   0   1   1   4   4   4   4   7  &lt;- total profit</span><br></pre></td></tr></table></figure><h1 id="at-most-k-transactions">At most k transactions</h1><p>Design an algorithm to find the maximum profit. You may complete at most <strong>k</strong> transactions.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,4,1], k = 2</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,2,6,5,0,3], k = 2</span><br><span class="line">Output: 7</span><br></pre></td></tr></table></figure><h2 id="dynamic-programming">Dynamic Programming</h2><p>Let <code>dp[k][n]</code> be the maximum profit completing at most <code>k</code> transactions on <code>n</code>-th day. <code>n</code> start from 1. Hence, <code>n</code>-th day's price is <code>prices[n - 1]</code>.</p><p>Base case: <code>dp[0][n] = dp[k][0] =  0</code>. Say <code>prices = [1,2,0,3]</code>, the base case is:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">prices      1   2   0   3</span><br><span class="line">       d0  d1  d2  d3  d4</span><br><span class="line">   t0   0   0   0   0   0</span><br><span class="line">   t1   0</span><br><span class="line">   t2   0</span><br></pre></td></tr></table></figure><p>Induction rules:</p><p>For filling in the entry of <code>dp[i][j]</code>,</p><ul><li>If we don't sell a stock on <code>j</code>-th day, <code>dp[i][j] = dp[i][j - 1]</code>.</li><li>If we sell a stock on <code>j</code>-th day, we must buy a stock on <code>x</code>-th day where <code>1 &lt;= x &lt; j</code>, <code>dp[i][j] = max(dp[i - 1][x - 1] - prices[x - 1] + prices[j - 1] | 1 &lt;= x &lt; j)</code>. <strong>If <code>x = j</code>, means we buy and sell a stock on one day, which is effectively trading nothing.</strong> So, <code>1 &lt;= x &lt;= j</code> also works well. This helps when we reduce the time complexity later.</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][j] = max(dp[i][j - 1],</span><br><span class="line">               max(dp[i - 1][x - 1] - prices[x - 1] | 1 &lt;= x &lt;= j) + prices[j - 1])</span><br><span class="line">                                      ^ buy on x-th day              ^ sell on j-th day</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(kn^2)</span></span><br><span class="line"><span class="comment"># Space: O(kn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, k: int, prices: list)</span> -&gt; int:</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(k + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, k + <span class="number">1</span>):  <span class="comment"># O(k), add an outer loop, dealing with transactions</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):  <span class="comment"># O(n)</span></span><br><span class="line">                val = max(dp[i - <span class="number">1</span>][x] - prices[x] <span class="keyword">for</span> x <span class="keyword">in</span> range(j))  <span class="comment"># O(n), 0 &lt;= x &lt;= j - 1</span></span><br><span class="line">                dp[i][j] = max(dp[i][j - <span class="number">1</span>], val + prices[j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[k][n]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(kn)</span></span><br><span class="line"><span class="comment"># Space: O(kn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, k: int, prices: list)</span> -&gt; int:</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(k + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, k + <span class="number">1</span>):  <span class="comment"># O(k)</span></span><br><span class="line">            val = float(<span class="string">'-inf'</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):  <span class="comment"># O(n)</span></span><br><span class="line">                val = max(val, dp[i - <span class="number">1</span>][j - <span class="number">1</span>] - prices[j - <span class="number">1</span>])  <span class="comment"># O(1)</span></span><br><span class="line">                dp[i][j] = max(dp[i][j - <span class="number">1</span>], val + prices[j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[k][n]</span><br></pre></td></tr></table></figure><h1 id="from-dp-to-one-pass">From DP to One Pass</h1><ul><li>Exchange the two <code>for</code> loop. <code>val</code> is different with different <code>i</code>, so we need a vector to store values separately.</li><li>Transpose array <code>dp</code>.</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(kn)</span></span><br><span class="line"><span class="comment"># Space: O(kn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: list)</span> -&gt; int:</span></span><br><span class="line">        n, k = len(prices), <span class="number">2</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (k + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)]  <span class="comment"># transposed</span></span><br><span class="line">        val = [float(<span class="string">'-inf'</span>)] * (k + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):  <span class="comment"># on j-th day</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, k + <span class="number">1</span>):</span><br><span class="line">                val[i] = max(val[i], dp[j - <span class="number">1</span>][i - <span class="number">1</span>] - prices[j - <span class="number">1</span>])</span><br><span class="line">                dp[j][i] = max(dp[j - <span class="number">1</span>][i], val[i] + prices[j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[n][k]</span><br></pre></td></tr></table></figure><h2 id="loop-backward">Loop backward</h2><p>It seems like <code>dp[j][i]</code> is dependent on <code>dp[j - 1][i]</code> and <code>dp[j - 1][i - 1]</code>. So, if we want to use a vector to instead array, we need to loop backwards from <code>k</code> to 1.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(kn)</span></span><br><span class="line"><span class="comment"># Space: O(k)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: list)</span> -&gt; int:</span></span><br><span class="line">        n, k = len(prices), <span class="number">2</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (k + <span class="number">1</span>)  <span class="comment"># using vector</span></span><br><span class="line">        val = [float(<span class="string">'-inf'</span>)] * (k + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(k, <span class="number">0</span>, <span class="number">-1</span>):  <span class="comment"># backward</span></span><br><span class="line">                val[i] = max(val[i], dp[i - <span class="number">1</span>] - prices[j - <span class="number">1</span>])</span><br><span class="line">                dp[i] = max(dp[i], val[i] + prices[j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[k]</span><br></pre></td></tr></table></figure><p>Let <code>dp = [sell_0, sell_1, sell_2]</code> and <code>val = [buy_0, buy_1, buy_2]</code>, we can reduce the space complexity further.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: list)</span> -&gt; int:</span></span><br><span class="line">        buy_1 = buy_2 = float(<span class="string">'-inf'</span>)</span><br><span class="line">        sell_1 = sell_2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> prices:</span><br><span class="line">            buy_2 = max(buy_2, sell_1 - p)  <span class="comment"># buy_2 &lt;- val[2]</span></span><br><span class="line">            sell_2 = max(sell_2, buy_2 + p)</span><br><span class="line">            buy_1 = max(buy_1, -p)</span><br><span class="line">            sell_1 = max(sell_1, buy_1 + p)</span><br><span class="line">        <span class="keyword">return</span> sell_2</span><br></pre></td></tr></table></figure><h2 id="loop-forward">Loop forward</h2><p>Actually, loop forwards from 1 to k is also feasible. <strong>Because even if <code>dp[j - 1][i - 1]</code> is updated to <code>dp[j][i - 1]</code>, <code>var[i]</code> has the same value.</strong></p><p><code>dp[j][i - 1]</code> can be larger than or equal to <code>dp[j - 1][i - 1]</code>.</p><ul><li>If <code>dp[j][i - 1] = dp[j - 1][i - 1]</code>, obviously <code>var[i]</code> won't change.</li><li>If <code>dp[j][i - 1] &gt; dp[j - 1][i - 1]</code>, means we have sold a stock on <code>j</code>-th day. Since <code>var[i] = max(var[i], dp[j][i - 1] - price[j - 1])</code>, buy and sell a stock on one day is effectively trading noting.</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: list)</span> -&gt; int:</span></span><br><span class="line">        buy_1 = buy_2 = float(<span class="string">'-inf'</span>)</span><br><span class="line">        sell_1 = sell_2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> prices:</span><br><span class="line">            buy_1 = max(buy_1, -p)</span><br><span class="line">            sell_1 = max(sell_1, buy_1 + p)</span><br><span class="line">            buy_2 = max(buy_2, sell_1 - p)</span><br><span class="line">            sell_2 = max(sell_2, buy_2 + p)</span><br><span class="line">        <span class="keyword">return</span> sell_2</span><br></pre></td></tr></table></figure><h1 id="with-cooldown">with Cooldown</h1><p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:</p><ul><li>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</li><li>After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)</li></ul><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3,0,2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: transactions = [buy, sell, cooldown, buy, sell]</span><br></pre></td></tr></table></figure><h2 id="one-pass-2">One Pass</h2><p>Let <code>dp[i]</code> represents the maximum profit on the <code>i</code>-th day.</p><p>Base case: <code>dp[0] = 0</code>.</p><p>Induction rules:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i] = max(dp[i - 1],</span><br><span class="line">            max(dp[j - 2] - prices[j - 1] | 1 &lt;= j &lt;= i) + prices[i - 1])</span><br><span class="line">                ^           ^ buy on j-th day                     ^ sell on i-th day</span><br><span class="line">       max profit on (j-2)-th day</span><br></pre></td></tr></table></figure><p>When <code>j = 1</code>, <code>dp[j - 2] = dp[-1]</code> should be 0.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: list)</span> -&gt; int:</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)  <span class="comment"># dp[-1] = dp[n] = 0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            val = max(dp[j - <span class="number">1</span>] - prices[j] <span class="keyword">for</span> j <span class="keyword">in</span> range(i))</span><br><span class="line">            dp[i] = max(dp[i - <span class="number">1</span>], val + prices[i - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: list)</span> -&gt; int:</span></span><br><span class="line">        prev1 = prev2 = <span class="number">0</span>  <span class="comment"># maximum profits</span></span><br><span class="line">        val = float(<span class="string">'-inf'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> prices:</span><br><span class="line">            val = max(val, prev2 - p)</span><br><span class="line">            prev2 = prev1</span><br><span class="line">            prev1 = max(prev1, val + p)</span><br><span class="line">        <span class="keyword">return</span> prev1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Triangle</title>
      <link href="/programming/leetcode/triangle/"/>
      <url>/programming/leetcode/triangle/</url>
      
        <content type="html"><![CDATA[<p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p><p>For example, given the follwing triangle</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).</p><h1 id="dynamic-programming">Dynamic Programming</h1><p>Let <code>dp[i][j]</code> denotes the sum of minimum path that end at <code>triangle[i][j]</code>.</p><p>Base case: <code>dp[m - 1][j] = triangle[m - 1][j]</code>. Where <code>m</code> is the length of <code>triangle</code>.</p><p>Induction rule: <code>dp[i][j] = triangle[i][j] + min(dp[i + 1][j], dp[i + 1][j + 1])</code>.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn), where n is the length of last row in triangle.</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle: list)</span> -&gt; int:</span></span><br><span class="line">        m, dp = len(triangle), triangle[<span class="number">-1</span>][:]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(triangle[i])):</span><br><span class="line">                dp[j] = triangle[i][j] + min(dp[j], dp[j + <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Distinct Subsequences</title>
      <link href="/programming/leetcode/distinct-subsequences/"/>
      <url>/programming/leetcode/distinct-subsequences/</url>
      
        <content type="html"><![CDATA[<p>Given a string <strong>S</strong> and a string <strong>T</strong>, count the number of distinct subsequences of <strong>S</strong> which equals <strong>T</strong>.</p><p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, &quot;ACE&quot; is a subsequence of &quot;ABCDE&quot; while &quot;AEC&quot; is not).</p><p>It's guaranteed the answer fits on a 32-bit signed integer.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: S = &quot;rabbbit&quot;, T = &quot;rabbit&quot;</span><br><span class="line">Ouput: 3</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: S = &quot;babgbag&quot;, T = &quot;bag&quot;</span><br><span class="line">Ouput: 5</span><br></pre></td></tr></table></figure><h1 id="dynamic-programming">Dynamic Programming</h1><p>Let <code>dp[i][j]</code> denotes the number of distinct subsequences of <code>s[0 .. i - 1]</code> which equals <code>t[0 .. j - 1]</code>.</p><p>Base cases:</p><ul><li>If <code>j == 0</code>, <code>dp[i][0] = 1</code>. An empty string is a subsequences of any strings.</li><li>If <code>i == 0</code>, <code>dp[0][j] = 0</code>. A non-empty string is not a subsequences of an empty string. Specially, <code>dp[0][0] = 1</code>.</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e.g. s = &apos;baag&apos;, t = &apos;bag&apos;</span><br><span class="line"></span><br><span class="line">  s 0  1  2  3  4</span><br><span class="line">t   +--+--+--+--+</span><br><span class="line">0   1  1  1  1  1</span><br><span class="line">1   0</span><br><span class="line">2   0</span><br><span class="line">3   0</span><br></pre></td></tr></table></figure><a id="more"></a><p>Induction rules:</p><p>For filling in the entry of <code>dp[i][j]</code>,</p><ul><li>If <code>s[i - 1] != t[j - 1]</code>, then we have the same number of distinct subsequences as we had without the new character. <code>dp[i][j] = dp[i - 1][j]</code>.</li><li>If <code>s[i - 1] == t[j - 1]</code>, <code>dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]</code>. The number of distinct subsequences is the number when character <code>s[i - 1]</code> is chosen <strong>plus</strong> when it's not.</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(mn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDistinct</span><span class="params">(self, s: str, t: str)</span> -&gt; int:</span></span><br><span class="line">        m, n = len(s), len(t)</span><br><span class="line">        <span class="keyword">if</span> m &lt; n:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> m == n:</span><br><span class="line">            <span class="keyword">return</span> s == t</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDistinct</span><span class="params">(self, s: str, t: str)</span> -&gt; int:</span></span><br><span class="line">        m, n = len(s), len(t)</span><br><span class="line">        <span class="keyword">if</span> m &lt; n:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> m == n:</span><br><span class="line">            <span class="keyword">return</span> s == t</span><br><span class="line">        dp = [<span class="number">1</span>] + [<span class="number">0</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            cur = dp[:]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]:</span><br><span class="line">                    cur[j] = dp[j - <span class="number">1</span>] + dp[j]</span><br><span class="line">            dp = cur</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interleaving String</title>
      <link href="/programming/leetcode/interleaving-string/"/>
      <url>/programming/leetcode/interleaving-string/</url>
      
        <content type="html"><![CDATA[<p>Given <em>s1, s2, s3</em>, find whether <em>s3</em> is formed by the interleaving of <em>s1</em> and <em>s2</em>.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbaccc&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><h1 id="brute-force">Brute Force</h1><p>The most basic idea is to find every string possible by all interleavings of the two given strings <code>s1</code> and <code>s2</code>. <code>m</code> is the length of <code>s1</code>, <code>n</code> is the length of <code>s2</code>.</p><p>If <code>s3[0 .. i + j - 1]</code> is formed by the interleaving of <code>s1[0 .. i - 1]</code> and <code>s2[0 .. j - 1]</code>,</p><ul><li>If <code>s3[i + j] == s1[i]</code>, then check if <code>s3[i + j + 1 .. m + n - 1]</code> can be obtained by <code>s1[i + 1 .. m - 1]</code> and <code>s2[j .. n - 1]</code>.</li><li>If <code>s3[i + j] == s2[j]</code>, then check if <code>s3[i + j + 1 .. m + n - 1]</code> can be obtained by <code>s1[i .. m - 1]</code> and <code>s2[j + 1 .. n - 1]</code>.</li><li>Else, return false.</li></ul><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(2^(m + n))</span></span><br><span class="line"><span class="comment"># Space: O(m + n). The size of stack for recursive calls can go upto m + n.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isInterleave</span><span class="params">(self, s1: str, s2: str, s3: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(s1) + len(s2) != len(s3):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.is_interleave(s1, <span class="number">0</span>, s2, <span class="number">0</span>, s3)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_interleave</span><span class="params">(self, s1, i, s2, j, s3)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i == len(s1):</span><br><span class="line">            <span class="keyword">return</span> s2[j:] == s3[i + j:]</span><br><span class="line">        <span class="keyword">if</span> j == len(s2):</span><br><span class="line">            <span class="keyword">return</span> s1[i:] == s3[i + j:]</span><br><span class="line">        res = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> s1[i] == s3[i + j]:</span><br><span class="line">            res |= self.is_interleave(s1, i + <span class="number">1</span>, s2, j, s3)</span><br><span class="line">        <span class="keyword">if</span> s2[j] == s3[i + j]:</span><br><span class="line">            res |= self.is_interleave(s1, i, s2, j + <span class="number">1</span>, s3)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="recursion-with-memoization">Recursion with memoization</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn). Each (i, j) combination is computed only once.</span></span><br><span class="line"><span class="comment"># Space: O(mn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isInterleave</span><span class="params">(self, s1: str, s2: str, s3: str)</span> -&gt; bool:</span></span><br><span class="line">        m, n = len(s1), len(s2)</span><br><span class="line">        <span class="keyword">if</span> m + n != len(s3):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        memo = [[<span class="literal">None</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">return</span> self.is_interleave(s1, <span class="number">0</span>, s2, <span class="number">0</span>, s3, memo)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_interleave</span><span class="params">(self, s1, i, s2, j, s3, memo)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> memo[i][j] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> memo[i][j]</span><br><span class="line">        res = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> i == len(s1):</span><br><span class="line">            res = s2[j:] == s3[i + j:]</span><br><span class="line">        <span class="keyword">elif</span> j == len(s2):</span><br><span class="line">            res = s1[i:] == s3[i + j:]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> s1[i] == s3[i + j]:</span><br><span class="line">                res |= self.is_interleave(s1, i + <span class="number">1</span>, s2, j, s3, memo)</span><br><span class="line">            <span class="keyword">if</span> s2[j] == s3[i + j]:</span><br><span class="line">                res |= self.is_interleave(s1, i, s2, j + <span class="number">1</span>, s3, memo)</span><br><span class="line">        memo[i][j] = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="dynamic-programming">Dynamic Programming</h1><p><code>dp[i][j] = true</code> if it is possible to obtain a substring <code>s3[0 .. i + j - 1]</code> by some interleaving of substring <code>s1[0 .. i - 1]</code> and <code>s2[0 .. j - 1]</code>.</p><p>Base case: <code>dp[0][0] = true</code>.</p><p>Induction rules:</p><p>For filling in the entry of <code>dp[i][j]</code>, we need to consider three cases:</p><ul><li>If <code>s3[i + j - 1] == s1[i - 1]</code>, the <code>s3[0 .. i + j - 2]</code> may formed by <code>s1[0 .. i - 2]</code> and <code>s2[0 .. j - 1]</code>. i.e. <code>dp[i][j] = dp[i - 1][j]</code>.</li><li>If <code>s3[i + j - 1] == s2[j - 1]</code>, similarily, <code>dp[i][j] = dp[i][j - 1]</code>.</li><li>If either, <code>s3[0 .. i + j - 1]</code> can't be formed by <code>s1[0 .. i - 1]</code> and <code>s2[0 .. j - 1]</code>. i.e. <code>dp[i][j] = false</code>.</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(mn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isInterleave</span><span class="params">(self, s1: str, s2: str, s3: str)</span> -&gt; bool:</span></span><br><span class="line">        m, n = len(s1), len(s2)</span><br><span class="line">        <span class="keyword">if</span> m + n != len(s3):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        dp = [[<span class="literal">False</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i == j == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">elif</span> i == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>] <span class="keyword">and</span> s2[j - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">elif</span> j == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] <span class="keyword">and</span> s1[i - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = (dp[i][j - <span class="number">1</span>] <span class="keyword">and</span> s2[j - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>]) <span class="keyword">or</span> \</span><br><span class="line">                               (dp[i - <span class="number">1</span>][j] <span class="keyword">and</span> s1[i - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isInterleave</span><span class="params">(self, s1: str, s2: str, s3: str)</span> -&gt; bool:</span></span><br><span class="line">        m, n = len(s1), len(s2)</span><br><span class="line">        <span class="keyword">if</span> m + n != len(s3):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        dp = [<span class="literal">False</span>] * (n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i == j == <span class="number">0</span>:</span><br><span class="line">                    dp[j] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">elif</span> i == <span class="number">0</span>:</span><br><span class="line">                    dp[j] = dp[j - <span class="number">1</span>] <span class="keyword">and</span> s2[j - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">elif</span> j == <span class="number">0</span>:</span><br><span class="line">                    dp[j] = dp[j] <span class="keyword">and</span> s1[i - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[j] = (dp[j - <span class="number">1</span>] <span class="keyword">and</span> s2[j - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>]) <span class="keyword">or</span> \</span><br><span class="line">                            (dp[j] <span class="keyword">and</span> s1[i - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> recursion </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unique Binary Search Trees</title>
      <link href="/programming/leetcode/unique-binary-search-trees/"/>
      <url>/programming/leetcode/unique-binary-search-trees/</url>
      
        <content type="html"><![CDATA[<h1 id="unique-binary-search-tree">Unique Binary Search Tree</h1><p>Given <em>n</em>, how many structurally unique <strong>BST's</strong> (binary search trees) that store values <em>1 ... n</em>?</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><h2 id="dynamic-programming">Dynamic Programming</h2><p>Let <code>dp[n]</code> denotes the number of unique BST's that store values <code>1 .. n</code>.</p><p>Base case: <code>dp[1] = 1</code>.</p><p>Induction rules:</p><p>Let <code>i</code> be the root node of a BST that store values <code>1 .. n</code>. For <code>i = 1 .. n</code>,</p><ul><li>In left subtree, values <code>1 .. i - 1</code> are stored, have <code>dp[i - 1]</code> unique structures.</li><li>In right subtree, values <code>i + 1 .. n</code> are stored. Number of unique structures is equal to <code>dp[n - i]</code>.</li></ul><a id="more"></a><p>So, we have <code>dp[i - 1] * dp[n - i]</code> unique BST's when <code>i</code> is root node. In particular, we let <code>dp[0] = 1</code>.</p><p>Therefore,</p><p><span class="math display">\[dp[n]=\sum_{i=1}^n \big(dp[i-1]*dp[n-i]\big)\]</span></p><p>e.g.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n = 1, dp[1] = 1</span><br><span class="line">n = 2,</span><br><span class="line">    If 1 is root, we have dp[0] * dp[1] = 1 unique BST.</span><br><span class="line">    If 2 is root, we have dp[1] * dp[0] = 1 unique BST.</span><br><span class="line">n = 3,</span><br><span class="line">    If 1 is root, we have dp[0] * dp[2] = 2 unique BST&apos;s.</span><br><span class="line">    If 2 is root, we have dp[1] * dp[1] = 1 unique BST.</span><br><span class="line">    If 3 is root, we have dp[2] * dp[0] = 2 unique BST&apos;s.</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> nn <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, nn + <span class="number">1</span>):</span><br><span class="line">                dp[nn] += dp[i - <span class="number">1</span>] * dp[nn - i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><h1 id="unique-binary-search-tree-ii">Unique Binary Search Tree II</h1><p>Given an integer <em>n</em>, generate all structurally unique <strong>BST's</strong> (binary search trees) that store values <em>1 ... n</em>.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  1         3     3     2     1</span><br><span class="line">   \       /     /     / \     \</span><br><span class="line">    3     2     1     1   3     2</span><br><span class="line">   /     /       \               \</span><br><span class="line">  2     1         2               3</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="dynamic-programming-1">Dynamic Programming</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n: int)</span> -&gt; list:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        dp = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>].append(<span class="literal">None</span>)</span><br><span class="line">        dp[<span class="number">1</span>].append(TreeNode(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> nn <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, nn + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> left <span class="keyword">in</span> dp[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">for</span> right <span class="keyword">in</span> dp[nn - i]:</span><br><span class="line">                        dp[nn].append(TreeNode(i, left, self.clone_tree(right, i)))</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clone_tree</span><span class="params">(self, node, sift)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        clone = TreeNode(node.val + sift)</span><br><span class="line">        clone.left = self.clone_tree(node.left, sift)</span><br><span class="line">        clone.right = self.clone_tree(node.right, sift)</span><br><span class="line">        <span class="keyword">return</span> clone</span><br></pre></td></tr></table></figure><h2 id="divide-and-conquer">Divide and Conquer</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n: int)</span> -&gt; list:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> self.generateSubtrees(<span class="number">1</span>, n)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateSubtrees</span><span class="params">(self, s, e)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> s &gt; e:</span><br><span class="line">            <span class="keyword">return</span> [<span class="literal">None</span>]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(s, e + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> left <span class="keyword">in</span> self.generateSubtrees(s, i - <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> right <span class="keyword">in</span> self.generateSubtrees(i + <span class="number">1</span>, e):</span><br><span class="line">                    res.append(TreeNode(i, left, right))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> divide and conquer </tag>
            
            <tag> tree </tag>
            
            <tag> leetcode </tag>
            
            <tag> BST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Decode Ways</title>
      <link href="/programming/leetcode/decode-ways/"/>
      <url>/programming/leetcode/decode-ways/</url>
      
        <content type="html"><![CDATA[<p>A message containing letters from <code>A-Z</code> is being encoded to numbers using the follwing mapping:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;A&apos; -&gt; 1</span><br><span class="line">&apos;B&apos; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&apos;Z&apos; -&gt; 26</span><br></pre></td></tr></table></figure><p>Given a <strong>non-empty</strong> string containing only digits, determine the total number of ways to decode it.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;12&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;226&quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p>Example 3:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;606&quot;</span><br><span class="line">Ouput: 0</span><br></pre></td></tr></table></figure><h1 id="dynamic-programming">Dynamic Programming</h1><p>Let <code>dp[i]</code> denotes the number of ways to decode the first <code>i</code> characters <code>s[0 .. i - 1]</code>.</p><a id="more"></a><p>Base cases:</p><ul><li>If <code>s[0] != '0'</code>, <code>dp[1] = 1</code>, only one decode way for one non-zero character.</li><li>If <code>s[0] == '0'</code>, <code>dp[1] = 0</code>.</li></ul><p>Induction rules:</p><p>To compute <code>dp[i]</code>, we define <code>t1 = int(s[i - 1])</code> and <code>t2 = int(s[i - 2:i])</code>.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s      0  ... i-3 i-2 i-1</span><br><span class="line">                      |t1|</span><br><span class="line">                  |  t2  |</span><br><span class="line"></span><br><span class="line">dp  0  1  ... i-2 i-1  i</span><br></pre></td></tr></table></figure><ul><li>If <code>1 &lt;= t1 &lt;= 9</code>, then we can decode <code>t1</code> separately, there are <code>dp[i - 1]</code> ways to decode first <code>i</code> characters.</li><li>If <code>10 &lt;= t2 &lt;= 26</code>, then we can decode <code>t2</code> separately, there are <code>dp[i - 2]</code> ways to decode first <code>i</code> characters.</li></ul><p><code>dp[0]</code> is used when <code>i == 2</code>, let <code>dp[0] = 1</code> is a good idea. Or, give the base cases of <code>i = 1, 2</code>, then start from <code>i = 3</code>.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="number">1</span>, int(s[<span class="number">0</span>] != <span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="number">1</span> &lt;= int(s[i - <span class="number">1</span>]) &lt;= <span class="number">9</span>:</span><br><span class="line">                dp[i] += dp[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="number">10</span> &lt;= int(s[i - <span class="number">2</span>: i]) &lt;= <span class="number">26</span>:</span><br><span class="line">                dp[i] += dp[i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        pre, res = <span class="number">1</span>, int(s[<span class="number">0</span>] != <span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            nxt = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">1</span> &lt;= int(s[i - <span class="number">1</span>]) &lt;= <span class="number">9</span>:</span><br><span class="line">                nxt += res</span><br><span class="line">            <span class="keyword">if</span> <span class="number">10</span> &lt;= int(s[i - <span class="number">2</span>: i]) &lt;= <span class="number">26</span>:</span><br><span class="line">                nxt += pre</span><br><span class="line">            pre = res</span><br><span class="line">            res = nxt</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网格搜索</title>
      <link href="/notes/introduction-to-ml-with-python/grid-search/"/>
      <url>/notes/introduction-to-ml-with-python/grid-search/</url>
      
        <content type="html"><![CDATA[<p>找到一个模型的重要参数（提供最佳泛化性能的参数）的取值是一项棘手的任务，但对于几乎所有模型和数据集来说都是必要的。由于这项任务如此常见，所以 scikit-learn 中有一些标准方法可以帮你完成。最常见的就是<strong>网格搜索</strong>（grid search），它主要指尝试我们关心的参数的所有可能组合。</p><p>考虑一个具有 RBF（径向基函数）核的核 SVM 的例子，它在 SVC 类中实现。它有 2 个重要参数：核宽度 gamma 核正则化参数 C。假设我们希望尝试 C 的取值为 0.001、0.01、0.1、1、10 和 100，gamma 也取这 6 个值，所以总共有 36 种参数组合。</p><a id="more"></a><h1 id="简单网格搜索">简单网格搜索</h1><p>我们可以实现一个简单的网格搜索，在 2 个参数上使用 for 循环，对每种参数组合分别训练并评估一个分类器。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 简单的网格搜索实现</span></span><br><span class="line">iris = load_iris()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">    iris.data, iris.target, random_state=<span class="number">0</span>)</span><br><span class="line">print(<span class="string">'Size of training set: &#123;&#125;  size of test set: &#123;&#125;'</span>.format(</span><br><span class="line">    X_train.shape[<span class="number">0</span>], X_test.shape[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">best_score = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> gamma <span class="keyword">in</span> [<span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>]:</span><br><span class="line">    <span class="keyword">for</span> C <span class="keyword">in</span> [<span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>]:</span><br><span class="line">        <span class="comment"># 对每种参数组合都训练一个SVC</span></span><br><span class="line">        svm = SVC(gamma=gamma, C=C)</span><br><span class="line">        svm.fit(X_train, y_train)</span><br><span class="line">        <span class="comment"># 在测试集上评估SVC</span></span><br><span class="line">        score = svm.score(X_test, y_test)</span><br><span class="line">        <span class="keyword">if</span> score &gt; best_score:</span><br><span class="line">            best_score = score</span><br><span class="line">            best_parameters = &#123;<span class="string">'C'</span>: C, <span class="string">'gamma'</span>: gamma&#125;</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Best score: &#123;:.2f&#125;'</span>.format(best_score))</span><br><span class="line">print(<span class="string">'Best parameters: &#123;&#125;'</span>.format(best_parameters))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Size of training set: 112  size of test set: 38</span><br><span class="line">Best score: 0.97</span><br><span class="line">Best parameters: &#123;&apos;C&apos;: 100, &apos;gamma&apos;: 0.001&#125;</span><br></pre></td></tr></table></figure><h1 id="参数过拟合的风险与验证集">参数过拟合的风险与验证集</h1><p>看到这个结果，我们可能忍不住要报告，我们找到了一个在数据集上精度达到 97% 的模型。然而，这种说法可能过于乐观了（或者就是错误的），其原因如下：我们尝试了许多不同的参数，并选择了在测试集上精度最高的那个，但这个精度不一定能推广到新数据上。<strong>由于我们使用测试数据进行调参，所以不能再用它来评估模型的好坏。</strong>我们最开始需要将数据划分为训练集和测试集也是因为这个原因。<strong>我们需要一个独立的数据集来进行评估，一个在创建模型时没有用到的数据集。</strong></p><p>为了解决这个问题，一种方法是再次划分数据，这样我们得到了 3 个数据集：用于构建模型的训练集，用于选择模型的验证集（开发集），用于评估所选参数性能的测试集。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_threefold_split()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/threefold-split.png"></p><p><strong>利用验证集选定最佳参数之后，我们可以找到的参数设置重新构建一个模型，但是要同时在训练数据和验证数据上进行训练。</strong>这样我们可以利用尽可能多的数据来构建模型。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将数据划分为训练+验证集与测试集</span></span><br><span class="line">X_trainval, X_test, y_trainval, y_test = train_test_split(</span><br><span class="line">    iris.data, iris.target, random_state=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 将训练+验证集划分为训练集和验证集</span></span><br><span class="line">X_train, X_valid, y_train, y_valid = train_test_split(</span><br><span class="line">    X_trainval, y_trainval, random_state=<span class="number">1</span>)</span><br><span class="line">print(<span class="string">'Size of training set: &#123;&#125;  size of validation set: &#123;&#125;  size of test set: &#123;&#125;'</span>.format(</span><br><span class="line">    X_train.shape[<span class="number">0</span>], X_valid.shape[<span class="number">0</span>], X_test.shape[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">best_score = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> gamma <span class="keyword">in</span> [<span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>]:</span><br><span class="line">    <span class="keyword">for</span> C <span class="keyword">in</span> [<span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>]:</span><br><span class="line">        <span class="comment"># 对每种参数组合都训练一个SVC</span></span><br><span class="line">        svm = SVC(gamma=gamma, C=C)</span><br><span class="line">        svm.fit(X_train, y_train)</span><br><span class="line">        <span class="comment"># 在测试集上评估SVC</span></span><br><span class="line">        score = svm.score(X_valid, y_valid)</span><br><span class="line">        <span class="keyword">if</span> score &gt; best_score:</span><br><span class="line">            best_score = score</span><br><span class="line">            best_parameters = &#123;<span class="string">'C'</span>: C, <span class="string">'gamma'</span>: gamma&#125;</span><br><span class="line"><span class="comment"># 在训练+验证集上重新构建一个模型，并在测试集上进行评估</span></span><br><span class="line">svm = SVC(**best_parameters)</span><br><span class="line">svm.fit(X_trainval, y_trainval)</span><br><span class="line">test_score = svm.score(X_test, y_test)</span><br><span class="line">print(<span class="string">'Best score on validation set: &#123;:.2f&#125;'</span>.format(best_score))</span><br><span class="line">print(<span class="string">'Best parameters: &#123;&#125;'</span>.format(best_parameters))</span><br><span class="line">print(<span class="string">'Test set score with best parameters: &#123;:.2f&#125;'</span>.format(test_score))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Size of training set: 84  size of validation set: 28  size of test set: 38</span><br><span class="line">Best score on validation set: 0.96</span><br><span class="line">Best parameters: &#123;&apos;C&apos;: 10, &apos;gamma&apos;: 0.001&#125;</span><br><span class="line">Test set score with best parameters: 0.92</span><br></pre></td></tr></table></figure><p>验证集上的最高分数是 96%，这比之前略低，可能是因为我们使用了更少的数据来训练模型。测试集上的分数更低，为 92%。因此，我们只能声称对 92% 的新数据正确分类，而不是我们之前认为的 97%。</p><p>训练集、验证集和测试集之间的区别对于在实践中应用机器学习方法至关重要。任何根据测试集精度所做的选择都会将测试集的信息“泄漏”（leak）到模型中。因此，<strong>保留一个单独的测试集是很重要的，它仅用于最终评估。</strong>严格来说，在测试集上对不止一个模型进行评估并选择更好的那个，将会导致对模型精度过于乐观的估计。</p><h1 id="带交叉验证的网格搜索">带交叉验证的网格搜索</h1><p>虽然将数据划分为训练集、验证集和测试集的方法是可行的，也相对常用，但这种方法对数据的划分方法相当敏感。为了得到对泛化性能的更好估计，我们可以使用交叉验证来评估每种参数组合的性能，而不是仅将数据单次划分为训练集与验证集。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> gamma <span class="keyword">in</span> [<span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>]:</span><br><span class="line">    <span class="keyword">for</span> C <span class="keyword">in</span> [<span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>]:</span><br><span class="line">        <span class="comment"># 对每种参数组合都训练一个SVC</span></span><br><span class="line">        svm = SVC(gamma=gamma, C=C)</span><br><span class="line">        svm.fit(X_train, y_train)</span><br><span class="line">        <span class="comment"># 执行交叉验证</span></span><br><span class="line">        scores = cross_val_score(svm, X_trainval, y_trainval, cv=<span class="number">5</span>)</span><br><span class="line">        <span class="comment"># 计算交叉验证的平均精度</span></span><br><span class="line">        score = np.mean(scores)</span><br><span class="line">        <span class="keyword">if</span> score &gt; best_score:</span><br><span class="line">            best_score = score</span><br><span class="line">            best_parameters = &#123;<span class="string">'C'</span>: C, <span class="string">'gamma'</span>: gamma&#125;</span><br><span class="line"><span class="comment"># 在训练+验证集上重新构建一个模型，并在测试集上进行评估</span></span><br><span class="line">svm = SVC(**best_parameters)</span><br><span class="line">svm.fit(X_trainval, y_trainval)</span><br></pre></td></tr></table></figure><p>要想使用 5 折交叉验证对 C 和 gamma 特定取值的 SVM 的精度进行评估，需要训练 36 x 5 = 180 个模型。你可以想象，使用交叉验证的主要缺点就是训练所有这些模型所需花费的时间。</p><p>下面的可视化说明了上述代码如何选择最佳参数设置。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_cross_val_selection()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/cross-val-grid-search.png"></p><p>对于每种参数设置（图中仅显示了一部分），需要计算 5 个精度值，交叉验证的每次划分都要计算一个精度值。然后，对每种参数设置计算平均验证精度。最后，选择平均验证精度最高的参数，用圆圈标记。</p><blockquote><p>交叉验证是在特定数据集上对给定模型进行评估的一种方法。但它通常与网格搜索等参数搜索方法结合使用。因此，许多人使用<strong>交叉验证</strong>（cross-validation）这一术语来通俗地指代带交叉验证的网格搜索。</p></blockquote><p>由于带交叉验证的网格搜索是一种常用的调参方法，因此 scikit-learn 提供了 GridSearchCV 类，它以估计器（estimator）的形式实现了这种方法。要使用 GridSearchCV 类，你首先需要用一个字典指定要搜索的参数。然后 GridSearchCV 会执行所有必要的模型拟合。字典的键是我们要调节的参数名称，字典的值是我们想要尝试的参数设置。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果 C 和 gamma 想要尝试的取值为 0.001、0.01、0.1、1、10 和 100</span></span><br><span class="line"><span class="comment"># 可以将其转化为下面这个字典</span></span><br><span class="line">param_grid = &#123;<span class="string">'C'</span>: [<span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>],</span><br><span class="line">              <span class="string">'gamma'</span>: [<span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="comment"># 将 GridSearchCV 实例化</span></span><br><span class="line">grid_search = GridSearchCV(SVC(), param_grid, cv=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># GridSearchCV 将使用交叉验证来代替之前的划分训练集和验证集方法</span></span><br><span class="line"><span class="comment"># 但是，我们仍需要将数据划分为训练集和测试集，以避免参数过拟合</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">    iris.data, iris.target, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建的 grid_search 对象的行为就像一个分类器</span></span><br><span class="line"><span class="comment"># 我们可以对它调用标准的 fit、predict 和 score 方法</span></span><br><span class="line"><span class="comment"># 但我们在调用 fit 时，它会对 param_grid 指定的每种参数组合都运行交叉验证</span></span><br><span class="line">grid_search.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拟合 GridSearchCV 对象不仅会搜索最佳参数，还会利用得到的最佳参数在整个</span></span><br><span class="line"><span class="comment"># 训练数据集上自动拟合一个新模型</span></span><br><span class="line"><span class="comment"># GridSearchCV 类提供了非常方便的接口，可以用 predict 和 score 方法来访问</span></span><br><span class="line"><span class="comment"># 重新训练过的模型</span></span><br><span class="line"><span class="comment"># 为了评估找到的最佳参数的泛化能力，我们可以在测试集上调用 score</span></span><br><span class="line">print(<span class="string">'Test set score: &#123;:.2f&#125;'</span>.format(grid_search.score(X_test, y_test)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们找到的参数保存在 best_params_ 属性中，而交叉验证最佳精度保存在 best_score_ 中</span></span><br><span class="line">print(<span class="string">'Best parameters: &#123;&#125;'</span>.format(grid_search.best_params_))</span><br><span class="line">print(<span class="string">'Best cross-validation score: &#123;:.2f&#125;'</span>.format(grid_search.best_score_))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 能够访问实际找到的模型，这有时是很有帮助的，比如查看系数或特征重要性</span></span><br><span class="line"><span class="comment"># 你可以用 best_estimator_ 属性来访问最佳参数对应的模型</span></span><br><span class="line"><span class="comment"># 由于 grid_search 本身具有 predict 和 score 方法</span></span><br><span class="line"><span class="comment"># 所以不需要使用 best_estimator_ 来进行预测和评估模型</span></span><br><span class="line">print(<span class="string">'Best estimator:\n&#123;&#125;'</span>.format(grid_search.best_estimator_))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test set score: 0.97</span><br><span class="line">Best parameters: &#123;&apos;C&apos;: 100, &apos;gamma&apos;: 0.01&#125;</span><br><span class="line">Best cross-validation score: 0.97</span><br><span class="line">Best estimator:</span><br><span class="line">SVC(C=100, cache_size=200, class_weight=None, coef0=0.0,</span><br><span class="line">    decision_function_shape=&apos;ovr&apos;, degree=3, gamma=0.01, kernel=&apos;rbf&apos;,</span><br><span class="line">    max_iter=-1, probability=False, random_state=None, shrinking=True,</span><br><span class="line">    tol=0.001, verbose=False)</span><br></pre></td></tr></table></figure><p>利用交叉验证选择参数，我们实际上找到了一个在测试集上精度为 97% 的模型。重要的是，我们<strong>没有使用测试集</strong>在选择参数。</p><p>注意不要将 <code>best_score_</code> 与 模型在测试集上调用 <code>score</code> 方法计算得到的泛化性能弄混。使用 <code>score</code> 方法（或者对 <code>predict</code> 方法的输出结果进行评估）采用的是<strong>在整个训练集上</strong>训练的模型。而 <code>best_score_</code> 属性保存的是交叉验证的平均精度，是<strong>在训练集上进行交叉验证</strong>得到的。</p><h2 id="分析交叉验证的结果">分析交叉验证的结果</h2><p>将交叉验证的结果可视化通常有助于理解模型泛化能力对所搜索参数的依赖关系。由于运行网格搜索的计算成本相当高，所以通常最好从相对比较稀疏且较小的网格开始搜索。然后我们可以检查交叉验证网格搜索的结果，可能也会扩展搜索范围。网格搜索的结果可以在 <code>cv_results_</code> 属性中找到，它是一个字典，其中保存了搜索的所有内容。它里面包含许多细节，最好将其转换成 pandas 数据框后查看：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">results = pd.DataFrame(grid_search.cv_results_)</span><br><span class="line"><span class="comment"># 显示前 5 行</span></span><br><span class="line">display(results.head())</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   mean_fit_time  std_fit_time  ...  std_test_score  rank_test_score</span><br><span class="line">0       0.000551      0.000136  ...        0.011371               22</span><br><span class="line">1       0.000453      0.000039  ...        0.011371               22</span><br><span class="line">2       0.000471      0.000039  ...        0.011371               22</span><br><span class="line">3       0.000438      0.000004  ...        0.011371               22</span><br><span class="line">4       0.000459      0.000028  ...        0.011371               22</span><br><span class="line"></span><br><span class="line">[5 rows x 15 columns]</span><br></pre></td></tr></table></figure><p>results 中每一行对应一种特定的参数设置。对于每种参数设置，交叉验证所有划分的结果都被记录下来，所有划分的平均值和标准差也被记录下来。由于我们搜索的是一个二维参数网格（C 和 gamma），所以最适合用热图可视化。我们首先提取平均验证分数，然后改变分数数组的形状，使其坐标轴分别对应于 C 和 gamma：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scores = np.array(results.mean_test_score).reshape(<span class="number">6</span>, <span class="number">6</span>)</span><br><span class="line"><span class="comment"># 对交叉验证平均分数作图</span></span><br><span class="line">mglearn.tools.heatmap(scores, xlabel=<span class="string">'gamma'</span>, xticklabels=param_grid[<span class="string">'gamma'</span>],</span><br><span class="line">    ylabel=<span class="string">'C'</span>, yticklabels=param_grid[<span class="string">'C'</span>], cmap=<span class="string">'viridis'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/grid-search-heatmap.png"></p><p>你可以看到，SVC 对参数设置非常敏感。对于许多种参数设置，精度都在 40% 左右，这是非常糟糕的；对于其他参数设置，精度约为 96%。我们可以从这张图中看出以下几点。首先，我们调节的参数对于获得良好的性能<strong>非常重要</strong>。这两个参数 都很重要，因为调节它们可以将精度从 40% 提高到 96%。此外，在我们选择的参数范围中也可以看到输出发生了显著的变化。同样重要的是要注意，参数的范围要足够大：每个参数的最佳取值不能位于图像的边界上。</p><p>下面我们来看几张图，其结果不那么理想，因为选择的搜索范围不合适。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">fig, axes = plt.subplots(<span class="number">1</span>, <span class="number">3</span>, figsize=(<span class="number">13</span>, <span class="number">5</span>))</span><br><span class="line">param_grid_linear = &#123;<span class="string">'C'</span>: np.linspace(<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>),</span><br><span class="line">                     <span class="string">'gamma'</span>: np.linspace(<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>)&#125;</span><br><span class="line"></span><br><span class="line">param_grid_one_log = &#123;<span class="string">'C'</span>: np.linspace(<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>),</span><br><span class="line">                     <span class="string">'gamma'</span>: np.logspace(<span class="number">-3</span>, <span class="number">2</span>, <span class="number">6</span>)&#125;</span><br><span class="line"></span><br><span class="line">param_grid_range = &#123;<span class="string">'C'</span>: np.logspace(<span class="number">-3</span>, <span class="number">2</span>, <span class="number">6</span>),</span><br><span class="line">                     <span class="string">'gamma'</span>: np.logspace(<span class="number">-7</span>, <span class="number">-2</span>, <span class="number">6</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> param_grid, ax <span class="keyword">in</span> zip([param_grid_linear, param_grid_one_log, </span><br><span class="line">                           param_grid_range], axes):</span><br><span class="line">    grid_search = GridSearchCV(SVC(), param_grid, cv=<span class="number">5</span>)</span><br><span class="line">    grid_search.fit(X_train, y_train)</span><br><span class="line">    scores = grid_search.cv_results_[<span class="string">'mean_test_score'</span>].reshape(<span class="number">6</span>, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    scores_image = mglearn.tools.heatmap(scores, xlabel=<span class="string">'gamma'</span>,</span><br><span class="line">        ylabel=<span class="string">'C'</span>, xticklabels=param_grid[<span class="string">'gamma'</span>],</span><br><span class="line">        yticklabels=param_grid[<span class="string">'C'</span>], cmap=<span class="string">'viridis'</span>, ax=ax)</span><br><span class="line"></span><br><span class="line">plt.colorbar(scores_image, ax=axes.tolist())</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/grid-search-heatmaps.png"></p><p>第一张图没有显示任何变化。在这种情况下，这是由参数 C 和 gamma 不正确的缩放以及不正确的范围造成的。但如果对于不同的参数设置都看不到精度的变化，也可能是因为这个参数根本不重要。<strong>通常最好在开始时尝试非常极端的值，以观察改变参数是否会导致精度发生变化。</strong></p><p>第二张图显示的是垂直条形模式。这表示只有 gamma 的设置对精度有影响。这可能意味着 gamma 参数的搜索范围是我们所关心的，而 C 参数并不是——也可能意味着 C 参数并不重要。</p><p>第三张图中 C 和 gamma 对应的精度都有变化。但可以看到，在图像的整个左下角都没有发生什么有趣的事情。我们在后面的网格搜索中可以不考虑非常小的值。最佳参数设置出现在右上角。由于最佳参数位于图像的边界，所以我们可以认为，在这个边界之外可能还有更好的取值，我们可能希望改变搜索范围以包含这一区域内的更多参数。</p><p>基于交叉验证分数来调节参数网格是非常好的，也是探索不同参数的重要性的好方法。但是，你不应该在最终测试集上测试不同的参数范围（在验证集上进行调参）——只有确切知道了想要使用的模型，才能对测试集进行评估（在测试集上进行评估）。</p><h2 id="在非网格的空间中搜索">在非网格的空间中搜索</h2><p>在某些情况下，尝试所有参数的所有可能组合并不是一个好主意。例如，SVC 有一个 kernel 参数，根据所选择的 kernel（内核），其他参数也是与之相关的。如果 <code>kernel='linear'</code>，那么模型是线性的，只会用到 C 参数。如果 <code>kernel='rbf'</code>，则需要使用 C 和 gamma 两个参数（但用不到类似 degree 的其他参数）。在这种情况下，搜索 C、gamma 和 kernel 所有可能的组合没有意义：如果 <code>kernel='linear'</code>，那么 gamma 是用不到的，尝试 gamma 的不同取值将会浪费时间。为了处理这种“条件”（conditional）参数，GridSearchCV 的 <code>param_grid</code> 可以是字典组成的列表。列表中每个字典可扩展为一个独立的网格。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">param_grid = [&#123;<span class="string">'kernel'</span>: [<span class="string">'rbf'</span>],  <span class="comment"># kernel 是一个长度为 1 的列表</span></span><br><span class="line">               <span class="string">'C'</span>: [<span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>],</span><br><span class="line">               <span class="string">'gamma'</span>: [<span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>]&#125;,</span><br><span class="line">              &#123;<span class="string">'kernel'</span>: [<span class="string">'linear'</span>],</span><br><span class="line">               <span class="string">'C'</span>: [<span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>]&#125;]</span><br><span class="line">grid_search = GridSearchCV(SVC(), param_grid, cv=<span class="number">5</span>)</span><br><span class="line">grid_search.fit(X_train, y_train)</span><br><span class="line">print(<span class="string">'Best parameters: &#123;&#125;'</span>.format(grid_search.best_params_))</span><br><span class="line">print(<span class="string">'Best cross-validation score: &#123;:.2f&#125;'</span>.format(grid_search.best_score_))</span><br><span class="line"></span><br><span class="line">results = pd.DataFrame(grid_search.cv_results_)</span><br><span class="line"><span class="comment"># 再次查看 cv_results_，如果 kernel='linear'，那么只有 C 是变化的</span></span><br><span class="line">display(results.T)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Best parameters: &#123;&apos;C&apos;: 100, &apos;gamma&apos;: 0.01, &apos;kernel&apos;: &apos;rbf&apos;&#125;</span><br><span class="line">Best cross-validation score: 0.97</span><br><span class="line">                                                               0  ...                              41</span><br><span class="line">mean_fit_time                                        0.000518799  ...                     0.000275612</span><br><span class="line">std_fit_time                                         8.65673e-05  ...                     1.92715e-05</span><br><span class="line">mean_score_time                                      0.000243187  ...                     0.000154543</span><br><span class="line">std_score_time                                       5.89067e-05  ...                     1.61281e-06</span><br><span class="line">param_C                                                    0.001  ...                             100</span><br><span class="line">param_gamma                                                0.001  ...                             NaN</span><br><span class="line">param_kernel                                                 rbf  ...                          linear</span><br><span class="line">params             &#123;&apos;C&apos;: 0.001, &apos;gamma&apos;: 0.001, &apos;kernel&apos;: &apos;rbf&apos;&#125;  ...  &#123;&apos;C&apos;: 100, &apos;kernel&apos;: &apos;linear&apos;&#125;</span><br><span class="line">split0_test_score                                          0.375  ...                        0.958333</span><br><span class="line">split1_test_score                                       0.347826  ...                               1</span><br><span class="line">split2_test_score                                       0.363636  ...                               1</span><br><span class="line">split3_test_score                                       0.363636  ...                        0.909091</span><br><span class="line">split4_test_score                                       0.380952  ...                        0.952381</span><br><span class="line">mean_test_score                                         0.366071  ...                        0.964286</span><br><span class="line">std_test_score                                         0.0113708  ...                       0.0338387</span><br><span class="line">rank_test_score                                               27  ...                               3</span><br><span class="line"></span><br><span class="line">[16 rows x 42 columns]</span><br></pre></td></tr></table></figure><h2 id="使用不同的交叉验证策略进行网格搜索">使用不同的交叉验证策略进行网格搜索</h2><p>与 <code>cross_val_score</code> 类似，GridSearchCV 对分类问题默认使用分层 <span class="math inline">\(k\)</span> 折交叉验证，对回归问题默认使用 <span class="math inline">\(k\)</span> 折交叉验证。但是，你可以传入任何交叉验证分离器作为 GridSearchCV 的 cv 参数。特别地，如果只想将数据单词划分为训练集和验证集，你可以使用 ShuffleSplit 或 StratifiedShuffleSplit，并设置 <code>n_iter=1</code>。这对于非常大的数据集或非常慢的模型可能会有帮助。</p><h3 id="嵌套交叉验证">嵌套交叉验证</h3><p>前面在使用 GridSearchCV 时，我们仍然将数据单次划分为训练集和测试集，这可能会导致结果不稳定，也让我们过于依赖数据的此次划分。我们可以再深入一点，不是只将原始数据一次划分为训练集和测试集，而是使用交叉验证进行多次划分，这就是所谓的<strong>嵌套交叉验证</strong>（nested cross-validation）。在嵌套交叉验证中，有一个外层循环，遍历将数据划分为训练集和测试集的所有划分。对于每种划分都运行一次网格搜索（对于外层循环的每种划分可能会得到不同的最佳参数）。然后，对于每种外层划分，利用最佳参数设置计算得到测试集分数。</p><p>这一过程的结果是由分数组成的列表——不是一个模型，也不是一种参数设置。这些分数告诉我们在网格找到的最佳参数下模型的泛化能力好坏。<strong>由于嵌套交叉验证不提供可用于新数据的模型，所以在寻找可用于未来数据的预测模型时很少用到它。</strong>但是，它对于评估给定模型在特定数据集上的效果很有用。</p><p>在 scikit-learn 中实现嵌套交叉验证很简单。我们调用 <code>cross_val_score</code>，并用 GridSearchCV 的一个实例作为模型：</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.model_selection.parametergrid#sklearn.model_selection.ParameterGrid" target="_blank" rel="noopener"><code>class sklearn.model_selection.ParameterGrid(param_grid)</code></a></p><p>Grid of parameters with a discrete number of values for each.</p><p>Can be used to iterate over parameter value combinations with the Python built-in function iter.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> ParameterGrid</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>param_grid = &#123;<span class="string">'a'</span>: [<span class="number">1</span>, <span class="number">2</span>], <span class="string">'b'</span>: [<span class="literal">True</span>, <span class="literal">False</span>]&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(ParameterGrid(param_grid)) == (</span><br><span class="line"><span class="meta">... </span>   [&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="literal">True</span>&#125;, &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="literal">False</span>&#125;,</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">'a'</span>: <span class="number">2</span>, <span class="string">'b'</span>: <span class="literal">True</span>&#125;, &#123;<span class="string">'a'</span>: <span class="number">2</span>, <span class="string">'b'</span>: <span class="literal">False</span>&#125;])</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">param_grid = &#123;<span class="string">'C'</span>: [<span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>],</span><br><span class="line">              <span class="string">'gamma'</span>: [<span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>]&#125;</span><br><span class="line"></span><br><span class="line">scores = cross_val_score(GridSearchCV(SVC(), param_grid, cv=<span class="number">5</span>),</span><br><span class="line">                         iris.data, iris.target, cv=<span class="number">5</span>)</span><br><span class="line">print(<span class="string">'Cross-validation scores:'</span>, scores)</span><br><span class="line">print(<span class="string">'Mean cross-validation score:'</span>, scores.mean())</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cross-validation scores: [0.96666667 1.         0.96666667 0.96666667 1.        ]</span><br><span class="line">Mean cross-validation score: 0.9800000000000001</span><br></pre></td></tr></table></figure><p>嵌套交叉验证的结果可以总结为 “SVC 在 iris 数据集上的交叉验证平均精度为 98%”——不多也不少（与上一个结果大致相同）。</p><p>这里我们在内层循环和外层循环中都使用了分层 5 折交叉验证。由于 <code>param_grid</code> 包含 36 中参数组合，所以需要构建 36 x 5 x 5 = 900 个模型，导致嵌套交叉验证过程的代价很高。这里我们在内层循环和外层循环中使用相同的交叉验证分离器，但这不是必需的，你可以在内层循环和外层循环中使用交叉验证策略的任意组合。理解上面单行代码的内容可能有点困难，将其展开为 for 循环可能会有所帮助，正如我么在下面这个简化的实现中所做的那样：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> StratifiedKFold, ParameterGrid</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nested_cv</span><span class="params">(X, y, inner_cv, outer_cv, Classifier, parameter_grid)</span>:</span></span><br><span class="line">    outer_scores = []</span><br><span class="line">    <span class="comment"># 对于外层交叉验证的每次数据划分，split方法返回索引值</span></span><br><span class="line">    <span class="keyword">for</span> training_samples, test_samples <span class="keyword">in</span> outer_cv.split(X, y):</span><br><span class="line">        <span class="comment"># 利用内层交叉验证找到最佳参数</span></span><br><span class="line">        best_params = &#123;&#125;</span><br><span class="line">        best_score = -np.inf</span><br><span class="line">        <span class="comment"># 遍历参数</span></span><br><span class="line">        <span class="keyword">for</span> parameters <span class="keyword">in</span> parameter_grid:</span><br><span class="line">            <span class="comment"># 在内层划分中累加分数</span></span><br><span class="line">            cv_scores = []</span><br><span class="line">            <span class="comment"># 遍历内层交叉验证</span></span><br><span class="line">            <span class="keyword">for</span> inner_train, inner_test <span class="keyword">in</span> inner_cv.split(X[training_samples], y[training_samples]):</span><br><span class="line">                <span class="comment"># 对于给定的参数和训练数据来构建分类器</span></span><br><span class="line">                clf = Classifier(**parameters)</span><br><span class="line">                clf.fit(X[inner_train], y[inner_train])</span><br><span class="line">                <span class="comment"># 在内层测试集上进行评估</span></span><br><span class="line">                score = clf.score(X[inner_test], y[inner_test])</span><br><span class="line">                cv_scores.append(score)</span><br><span class="line">            <span class="comment"># 计算内层交叉验证的平均分数</span></span><br><span class="line">            mean_score = np.mean(cv_scores)</span><br><span class="line">            <span class="keyword">if</span> mean_score &gt; best_score:</span><br><span class="line">                best_score = mean_score</span><br><span class="line">                best_params = parameters</span><br><span class="line">        <span class="comment"># 利用外层训练集和最佳参数来构建模型</span></span><br><span class="line">        clf = Classifier(**best_params)</span><br><span class="line">        clf.fit(X[training_samples], y[training_samples])</span><br><span class="line">        <span class="comment"># 评估模型</span></span><br><span class="line">        outer_scores.append(clf.score(X[test_samples], y[test_samples]))</span><br><span class="line">    <span class="keyword">return</span> np.array(outer_scores)</span><br><span class="line"></span><br><span class="line">scores = nested_cv(iris.data, iris.target, StratifiedKFold(<span class="number">5</span>),</span><br><span class="line">    StratifiedKFold(<span class="number">5</span>), SVC, ParameterGrid(param_grid))</span><br><span class="line">print(<span class="string">'Cross-validation scores:'</span>, scores)</span><br><span class="line">print(<span class="string">'Mean cross-validation score:'</span>, scores.mean())</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cross-validation scores: [0.96666667 1.         0.96666667 0.96666667 1.        ]</span><br><span class="line">Mean cross-validation score: 0.9800000000000001</span><br></pre></td></tr></table></figure><h3 id="交叉验证与网格搜索并行">交叉验证与网格搜索并行</h3><p>虽然在许多参数上运行网格搜索和在大型数据集上运行网格搜索的计算量可能很大，但令人尴尬的是，这些计算都是<strong>并行的</strong>（parallel）。这也就是说，在一种交叉验证划分下使用特定参数设置来构建一个模型，与利用其他参数的模型是完全独立的。这使得网格搜索与交叉验证成为多个 CPU 内核或集群上并行化的理想选择。你可以将 <code>n_jobs</code> 参数设置为你想使用的 CPU 内核数量，从而在 GridSearchCV 和 <code>cross_val_score</code> 中使用多个内核。你可以设置 <code>n_jobs=-1</code> 来使用所有可用的内核。</p><p>你应该知道，<strong>scikit-learn 不允许并行操作的嵌套</strong>。因此，如果你在模型（比如随机森林）中使用了 <code>n_jobs</code> 选项，那么就不能在 GridSearchCV 使用它来搜索这个模型。如果你的数据集和模型都非常大，那么使用多个内核可能会占用大量内存，你应该在并行构建大型模型时监视内存的使用情况。</p><p>还可以在集群内的多台机器上并行运行网格搜索和交叉验证。对于 Spark 用户，可以使用 spark-sklearn 包，它允许在已经建立好的 Spark 集群上运行网格搜索。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Machine Learning with Python </tag>
            
            <tag> grid search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scramble String</title>
      <link href="/programming/leetcode/scramble-string/"/>
      <url>/programming/leetcode/scramble-string/</url>
      
        <content type="html"><![CDATA[<p>Given a string <code>s1</code>, we may represent it as a binary tree by partitioning it to <strong>two non-empty substrings</strong> recursively.</p><p>Below is one possible representation of <code>s1 = great</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    great</span><br><span class="line">   /     \</span><br><span class="line">  gr     eat</span><br><span class="line"> / \     /  \</span><br><span class="line">g   r   e   at</span><br><span class="line">           /  \</span><br><span class="line">          a    t</span><br></pre></td></tr></table></figure><p>To scramble the string, we may choose any non-leaf node and swap its two children.</p><p>For example, if we choose the node <code>&quot;gr&quot;</code> and swap its two children, it produces a scrambled string <code>&quot;rgeat&quot;</code>.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    rgeat</span><br><span class="line">   /     \</span><br><span class="line">  rg     eat</span><br><span class="line"> / \     /  \</span><br><span class="line">r   g   e   at</span><br><span class="line">           /  \</span><br><span class="line">          a    t</span><br></pre></td></tr></table></figure><p>We say that <code>&quot;rgeat&quot;</code> is a scrambled string of <code>&quot;great&quot;</code>.</p><a id="more"></a><p>Similarly, if we continue to swap the children of nodes <code>&quot;eat&quot;</code> and <code>&quot;at&quot;</code>, it produces a scrambled string <code>&quot;rgtae&quot;</code>.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    rgtae</span><br><span class="line">   /     \</span><br><span class="line">  rg     tae</span><br><span class="line"> / \     /  \</span><br><span class="line">r   g   ta   e</span><br><span class="line">       /  \</span><br><span class="line">      t    a</span><br></pre></td></tr></table></figure><p>We say that <code>&quot;rgtae&quot;</code> is a scrambled string of <code>&quot;great&quot;</code>.</p><p>Given two strings <code>s1</code> and <code>s2</code> of the same length, determine if <code>s2</code> is a scrambled string of <code>s1</code>.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s1 = &quot;great&quot;, s2 = &quot;rgeat&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s1 = &quot;abcde&quot;, s2 = &quot;caebd&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> String can be partitioned at ANY position. But can only be partitioned (maybe) once.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e.g. s1 = &quot;abcde&quot;, s2 = &quot;bcade&quot;, s3 = &quot;bcead&quot;</span><br><span class="line"></span><br><span class="line">s2 is a scramble of s1</span><br><span class="line"></span><br><span class="line">        abcde</span><br><span class="line">       /     \</span><br><span class="line">      abc     de</span><br><span class="line">     /  \    /  \</span><br><span class="line">    a   bc  d    e</span><br><span class="line">       /  \</span><br><span class="line">      b    c</span><br><span class="line"></span><br><span class="line">    swap &quot;a&quot; and &quot;bc&quot;</span><br><span class="line"></span><br><span class="line">          bcade</span><br><span class="line">         /     \</span><br><span class="line">        bca     de</span><br><span class="line">       /  \    /  \</span><br><span class="line">      bc   a  d    e</span><br><span class="line">     /  \</span><br><span class="line">    b    c</span><br><span class="line"></span><br><span class="line">s3 is a scramble of s2</span><br><span class="line"></span><br><span class="line">        bcade</span><br><span class="line">       /     \</span><br><span class="line">      bc     ade</span><br><span class="line">     / \     / \</span><br><span class="line">    b   c   ad  e</span><br><span class="line">           / \</span><br><span class="line">          a   d</span><br><span class="line"></span><br><span class="line">    swap &quot;ad&quot; and &quot;e&quot;</span><br><span class="line"></span><br><span class="line">        bcead</span><br><span class="line">       /     \</span><br><span class="line">      bc     ead</span><br><span class="line">     / \     / \</span><br><span class="line">    b   c   e  ad</span><br><span class="line">               / \</span><br><span class="line">              a   d</span><br><span class="line"></span><br><span class="line">But s3 is NOT a scramble of s1</span><br><span class="line"></span><br><span class="line">s1 ---&gt; s2</span><br><span class="line">s2 ---&gt; s3</span><br><span class="line">s1 -x-&gt; s3</span><br></pre></td></tr></table></figure><h1 id="recursion">Recursion</h1><p>Let <code>m</code> denotes the lenght of <code>s1</code>, and <code>n</code> denotes the length of <code>s2</code>.</p><p>Base cases:</p><ul><li>If <code>m != n</code>, <code>isScramble(s1, s2) = False</code>.</li><li>If <code>m == n == 1</code>, which means <code>s1</code> and <code>s2</code> are leaf nodes, <code>isScramble(s1, s2) = s1 == s2</code>.</li></ul><p>Recursion:</p><p>If there exist <code>1 &lt;= i &lt;= m-1</code>, where</p><ul><li><code>s1[0:i]</code> is a scramble of <code>s2[0:i]</code> and <code>s1[i:m]</code> is a scramble of <code>s2[i:n]</code>. Or,</li><li><code>s1[0:i]</code> is a scramble of <code>s2[n-i:n]</code> and <code>s1[i:m]</code> is a scramble of <code>s2[0:m-i]</code>.</li></ul><p>Then, <code>isScramble(s1, s2) = True</code>.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isScramble</span><span class="params">(self, s1: str, s2: str)</span> -&gt; bool:</span></span><br><span class="line">        m, n = len(s1), len(s2)</span><br><span class="line">        <span class="keyword">if</span> m != n:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> m == n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s1 == s2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> self.isScramble(s1[:i], s2[:i]) <span class="keyword">and</span> self.isScramble(s1[i:], s2[i:]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> self.isScramble(s1[:i], s2[-i:]) <span class="keyword">and</span> self.isScramble(s1[i:], s2[:n - i]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="dynamic-programming">Dynamic Programming</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Let F(i, j, k) denotes wheter the substring s1[i..i + k - 1] is a scramble of s2[j..j + k - 1].</span><br><span class="line">Since each of these substrings is a potential node in the tree, we need to check for all possible cuts.</span><br><span class="line"></span><br><span class="line">If s1 is a scrible of s2, let q be the length of a cut (hence, q &lt; k),</span><br><span class="line">then we are in the folloing situation:</span><br><span class="line"></span><br><span class="line">s1  [     x1     |       x2       ]</span><br><span class="line">    i            i + q            i + k - 1</span><br><span class="line"></span><br><span class="line">here, s2 has two possibilities:</span><br><span class="line"></span><br><span class="line">s2  [     y1     |       y2       ]</span><br><span class="line">    j            j + q            j + k - 1</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">s2  [       y1       |     y2     ]</span><br><span class="line">    j                j + k - q    j + k - 1</span><br><span class="line"></span><br><span class="line">which in terms of F means:</span><br><span class="line"></span><br><span class="line">F(i, j, k) = for some 1 &lt;= q &lt; k we have:</span><br><span class="line">    (F(i, j, q) AND F(i + q, j + q, k - q)) OR</span><br><span class="line">    (F(i, j + k - q, q) AND F(i + q, j, k - q))</span><br><span class="line"></span><br><span class="line">Base case is k = 1, where we simply need to check for s1[i] == s2[j]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isScramble</span><span class="params">(self, s1: str, s2: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(s1) != len(s2):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        n = len(s1)</span><br><span class="line">        dp = [[[<span class="literal">False</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n - k + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(n - k + <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">                        dp[i][j][k] = s1[i] == s2[j]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j][k] = any(</span><br><span class="line">                            (dp[i][j][q] <span class="keyword">and</span> dp[i + q][j + q][k - q]) <span class="keyword">or</span></span><br><span class="line">                            (dp[i][j + k - q][q] <span class="keyword">and</span> dp[i + q][j][k - q])</span><br><span class="line">                            <span class="keyword">for</span> q <span class="keyword">in</span> range(<span class="number">1</span>, k)</span><br><span class="line">                        )</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>][n]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> recursion </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maximal Rectangle</title>
      <link href="/programming/leetcode/maximal-rectangle/"/>
      <url>/programming/leetcode/maximal-rectangle/</url>
      
        <content type="html"><![CDATA[<p>Given an 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [&apos;1&apos;, &apos;0&apos;, &apos;1&apos;, &apos;0&apos;, &apos;0&apos;],</span><br><span class="line">  [&apos;1&apos;, &apos;0&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;],</span><br><span class="line">  [&apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;],</span><br><span class="line">  [&apos;1&apos;, &apos;0&apos;, &apos;0&apos;, &apos;1&apos;, &apos;0&apos;]</span><br><span class="line">]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure><h1 id="dynamic-programming">Dynamic Programming</h1><p>In this approach, we use three DP arrays, <code>left</code>, <code>right</code> and <code>height</code>. The DP solution proceeds row by row, starting from the first row. Let the maximal rectangle area at row <code>i</code> and column <code>j</code> be computed by <code>(right[i][j] - left[i][j]) * height[i][j]</code>.</p><p>Let <code>m</code> denotes the height of matrix and <code>n</code> denotes the width of matrix. Define <code>lm</code> and <code>rm</code> as follows.</p><ul><li><code>lm</code>: the leftmost index of consecutive 1's ending at current cell. <code>lm</code> can be updated during a left to right scan.</li><li><code>rm</code>: 1 + the rightmost index of consecutive 1's starting from current cell. <code>rm</code> can be updated during a right to left scan.</li></ul><p>The meaning of <code>left</code>, <code>right</code> and <code>height</code>:</p><ul><li><code>height[i][j]</code>: the height of consecutive 1's above <code>matrix[i][j]</code>.</li><li><code>left[i][j]</code>: the leftmost of consecutive 1's with height <code>height[i][j]</code>.</li><li><code>right[i][j]</code>: the rightmost of consecutive 1's with height <code>height[i][j]</code>.</li></ul><p>First rows are given by:</p><ul><li><code>left[0][j] = max(0, lm) if matrix[0][j] == '1' else 0</code></li><li><code>right[0][j] = min(n, rm) if matrix[0][j] == '1' else n</code></li><li><code>height[0][j] = 1 if matrix[0][j] == '1' else 0</code></li></ul><p>The transition equations are:</p><ul><li><code>left[i][j] = max(left[i - 1][j], lm) if matrix[i][j] == '1' else 0</code></li><li><code>right[i][j] = min(right[i - 1][j], rm) if matrix[i][j] == '1' else n</code></li><li><code>height[i][j] = height[i - 1][j] + 1 if matrix[i][j] == '1' else 0</code></li></ul><a id="more"></a><p>e.g.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">matrix:</span><br><span class="line">0  1  0</span><br><span class="line">1  1  1</span><br><span class="line"></span><br><span class="line">height:   height array is easier to understand</span><br><span class="line">0  1  0</span><br><span class="line">1  2  1</span><br><span class="line"></span><br><span class="line">left:</span><br><span class="line">0  1  0</span><br><span class="line">0  1  0</span><br><span class="line"></span><br><span class="line">left[1][1] = 1, because rectangle with height 2 can&apos;t expand left anymore</span><br><span class="line">left[1][2] = 0, because rectangle with height 1 can expand left to 0</span><br><span class="line"></span><br><span class="line">right:</span><br><span class="line">3  2  3</span><br><span class="line">3  2  3</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalRectangle</span><span class="params">(self, matrix: list)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            m, n = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left, right, height = [<span class="number">0</span>] * n, [n] * n, [<span class="number">0</span>] * n  <span class="comment"># using vector replace the matrix</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            rm = n</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> reversed(range(n)):  <span class="comment"># right to left scan</span></span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="string">'1'</span>:</span><br><span class="line">                    right[j] = min(right[j], rm)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right[j] = n</span><br><span class="line">                    rm = j</span><br><span class="line">            lm = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):  <span class="comment"># left to right scan</span></span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="string">'1'</span>:</span><br><span class="line">                    left[j] = max(left[j], lm)</span><br><span class="line">                    height[j] = height[j] + <span class="number">1</span></span><br><span class="line">                    res = max(res, (right[j] - left[j]) * height[j])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left[j] = <span class="number">0</span></span><br><span class="line">                    height[j] = <span class="number">0</span></span><br><span class="line">                    lm = j + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Climbing Stairs</title>
      <link href="/programming/leetcode/climbing-stairs/"/>
      <url>/programming/leetcode/climbing-stairs/</url>
      
        <content type="html"><![CDATA[<p>You are climbnig a stair case. It takes <em>n</em> steps to reach the top.</p><p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p><p>Note: Given <em>n</em> will be a positive integer.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><h1 id="dynamic-programming">Dynamic Programming</h1><p>Let <code>dp[i]</code> denotes the number of ways to reach on <code>i</code>-th step.</p><p>Base cases:</p><ul><li><code>dp[1] = 1</code>.</li><li><code>dp[2] = 2</code>.</li></ul><p>One can reach <code>i</code>-th step in one of the two ways:</p><ol type="1"><li>Taking a single step from <code>(i - 1)</code>-th step.</li><li>Taking a step of 2 from <code>(i - 2)</code>-th step.</li></ol><p>So, the total number of ways to reach <code>i</code>-th is equal to sum of ways of reaching <code>(i - 1)</code>-th step and ways of reach <code>(i - 2)</code>-th step. i.e. <code>dp[n] = dp[n - 1] + dp[n - 2]</code>.</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dp = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">            dp.append(dp[<span class="number">-1</span>] + dp[<span class="number">-2</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="fibonacci-number">Fibonacci Number</h1><p>In the above approach we have used <code>dp</code> array where <code>dp[i] = dp[i - 1] + dp[i - 2]</code>. It can be easily analysed that <code>dp[i]</code> is nothing but <code>i</code>-th fibonacci number.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        first, second = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">            third = first + second</span><br><span class="line">            first, second = second, third</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> second</span><br></pre></td></tr></table></figure><h1 id="binets-method">Binets Method</h1><p>This is an interesting solution which uses matrix multiplication to obtain the <code>n</code>-th Fibonacci Number. The matrix takes the following form: <span class="math inline">\(\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}\)</span>.</p><p>Let's say <span class="math inline">\(Q^n=\begin{bmatrix}F_n&amp;F_{n-1}\\F_{n-1}&amp;F_{n-2}\end{bmatrix}\)</span>, the <code>n</code>-th Fibonacci Number is given by <span class="math inline">\(Q^n[0][0]\)</span>.</p><p>In particular, we denote <span class="math inline">\(Q^1=\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}\)</span>, where <span class="math inline">\(F_1=Q^1[0][0]=1\)</span>.</p><p>We can prove this method using Mathematical Induction.</p><p><span class="math inline">\(Q^2=Q^1\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}=\begin{bmatrix}2&amp;1\\1&amp;1\end{bmatrix} \quad F_2=Q^2[0][0]=2\)</span> holds.</p><p><span class="math inline">\(Q^3=Q^2\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}=\begin{bmatrix}3&amp;2\\2&amp;1\end{bmatrix} \quad F_3=Q^3[0][0]=3\)</span> holds.</p><p>Thus, the base case holds.</p><p>Assume that this method holds for finding the <code>n</code>-th Fibonacci Number, i.e. <span class="math inline">\(F_n = Q^n[0][0]\)</span>, where, <span class="math inline">\(Q^n=\begin{bmatrix}F_n&amp;F_{n-1}\\F_{n-1}&amp;F_{n-2}\end{bmatrix}\)</span>.</p><p>Now, we need to prove that with the above two conditions holding true, the method is valid for finding the <code>(n + 1)</code>-th Fibonacci Number, i.e. <span class="math inline">\(F_{n+1} = Q^{n+1}[0][0]\)</span>.</p><p>Proof: <span class="math inline">\(Q^{n+1}=\begin{bmatrix}F_n&amp;F_{n-1}\\F_{n-1}&amp;F_{n-2}\end{bmatrix}\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}=\begin{bmatrix}F_n+F_{n-1}&amp;F_n\\F_{n-1}+F_{n-2}&amp;F_{n-1}\end{bmatrix} = \begin{bmatrix}F_{n+1}&amp;F_n\\F_n&amp;F_{n-1}\end{bmatrix}\)</span>.</p><p>Thus, <span class="math inline">\(F_{n+1} = Q^{n+1}[0][0]\)</span>. This completes the proof of this method.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(log n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        q = [[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>]]</span><br><span class="line">        res = self.pow(q, n)</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pow</span><span class="params">(self, a, n)</span>:</span></span><br><span class="line">        ret = [[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span> == <span class="number">1</span>:  <span class="comment"># when n is odd</span></span><br><span class="line">                ret = self.multiply(ret, a)</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>         <span class="comment"># n = n // 2</span></span><br><span class="line">            a = self.multiply(a, a)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(a, b)</span>:</span></span><br><span class="line">        c = [[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">                c[i][j] = a[i][<span class="number">0</span>] * b[<span class="number">0</span>][j] + a[i][<span class="number">1</span>] * b[<span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure><p>Proof of time complexity:</p><p>Suppose, <span class="math inline">\(n\)</span> is the power of 2. To calculate <span class="math inline">\(Q^n\)</span> matrix, we should calculate <span class="math inline">\(Q^{n/2}\)</span> matrix and multiply it by itself. To calculate <span class="math inline">\(Q^{n/2}\)</span> we should have to do the same with <span class="math inline">\(Q^{n/4}\)</span> and so on. Meaning that: <span class="math inline">\(Q^{n}=Q^{n/2}\cdot Q^{n/2}=\dots=\prod_1^n Q^1\)</span>.</p><p>e.g. <span class="math inline">\(Q^8=(Q^4)^2=((Q^2)^2)^2=(((Q^1)^2)^2)^2\)</span>.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">         Q^n</span><br><span class="line">      /       \</span><br><span class="line">  Q^&#123;n/2&#125;   Q^&#123;n/2&#125;</span><br><span class="line">   ...        ...</span><br><span class="line">  /   \      /   \</span><br><span class="line">Q^1   Q^1  Q^1   Q^1</span><br></pre></td></tr></table></figure><p>Obviously, the tree height is <span class="math inline">\(\log_2 n\)</span>.</p><p>In case, the number <span class="math inline">\(n\)</span> is not a power of 2, we can <strong>break it in terms of powers of 2</strong> using its binary representation: <span class="math inline">\(n=\sum_{p\in P}2^p\)</span>, where <span class="math inline">\(P\subset \mathbb{N}\)</span>.</p><p>Thus, we can obtain the final result using: <span class="math inline">\(Q^n=\prod_{p\in P}Q^{2^p}\)</span>.</p><p>e.g. <span class="math inline">\(Q^7=Q^4\cdot Q^2 \cdot Q^1\)</span>.</p><p>This is the method we've used in implementation. Again, the complexity remains <span class="math inline">\(O(\log_2 n)\)</span> as we have limited the number of multiplications to <span class="math inline">\(O(\log_2 n)\)</span>.</p><h1 id="fibonacci-formula">Fibonacci Formula</h1><p>We can find <code>n</code>-th fibonacci number using this formula: <span class="math inline">\(F_n=1/\sqrt 5\Big[\Big(\frac{1+\sqrt 5}{2}\Big)^n-\Big(\frac{1-\sqrt 5}{2}\Big)^n\Big]\)</span>.</p><p>For the given problem, the Fibonacci sequence is defined by <span class="math inline">\(F_0=1, F_1=1, F_2=2, F_{n+2}=F_{n+1}+F_n\)</span>.</p><p>A standard method of trying to sovle such recursion formulas is assume <span class="math inline">\(F_n\)</span> of the form <span class="math inline">\(F_n=a^n\)</span>.</p><p>Then, of cource, <span class="math inline">\(F_{n+1}=a^{n+1}\)</span> and <span class="math inline">\(F_{n+2}=a^{n+2}\)</span> so the equation becomes <span class="math inline">\(a^{n+2}=a^{n+1}+a^n\)</span>. If we divide the entire equation by <span class="math inline">\(a^n\)</span> we arrive at <span class="math inline">\(a^2=a+1\)</span>.</p><p>Solving this by the quadratic formula, we get: <span class="math inline">\(a=1/\sqrt 5\Big(\frac{1\pm\sqrt 5}{2}\Big)\)</span>.</p><p>The general solution, thus takes the form: <span class="math inline">\(F_n=A\Big(\frac{1+\sqrt 5}{2}\Big)^n+B\Big(\frac{1-\sqrt 5}{2}\Big)^n\)</span>.</p><p>For <span class="math inline">\(n=0\)</span>, we get <span class="math inline">\(A+B=1\)</span>. For <span class="math inline">\(n=1\)</span>, we get <span class="math inline">\(A\Big(\frac{1+\sqrt 5}{2}\Big)+B\Big(\frac{1-\sqrt 5}{2}\Big)=1\)</span>. Solving the above equations, we get <span class="math inline">\(A=\Big(\frac{1+\sqrt 5}{2\sqrt 5}\Big), B=\Big(\frac{1-\sqrt 5}{2\sqrt 5}\Big)\)</span>.</p><p>Putting these values of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> in the above general solution equation, we get:</p><p><span class="math inline">\(F_n=1/\sqrt 5\Big[\Big(\frac{1+\sqrt 5}{2}\Big)^n-\Big(\frac{1-\sqrt 5}{2}\Big)^n\Big]\)</span></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(log n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">import</span> math</span><br><span class="line">        sqrt5 = math.sqrt(<span class="number">5</span>)</span><br><span class="line">        fibn = math.pow((<span class="number">1</span> + sqrt5) / <span class="number">2</span>, n + <span class="number">1</span>) - math.pow((<span class="number">1</span> - sqrt5) / <span class="number">2</span>, n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> int(fibn / sqrt5)</span><br></pre></td></tr></table></figure><p><em>zhoubowei</em> commented on leetcode that Fibonacci Formula would be invalid while the answer is larger than 10^15.</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
            <tag> fibonacci </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Minimum Path Sum</title>
      <link href="/programming/leetcode/minimum-path-sum/"/>
      <url>/programming/leetcode/minimum-path-sum/</url>
      
        <content type="html"><![CDATA[<p>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which <em>minimizes</em> the sum of all numbers along its path.</p><p><strong>Note:</strong> You can only move either down or right at any point in time.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">Output: 7</span><br></pre></td></tr></table></figure><h1 id="dynamic-programming">Dynamic Programming</h1><p><code>dp[i][j]</code> denotes the minimum sum of all numbers along the path that start from <code>(1, 1)</code> to <code>(i, j)</code>. Indices start from 1.</p><ul><li><code>dp[i][1] = dp[i - 1][1] + grid[i][1]</code>. Any cell in the first column can only be reached from the cell above it.</li><li><code>dp[1][j] = dp[1][j - 1] + grid[1][j]</code>. Any cell in the first row can only be reached from the cell left to it.</li><li><code>dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]</code>. Cell <code>(i, j)</code> can be reached from the cell above it or the left to it.</li></ul><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid: list)</span> -&gt; int:</span></span><br><span class="line">        m, n = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            grid[i][<span class="number">0</span>] = grid[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            grid[<span class="number">0</span>][j] = grid[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                grid[i][j] = min(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>]) + grid[i][j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> grid[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="dijkstra">Dijkstra</h1><p>For more details, see <a href="/notes/introduction-to-algorithms/single-source-shortest-paths/" title="Single Source Shortest Paths">Single Source Shortest Paths</a>.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid: list)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">        m, n = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">        heap = [(grid[<span class="number">0</span>][<span class="number">0</span>], (<span class="number">0</span>, <span class="number">0</span>))]</span><br><span class="line">        visited = set()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> heap:</span><br><span class="line">            curr, (i, j) = heapq.heappop(heap)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i, j) == (m - <span class="number">1</span>, n - <span class="number">1</span>):  <span class="comment"># got the result</span></span><br><span class="line">                <span class="keyword">return</span> curr</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i, j) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                visited.add((i, j))</span><br><span class="line">                <span class="keyword">for</span> x, y <span class="keyword">in</span> &#123;(i + <span class="number">1</span>, j), (i, j + <span class="number">1</span>)&#125;:  <span class="comment"># relax neighbor</span></span><br><span class="line">                    <span class="keyword">if</span> x &lt; m <span class="keyword">and</span> y &lt; n <span class="keyword">and</span> (x, y) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        heapq.heappush(heap, (curr + grid[x][y], (x, y)))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
            <tag> shortest path </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unique Paths</title>
      <link href="/programming/leetcode/unique-paths/"/>
      <url>/programming/leetcode/unique-paths/</url>
      
        <content type="html"><![CDATA[<h1 id="unique-paths">Unique Paths</h1><p>A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).</p><p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).</p><p><img src="/uploads/image/leetcode/robot_maze.png"></p><p>How many possible unique paths are there?</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: m = 3, n = 2</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: m = 7, n = 3</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure><p>Constraints:</p><ul><li><code>1 &lt;= m, n &lt;= 100</code>.</li><li>It's guaranteed that the answer will be less than or equal to <code>2 * 10 ^ 9</code>.</li></ul><h2 id="dynamic-programming">Dynamic Programming</h2><p><code>dp[i][j]</code> denotes the number of possible unique paths that from <code>(i, j)</code> to <code>(m, n)</code>. Indices start from 1 here.</p><ul><li><code>i = m</code>, robot can only move right. So, <code>dp[m][j] = 1</code>.</li><li><code>j = n</code>, robot can only move down. So, <code>dp[i][n] = 1</code>.</li><li><code>i &lt; m and j &lt; n</code>, robot can move down or right. When move right, robot has <code>dp[i][j + 1]</code> unique paths. When move down, robot has <code>dp[i + 1][j]</code> unique paths. So, <code>dp[i][j] = dp[i][j + 1] + dp[i + 1][j]</code>.</li></ul><p>Also, you can denote <code>dp[i][j]</code> as the number of possible unique paths that from <code>(1, 1)</code> to <code>(i, j)</code>. Then,</p><ul><li><code>dp[1][j] = dp[i][1] = 1</code>.</li><li><code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>.</li><li><code>dp[m][n]</code> is the answer of problem.</li></ul><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(mn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [[<span class="number">1</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(m - <span class="number">1</span>)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> reversed(range(n - <span class="number">1</span>)):</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j] + dp[i][j + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">1</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> reversed(range(m - <span class="number">1</span>)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> reversed(range(n - <span class="number">1</span>)):</span><br><span class="line">                dp[j] = dp[j] + dp[j + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h1 id="unique-paths-ii">Unique Paths II</h1><p>Now consider if some obstacles are aded to the grids. How many unique paths would there be?</p><p>An obstale and empty space is marked as <code>1</code> and <code>0</code> respectively in the grid.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><h2 id="dynamic-programming-1">Dynamic Programming</h2><p>Base cases:</p><ul><li>If <code>grid[i][j] == 1</code>, which means a obstacle, <code>dp[i][j] = 0</code>.</li><li><code>i = m</code>, robot can move right only if <code>grid[i][j + 1] == 0</code>. So, <code>dp[i][j] = dp[i][j + 1]</code>.</li><li><code>j = n</code>, robot can move down only if <code>grid[i + 1][j] == 0</code>. So, <code>dp[i][j] = dp[i + 1][j]</code>.</li></ul><p>Induction rules:</p><ul><li>If <code>grid[i][j] == 1</code>, <code>dp[i][j] = 0</code>.</li><li>If <code>grid[i][j] == 0</code>, <code>dp[i][j] = dp[i + 1][j] + dp[i][j + 1]</code>.</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(1). We are utilizing the `obstacleGrid` as the DP array. Hence, no extra space.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid: list)</span> -&gt; int:</span></span><br><span class="line">        m, n = len(obstacleGrid), len(obstacleGrid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># If the start or finish cell has an obstacle</span></span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] + obstacleGrid[<span class="number">-1</span>][<span class="number">-1</span>] &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Utilizing input obstacleGrid as dp</span></span><br><span class="line">        obstacleGrid[<span class="number">-1</span>][<span class="number">-1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(m - <span class="number">1</span>)):</span><br><span class="line">            obstacleGrid[i][- <span class="number">1</span>] = int(obstacleGrid[i][<span class="number">-1</span>] == <span class="number">0</span> <span class="keyword">and</span> obstacleGrid[i + <span class="number">1</span>][<span class="number">-1</span>] == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> reversed(range(n - <span class="number">1</span>)):</span><br><span class="line">            obstacleGrid[<span class="number">-1</span>][j] = int(obstacleGrid[<span class="number">-1</span>][j] == <span class="number">0</span> <span class="keyword">and</span> obstacleGrid[<span class="number">-1</span>][j + <span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(m - <span class="number">1</span>)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> reversed(range(n - <span class="number">1</span>)):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">0</span>:</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i + <span class="number">1</span>][j] + obstacleGrid[i][j + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    obstacleGrid[i][j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wildcard Matching</title>
      <link href="/programming/leetcode/wildcard-matching/"/>
      <url>/programming/leetcode/wildcard-matching/</url>
      
        <content type="html"><![CDATA[<p>Given an input string (<code>s</code>) and a pattern (<code>p</code>), implement wildcard pattern matching with support for <code>'?'</code> and <code>'*'</code>.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;?&apos; Matches any single character.</span><br><span class="line">&apos;*&apos; Matches any sequence of characters (including the empty sequence).</span><br></pre></td></tr></table></figure><p>The matching should cover the <strong>entire</strong> input string (not partial).</p><p><strong>Note:</strong></p><ul><li><code>s</code> could be empty and contains only lowercase latters <code>a-z</code>.</li><li><code>p</code> could be empty and contains only lowercase latters <code>a-z</code>, and characters like <code>?</code> or <code>*</code>.</li></ul><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;aa&quot;, p = &quot;a&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;aa&quot;, p = &quot;*&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>Example 3:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;cb&quot;, p = &quot;?a&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p>Example 4:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;adceb&quot;, p = &quot;*a*b&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>Example 5:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;acdcb&quot;, p = &quot;a*c?b&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><h1 id="dynamic-programming">Dynamic Programming</h1><p>Similar to the problem <a href="/programming/leetcode/regular-expression-matching/" title="Regular Expression Matching">Regular Expression Matching</a>.</p><p><code>dp[i][j]</code> denotes whether <code>s[i..m)</code> matches <code>p[j..n)</code>. Index of strings start from 0.</p><p>Assuming <code>m</code> is the length of string <code>s</code>, <code>n</code> is the length of pattern <code>p</code>.</p><p>Base cases:</p><ul><li>origin: <code>dp[m][n] = true</code>. <code>s[m:] == p[n:] == ''</code>, they do match.</li><li>last row: <code>dp[m][j]</code>, expect for string <code>p</code> is <code>*</code>, which can match empty sequence, otherwise all false.</li><li>last column: <code>dp[i][n] = false</code>. <code>s[i:] != ''</code> but <code>p[n:] == ''</code>, they can't match.</li></ul><p>Induction rules:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if s[i] == p[j] or p[j] == &apos;?&apos;:   # the matches are single to single.</span><br><span class="line">    dp[i][j] = dp[i + 1][j + 1]   # the result depends on whether the last characters are match.</span><br><span class="line"></span><br><span class="line">elif p[j] == &apos;*&apos;:</span><br><span class="line">    dp[i][j] = dp[i][j + 1] or dp[i + 1][j]  # if * matches empty sequence, dp[i][j] = dp[i][j + 1]</span><br><span class="line">                                             # if * matches any not empty sequence, dp[i][j] = dp[i + 1][j]</span><br><span class="line">else:</span><br><span class="line">    dp[i][j] = False              # can&apos;t match</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(mn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        m, n = len(s), len(p)</span><br><span class="line"></span><br><span class="line">        dp = [[<span class="literal">False</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">-1</span>][<span class="number">-1</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> p[j] == <span class="string">'*'</span>:</span><br><span class="line">                dp[m][j] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="comment"># first, check if s[i] and p[j] is single to single match</span></span><br><span class="line">                <span class="keyword">if</span> p[j] == s[i] <span class="keyword">or</span> p[j] == <span class="string">'?'</span>:</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j + <span class="number">1</span>]</span><br><span class="line">                <span class="comment"># then, deal with *</span></span><br><span class="line">                <span class="keyword">elif</span> p[j] == <span class="string">'*'</span>:</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j] <span class="keyword">or</span> dp[i][j + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>There also exists another variation, where <code>dp[i][j]</code> denotes whether <code>s[0..i-1]</code> matches <code>p[0..j-1]</code>. It's similar to the solution above, but be careful about the indices.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        m, n = len(s), len(p)</span><br><span class="line"></span><br><span class="line">        dp = [[<span class="literal">False</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> p[j - <span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> p[j - <span class="number">1</span>] == s[i - <span class="number">1</span>] <span class="keyword">or</span> p[j - <span class="number">1</span>] == <span class="string">'?'</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">elif</span> p[j - <span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] <span class="keyword">or</span> dp[i][j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure><h1 id="another-approach">Another approach</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If s[i] == p[j] or p[j] == &apos;?&apos;, which means this is a match,</span><br><span class="line">    goes to next element, i++, j++.</span><br><span class="line"></span><br><span class="line">If p[j] == &apos;*&apos;, this is also a match, but zero or many chars may be available,</span><br><span class="line">    save this * position and the matched s position ii.</span><br><span class="line"></span><br><span class="line">If not match, then we check if there was a * previously showd up,</span><br><span class="line">    if there is no *, return false;</span><br><span class="line">    if there is a *, we set current j to the next element of *, and set current i to the next saved ii position.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">e.g. s=&apos;abed&apos;, p=&apos;?b*d**&apos;</span><br><span class="line"></span><br><span class="line">a = ?, go on, i++, j++</span><br><span class="line">b = b, go on, i++, j++</span><br><span class="line">e = *, save * position, star = 3, save s position, ii = 3, j++</span><br><span class="line">e != d, check if there was a *, yes, j = star + 1, ii++, i = ii</span><br><span class="line">d = d, go on, i++, j++, i meet the end</span><br><span class="line">check the rest element in p, if all are *, return true, else false</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        i = j = match = <span class="number">0</span></span><br><span class="line">        star = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> j &lt; len(p) <span class="keyword">and</span> (p[j] == <span class="string">'?'</span> <span class="keyword">or</span> s[i] == p[j]):</span><br><span class="line">                i = i + <span class="number">1</span></span><br><span class="line">                j = j + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> j &lt; len(p) <span class="keyword">and</span> p[j] == <span class="string">'*'</span>:</span><br><span class="line">                match = i   <span class="comment"># the character to match * if there exist not match latter</span></span><br><span class="line">                star = j    <span class="comment"># save star position</span></span><br><span class="line">                j = j + <span class="number">1</span>   <span class="comment"># only move j</span></span><br><span class="line">            <span class="keyword">elif</span> star != <span class="number">-1</span>:       <span class="comment"># not match happend, check if there was a *</span></span><br><span class="line">                j = star + <span class="number">1</span>       <span class="comment"># move j to the next of *</span></span><br><span class="line">                match = match + <span class="number">1</span>  <span class="comment"># let s[match] to match *</span></span><br><span class="line">                i = match          <span class="comment"># move i</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> j &lt; len(p) <span class="keyword">and</span> p[j] == <span class="string">'*'</span>:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> j == len(p)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
            <tag> matching </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>交叉验证</title>
      <link href="/notes/introduction-to-ml-with-python/cross-validation/"/>
      <url>/notes/introduction-to-ml-with-python/cross-validation/</url>
      
        <content type="html"><![CDATA[<p>交叉验证（cross-validation）是一种评估泛化性能的统计学方法，它比单次划分训练集和测试集的方法更加稳定、全面。在交叉验证中，数据被多次划分，并且需要训练多个模型。最常用的交叉验证是 <strong><span class="math inline">\(k\)</span> 折交叉验证</strong>（ <span class="math inline">\(k\)</span>-fold cross-validation），其中 <span class="math inline">\(k\)</span> 是由用户指定的数字，通常取 5 或 10。在执行 5 折交叉验证时，首先将数据划分为（大致）相等的 5 部分，每一部分叫作<strong>折</strong>（fold）。接下来训练一系列模型。使用第 1 折作为测试集，其他折（2-5）作为训练集来训练第一个模型。之后构建另一个模型，这次使用第 2 折作为测试集，其他折作为训练集……对于将数据划分为训练集和测试集的这 5 次划分，每一次都要计算精度。最后我们得到了 5 个精度值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_cross_validation()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/cross-validation.png"></p><a id="more"></a><h1 id="scikit-learn-中的交叉验证">scikit-learn 中的交叉验证</h1><p>scikit-learn 是利用 <code>model_selection</code> 模块中的 <code>cross_val_score</code> 函数来实现交叉验证的。<code>cross_val_score</code> 函数的参数是我们想要评估的模型、训练数据与真实标签。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.model_selection.cross_val_score#sklearn.model_selection.cross_val_score" target="_blank" rel="noopener"><code>sklearn.model_selection.cross_val_score(estimator, X, y=None, groups=None, scoring=None, cv=’warn’, n_jobs=None, verbose=0, fit_params=None, pre_dispatch=‘2*n_jobs’, error_score=’raise-deprecating’)</code></a></p><p>Evaluate a score by cross-validation</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"></span><br><span class="line">iris = load_iris()</span><br><span class="line">logreg = LogisticRegression()</span><br><span class="line"></span><br><span class="line">scores = cross_val_score(logreg, iris.data, iris.target)  <span class="comment"># 默认执行 3 折交叉验证</span></span><br><span class="line">print(<span class="string">'Cross-validation scores:'</span>, scores)</span><br><span class="line"></span><br><span class="line">scores = cross_val_score(logreg, iris.data, iris.target, cv=<span class="number">5</span>)</span><br><span class="line">print(<span class="string">'Cross-validation scores:'</span>, scores)</span><br><span class="line"><span class="comment"># 总结交叉验证精度的一种常用方法是计算平均值</span></span><br><span class="line">print(<span class="string">'Average cross-validation score: &#123;:.2f&#125;'</span>.format(scores.mean()))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cross-validation scores: [0.96078431 0.92156863 0.95833333]</span><br><span class="line">Cross-validation scores: [1.         0.96666667 0.93333333 0.9        1.        ]</span><br><span class="line">Average cross-validation score: 0.96</span><br></pre></td></tr></table></figure><p>模型的平均精度约为 96%。观察 5 折交叉验证得到的所有 5 个精度值，还可以发现，折与折之间的精度有较大的变化，范围从 100% 精度到 90% 精度。这可能意味着模型强烈依赖于将某个折用于训练，但也可能只是因为数据集的数据量太小。</p><h1 id="交叉验证的优缺点">交叉验证的优缺点</h1><p>使用交叉验证而不是将数据单次划分为训练集和测试集，这种做法具有下列优点。首先，<code>train_test_split</code> 对数据进行随机划分。想象一下，在随机划分数据时我们很“幸运”，所有难以分类的样例都在训练集中。在这种情况下，测试集将仅包含“容易分类的”样例，并且测试集精度会高得不切实际。相反，如果我们“不够幸运”，则可能随机地将所有难以分类的样例都放在测试集中，因此得到一个不切实际的低分数。但如果使用交叉验证，每个样例都会刚好在测试集中出现一次：每个样例位于一个折中，而每个折都在测试集中出现一次。因此，模型需要对数据集中所有样本的泛化能力都很好，才能让所有的交叉验证得分（及其平均值）都很高。</p><p>对数据进行多次划分，还可以提供我们的模型对训练集选择的敏感性信息。对于 iris 数据集，我们观察到精度在 90% 到 100% 之间。这是一个不小的范围，它告诉我们将模型应用于新数据时在最坏情况和最好情况下的可能表现。</p><p>与数据的单词划分相比，交叉验证的另一个优点是我们对数据的使用更加高效。在使用 <code>train_test_split</code> 时，我们通常将 75% 的数据用于训练，25% 的数据用于评估。在使用 5 折交叉验证时，在每次迭代中我们可以使用 4/5（80%）的数据来拟合模型。在使用 10 折交叉验证时，我们可以使用 9/10（90%）的数据来拟合模型。更多的数据通常可以得到更为精确的模型。</p><p>交叉验证的主要缺点是增加了计算成本。现在我们要训练 <span class="math inline">\(k\)</span> 个模型而不是单个模型，所以交叉验证的速度要比数据的单次划分大约慢 <span class="math inline">\(k\)</span> 倍。</p><h1 id="分层-k-折交叉验证和其他策略">分层 <span class="math inline">\(k\)</span> 折交叉验证和其他策略</h1><p>将数据集划分为 <span class="math inline">\(k\)</span> 折时，从数据的前 <span class="math inline">\(k\)</span> 分之一开始划分（正如上一节所述），这可能并不总是一个好主意。例如，我们来看一下 iris 数据集。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'Iris labels:\n&#123;&#125;'</span>.format(iris.target))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Iris labels:</span><br><span class="line">[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br><span class="line"> 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</span><br><span class="line"> 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2</span><br><span class="line"> 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2</span><br><span class="line"> 2 2]</span><br></pre></td></tr></table></figure><p>如你所见，数据的前三分之一是类别 0，中间三分之一是类别 1，最后三分之一是类别 2。想象一下在这个数据集上进行 3 折交叉验证。第 1 折将只包含类别 0，所以在数据的第一次划分中，测试集将只包含类别 0，而训练集只包含类别 1 和 2。由于在 3 次划分中训练集和测试集中的类别都不相同，因此这个数据集上的 3 折交叉验证精度为 0。这没什么帮助，因为我们在 iris 上可以的得到比 0% 好得多的精度。</p><p>由于简单的 <span class="math inline">\(k\)</span> 折策略在这里失效了，所以 scikit-learn 在分类问题中不使用这种策略，而是使用<strong>分层 <span class="math inline">\(k\)</span> 折交叉验证</strong>（stratified <span class="math inline">\(k\)</span>-fold cross-validation）。在分层交叉验证中，我们划分数据，使每个折中类别之间的比例与整个数据集中的比例相同。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'Iris labels:\n&#123;&#125;'</span>.format(iris.target))</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/stratified-cross-validation.png"></p><p>举个例子，如果 90% 的样本属于类别 A 而 10% 的样本属于类别 B，那么分层交叉验证可以确保，在每个折中 90% 的样本属于类别 A 而 10% 的样本属于类别 B。</p><p>使用分层 <span class="math inline">\(k\)</span> 折交叉验证而不是 <span class="math inline">\(k\)</span> 折交叉验证来评估一个分类器，这通常是一个好主意，因为它可以对泛化性能做出更可靠的估计。在只有 10% 的样本属于类别 B 的情况下，如果使用标准 <span class="math inline">\(k\)</span> 折交叉验证，很可能某个折中只包含类别 A 的样本。利用这个折作为测试集的话，无法给出分类器整体性能的信息。</p><p>对于回归问题，scikit-learn 默认使用标准 <span class="math inline">\(k\)</span> 折交叉验证。也可以尝试让每个折表示回归目标的不同取值，但这并不是一种常用的策略，也会让大多数用户感到以外。</p><h2 id="对交叉验证的更多控制">对交叉验证的更多控制</h2><p>我们之前看到，可以利用 cv 参数来调节 <code>cross_val_score</code> 所使用的折数。但 scikit-learn 允许提供一个<strong>交叉验证分离器</strong>（cross-validation spliter）作为 cv 参数，来对数据划分过程进行更精确的控制。对于大多数使用场景而言，回归问题默认的 <span class="math inline">\(k\)</span> 折交叉验证与分类问题的分层 <span class="math inline">\(k\)</span> 折交叉验证的表现都很好，但有些情况下你可能希望使用不同的策略。比如说，我们想要在一个分类数据集上使用标准 <span class="math inline">\(k\)</span> 折交叉验证来重现别人的结果。为了实现这一点，我们首先必须从 <code>model_selection</code> 模块中导入 <code>KFold</code> 分离器类，并用我们想要使用的折数来将其实例化。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold</span><br><span class="line"></span><br><span class="line">kfold = KFold(n_splits=<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 将kfold分离器对象作为cv参数传入cross_val_score</span></span><br><span class="line">print(<span class="string">'Cross-validation scores:\n&#123;&#125;\n'</span>.format(</span><br><span class="line">    cross_val_score(logreg, iris.data, iris.target, cv=kfold)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们可以验证，在iris数据集上使用标准 3 折交叉验证确实是一个非常糟糕的注意</span></span><br><span class="line">kfold = KFold(n_splits=<span class="number">3</span>)</span><br><span class="line">print(<span class="string">'Cross-validation scores:\n&#123;&#125;\n'</span>.format(</span><br><span class="line">    cross_val_score(logreg, iris.data, iris.target, cv=kfold)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决这种问题的另一个方法是将数据打乱来代替分层</span></span><br><span class="line">kfold = KFold(n_splits=<span class="number">3</span>, shuffle=<span class="literal">True</span>, random_state=<span class="number">0</span>)</span><br><span class="line">print(<span class="string">'Cross-validation scores:\n&#123;&#125;'</span>.format(</span><br><span class="line">    cross_val_score(logreg, iris.data, iris.target, cv=kfold)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cross-validation scores:</span><br><span class="line">[1.         0.93333333 0.43333333 0.96666667 0.43333333]</span><br><span class="line"></span><br><span class="line">Cross-validation scores:</span><br><span class="line">[0. 0. 0.]</span><br><span class="line"></span><br><span class="line">Cross-validation scores:</span><br><span class="line">[0.9  0.96 0.96]</span><br></pre></td></tr></table></figure><h2 id="留一法交叉验证">留一法交叉验证</h2><p>另一种常用的交叉验证方法是<strong>留一法</strong>（leave-one-out）。你可以将留一法交叉验证看作是每折只包含单个样本的 <span class="math inline">\(k\)</span> 折交叉验证。对于每次划分，选择单个数据点作为测试集。这种方法可能非常耗时，特别是对于大型数据集来说，但在小型数据集上有时可以给出更好的估计结果。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.model_selection.leaveoneout" target="_blank" rel="noopener"><code>class sklearn.model_selection.LeaveOneOut</code></a></p><p>Leave-One-Out cross-validator</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> LeaveOneOut</span><br><span class="line"></span><br><span class="line">loo = LeaveOneOut()</span><br><span class="line">scores = cross_val_score(logreg, iris.data, iris.target, cv=loo)</span><br><span class="line">print(<span class="string">'Number of cv iterations:'</span>, len(scores))</span><br><span class="line">print(<span class="string">'Mean accuracy: &#123;:.2f&#125;'</span>.format(scores.mean()))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Number of cv iterations: 150</span><br><span class="line">Mean accuracy: 0.95</span><br></pre></td></tr></table></figure><h2 id="打乱划分交叉验证">打乱划分交叉验证</h2><p>另一种非常灵活的交叉验证策略是<strong>打乱划分交叉验证</strong>（shuffle-split cross-validation）。在打乱划分交叉验证中，每次划分为训练集取样 <code>train_size</code> 个点，为测试集取样 <code>test_size</code> 个（不相交的）点。将这一划分方法重复 <code>n_iter</code> 次。下图显示的是对包含 10 个点的数据集进行 4 次迭代划分，每次的训练集包含 5 个点，测试集包含 2 个点（你可以将 <code>train_size</code> 和 <code>test_size</code> 设为整数来表示这两个集合的绝对大小，也可以设为浮点数来表示占整个数据集的比例）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_shuffle_split()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/shuffle-split.png"></p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.model_selection.shufflesplit" target="_blank" rel="noopener"><code>class sklearn.model_selection.ShuffleSplit(n_splits=10, test_size=’default’, train_size=None, random_state=None)</code></a></p><p>Random permutation cross-validator</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> ShuffleSplit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分为 50% 的训练集和 50% 的测试集，共运行 10 次迭代</span></span><br><span class="line">shuffle_split = ShuffleSplit(test_size=<span class="number">.5</span>, train_size=<span class="number">.5</span>, n_splits=<span class="number">10</span>, random_state=<span class="number">0</span>)</span><br><span class="line">scores = cross_val_score(logreg, iris.data, iris.target, cv=shuffle_split)</span><br><span class="line">print(<span class="string">'Cross-validation scores:\n&#123;&#125;'</span>.format(scores))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cross-validation scores:</span><br><span class="line">[0.84       0.93333333 0.90666667 1.         0.90666667 0.93333333</span><br><span class="line"> 0.94666667 1.         0.90666667 0.88      ]</span><br></pre></td></tr></table></figure><p>打乱划分交叉验证可以在训练集和测试集大小之外独立控制迭代次数，这有时是很有帮助的。它还允许在每次迭代中仅使用部分数据。用这种方法对数据进行二次采样可能对大型数据集上的试验很有帮助。</p><p><code>ShuufleSplit</code> 还有一种分层的形式，，其名称为 <code>StratifiedShuffleSplit</code>，它可以为分类任务提供更可靠的结果。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.model_selection.stratifiedshufflesplit" target="_blank" rel="noopener"><code>class sklearn.model_selection.StratifiedShuffleSplit(n_splits=10, test_size=’default’, train_size=None, random_state=None)</code></a></p><p>Stratified ShuffleSplit cross-validator</p></blockquote><h2 id="分组交叉验证">分组交叉验证</h2><p>另一种非常常见的交叉验证适用于<strong>数据中的分组高度相关</strong>时。比如你想构建一个从人脸图片中识别情感的系统，并且收集了 100 个人的照片的数据集，其中每个人都进行了多次拍摄，分别展示了不同的情感。我们的目标是构建一个分类器，能够正确识别未包含在数据集中的人的情感。</p><p>你可以使用默认的分层交叉验证来度量分类器的性能。但是这样的话，同一个人的照片可能会同时出现在训练集和测试集中。对于分类器而言，检测训练集中出现过的人脸情感比全新的人脸要容易得多。因此，为了准确评估模型对新的人脸的泛化能力，我们必须确保训练集和测试集中包含不同人的图像。</p><p>为了实现这一点，我们可以使用 <code>GroupKFold</code>，它以 <code>groups</code> 数组作为参数，可以用来说明照片中对应的是哪个人。这里的 <code>groups</code> 数组表示数据中的分组，在创建训练集和测试集的时候不应该将其分开，也不应该与类别标签弄混。</p><p>数据分组的这种例子常见于医疗应用，你可能用来来自同一名病人的多个样本，但想要将其泛化到新的病人。同样，在语音识别领域，你的数据集中可能包含同一名发言人的多条记录，但你希望能够识别新的发言人的讲话。</p><p>下面这个示例用到了一个由 <code>groups</code> 数组指定分组的模拟数据集。这个数据集包含 12 个数据点，且对于每个数据点，<code>groups</code> 指定了该点所属的分组。一共分成 4 个组，前 3 个样本属于第一组，接下来的 4 个样本属于第二组，以此类推。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.model_selection.groupkfold" target="_blank" rel="noopener"><code>class sklearn.model_selection.GroupKFold(n_splits=’warn’)</code></a></p><p>K-fold iterator variant with non-overlapping groups.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GroupKFold</span><br><span class="line"></span><br><span class="line">X, y = make_blobs(n_samples=<span class="number">12</span>, random_state=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 样本不需要按分组进行排序，这么做只是为了便于说明</span></span><br><span class="line">groups = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line">scores = cross_val_score(logreg, X, y, groups, cv=GroupKFold(n_splits=<span class="number">3</span>))</span><br><span class="line">print(<span class="string">'Cross-validation scores:\n&#123;&#125;'</span>.format(scores))</span><br></pre></td></tr></table></figure><p>基于这些标签计算得到的划分如图所示。对于每次划分，每个分组都是整体出现在训练集或测试集中。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_group_kfold()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/group-kfold.png"></p><p>scikit-learn 中还有很多交叉验证的划分策略，适用于更多的使用场景。标准的 <code>KFold</code>、<code>StratifiedKFold</code> 和 <code>GroupKFold</code> 是目前最常用的集中。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Machine Learning with Python </tag>
            
            <tag> cross-validation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maximum Subarray</title>
      <link href="/programming/leetcode/maximum-subarray/"/>
      <url>/programming/leetcode/maximum-subarray/</url>
      
        <content type="html"><![CDATA[<p>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure><h1 id="dynamic-programming">Dynamic Programming</h1><p>Let <code>dp[j]</code> denotes the largest sum of the subarray ending at j-th index.</p><ul><li>When <code>j = 0</code>, <code>dp[j] = A[j]</code>.</li><li>When <code>j &gt; 0</code>, since subarray must ending at j-th index <code>dp[j]</code>, there are two cases: <code>A[i..j]</code> (more than one element) or <code>A[j]</code> (just the last one element). Thus, <code>dp[j] = max(dp[j - 1] + A[j], A[j])</code>.</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubarray</span><span class="params">(self, nums: list)</span> -&gt; int:</span></span><br><span class="line">        curr = res = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            curr = max(curr, <span class="number">0</span>) + nums[i]</span><br><span class="line">            res = max(res, curr)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>Save the start and end index of the maximum subarray.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubarray</span><span class="params">(self, nums: list)</span> -&gt; tuple:</span></span><br><span class="line">        curr = res = nums[<span class="number">0</span>]</span><br><span class="line">        start = end = <span class="number">0</span></span><br><span class="line">        temp = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> curr &lt; <span class="number">0</span>:</span><br><span class="line">                curr, temp = <span class="number">0</span>, i</span><br><span class="line">            curr = curr + nums[i]</span><br><span class="line">            <span class="keyword">if</span> res &lt; curr:</span><br><span class="line">                res = curr</span><br><span class="line">                start, end = temp, i</span><br><span class="line">        <span class="keyword">return</span> start, end, res</span><br></pre></td></tr></table></figure><h1 id="divide-and-conquer">Divide and Conquer</h1><a href="/notes/introduction-to-algorithms/maximum-subarray-problems/" title="最大子数组问题">最大子数组问题</a>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> divide and conquer </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Edit Distance</title>
      <link href="/programming/leetcode/edit-distance/"/>
      <url>/programming/leetcode/edit-distance/</url>
      
        <content type="html"><![CDATA[<p>Given two words <em>word1</em> and <em>word2</em>, find the minimum number of operations required to convert <em>word1</em> to <em>word2</em>.</p><p>You have the following 3 operations permitted on a word:</p><ol type="1"><li>Insert a character</li><li>Delete a character</li><li>Replace a character</li></ol><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><h1 id="dynamic-programming">Dynamic Programming</h1><p><code>dp[i][j]</code> denotes minimum number of operations required to convert <code>word1[0..i)</code> to <code>word2[0..j)</code>。</p><p>Base cases:</p><p><code>m</code> is the length of <code>word1</code>, <code>n</code> is the length of <code>word2</code>.</p><ul><li><code>dp[i][0] = i</code>, convert <code>word1[0..i)</code> to <code>''</code>.</li><li><code>dp[0][j] = j</code>, convert <code>''</code> to <code>word2[0..j]</code>.</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp   0   1   2   ...   n</span><br><span class="line"> 0   0   1   2   ...   n</span><br><span class="line"> 1   1</span><br><span class="line"> 2   2</span><br><span class="line">... ...</span><br><span class="line"> m   m</span><br></pre></td></tr></table></figure><p>Induction rules:</p><ul><li>If <code>word1[i - 1] == word2[j - 1]</code>, then <code>dp[i][j] = dp[i - 1][j - 1]</code>. Since we need do nothing after we converted <code>word1[0..i - 1)</code> to <code>word2[0..j - 1)</code>.</li><li>If <code>word1[i - 1] != word2[j - 1]</code>, we have three cases to complete this convertion:<ul><li>Convert <code>word1[0..i - 1)</code> to <code>word2[0..j - 1)</code>, then replace <code>word1[i - 1]</code> by <code>word2[j - 1]</code>. So, <code>dp[i][j] = dp[i - 1][j - 1] + 1</code>.</li><li>Convert <code>word1[0..i)</code> to <code>word2[0..j - 1)</code>, then insert <code>word2[j - 1]</code>. So, <code>dp[i][j] = dp[i][j - 1] + 1</code>.</li><li>Delete <code>word1[i - 1]</code>. Then convert <code>word1[0..i - 1)</code> to <code>word2[0..j)</code>. So, <code>dp[i][j] = dp[i - 1][j] + 1</code>.</li></ul></li></ul><a id="more"></a><h2 id="bottom-up-variation">Bottom-Up Variation</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(mn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">        m, n = len(word1), len(word2)</span><br><span class="line">        dp = [[<span class="number">-1</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n + <span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = j</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">        m, n = len(word1), len(word2)</span><br><span class="line">        pre = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            curr = [i] * (n + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                curr[j] = min(pre[j] + <span class="number">1</span>,</span><br><span class="line">                              curr[j - <span class="number">1</span>] + <span class="number">1</span>,</span><br><span class="line">                              pre[j - <span class="number">1</span>] + (word1[i - <span class="number">1</span>] != word2[j - <span class="number">1</span>]))</span><br><span class="line">            pre = curr</span><br><span class="line">        <span class="keyword">return</span> pre[n]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">        m, n = len(word1), len(word2)</span><br><span class="line">        curr = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            pre = curr[<span class="number">0</span>]</span><br><span class="line">            curr[<span class="number">0</span>] = i</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                temp = curr[j]              <span class="comment"># curr[j] is not updated yet, curr[j] == dp[i - 1][j - 1]</span></span><br><span class="line">                curr[j] = min(curr[j] + <span class="number">1</span>,  <span class="comment"># update curr[j]</span></span><br><span class="line">                              curr[j - <span class="number">1</span>] + <span class="number">1</span>,</span><br><span class="line">                              pre + (word1[i - <span class="number">1</span>] != word2[j - <span class="number">1</span>]))</span><br><span class="line">                pre = temp                  <span class="comment"># save dp[i - 1][j - 1] to pre</span></span><br><span class="line">        <span class="keyword">return</span> curr[n]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Binary Tree Traversal</title>
      <link href="/programming/leetcode/binary-tree-traversal/"/>
      <url>/programming/leetcode/binary-tree-traversal/</url>
      
        <content type="html"><![CDATA[<h1 id="preinpost-order">Pre/In/Post Order</h1><p>Given a binary tree, return the <em>preorder/inorder/postorder</em> traversal of its nodes' values.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure><h2 id="recursion">Recursion</h2><p><img src="/uploads/image/leetcode/traversal.png"></p><p>Here the nodes are enumerated in the order you visit them, and you could follow <code>1-2-3-4-5</code> to compare different strategies.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root, res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                res.append(root.val)</span><br><span class="line">                helper(root.left, res)</span><br><span class="line">                helper(root.right, res)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        helper(root, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root, res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                helper(root.left, res)</span><br><span class="line">                res.append(root.val)</span><br><span class="line">                helper(root.right, res)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        helper(root, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root, res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                helper(root.left, res)</span><br><span class="line">                helper(root.right, res)</span><br><span class="line">                res.append(root.val)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        helper(root, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="iterating-method-using-stack">Iterating method using stack</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        res, stack = [], [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            curr = stack.pop()   <span class="comment"># first, visit</span></span><br><span class="line">            res.append(curr.val)</span><br><span class="line">            <span class="keyword">if</span> curr.right:       <span class="comment"># then, push right child</span></span><br><span class="line">                stack.append(curr.right)</span><br><span class="line">            <span class="keyword">if</span> curr.left:        <span class="comment"># last, push left child</span></span><br><span class="line">                stack.append(curr.left)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        res, stack = [], []</span><br><span class="line">        curr = root</span><br><span class="line">        <span class="keyword">while</span> curr <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> curr:</span><br><span class="line">                stack.append(curr)</span><br><span class="line">                curr = curr.left</span><br><span class="line">            curr = stack.pop()    <span class="comment"># Visit leftmost node, or you can image it as</span></span><br><span class="line">            res.append(curr.val)  <span class="comment"># the parent of a None node. Then, we need to</span></span><br><span class="line">            curr = curr.right     <span class="comment"># visit it's right subtree.</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        res, stack = [], []</span><br><span class="line">        curr, last_visit = root, <span class="literal">None</span>  <span class="comment"># need a variable to record if right subtree is visited</span></span><br><span class="line">        <span class="keyword">while</span> curr <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> curr:</span><br><span class="line">                stack.append(curr)</span><br><span class="line">                curr = curr.left</span><br><span class="line">            peek = stack[<span class="number">-1</span>]           <span class="comment"># leftmost node (parent node of a None node)</span></span><br><span class="line">            <span class="keyword">if</span> peek.right <span class="keyword">and</span> peek.right != last_visit:  <span class="comment"># if it's right subtree is not visited yet</span></span><br><span class="line">                curr = peek.right                          <span class="comment"># to visit it</span></span><br><span class="line">            <span class="keyword">else</span>:                                        <span class="comment"># else</span></span><br><span class="line">                last_visit = stack.pop()</span><br><span class="line">                res.append(last_visit.val)                 <span class="comment"># visit parent</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br><span class="line">   / \</span><br><span class="line">  6   7</span><br></pre></td></tr></table></figure><ul><li>Preorder: [1, 2, 4, 5, 6, 7, 3]</li></ul><table><thead><tr class="header"><th>res</th><th>stack</th></tr></thead><tbody><tr class="odd"><td>1</td><td>3, 2</td></tr><tr class="even"><td>1, 2</td><td>3, 5, 4</td></tr><tr class="odd"><td>1, 2, 4</td><td>3, 5</td></tr><tr class="even"><td>1, 2, 4, 5</td><td>3, 7, 6</td></tr><tr class="odd"><td>1, 2, 4, 5, 6</td><td>3, 7</td></tr><tr class="even"><td>1, 2, 4, 5, 6, 7</td><td>3</td></tr><tr class="odd"><td>1, 2, 4, 5, 6, 7, 3</td><td></td></tr></tbody></table><ul><li>Inorder: [4, 2, 6, 5, 7, 1, 3]</li></ul><table><thead><tr class="header"><th>res</th><th>curr</th><th>stack</th><th>explanation</th></tr></thead><tbody><tr class="odd"><td></td><td>1</td><td></td><td></td></tr><tr class="even"><td></td><td>None</td><td>1, 2, 4</td><td>state when exit the inner loop</td></tr><tr class="odd"><td>4</td><td>None</td><td>1, 2</td><td>curr = 4.right</td></tr><tr class="even"><td>4, 2</td><td>5</td><td>1</td><td>curr = 2.right</td></tr><tr class="odd"><td>4, 2</td><td>None</td><td>1, 5, 6</td><td>state when exit the inner loop</td></tr><tr class="even"><td>4, 2, 6</td><td>None</td><td>1, 5</td><td>curr = 6.right</td></tr><tr class="odd"><td>4, 2, 6, 5</td><td>7</td><td>1</td><td>curr = 5.right</td></tr><tr class="even"><td>4, 2, 6, 5</td><td>None</td><td>1, 7</td><td>state when exit the inner loop</td></tr><tr class="odd"><td>4, 2, 6, 5, 7</td><td>None</td><td>1</td><td>curr = 7.right</td></tr><tr class="even"><td>4, 2, 6, 5, 7, 1</td><td>3</td><td></td><td>stack is empty</td></tr><tr class="odd"><td>4, 2, 6, 5, 7, 1</td><td>None</td><td>3</td><td>state when exit the inner loop</td></tr><tr class="even"><td>4, 2, 6, 5, 7, 1, 3</td><td></td><td></td><td></td></tr></tbody></table><ul><li>Postorder: [4, 6, 7, 5, 2, 3, 1]</li></ul><table><thead><tr class="header"><th>res</th><th>curr</th><th>stack</th><th>last_visit</th><th>explanation</th></tr></thead><tbody><tr class="odd"><td></td><td>1</td><td></td><td>None</td><td></td></tr><tr class="even"><td></td><td>None</td><td>1, 2, 4</td><td>None</td><td>state when exit the inner loop</td></tr><tr class="odd"><td>4</td><td>None</td><td>1, 2</td><td>4</td><td>stack[-1].right is None</td></tr><tr class="even"><td>4</td><td>5</td><td>1, 2</td><td>4</td><td></td></tr><tr class="odd"><td>4</td><td>None</td><td>1, 2, 5, 6</td><td>4</td><td>state when exit the inner loop</td></tr><tr class="even"><td>4, 6</td><td>None</td><td>1, 2, 5</td><td>6</td><td></td></tr><tr class="odd"><td>4, 6</td><td>7</td><td>1, 2, 5</td><td>6</td><td>curr = stack[-1].right</td></tr><tr class="even"><td>4, 6</td><td>None</td><td>1, 2, 5, 7</td><td>6</td><td>state when exit the inner loop</td></tr><tr class="odd"><td>4, 6, 7</td><td>None</td><td>1, 2, 5</td><td>7</td><td>stack[-1].right == last_visit, goto else</td></tr><tr class="even"><td>4, 6, 7, 5</td><td>None</td><td>1, 2</td><td>5</td><td>stack[-1].right == last_visit, goto else</td></tr><tr class="odd"><td>4, 6, 7, 5, 2</td><td>None</td><td>1</td><td>2</td><td></td></tr><tr class="even"><td>4, 6, 7, 5, 2</td><td>3</td><td>1</td><td>2</td><td>curr = stack[-1].right</td></tr><tr class="odd"><td>4, 6, 7, 5, 2</td><td>None</td><td>1, 3</td><td>2</td><td>state when exit the inner loop</td></tr><tr class="even"><td>4, 6, 7, 5, 2, 3</td><td>None</td><td>1</td><td>3</td><td>stack[-1].right == last_visit, goto else</td></tr><tr class="odd"><td>4, 6, 7, 5, 2, 3, 1</td><td>None</td><td></td><td>1</td><td></td></tr></tbody></table><h1 id="morris-inorder-traversal">Morris Inorder Traversal</h1><p>In this method, we have to use a new data structure -- Threaded Binary Tree, and the strategy is as follows:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. Initialize current as root</span><br><span class="line">2. While current is not None</span><br><span class="line">    2.1 If current does not have left child</span><br><span class="line">        a. Add current&apos;s data</span><br><span class="line">        b. Go to the right, i.e. current = current.right</span><br><span class="line">    2.2 Else</span><br><span class="line">        a. In current&apos;s left subtree, make current the right child of the rightmost node</span><br><span class="line">        b. Go to this left child, i.e. current = current.left</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        res = []</span><br><span class="line">        curr, pre = root, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            <span class="keyword">if</span> curr.left:</span><br><span class="line">                pre = curr.left</span><br><span class="line">                <span class="keyword">while</span> pre.right:  <span class="comment"># find rightmost</span></span><br><span class="line">                    pre = pre.right</span><br><span class="line">                pre.right = curr   <span class="comment"># add an edge</span></span><br><span class="line">                temp = curr</span><br><span class="line">                curr = curr.left   <span class="comment"># move to left subtree</span></span><br><span class="line">                temp.left = <span class="literal">None</span>   <span class="comment"># delete an edge, avoid infinite loop</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(curr.val)</span><br><span class="line">                curr = curr.right  <span class="comment"># move to next right node</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>See a simple example to understand how it works:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  2</span><br><span class="line"> / \     Let N(2) represent the node which has value 2.</span><br><span class="line">1   3    curr = N(2) at the beginning.</span><br><span class="line"></span><br><span class="line">  2     N(1) is the rightmost node in left subtree,</span><br><span class="line"> ^ \    which means curr = N(2) is the successor node of N(1).</span><br><span class="line">1   3   So we add an edge N(1).right = N(2), we use &apos;^&apos; represent such edges.</span><br><span class="line">        Then, move curr = N(2).left = N(1).</span><br><span class="line">        And, we deleted the edge N(2).left.</span><br><span class="line"></span><br><span class="line">  2     Now, N(1).left is None, we can visit it.</span><br><span class="line"> ^ \    We added a &apos;.&apos; to represent a node has been visited.</span><br><span class="line">1.  3   Then, move curr = N(1).right = N(2).    &lt;-- The edge we added makes sense.</span><br><span class="line"></span><br><span class="line">  2.     Again, we check if curr has left child?</span><br><span class="line"> ^ \     No, since we has deleted the edge.</span><br><span class="line">1.  3.   So, we visit N(2).</span><br><span class="line">         Then, move curr = N(2).right = N(3). Visit it.</span><br></pre></td></tr></table></figure><p>As you can see, the tree is modified by algorithm. Can we avoid it?</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        res = []</span><br><span class="line">        curr, pre = root, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            <span class="keyword">if</span> curr.left:</span><br><span class="line">                pre = curr.left</span><br><span class="line">                <span class="comment"># add a condition: pre.right != curr</span></span><br><span class="line">                <span class="keyword">while</span> pre.right <span class="keyword">and</span> pre.right != curr:  <span class="comment"># find rightmost</span></span><br><span class="line">                    pre = pre.right</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> pre.right:  <span class="comment"># right child is None</span></span><br><span class="line">                    pre.right = curr  <span class="comment"># add an edge</span></span><br><span class="line">                    curr = curr.left  <span class="comment"># move to left subtree</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># pre.right == curr, means pre has benn visited</span></span><br><span class="line">                    pre.right = <span class="literal">None</span>  <span class="comment"># delete the edge we added before</span></span><br><span class="line">            res.append(curr.val)</span><br><span class="line">            curr = curr.right  <span class="comment"># move to next right node</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">1   3    curr = N(2) at the beginning.</span><br><span class="line"></span><br><span class="line">   2     N(1).right is None,</span><br><span class="line"> /^ \    So we add an edge N(1).right = N(2).</span><br><span class="line">1    3   Then, move curr = N(2).left = N(1).</span><br><span class="line"></span><br><span class="line">   2     Now, N(1).left is None, we can visit it.</span><br><span class="line"> /^ \    Then, move curr = N(1).right = N(2).</span><br><span class="line">1.   3</span><br><span class="line"></span><br><span class="line">  2.     Here comes the difference.</span><br><span class="line"> /  \    N(2).left = N(1), but N(1).right = curr.</span><br><span class="line">1.   3   Which means, N(1).right is the edge we added before.</span><br><span class="line">         So, we delete N(1).right, and visit curr N(2).</span><br><span class="line">         Then, move curr = curr.right = N(3).</span><br><span class="line"></span><br><span class="line">  2.     Visit N(3).</span><br><span class="line"> /  \    See, the tree is recovered after we traversed it.</span><br><span class="line">1.   3.</span><br></pre></td></tr></table></figure><h1 id="level-order">Level Order</h1><p>Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>Performance of stack and queue:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list, used as stack, append() and pop()</span><br><span class="line">    similar to</span><br><span class="line">collections.deque, used as stack, append() and pop()</span><br><span class="line">    similar to</span><br><span class="line">collections.deque, used as queue, append() and popleft() (or appendleft() and pop())</span><br><span class="line">    better than</span><br><span class="line">queue.Queue, queue, put() and get() (queue is synchronized)</span><br><span class="line">    similar to</span><br><span class="line">queue.LifoQueue, stack, put() and get()</span><br><span class="line">    much much better than</span><br><span class="line">list, used as queue, append() and pop(0) ()</span><br></pre></td></tr></table></figure><p>Docs:</p><p><a href="https://devdocs.io/python~3.6/library/queue" target="_blank" rel="noopener"><code>queue — A synchronized queue class</code></a></p><p><a href="https://devdocs.io/python~3.6/library/collections#collections.deque" target="_blank" rel="noopener"><code>collections.deque</code></a></p><h2 id="using-two-queues">Using two queues</h2><p>One queue stores nodes in current level, another stores nodes in next level.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res, cur = [], deque([root])</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            res.append([])</span><br><span class="line">            nxt = deque()  <span class="comment"># next level</span></span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                n = cur.popleft()  <span class="comment"># queue</span></span><br><span class="line">                res[<span class="number">-1</span>].append(n.val)</span><br><span class="line">                <span class="keyword">if</span> n.left:</span><br><span class="line">                    nxt.append(n.left)</span><br><span class="line">                <span class="keyword">if</span> n.right:</span><br><span class="line">                    nxt.append(n.right)</span><br><span class="line">            cur = nxt</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="using-a-queue-and-a-variable">Using a queue and a variable</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        cur, res = deque([root]), []</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            res.append([])</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(cur)):  <span class="comment"># number of nodes in current level</span></span><br><span class="line">                n = cur.popleft()  <span class="comment"># queue</span></span><br><span class="line">                res[<span class="number">-1</span>].append(n.val)</span><br><span class="line">                <span class="keyword">if</span> n.left:</span><br><span class="line">                    cur.append(n.left)</span><br><span class="line">                <span class="keyword">if</span> n.right:</span><br><span class="line">                    cur.append(n.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="zigzag-level-order">Zigzag Level Order</h1><p>Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="using-two-stacks">Using two stacks</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">           1</span><br><span class="line">      /         \</span><br><span class="line">     2           3</span><br><span class="line">   /   \       /   \</span><br><span class="line">  4     5     6     7</span><br><span class="line"> / \   / \   / \   / \</span><br><span class="line">8   9 10 11 12 13 14 15</span><br></pre></td></tr></table></figure><table><thead><tr class="header"><th>visit</th><th>stack1 (current level)</th><th>stack2 (next level)</th></tr></thead><tbody><tr class="odd"><td>1</td><td>2, 3</td><td></td></tr><tr class="even"><td>3</td><td>2</td><td>7, 6</td></tr><tr class="odd"><td>2</td><td></td><td>7, 6, 5, 4</td></tr><tr class="even"><td>4</td><td>8, 9</td><td>7, 6, 5</td></tr><tr class="odd"><td>5</td><td>8, 9, 10, 11</td><td>7, 6</td></tr><tr class="even"><td>6</td><td>8, 9, 10, 11, 12, 13</td><td>7</td></tr><tr class="odd"><td>7</td><td>8, 9, 10, 11, 12, 13, 14, 15</td><td></td></tr><tr class="even"><td>15</td><td>8, 9, 10, 11, 12, 13, 14</td><td></td></tr><tr class="odd"><td>...</td><td></td><td></td></tr></tbody></table><p>We need stack becacuse the visit order is changed each level, the node visit later in previous level, it's children will be visited earlier. That's exactly the property of stack.</p><p>And we need to note that the order to push children into stack is also different by level. From the example, we know if current level is visited from left, the order to push it's childern is (left, right); otherwise, (right, left).</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; list:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res, cur = [], deque([root])</span><br><span class="line">        reverse = <span class="literal">True</span>  <span class="comment"># add a flag</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            res.append([])</span><br><span class="line">            nxt = deque()</span><br><span class="line">            reverse = <span class="keyword">not</span> reverse  <span class="comment"># flip when a new level started</span></span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                n = cur.pop()</span><br><span class="line">                res[<span class="number">-1</span>].append(n.val)</span><br><span class="line">                <span class="keyword">if</span> reverse:</span><br><span class="line">                    <span class="keyword">if</span> n.right:</span><br><span class="line">                        nxt.append(n.right)</span><br><span class="line">                    <span class="keyword">if</span> n.left:</span><br><span class="line">                        nxt.append(n.left)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> n.left:</span><br><span class="line">                        nxt.append(n.left)</span><br><span class="line">                    <span class="keyword">if</span> n.right:</span><br><span class="line">                        nxt.append(n.right)</span><br><span class="line">            cur = nxt</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursion </tag>
            
            <tag> stack </tag>
            
            <tag> tree </tag>
            
            <tag> leetcode </tag>
            
            <tag> traversal </tag>
            
            <tag> level order </tag>
            
            <tag> morris </tag>
            
            <tag> preorder </tag>
            
            <tag> inorder </tag>
            
            <tag> postorder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Longest Valid Parentheses</title>
      <link href="/programming/leetcode/longest-valid-parentheses/"/>
      <url>/programming/leetcode/longest-valid-parentheses/</url>
      
        <content type="html"><![CDATA[<p>Given a string <code>s</code> containing just the characters <code>(</code> and <code>)</code>, find the length of the longest valid (well-formed) parentheses substring.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;(()&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;)()())&quot;</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><h1 id="dynamic-programming">Dynamic Programming</h1><p><code>dp[i]</code> denotes length of the longest valid substring ending at ith index.</p><p>Induction rules:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if s[i] == &apos;(&apos;:        # valid parentheses never end with &apos;(&apos;</span><br><span class="line">    dp[i] = 0</span><br><span class="line"></span><br><span class="line">if s[i] == &apos;)&apos;:</span><br><span class="line">    if s[i - 1] == &apos;(&apos;:                   # &apos;x()&apos;</span><br><span class="line">        # dp[i - 2] is the length of &apos;x&apos;, 2 is the length of &apos;()&apos;</span><br><span class="line">        dp[i] = dp[i - 2] + 2</span><br><span class="line"></span><br><span class="line">    # dp[i - 1] is the length of &apos;x&apos;</span><br><span class="line">    elif s[i - dp[i - 1] - 1] == &apos;(&apos;:     # &apos;y(x)&apos;</span><br><span class="line">        # dp[i - dp[i - 1] - 2] is the length of &apos;y&apos;</span><br><span class="line">        dp[i] = dp[i - dp[i - 1] - 2] + dp[i - 1] + 2</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        maxans = <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span>] * len(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">')'</span>:</span><br><span class="line">                <span class="keyword">if</span> s[i - <span class="number">1</span>] == <span class="string">'('</span>:</span><br><span class="line">                    dp[i] = dp[i - <span class="number">2</span>] + <span class="number">2</span></span><br><span class="line">                <span class="keyword">elif</span> i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> s[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">'('</span>:</span><br><span class="line">                    dp[i] = dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] + dp[i - <span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">            maxans = max(maxans, dp[i])</span><br><span class="line">        <span class="keyword">return</span> maxans</span><br></pre></td></tr></table></figure><h1 id="using-stack">Using Stack</h1><p>Initial, push -1 onto stack.</p><p>For every <code>'('</code> encountered, push its index onto the stack.</p><p>For every <code>')'</code> encountered, pop the topmost element and substract the current element's index from the new top element of the stack, which gives the length of the currently encountered valid string of parentheses. If while popping the element, the stack becomes empty, we push the current element's index onto the stack.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        maxans = <span class="number">0</span></span><br><span class="line">        stack = [<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'('</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">                <span class="keyword">if</span> stack:</span><br><span class="line">                    maxans = max(maxans, i - stack[<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> maxans</span><br></pre></td></tr></table></figure><h1 id="without-extra-space">Without extra space</h1><p>In this approach, we make use of two counters <code>left</code> and <code>right</code>.</p><p>First, we start traversing the string from the left towards the right and for every <code>'('</code> encountered, we increment the <code>left</code> counter and for every <code>')'</code> encountered, we increment the <code>right</code> counter. Whenever <code>left</code> becomes equal to <code>right</code>, we calculate the length of the current valid string and keep track of maximum length substring found so far. If <code>right</code> becomes greater than <code>left</code> we reset <code>left</code> and <code>right</code> to 0.</p><p>Next, we start traversing the string from right to left and similar procedure is applied.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        maxans = left = right = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:            <span class="comment"># left to right scan</span></span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">'('</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left == right:</span><br><span class="line">                maxans = max(maxans, <span class="number">2</span> * left)</span><br><span class="line">            <span class="keyword">elif</span> right &gt; left:</span><br><span class="line">                left = right = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> reversed(s):  <span class="comment"># right to left scan</span></span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">'('</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left == right:</span><br><span class="line">                maxans = max(maxans, <span class="number">2</span> * left)</span><br><span class="line">            <span class="keyword">elif</span> right &gt; left:</span><br><span class="line">                left = right = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> stack </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Longest Palindromic Substring</title>
      <link href="/programming/leetcode/longest-palindromic-substring/"/>
      <url>/programming/leetcode/longest-palindromic-substring/</url>
      
        <content type="html"><![CDATA[<p>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000。</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;cbbd&quot;</span><br><span class="line">Output: &quot;bb&quot;</span><br></pre></td></tr></table></figure><h1 id="dynamic-progromming">Dynamic Progromming</h1><p><code>dp[i][j]</code> denotes whether the substring <code>s[i..j]</code> is a palindrome.</p><p>Base cases:</p><ul><li><p><code>dp[i][i] = true</code>.</p></li><li><p><code>dp[i][i + 1] = s[i] == s[i + 1]</code>.</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s=&quot;xabaa&quot;</span><br><span class="line"></span><br><span class="line">dp  0  1  2  3  4</span><br><span class="line"> 0  T  F</span><br><span class="line"> 1     T  F</span><br><span class="line"> 2        T  F</span><br><span class="line"> 3           T  T</span><br><span class="line"> 4              T</span><br></pre></td></tr></table></figure><p>Induction rule:</p><p>If <code>s[i] == s[j]</code>, then <code>dp[i][j] = dp[i + 1][j - 1]</code>. i.e. <code>dp[i][j] = dp[i + 1][j - 1] and s[i] == s[j]</code>.</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2)</span></span><br><span class="line"><span class="comment"># Space: O(n^2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        n, start, stop = len(s), <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        dp = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> left <span class="keyword">in</span> range(right + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[left] == s[right] <span class="keyword">and</span> \</span><br><span class="line">                        (right - left &lt;= <span class="number">2</span> <span class="keyword">or</span> dp[left + <span class="number">1</span>][right - <span class="number">1</span>]):</span><br><span class="line">                    dp[left][right] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">if</span> stop - start &lt; right - left + <span class="number">1</span>:</span><br><span class="line">                        start, stop = left, right + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[start:stop]</span><br></pre></td></tr></table></figure><h1 id="expand-around-center">Expand Around Center</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(n^2)</span></span><br><span class="line"><span class="comment"># Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line"></span><br><span class="line">        start, end = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            len1 = self.expandAroundCenter(s, i, i)      <span class="comment"># length is odd</span></span><br><span class="line">            len2 = self.expandAroundCenter(s, i, i + <span class="number">1</span>)  <span class="comment"># length is even</span></span><br><span class="line">            len_max = max(len1, len2)</span><br><span class="line">            <span class="keyword">if</span> len_max &gt; end - start:  <span class="comment"># calculate the start and end of palindromic string</span></span><br><span class="line">                <span class="comment"># what a smart way</span></span><br><span class="line">                start = i - (len_max - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">                end = i + len_max // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> s[start:end + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expandAroundCenter</span><span class="params">(self, s: str, left: int, right: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; len(s) <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">            left, right = left - <span class="number">1</span>, right + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>  <span class="comment"># length of palindromic string</span></span><br></pre></td></tr></table></figure><h1 id="manachers-algorithm">Manacher's Algorithm</h1><p>// TODO //</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
            <tag> palindrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Regular Expression Matching</title>
      <link href="/programming/leetcode/regular-expression-matching/"/>
      <url>/programming/leetcode/regular-expression-matching/</url>
      
        <content type="html"><![CDATA[<p>Given an input string (<code>s</code>) and a pattern (<code>p</code>), implement regular expression matching with support for <code>'.'</code> and <code>'*'</code>.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;.&apos; Matches any single character.</span><br><span class="line">&apos;*&apos; Matches zero or more of the preceding element.</span><br></pre></td></tr></table></figure><p>The matching should cover the <strong>entire</strong> input string (not partial).</p><p><strong>Note:</strong></p><ul><li><code>s</code> could be empty and contains only lowercase letters <code>a-z</code>.</li><li><code>p</code> could be empty and contains only lowercase letters <code>a-z</code>, and characters like <code>.</code> or <code>*</code>.</li></ul><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;aa&quot;, p = &quot;a&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;aa&quot;, p = &quot;a*&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>Example 3:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;ab&quot;, p = &quot;.*&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>Example 4:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;aab&quot;, p = &quot;c*a*b&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>Example 5:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;mississippi&quot;, p = &quot;mis*is*p*&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><h1 id="recursion">Recursion</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, text: str, pattern: str)</span> -&gt; bool:</span></span><br><span class="line">        first_match = bool(text) <span class="keyword">and</span> pattern[<span class="number">0</span>] <span class="keyword">in</span> &#123;text[<span class="number">0</span>], <span class="string">'.'</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(pattern) &gt;= <span class="number">2</span> <span class="keyword">and</span> pattern[<span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">            <span class="keyword">return</span> (self.isMatch(text, pattern[<span class="number">2</span>:]) <span class="keyword">or</span>                  <span class="comment"># pattern[0:2] matches empty sequence</span></span><br><span class="line">                    first_match <span class="keyword">and</span> self.isMatch(text[<span class="number">1</span>:], pattern))    <span class="comment"># pattern[0:2] matches one character</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> first_match <span class="keyword">and</span> self.isMatch(text[<span class="number">1</span>:], pattern[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure><p>Time complexity: <span class="math inline">\(O((m+n)2^{m+\frac{n}{2}})\)</span>, where <code>m</code> is the length of text and <code>n</code> is the length of pattern.</p><p>Space complexity: <span class="math inline">\(O((m+n)2^{m+\frac{n}{2}})\)</span>.</p><a id="more"></a><h1 id="dynamic-programming">Dynamic Programming</h1><p><code>dp[i][j]</code> denotes wether <code>text[i..m]</code> matches <code>pattern[j..n]</code>. Indices start from 0.</p><p>Base cases:</p><ul><li><p><code>dp[i][n] = False</code>. when <code>i = 0, 1, ..., m-1</code>. Because <code>text[i:] != ''</code> but <code>pattern[n:] == ''</code>.</p></li><li><p><code>dp[m][n] = True</code>. Because <code>text[m:] == ''</code> and <code>pattern[n:] == ''</code>.</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp  0  1  2  ... n</span><br><span class="line"> 0               F</span><br><span class="line"> 1               F</span><br><span class="line"> 2               F</span><br><span class="line">...              F</span><br><span class="line"> m               T</span><br></pre></td></tr></table></figure><p>Induction rules:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If p[j + 1] == &apos;*&apos;:                 # p[j]p[j + 1] may match zero or many chars in text</span><br><span class="line">    dp[i][j] = dp[i][j + 2] or      # when match zero char, s[i] != p[j] is also acceptable</span><br><span class="line">               dp[i + 1][j] and (s[i] == p[j] or p[j] == &apos;.&apos;)  # or match one char</span><br><span class="line"></span><br><span class="line">if p[j + 1] != &apos;*&apos;:             # s[i] must match p[j] and s[i+1:] must match p[j+1:]</span><br><span class="line">    dp[i][j] = (s[i] == p[j] or p[j] == &apos;.&apos;) and dp[i + 1][j + 1]</span><br></pre></td></tr></table></figure><h2 id="top-down-variation">Top-Down Variation</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(mn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, text: str, pattern: str)</span> -&gt; bool:</span></span><br><span class="line">        memo = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> (i, j) <span class="keyword">not</span> <span class="keyword">in</span> memo:</span><br><span class="line">                <span class="keyword">if</span> j == len(pattern):</span><br><span class="line">                    ans = i == len(text)  <span class="comment"># dp(m, n) is true, otherwise false</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    first_match = i &lt; len(text) <span class="keyword">and</span> pattern[j] <span class="keyword">in</span> &#123;text[i], <span class="string">'.'</span>&#125;</span><br><span class="line">                    <span class="keyword">if</span> j + <span class="number">1</span> &lt; len(pattern) <span class="keyword">and</span> pattern[j + <span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                        ans = dp(i, j + <span class="number">2</span>) <span class="keyword">or</span> first_match <span class="keyword">and</span> dp(i + <span class="number">1</span>, j)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        ans = first_match <span class="keyword">and</span> dp(i + <span class="number">1</span>, j + <span class="number">1</span>)</span><br><span class="line">                memo[i, j] = ans</span><br><span class="line">            <span class="keyword">return</span> memo[i, j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp(<span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="bottom-up-variation">Bottom-Up Variation</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Time: O(mn)</span></span><br><span class="line"><span class="comment"># Space: O(mn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, text: str, pattern: str)</span> -&gt; bool:</span></span><br><span class="line">        dp = [[<span class="literal">False</span>] * (len(pattern) + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(text) + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">-1</span>][<span class="number">-1</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(text), <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(pattern) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                first_match = i &lt; len(text) <span class="keyword">and</span> pattern[j] <span class="keyword">in</span> &#123;text[i], <span class="string">'.'</span>&#125;</span><br><span class="line">                <span class="keyword">if</span> j + <span class="number">1</span> &lt; len(pattern) <span class="keyword">and</span> pattern[j + <span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                    dp[i][j] = dp[i][j + <span class="number">2</span>] <span class="keyword">or</span> first_match <span class="keyword">and</span> dp[i + <span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = first_match <span class="keyword">and</span> dp[i + <span class="number">1</span>][j + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
            <tag> matching </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据表示与特征工程</title>
      <link href="/notes/introduction-to-ml-with-python/representing-data-and-engineering-features/"/>
      <url>/notes/introduction-to-ml-with-python/representing-data-and-engineering-features/</url>
      
        <content type="html"><![CDATA[<p>到目前为止，我们一直假设数据是由浮点数组成的二维数组，其中每一列是描述数据点的<strong>连续特征</strong>（continuous feature）。对于许多应用而言，数据的收集方式并不是这样。一种常见的特征类型就是<strong>分类特征</strong>（categorical feature），也叫<strong>离散特征</strong>（discrete feature）。分类特征的例子包括产品的品牌、产品的颜色或产品的销售部门。这些都是描述一件产品的属性，但它们不以连续的方式变化。</p><p>无论数据包含哪种类型的特征，数据表示方式都会对机器学习模型的性能产生巨大影响。数据缩放非常重要。如果你没有缩放数据（比如，缩放到单位方差），那么你用厘米还是英寸表示测量数据的结果将会不同。用额外的特征<strong>扩充</strong>（augment）数据也很有帮助，比如添加特征的交互项（乘积）或更一般的多项式。</p><p>对于某个特定应用来说，如何找到最佳数据表示，这个问题被称为<strong>特征工程</strong>（feature engineering），它是数据科学家和机器学习从业者在尝试解决现实世界问题时主要任务之一。用正确的方式表示数据，对监督模型性能的影响比所选择的精确参数还要大。</p><a id="more"></a><h1 id="分类变量">分类变量</h1><p>作为例子，我们将使用美国成年人收入的数据集。adult数据集的任务是预测一名工人的收入是高于50 000美元还是低于50 000美元。这个数据集的特征包括工人的年龄、雇佣方式、教育水平、性别、每周工作时长、职业，等等。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> display</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件中没有包含列名称的表头，因此我们传入header=None</span></span><br><span class="line"><span class="comment"># 然后在"names"中显式地提供名称</span></span><br><span class="line">data = pd.read_csv(os.path.join(mglearn.datasets.DATA_PATH, <span class="string">"adult.data"</span>),</span><br><span class="line">    header=<span class="literal">None</span>, index_col=<span class="literal">False</span>,</span><br><span class="line">    names=[<span class="string">'age'</span>, <span class="string">'workclass'</span>, <span class="string">'fnlwgt'</span>, <span class="string">'education'</span>, <span class="string">'education-num'</span>,</span><br><span class="line">           <span class="string">'marital-status'</span>, <span class="string">'occupation'</span>, <span class="string">'relationship'</span>, <span class="string">'race'</span>, <span class="string">'gender'</span>,</span><br><span class="line">           <span class="string">'capital-gain'</span>, <span class="string">'capital-loss'</span>, <span class="string">'hours-per-week'</span>, <span class="string">'native-country'</span>,</span><br><span class="line">           <span class="string">'income'</span>])</span><br><span class="line"><span class="comment"># 只选其中几列</span></span><br><span class="line">data = data[[<span class="string">'age'</span>, <span class="string">'workclass'</span>, <span class="string">'education'</span>, <span class="string">'gender'</span>, <span class="string">'hours-per-week'</span>,</span><br><span class="line">             <span class="string">'occupation'</span>, <span class="string">'income'</span>]]</span><br><span class="line"></span><br><span class="line">display(data.head())</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   age          workclass  ...          occupation  income</span><br><span class="line">0   39          State-gov  ...        Adm-clerical   &lt;=50K</span><br><span class="line">1   50   Self-emp-not-inc  ...     Exec-managerial   &lt;=50K</span><br><span class="line">2   38            Private  ...   Handlers-cleaners   &lt;=50K</span><br><span class="line">3   53            Private  ...   Handlers-cleaners   &lt;=50K</span><br><span class="line">4   28            Private  ...      Prof-specialty   &lt;=50K</span><br><span class="line"></span><br><span class="line">[5 rows x 7 columns]</span><br></pre></td></tr></table></figure><p>在这个数据集中，age（年龄）和hours-per-week（每周工作时长）是连续特征。但workclass（工作类型）、education（教育程度）、gender（性别）、occupation（职业）都是分类特征，它们都来自一系列固定的可能取值（而不是一个范围），表示的是定性属性（而不是数量）。</p><p>假设我们想要在这个数据上学习一个Logistic回归分类器。Logistic回归利用下列公式进行预测：</p><p><span class="math display">\[\hat y=w[0]*x[0]+w[1]*x[1]+\dots+w[p]*x[p]+b&gt;0\]</span></p><p>其中 <span class="math inline">\(w[i]\)</span> 和 <span class="math inline">\(b\)</span> 是从训练集中学到的系数，<span class="math inline">\(x[i]\)</span> 是输入特征。当 <span class="math inline">\(x[i]\)</span> 是数字时这个公式才有意义，但如果 <span class="math inline">\(x[2]\)</span> 是 &quot;Masters&quot; 或 &quot;Bachelors&quot; 的话，这个公式则没有意义。显然，在应用Logistic回归时，我们需要换一种方式来表示数据。</p><h2 id="one-hot编码虚拟变量">One-Hot编码（虚拟变量）</h2><p>表示分类变量最常用的方法就是使用 <strong>one-hot编码</strong>（one-hot-encoding）或 <strong>N取一编码</strong>（one-out-of-N encoding），也叫<strong>虚拟变量</strong>（dummy variable）。虚拟变量背后的思想是将一个分类变量替换为一个或多个新特征，新特征取值为 0 和 1。对于线性二分类（以及 scikit-learn 中其他所有模型）的公式而言，0 和 1 这两个值是有意义的，我们可以对每个类别引入一个新特征，从而表示任意数量的类别。</p><p>比如说 workclass 特征的可能取值包括 &quot;Government Employee&quot;、&quot;Private Employee&quot;、&quot;Self Employed&quot; 和 &quot;Self Employed Incorporated&quot;。为了编码这4个可能的取值，我们创建了4个新特征，分别叫作 &quot;Government Employee&quot;、&quot;Private Employee&quot;、&quot;Self Employed&quot; 和 &quot;Self Employed Incorporated&quot;。如果一个人的 workclass 取某个值，那么对应的特征取值为 1，其他特征均取值为 0。因此，对每个数据点来说，4个新特征中只有一个的取值为 1。这就是它叫作 one-hot 编码或 N取一编码的原因。</p><blockquote><p>我们使用的 one-hot 编码与统计学中使用的虚拟编码（dummy encoding）非常相似，但并不完全相同。在统计学中，通常将具有 k 个可能取值的分类特征编码为 k-1 个特征（都等于零表示最后一个可能取值）。这么做是为了简化分析（更专业的说法是，这可以避免使数据矩阵秩亏）。</p></blockquote><p>将数据转换为分类变量的 one-hot 编码有两种方法：一种是使用 pandas，一种是使用 scikit-learn。</p><h3 id="检查字符串编码的分类数据">检查字符串编码的分类数据</h3><p>读取完数据集之后，最好先检查每一列是否包含有意义的分类数据。在处理人工（比如网站用户）输入的数据时，可能没有固定的类别，拼写和大小写也存在差异，因此可能需要预处理。检查列的内容有一个好方法，就是使用 pandas Series（Series 是 DataFrame 中单列对应的数据类型）的 values_counts 函数，以显示唯一值及其出现次数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(data.gender.value_counts())</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> Male      21790</span><br><span class="line"> Female    10771</span><br><span class="line">Name: gender, dtype: int64</span><br></pre></td></tr></table></figure><p>在这个数据集中性别刚好有两个值：Male 和 Female，这说明数据格式已经很好，可以用 one-hot 编码来表示。在实际的应用中，你应该检查所有列的值。</p><p>用 pandas 编码数据有一种非常简单的方法，就是使用 get_dummies 函数。get_dummies 函数自动变换所有具有对象类型（比如字符串）的列或所有分类的列（这是 pandas 中的一个特殊概念，还没有讲到）。</p><blockquote><p><a href="https://devdocs.io/pandas~0.25/reference/api/pandas.get_dummies" target="_blank" rel="noopener"><code>pandas.get_dummies(data, prefix=None, prefix_sep='_', dummy_na=False, columns=None, sparse=False, drop_first=False, dtype=None)</code></a></p><p>Convert categorical variable into dummy/indicator variables.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"Original features:\n"</span>, list(data.columns), <span class="string">"\n"</span>)</span><br><span class="line">data_dummies = pd.get_dummies(data)</span><br><span class="line">print(<span class="string">'Features after get_dummies:\n'</span>, list(data_dummies.columns))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Original features:</span><br><span class="line"> [&apos;age&apos;, &apos;workclass&apos;, &apos;education&apos;, &apos;gender&apos;, &apos;hours-per-week&apos;, &apos;occupation&apos;, &apos;income&apos;]</span><br><span class="line"></span><br><span class="line">Features after get_dummies:</span><br><span class="line"> [&apos;age&apos;, &apos;hours-per-week&apos;, &apos;workclass_ ?&apos;, &apos;workclass_ Federal-gov&apos;, &apos;workclass_ Local-gov&apos;, &apos;workclass_ Never-worked&apos;, &apos;workclass_ Private&apos;, &apos;workclass_ Self-emp-inc&apos;, &apos;workclass_ Self-emp-not-inc&apos;, &apos;workclass_ State-gov&apos;, &apos;workclass_ Without-pay&apos;, &apos;education_ 10th&apos;, &apos;education_ 11th&apos;, &apos;education_ 12th&apos;, &apos;education_ 1st-4th&apos;, &apos;education_ 5th-6th&apos;, &apos;education_ 7th-8th&apos;, &apos;education_ 9th&apos;, &apos;education_ Assoc-acdm&apos;, &apos;education_ Assoc-voc&apos;, &apos;education_ Bachelors&apos;, &apos;education_ Doctorate&apos;, &apos;education_ HS-grad&apos;, &apos;education_ Masters&apos;, &apos;education_ Preschool&apos;, &apos;education_ Prof-school&apos;, &apos;education_ Some-college&apos;, &apos;gender_ Female&apos;, &apos;gender_ Male&apos;, &apos;occupation_ ?&apos;, &apos;occupation_ Adm-clerical&apos;, &apos;occupation_ Armed-Forces&apos;, &apos;occupation_ Craft-repair&apos;, &apos;occupation_ Exec-managerial&apos;, &apos;occupation_ Farming-fishing&apos;, &apos;occupation_ Handlers-cleaners&apos;, &apos;occupation_ Machine-op-inspct&apos;, &apos;occupation_ Other-service&apos;, &apos;occupation_ Priv-house-serv&apos;, &apos;occupation_ Prof-specialty&apos;, &apos;occupation_ Protective-serv&apos;, &apos;occupation_ Sales&apos;, &apos;occupation_ Tech-support&apos;, &apos;occupation_ Transport-moving&apos;, &apos;income_ &lt;=50K&apos;, &apos;income_ &gt;50K&apos;]</span><br></pre></td></tr></table></figure><p>可以看到，连续特征 age 和 hours-per-week 没有发生变化，而分类特征的每个可能取值都被扩展为一个新特征。</p><p>下面我们可以使用 values 属性将 data_dummies 数据框（DataFrame）转换为 NumPy 数组，然后在其上训练一个机器学习模型。在训练模型之前，注意要把目标变量（现在被编码为两个 income 列）从数据中分离出来。</p><blockquote><p>注意：andas 中的列索引包括范围的结尾，因此 'age':'occupation_ Transport-moving' 中包括 occupation_ Transport-moving。这与 NumPy数组的切片不同，后者不包括范围的末尾，例如 <code>np.arange(11)[0:10]</code>不包括索引编号为 10 的元素。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">features = data_dummies.ix[:, <span class="string">'age'</span>:<span class="string">'occupation_ Transport-moving'</span>]</span><br><span class="line"><span class="comment"># 提取NumPy数组</span></span><br><span class="line">X = features.values</span><br><span class="line">y = data_dummies[<span class="string">'income_ &gt;50K'</span>].values</span><br><span class="line">print(<span class="string">'X.shape: &#123;&#125;  y.shape: &#123;&#125;'</span>.format(X.shape, y.shape))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X.shape: (32561, 44)  y.shape: (32561,)</span><br></pre></td></tr></table></figure><p>现在数据的表示方式可以被 scikit-learn 处理。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=<span class="number">0</span>)</span><br><span class="line">logreg = LogisticRegression()</span><br><span class="line">logreg.fit(X_train, y_train)</span><br><span class="line">print(<span class="string">'Test score: &#123;:.2f&#125;'</span>.format(logreg.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test score: 0.81</span><br></pre></td></tr></table></figure><p>在这个例子中，我们对同时包含训练数据和测试数据的数据框调用 get_dummies。这一点很重要，可以确保训练集和测试集中分类变量的表示方式相同。</p><p>假设我们的训练集和测试集位于两个不同的数据框中。如果 workclass 特征的 &quot;Private Employee&quot; 取值没有出现在测试集中，那么 pandas 会认为这个特征只有3个可能的取值，因此只会创建 3 个新的虚拟特征。现在训练集和测试集的特征个数不相同，我们就无法将在训练集上学到的模型应用到测试集上。</p><p>更糟糕的是，假设 workclass 特征在训练集中有 &quot;Government Employee&quot; 和 &quot;Private Employee&quot; 两个值，而在测试集中有 &quot;Self Employed&quot; 和 &quot;Self Employed Incorporated&quot; 两个值。在两种情况下，pandas 都会创建两个新的虚拟特征，所有编码后的数据框的特征个数相同。但在训练集和测试集中的两个虚拟特征含义完全不同。如果我们在这个数据上构建机器学习模型，那么它的表现会很差。要想避免这个问题，可以在同时包含训练数据点和测试数据点的数据框上调用 get_dummies，确保调用 get_dummies后训练集和测试集的列名称相同，保证它们具有相同的语义。</p><h2 id="数字可以编码分类变量">数字可以编码分类变量</h2><p>在 adult 数据集的例子中，分类变量被编码为字符串。一方面，可能会有拼写错误；但另一方面，它明确地将一个变量标记为分类变量。（然而）无论是为了便于存储还是因为数据的收集方式，分类变量通常被编码为整数。例如，假设 adult 数据集中的人口普查数据是利用问卷收集的，workclass 的回答被记录为 0（在第一个框打勾）、1、2，等等。现在该列包含数字 0 到 8，而不是像 &quot;Private&quot; 这样的字符串。如果有人观察表示数据集的表格，很难一眼看出这个变量应该被视为连续变量还是分类变量。但是，如果知道这些数字表示的是就业状况，那么很明显它们是不同的状态，不应该用单个连续变量来建模。</p><blockquote><p>分类特征通常用整数进行编码。它们是数字并不意味着它们必须被视为连续特征。一个整数特征应该被视为连续的还是离散的，有时并不明确。如果在被编码的语义之间没有顺序关系（比如 workclass 的例子），那么特征必须被视为离散特征。对于其他情况（比如五星评分），哪种编码更好取决于具体的任务和数据，以及使用哪种机器学习算法。</p></blockquote><p>pandas的 get_dummies 函数将所有数字看作是连续的，不会为其创建虚拟变量。为了解决这个问题，你可以使用 scikit-learn 的 OneHotEncoder，指定哪些变量是连续的、哪些变量是离散的，你也可以将数据框中的数值列转换为字符串。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个DataFrame，包含一个整数特征和一个分类字符串特征</span></span><br><span class="line">demo_df = pd.DataFrame(&#123;<span class="string">'Integer Feature'</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">                        <span class="string">'Categorical Feature'</span>: [<span class="string">'socks'</span>, <span class="string">'fox'</span>, <span class="string">'socks'</span>, <span class="string">'box'</span>]&#125;)</span><br><span class="line">display(demo_df)</span><br><span class="line"><span class="comment"># 使用 get_dummies 只会编码字符串特征，不会改变整数特征</span></span><br><span class="line">display(pd.get_dummies(demo_df))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   Integer Feature Categorical Feature</span><br><span class="line">0                0               socks</span><br><span class="line">1                1                 fox</span><br><span class="line">2                2               socks</span><br><span class="line">3                1                 box</span><br><span class="line">   Integer Feature  ...  Categorical Feature_socks</span><br><span class="line">0                0  ...                          1</span><br><span class="line">1                1  ...                          0</span><br><span class="line">2                2  ...                          1</span><br><span class="line">3                1  ...                          0</span><br><span class="line"></span><br><span class="line">[4 rows x 4 columns]</span><br></pre></td></tr></table></figure><p>如果你想为 &quot;Integer Feature&quot; 这一列创建虚拟变量，可以使用 columns 参数显示地给出想要编码的列。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">demo_df[<span class="string">'Integer Feature'</span>] = demo_df[<span class="string">'Integer Feature'</span>].astype(str)</span><br><span class="line">display(pd.get_dummies(demo_df, columns=[<span class="string">'Integer Feature'</span>, <span class="string">'Categorical Feature'</span>]))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   Integer Feature_0  ...  Categorical Feature_socks</span><br><span class="line">0                  1  ...                          1</span><br><span class="line">1                  0  ...                          0</span><br><span class="line">2                  0  ...                          1</span><br><span class="line">3                  0  ...                          0</span><br><span class="line"></span><br><span class="line">[4 rows x 6 columns]</span><br></pre></td></tr></table></figure><h1 id="分箱离散化线性模型与树">分箱、离散化、线性模型与树</h1><p>数据表示的最佳方法不仅取决于数据的语义，还取决于所使用的模型种类。线性模型与基于树的模型（比如决策树、梯度提升树和随机森林）是两种成员很多同时又非常常用的模型，它们在处理不同的特征表示时就具有非常不同的性质。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X, y = mglearn.datasets.make_wave(n_samples=<span class="number">100</span>)</span><br><span class="line">line = np.linspace(<span class="number">-3</span>, <span class="number">3</span>, <span class="number">1000</span>, endpoint=<span class="literal">False</span>).reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">reg = DecisionTreeRegressor(min_samples_split=<span class="number">3</span>).fit(X, y)</span><br><span class="line">plt.plot(line, reg.predict(line), label=<span class="string">"decision tree"</span>)</span><br><span class="line"></span><br><span class="line">reg = LinearRegression().fit(X, y)</span><br><span class="line">plt.plot(line, reg.predict(line), label=<span class="string">"linear regression"</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(X[:, <span class="number">0</span>], y, <span class="string">'o'</span>, c=<span class="string">'k'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Regression output'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Input feature'</span>)</span><br><span class="line">plt.legend(loc=<span class="string">'best'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/difference-between-tree-and-linear.png"></p><p>线性模型只能对线性关系建模，对于单个特征的情况就是直线。决策树可以构建更为复杂的数据模型，但这强烈依赖于数据表示。有一种方法可以让线性模型在连续数据上变得更加强大，就是使用特征<strong>分箱</strong>（binning，也叫<strong>离散化</strong>，即 discretization）将其划分为多个特征。</p><p>我们假设将特征的输入范围划分成固定个数的<strong>箱子</strong>（bin），比如 10 个，那么数据点就可以用它所在的箱子来表示。为了确定这一点，我们首先需要定义箱子。在这个例子中，我们在 -3 和 3 之间定义 10 个均匀分布的箱子。我们用 np.linspace 函数创建 11 个元素，从而创建 10 个箱子，即两个连续边界之间的空间。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bins = np.linspace(<span class="number">-3</span>, <span class="number">3</span>, <span class="number">11</span>)</span><br><span class="line">print(<span class="string">'bins: &#123;&#125;'</span>.format(bins))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bins: [-3.  -2.4 -1.8 -1.2 -0.6  0.   0.6  1.2  1.8  2.4  3. ]</span><br></pre></td></tr></table></figure><p>接下来，我们记录每个数据点所属的箱子。这可以用 np.digitize 函数轻松计算出来。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">which_bin = np.digitize(X, bins=bins)</span><br><span class="line">print(<span class="string">'Data points:\n'</span>, X[:<span class="number">5</span>])</span><br><span class="line">print(<span class="string">'\nBin membership for data points:\n'</span>, which_bin[:<span class="number">5</span>])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Data points:</span><br><span class="line"> [[-0.75275929]</span><br><span class="line"> [ 2.70428584]</span><br><span class="line"> [ 1.39196365]</span><br><span class="line"> [ 0.59195091]</span><br><span class="line"> [-2.06388816]]</span><br><span class="line"></span><br><span class="line">Bin membership for data points:</span><br><span class="line"> [[ 4]</span><br><span class="line"> [10]</span><br><span class="line"> [ 8]</span><br><span class="line"> [ 6]</span><br><span class="line"> [ 2]]</span><br></pre></td></tr></table></figure><p>我们在这里做的是将 wave 数据集中单个连续输入特征变换为一个分类特征，用于表示数据点所在的箱子。要想在这个数据上使用 scikit-learn 模型，我们利用 preprocessing 模块的 OneHotEncoder 将这个离散特征变换为 one-hot 编码。 OneHotEncoder 实现的编码与 pandas.get_dummies 相同，但目前它只适用于值为整数的分类变量。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.preprocessing.onehotencoder#sklearn.preprocessing.OneHotEncoder" target="_blank" rel="noopener"><code>class sklearn.preprocessing.OneHotEncoder(n_values=None, categorical_features=None, categories=None, sparse=True, dtype=&lt;class ‘numpy.float64’&gt;, handle_unknown=’error’)</code></a></p><p>Encode categorical integer features as a one-hot numeric array.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用OneHotEncoder进行变换</span></span><br><span class="line">encoder = OneHotEncoder(sparse=<span class="literal">False</span>)</span><br><span class="line">encoder.fit(which_bin)</span><br><span class="line">X_binned = encoder.transform(which_bin)</span><br><span class="line">print(X_binned[:<span class="number">5</span>])</span><br><span class="line"><span class="comment"># 由于我们指定了 10 个箱子，所以变换后的 X_binned 数据集现在包含 10 个特征</span></span><br><span class="line">print(<span class="string">'X_binned.shape: &#123;&#125;'</span>.format(X_binned.shape))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[0. 0. 0. 1. 0. 0. 0. 0. 0. 0.]</span><br><span class="line"> [0. 0. 0. 0. 0. 0. 0. 0. 0. 1.]</span><br><span class="line"> [0. 0. 0. 0. 0. 0. 0. 1. 0. 0.]</span><br><span class="line"> [0. 0. 0. 0. 0. 1. 0. 0. 0. 0.]</span><br><span class="line"> [0. 1. 0. 0. 0. 0. 0. 0. 0. 0.]]</span><br><span class="line">X_binned.shape: (100, 10)</span><br></pre></td></tr></table></figure><p>下面我们在 one-hot 编码后的数据上构建新的线性模型和新的决策树模型。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">line_binned = encoder.transform(np.digitize(line, bins=bins))</span><br><span class="line"></span><br><span class="line">reg = LinearRegression().fit(X_binned, y)</span><br><span class="line">plt.plot(line, reg.predict(line_binned), label=<span class="string">'linear regression binned'</span>)</span><br><span class="line"></span><br><span class="line">reg = DecisionTreeRegressor(min_samples_split=<span class="number">3</span>).fit(X_binned, y)</span><br><span class="line">plt.plot(line, reg.predict(line_binned), label=<span class="string">'decision tree binned'</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(X[:, <span class="number">0</span>], y, <span class="string">'o'</span>, c=<span class="string">'k'</span>)</span><br><span class="line">plt.vlines(bins, <span class="number">-3</span>, <span class="number">3</span>, linewidth=<span class="number">1</span>, alpha=<span class="number">.2</span>)</span><br><span class="line">plt.legend(loc=<span class="string">'best'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Regresson output'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Input feature'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/linear-and-tree-on-binned-data.png"></p><p>虚线和实线完全重合，说明线性回归模型和决策树模型做出了完全相同的预测。对于每个箱子，二者都预测一个常数值。因为每个箱子内的特征是不变的，所以对于一个箱子内的所有点，任何模型都会预测相同的值。</p><p>比较对特征进行分箱前后模型学到的内容，我们发现，线性模型变得更加灵活了，因为现在它对每个箱子具有不同的取值，而决策树模型的灵活性降低了。分箱特征对基于树的模型通常不会产生更好的效果，因为这种模型可以学习在任何位置划分数据。从某种意义上来看，决策树可以学习如何分箱对预测这些数据最为有用。此外，决策树可以同时查看多个特征，而分箱通常针对的是单个特征。不过，线性模型的表现力在数据变换后得到了极大的提高。</p><p><strong>对于特定的数据集，如果有充分的理由使用线性模型——比如数据集很大、维度很高，但有些特征与输出的关系是非线性的——那么分箱是提高建模能力的好方法。</strong></p><h1 id="交互特征与多项式特征">交互特征与多项式特征</h1><p>想要丰富特征表示，特别是对于线性模型而言，另一种方法是添加原始数据的<strong>交互特征</strong>（interaction feature）和<strong>多项式特征</strong>（polynomial feature）。这种特征工程通常用于统计建模，但也常用于许多实际的机器学习应用中。</p><p>线性模型对 wave 数据集中的每个箱子都学到一个常数值。但我们知道，线性模型不仅可以学习偏移，还可以学习斜率。想要向分箱数据上的线性模型添加斜率，一种方法是重新加入原始特征。这样会得到 11 维的数据集。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_combined = np.hstack([X, X_binned])</span><br><span class="line">print(<span class="string">'X_combined.shape: &#123;&#125;'</span>.format(X_combined.shape))</span><br><span class="line"></span><br><span class="line">line_combined = np.hstack([line, line_binned])</span><br><span class="line">reg = LinearRegression().fit(X_combined, y)</span><br><span class="line">plt.plot(line, reg.predict(line_combined), label=<span class="string">'linear regression combined'</span>)</span><br><span class="line">plt.plot(X[:, <span class="number">0</span>], y, <span class="string">'o'</span>, c=<span class="string">'k'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> bin <span class="keyword">in</span> bins:</span><br><span class="line">    plt.plot([bin, bin], [<span class="number">-3</span>, <span class="number">3</span>], <span class="string">':'</span>, c=<span class="string">'k'</span>)</span><br><span class="line">plt.legend(loc=<span class="string">'best'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Regresson output'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Input feature'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X_combined.shape: (100, 11)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/linear-regression-combined-on-binned-data.png"></p><p>在这个例子中，模型在每个箱子中都学到一个偏移，还学到一个斜率。学到的斜率在所有箱子中都相同——只有一个 x 轴特征，也就只有一个斜率。因为斜率在所有箱子中是相同的，所以它似乎不是很有用。我们更希望每个箱子都有一个不同的斜率。为了实现这一点，我们可以添加交互特征或乘积特征，用来表示数据点所在箱子以及数据点在 x 轴上的位置。这个特征是箱子指示符与原始特征的乘积。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_product = np.hstack([X_binned, X * X_binned])</span><br><span class="line">print(<span class="string">'X_product.shape: &#123;&#125;'</span>.format(X_product.shape))</span><br><span class="line"></span><br><span class="line">line_product = np.hstack([line_binned, line * line_binned])</span><br><span class="line"></span><br><span class="line">reg = LinearRegression().fit(X_product, y)</span><br><span class="line">plt.plot(line, reg.predict(line_product), label=<span class="string">'linear regression product'</span>)</span><br><span class="line">plt.plot(X[:, <span class="number">0</span>], y, <span class="string">'o'</span>, c=<span class="string">'k'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> bin <span class="keyword">in</span> bins:</span><br><span class="line">    plt.plot([bin, bin], [<span class="number">-3</span>, <span class="number">3</span>], <span class="string">':'</span>, c=<span class="string">'k'</span>)</span><br><span class="line">plt.legend(loc=<span class="string">'best'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Regresson output'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Input feature'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X_product.shape: (100, 20)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/linear-regression-product-on-binned-data.png"></p><p>这个数据集有20个特征：数据点所在箱子的指示符（10 个特征）与原始特征和箱子指示符的乘积（10 个特征）。你可以将乘积特征看作每个箱子 x 轴特征的单独副本。它在箱子内等于原始特征，在其他位置等于零。现在这个模型中，每个箱子都有自己的偏移和斜率。</p><p>使用分箱是扩展连续特征的一种方法。另一种方法是使用原始特征的<strong>多项式</strong>（polynomial）。对于给定特征 x，我们可以考虑 x ** 2、x ** 3、x ** 4，等等。这在 preprocessing 模块的 PolynomialFeatures 中实现。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.preprocessing.polynomialfeatures#sklearn.preprocessing.PolynomialFeatures" target="_blank" rel="noopener"><code>class sklearn.preprocessing.PolynomialFeatures(degree=2, interaction_only=False, include_bias=True)</code></a></p><p>Generate polynomial and interaction features.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 包含直到x ** 10的多项式</span></span><br><span class="line"><span class="comment"># 默认的"include_bias=True"添加恒等于1的常数特征</span></span><br><span class="line">poly = PolynomialFeatures(degree=<span class="number">10</span>, include_bias=<span class="literal">False</span>)</span><br><span class="line">poly.fit(X)</span><br><span class="line">X_poly = poly.transform(X)</span><br><span class="line">print(<span class="string">"X_poly.shape: &#123;&#125;"</span>.format(X_poly.shape))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较X_poly和X的元素</span></span><br><span class="line">print(<span class="string">'Entries of X:\n'</span>, X[:<span class="number">5</span>])</span><br><span class="line">print(<span class="string">'Entries of X_poly:\n'</span>, X_poly[:<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以通过调用get_feature_names方法来获取特征的语义，给出每个特征的指数</span></span><br><span class="line">print(<span class="string">'Polynomial feature names:\n'</span>, poly.get_feature_names())</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X_poly.shape: (100, 10)</span><br><span class="line">Entries of X:</span><br><span class="line"> [[-0.75275929]</span><br><span class="line"> [ 2.70428584]</span><br><span class="line"> [ 1.39196365]</span><br><span class="line"> [ 0.59195091]</span><br><span class="line"> [-2.06388816]]</span><br><span class="line">Entries of X_poly:</span><br><span class="line"> [[-7.52759287e-01  5.66646544e-01 -4.26548448e-01  3.21088306e-01</span><br><span class="line">  -2.41702204e-01  1.81943579e-01 -1.36959719e-01  1.03097700e-01</span><br><span class="line">  -7.76077513e-02  5.84199555e-02]</span><br><span class="line"> [ 2.70428584e+00  7.31316190e+00  1.97768801e+01  5.34823369e+01</span><br><span class="line">   1.44631526e+02  3.91124988e+02  1.05771377e+03  2.86036036e+03</span><br><span class="line">   7.73523202e+03  2.09182784e+04]</span><br><span class="line"> [ 1.39196365e+00  1.93756281e+00  2.69701700e+00  3.75414962e+00</span><br><span class="line">   5.22563982e+00  7.27390068e+00  1.01250053e+01  1.40936394e+01</span><br><span class="line">   1.96178338e+01  2.73073115e+01]</span><br><span class="line"> [ 5.91950905e-01  3.50405874e-01  2.07423074e-01  1.22784277e-01</span><br><span class="line">   7.26822637e-02  4.30243318e-02  2.54682921e-02  1.50759786e-02</span><br><span class="line">   8.92423917e-03  5.28271146e-03]</span><br><span class="line"> [-2.06388816e+00  4.25963433e+00 -8.79140884e+00  1.81444846e+01</span><br><span class="line">  -3.74481869e+01  7.72888694e+01 -1.59515582e+02  3.29222321e+02</span><br><span class="line">  -6.79478050e+02  1.40236670e+03]]</span><br><span class="line">Polynomial feature names:</span><br><span class="line"> [&apos;x0&apos;, &apos;x0^2&apos;, &apos;x0^3&apos;, &apos;x0^4&apos;, &apos;x0^5&apos;, &apos;x0^6&apos;, &apos;x0^7&apos;, &apos;x0^8&apos;, &apos;x0^9&apos;, &apos;x0^10&apos;]</span><br></pre></td></tr></table></figure><p>X_poly 的第一列与 X 完全对应，而其他列则是第一列的幂。将多项式特征与线性回归模型一起使用，可以得到经典的<strong>多项式回归</strong>（polynomial regression）模型。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">line_poly = poly.transform(line)</span><br><span class="line"></span><br><span class="line">reg = LinearRegression().fit(X_poly, y)</span><br><span class="line">plt.plot(line, reg.predict(line_poly), label=<span class="string">'polynomial linear regression'</span>)</span><br><span class="line">plt.plot(X[:, <span class="number">0</span>], y, <span class="string">'o'</span>, c=<span class="string">'k'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Regression output'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Input feature'</span>)</span><br><span class="line">plt.legend(loc=<span class="string">'best'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/polynomial-linear-regression.png"></p><p>多项式特征在这个一维数据上得到了非常平滑的拟合。但高次多项式在边界上或数据很少的区域可能有极端的表现。作为对比，下面是在原始数据上学到的核 SVM 模型，没有做任何变换。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVR</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> gamma <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">10</span>]:</span><br><span class="line">    svr = SVR(gamma=gamma).fit(X, y)</span><br><span class="line">    plt.plot(line, svr.predict(line), label=<span class="string">'SVR gamma=&#123;&#125;'</span>.format(gamma))</span><br><span class="line"></span><br><span class="line">plt.plot(X[:, <span class="number">0</span>], y, <span class="string">'o'</span>, c=<span class="string">'k'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Regression output'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Input feature'</span>)</span><br><span class="line">plt.legend(loc=<span class="string">'best'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/svr-on-source-data.png"></p><p>使用更复杂的模型（即核 SVM），我们能够学到一个与多项式回归的复杂度类似的预测结果，且不需要进行显示的特征变换。</p><p>我们再次观察波士顿房价数据集，作为对交互特征和多项式特征更加实际的应用。现在来看一下这些特征的构造方式，以及多项式特征的帮助有多大。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">boston = load_boston()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">    boston.data, boston.target, random_state=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 缩放数据</span></span><br><span class="line">scaler = MinMaxScaler()</span><br><span class="line">X_train_scaled = scaler.fit_transform(X_train)</span><br><span class="line">X_test_scaled = scaler.fit_transform(X_test)</span><br><span class="line"><span class="comment"># 提取多项式特征和交互特征，次数最高为 2</span></span><br><span class="line">poly = PolynomialFeatures(degree=<span class="number">2</span>).fit(X_train_scaled)</span><br><span class="line">X_train_poly = poly.transform(X_train_scaled)</span><br><span class="line">X_test_poly = poly.transform(X_test_scaled)</span><br><span class="line">print(<span class="string">'X_train.shape: &#123;&#125;'</span>.format(X_train.shape))</span><br><span class="line">print(<span class="string">'X_train_poly.shape: &#123;&#125;'</span>.format(X_train_poly.shape))</span><br><span class="line"><span class="comment"># 利用get_feature_names得到输入特征和输出特征之间的确切关系</span></span><br><span class="line">print(<span class="string">'Polynomial feature names:\n'</span>, poly.get_feature_names())</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X_train.shape: (379, 13)</span><br><span class="line">X_train_poly.shape: (379, 105)</span><br><span class="line">Polynomial feature names:</span><br><span class="line"> [&apos;1&apos;, &apos;x0&apos;, &apos;x1&apos;, &apos;x2&apos;, &apos;x3&apos;, &apos;x4&apos;, &apos;x5&apos;, &apos;x6&apos;, &apos;x7&apos;, &apos;x8&apos;, &apos;x9&apos;, &apos;x10&apos;, &apos;x11&apos;, &apos;x12&apos;, &apos;x0^2&apos;, &apos;x0 x1&apos;, &apos;x0 x2&apos;, &apos;x0 x3&apos;, &apos;x0 x4&apos;, &apos;x0 x5&apos;, &apos;x0 x6&apos;, &apos;x0 x7&apos;, &apos;x0 x8&apos;, &apos;x0 x9&apos;, &apos;x0 x10&apos;, &apos;x0 x11&apos;, &apos;x0 x12&apos;, &apos;x1^2&apos;, &apos;x1 x2&apos;, &apos;x1 x3&apos;, &apos;x1 x4&apos;, &apos;x1 x5&apos;, &apos;x1 x6&apos;, &apos;x1 x7&apos;, &apos;x1 x8&apos;, &apos;x1 x9&apos;, &apos;x1 x10&apos;, &apos;x1 x11&apos;, &apos;x1 x12&apos;, &apos;x2^2&apos;, &apos;x2 x3&apos;, &apos;x2 x4&apos;, &apos;x2 x5&apos;, &apos;x2 x6&apos;, &apos;x2 x7&apos;, &apos;x2 x8&apos;, &apos;x2 x9&apos;, &apos;x2 x10&apos;, &apos;x2 x11&apos;, &apos;x2 x12&apos;, &apos;x3^2&apos;, &apos;x3 x4&apos;, &apos;x3 x5&apos;, &apos;x3 x6&apos;, &apos;x3 x7&apos;, &apos;x3 x8&apos;, &apos;x3 x9&apos;, &apos;x3 x10&apos;, &apos;x3 x11&apos;, &apos;x3 x12&apos;, &apos;x4^2&apos;, &apos;x4 x5&apos;, &apos;x4 x6&apos;, &apos;x4 x7&apos;, &apos;x4 x8&apos;, &apos;x4 x9&apos;, &apos;x4 x10&apos;, &apos;x4 x11&apos;, &apos;x4 x12&apos;, &apos;x5^2&apos;, &apos;x5 x6&apos;, &apos;x5 x7&apos;, &apos;x5 x8&apos;, &apos;x5 x9&apos;, &apos;x5 x10&apos;, &apos;x5 x11&apos;, &apos;x5 x12&apos;, &apos;x6^2&apos;, &apos;x6 x7&apos;, &apos;x6 x8&apos;, &apos;x6 x9&apos;, &apos;x6 x10&apos;, &apos;x6 x11&apos;, &apos;x6 x12&apos;, &apos;x7^2&apos;, &apos;x7 x8&apos;, &apos;x7 x9&apos;, &apos;x7 x10&apos;, &apos;x7 x11&apos;, &apos;x7 x12&apos;, &apos;x8^2&apos;, &apos;x8 x9&apos;, &apos;x8 x10&apos;, &apos;x8 x11&apos;, &apos;x8 x12&apos;, &apos;x9^2&apos;, &apos;x9 x10&apos;, &apos;x9 x11&apos;, &apos;x9 x12&apos;, &apos;x10^2&apos;, &apos;x10 x11&apos;, &apos;x10 x12&apos;, &apos;x11^2&apos;, &apos;x11 x12&apos;, &apos;x12^2&apos;]</span><br></pre></td></tr></table></figure><p>原始数据有 13 个特征，现在被扩展到 105 个交互特征。这些新特征表示两个不同的原始特征之间所有可能的交互项，以及每个原始特征的平方。第一个新特征是常数特征，这里的名称是 &quot;1&quot;。接下来的 13 个特征是原始特征（&quot;x0&quot; 到 &quot;x12&quot;）。然后是第一个特征的平方（&quot;x0^2&quot;）以及它与其他特征的组合。</p><p>我们对 Ridge 在有交互特征的数据集上和没有交互特征的数据集上的性能进行比较。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ridge = Ridge().fit(X_train_scaled, y_train)</span><br><span class="line">print(<span class="string">'Score without interactions: &#123;:.3f&#125;'</span>.format(ridge.score(X_test_scaled, y_test)))</span><br><span class="line">ridge = Ridge().fit(X_train_poly, y_train)</span><br><span class="line">print(<span class="string">'Score with interactions: &#123;:.3f&#125;'</span>.format(ridge.score(X_test_poly, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Score without interactions: 0.577</span><br><span class="line">Score with interactions: 0.741</span><br></pre></td></tr></table></figure><p>显然，在使用 Ridge 时，交互特征和多项式特征对性能有很大的提升。但如果使用更加复杂的模型（比如随机森林），情况会稍有不同。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rf = RandomForestRegressor(n_estimators=<span class="number">100</span>).fit(X_train_scaled, y_train)</span><br><span class="line">print(<span class="string">'Score without interactions: &#123;:.3f&#125;'</span>.format(rf.score(X_test_scaled, y_test)))</span><br><span class="line">rf = RandomForestRegressor(n_estimators=<span class="number">100</span>).fit(X_train_poly, y_train)</span><br><span class="line">print(<span class="string">'Score with interactions: &#123;:.3f&#125;'</span>.format(rf.score(X_test_poly, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Score without interactions: 0.780</span><br><span class="line">Score with interactions: 0.755</span><br></pre></td></tr></table></figure><p>你可以看到，即使没有额外的特征，随机森林的性能也要优于 Ridge。添加交互特征和多项式特征实际上会略微降低其性能。</p><h1 id="单变量非线性变换">单变量非线性变换</h1><p>我们刚刚看到，<strong>添加特征的平方或立方可以改进线性回归模型</strong>。其他变换通常也对变换某些特征有用，特别是应用数学函数，比如 log、exp 或 sin。虽然基于树的模型只关注特征的顺序，但线性模型和神经网络依赖于每个特征的尺度和分布。如果在特征和目标之间存在非线性关系，那么建模就变得非常困难，特别是对于回归问题。log 和 exp 函数可以帮助调节数据的相对比例，从而改进线性模型或神经网络的学习效果。我们在第 2 章中对内存价格数据应用过这种函数。在处理具有周期性模式的数据时，sin 和 cos 函数非常有用。</p><p>大部分模型都在每个特征（在回归问题中还包括目标值）大致遵循高斯分布时表现最好，也就是说，每个特征的直方图应该具有类似于“钟形曲线”的形状。使用诸如 log 和 exp 之类的变换并不稀奇，却却是实现这一点的简单又有效的方法。在一种特别常见的情况下，这样的变换非常有用，就是处理整数计数数据时。计数数据是指类似“用户A多长时间登陆一次？”这样的特征。计数不可能取负值，并且通常遵循特定的统计模式。特征全都是整数值，而响应是连续的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rnd = np.random.RandomState(<span class="number">0</span>)</span><br><span class="line">X_org = rnd.normal(size=(<span class="number">1000</span>, <span class="number">3</span>))</span><br><span class="line">w = rnd.normal(size=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">X = rnd.poisson(<span class="number">10</span> * np.exp(X_org))</span><br><span class="line">y = np.dot(X_org, w)</span><br><span class="line"></span><br><span class="line">print(X[:<span class="number">10</span>, <span class="number">0</span>])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ 56  81  25  20  27  18  12  21 109   7]</span><br></pre></td></tr></table></figure><p>第一个特征的前 10 个元素都是正整数，但除此之外很难找出特定的模式。如果我们计算每个值的出现次数，那么数值的分布将变得更清楚。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'Number of feature appearances:\n'</span>, np.bincount(X[:, <span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">bins = np.bincount(X[:, <span class="number">0</span>])</span><br><span class="line">plt.bar(range(len(bins)), bins, color=<span class="string">'gray'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Number of appearances'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Value'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Number of feature appearances:</span><br><span class="line"> [28 38 68 48 61 59 45 56 37 40 35 34 36 26 23 26 27 21 23 23 18 21 10  9</span><br><span class="line"> 17  9  7 14 12  7  3  8  4  5  5  3  4  2  4  1  1  3  2  5  3  8  2  5</span><br><span class="line">  2  1  2  3  3  2  2  3  3  0  1  2  1  0  0  3  1  0  0  0  1  3  0  1</span><br><span class="line">  0  2  0  1  1  0  0  0  0  1  0  0  2  2  0  1  1  0  0  0  0  1  1  0</span><br><span class="line">  0  0  0  0  0  0  1  0  0  0  0  0  1  1  0  0  1  0  0  0  0  0  0  0</span><br><span class="line">  1  0  0  0  0  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1]</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/appearances-count-of-poisson.png"></p><p>特征 <code>X[:, 1]</code> 和 <code>X[:, 2]</code> 具有类似的性质。这种类型的数值分布（泊松分布）在实践中非常常见。但多数线性模型无法很好地处理这种数据。我们尝试拟合一个岭回归模型。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=<span class="number">0</span>)</span><br><span class="line">score = Ridge().fit(X_train, y_train).score(X_test, y_test)</span><br><span class="line">print(<span class="string">'Test score: &#123;:.3f&#125;'</span>.format(score))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test score: 0.622</span><br></pre></td></tr></table></figure><p>从相对较小的分数中可以看出，Ridge 无法真正捕捉到 X 和 y 之间的关系。不过应用对数变换可能有用。由于数据取值中包括 0（对数在 0 处没有定义），所以我们不能直接应用 log，而是要计算 log(X + 1)。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_train_log = np.log(X_train + <span class="number">1</span>)</span><br><span class="line">X_test_log = np.log(X_test + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">plt.hist(X_train_log[:, <span class="number">0</span>], bins=<span class="number">25</span>, color=<span class="string">'gray'</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Number of apperances"</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Value"</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/appearances-count-of-log-poisson.png"></p><p>在新数据上构建一个岭回归模型，可以得到更好地拟合。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">score = Ridge().fit(X_train_log, y_train).score(X_test_log, y_test)</span><br><span class="line">print(<span class="string">'Test score: &#123;:.3f&#125;'</span>.format(score))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test score: 0.875</span><br></pre></td></tr></table></figure><p>在这个例子中，所有特征都具有相同的性质，这在实践中是非常少见的情况。通常来说，只有一部分特征应该进行变换，有时每个特征的变换方式也各不相同。前面提到过，<strong>对基于树的模型而言，这种变换并不重要，但对线性模型来说可能至关重要。</strong>最回归的目标变量 y 进行变换有时也是一个好主意。尝试预计计数（比如订单数量）是一项相当常见的任务，而且使用 log(y + 1) 变换也往往有用。</p><p>分箱、多项式和交互项都对模型在给定数据集上的性能有很大影响，对于复杂度低的模型更是这样，比如线性模型和朴素贝叶斯模型。与之相反，基于树的模型通常能够自己发现重要的交互项，大多数情况下不需要显示地变换数据。其他模型，比如 SVM、最近邻和神经网络，有时可能会从分箱、交互项或多项式中受益，但其效果通常不如线性模型那么明显。</p><h1 id="自动化特征选择">自动化特征选择</h1><p>有了这么多种创建新特征的方法，你可能会想要增大数据的维度，使其远大于原始特征的数量。但是，添加更多特征会使所有模型变得更加复杂，从而增大过拟合的可能性。在添加新特征或处理一般的高纬度数据集时，最好将特征的数量减少到只包含最有用的那些特征，并删除其余特征。这样会得到泛化能力更好、更简单的模型。但你如何判断每个特征的作用有多大呢？有三种基本的策略：<strong>单变量统计</strong>（univariate statistics）、<strong>基于模型的选择</strong>（model-based selection）和<strong>迭代选择</strong>（iterative selection）。所有这些方法都是监督方法，即它们需要目标值来拟合模型。</p><h2 id="单变量统计">单变量统计</h2><p>在单变量统计中，我们计算每个特征和目标值之间的关系是否存在统计显著性，然后选择具有最高置信度的特征。对于分类问题，这也被称为<strong>方差分析</strong>（analysis of variance，ANOVA）。这些测试的一个关键性质就是它们是<strong>单变量的</strong>（univariate），即它们只单独考虑每个特征。因此，如果一个特征只有在与另一个特征合并时才具有信息量，那么这个特征将被舍弃。单变量测试的计算速度通常很快，并且不需要构建模型。另一方面，它们完全独立于你可能想要在特征选择之后应用的模型。</p><p>想要在 scikit-learn 中使用单变量特征选择，你需要选择一项测试——对分类问题通常是 f_classif（默认值），对回归问题通常是 f_regression——然后基于测试中确定的 p 值来选择一种舍弃特征的方法。所有舍弃参数的方法都使用阈值来舍弃所有 p 值过大的特征（意味着它们不可能与目标值相关）。计算阈值的方法各有不同，最简单的是 SelectKBest 和 SelectPercentile，前者选择固定数量的 k 个特征，后者选择固定百分比的特征。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.feature_selection.selectkbest#sklearn.feature_selection.SelectKBest" target="_blank" rel="noopener"><code>class sklearn.feature_selection.SelectKBest(score_func=&lt;function f_classif&gt;, k=10)</code></a></p><p>Select features according to the k highest scores.</p><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.feature_selection.selectpercentile#sklearn.feature_selection.SelectPercentile" target="_blank" rel="noopener"><code>class sklearn.feature_selection.SelectPercentile(score_func=&lt;function f_classif&gt;, percentile=10)</code></a></p><p>Select features according to a percentile of the highest scores.</p></blockquote><p>我们将分类的特征选择应用于 cancer 数据集。为了使任务更难一点，我们将向数据中添加一些没有信息量的噪声特征。我们期望特征选择能够识别没有信息量的特征并删除它们。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectPercentile</span><br><span class="line"></span><br><span class="line">cancer = load_breast_cancer()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得确定性的随机数</span></span><br><span class="line">rng = np.random.RandomState(<span class="number">42</span>)</span><br><span class="line">noise = rng.normal(size=(len(cancer.data), <span class="number">50</span>))</span><br><span class="line"><span class="comment"># 向数据中添加噪声特征</span></span><br><span class="line"><span class="comment"># 前30个特征来自数据集，后50个是噪声</span></span><br><span class="line">X_w_noise = np.hstack([cancer.data, noise])</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">    X_w_noise, cancer.target, random_state=<span class="number">0</span>, test_size=<span class="number">.5</span>)</span><br><span class="line"><span class="comment"># 使用f_classif（默认值）和SelectPercentile来选择50%的特征</span></span><br><span class="line">select = SelectPercentile(percentile=<span class="number">50</span>)</span><br><span class="line">select.fit(X_train, y_train)</span><br><span class="line"><span class="comment"># 对训练集进行变换</span></span><br><span class="line">X_train_selected = select.transform(X_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'X_train.shape:'</span>, X_train.shape)</span><br><span class="line">print(<span class="string">'X_train_selected.shape:'</span>, X_train_selected.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用get_support方法来查看那哪些特征被选中，它会返回所选特征的布尔遮罩（mask）</span></span><br><span class="line">mask = select.get_support()</span><br><span class="line">print(mask)</span><br><span class="line"><span class="comment"># 将遮罩可视化——黑色为True，白色为False</span></span><br><span class="line">plt.matshow(mask.reshape(<span class="number">1</span>, <span class="number">-1</span>), cmap=<span class="string">'gray_r'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Sample index'</span>)</span><br><span class="line">plt.yticks([<span class="number">0</span>])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X_train.shape: (284, 80)</span><br><span class="line">X_train_selected.shape: (284, 40)</span><br><span class="line">[ True  True  True  True  True  True  True  True  True False  True False</span><br><span class="line">  True  True  True  True  True  True False False  True  True  True  True</span><br><span class="line">  True  True  True  True  True  True False False False  True False  True</span><br><span class="line"> False False  True False False False False  True False False  True False</span><br><span class="line"> False  True False  True False False False False False False  True False</span><br><span class="line">  True False False False False  True False  True False False False False</span><br><span class="line">  True  True False  True False False False False]</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/features-selected-by-selectpercentile.png"></p><p>从遮罩层的可视化中可以看出，大多数所选择的特征都是原始特征，并且大多数噪声特征都已被删除。但原始特征的还原并不完美。我们来比较 Logistic 回归在所有特征上的性能与仅使用所选特征时的性能。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对测试集进行变换</span></span><br><span class="line">X_test_selected = select.transform(X_test)</span><br><span class="line"></span><br><span class="line">lr = LogisticRegression()</span><br><span class="line">lr.fit(X_train, y_train)</span><br><span class="line">print(<span class="string">'Score with all features: &#123;:.3f&#125;'</span>.format(lr.score(X_test, y_test)))</span><br><span class="line"></span><br><span class="line">lr.fit(X_train_selected, y_train)</span><br><span class="line">print(<span class="string">'Score with only selected features: &#123;:.3f&#125;'</span>.format(lr.score(X_test_selected, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Score with all features: 0.930</span><br><span class="line">Score with only selected features: 0.940</span><br></pre></td></tr></table></figure><p>在这个例子中，删除噪声特征可以提高性能，即使丢失了某些原始特征。这是一个非常简单的假想示例，在真实数据上的结果要更加复杂。不过，如果特征量太大以至于无法构建模型，或者你怀疑许多特征完全没有信息量，那么单变量特征选择还是非常有用的。</p><h2 id="基于模型的特征选择">基于模型的特征选择</h2><p>基于模型的特征选择使用一个监督机器学习模型来判断每个特征的重要性，并且仅保留最重要的特征。用于特征选择的监督模型不需要与用于最终监督检模型的模型相同。特征选择模型需要为每个特征提供某种重要性度量，以便用这个度量对特征进行排序。决策树和基于决策树的模型提供了 feature_importances_ 属性，可以直接编码每个特征的重要性。线性模型系数的绝对值也可以用于表示特征重要性。L1 惩罚的线性模型学到的是稀疏系数，它只用到了特征的一个很小的子集。这可以被视为模型本身的一种特征选择形式，但也可以用作另一个模型选择特征的预处理步骤。与单变量选择不同，基于模型的选择同时考虑所有特征，因此可以获取交互项（如果模型能够获取它们的话）。要想使用基于模型的特征选择，我们需要使用 SelectFromModel 变换器。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.feature_selection.selectfrommodel#sklearn.feature_selection.SelectFromModel" target="_blank" rel="noopener"><code>class sklearn.feature_selection.SelectFromModel(estimator, threshold=None, prefit=False, norm_order=1, max_features=None)</code></a></p><p>Meta-transformer for selecting features based on importance weights.</p></blockquote><p>SelectFromModel类选出重要性度量（由监督模型提供）大于给定阈值的所有特征。我们用包含 100 棵树的随机森林分类器来计算特征重要性。这是一个相当复杂的模型，也比单变量测试要强大得多。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectFromModel</span><br><span class="line"></span><br><span class="line">select = SelectFromModel(</span><br><span class="line">    RandomForestClassifier(n_estimators=<span class="number">100</span>, random_state=<span class="number">42</span>),</span><br><span class="line">    threshold=<span class="string">'median'</span>)</span><br><span class="line"></span><br><span class="line">select.fit(X_train, y_train)</span><br><span class="line">X_train_l1 = select.transform(X_train)</span><br><span class="line">print(<span class="string">'X_train.shape:'</span>, X_train.shape)</span><br><span class="line">print(<span class="string">'X_train_l1.shape:'</span>, X_train_l1.shape)</span><br><span class="line"></span><br><span class="line">X_test_l1 = select.transform(X_test)</span><br><span class="line">score = LogisticRegression().fit(X_train_l1, y_train).score(X_test_l1, y_test)</span><br><span class="line">print(<span class="string">'Test score: &#123;:.3f&#125;'</span>.format(score))</span><br><span class="line"></span><br><span class="line">mask = select.get_support()</span><br><span class="line">plt.matshow(mask.reshape(<span class="number">1</span>, <span class="number">-1</span>), cmap=<span class="string">'gray_r'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Sample index'</span>)</span><br><span class="line">plt.yticks([<span class="number">0</span>])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X_train.shape: (284, 80)</span><br><span class="line">X_train_l1.shape: (284, 40)</span><br><span class="line">Test score: 0.951</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/features-selected-by-selectfrommodel.png"></p><h2 id="迭代特征选择">迭代特征选择</h2><p>在单变量测试中，我们没有使用模型，而在基于模型的选择中，我们使用了单个模型来选择特征。在迭代特征选择中，将会构建一系列模型，每个模型都使用不同数量的特征。有两种基本方法：开始时没有特征，然后逐个添加特征，直到满足某个终止条件；或者从所有特征开始，然后逐个删除特征，直到满足某个终止条件。由于构建了一系列模型，所以这些方法的计算成本要比前面的方法更高。其中一种特殊的方法是<strong>递归特征消除</strong>（recursive feature elimination，RFE），它从所有特征开始构建模型，并根据模型舍弃最不重要的特征，然后使用剩余特征来构建一个新模型，如此继续，直到仅剩下预设数量的特征。为了让这种方法能够运行，用于选择的模型需要提供某种确定特征重要性的方法，正如基于模型的选择所做的那样。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.feature_selection.rfe#sklearn.feature_selection.RFE" target="_blank" rel="noopener"><code>class sklearn.feature_selection.RFE(estimator, n_features_to_select=None, step=1, verbose=0)</code></a></p><p>Feature ranking with recursive feature elimination.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> RFE</span><br><span class="line"></span><br><span class="line">select = RFE(RandomForestClassifier(n_estimators=<span class="number">100</span>, random_state=<span class="number">42</span>),</span><br><span class="line">    n_features_to_select=<span class="number">40</span>)</span><br><span class="line">select.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">mask = select.get_support()</span><br><span class="line">plt.matshow(mask.reshape(<span class="number">1</span>, <span class="number">-1</span>), cmap=<span class="string">'gray_r'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Sample index'</span>)</span><br><span class="line">plt.yticks([<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/features-selected-by-rfe.png"></p><p>与单变量选择和基于模型的选择相比，迭代特征选择的结果更好，但仍然漏掉了一个特征。运行上述代码需要的时间也比基于模型的选择要长得多，因为对一个随机森林模型训练了 40 次，每运行一次删除一个特含。我们来测试一下使用 RFE 做特征选择时 Logistic 回归模型的精度。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">score = LogisticRegression().fit(X_train_rfe, y_train).score(X_test_rfe, y_test)</span><br><span class="line">print(<span class="string">'Test score: &#123;:.3f&#125;'</span>.format(score))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test score: 0.951</span><br></pre></td></tr></table></figure><p>我们还可以利用在 RFE 内使用的模型来进行预测。这仅使用被选择的特征集。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'Test score: &#123;:.3f&#125;'</span>.format(select.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test score: 0.951</span><br></pre></td></tr></table></figure><p>这里，在 RFE 内部使用的随机森林的性能，与在所选特征上训练一个 Logistic 回归模型得到的性能相同。换句话说，只要我们选择了正确的特征，线性模型的表现就与随机森林一样好。</p><p>如果你不确定何时选择使用哪些特征作为机器学习算法的输入，那么自动化特征选择可能特别有用。它还有助于减少所需要的特征数量，加快预测速度，或允许可解释性更强的模型。在大多数现实情况下，使用特征选择不太可能大幅提升性能，但它仍是特征工程工具箱中一个非常有价值的工具。</p><h1 id="利用专家知识">利用专家知识</h1><p>对于特定应用来说，在特征工程中通常可以利用<strong>专家知识</strong>（expert knowledge）。虽然在许多情况下，机器学习的目的是避免创建一组专家设计的规则，但这并不意味着应该舍弃该应用或该领域的先验知识。通常来说，领域专家可以帮助找出有用的特征，其信息量比数据原始表示要大得多。</p><p>下面我们来看一个利用专家知识的特例。任务是预测在 Andreas 家门口的自行车出租。我们想要解决的任务是，对于给定的日期和时间，预测有多少人将会在 Andreas 的家门口租一辆自行车——这样他就知道是否还有自行车留给他。</p><p>我们首先将 2015 年 8 月的数据加载为一个 pandas 数据框。我们将数据重新采样为每 3 个小时一个数据，以得到每一天的主要趋势：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">citibike = mglearn.datasets.load_citibike()</span><br><span class="line">print(<span class="string">'Citi Bike data:\n'</span>, citibike.head())</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">3</span>))</span><br><span class="line">xticks = pd.date_range(start=citibike.index.min(), end=citibike.index.max(), freq=<span class="string">'D'</span>)</span><br><span class="line">plt.xticks(xticks, xticks.strftime(<span class="string">'%a %m-%d'</span>), rotation=<span class="number">90</span>, ha=<span class="string">'left'</span>)</span><br><span class="line">plt.plot(citibike, linewidth=<span class="number">1</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Data'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Rentals'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Citi Bike data:</span><br><span class="line"> starttime</span><br><span class="line">2015-08-01 00:00:00     3</span><br><span class="line">2015-08-01 03:00:00     0</span><br><span class="line">2015-08-01 06:00:00     9</span><br><span class="line">2015-08-01 09:00:00    41</span><br><span class="line">2015-08-01 12:00:00    39</span><br><span class="line">Freq: 3H, Name: one, dtype: int64</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/datasets-citibike.png"></p><p>观察此数据，我们可以清楚地区分每 24 小时中的白天和夜间。工作日和周末的模式似乎也有很大不同。在对这种时间序列上的预测任务进行评估时，我们通常希望<strong>从过去学习</strong>并<strong>预测未来</strong>。也就是说，在划分训练集和测试集的时候，我们希望使用某个特定日期之前的所有数据作为训练集，该日期之后的所有数据作为测试集。我们将使用前 184 个数据点（对应前 23 天）作为训练集，剩余的 64 个数据点（对应剩余的 8 天）作为测试集。</p><p>在我们的预测任务中，我们使用的唯一特征就是某一租车数量对应的日期和时间。因此输入特征是日期和时间，比如 2014-08-01 00:00:00，而输出是在接下来 3 小时内的租车数量（在这个例子中是 3）。</p><p>在计算机上存储日期的常用方式是使用 POSIX 时间，它是从 1970 年 1 月 1 日 00:00:00（也就是 Unix 时间的起点）起至现在的总秒数。首先，我们可以尝试使用这个单一整数特征作为数据表示。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提取目标值</span></span><br><span class="line">y = citibike.values</span><br><span class="line"><span class="comment"># 利用"%s"将时间转换为POSIX时间</span></span><br><span class="line">X = np.reshape(citibike.index.strftime(<span class="string">"%s"</span>).astype(<span class="string">"int"</span>), (<span class="number">-1</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，它可以将数据划分为训练集和测试集，构建模型并将结果可视化</span></span><br><span class="line">n_train = <span class="number">184</span>  <span class="comment"># 使用前184个数据点用于训练，剩余的数据点用于测试</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对给定特征集上的回归进行评估和作图的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval_on_features</span><span class="params">(features, target, regressor)</span>:</span></span><br><span class="line">    <span class="comment"># 将给定特征划分为训练集和测试集</span></span><br><span class="line">    X_train, X_test = features[:n_train], features[n_train:]</span><br><span class="line">    <span class="comment"># 同样划分目标数组</span></span><br><span class="line">    y_train, y_test = target[:n_train], target[n_train:]</span><br><span class="line">    regressor.fit(X_train, y_train)</span><br><span class="line">    print(<span class="string">'Test-set R^2: &#123;:.2f&#125;'</span>.format(regressor.score(X_test, y_test)))</span><br><span class="line"></span><br><span class="line">    y_pred = regressor.predict(X_test)</span><br><span class="line">    y_pred_train = regressor.predict(X_train)</span><br><span class="line">    plt.figure(figsize=(<span class="number">10</span>, <span class="number">3</span>))</span><br><span class="line">    plt.xticks(range(<span class="number">0</span>, len(X), <span class="number">8</span>), xticks.strftime(<span class="string">'%a %m-%d'</span>), rotation=<span class="number">90</span>, ha=<span class="string">'left'</span>)</span><br><span class="line">    plt.plot(range(n_train), y_train, label=<span class="string">'train'</span>)</span><br><span class="line">    plt.plot(range(n_train, len(y_test) + n_train), y_test, <span class="string">'-'</span>, label=<span class="string">'test'</span>)</span><br><span class="line"></span><br><span class="line">    plt.plot(range(n_train), y_pred_train, <span class="string">'--'</span>, label=<span class="string">'prediction train'</span>)</span><br><span class="line">    plt.plot(range(n_train, len(y_test) + n_train), y_pred, <span class="string">'--'</span>, label=<span class="string">'prediction test'</span>)</span><br><span class="line">    plt.legend(loc=(<span class="number">1.01</span>, <span class="number">0</span>))</span><br><span class="line">    plt.xlabel(<span class="string">'Date'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'Rentals'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用随机森林回归</span></span><br><span class="line">regressor = RandomForestRegressor(n_estimators=<span class="number">100</span>, random_state=<span class="number">0</span>)</span><br><span class="line">eval_on_features(X, y, regressor)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test-set R^2: -0.04</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/random-forest-on-citibike.png"></p><p>在训练集上的预测结果相当好，这符合随机森林通常的表现。但对于测试集来说，预测结果是一条常数直线。<span class="math inline">\(R^2\)</span>为 -0.04，说明我们什么都没有学到。发生了什么？</p><p>问题在于特征和随机森林的组合。测试集中 POSIX 时间特征的值超出了训练集中特征取值的范围：测试集中数据点的时间戳要晚于训练集中的所有数据点。树以及随机森林无法<strong>外推</strong>（extrapolate）到训练集之外的特征范围。结果就是模型只能预测训练集中最近数据点的目标值，即最后一次观测到数据的时间。</p><p>显然，我们可以做到更好。这就是我们的“专家知识”的用武之地。通过观察训练数据中的租车数量图像，我们发现两个因素似乎非常重要：一天内的时间与一周的星期几。因此我们来添加这两个特征。我们从 POSIX 时间中学不到任何东西，所以删掉这个特征。首先，我们仅使用每天的时刻。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_hour = np.reshape(citibike.index.hour, (<span class="number">-1</span>, <span class="number">1</span>))</span><br><span class="line">eval_on_features(X_hour, y, regressor)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test-set R^2: 0.60</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/random-forest-on-citibike-hour.png"></p><p><span class="math inline">\(R^2\)</span> 已经好多了，但预测结果显然没有抓住每周的模式，现在的预测结果对一周内的每天都具有相同的模式。下面我们添加一周的星期几作为特征。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_hour_week = np.hstack([np.reshape(citibike.index.dayofweek, (<span class="number">-1</span>, <span class="number">1</span>)),</span><br><span class="line">                          np.reshape(citibike.index.hour, (<span class="number">-1</span>, <span class="number">1</span>))])</span><br><span class="line">eval_on_features(X_hour_week, y, regressor)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test-set R^2: 0.84</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/random-forest-on-citibike-hour-week.png"></p><p>现在我们的模型通过考虑一周的星期几和一天内的时间捕捉到了周期性的行为。它的 <span class="math inline">\(R^2\)</span> 为 0.84，预测性能相当好。模型学到的内容可能是 8 月前 23 天中星期几与时刻每种组合的平均租车数量。这实际上不需要像随机森林这样复杂的模型，所以我们尝试一个更简单的模型——LinearRegression。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">eval_on_features(X_hour_week, y, LinearRegression())</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test-set R^2: 0.13</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/linear-regression-on-citibike.png"></p><p><strong>LinearRegression 的效果差得多，而且周期性模式看起来很奇怪。其原因在于我们用整数编码一周的星期几和一天内的时间，它们被解释为连续变量。</strong>因此，线性模型只能学到关于每天时间的线性函数——它学到的是，时间越晚，租车数量越多。但实际模式比这要复杂得多。我们可以通过将整数解释为分类变量（用 OneHotEncoder 进行变换）来获得这种模式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">enc = OneHotEncoder()</span><br><span class="line">X_hour_week_onehot = enc.fit_transform(X_hour_week).toarray()</span><br><span class="line">eval_on_features(X_hour_week_onehot, y, Ridge())</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test-set R^2: 0.62</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/ridge-on-citibike.png"></p><p>它给出了比连续特征编码好得多的匹配。现在线性模型为一周内的每天都学到了一个系数，为一天内的每个时刻都学到了一个系数。也就是说，一周七天共享“一天内每个时刻”的模式。</p><p>利用交互特征，我们可以让模型为星期几和时刻的每一种组合都学到一个系数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">poly_transformer = PolynomialFeatures(degree=<span class="number">2</span>, interaction_only=<span class="literal">True</span>, include_bias=<span class="literal">False</span>)</span><br><span class="line">X_hour_week_onehot_poly = poly_transformer.fit_transform(X_hour_week_onehot)</span><br><span class="line">lr = Ridge()</span><br><span class="line">eval_on_features(X_hour_week_onehot_poly, y, lr)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test-set R^2: 0.85</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/ridge-on-citibike-poly.png"></p><p>这一变换最终得到一个性能与随机森林类似的模型。这个模型的一大优点是，可以很清楚地看到学到的内容：对每个星期几和时刻的交互项学到了一个系数。我们可以将模型学到的系数作图，而这对于随机森林来说是不可能的（随机森林也有关于特征重要性的参数 <code>feature_importances_</code>，为何不可能？）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为时刻和星期几创建名称</span></span><br><span class="line">hour = [<span class="string">'%02d:00'</span> % i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">24</span>, <span class="number">3</span>)]</span><br><span class="line">day = [<span class="string">'Mon'</span>, <span class="string">'Tue'</span>, <span class="string">'Wed'</span>, <span class="string">'Thu'</span>, <span class="string">'Fri'</span>, <span class="string">'Sat'</span>, <span class="string">'Sun'</span>]</span><br><span class="line">features = day + hour</span><br><span class="line"><span class="comment"># 利用 get_feature_names 方法对 PolynomialFeatures 提取的所有交互特征进行命名</span></span><br><span class="line">features_poly = poly_transformer.get_feature_names(features)</span><br><span class="line">features_nonzero = np.array(features_poly)[lr.coef_ != <span class="number">0</span>]</span><br><span class="line">coef_nonzero = lr.coef_[lr.coef_ != <span class="number">0</span>]</span><br><span class="line"><span class="comment"># 将线性模型学到的系数可视化</span></span><br><span class="line">plt.figure(figsize=(<span class="number">15</span>, <span class="number">2</span>))</span><br><span class="line">plt.plot(coef_nonzero, <span class="string">'o'</span>)</span><br><span class="line">plt.xticks(np.arange(len(coef_nonzero)), features_nonzero, rotation=<span class="number">90</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Feature name'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature magnitude'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/coef-of-linear-regression-on-citibike.png"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Machine Learning with Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Useful Mac Apps</title>
      <link href="/mac/useful-mac-apps/"/>
      <url>/mac/useful-mac-apps/</url>
      
        <content type="html"><![CDATA[<h1 id="装机必备">装机必备</h1><table><thead><tr class="header"><th>名称</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a></td><td>最好用的软件包管理工具</td></tr><tr class="even"><td><a href="https://theunarchiver.com/" target="_blank" rel="noopener">The Unarchiver</a></td><td>最好用的解压缩工具</td></tr><tr class="odd"><td><a href="https://freemacsoft.net/appcleaner/" target="_blank" rel="noopener">AppCleaner</a></td><td>完全卸载应用</td></tr><tr class="even"><td><a href="https://mounty.app/" target="_blank" rel="noopener">Mounty for NTFS</a></td><td>读/写NTFS格式的卷</td></tr><tr class="odd"><td><a href="https://pock.dev/" target="_blank" rel="noopener">Pock</a></td><td>自定义Touch Bar</td></tr></tbody></table><a id="more"></a><h1 id="开发工具">开发工具</h1><table><thead><tr class="header"><th>名称</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><a href="https://www.jetbrains.com/toolbox-app/" target="_blank" rel="noopener">Jetbrains Toolbox</a></td><td>轻松管理Jetbrains开发工具</td></tr><tr class="even"><td><a href="https://devdocs.io/" target="_blank" rel="noopener">devdocs</a> / <a href="https://devdocs.egoist.moe/" target="_blank" rel="noopener">DevDocs Desktop</a></td><td>免费、开源的API文档</td></tr><tr class="odd"><td><a href="https://sequelpro.com/test-builds" target="_blank" rel="noopener">Sequel Pro</a></td><td>免费的数据库客户端</td></tr></tbody></table><h1 id="下载工具">下载工具</h1><table><thead><tr class="header"><th>名称</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><a href="https://github.com/ytdl-org/youtube-dl" target="_blank" rel="noopener">youtube-dl</a></td><td>下载油管上的视频，命令行工具</td></tr><tr class="even"><td><a href="https://www.jihosoft.cn/tubeget/" target="_blank" rel="noopener">Gihosoft TubeGet</a></td><td>下载油管上的视频，app</td></tr><tr class="odd"><td><a href="https://www.freedownloadmanager.org/zh/" target="_blank" rel="noopener">Free Download Manager(FDM)</a></td><td>IDM的优秀替代</td></tr></tbody></table><h1 id="谷歌浏览器扩展">谷歌浏览器扩展</h1><table><thead><tr class="header"><th>名称</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><a href="https://chrome.google.com/webstore/detail/free-download-manager/ahmpjcflkgiildlgicmcieglgoilbfdp" target="_blank" rel="noopener">Free Download Manager</a></td><td>搭配FDM使用</td></tr><tr class="even"><td><a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo" target="_blank" rel="noopener">Tampermonkey</a></td><td>管理用户脚本</td></tr><tr class="odd"><td></td><td><a href="https://greasyfork.org/zh-CN/scripts/25718-%E8%A7%A3%E9%99%A4b%E7%AB%99%E5%8C%BA%E5%9F%9F%E9%99%90%E5%88%B6" target="_blank" rel="noopener">解除B站区域限制</a></td></tr><tr class="even"><td></td><td><a href="https://greasyfork.org/zh-CN/scripts/1682-google-hit-hider-by-domain-search-filter-block-sites" target="_blank" rel="noopener">Google Hit Hider by Domain (Search Filter / Block Sites)</a></td></tr><tr class="odd"><td><a href="https://chrome.google.com/webstore/detail/neteasemusicworld%2B/pjcgkmiglhiambjngnljkdpoggonlnfe" target="_blank" rel="noopener">NetEaseMusicWorld+</a></td><td>解锁网易云音乐的海外播放</td></tr><tr class="even"><td><a href="https://chrome.google.com/webstore/detail/%E5%B9%BF%E5%91%8A%E7%BB%88%E7%BB%93%E8%80%85/fpdnjdlbdmifoocedhkighhlbchbiikl" target="_blank" rel="noopener">广告终结者</a></td><td>清除网页上的所有广告</td></tr></tbody></table><h1 id="音乐视频">音乐视频</h1><table><thead><tr class="header"><th>名称</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><a href="https://iina.io/" target="_blank" rel="noopener">IINA</a></td><td>（最）好用的视频播放器</td></tr><tr class="even"><td><a href="http://deadbeatsw.com/thetagger/" target="_blank" rel="noopener">The Tagger</a></td><td>修改MP3和AAC的标签</td></tr></tbody></table><h1 id="社交">社交</h1><table><thead><tr class="header"><th>名称</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><a href="https://weiboformac.sinaapp.com/" target="_blank" rel="noopener">Maipo for Weibo</a></td><td>新浪微博的非官方客户端</td></tr><tr class="even"><td><a href="https://sparkmailapp.com/zh" target="_blank" rel="noopener">Spark</a></td><td>简单易用的邮件客户端</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> app </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>No Xcode or CLT version detected</title>
      <link href="/programming/no-xcode-or-clt-version-detected/"/>
      <url>/programming/no-xcode-or-clt-version-detected/</url>
      
        <content type="html"><![CDATA[<p>If your Mac has been upgraded to macOS Catalina (10.15), please read <a href="https://github.com/nodejs/node-gyp/blob/master/macOS_Catalina.md" target="_blank" rel="noopener">macOS_Catalina.md</a>.</p><p>解决方法：</p><p>安装所需的编译器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure><p>或重新安装</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm -rf $(xcode-select -print-path)</span><br><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sklearn bunch</title>
      <link href="/source-code/sklearn-bunch/"/>
      <url>/source-code/sklearn-bunch/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><figcaption><span>utils.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bunch</span><span class="params">(dict)</span>:</span></span><br><span class="line">    <span class="string">"""Container object for datasets</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Dictionary-like object that exposes its keys as attributes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; b = Bunch(a=1, b=2)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; b['b']</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; b.b</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; b.a = 3</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; b['a']</span></span><br><span class="line"><span class="string">    3</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; b.c = 6</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; b['c']</span></span><br><span class="line"><span class="string">    6</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        super().__init__(kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        self[key] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__dir__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.keys()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self[key]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(key)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dict </tag>
            
            <tag> sklearn </tag>
            
            <tag> special method </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cplex cutting stock</title>
      <link href="/source-code/cplex-cutting-stock/"/>
      <url>/source-code/cplex-cutting-stock/</url>
      
        <content type="html"><![CDATA[<h1 id="源码">源码</h1><figure class="highlight python"><figcaption><span>cutstock.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># File: cutstock.py</span></span><br><span class="line"><span class="comment"># Version 12.9.0</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Licensed Materials - Property of IBM</span></span><br><span class="line"><span class="comment"># 5725-A06 5725-A29 5724-Y48 5724-Y49 5724-Y54 5724-Y55 5655-Y21</span></span><br><span class="line"><span class="comment"># Copyright IBM Corporation 2009, 2019. All Rights Reserved.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># US Government Users Restricted Rights - Use, duplication or</span></span><br><span class="line"><span class="comment"># disclosure restricted by GSA ADP Schedule Contract with</span></span><br><span class="line"><span class="comment"># IBM Corp.</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Using column generation</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Problem Description:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">The cutting stock problem in this example is sometimes known in math</span></span><br><span class="line"><span class="string">programming terms as a knapsack problem with reduced costs in the</span></span><br><span class="line"><span class="string">objective function. Generally, a cutting stock problem begins with a</span></span><br><span class="line"><span class="string">supply of rolls of material of fixed length (the stock). Strips are cut</span></span><br><span class="line"><span class="string">from these rolls. All the strips cut from one roll are known together as</span></span><br><span class="line"><span class="string">a pattern. The point of this example is to use as few rolls of stock as</span></span><br><span class="line"><span class="string">possible to satisfy some specified demand of strips. By convention, it is</span></span><br><span class="line"><span class="string">assumed that only one pattern is laid out across the stock; consequently,</span></span><br><span class="line"><span class="string">only one dimension (the width) of each roll of stock is important.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">To run from the command line, use</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   python cutstock.py</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cplex</span><br><span class="line"><span class="keyword">from</span> cplex.exceptions <span class="keyword">import</span> CplexSolverError</span><br><span class="line"><span class="keyword">from</span> cplex <span class="keyword">import</span> SparsePair</span><br><span class="line"><span class="keyword">from</span> cplex.six.moves <span class="keyword">import</span> zip</span><br><span class="line"><span class="keyword">from</span> inputdata <span class="keyword">import</span> read_dat_file</span><br><span class="line"></span><br><span class="line">RC_EPS = <span class="number">1.0e-6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">report1</span><span class="params">(cut)</span>:</span></span><br><span class="line">    <span class="string">"""Print a report about the current solution in the cutting</span></span><br><span class="line"><span class="string">    optimization problem given by the cut argument.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    print()</span><br><span class="line">    print(<span class="string">"Using "</span> + str(cut.solution.get_objective_value()) + <span class="string">" rolls"</span>)</span><br><span class="line">    print()</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> range(cut.variables.get_num()):</span><br><span class="line">        print(<span class="string">"  Cut"</span> + str(v) + <span class="string">" = "</span> + str(cut.solution.get_values(v)))</span><br><span class="line">    print()</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> range(cut.linear_constraints.get_num()):</span><br><span class="line">        print(<span class="string">"  Fill"</span> + str(c) + <span class="string">" = "</span> + str(cut.solution.get_dual_values(c)))</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">report2</span><span class="params">(pat, use)</span>:</span></span><br><span class="line">    <span class="string">"""Print a report about the current solution in the pattern generation</span></span><br><span class="line"><span class="string">    problem given by the pat argument. The use argument specifies the indices</span></span><br><span class="line"><span class="string">    of variables that shall appear in the report.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print()</span><br><span class="line">    print(<span class="string">"Reduced cost is "</span> + str(pat.solution.get_objective_value()))</span><br><span class="line">    print()</span><br><span class="line">    <span class="keyword">if</span> pat.solution.get_objective_value() &lt;= -RC_EPS:</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> use:</span><br><span class="line">            print(<span class="string">"  Use"</span> + str(v) + <span class="string">" = "</span> + str(pat.solution.get_values(v)))</span><br><span class="line">        print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">report3</span><span class="params">(cut)</span>:</span></span><br><span class="line">    <span class="string">"""Print the final report for the current solution in the cutting</span></span><br><span class="line"><span class="string">    optimization problem given by the cut argument.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print()</span><br><span class="line">    print(<span class="string">"Best integer solution uses "</span> +</span><br><span class="line">          str(cut.solution.get_objective_value()) + <span class="string">" rolls"</span>)</span><br><span class="line">    print()</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> range(cut.variables.get_num()):</span><br><span class="line">        print(<span class="string">"  Cut"</span> + str(v) + <span class="string">" = "</span> + str(cut.solution.get_values(v)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cutstock</span><span class="params">(datafile)</span>:</span></span><br><span class="line">    <span class="comment"># Input data. If no file is given on the command line then use a</span></span><br><span class="line">    <span class="comment"># default file name. The data read is</span></span><br><span class="line">    <span class="comment"># width  - the width of the the roll,</span></span><br><span class="line">    <span class="comment"># size   - the sie of each strip,</span></span><br><span class="line">    <span class="comment"># amount - the demand for each strip.</span></span><br><span class="line">    width, size, amount = read_dat_file(datafile)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Setup cutting optimization (master) problem.</span></span><br><span class="line">    <span class="comment"># This is the problem to which columns will be added in the loop</span></span><br><span class="line">    <span class="comment"># below.</span></span><br><span class="line">    cut = cplex.Cplex()</span><br><span class="line">    cut.set_results_stream(<span class="literal">None</span>)</span><br><span class="line">    cutcons = list(range(len(amount)))   <span class="comment"># constraint indices</span></span><br><span class="line">    cutvars = list(range(len(size)))     <span class="comment"># variable indices</span></span><br><span class="line">    cut.variables.add(obj=[<span class="number">1</span>] * len(cutvars))</span><br><span class="line">    <span class="comment"># Add constraints. They have empty left-hand side initially. The</span></span><br><span class="line">    <span class="comment"># left-hand side is filled in the next loop.</span></span><br><span class="line">    cut.linear_constraints.add(lin_expr=[SparsePair()] * len(cutcons),</span><br><span class="line">                               senses=[<span class="string">"G"</span>] * len(cutcons),</span><br><span class="line">                               rhs=amount)</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> cutvars:</span><br><span class="line">        cut.linear_constraints.set_coefficients(v, v, int(width / size[v]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Setup pattern generation (worker) problem.</span></span><br><span class="line">    <span class="comment"># The constraints and variables in this problem always stay the same</span></span><br><span class="line">    <span class="comment"># but the objective function will change during the column generation</span></span><br><span class="line">    <span class="comment"># loop.</span></span><br><span class="line">    pat = cplex.Cplex()</span><br><span class="line">    pat.set_results_stream(<span class="literal">None</span>)</span><br><span class="line">    use = list(range(len(size)))         <span class="comment"># variable indices</span></span><br><span class="line">    pat.variables.add(types=[pat.variables.type.integer] * len(use))</span><br><span class="line">    <span class="comment"># Add a constant 1 to the objective.</span></span><br><span class="line">    pat.variables.add(obj=[<span class="number">1</span>], lb=[<span class="number">1</span>], ub=[<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># Single constraint: total size must not exceed the width.</span></span><br><span class="line">    totalsize = SparsePair(ind=use, val=size)</span><br><span class="line">    pat.linear_constraints.add(lin_expr=[totalsize],</span><br><span class="line">                               senses=[<span class="string">"L"</span>],</span><br><span class="line">                               rhs=[width])</span><br><span class="line">    pat.objective.set_sense(pat.objective.sense.minimize)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Column generation procedure</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Optimize over current patterns</span></span><br><span class="line">        cut.solve()</span><br><span class="line">        report1(cut)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Find and add new pattern. The objective function of the</span></span><br><span class="line">        <span class="comment"># worker problem is constructed from the dual values of the</span></span><br><span class="line">        <span class="comment"># constraints of the master problem.</span></span><br><span class="line">        price = [-d <span class="keyword">for</span> d <span class="keyword">in</span> cut.solution.get_dual_values(cutcons)]</span><br><span class="line">        pat.objective.set_linear(list(zip(use, price)))</span><br><span class="line">        pat.solve()</span><br><span class="line">        report2(pat, use)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># If reduced cost (worker problem objective function value) is</span></span><br><span class="line">        <span class="comment"># non-negative we are optimal. Otherwise we found a new column</span></span><br><span class="line">        <span class="comment"># to be added. Coefficients of the new column are given by the</span></span><br><span class="line">        <span class="comment"># optimal solution vector to the worker problem.</span></span><br><span class="line">        <span class="keyword">if</span> pat.solution.get_objective_value() &gt; -RC_EPS:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        newpat = pat.solution.get_values(use)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># The new pattern constitutes a new variable in the cutting</span></span><br><span class="line">        <span class="comment"># optimization problem. Create that variable and add it to all</span></span><br><span class="line">        <span class="comment"># constraints with the coefficients read from the optimal solution</span></span><br><span class="line">        <span class="comment"># of the pattern generation problem.</span></span><br><span class="line">        idx = cut.variables.get_num()</span><br><span class="line">        cut.variables.add(obj=[<span class="number">1.0</span>])</span><br><span class="line">        cut.linear_constraints.set_coefficients(list(zip(cutcons,</span><br><span class="line">                                                         [idx] * len(use),</span><br><span class="line">                                                         newpat)))</span><br><span class="line">        cutvars.append(idx)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Perform a final solve on the cutting optimization problem.</span></span><br><span class="line">    <span class="comment"># Turn all variables into integers before doing that.</span></span><br><span class="line">    cut.variables.set_types(</span><br><span class="line">        list(zip(cutvars, [cut.variables.type.integer] * len(cutvars))))</span><br><span class="line">    cut.solve()</span><br><span class="line">    report3(cut)</span><br><span class="line">    print(<span class="string">"Solution status = "</span>, cut.solution.get_status())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    datafile = <span class="string">"../../../examples/data/cutstock.dat"</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) &lt; <span class="number">2</span>:</span><br><span class="line">        print(<span class="string">"Default data file : "</span> + datafile)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        datafile = sys.argv[<span class="number">1</span>]</span><br><span class="line">    cutstock(datafile)</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="读取问题">读取问题</h1><figure class="highlight python"><figcaption><span>inputdata.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># File: inputdata.py</span></span><br><span class="line"><span class="comment"># Version 12.9.0</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Licensed Materials - Property of IBM</span></span><br><span class="line"><span class="comment"># 5725-A06 5725-A29 5724-Y48 5724-Y49 5724-Y54 5724-Y55 5655-Y21</span></span><br><span class="line"><span class="comment"># Copyright IBM Corporation 2009, 2019. All Rights Reserved.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># US Government Users Restricted Rights - Use, duplication or</span></span><br><span class="line"><span class="comment"># disclosure restricted by GSA ADP Schedule Contract with</span></span><br><span class="line"><span class="comment"># IBM Corp.</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="string">"""Utility for reading data from .dat files in examples/data/."""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_words</span><span class="params">(line)</span>:</span></span><br><span class="line">    <span class="string">"""Return a list of the tokens in line."""</span></span><br><span class="line">    line = line.replace(<span class="string">"\t"</span>, <span class="string">" "</span>)</span><br><span class="line">    line = line.replace(<span class="string">"\v"</span>, <span class="string">" "</span>)</span><br><span class="line">    line = line.replace(<span class="string">"\r"</span>, <span class="string">" "</span>)</span><br><span class="line">    line = line.replace(<span class="string">"\n"</span>, <span class="string">" "</span>)</span><br><span class="line">    <span class="keyword">while</span> line.count(<span class="string">"  "</span>):</span><br><span class="line">        line = line.replace(<span class="string">"  "</span>, <span class="string">" "</span>)</span><br><span class="line">    line = line.strip()</span><br><span class="line">    <span class="keyword">return</span> [word + <span class="string">" "</span> <span class="keyword">for</span> word <span class="keyword">in</span> line.split(<span class="string">" "</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_dat_file</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="string">"""Return a list containing the data stored in the dat file.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Single integers or floats are stored as their natural type.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    1-d arrays are stored as lists</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    2-d arrays are stored as lists of lists.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    NOTE: the 2-d arrays are not in the list-of-lists matrix format</span></span><br><span class="line"><span class="string">    that the python methods take as input for constraints.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    ret = []</span><br><span class="line">    continuation = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> get_words(line):</span><br><span class="line">                <span class="keyword">if</span> continuation:</span><br><span class="line">                    entity = <span class="string">""</span>.join([entity, word])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    entity = word</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    ret.append(eval(entity))</span><br><span class="line">                    continuation = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">except</span> SyntaxError:</span><br><span class="line">                    continuation = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><h1 id="示例问题">示例问题</h1><figure class="highlight plain"><figcaption><span>cutstock.dat</span></figcaption><table><tr><td class="code"><pre><span class="line">115</span><br><span class="line">[25, 40, 50, 55, 70]</span><br><span class="line">[50, 36, 24, 8, 30]</span><br></pre></td></tr></table></figure><h1 id="示例运行结果">示例运行结果</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python cutstock.py</span><br><span class="line">Default data file : ../../../examples/data/cutstock.dat</span><br><span class="line"></span><br><span class="line">Using 76.5 rolls</span><br><span class="line"></span><br><span class="line">  Cut0 = 12.5</span><br><span class="line">  Cut1 = 18.0</span><br><span class="line">  Cut2 = 12.0</span><br><span class="line">  Cut3 = 4.0</span><br><span class="line">  Cut4 = 30.0</span><br><span class="line"></span><br><span class="line">  Fill0 = 0.25</span><br><span class="line">  Fill1 = 0.5</span><br><span class="line">  Fill2 = 0.5</span><br><span class="line">  Fill3 = 0.5</span><br><span class="line">  Fill4 = 1.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Reduced cost is -0.5</span><br><span class="line"></span><br><span class="line">  Use0 = 0.0</span><br><span class="line">  Use1 = 1.0</span><br><span class="line">  Use2 = 0.0</span><br><span class="line">  Use3 = 0.0</span><br><span class="line">  Use4 = 1.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Using 61.5 rolls</span><br><span class="line"></span><br><span class="line">  Cut0 = 12.5</span><br><span class="line">  Cut1 = 3.0</span><br><span class="line">  Cut2 = 12.0</span><br><span class="line">  Cut3 = 4.0</span><br><span class="line">  Cut4 = 0.0</span><br><span class="line">  Cut5 = 30.0</span><br><span class="line"></span><br><span class="line">  Fill0 = 0.25</span><br><span class="line">  Fill1 = 0.5</span><br><span class="line">  Fill2 = 0.5</span><br><span class="line">  Fill3 = 0.5</span><br><span class="line">  Fill4 = 0.5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Reduced cost is -0.25</span><br><span class="line"></span><br><span class="line">  Use0 = 1.0</span><br><span class="line">  Use1 = 2.0</span><br><span class="line">  Use2 = 0.0</span><br><span class="line">  Use3 = 0.0</span><br><span class="line">  Use4 = 0.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Using 60.75 rolls</span><br><span class="line"></span><br><span class="line">  Cut0 = 11.75</span><br><span class="line">  Cut1 = 0.0</span><br><span class="line">  Cut2 = 12.0</span><br><span class="line">  Cut3 = 4.0</span><br><span class="line">  Cut4 = 0.0</span><br><span class="line">  Cut5 = 30.0</span><br><span class="line">  Cut6 = 3.0</span><br><span class="line"></span><br><span class="line">  Fill0 = 0.25</span><br><span class="line">  Fill1 = 0.375</span><br><span class="line">  Fill2 = 0.5</span><br><span class="line">  Fill3 = 0.5</span><br><span class="line">  Fill4 = 0.625</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Reduced cost is -0.125</span><br><span class="line"></span><br><span class="line">  Use0 = 3.0</span><br><span class="line">  Use1 = 1.0</span><br><span class="line">  Use2 = 0.0</span><br><span class="line">  Use3 = -0.0</span><br><span class="line">  Use4 = -0.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Using 60.0 rolls</span><br><span class="line"></span><br><span class="line">  Cut0 = 8.0</span><br><span class="line">  Cut1 = 0.0</span><br><span class="line">  Cut2 = 12.0</span><br><span class="line">  Cut3 = 4.0</span><br><span class="line">  Cut4 = 0.0</span><br><span class="line">  Cut5 = 30.0</span><br><span class="line">  Cut6 = 0.0</span><br><span class="line">  Cut7 = 6.0</span><br><span class="line"></span><br><span class="line">  Fill0 = 0.25</span><br><span class="line">  Fill1 = 0.25</span><br><span class="line">  Fill2 = 0.5</span><br><span class="line">  Fill3 = 0.5</span><br><span class="line">  Fill4 = 0.75</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Reduced cost is 0.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Best integer solution uses 60.0 rolls</span><br><span class="line"></span><br><span class="line">  Cut0 = 8.0</span><br><span class="line">  Cut1 = -0.0</span><br><span class="line">  Cut2 = 12.0</span><br><span class="line">  Cut3 = 4.0</span><br><span class="line">  Cut4 = -0.0</span><br><span class="line">  Cut5 = 30.0</span><br><span class="line">  Cut6 = -0.0</span><br><span class="line">  Cut7 = 6.0</span><br><span class="line">Solution status =  101</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> column generation </tag>
            
            <tag> cplex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聚类</title>
      <link href="/notes/introduction-to-ml-with-python/clustering/"/>
      <url>/notes/introduction-to-ml-with-python/clustering/</url>
      
        <content type="html"><![CDATA[<p>聚类（clustering）是将数据集划分成组的任务，这些组叫作簇（cluster）。其目标是划分数据，使得一个簇内的数据点非常相似且不同簇内的数据点非常不同。与分类算法类似，聚类算法为每个数据点分配（或预测）一个数字，表示这个点属于哪个簇。</p><h1 id="k均值聚类">k均值聚类</h1><p>k均值聚类是最简单也最常用的聚类算法之一。它试图找到代表数据特定区域的<strong>簇中心</strong>（cluster center）。算法交替执行以下两个步骤：将每个数据点分配给最近的簇中心，然后将每个簇中心设置为所分配的所有数据点的平均值。如果簇的分配不再发生变化，那么算法结束。下面的例子在一个模拟数据集上对这一算法进行说明。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_kmeans_algorithm()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/kmeans-algorithm.png"></p><a id="more"></a><p>簇中心用三角形表示，而数据点用圆形表示。颜色表示簇成员。我们指定要寻找三个簇，所以通过声明三个随机数据点为簇中心来将算法初始化。然后开始迭代算法。首先每个数据点被分配给距离最近的簇中心。接下来，将簇中心修改为所分配点的平均值。然后将这一过程再重复两次。在第三次迭代之后，为簇中心分配的数据点保持不变，因此算法结束。</p><p>给定新的数据点，k均值会将其分配给最近的簇中心。下一例子展示了学到的簇中心的边界。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_kmeans_boundaries()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/kmeans-boundaries.png"></p><p>用<code>scikit-learn</code>应用k均值相当简单。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.cluster.kmeans" target="_blank" rel="noopener"><code>class sklearn.cluster.KMeans(n_clusters=8, init=’k-means++’, n_init=10, max_iter=300, tol=0.0001, precompute_distances=’auto’, verbose=0, random_state=None, copy_x=True, n_jobs=None, algorithm=’auto’)</code></a></p><p>K-Means clustering</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成模拟的二维数据</span></span><br><span class="line">X, y = make_blobs(random_state=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 构建聚类模型</span></span><br><span class="line">kmeans = KMeans(n_clusters=<span class="number">3</span>)</span><br><span class="line">kmeans.fit(X)</span><br><span class="line">print(<span class="string">'Cluster memberships:\n&#123;&#125;'</span>.format(kmeans.labels_))</span><br><span class="line"><span class="comment"># 对训练集运行predict会返回与labels_相同的结果</span></span><br><span class="line">print(kmeans.predict(X))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cluster memberships:</span><br><span class="line">[0 2 2 2 1 1 1 2 0 0 2 2 1 0 1 1 1 0 2 2 1 2 1 0 2 1 1 0 0 1 0 0 1 0 2 1 2</span><br><span class="line"> 2 2 1 1 2 0 2 2 1 0 0 0 0 2 1 1 1 0 1 2 2 0 0 2 1 1 2 2 1 0 1 0 2 2 2 1 0</span><br><span class="line"> 0 2 1 1 0 2 0 2 2 1 0 0 0 0 2 0 1 0 0 2 2 1 1 0 1 0]</span><br><span class="line">[0 2 2 2 1 1 1 2 0 0 2 2 1 0 1 1 1 0 2 2 1 2 1 0 2 1 1 0 0 1 0 0 1 0 2 1 2</span><br><span class="line"> 2 2 1 1 2 0 2 2 1 0 0 0 0 2 1 1 1 0 1 2 2 0 0 2 1 1 2 2 1 0 1 0 2 2 2 1 0</span><br><span class="line"> 0 2 1 1 0 2 0 2 2 1 0 0 0 0 2 0 1 0 0 2 2 1 1 0 1 0]</span><br></pre></td></tr></table></figure><p>因为要们要找的是3个簇，所有簇的编号是0到2。你也可以用predict方法为新数据点分配标签。预测时会将最近的簇中心分配个每个新数据点，但现有模型不会改变（即不会更新簇中心的位置）。</p><p>与分类算法类似，聚类算法的每个元素也有一个标签。但并不存在真实的标签，因此标签本身并没有<strong>先验</strong>意义。回到人脸图像聚类的例子。聚类的结果可能是，算法找到的第3个簇仅包含你朋友Bela的面孔。但只有在查看图片之后才能知道这一点，而且数字3是任意的。算法给你的唯一信息就是所有标签为3的人脸都是相似的。</p><p>对于我们刚刚在二维玩具数据集上运行的聚类算法，这意味着我们不应该为其中一组的标签是0、另一组的标签是1这一事实赋予任何意义。再次运行该算法可能会导致不同的簇编号，原因在于初始化的随机性质。</p><p>下面又给出了这个数据的图像。簇中心被保存在<code>cluster_centers_</code>属性中，我们用三角形表示它们。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.discrete_scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], kmeans.labels_, markers=<span class="string">'o'</span>)</span><br><span class="line">mglearn.discrete_scatter(kmeans.cluster_centers_[:, <span class="number">0</span>],</span><br><span class="line">    kmeans.cluster_centers_[:, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], markers=<span class="string">'^'</span>, markeredgewidth=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/kmeans-cluster-centers.png"></p><p>我们也可以使用更多或更少的簇中心。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, axes = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment"># 使用2个簇中心</span></span><br><span class="line">kmeans = KMeans(n_clusters=<span class="number">2</span>)</span><br><span class="line">kmeans.fit(X)</span><br><span class="line">assignments = kmeans.labels_</span><br><span class="line">mglearn.discrete_scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], assignments, ax=axes[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 使用5个簇中心</span></span><br><span class="line">kmeans = KMeans(n_clusters=<span class="number">5</span>)</span><br><span class="line">kmeans.fit(X)</span><br><span class="line">assignments = kmeans.labels_</span><br><span class="line">mglearn.discrete_scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], assignments, ax=axes[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/kmeans-more-or-less-cluster-centers.png"></p><h2 id="k均值的失败案例">k均值的失败案例</h2><p>即使你知道给定数据集中簇的“正确”个数，k均值可能也不是总能找到它们。<strong>每个簇仅有其中心定义，这意味着每个簇都是凸形（convex）。因此，k均值只能找到相对简单的形状。</strong>k均值还假设所有簇在某种程度上具有相同的“直径”，它总是将簇之间的边界刚好画在簇中心的中间位置。有时这会导致令人惊讶的结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_varied, y_varied = make_blobs(n_samples=<span class="number">200</span>, cluster_std=[<span class="number">1.0</span>, <span class="number">2.5</span>, <span class="number">0.5</span>],</span><br><span class="line">    random_state=<span class="number">170</span>)</span><br><span class="line">y_pred = KMeans(n_clusters=<span class="number">3</span>, random_state=<span class="number">0</span>).fit_predict(X_varied)</span><br><span class="line"></span><br><span class="line">mglearn.discrete_scatter(X_varied[:, <span class="number">0</span>], X_varied[:, <span class="number">1</span>], y_pred)</span><br><span class="line">plt.legend([<span class="string">'cluster 0'</span>, <span class="string">'cluster 1'</span>, <span class="string">'cluster 2'</span>], loc=<span class="string">'best'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature 1'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/kmeans-different-density.png"></p><p>你可能会认为，左下方的密集区域是第一个簇，右上方的密集区域是第二个，中间密度较小的区域是第三个。但事实上，簇0和簇1都包含一些远离簇中其他点的点。</p><p>k均值还假设所有方向对每个簇都同等重要。下图显示了一个二维数据集，数据中包含明确分开的三部分。但是这三部分被沿着对角线方向拉长。由于k均值仅考虑到最近簇中心的距离，所以它无法处理这种类型的数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成一些随机分组数据</span></span><br><span class="line">X, y = make_blobs(random_state=<span class="number">170</span>, n_samples=<span class="number">600</span>)</span><br><span class="line">rng = np.random.RandomState(<span class="number">74</span>)</span><br><span class="line"><span class="comment"># 变换数据使其拉长</span></span><br><span class="line">transformation = rng.normal(size=(<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line">X = np.dot(X, transformation)</span><br><span class="line"><span class="comment"># 将数据聚类成3个簇</span></span><br><span class="line">kmeans = KMeans(n_clusters=<span class="number">3</span>)</span><br><span class="line">kmeans.fit(X)</span><br><span class="line">y_pred = kmeans.predict(X)</span><br><span class="line"><span class="comment"># 画出簇分配和簇中心</span></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y_pred, cmap=mglearn.cm3)</span><br><span class="line">plt.scatter(kmeans.cluster_centers_[:, <span class="number">0</span>], kmeans.cluster_centers_[:, <span class="number">1</span>],</span><br><span class="line">    marker=<span class="string">'^'</span>, c=[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], s=<span class="number">100</span>, linewidth=<span class="number">2</span>, cmap=mglearn.cm3)</span><br><span class="line">plt.xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature 1'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/kmeans-aspherical.png"></p><p>如果簇的形状更加复杂，那么k均值的表现也很差。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成模拟的two_moons数据</span></span><br><span class="line">X, y = make_moons(n_samples=<span class="number">200</span>, noise=<span class="number">0.05</span>, random_state=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 将数据聚类成2个簇</span></span><br><span class="line">kmeans = KMeans(n_clusters=<span class="number">2</span>)</span><br><span class="line">kmeans.fit(X)</span><br><span class="line">y_pred = kmeans.predict(X)</span><br><span class="line"><span class="comment"># 画出簇分配和簇中心</span></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y_pred, cmap=mglearn.cm3, s=<span class="number">60</span>)</span><br><span class="line">plt.scatter(kmeans.cluster_centers_[:, <span class="number">0</span>], kmeans.cluster_centers_[:, <span class="number">1</span>],</span><br><span class="line">    marker=<span class="string">'^'</span>, c=[mglearn.cm2(<span class="number">0</span>), mglearn.cm2(<span class="number">1</span>)], s=<span class="number">100</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature 1'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/kmeans-on-two-moons.png"></p><p>这里我们希望聚类算法能够发现两个半月形。但利用k均值算法是不可能做到这一点的。</p><h2 id="矢量量化或者将k均值看作分解">矢量量化，或者将k均值看作分解</h2><p>虽然k均值是一种聚类算法，但在k均值和分解方法（比如PCA和NMF）之间存在一些有趣的相似之处。PCA试图找到数据中方差最大的方向，而NMF试图找到累加的分量，这通常对应于数据的“极值”或“部分”。两种方法都试图将数据点表示为一些分量之和。与之相反，k均值则尝试利用簇中心来表示每个数据点。你可以将其看作仅用一个分量来表示每个数据点，该分量由簇中心给出。这种观点将k均值看作是一种分解方法，其中每个点用单一分量来表示，这种观点被称为<strong>矢量量化</strong>（vector quantization）。</p><p>我们来并排比较PCA、NMF和k均值，分别显示提取的分量，以及利用100个分量对测试集中人脸的重建。对于k均值，重建就是在训练集中找到最近的簇中心。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">    X_people, y_people, stratify=y_people, random_state=<span class="number">0</span>)</span><br><span class="line">nmf = NMF(n_components=<span class="number">100</span>, random_state=<span class="number">0</span>)</span><br><span class="line">nmf.fit(X_train)</span><br><span class="line">pca = PCA(n_components=<span class="number">100</span>, random_state=<span class="number">0</span>)</span><br><span class="line">pca.fit(X_train)</span><br><span class="line">kmeans = KMeans(n_clusters=<span class="number">100</span>, random_state=<span class="number">0</span>)</span><br><span class="line">kmeans.fit(X_train)</span><br><span class="line"></span><br><span class="line">X_reconstructed_pca = pca.inverse_transform(pca.transform(X_test))</span><br><span class="line">X_reconstructed_nmf = np.dot(nmf.transform(X_test), nmf.components_)</span><br><span class="line">X_reconstructed_kmeans = kmeans.cluster_centers_[kmeans.predict(X_test)]</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(<span class="number">3</span>, <span class="number">5</span>, figsize=(<span class="number">8</span>, <span class="number">8</span>),</span><br><span class="line">    subplot_kw=&#123;<span class="string">'xticks'</span>: (), <span class="string">'yticks'</span>: ()&#125;)</span><br><span class="line">fig.suptitle(<span class="string">'Extracted Components'</span>)</span><br><span class="line"><span class="keyword">for</span> ax, comp_kmeans, comp_pca, comp_nmf <span class="keyword">in</span> zip(</span><br><span class="line">    axes.T, kmeans.cluster_centers_, pca.components_, nmf.components_):</span><br><span class="line">    ax[<span class="number">0</span>].imshow(comp_kmeans.reshape(image_shape))</span><br><span class="line">    ax[<span class="number">1</span>].imshow(comp_pca.reshape(image_shape), cmap=<span class="string">'viridis'</span>)</span><br><span class="line">    ax[<span class="number">2</span>].imshow(comp_nmf.reshape(image_shape))</span><br><span class="line">axes[<span class="number">0</span>, <span class="number">0</span>].set_ylabel(<span class="string">'kmeas'</span>)</span><br><span class="line">axes[<span class="number">1</span>, <span class="number">0</span>].set_ylabel(<span class="string">'pca'</span>)</span><br><span class="line">axes[<span class="number">2</span>, <span class="number">0</span>].set_ylabel(<span class="string">'nmf'</span>)</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(<span class="number">4</span>, <span class="number">5</span>, figsize=(<span class="number">8</span>, <span class="number">8</span>),</span><br><span class="line">    subplot_kw=&#123;<span class="string">'xticks'</span>: (), <span class="string">'yticks'</span>: ()&#125;)</span><br><span class="line">fig.suptitle(<span class="string">'Reconstructions'</span>)</span><br><span class="line"><span class="keyword">for</span> ax, org, rec_kmeans, rec_pca, rec_nmf <span class="keyword">in</span> zip(axes.T, X_test,</span><br><span class="line">    X_reconstructed_kmeans, X_reconstructed_pca, X_reconstructed_nmf):</span><br><span class="line">    ax[<span class="number">0</span>].imshow(org.reshape(image_shape))</span><br><span class="line">    ax[<span class="number">1</span>].imshow(rec_kmeans.reshape(image_shape))</span><br><span class="line">    ax[<span class="number">2</span>].imshow(rec_pca.reshape(image_shape))</span><br><span class="line">    ax[<span class="number">3</span>].imshow(rec_nmf.reshape(image_shape))</span><br><span class="line">axes[<span class="number">0</span>, <span class="number">0</span>].set_ylabel(<span class="string">'original'</span>)</span><br><span class="line">axes[<span class="number">1</span>, <span class="number">0</span>].set_ylabel(<span class="string">'kmeas'</span>)</span><br><span class="line">axes[<span class="number">2</span>, <span class="number">0</span>].set_ylabel(<span class="string">'pca'</span>)</span><br><span class="line">axes[<span class="number">3</span>, <span class="number">0</span>].set_ylabel(<span class="string">'nmf'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/kmeans-pca-nmf-extract-components.png"></p><p><img src="/uploads/image/introduction-to-ml-with-python/kmeans-pca-nmf-reconstructions.png"></p><p><strong>利用k均值做矢量量化的一个有趣之处在于，可以用比输入维度更多的簇来对数据进行编码</strong>让我们回到<code>two_moons</code>数据。利用PCA或NMF，我们对这个数据无能为力，因为它只有两个维度。使用PCA或NMF将其降到一维，将会完全破坏数据的结构。但通过使用更多的簇中心，我们可以用k均值找到一种更具表现力的表示。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X, y = make_moons(n_samples=<span class="number">200</span>, noise=<span class="number">0.05</span>, random_state=<span class="number">0</span>)</span><br><span class="line">kmeans = KMeans(n_clusters=<span class="number">10</span>, random_state=<span class="number">0</span>)</span><br><span class="line">kmeans.fit(X)</span><br><span class="line">y_pred = kmeans.predict(X)</span><br><span class="line"></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y_pred, s=<span class="number">60</span>, cmap=<span class="string">'Paired'</span>)</span><br><span class="line">plt.scatter(kmeans.cluster_centers_[:, <span class="number">0</span>], kmeans.cluster_centers_[:, <span class="number">1</span>],</span><br><span class="line">    s=<span class="number">60</span>, marker=<span class="string">'^'</span>, c=range(kmeans.n_clusters), linewidth=<span class="number">2</span>, cmap=<span class="string">'Paired'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature 1'</span>)</span><br><span class="line">print(<span class="string">'Cluster memberships:\n&#123;&#125;'</span>.format(y_pred))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cluster memberships:</span><br><span class="line">[9 2 5 4 2 7 9 6 9 6 1 0 2 6 1 9 3 0 3 1 7 6 8 6 8 5 2 7 5 8 9 8 6 5 3 7 0</span><br><span class="line"> 9 4 5 0 1 3 5 2 8 9 1 5 6 1 0 7 4 6 3 3 6 3 8 0 4 2 9 6 4 8 2 8 4 0 4 0 5</span><br><span class="line"> 6 4 5 9 3 0 7 8 0 7 5 8 9 8 0 7 3 9 7 1 7 2 2 0 4 5 6 7 8 9 4 5 4 1 2 3 1</span><br><span class="line"> 8 8 4 9 2 3 7 0 9 9 1 5 8 5 1 9 5 6 7 9 1 4 0 6 2 6 4 7 9 5 5 3 8 1 9 5 6</span><br><span class="line"> 3 5 0 2 9 3 0 8 6 0 3 3 5 6 3 2 0 2 3 0 2 6 3 4 4 1 5 6 7 1 1 3 2 4 7 2 7</span><br><span class="line"> 3 8 6 4 1 4 3 9 9 5 1 7 5 8 2]</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/kmeans-on-two-moons-10-centers.png"></p><p>我们使用了10个簇中心，也就是说，现在每个点都被分配了0到9之间的一个数字。我们可以将其看作10个分量表示的数据（我们有是10个新特征），只有表示该点对应的簇中心的那个特征不为0，其他特征均为0。利用这个10维表示，现在可以用线性模型来划分两个半月形，而利用原始的两个特征是不可能做到这一点的。将到每个簇中心的距离作为特征，还可以得到一种表现力更强的数据表示。可以利用kmeans的transform方法来完成这一点。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">distance_features = kmeans.transform(X)</span><br><span class="line">print(<span class="string">'Distance feature shape: &#123;&#125;'</span>.format(distance_features.shape))</span><br><span class="line">print(<span class="string">'Distance features:\n&#123;&#125;'</span>.format(distance_features))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Distance feature shape: (200, 10)</span><br><span class="line">Distance features:</span><br><span class="line">[[0.9220768  1.46553151 1.13956805 ... 1.16559918 1.03852189 0.23340263]</span><br><span class="line"> [1.14159679 2.51721597 0.1199124  ... 0.70700803 2.20414144 0.98271691]</span><br><span class="line"> [0.78786246 0.77354687 1.74914157 ... 1.97061341 0.71561277 0.94399739]</span><br><span class="line"> ...</span><br><span class="line"> [0.44639122 1.10631579 1.48991975 ... 1.79125448 1.03195812 0.81205971]</span><br><span class="line"> [1.38951924 0.79790385 1.98056306 ... 1.97788956 0.23892095 1.05774337]</span><br><span class="line"> [1.14920754 2.4536383  0.04506731 ... 0.57163262 2.11331394 0.88166689]]</span><br></pre></td></tr></table></figure><p>k均值是非常流行的聚类算法，因为它不仅相对容易理解和实现，而且运行速度也相对较快。k均值可以轻松扩展到大型数据集，<code>scikit-learn</code>甚至在<code>MiniBatchKMeans</code>类中包含了一种更具扩展性的变体，可以处理非常大的数据集。</p><p>k均值的缺点之一在于，它依赖于随机初始化，也就是说，算法的输出依赖于随机种子。默认情况下，<code>scikit-learn</code>用10种不同的随机初始化将算法运行10次，并返回最佳（簇的方差之和最小）结果。k均值还有一个缺点，就是对簇形状的假设的约束性较强，而且还要求指定所要寻找的簇的个数（在现实世界的应用中可能并不知道这个数字）。</p><p>接下来，我们将学习另外两种聚类算法，它们都在某些方面对这些性质做了改进。</p><h1 id="凝聚聚类">凝聚聚类</h1><p>凝聚聚类（agglomerative clustering）指的是许多基于相同原则构建的聚类算法，这一原则是：算法首先声明每个点是自己的簇，然后合并两个最相似的簇，直到满足某种停止准则为止。<code>scikit-learn</code>中实现的停止准则是簇的个数，因此相似的簇被合并，直到仅剩下指定个数的簇。还有一些链接（linkage）准则，规定如何度量“最相似的簇”。这种度量总是定义在两个现有的簇之间。</p><p><code>scikit-learn</code>中实现了以下三种选项。</p><ul><li><p>ward</p><p>默认选项。ward挑选两个簇来合并，使得所有簇中的方差增加最小。这通常会得到大小差不多相等的簇。</p></li><li><p>average</p><p>average链接将簇中所有点之间平均距离最小的两个簇合并。</p></li><li><p>complete</p><p>complete链接（也称为最大链接）将簇中点之间最大距离最小的两个簇合并。</p></li></ul><p>ward适用于大多数数据集，在我们的例子中将使用它。如果簇中的成员个数非常不同（比如其中一个比其他所有都大得多），那么average或complete可能效果更好。</p><p>下图给出了在一个二维数据集上的凝聚聚类过程，要寻找三个簇。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_agglomerative_algorithm()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/agglomerative-algorithm.png"></p><p>我们来看一下凝聚聚类对简单三簇数据的效果如何。由于算法的工作原理，凝聚算法不能对新数据点作出预测。因此<code>AgglomerativeClustering</code>没有predict方法。为了构造模型并得到训练集上簇的成员表示，可以改用<code>fit_predict</code>方法，或使用<code>labels_</code>属性。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.cluster.agglomerativeclustering" target="_blank" rel="noopener"><code>class sklearn.cluster.AgglomerativeClustering(n_clusters=2, affinity=’euclidean’, memory=None, connectivity=None, compute_full_tree=’auto’, linkage=’ward’, pooling_func=’deprecated’)</code></a></p><p>Agglomerative Clustering</p><p>Recursively merges the pair of clusters that minimally increases a given linkage distance.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> AgglomerativeClustering</span><br><span class="line"></span><br><span class="line">X, y = make_blobs(random_state=<span class="number">1</span>)</span><br><span class="line">agg = AgglomerativeClustering(n_clusters=<span class="number">3</span>)</span><br><span class="line">assignment = agg.fit_predict(X)</span><br><span class="line"></span><br><span class="line">mglearn.discrete_scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], assignment)</span><br><span class="line">plt.legend([<span class="string">'Cluster 0'</span>, <span class="string">'Cluster 1'</span>, <span class="string">'Cluster 1'</span>], loc=<span class="number">2</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature 1'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/agglomerative-clustering-on-blobs.png"></p><p>正如缩小，算法完美地完成了聚类。虽然凝聚聚类的<code>scikit-learn</code>实现需要你指定希望算法找到的簇的个数，但凝聚聚类方法为选择正确的个数提供了一些帮助，我们将在下面讨论。</p><h2 id="层次聚类与树状图">层次聚类与树状图</h2><p>凝聚聚类生成了所谓的层次聚类（hierarchical clustering）。聚类过程迭代进行，每个点都从一个单点簇变为属于最终的某个簇。每个中间步骤都提供了数据的一种聚类（簇的个数也不相同）。有时候，同时查看所有可能的聚类是有帮助的。下一个例子叠加显示了所有可能的聚类，有助于深入了解每个簇如何分解为较小的簇。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_agglomerative()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/agglomerative-hierarchical-clustering.png"></p><p>虽然这种可视化为层次聚类提供了非常详细的试图，但它依赖于数据的二维性质，因此不能用于具有两个以上特征的数据集。但还有另一个将层次聚类可视化的工具，叫作树状图（dendrogram），它可以处理多维数据集。</p><p>不幸的是，目前<code>scikit-learn</code>没有绘制树状图的功能。但你可以利用SciPy轻松生成树状图。SciPy的聚类算法接口与<code>scikit-learn</code>的聚类算法稍有不同。SciPy提供了一个函数，接受数据数组X并计算出一个链接数据（linkage array），它对层次聚类的相似度进行编码。然后我们可以将这个链接数据提供给scipy的dendrogram函数来绘制树状图。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从SciPy中导入dendrogram函数和ward聚类函数</span></span><br><span class="line"><span class="keyword">from</span> scipy.cluster.hierarchy <span class="keyword">import</span> dendrogram, ward</span><br><span class="line"></span><br><span class="line">X, y = make_blobs(random_state=<span class="number">0</span>, n_samples=<span class="number">12</span>)</span><br><span class="line"><span class="comment"># 将ward聚类应用于数据数组X</span></span><br><span class="line"><span class="comment"># SciPy的ward函数返回一个数组，指定执行凝聚聚类时跨越的距离</span></span><br><span class="line">linkage_array = ward(X)</span><br><span class="line"><span class="comment"># 现在为包含簇之间距离的linkage_array绘制树状图</span></span><br><span class="line">dendrogram(linkage_array)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在树中标记划分成两个簇或三个簇的位置</span></span><br><span class="line">ax = plt.gca()</span><br><span class="line">bounds = ax.get_xbound()</span><br><span class="line">ax.plot(bounds, [<span class="number">7.25</span>, <span class="number">7.25</span>], <span class="string">'--'</span>, c=<span class="string">'k'</span>)</span><br><span class="line">ax.plot(bounds, [<span class="number">4</span>, <span class="number">4</span>], <span class="string">'--'</span>, c=<span class="string">'k'</span>)</span><br><span class="line"></span><br><span class="line">ax.text(bounds[<span class="number">1</span>], <span class="number">7.25</span>, <span class="string">' two clusters'</span>, va=<span class="string">'center'</span>, fontdict=&#123;<span class="string">'size'</span>: <span class="number">15</span>&#125;)</span><br><span class="line">ax.text(bounds[<span class="number">1</span>], <span class="number">4</span>, <span class="string">' three clusters'</span>, va=<span class="string">'center'</span>, fontdict=&#123;<span class="string">'size'</span>: <span class="number">15</span>&#125;)</span><br><span class="line">plt.xlabel(<span class="string">'Sample index'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Cluster distance'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/agglomerative-clustering-dendrogram.png"></p><p>树状图在底部显示数据点（编号从0到11）。然后以这些点（表示单点簇）作为叶节点绘制一棵树，每合并两个簇就添加一个新的父节点。</p><p>从下往上看，数据点1和4首先被合并。接下来，点6和9被合并为一个簇，以此类推。在顶层有两个分支，一个由点11、0、5、10、7、6和9组成，另一个由点1、4、3、2和8组成。这对应于图中两个最大的簇。</p><p>树状图的y轴不仅说明凝聚算法中两个簇何时合并，每个分支的长度还表示被合并的簇之间的距离。在这张树状图中，最长的分支是标记为“three clusters”的虚线表示的三条线。它们是最长的分支，这表示从三个簇到两个簇的过程中合并了一些距离非常远的点。将剩下的两个簇合并为一个簇也需要跨越相对较大的距离。</p><p>不幸的是，凝聚算法仍然无法分离像<code>two_moons</code>数据集这样复杂的形状。但我们要学习的下一个算法DBSCAN可以解决这个问题。</p><h1 id="dbscan">DBSCAN</h1><p>另一个非常有用的聚类算法是DBSCAN（density-based spatial clustering of applications with noise，即“具有噪声的基于密度的空间聚类应用”）。DBSCAN的主要优点是它不需要用户先验地设置簇的个数，可以划分具有复杂形状的簇，还可以找出不属于任何簇的点。DBSCAN比凝聚聚类和k均值稍慢，但仍可以扩展到相对较大的数据集。</p><p>DBSCAN的原理是识别特征空间的“拥挤”区域中的点，在这些区域中许多数据点靠近在一起。这些区域被称为特征空间中的密集（dense）区域。DBSCAN背后的思想是，簇形成数据的密集区域，并由相对较空的区域分隔开。</p><p>在密集区域内的点被称为<strong>核心样本</strong>（core sample，或核心点），它们的定义如下。DBSCAN有两个参数：<code>min_samples</code>和<code>eps</code>。如果距一个给定数据点<code>eps</code>的距离至少有<code>min_samples</code>个数据点，那么这个数据点就是核心样本。DBSCAN将彼此距离小于<code>eps</code>的核心样本放到同一个簇中。</p><p>算法首先任意选取一个点，然后找到这个点的距离小于等于eps的所有的点。如果距起始点的距离在eps之内的数据点个数小于<code>min_samples</code>，那么这个点被标记为<strong>噪声</strong>（noise），也就是说它不属于任何簇。如果距离在eps之内的数据点个数大于<code>min_samples</code>，则这个点被标记为核心样本，并被分配一个新的簇标签。然后访问该点的所有邻居（在距离eps之内）。如果它们还没有被分配一个簇，那么就将刚刚创建的新的簇标签分配给它们。如果它们是核心样本，那么就依次访问其邻居，以此类推。簇逐渐增大，直到在簇的eps距离内没有更多的核心样本为止。然后选取另一个尚未被访问过的点，并重复相同的过程。</p><p><strong>最后，一共有三种类型的点：核心点，与核心点的距离在eps之内的点（叫作边界点，boundary point）和噪声。如果DBSCAN算法在特定数据集上多次运行，那么核心点的聚类始终相同，同样的点也始终被标记为噪声。但边界点可能与不止一个簇的核心样本相邻。因此，边界点所属的簇依赖于数据点的访问顺序。一般来说只有很少的边界点，这种对访问顺序的轻度依赖并不重要。</strong></p><p>我们将DBSCAN应用于演示凝聚聚类的模拟数据集。与凝聚聚类类似，DBSCAN也不允许对新的测试数据进行预测，所以我们将使用<code>fit_predict</code>方法来执行聚类并返回簇标签。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.cluster.dbscan" target="_blank" rel="noopener"><code>class sklearn.cluster.DBSCAN(eps=0.5, min_samples=5, metric=’euclidean’, metric_params=None, algorithm=’auto’, leaf_size=30, p=None, n_jobs=None)</code></a></p><p>Perform DBSCAN clustering from vector array or distance matrix.</p><p>DBSCAN - Density-Based Spatial Clustering of Applications with Noise. Finds core samples of high density and expands clusters from them. Good for data which contains clusters of similar density.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> DBSCAN</span><br><span class="line"></span><br><span class="line">X, y = make_blobs(random_state=<span class="number">0</span>, n_samples=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">dbscan = DBSCAN()</span><br><span class="line">clusters = dbscan.fit_predict(X)</span><br><span class="line">print(<span class="string">'Cluster memberships:\n&#123;&#125;'</span>.format(clusters))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cluster memberships:</span><br><span class="line">[-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1]</span><br></pre></td></tr></table></figure><p>所有数据点都被分配了标签-1，这代表噪声。这是eps和<code>min_samples</code>默认参数设置的结果，对于小型的玩具数据集并没有调节这些参数。<code>min_samples</code>和eps取不同值时的簇分类如下所示。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_dbscan()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">min_samples: 2 eps: 1.000000  cluster: [-1  0  0 -1  0 -1  1  1  0  1 -1 -1]</span><br><span class="line">min_samples: 2 eps: 1.500000  cluster: [0 1 1 1 1 0 2 2 1 2 2 0]</span><br><span class="line">min_samples: 2 eps: 2.000000  cluster: [0 1 1 1 1 0 0 0 1 0 0 0]</span><br><span class="line">min_samples: 2 eps: 3.000000  cluster: [0 0 0 0 0 0 0 0 0 0 0 0]</span><br><span class="line">min_samples: 3 eps: 1.000000  cluster: [-1  0  0 -1  0 -1  1  1  0  1 -1 -1]</span><br><span class="line">min_samples: 3 eps: 1.500000  cluster: [0 1 1 1 1 0 2 2 1 2 2 0]</span><br><span class="line">min_samples: 3 eps: 2.000000  cluster: [0 1 1 1 1 0 0 0 1 0 0 0]</span><br><span class="line">min_samples: 3 eps: 3.000000  cluster: [0 0 0 0 0 0 0 0 0 0 0 0]</span><br><span class="line">min_samples: 5 eps: 1.000000  cluster: [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1]</span><br><span class="line">min_samples: 5 eps: 1.500000  cluster: [-1  0  0  0  0 -1 -1 -1  0 -1 -1 -1]</span><br><span class="line">min_samples: 5 eps: 2.000000  cluster: [-1  0  0  0  0 -1 -1 -1  0 -1 -1 -1]</span><br><span class="line">min_samples: 5 eps: 3.000000  cluster: [0 0 0 0 0 0 0 0 0 0 0 0]</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/dbscan-different-parameters.png"></p><p>在这张图中，属于簇的点是实心的，而噪声点则显示为空心的。核心样本显示为较大的标记，而边界点则显示为较小的标记。增大eps（在图中从左到右），更多的点会被包含在一个簇中。这让簇变大，但可能也会导致多个簇合并成一个。增大<code>min_samples</code>（在图中从上到下），核心点会变得更少，更多的点被标记为噪声。</p><p>参数eps在某种程度上更加重要，因为它决定了点与点之间“接近”的含义。将eps设置的非常小，意味着没有点是核心样本，可能会导致所有点都被标记为噪声。将eps设置的非常大，可能会导致所有点形成单个簇。</p><p>设置<code>min_samples</code>主要是为了判断稀疏区域内的点被标记为异常值还是形成自己的簇。如果增大<code>min_samples</code>，任何一个包含少于<code>min_samples</code>个样本的簇现在将被标记为噪声。因此，<strong><code>min_samples</code>决定簇的最小尺寸。</strong>在上图中你可以清楚地看到这一点。</p><p><strong>虽然DBSCAN不需要显式地设置簇的个数，但设置eps可以隐式地控制找到的簇的个数。</strong>使用StandardScaler或MinMaxScaler对数据进行缩放之后，有时会更容易找到eps的较好取值，因为使用这些缩放技术将确保所有特征具有相似的范围。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X, y = make_moons(n_samples=<span class="number">200</span>, noise=<span class="number">0.05</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据缩放成平均值为0、方差为1</span></span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">scaler.fit(X)</span><br><span class="line">X_scaled = scaler.transform(X)</span><br><span class="line"></span><br><span class="line">dbscan = DBSCAN()</span><br><span class="line">clusters = dbscan.fit_predict(X_scaled)</span><br><span class="line"><span class="comment"># 绘制簇分配</span></span><br><span class="line">plt.scatter(X_scaled[:, <span class="number">0</span>], X_scaled[:, <span class="number">1</span>], c=clusters,</span><br><span class="line">    cmap=mglearn.cm2, s=<span class="number">60</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature 1'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/dbscan-on-moons.png"></p><p>由于算法找到了我们想要的簇的个数（2个），因此参数设置的效果似乎很好。如果将eps减小到0.2（默认值为0.5），我们将会得到8个簇，这显然太多了。将eps增大到0.7则会导致只有一个簇。</p><p>在使用DBSCAN时，你需要谨慎处理返回的簇分配。如果使用簇标签对另一个数据进行索引，那么使用-1表示噪声可能会产生意料之外的结果。</p><h1 id="聚类算法的对比与评估">聚类算法的对比与评估</h1><p>在应用聚类算法时，其挑战之一就是很难评估一个算法的效果好坏，也很难比较不同算法的结果。</p><h2 id="用真实值评估聚类">用真实值评估聚类</h2><p>有一些指标可用于评估聚类算法相对于真实聚类的结果，其中最重要的是<strong>调整rand指数</strong>（adjusted rand index，ARI）和<strong>归一化互信息</strong>（normalized mutual information，NMI），二者都给出了定量的度量，其最佳值为1，0表示不相关的聚类（虽然ARI可以取负值）。</p><p>下面我们使用ARI来比较k均值、凝聚聚类和DBSCAN算法。对了对比，我们还添加了将点随机分配到两个簇中的图像。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.metrics.adjusted_rand_score" target="_blank" rel="noopener"><code>sklearn.metrics.adjusted_rand_score(labels_true, labels_pred)</code></a></p><p>Rand index adjusted for chance.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics.cluster <span class="keyword">import</span> adjusted_rand_score</span><br><span class="line"></span><br><span class="line">X, y = make_moons(n_samples=<span class="number">200</span>, noise=<span class="number">0.05</span>, random_state=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 将数据缩放成平均值为0、方差为1</span></span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">scaler.fit(X)</span><br><span class="line">X_scaled = scaler.transform(X)</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(<span class="number">1</span>, <span class="number">4</span>, figsize=(<span class="number">15</span>, <span class="number">3</span>),</span><br><span class="line">    subplot_kw=&#123;<span class="string">'xticks'</span>: (), <span class="string">'yticks'</span>: ()&#125;)</span><br><span class="line"><span class="comment"># 要使用的算法</span></span><br><span class="line">algorithms = [KMeans(n_clusters=<span class="number">2</span>), AgglomerativeClustering(n_clusters=<span class="number">2</span>),</span><br><span class="line">    DBSCAN() ]</span><br><span class="line"><span class="comment"># 创建一个随机的簇分配，作为参考</span></span><br><span class="line">random_state = np.random.RandomState(seed=<span class="number">0</span>)</span><br><span class="line">random_clusters = random_state.randint(low=<span class="number">0</span>, high=<span class="number">2</span>, size=len(X))</span><br><span class="line"><span class="comment"># 绘制随机分配</span></span><br><span class="line">axes[<span class="number">0</span>].scatter(X_scaled[:, <span class="number">0</span>], X_scaled[:, <span class="number">1</span>], c=random_clusters,</span><br><span class="line">    cmap=mglearn.cm3, s=<span class="number">60</span>)</span><br><span class="line">axes[<span class="number">0</span>].set_title(<span class="string">'Random assignment - ARI: &#123;:.2f&#125;'</span>.format(</span><br><span class="line">    adjusted_rand_score(y, random_clusters)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax, algorithm <span class="keyword">in</span> zip(axes[<span class="number">1</span>:], algorithms):</span><br><span class="line">    clusters = algorithm.fit_predict(X_scaled)</span><br><span class="line">    ax.scatter(X_scaled[:, <span class="number">0</span>], X_scaled[:, <span class="number">1</span>], c=clusters,</span><br><span class="line">    cmap=mglearn.cm3, s=<span class="number">60</span>)</span><br><span class="line">    ax.set_title(<span class="string">'&#123;&#125; - ARI: &#123;:.2f&#125;'</span>.format(</span><br><span class="line">        algorithm.__class__.__name__, adjusted_rand_score(y, clusters)))</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/ari-of-kmeans-agglomerative-clustering-and-dbscan.png"></p><p>ARI给出了符合直觉的结果，随机簇分配的分数为0，而DBSCAN（完美地找到了期望中的簇）的分数为1。</p><p>用这种方式评估聚类时，一个常见的错误是使用<code>accuracy_score</code>而不是<code>adjusted_rand_score</code>、<code>normalized_mutual_info_score</code>或其他聚类指标。<strong>使用精度的问题在于，它要求分配的簇标签与真实值完全匹配。但簇标签本身毫无意义——唯一重要的是哪些点位于同一个簇中。</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这两种点标签对应于相同的聚类</span></span><br><span class="line">clusters1 = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">clusters2 = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Accuracy: &#123;:.2f&#125;'</span>.format(accuracy_score(clusters1, clusters2)))</span><br><span class="line">print(<span class="string">'ARI: &#123;:.2f&#125;'</span>.format(adjusted_rand_score(clusters1, clusters2)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accuracy: 0.00</span><br><span class="line">ARI: 1.00</span><br></pre></td></tr></table></figure><h2 id="在没有真实值的情况下评估聚类">在没有真实值的情况下评估聚类</h2><p>在实践中，使用诸如ARI之类的指标有一个很大的问题。<strong>在应用聚类算法时，通常没有真实值来比较结果。</strong>如果我们知道了数据的正确聚类，那么可以使用这一信息构建一个监督模型（比如分类器）。因此，使用类似ARI和NMI的指标通常仅有助于开发算法，但对评估应用是否成功没有帮助。</p><p>有一些聚类的评分指标不需要真实值，比如<strong>轮廓系数</strong>（silhouette coefficient）。但它们在实践中的效果并不好。轮廓分数计算一个簇的紧致度，其值越大越好，最高分数为1。<strong>虽然紧致的簇很好，但紧致度不允许复杂的形状。</strong></p><p>下面是一个例子，利用轮廓分数在<code>two_moons</code>数据集上比较k均值、凝聚聚类和DBSCAN。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.metrics.silhouette_score" target="_blank" rel="noopener"><code>sklearn.metrics.silhouette_score(X, labels, metric=’euclidean’, sample_size=None, random_state=None, **kwds)</code></a></p><p>Compute the mean Silhouette Coefficient of all samples.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics.cluster <span class="keyword">import</span> silhouette_score</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(<span class="number">1</span>, <span class="number">4</span>, figsize=(<span class="number">15</span>, <span class="number">3</span>),</span><br><span class="line">    subplot_kw=&#123;<span class="string">'xticks'</span>: (), <span class="string">'yticks'</span>: ()&#125;)</span><br><span class="line"><span class="comment"># 绘制随机分配</span></span><br><span class="line">axes[<span class="number">0</span>].scatter(X_scaled[:, <span class="number">0</span>], X_scaled[:, <span class="number">1</span>], c=random_clusters,</span><br><span class="line">    cmap=mglearn.cm3, s=<span class="number">60</span>)</span><br><span class="line">axes[<span class="number">0</span>].set_title(<span class="string">'Random assignment: &#123;:.2f&#125;'</span>.format(</span><br><span class="line">    silhouette_score(X_scaled, random_clusters)))</span><br><span class="line"><span class="keyword">for</span> ax, algorithm <span class="keyword">in</span> zip(axes[<span class="number">1</span>:], algorithms):</span><br><span class="line">    clusters = algorithm.fit_predict(X_scaled)</span><br><span class="line">    ax.scatter(X_scaled[:, <span class="number">0</span>], X_scaled[:, <span class="number">1</span>], c=clusters,</span><br><span class="line">    cmap=mglearn.cm3, s=<span class="number">60</span>)</span><br><span class="line">    ax.set_title(<span class="string">'&#123;&#125;: &#123;:.2f&#125;'</span>.format(</span><br><span class="line">        algorithm.__class__.__name__, silhouette_score(X_scaled, clusters)))</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/silhouette-score-of-kmeans-agglomerative-clustering-and-dbscan.png"></p><p>k均值的轮廓分数最高，尽管我们可能更喜欢DBSCAN的结果。对于评估聚类，稍好的策略是使用<strong>基于鲁棒性的</strong>（robustness-based）聚类指标。这种指标优先向数据中添加一些噪声，或者使用不同的参数设定，然后运行算法，并对结果进行比较。其思想是，如果许多算法参数和许多数据扰动返回相同的结果，那么它很可能是可信的。不幸的是，<code>scikit-learn</code>还没有实现这一策略。</p><p>即使我们得到一个鲁棒性很好的聚类或者非常高的轮廓分数，但仍然不知道聚类中是否有任何语义含义，或者聚类是否反映了数据中我们感兴趣的某个方面。回到人脸图像的例子。我们希望找到类似人脸的分组，比如男人和女人、老人和年轻人，或者有胡子的人和没胡子的人。假设我们将数据分为两个簇，关于哪些点应该被聚类在一起，所有算法的结果一致。我们仍不知道找到的簇是否以某种方式对应我们感兴趣的概念。算法找到的可能是侧视图和正面视图、夜间拍摄的照片和白天拍摄的照片，或者iPhone拍摄的照片和安卓手机拍摄的照片。要想知道聚类是否对应于我们感兴趣的内容，唯一的办法就是对簇进行人工分析。</p><h2 id="在人脸数据集上比较算法">在人脸数据集上比较算法</h2><h3 id="用dbscan分析">用DBSCAN分析</h3><p>将k均值、DBSCAN和凝聚聚类算法应用于人脸数据集，并查看它们是否找到了有趣的结构。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从数据中提取特征脸，并对数组进行变换</span></span><br><span class="line">pca = PCA(n_components=<span class="number">100</span>, whiten=<span class="literal">True</span>, random_state=<span class="number">0</span>)</span><br><span class="line">X_pca = pca.fit_transform(X_people)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用默认参数的DBSCAN</span></span><br><span class="line">dbscan = DBSCAN()</span><br><span class="line">labels = dbscan.fit_predict(X_pca)</span><br><span class="line">print(<span class="string">'Unique labels: &#123;&#125;'</span>.format(np.unique(labels)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Unique labels: [-1]</span><br></pre></td></tr></table></figure><p>所有返回的标签都是-1，因此所有数据都被标记为“噪声”。我们可以改变两个参数来改进这一点：第一，我们可以增大eps，从而扩展每个点的邻域；第二，我们可以减小<code>min_samples</code>，从而将更小的点组视为簇。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 尝试改变min_samples</span></span><br><span class="line">dbscan = DBSCAN(min_samples=<span class="number">3</span>)</span><br><span class="line">labels = dbscan.fit_predict(X_pca)</span><br><span class="line">print(<span class="string">'Unique labels: &#123;&#125;'</span>.format(np.unique(labels)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Unique labels: [-1]</span><br></pre></td></tr></table></figure><p>即使仅考虑由三个点构成的组，所有点也都被标记为噪声。因此我们需要增大eps。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dbscan = DBSCAN(min_samples=<span class="number">3</span>, eps=<span class="number">15</span>)</span><br><span class="line">labels = dbscan.fit_predict(X_pca)</span><br><span class="line">print(<span class="string">'Unique labels: &#123;&#125;'</span>.format(np.unique(labels)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Unique labels: [-1  0]</span><br></pre></td></tr></table></figure><p>使用更大的eps，我们得到了单一簇和噪声点。我们可以利用这一结果找出“噪声”相对于其他数据的形状。为了进一步理解发生的事情，我们查看有多少点是噪声，有多少点在簇内。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算所有簇中的点数和噪声中的点数</span></span><br><span class="line"><span class="comment"># bincount不允许负值，所以我们需要加1</span></span><br><span class="line"><span class="comment"># 结果中的第一个数字对应于噪声点</span></span><br><span class="line">print(<span class="string">'Number of points per cluster: &#123;&#125;'</span>.format(np.bincount(labels + <span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line">noise = X_people[labels == <span class="number">-1</span>]</span><br><span class="line">fig, axes = plt.subplots(<span class="number">3</span>, <span class="number">11</span>, figsize=(<span class="number">12</span>, <span class="number">4</span>),</span><br><span class="line">    subplot_kw=&#123;<span class="string">'xticks'</span>: (), <span class="string">'yticks'</span>: (), <span class="string">'frameon'</span>: <span class="literal">False</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> image, ax <span class="keyword">in</span> zip(noise, axes.ravel()):</span><br><span class="line">    ax.imshow(image.reshape(image_shape), vmin=<span class="number">0</span>, vmax=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Number of points per cluster: [  32 2031]</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/noise-in-dbscan.png"></p><p>我们可以猜测它们被标记为噪声的原因：第2行第3张图像显示一个人正在用玻璃杯喝水，还有人戴帽子，人脸前面有一只手的图像。其他图像都包含奇怪的角度，或者太近或太宽的剪切。这种类型的分析——尝试找出“奇怪的哪一个”——被称为<strong>异常值检测</strong>（outlier detection）。如果这是一个真实的应用，那么我们可能会尝试更好地裁切图像，以得到更加均匀的数据。对于照片中的人有时戴着帽子、喝水或在面前举着某物，我们能做的事情很少。但需要知道它们是数据中存在的问题，我们应用任何算法都需要解决这些问题。</p><p>如果我们想要找到更有趣的簇，而不是一个非常大的簇，那么需要将eps设置的很小，取值在15和0.5（默认值）之间。我们来看一下eps不同取值对应的结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> eps <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>]:</span><br><span class="line">    print(<span class="string">'\neps=&#123;&#125;'</span>.format(eps))</span><br><span class="line">    dbscan = DBSCAN(eps=eps, min_samples=<span class="number">3</span>)</span><br><span class="line">    labels = dbscan.fit_predict(X_pca)</span><br><span class="line">    print(<span class="string">'Clusters present: &#123;&#125;'</span>.format(np.unique(labels)))</span><br><span class="line">    print(<span class="string">'Cluster sizes: &#123;&#125;'</span>.format(np.bincount(labels + <span class="number">1</span>)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eps=1</span><br><span class="line">Clusters present: [-1]</span><br><span class="line">Cluster sizes: [2063]</span><br><span class="line"></span><br><span class="line">eps=3</span><br><span class="line">Clusters present: [-1]</span><br><span class="line">Cluster sizes: [2063]</span><br><span class="line"></span><br><span class="line">eps=5</span><br><span class="line">Clusters present: [-1]</span><br><span class="line">Cluster sizes: [2063]</span><br><span class="line"></span><br><span class="line">eps=7</span><br><span class="line">Clusters present: [-1  0  1  2  3  4  5  6  7  8  9 10 11 12]</span><br><span class="line">Cluster sizes: [2004    3   14    7    4    3    3    4    4    3    3    5    3    3]</span><br><span class="line"></span><br><span class="line">eps=9</span><br><span class="line">Clusters present: [-1  0  1  2]</span><br><span class="line">Cluster sizes: [1307  750    3    3]</span><br><span class="line"></span><br><span class="line">eps=11</span><br><span class="line">Clusters present: [-1  0]</span><br><span class="line">Cluster sizes: [ 413 1650]</span><br><span class="line"></span><br><span class="line">eps=13</span><br><span class="line">Clusters present: [-1  0]</span><br><span class="line">Cluster sizes: [ 120 1943]</span><br></pre></td></tr></table></figure><p>对于较小的eps，所有点都被标记为噪声。eps=7时，我们得到许多噪声点和许多较小的簇。eps=9时，我们仍得到许多噪声点，但我们得到了一个较大的簇和一些较小的簇。从eps=11开始，我们仅得到一个较大的簇和噪声。</p><p>有趣的是，<strong>较大的簇从来没有超过一个。最多有一个较大的簇包含大多数点，还有一些较小的簇。这表示数据中没有两类或三类非常不同的人脸图像，而是所有图像或多或少地都与其他图像具有相同的相似度（或不相似度）。</strong></p><p>eps=7的结果看起来最有趣，它有许多较小的簇。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dbscan = DBSCAN(min_samples=<span class="number">3</span>, eps=<span class="number">7</span>)</span><br><span class="line">labels = dbscan.fit_predict(X_pca)</span><br><span class="line"></span><br><span class="line">n_clusters = max(labels) + <span class="number">1</span></span><br><span class="line">masks = [labels == i <span class="keyword">for</span> i <span class="keyword">in</span> range(n_clusters)]</span><br><span class="line">n_cols = max(np.sum(mask) <span class="keyword">for</span> mask <span class="keyword">in</span> masks)</span><br><span class="line"></span><br><span class="line">content = []</span><br><span class="line">i = j = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> mask <span class="keyword">in</span> masks:</span><br><span class="line">    <span class="keyword">if</span> n_cols - j - <span class="number">1</span> &lt; np.sum(mask):</span><br><span class="line">        i, j = i + <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> image, label <span class="keyword">in</span> zip(X_people[mask], y_people[mask]):</span><br><span class="line">        content.append((image, label, i, j))</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">n_rows = i + <span class="number">1</span></span><br><span class="line">fig, axes = plt.subplots(n_rows, n_cols,</span><br><span class="line">    figsize=(n_cols * <span class="number">1.5</span>, n_rows * <span class="number">2</span>),</span><br><span class="line">    subplot_kw=&#123;<span class="string">'xticks'</span>: (), <span class="string">'yticks'</span>: (), <span class="string">'frameon'</span>: <span class="literal">False</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> image, label, i, j <span class="keyword">in</span> content:</span><br><span class="line">    ax = axes[i, j]</span><br><span class="line">    ax.imshow(image.reshape(image_shape), vmin=<span class="number">0</span>, vmax=<span class="number">1</span>)</span><br><span class="line">    ax.set_title(people.target_names[label].split()[<span class="number">-1</span>])</span><br><span class="line">plt.tight_layout()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/clusters-of-7-eps-dbscan.png"></p><p>有一些簇对应于数据集中脸部非常不同的人，比如Sharon（沙龙）或Koizumi（小泉）。在每个簇中，人脸方向和面部表情也是固定的。有些簇中包含多个人的面孔，但他们的表情和方向都相似。</p><p>这就是将DBSCAN算法应用于人脸数据集的分析结论。如你所见，我们这里进行了人工分析，不同于监督学习中基于<span class="math inline">\(R^2\)</span>分数或精度的更为自动化的方法。</p><h3 id="用k均值分析">用k均值分析</h3><p>我们看到，利用DBSCAN无法创建多于一个较大的簇。凝聚聚类和k均值更可能创建君悦大小的簇，但我们需要设置簇的目标个数。我们可以将簇的数量设置为数据集中的已知人数，虽然无监督聚类算法不太可能完全找到它们。相反，我们可以首先设置一个比较小的簇的数量，比如10个，这样我们可以分析每个簇。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用k均值提取簇</span></span><br><span class="line">km = KMeans(n_clusters=<span class="number">10</span>, random_state=<span class="number">0</span>)</span><br><span class="line">labels_km = km.fit_predict(X_pca)</span><br><span class="line">print(<span class="string">'Cluster sizes k-means: &#123;&#125;'</span>.format(np.bincount(labels_km)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cluster sizes k-means: [155 175 238  75 358 257  91 219 323 172]</span><br></pre></td></tr></table></figure><p>k均值聚类将数据划分成大小相似的簇，其大小在75和358之间。这与DBSCAN的结果非常不同。我们可以通过将簇中心可视化来进一步分析k均值的结果。由于我们是在PCA生成的表示中进行聚类，因此我们需要使用<code>pca.inverse_transform</code>将簇中心旋转回到原始空间并可视化。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">5</span>, figsize=(<span class="number">12</span>, <span class="number">4</span>),</span><br><span class="line">    subplot_kw=&#123;<span class="string">'xticks'</span>: (), <span class="string">'yticks'</span>: ()&#125;)</span><br><span class="line"><span class="keyword">for</span> center, ax <span class="keyword">in</span> zip(km.cluster_centers_, axes.ravel()):</span><br><span class="line">    ax.imshow(pca.inverse_transform(center).reshape(image_shape),</span><br><span class="line">        vmin=<span class="number">0</span>, vmax=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/cluster-centers-of-kmeans-faces.png"></p><p>k均值找到的簇中心是非常平滑的人脸。这并不奇怪，因为每个簇中心都是许多张人脸图像的平均。使用降维的PCA表示，可以增加图像的平滑度（对比利用100个PCA维度重建的人物图像）。聚类似乎捕捉到人脸的不同方向（下图的第7个簇）、不同表情（下图的第4个簇）。下图给出了更详细的视图，我们对每个簇中心给出了簇中5张最典型的图像（该簇中与簇中心距离最近的图像）与5张最不典型的图像（该簇中与簇中心距离最远的图像）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_kmeans_faces(km, pca, X_pca, X_people, y_people,</span><br><span class="line">    people.target_names)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/kmeans-faces-close-and-far.png"></p><p>“非典型的”点与簇中心不太相似，而且它们的分配似乎有些随意。这可以归因于以下事实：k均值对所有数据点进行划分，不像DBSCAN那样具有“噪声”点的概念。利用更多数量的簇，算法可以找到更细微的区别。但添加更多的簇会使得人工检查更加困难。</p><h3 id="用凝聚聚类分析">用凝聚聚类分析</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用ward凝聚聚类提取簇</span></span><br><span class="line">agglomerative = AgglomerativeClustering(n_clusters=<span class="number">10</span>)</span><br><span class="line">labels_agg = agglomerative.fit_predict(X_pca)</span><br><span class="line">print(<span class="string">'Cluster sizes agglomerative clustering: &#123;&#125;'</span>.format(</span><br><span class="line">    np.bincount(labels_agg)))</span><br><span class="line"><span class="comment"># 通过计算ARI来度量凝聚聚类和k均值给出的两种数据划分是否相似</span></span><br><span class="line">print(<span class="string">'ARI: &#123;:.2f&#125;'</span>.format(adjusted_rand_score(labels_agg, labels_km)))</span><br><span class="line"><span class="comment"># 绘制树状图，限制了树的深度，因为如果分支到2063个数据点，图像将密密麻麻无法阅读</span></span><br><span class="line">linkage_array = ward(X_pca)</span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>, <span class="number">5</span>))</span><br><span class="line">dendrogram(linkage_array, p=<span class="number">7</span>, truncate_mode=<span class="string">'level'</span>, no_labels=<span class="literal">True</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Sample index'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Cluster distance'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cluster sizes agglomerative clustering: [169 660 144 329 217  85  18 261  31 149]</span><br><span class="line">ARI: 0.09</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/agglomerative-clustering-dendrogram-on-faces.png"></p><p>凝聚聚类生成的簇大小在18和660之间。这比k均值生成的簇更不均匀，但比DBSCAN生成的簇要更均匀。ARI只有0.09，说明<code>labels_agg</code>和<code>labels_km</code>这两种聚类的共同点很少。这不奇怪，原因在于以下事实：对于k均值，远离簇中心的点似乎没有什么共同点。</p><p>要想创建10个簇，我们在顶部有10条竖线的位置将树横切。在图示的玩具数据的树状图中，你可以从分支长度中看出，两个或三个簇就可以很好地划分数据。对于人脸数据而言，似乎没有非常自然的切割点。有一些分支代表更为不同的组，但似乎没有一个特别合适的簇的数量。这并不奇怪，因为DBSCAN（原书可能有错误，此处应该是凝聚聚类）的结果是视图将所有点都聚类在一起。</p><p>我们将10个簇可视化，正如之前对k均值所做的那样。在凝聚聚类中没有簇中心的概念（虽然我们计算平均值），我们只是给出了每个簇的前几个点。我们在第一张图的左侧给出了每个簇中的点的数量。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n_clusters = <span class="number">10</span></span><br><span class="line">flg, axes = plt.subplots(n_clusters, <span class="number">10</span>, figsize=(<span class="number">15</span>, <span class="number">2</span> * n_clusters),</span><br><span class="line">    subplot_kw=&#123;<span class="string">'xticks'</span>: (), <span class="string">'yticks'</span>: ()&#125;)</span><br><span class="line"><span class="keyword">for</span> cluster <span class="keyword">in</span> range(n_clusters):</span><br><span class="line">    mask = labels_agg == cluster</span><br><span class="line">    axes[cluster, <span class="number">0</span>].set_ylabel(np.sum(mask))</span><br><span class="line">    <span class="keyword">for</span> image, label, asdf, ax <span class="keyword">in</span> zip(X_people[mask],</span><br><span class="line">            y_people[mask], labels_agg[mask], axes[cluster]):</span><br><span class="line">        ax.imshow(image.reshape(image_shape), vmin=<span class="number">0</span>, vmax=<span class="number">1</span>)</span><br><span class="line">        ax.set_title(people.target_names[label].split()[<span class="number">-1</span>],</span><br><span class="line">            fontdict=&#123;<span class="string">'fontsize'</span>: <span class="number">9</span>&#125;)</span><br><span class="line">plt.tight_layout()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/clusters-of-agglomerative-clustering.png"></p><p>虽然某些簇似乎具有语义上的主题，但许多簇都太大而实际上很难是均匀的。</p><h3 id="聚类方法小结">聚类方法小结</h3><p>聚类的应用与评估是一个非常定性的过程，通常在数据分析的探索阶段很有帮助。我们学习了三种聚类算法：k均值、DBSCAN和凝聚聚类。这三种算法都可以控制聚类的粒度（granularity）。k均值和凝聚聚类允许你指定想要的簇的数量，而DBSCAN允许你用eps参数定义接近程度，从而间接影响簇的大小。</p><p>每种算法的优点稍有不同。k均值可以用簇的平均值来表示簇。它还可以被看作一种分解方法，每个数据点都由其簇中心表示。DBSCAN可以检测到没有分配任何簇的“噪声点”，还可以帮助自动判断簇的数量。与其他两种方法不同，它允许簇具有复杂的形状。DBSCAN有时会生成大小差别很大的簇，这可能是它的优点，也可能是缺点。凝聚聚类可以提供数据的可能划分的整个层次结构，可以通过树状图轻松查看。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Machine Learning with Python </tag>
            
            <tag> unsupervised </tag>
            
            <tag> clustering </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>降维、特征提取与流形学习</title>
      <link href="/notes/introduction-to-ml-with-python/dimensionality-reduction-feature-extraction-and-manifold-learning/"/>
      <url>/notes/introduction-to-ml-with-python/dimensionality-reduction-feature-extraction-and-manifold-learning/</url>
      
        <content type="html"><![CDATA[<p>利用无监督学习进行数据变换可能有很多种目的。最常见的目的就是可视化、压缩数据，以及寻找信息量更大的数据表示以用于进一步的处理。</p><p>为了实现这些目的，最简单也最常用的一种算法就是主成分分析。我们也将学习另外两种算法：非负矩阵分解（NMF）和t-SNE，前者通常用于特征提取，后者通常用于二维散点的可视化。</p><h1 id="主成分分析">主成分分析</h1><p>主成分分析（principal component analysis，PCA）是一种旋转数据集的方法，旋转后的特征在统计上不相关。在做完这种旋转之后，通常是根据新特征对解释数据的重要性来选择它的一个子集。下面的例子展示了PCA对一个模拟二维数据集的作用。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.decomposition.pca" target="_blank" rel="noopener"><code>class sklearn.decomposition.PCA(n_components=None, copy=True, whiten=False, svd_solver=’auto’, tol=0.0, iterated_power=’auto’, random_state=None)</code></a></p><p>Principal component analysis (PCA)</p></blockquote><a id="more"></a><h2 id="将pca应用于模拟数据">将PCA应用于模拟数据</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 函数源码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_pca_illustration</span><span class="params">()</span>:</span></span><br><span class="line">    rnd = np.random.RandomState(<span class="number">5</span>)</span><br><span class="line">    X_ = rnd.normal(size=(<span class="number">300</span>, <span class="number">2</span>))</span><br><span class="line">    X_blob = np.dot(X_, rnd.normal(size=(<span class="number">2</span>, <span class="number">2</span>))) + rnd.normal(size=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    pca = PCA()</span><br><span class="line">    pca.fit(X_blob)</span><br><span class="line">    X_pca = pca.transform(X_blob)</span><br><span class="line"></span><br><span class="line">    S = X_pca.std(axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">    axes = axes.ravel()</span><br><span class="line"></span><br><span class="line">    axes[<span class="number">0</span>].set_title(<span class="string">"Original data"</span>)</span><br><span class="line">    axes[<span class="number">0</span>].scatter(X_blob[:, <span class="number">0</span>], X_blob[:, <span class="number">1</span>], c=X_pca[:, <span class="number">0</span>], linewidths=<span class="number">0</span>,</span><br><span class="line">                    s=<span class="number">60</span>, cmap=<span class="string">'viridis'</span>)</span><br><span class="line">    axes[<span class="number">0</span>].set_xlabel(<span class="string">"feature 1"</span>)</span><br><span class="line">    axes[<span class="number">0</span>].set_ylabel(<span class="string">"feature 2"</span>)</span><br><span class="line">    axes[<span class="number">0</span>].arrow(pca.mean_[<span class="number">0</span>], pca.mean_[<span class="number">1</span>], S[<span class="number">0</span>] * pca.components_[<span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                  S[<span class="number">0</span>] * pca.components_[<span class="number">0</span>, <span class="number">1</span>], width=<span class="number">.1</span>, head_width=<span class="number">.3</span>,</span><br><span class="line">                  color=<span class="string">'k'</span>)</span><br><span class="line">    axes[<span class="number">0</span>].arrow(pca.mean_[<span class="number">0</span>], pca.mean_[<span class="number">1</span>], S[<span class="number">1</span>] * pca.components_[<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">                  S[<span class="number">1</span>] * pca.components_[<span class="number">1</span>, <span class="number">1</span>], width=<span class="number">.1</span>, head_width=<span class="number">.3</span>,</span><br><span class="line">                  color=<span class="string">'k'</span>)</span><br><span class="line">    axes[<span class="number">0</span>].text(<span class="number">-1.5</span>, <span class="number">-.5</span>, <span class="string">"Component 2"</span>, size=<span class="number">14</span>)</span><br><span class="line">    axes[<span class="number">0</span>].text(<span class="number">-4</span>, <span class="number">-4</span>, <span class="string">"Component 1"</span>, size=<span class="number">14</span>)</span><br><span class="line">    axes[<span class="number">0</span>].set_aspect(<span class="string">'equal'</span>)</span><br><span class="line"></span><br><span class="line">    axes[<span class="number">1</span>].set_title(<span class="string">"Transformed data"</span>)</span><br><span class="line">    axes[<span class="number">1</span>].scatter(X_pca[:, <span class="number">0</span>], X_pca[:, <span class="number">1</span>], c=X_pca[:, <span class="number">0</span>], linewidths=<span class="number">0</span>,</span><br><span class="line">                    s=<span class="number">60</span>, cmap=<span class="string">'viridis'</span>)</span><br><span class="line">    axes[<span class="number">1</span>].set_xlabel(<span class="string">"First principal component"</span>)</span><br><span class="line">    axes[<span class="number">1</span>].set_ylabel(<span class="string">"Second principal component"</span>)</span><br><span class="line">    axes[<span class="number">1</span>].set_aspect(<span class="string">'equal'</span>)</span><br><span class="line">    axes[<span class="number">1</span>].set_ylim(<span class="number">-8</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    pca = PCA(n_components=<span class="number">1</span>)</span><br><span class="line">    pca.fit(X_blob)</span><br><span class="line">    X_inverse = pca.inverse_transform(pca.transform(X_blob))</span><br><span class="line"></span><br><span class="line">    axes[<span class="number">2</span>].set_title(<span class="string">"Transformed data w/ second component dropped"</span>)</span><br><span class="line">    axes[<span class="number">2</span>].scatter(X_pca[:, <span class="number">0</span>], np.zeros(X_pca.shape[<span class="number">0</span>]), c=X_pca[:, <span class="number">0</span>],</span><br><span class="line">                    linewidths=<span class="number">0</span>, s=<span class="number">60</span>, cmap=<span class="string">'viridis'</span>)</span><br><span class="line">    axes[<span class="number">2</span>].set_xlabel(<span class="string">"First principal component"</span>)</span><br><span class="line">    axes[<span class="number">2</span>].set_aspect(<span class="string">'equal'</span>)</span><br><span class="line">    axes[<span class="number">2</span>].set_ylim(<span class="number">-8</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    axes[<span class="number">3</span>].set_title(<span class="string">"Back-rotation using only first component"</span>)</span><br><span class="line">    axes[<span class="number">3</span>].scatter(X_inverse[:, <span class="number">0</span>], X_inverse[:, <span class="number">1</span>], c=X_pca[:, <span class="number">0</span>],</span><br><span class="line">                    linewidths=<span class="number">0</span>, s=<span class="number">60</span>, cmap=<span class="string">'viridis'</span>)</span><br><span class="line">    axes[<span class="number">3</span>].set_xlabel(<span class="string">"feature 1"</span>)</span><br><span class="line">    axes[<span class="number">3</span>].set_ylabel(<span class="string">"feature 2"</span>)</span><br><span class="line">    axes[<span class="number">3</span>].set_aspect(<span class="string">'equal'</span>)</span><br><span class="line">    axes[<span class="number">3</span>].set_xlim(<span class="number">-8</span>, <span class="number">4</span>)</span><br><span class="line">    axes[<span class="number">3</span>].set_ylim(<span class="number">-8</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">mglearn.plots.plot_pca_illustration()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/pca.png"></p><p>算法首先找到方法最大的方向，将其标记为“成分1”（Component 1）。这是数据中包含最多信息的方向（或向量），换句话说，沿着这个方向的特征之间最为相关。然后，算法找到与第一个方向正交（成直角）且包含最多信息的方向。在二维空间中，只有一个成直角的方向，但在更高维的空间中会有（无穷）多的正交方向。虽然这两个成分都画成箭头，但其头尾的位置并不重要。我们也可以将第一个成分化成从中心指向左上，而不是右下。利用这一过程找到的方向被称为主成分，因为它们是数据方差的主要方向。一般来说，主成分的个数与原始特征相同。</p><p>第二张图（右上）显示的是同样的数据，但现在将其旋转，使得第一主成分与x轴平行且第二主成分与y轴平行。在旋转之前，从数据中减去平均值，使得变换后的数据以零为中心。在PCA找到的旋转表示中，两个坐标轴是不相关的，也就是说，对于这种数据表示，除了对角线，相关矩阵全部为零。</p><p>我们可以通过仅保留一部分主成分来使用PCA进行降维。在这个例子中，我们可以仅保留第一主成分，正如第三张图（左下）所示。这将数据从二维数据集降为一维数据集。但要注意，我们没有保留原始特征之一，而是找到了最有趣的方向（第一张图中从左上到右下）并保留这一方向，即第一主成分。</p><p>最后，我们可以反向旋转并将平均值重新加到数据集中。这样会得到最后一张图中的数据。这些数据点位于原始特征空间中，但我们仅保留了第一主成分中包含的信息。这种变换有时用于去除数据中的噪声影响，或者将主成分中保留的那部分信息可视化。</p><h2 id="将pca应用于cancer数据集并可视化">将PCA应用于cancer数据集并可视化</h2><p>PCA最常见的应用之一就是将高维数据可视化。对于有两个以上特征的数据，很难绘制散点图。对于Iris（鸢尾花）数据集，我们可以创建散点图矩阵，通过展示特征所有可能的两两组和来展示数据的局部图像。但如果我们想要查看乳腺癌数据集，即便用散点图矩阵也很困难。这个数据集包含30个特征，这就导致需要绘制<code>30*14=420</code>张散点图！我们永远不可能仔细观察所有这些图像，更不用说试图理解它们了。</p><p>不过我们可以使用一种更简单的可视化方法——对每个特征分别计算两个类别（良性肿瘤和恶性肿瘤）的直方图。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, axes = plt.subplots(<span class="number">15</span>, <span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">20</span>))</span><br><span class="line">malignant = cancer.data[cancer.target == <span class="number">0</span>]</span><br><span class="line">benign = cancer.data[cancer.target == <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">ax = axes.ravel()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">    _, bins = np.histogram(cancer.data[:, i], bins=<span class="number">50</span>)</span><br><span class="line">    ax[i].hist(malignant[:, i], bins=bins, color=mglearn.cm3(<span class="number">0</span>), alpha=<span class="number">.5</span>)</span><br><span class="line">    ax[i].hist(benign[:, i], bins=bins, color=mglearn.cm3(<span class="number">2</span>), alpha=<span class="number">.5</span>)</span><br><span class="line">    ax[i].set_title(cancer.feature_names[i])</span><br><span class="line">    ax[i].set_yticks(())</span><br><span class="line"></span><br><span class="line">ax[<span class="number">0</span>].set_xlabel(<span class="string">'Feature magnitude'</span>)</span><br><span class="line">ax[<span class="number">0</span>].set_ylabel(<span class="string">'Frequency'</span>)</span><br><span class="line">ax[<span class="number">0</span>].legend([<span class="string">'malignant'</span>, <span class="string">'benign'</span>], loc=<span class="string">'best'</span>)</span><br><span class="line">fig.tight_layout()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/feature-hist.png"></p><p>这里我们为每个特征创建一个直方图，计算具有某一特征的数据点在特定范围内（叫作bin）的出现频率。每张图都包含两个直方图，一个是良性类别的所有点（蓝色），一个是恶性类别的所有点（红色）。这样我们可以了解每个特征在两个类别中的分布情况，也可以猜测哪些特征能够更好地区分良性样本和恶性样本。例如，“smoothness error”特征似乎没有什么信息量，因为两个直方图大部分都重叠在一起，而“worst concave points”特征看起来信息量相当大，因为两个直方图的交集很小。</p><p>但是，这种图无法向我们展示变量之间的相互作用以及这种相互作用与类别之间的关系。<strong>利用PCA，我们可以获取到主要的相互作用，并得到稍为完整的图像。</strong>我们可以找到前两个主成分，并在这个新的二维空间中用散点图将数据可视化。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在应用PCA之前，利用StandardScaler缩放数据，使每个特征的方差均为1</span></span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">scaler.fit(cancer.data)</span><br><span class="line">X_scaled = scaler.transform(cancer.data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留数据的前两个主要成分</span></span><br><span class="line">pca = PCA(n_components=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 对乳腺癌数据拟合PCA模型</span></span><br><span class="line">pca.fit(X_scaled)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据变换到前两个主要成分上</span></span><br><span class="line">X_pca = pca.transform(X_scaled)</span><br><span class="line">print(<span class="string">'Original shape: &#123;&#125;'</span>.format(str(X_scaled.shape)))</span><br><span class="line">print(<span class="string">'Reduced shape: &#123;&#125;'</span>.format(str(X_pca.shape)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对第一个和第二个主成分作图，按类别着色</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">mglearn.discrete_scatter(X_pca[:, <span class="number">0</span>], X_pca[:, <span class="number">1</span>], cancer.target)</span><br><span class="line">plt.legend(cancer.target_names, loc=<span class="string">'best'</span>)</span><br><span class="line">plt.gca().set_aspect(<span class="string">'equal'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'First principal component'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Second principal component'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Original shape: (569, 30)</span><br><span class="line">Reduced shape: (569, 2)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/pca-on-cancer.png"></p><p>重要的是要注意，PCA是一种无监督方法，在寻找旋转方向时没有用到任何类别信息。它只是观察数据中的相关性。对于这里所示的散点图，我们绘制了第一主成分和第二主成分之间的关系，然后利用类别信息对数据点进行着色。你可以看到，在这个二维空间中两个类别被很好的分离。这让我们相信，即使是线性分类器（在这个空间中学习一条直线）也可以在区分这两个类别时表现得相当不错。我们还可以看到，恶性点比良性点更加分散，这一点也可以在直方图中看出来。</p><p>PCA的一个缺点在于，通常不容易对图中的两个轴做出解释。主成分对应于原始数据中的方向，所以它们是原始特征的组合。但这些组合往往非常复杂，这一点我们很快就会看到。在拟合过程中，主成分被保存在PCA对象的<code>components_</code>属性中。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'PCA component shape: &#123;&#125;'</span>.format(pca.components_.shape))</span><br><span class="line">print(<span class="string">'PCA components:\n&#123;&#125;'</span>.format(pca.components_))</span><br><span class="line"><span class="comment"># 用热图将系数可视化</span></span><br><span class="line">plt.matshow(pca.components_, cmap=<span class="string">'viridis'</span>)</span><br><span class="line">plt.yticks([<span class="number">0</span>, <span class="number">1</span>], [<span class="string">'First component'</span>, <span class="string">'Second component'</span>])</span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.xticks(range(len(cancer.feature_names)),</span><br><span class="line">    cancer.feature_names, rotation=<span class="number">60</span>, ha=<span class="string">'left'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Feature'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Principal components'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PCA component shape: (2, 30)</span><br><span class="line">PCA components:</span><br><span class="line">[[ 0.21890244  0.10372458  0.22753729  0.22099499  0.14258969  0.23928535</span><br><span class="line">   0.25840048  0.26085376  0.13816696  0.06436335  0.20597878  0.01742803</span><br><span class="line">   0.21132592  0.20286964  0.01453145  0.17039345  0.15358979  0.1834174</span><br><span class="line">   0.04249842  0.10256832  0.22799663  0.10446933  0.23663968  0.22487053</span><br><span class="line">   0.12795256  0.21009588  0.22876753  0.25088597  0.12290456  0.13178394]</span><br><span class="line"> [-0.23385713 -0.05970609 -0.21518136 -0.23107671  0.18611302  0.15189161</span><br><span class="line">   0.06016536 -0.0347675   0.19034877  0.36657547 -0.10555215  0.08997968</span><br><span class="line">  -0.08945723 -0.15229263  0.20443045  0.2327159   0.19720728  0.13032156</span><br><span class="line">   0.183848    0.28009203 -0.21986638 -0.0454673  -0.19987843 -0.21935186</span><br><span class="line">   0.17230435  0.14359317  0.09796411 -0.00825724  0.14188335  0.27533947]]</span><br></pre></td></tr></table></figure><p><code>components_</code>中的每一行对应于一个主成分，它们按重要性排序（第一主成分排在首位，以此类推）。列对应于PCA的原始特征属性。</p><p><img src="/uploads/image/introduction-to-ml-with-python/2-principal-components-of-cancer.png"></p><p>在第一个主成分中，<strong>所有特征的符号相同（均为正，但前面我们提到过，箭头指向哪个方向无关紧要）。这意味着在所有特征之间存在普遍的相关性。</strong>如果一个测量值较大的话，其他的测量值可能也较大。第二个主成分的符号有正有负，而且两个主成分都包含30个特征。这种所有特征的混合使得解释上图中的坐标轴变得十分困难。</p><h2 id="特征提取的特征脸">特征提取的特征脸</h2><p>PCA的另一个应用是特征提取。特征提取背后的思想是，可以找到一种数据表示，比给定的原始表示更适合于分析。特征提取很有用，它的一个很好的应用实例就是图像。图像由像素组成，通常存储为红绿蓝（RGB）强度。图像中的对象通常由千万个像素组成，它们只有放在一起才有意义。</p><p>我们将给出用PCA对图像做特征提取的一个简单应用，即处理Wild数据集Labeled Faces中的人脸图像。这一数据集包含从互联网下载的名人脸部图像，它包含从21世纪初开始的政治家、歌手、演员和运动员的人脸图像。我们使用这些图像的灰度版本，并将它们按比例缩小以加快处理速度。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_lfw_people</span><br><span class="line"></span><br><span class="line">people = fetch_lfw_people(min_faces_per_person=<span class="number">20</span>, resize=<span class="number">.7</span>)</span><br><span class="line">image_shape = people.images[<span class="number">0</span>].shape</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">5</span>, figsize=(<span class="number">15</span>, <span class="number">8</span>),</span><br><span class="line">    subplot_kw=&#123;<span class="string">'xticks'</span>: (), <span class="string">'yticks'</span>: ()&#125;)</span><br><span class="line"><span class="keyword">for</span> target, image, ax <span class="keyword">in</span> zip(people.target, people.images, axes.ravel()):</span><br><span class="line">    ax.imshow(image, cmap=plt.cm.gray_r)</span><br><span class="line">    ax.set_title(people.target_names[target])</span><br><span class="line"></span><br><span class="line">print(<span class="string">'people.images.shape: &#123;&#125;'</span>.format(people.images.shape))</span><br><span class="line">print(<span class="string">'Number of classes: &#123;&#125;'</span>.format(len(people.target_names)))</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/datasets-lfw-people.png"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">people.images.shape: (3023, 87, 65)  # 一共有3023张图像，每张大小为87像素x65像素</span><br><span class="line">Number of classes: 62  # 分别属于62个不同的人</span><br></pre></td></tr></table></figure><p>这个数据集有些偏斜，其中包含George W. Bush（小布什）和Colin Powell（科林·鲍威尔）的大量图像。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算每个目标出现的次数</span></span><br><span class="line">counts = np.bincount(people.target)</span><br><span class="line"><span class="comment"># 将次数与目标名称一起打印出来</span></span><br><span class="line"><span class="keyword">for</span> i, (count, name) <span class="keyword">in</span> enumerate(zip(counts, people.target_names)):</span><br><span class="line">    print(<span class="string">'&#123;0:25&#125; &#123;1:3&#125;'</span>.format(name, count), end=<span class="string">'    '</span>)</span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">        print()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alejandro Toledo           39    Alvaro Uribe               35    Amelie Mauresmo            21</span><br><span class="line">Andre Agassi               36    Angelina Jolie             20    Ariel Sharon               77</span><br><span class="line">Arnold Schwarzenegger      42    Atal Bihari Vajpayee       24    Bill Clinton               29</span><br><span class="line">Carlos Menem               21    Colin Powell              236    David Beckham              31</span><br><span class="line">Donald Rumsfeld           121    George Robertson           22    George W Bush             530</span><br><span class="line">Gerhard Schroeder         109    Gloria Macapagal Arroyo    44    Gray Davis                 26</span><br><span class="line">Guillermo Coria            30    Hamid Karzai               22    Hans Blix                  39</span><br><span class="line">Hugo Chavez                71    Igor Ivanov                20    Jack Straw                 28</span><br><span class="line">Jacques Chirac             52    Jean Chretien              55    Jennifer Aniston           21</span><br><span class="line">Jennifer Capriati          42    Jennifer Lopez             21    Jeremy Greenstock          24</span><br><span class="line">Jiang Zemin                20    John Ashcroft              53    John Negroponte            31</span><br><span class="line">Jose Maria Aznar           23    Juan Carlos Ferrero        28    Junichiro Koizumi          60</span><br><span class="line">Kofi Annan                 32    Laura Bush                 41    Lindsay Davenport          22</span><br><span class="line">Lleyton Hewitt             41    Luiz Inacio Lula da Silva  48    Mahmoud Abbas              29</span><br><span class="line">Megawati Sukarnoputri      33    Michael Bloomberg          20    Naomi Watts                22</span><br><span class="line">Nestor Kirchner            37    Paul Bremer                20    Pete Sampras               22</span><br><span class="line">Recep Tayyip Erdogan       30    Ricardo Lagos              27    Roh Moo-hyun               32</span><br><span class="line">Rudolph Giuliani           26    Saddam Hussein             23    Serena Williams            52</span><br><span class="line">Silvio Berlusconi          33    Tiger Woods                23    Tom Daschle                25</span><br><span class="line">Tom Ridge                  33    Tony Blair                144    Vicente Fox                32</span><br><span class="line">Vladimir Putin             49    Winona Ryder               24</span><br></pre></td></tr></table></figure><p>为了降低数据偏斜，我们对每个人最多只取50张图像（否则，特征提取将会被George w. Bush影响的可能性大大增加）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mask = np.zeros(people.target.shape, dtype=np.bool)</span><br><span class="line"><span class="keyword">for</span> target <span class="keyword">in</span> np.unique(people.target):</span><br><span class="line">    mask[np.where(people.target == target)[<span class="number">0</span>][:<span class="number">50</span>]] = <span class="number">1</span>  <span class="comment"># 各取前50个</span></span><br><span class="line"></span><br><span class="line">X_people = people.data[mask]</span><br><span class="line">y_people = people.target[mask]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将灰度值缩放到0到1之间，而不是在0到255之间</span></span><br><span class="line"><span class="comment"># 以得到更好的数据稳定性</span></span><br><span class="line">X_people = X_people / <span class="number">255</span></span><br></pre></td></tr></table></figure><p>人脸识别的一个常见任务就是看某个前所未见的人脸是否属于数据库中某个已知人物。这在照片收集、社交媒体和安全应用中都有应用。<strong>解决这个问题的方法之一就是构建一个分类器，每个人都是一个单独的类别。但人脸数据库中通常有许多不同的人，而同一个人的图像很少（也就是说，每个类别的训练样例很少）。这使得大多数分类器的训练都很困难。另外，通常你还想要能够轻松添加新的人物，不需要重新训练一个大型模型。</strong></p><p><strong>一种简单的解决方法是使用单一最近邻分类器，寻找与你要分类的人脸最为相似的人脸。这个分类器原则上可以处理每个类别只有一个训练样例的情况。</strong>下面看一下<code>KNeighborsClassifier</code>的表现如何。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将数据划分为训练集和测试集</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">    X_people, y_people, stratify=y_people, random_state=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 使用一个邻居构建</span></span><br><span class="line">knn = KNeighborsClassifier(n_neighbors=<span class="number">1</span>)</span><br><span class="line">knn.fit(X_train, y_train)</span><br><span class="line">print(<span class="string">'Test set score of 1-nn: &#123;:.2f&#125;'</span>.format(knn.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test set score of 1-nn: 0.23</span><br></pre></td></tr></table></figure><p>我们得到的精度为23%。对于包含62个类别的分类问题来说，这实际上不算太差，但也不算好。</p><p>这里就可以用到PCA。<strong>想要度量人脸的相似度，计算原始像素空间中的距离是一种相当糟糕的方法。用像素表示来比较两张图时，我们比较的是每个像素的灰度值与另一张图像对应位置的像素灰度值。这种表示与人们对人脸图像的解释方式有很大不同，使用这种原始表示很难获取到面部特征。例如，如果使用像素距离，那么将人脸向右移动一个像素将会发生巨大的变化，得到一个完全不同的表示。</strong>我们希望，使用沿着主成分方向的距离可以提高精度。这里我们启动PCA的<strong>白化</strong>（whitening）选项，它将主成分缩放到相同的尺度。变换后的结果与使用<code>StandardScaler</code>相同。白化不仅对应于旋转数据，还对应于缩放数据使其形状是圆形而不是椭圆。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_pca_whitening()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/pca-whitening.png"></p><p>我们对训练数据拟合PCA对象，并提取前100个主成分。然后对训练数据和测试数据进行变换。再对新表示使用单一最近邻分类器来将图像分类。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pca = PCA(n_components=<span class="number">100</span>, whiten=<span class="literal">True</span>, random_state=<span class="number">0</span>).fit(X_train)</span><br><span class="line">X_train_pca = pca.transform(X_train)</span><br><span class="line">X_test_pca = pca.transform(X_test)</span><br><span class="line">print(<span class="string">'X_train_pca.shape: &#123;&#125;'</span>.format(X_train_pca.shape))</span><br><span class="line"></span><br><span class="line">knn = KNeighborsClassifier(n_neighbors=<span class="number">1</span>)</span><br><span class="line">knn.fit(X_train_pca, y_train)</span><br><span class="line">print(<span class="string">'Test set accuracy: &#123;:.2f&#125;'</span>.format(knn.score(X_test_pca, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test set accuracy: 0.31</span><br></pre></td></tr></table></figure><p>我们的精度有了相当显著的提高，这证实了我们的直觉，即<strong>主成分可能提供了一种更好的数据表示。</strong></p><p><strong>对于图像数据，我们还可以很容易地将找到的主成分可视化。请记住，成分对应于输入空间里的方向。</strong>这里的输入空间是87像素x65像素的灰度图像，所以在这个空间中的方向也是87像素x65像素的灰度图像。我们来看一下前几个主成分。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'pca.components_.shape: &#123;&#125;'</span>.format(pca.components_.shape))</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(<span class="number">3</span>, <span class="number">5</span>, figsize=(<span class="number">15</span>, <span class="number">12</span>),</span><br><span class="line">    subplot_kw=&#123;<span class="string">'xticks'</span>: (), <span class="string">'yticks'</span>: ()&#125;)</span><br><span class="line"><span class="keyword">for</span> i, (component, ax) <span class="keyword">in</span> enumerate(zip(pca.components_, axes.ravel())):</span><br><span class="line">    ax.imshow(component.reshape(image_shape), cmap=<span class="string">'viridis'</span>)</span><br><span class="line">    ax.set_title(<span class="string">"&#123;&#125;. component"</span>.format(i + <span class="number">1</span>))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pca.components_.shape: (100, 5655)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/visualization-of-image-pca.png"></p><p>虽然我们肯定无法理解这些成分的所有内容，但可以猜测一些主成分捕捉到了人脸图像的哪些方面。第一个主成分似乎主要编码的是人脸与背景的对比，第二个主成分编码的是人脸左半部分和右半部分的明暗程度差异，如此等等。虽然这种表示比原始像素值的语义稍强，但它仍与人们感知人脸的方式相去甚远。<strong>由于PCA模型是基于像素的，因此人脸的相对位置（眼睛、下巴和鼻子的位置）和明暗程度都对两张图像在像素表示中的相似程度有很大印象。但人脸的相对位置和明暗程度可能并不是人们首先感知的内容。</strong>在要求人们评价人脸的相似度时，他们更可能会使用年龄、性别、面部表情和发型等属性，而这些属性很难从像素强度中推断出来。重要的是要记住，算法对数据（特别是视觉数据，比如人们非常熟悉的图像）的解释通常与人类的解释方式有很大不同。</p><p>不过让我们回到PCA的具体案例。我们对PCA变换的介绍是：先旋转数据，然后删除方差较小的成分。另一种有用的解释是尝试找到一些数字（PCA旋转后的新特征值），使我们可以将测试点表示为主成分的加权求和。</p><p><img src="/uploads/image/introduction-to-ml-with-python/break-down-image-to-weighted-summation-of-pca.png"></p><p>这里<span class="math inline">\(x_0、x_1\)</span>等是这个数据点的主成分的系数，换句话说，它们是图像在旋转后的空间中的表示。</p><p>我们还可以用另一种方法来理解PCA模型。就是仅使用一些成分对原始数据进行重建。在<code>plot_pca_illustration</code>函数中，去掉第二个主成分，再反向旋转并加上平均值，这样就在原始空间中获得去掉第二个成分的新数据点。我们可以对人脸做类似的变换，将数据降维到只包含一些主成分，然后反向旋转回到原始空间。回到原始特征空间可以通过<code>inverse_transform(X)</code>方法来实现。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.decomposition.pca#sklearn.decomposition.PCA.inverse_transform" target="_blank" rel="noopener"><code>inverse_transform(X)</code></a></p><p>Transform data back to its original space.</p><p>In other words, return an input X_original whose transform would be X.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.rcParams[<span class="string">'image.cmap'</span>] = <span class="string">'gray'</span></span><br><span class="line"><span class="comment"># 分别利用10个、50个、100个和500个成分对一些人脸进行重建并将其可视化</span></span><br><span class="line">mglearn.plots.plot_pca_faces(X_train, X_test, image_shape)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/pca-faces.png"></p><p>可以看到，在仅使用前10个主成分时，仅捕捉到了图片的基本特点，比如人脸方向和明暗程度。随着使用的主成分越来越多，图像中也保留了越来越多的细节。这对应于前一幅图的求和中包含越来越多的项。如果使用的成分个数与像素个数相等，意味着我们在旋转后不会丢弃任何信息，可以完美重建图像。</p><p>我们还可以尝试使用PCA的前两个主成分，将数据集中的所有人脸在散点图中可视化，其类别在图中给出。这与我们对cancer数据集所做的类似。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.discrete_scatter(X_train_pca[:, <span class="number">0</span>], X_train_pca[:, <span class="number">1</span>], y_train)</span><br><span class="line">plt.xlabel(<span class="string">'First principal component'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Second principal component'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/pca-faces-scatter.png"></p><p>如你所见，如果我们只使用前两个主成分，整个数据只是一大团，看不到类别之间的分界。这并不意外，因为即使有10个成分，PCA也仅捕捉到人脸非常粗略的特征。</p><h1 id="非负矩阵分解">非负矩阵分解</h1><p>非负矩阵分解（non-negative matrix factorization，NMF）是另一种无监督学习算法，其目的在于提取有用的特征。它的工作原理类似PCA，也可以用于降维。与PCA相同，我们试图将每个数据点写成一些分量的加权求和。但在PCA中，我们想要的是正交分量，并且能够解释尽可能多的数据方差；而在NMF中，我们希望分量和系数均为非负。因此，这种方法只能应用于每个特征都是非负的数据，因为非负分量的非负求和不可能变为负值。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.decomposition.nmf" target="_blank" rel="noopener"><code>class sklearn.decomposition.NMF(n_components=None, init=None, solver=’cd’, beta_loss=’frobenius’, tol=0.0001, max_iter=200, random_state=None, alpha=0.0, l1_ratio=0.0, verbose=0, shuffle=False)</code></a></p><p>Non-Negative Matrix Factorization (NMF)</p></blockquote><p>将数据分解成非负加权求和的这个过程，对由多个独立源相加（或叠加）创建而成的数据特别有用，比如多人说话的音轨或包含多种乐器的音乐。在这种情况下，NMF可以识别出组合合成数据的原始分量。总的来说，与PCA相比，NMF得到的分量更容易理解，因为负的分量和系数可能会导致难以理解的抵消效应（cancellation effect）。</p><h2 id="将nmf应用于模拟数据">将NMF应用于模拟数据</h2><p>与使用PCA不同，我们需要保证数据是正的，NMF能够对数据进行操作。这说明数据相对于原点(0, 0)的位置实际上对NMF很重要。因此，你可以将提取出来的非负分量看作是从(0, 0)到数据的方向。下面的例子给出了NMF在二维玩具数据上的结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_nmf_illustration()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/nmf.png"></p><p>对于两个分量的NMF（左图），显然所有数据点都可以写成这两个分量的正数组合。如果有足够多的分量能够完美地重建数据（分量个数与特征个数相同），那么算法会选择指向数据极值的方向。</p><p>如果我们仅使用一个分量，那么NMF会创建一个指向平均值的分量，因为指向这里可以对数据做出最好的解释。<strong>与PCA不同，减少分量个数不仅会删除一些方向，而且会创建一组完全不同的分量！NMF的分量也没有按任何特定方法排序，所以不存在“第一非负分量”：所有分量的地位平等。</strong></p><p>NMF使用了随机初始化，根据随机种子的不同可能会产生不同的结果。在相对简单的情况下（比如两个分量的模拟数据），所有数据都可以被完美地解释，那么随机性的影响很小（虽然可能会影响分量的顺序或尺度）。在更加复杂的情况下，影响可能会很大。</p><h2 id="将nmf应用于人脸图像">将NMF应用于人脸图像</h2><p>NMF的主要参数是我们想要提取的分量个数。通常来说，这个数字要小于输入特征的个数（否则的话，将每个像素作为单独的分量就可以对数据进行解释）。</p><p>首先，我们来观察分量个数如何影响NMF重建数据的好坏。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_nmf_faces(X_train, X_test, image_shape)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/nmf-faces.png"></p><p><strong>反向变换的数据质量与使用PCA时类似，但要稍差一些。这是符合预期的，因为PCA找到的是重建的最佳方向。NMF通常并不用于对数据进行重建或者编码，而是用于在数据中寻找有趣的模式。</strong></p><p>我们尝试仅提取一部分分量，初步观察一下数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> NMF</span><br><span class="line"></span><br><span class="line">nmf = NMF(n_components=<span class="number">15</span>, random_state=<span class="number">0</span>)</span><br><span class="line">nmf.fit(X_train)</span><br><span class="line">X_train_nmf = nmf.transform(X_train)</span><br><span class="line">X_test_nmf = nmf.transform(X_test)</span><br><span class="line"></span><br><span class="line">fix, axes = plt.subplots(<span class="number">3</span>, <span class="number">5</span>, figsize=(<span class="number">15</span>, <span class="number">12</span>),</span><br><span class="line">    subplot_kw=&#123;<span class="string">'xticks'</span>: (), <span class="string">'yticks'</span>: ()&#125;)</span><br><span class="line"><span class="keyword">for</span> i, (component, ax) <span class="keyword">in</span> enumerate(zip(nmf.components_, axes.ravel())):</span><br><span class="line">    ax.imshow(component.reshape(image_shape))</span><br><span class="line">    ax.set_title(<span class="string">'&#123;&#125;. component'</span>.format(i))</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/nmf-components.png"></p><p>这些分量都是正的，因此比PCA分量更像人脸模型。例如，你可以看到，分量3显示了稍微向右转动的人脸，而分量7则显示了稍微向左转动的人脸。我们来看一下这两个分量特别大的那些图像。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> compn <span class="keyword">in</span> (<span class="number">3</span>, <span class="number">7</span>):</span><br><span class="line">    inds = np.argsort(X_train_nmf[:, compn])[::<span class="number">-1</span>]</span><br><span class="line">    fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">5</span>, figsize=(<span class="number">15</span>, <span class="number">8</span>),</span><br><span class="line">        subplot_kw=&#123;<span class="string">'xticks'</span>: (), <span class="string">'yticks'</span>: ()&#125;)</span><br><span class="line">    <span class="keyword">for</span> i, (ind, ax) <span class="keyword">in</span> enumerate(zip(inds, axes.ravel())):</span><br><span class="line">        ax.imshow(X_train[ind].reshape(image_shape))</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/nmf-components-argsort-3.png"></p><p><img src="/uploads/image/introduction-to-ml-with-python/nmf-components-argsort-7.png"></p><p>正如所料，分量3系数较大的人脸都是向右看的人脸，而分量7系数较大的人脸都向左看。<strong>提取这样的模式最适合于具有叠加结构的数据，包括音频、基因表达和文本数据。</strong></p><p>我们通过一个模拟数据的例子来看一下这种用法。加入我们对一个信号感兴趣，它是三个不同信号源合成的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = mglearn.datasets.make_signals()</span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">1</span>))</span><br><span class="line">plt.plot(S, <span class="string">'-'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Time'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Signal'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/datasets-signals.png"></p><p>不幸的是，我们无法观测到原始信号，只能观测到三个信号的叠加混合。我们想要将混合信号分解成原始分量。假设我们有许多种不同的方法来观测信号（比如有100台测量装置），每种方法都为我们提供了一些列观测结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将数据混合成100维的状态</span></span><br><span class="line">A = np.random.RandomState(<span class="number">0</span>).uniform(size=(<span class="number">100</span>, <span class="number">3</span>))</span><br><span class="line">X = np.dot(S, A.T)</span><br><span class="line">print(<span class="string">'Shape of measurements: &#123;&#125;'</span>.format(X.shape))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用NMF来还原这三个信号</span></span><br><span class="line">nmf = NMF(n_components=<span class="number">3</span>, random_state=<span class="number">42</span>)</span><br><span class="line">S_ = nmf.fit_transform(X)</span><br><span class="line">print(<span class="string">'Recovered signal shape: &#123;&#125;'</span>.format(S_.shape))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了对比，应用PCA</span></span><br><span class="line">pca = PCA(n_components=<span class="number">3</span>)</span><br><span class="line">H = pca.fit_transform(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给出NMF和PCA发现的信号活动</span></span><br><span class="line">models = [X, S, S_, H]</span><br><span class="line">names = [<span class="string">'Observations (first three measurements)'</span>, <span class="string">'True sources'</span>,</span><br><span class="line">    <span class="string">'NMF recovered signals'</span>, <span class="string">'PCA recovered signals'</span>]</span><br><span class="line">fig, axes = plt.subplots(<span class="number">4</span>, figsize=(<span class="number">8</span>, <span class="number">4</span>), gridspec_kw=&#123;<span class="string">'hspace'</span>: <span class="number">.5</span>&#125;,</span><br><span class="line">    subplot_kw=&#123;<span class="string">'xticks'</span>: (), <span class="string">'yticks'</span>: ()&#125;)</span><br><span class="line"><span class="keyword">for</span> model, name, ax <span class="keyword">in</span> zip(models, names, axes):</span><br><span class="line">    ax.set_title(name)</span><br><span class="line">    ax.plot(model[:, :<span class="number">3</span>], <span class="string">'-'</span>)  <span class="comment"># 绘制X时，仅包含100次中的前3次测量</span></span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/nmf-and-pca-on-signals.png"></p><p>可以看到，NMF在发现原始信号源时得到了不错的结果，而PCA则失败了，仅使用第一个成分来解释数据中的大部分变化。<strong>要记住，NMF生成的分量是没有顺序的。在这个例子中，NMF分量的顺序与原始信号完全相同（参见三条曲线的颜色），但这纯属偶然。</strong></p><p>还有许多其他算法可用于将每个数据点分解成一系列固定分量的加权求和，正如PCA和NMF所做的那样。如果你对这种类型的模式提取感兴趣，我们推荐你学习<code>scikit-learn</code>用户指南中关于独立成分分析（ICA）、因子分析（FA）和稀疏编码（字典学习）等的内容，所有这些内容都可以在关于分解方法的页面中找到（<a href="http://scikit-learn.org/stable/modules/decomposition.html" class="uri" target="_blank" rel="noopener">http://scikit-learn.org/stable/modules/decomposition.html</a>）。</p><h1 id="用t-sne进行流形学习">用t-SNE进行流形学习</h1><p>虽然PCA通常是用于变换数据的首选方法，使你能够用散点图将其可视化，但这一方法的性质（先旋转然后减少方向）限制了其有效性。有一类用于可视化的算法叫作<strong>流形学习算法</strong>（manifold learning algorithm），它允许进行更复杂的映射，通常也可以给出更好的可视化。其中特别有用的一个就是t-SNE（t-distributed Stochastic Neighbor Embedding）算法。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.manifold.tsne" target="_blank" rel="noopener"><code>class sklearn.manifold.TSNE(n_components=2, perplexity=30.0, early_exaggeration=12.0, learning_rate=200.0, n_iter=1000, n_iter_without_progress=300, min_grad_norm=1e-07, metric=’euclidean’, init=’random’, verbose=0, random_state=None, method=’barnes_hut’, angle=0.5)</code></a></p><p>t-distributed Stochastic Neighbor Embedding.</p></blockquote><p><strong>流形学习算法主要用于可视化，因此很少用来生成两个以上的新特征。其中一些算法（包括t-SNE）计算训练数据的一种新表示，但不允许变换新数据。这意味着这些算法不能用于测试集：更确切地说，它们只能变换用于训练的数据。</strong>流形学习对探索性数据分析是很有用的，但如果最终目标是监督学习的话，则很少使用。t-SNE背后的思想是找到数据的一个二维表示，尽可能地保持数据点之间的距离。t-SNE首先给出每个数据点的随机二维表示，然后尝试让在原始特征空间中距离较近的点更加靠近，原始特征空间中相距较远的点更加远离。t-SNE重点关注距离较近的点，而不是保持距离较远的点之间的距离。换句话说，它试图保存那些表示哪些点比较靠近的信息。</p><p>我们将对<code>scikit-learn</code>包含的一个手写数字数据集应用t-SNE流形学习算法。在这个数据集中，每个数据点都是0到9之间手写数字的一张8x8灰度图像。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_digits</span><br><span class="line"></span><br><span class="line">digits = load_digits()</span><br><span class="line">fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">5</span>, figsize=(<span class="number">10</span>, <span class="number">5</span>),</span><br><span class="line">    subplot_kw=&#123;<span class="string">'xticks'</span>: (), <span class="string">'yticks'</span>: ()&#125;)</span><br><span class="line"><span class="keyword">for</span> ax, img <span class="keyword">in</span> zip(axes.ravel(), digits.images):</span><br><span class="line">    ax.imshow(img)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/datasets-digits.png"></p><p>我们用PCA将降到二维的数据可视化。对前两个主成分作图，并按类别对数据点着色。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pca = PCA(n_components=<span class="number">2</span>)</span><br><span class="line">pca.fit(digits.data)</span><br><span class="line">digits_pca = pca.transform(digits.data)</span><br><span class="line">colors = [<span class="string">"#476A2A"</span>, <span class="string">"#7851B8"</span>, <span class="string">"#BD3430"</span>, <span class="string">"#4A2D4E"</span>, <span class="string">"#875525"</span>,</span><br><span class="line">          <span class="string">"#A83683"</span>, <span class="string">"#4E655E"</span>, <span class="string">"#853541"</span>, <span class="string">"#3A3120"</span>, <span class="string">"#535D8E"</span>]</span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">plt.xlim(digits_pca[:, <span class="number">0</span>].min(), digits_pca[:, <span class="number">0</span>].max())</span><br><span class="line">plt.ylim(digits_pca[:, <span class="number">1</span>].min(), digits_pca[:, <span class="number">1</span>].max())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(digits.data)):</span><br><span class="line">    <span class="comment"># 用每个类别对应的数字分别作为符号来显示每个类别的位置</span></span><br><span class="line">    plt.text(digits_pca[i, <span class="number">0</span>], digits_pca[i, <span class="number">1</span>], str(digits.target[i]),</span><br><span class="line">        color=colors[digits.target[i]], fontdict=&#123;<span class="string">'weight'</span>: <span class="string">'bold'</span>, <span class="string">'size'</span>: <span class="number">9</span>&#125;)</span><br><span class="line">plt.xlabel(<span class="string">'First principal component'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Second principal component'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/pca-digits.png"></p><p>利用前两个主成分可以将数字0、6和4相对较好地分开，尽管仍有重叠。大部分其他数字都大量重叠在一起。</p><p>我们将t-SNE应用于同一个数据集，并对结果进行比较。由于t-SNE不支持变换新数据，所以<code>TSNE</code>类没有transform方法。我们可以调用<code>fit_transform</code>方来来代替，它会构建模型并立即返回变换后的数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.manifold <span class="keyword">import</span> TSNE</span><br><span class="line"></span><br><span class="line">tsne = TSNE(random_state=<span class="number">42</span>)</span><br><span class="line">digits_tsne = tsne.fit_transform(digits.data)</span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">plt.xlim(digits_tsne[:, <span class="number">0</span>].min(), digits_tsne[:, <span class="number">0</span>].max() + <span class="number">1</span>)</span><br><span class="line">plt.ylim(digits_tsne[:, <span class="number">1</span>].min(), digits_tsne[:, <span class="number">1</span>].max() + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(digits.data)):</span><br><span class="line">    plt.text(digits_tsne[i, <span class="number">0</span>], digits_tsne[i, <span class="number">1</span>], str(digits.target[i]),</span><br><span class="line">        color=colors[digits.target[i]], fontdict=&#123;<span class="string">'weight'</span>: <span class="string">'bold'</span>, <span class="string">'size'</span>: <span class="number">9</span>&#125;)</span><br><span class="line">plt.xlabel(<span class="string">'t-SNE feature 0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'t-SNE feature 1'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/t-sne-digits.png"></p><p>t-SNE的结果非常棒。所有类别都被明确分开。数字1和9被分成几块，但大多数类别都形成以一个密集的组。<strong>要记住，这种方法并不知道类别标签：它完全是无监督的。但它能够找到数据的一种二维表示，仅根据原始空间中数据点之间的靠近程度就能够将各个类别明确分开。</strong></p><p>t-SNE算法还有一些调节参数，虽然默认参数的效果通常就很好。你可以尝试修改<code>perplexity</code>和<code>early_exaggeration</code>，但作用一般很小。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Machine Learning with Python </tag>
            
            <tag> unsupervised </tag>
            
            <tag> preprocessing </tag>
            
            <tag> PCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>预处理与缩放</title>
      <link href="/notes/introduction-to-ml-with-python/preprocess-and-scaling/"/>
      <url>/notes/introduction-to-ml-with-python/preprocess-and-scaling/</url>
      
        <content type="html"><![CDATA[<p>一些算法（如神经网络和SVM）对数据缩放非常敏感。因此，通常的做法是对特征进行调节，使数据表示更适合于这些算法。通常来说，这是对数据的一种简单的按特征的缩放和移动。下图给出了一个简单的例子。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_scaling()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/scaling.png"></p><a id="more"></a><h1 id="不同类型的预处理">不同类型的预处理</h1><p>上图中，左图显示的是一个模拟的有两个特征的二分类数据集。第一个特征（x轴）位于10到15之间。第二个特征（y轴）大约位于1到9之间。</p><p>接下来的4张图展示了4种数据变换方法，都生成了更加标准的范围。<code>scikit-learn</code>中的<code>StandardScaler</code>确保每个特征的平均值为0、方差为1，使所有特征都位于同一量级。但这种缩放不能保证特征任何特定的最大值和最小值。<code>RobustScaler</code>的工作原理与<code>StandardScaler</code>类似，确保每个特征的统计属性都位于统一范围。但<code>RobustScaler</code>使用的是中位数和四分位数，而不是平均值和方差。这样<code>RobustScaler</code>会忽略与其他点有很大不同的数据点（比如测量误差）。这些与众不同的数据点也叫<strong>异常值</strong>（outlier），可能会给其他缩放方法造成麻烦。</p><p>与之相反，<code>MinMaxScaler</code>移动数据，使所有特征都刚好位于0到1之间。对于二维数据集来说，所有的数据都包含在x轴0到1与y轴0到1组成的矩形中。</p><p>最后，<code>Normalizer</code>用到一种完全不同的缩放方法。它对每个数据点进行缩放，使得特征向量的欧式长度等于1。换句话说，它将每一个数据点投射到半径为1的圆上（对于更高维度的情况，是球面）。这意味着每个数据点的缩放比例都不相同（乘以其长度的倒数）。如果只有数据的方向（或角度）是重要的，而特征向量的长度无关紧要，那么通常会使用这种归一化。</p><h1 id="应用数据变换">应用数据变换</h1><p>通常在应用监督学习算法之前使用预处理方法（比如缩放）。举个例子，比如我们想要将核SVM应用在cancer数据集上，并使用MinMaxScaler来预处理数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_breast_cancer</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">cancer = load_breast_cancer()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">    cancer.data, cancer.target, random_state=<span class="number">1</span>)</span><br><span class="line">print(X_train.shape)</span><br><span class="line">print(X_test.shape)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(426, 30)</span><br><span class="line">(143, 30)</span><br></pre></td></tr></table></figure><p>与构建监督模型一样，首先导入实现预处理的类，然后将其实例化。然后，使用fit方法拟合缩放器（scaler），并将其应用于训练数据。对于<code>MinMaxScaler</code>来说，fit方法计算训练集中每个特征的最大值和最小值。与分类器和回归器不同，在对缩放器调用fit时只提供<code>X_train</code>，而不用<code>y_train</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"></span><br><span class="line">scaler = MinMaxScaler()</span><br><span class="line">scaler.fit(X_train)</span><br><span class="line"><span class="comment"># 变换数据</span></span><br><span class="line">X_train_scaled = scaler.transform(X_train)</span><br><span class="line"><span class="comment"># 在缩放之前和之后分别打印数据集属性</span></span><br><span class="line">print(<span class="string">"Transformed shape: &#123;&#125;"</span>.format(X_train_scaled.shape))</span><br><span class="line">print(<span class="string">'per-feature minimum before scaling:\n&#123;&#125;'</span>.format(X_train.min(axis=<span class="number">0</span>)))</span><br><span class="line">print(<span class="string">'per-feature maximum before scaling:\n&#123;&#125;'</span>.format(X_train.max(axis=<span class="number">0</span>)))</span><br><span class="line">print(<span class="string">'per-feature minimum after scaling:\n&#123;&#125;'</span>.format(X_train_scaled.min(axis=<span class="number">0</span>)))</span><br><span class="line">print(<span class="string">'per-feature maximum after scaling:\n&#123;&#125;'</span>.format(X_train_scaled.max(axis=<span class="number">0</span>)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Transformed shape: (426, 30)</span><br><span class="line">per-feature minimum before scaling:</span><br><span class="line">[6.981e+00 9.710e+00 4.379e+01 1.435e+02 5.263e-02 1.938e-02 0.000e+00</span><br><span class="line"> 0.000e+00 1.060e-01 5.024e-02 1.153e-01 3.602e-01 7.570e-01 6.802e+00</span><br><span class="line"> 1.713e-03 2.252e-03 0.000e+00 0.000e+00 9.539e-03 8.948e-04 7.930e+00</span><br><span class="line"> 1.202e+01 5.041e+01 1.852e+02 7.117e-02 2.729e-02 0.000e+00 0.000e+00</span><br><span class="line"> 1.566e-01 5.521e-02]</span><br><span class="line">per-feature maximum before scaling:</span><br><span class="line">[2.811e+01 3.928e+01 1.885e+02 2.501e+03 1.634e-01 2.867e-01 4.268e-01</span><br><span class="line"> 2.012e-01 3.040e-01 9.575e-02 2.873e+00 4.885e+00 2.198e+01 5.422e+02</span><br><span class="line"> 3.113e-02 1.354e-01 3.960e-01 5.279e-02 6.146e-02 2.984e-02 3.604e+01</span><br><span class="line"> 4.954e+01 2.512e+02 4.254e+03 2.226e-01 9.379e-01 1.170e+00 2.910e-01</span><br><span class="line"> 5.774e-01 1.486e-01]</span><br><span class="line">per-feature minimum after scaling:</span><br><span class="line">[0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.</span><br><span class="line"> 0. 0. 0. 0. 0. 0.]</span><br><span class="line">per-feature maximum after scaling:</span><br><span class="line">[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.</span><br><span class="line"> 1. 1. 1. 1. 1. 1.]</span><br></pre></td></tr></table></figure><p>变换后的数据形状与原始数据相同，特征只是发生了移动和缩放。为了将SVM应用到缩放后的数据上，还需要对测试集进行变换。这可以通过对<code>X_test</code>调用transform方法来完成。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对测试数据进行变换</span></span><br><span class="line">X_test_scaled = scaler.transform(X_test)</span><br><span class="line"><span class="comment"># 在缩放之后打印测试数据的属性</span></span><br><span class="line">print(<span class="string">'per-feature minimum after scaling:\n&#123;&#125;'</span>.format(X_test_scaled.min(axis=<span class="number">0</span>)))</span><br><span class="line">print(<span class="string">'per-feature maximum after scaling:\n&#123;&#125;'</span>.format(X_test_scaled.max(axis=<span class="number">0</span>)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">per-feature minimum after scaling:</span><br><span class="line">[ 0.0336031   0.0226581   0.03144219  0.01141039  0.14128374  0.04406704</span><br><span class="line">  0.          0.          0.1540404  -0.00615249 -0.00137796  0.00594501</span><br><span class="line">  0.00430665  0.00079567  0.03919502  0.0112206   0.          0.</span><br><span class="line"> -0.03191387  0.00664013  0.02660975  0.05810235  0.02031974  0.00943767</span><br><span class="line">  0.1094235   0.02637792  0.          0.         -0.00023764 -0.00182032]</span><br><span class="line">per-feature maximum after scaling:</span><br><span class="line">[0.9578778  0.81501522 0.95577362 0.89353128 0.81132075 1.21958701</span><br><span class="line"> 0.87956888 0.9333996  0.93232323 1.0371347  0.42669616 0.49765736</span><br><span class="line"> 0.44117231 0.28371044 0.48703131 0.73863671 0.76717172 0.62928585</span><br><span class="line"> 1.33685792 0.39057253 0.89612238 0.79317697 0.84859804 0.74488793</span><br><span class="line"> 0.9154725  1.13188961 1.07008547 0.92371134 1.20532319 1.63068851]</span><br></pre></td></tr></table></figure><p>你可以发现，对测试集缩放后的最大值和最小值不是1和0，这或许有些出乎意料。有些特征甚至在0～1之外！<strong>对此的解释是，<code>MinMaxScaler</code>（以及其他所有缩放器）总是对训练集和测试集应用完全相同的变换。也就是说，transform方法总是减去训练集的最小值，然后处理训练集范围，而这两个值可能与测试集的最小值和范围并不相同。</strong></p><h1 id="对训练数据和测试数据进行相同的缩放">对训练数据和测试数据进行相同的缩放</h1><p><strong>为了让监督模型能够在测试集上运行，对训练集和测试集应用完全相同的变换是很重要的。</strong>如果我们使用测试集的最小值和范围，下面这个例子展示了会发生什么。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造数据</span></span><br><span class="line">X, _ = make_blobs(n_samples=<span class="number">50</span>, centers=<span class="number">5</span>, random_state=<span class="number">4</span>, cluster_std=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 将其划分为训练集和测试集</span></span><br><span class="line">X_train, X_test = train_test_split(X, random_state=<span class="number">5</span>, test_size=<span class="number">.1</span>)</span><br><span class="line"><span class="comment"># 绘制训练集和测试集</span></span><br><span class="line">fig, axes = plt.subplots(<span class="number">1</span>, <span class="number">3</span>, figsize=(<span class="number">13</span>, <span class="number">4</span>))</span><br><span class="line">axes[<span class="number">0</span>].scatter(X_train[:, <span class="number">0</span>], X_train[:, <span class="number">1</span>],</span><br><span class="line">    c=mglearn.cm2(<span class="number">0</span>), label=<span class="string">'Training set'</span>, s=<span class="number">60</span>)</span><br><span class="line">axes[<span class="number">0</span>].scatter(X_test[:, <span class="number">0</span>], X_test[:, <span class="number">1</span>], marker=<span class="string">'^'</span>,</span><br><span class="line">    c=mglearn.cm2(<span class="number">1</span>), label=<span class="string">'Test set'</span>, s=<span class="number">60</span>)</span><br><span class="line">axes[<span class="number">0</span>].legend(loc=<span class="string">'upper left'</span>)</span><br><span class="line">axes[<span class="number">0</span>].set_title(<span class="string">'Original Data'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用MinMaxScaler缩放数据</span></span><br><span class="line">scaler = MinMaxScaler()</span><br><span class="line">scaler.fit(X_train)</span><br><span class="line">X_train_scaled = scaler.transform(X_train)</span><br><span class="line">X_test_scaled = scaler.transform(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将正确缩放的数据可视化</span></span><br><span class="line">axes[<span class="number">1</span>].scatter(X_train_scaled[:, <span class="number">0</span>], X_train_scaled[:, <span class="number">1</span>],</span><br><span class="line">    c=mglearn.cm2(<span class="number">0</span>), label=<span class="string">'Training set'</span>, s=<span class="number">60</span>)</span><br><span class="line">axes[<span class="number">1</span>].scatter(X_test_scaled[:, <span class="number">0</span>], X_test_scaled[:, <span class="number">1</span>], marker=<span class="string">'^'</span>,</span><br><span class="line">    c=mglearn.cm2(<span class="number">1</span>), label=<span class="string">'Test set'</span>, s=<span class="number">60</span>)</span><br><span class="line">axes[<span class="number">1</span>].set_title(<span class="string">'Scaled Data'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单独对测试集进行缩放</span></span><br><span class="line"><span class="comment"># 使得测试集的最小值为0，最大值为1</span></span><br><span class="line"><span class="comment"># 千万不要这么做！这里只是为了举例</span></span><br><span class="line">test_scaler = MinMaxScaler()</span><br><span class="line">test_scaler.fit(X_test)</span><br><span class="line">X_test_scaled_badly = test_scaler.transform(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将错误缩放的数据可视化</span></span><br><span class="line">axes[<span class="number">2</span>].scatter(X_train_scaled[:, <span class="number">0</span>], X_train_scaled[:, <span class="number">1</span>],</span><br><span class="line">    c=mglearn.cm2(<span class="number">0</span>), label=<span class="string">'Training set'</span>, s=<span class="number">60</span>)</span><br><span class="line">axes[<span class="number">2</span>].scatter(X_test_scaled_badly[:, <span class="number">0</span>], X_test_scaled_badly[:, <span class="number">1</span>],</span><br><span class="line">    marker=<span class="string">'^'</span>, c=mglearn.cm2(<span class="number">1</span>), label=<span class="string">'Test set'</span>, s=<span class="number">60</span>)</span><br><span class="line">axes[<span class="number">2</span>].set_title(<span class="string">'Improperly Scaled Data'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax <span class="keyword">in</span> axes:</span><br><span class="line">    ax.set_xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">'Feature 1'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/minmaxscaling-of-blobs.png"></p><p>你可以发现，第二张图中的数据集看起来与第一张图中的完全相同，只是坐标轴刻度发生了变化。现在所有特征都位于0到1之间。你还可以发现，测试数据的特征最大值和最小值并不是1和0。第三张图展示了如果我们对训练集和测试集分别进行缩放会发生什么。在这种情况下，对训练集和测试集而言，特征的最大值和最小值都是1和0。但现在数据集看起来不一样。测试集相对训练集的移动不一致，因为它们分别做了不同的缩放。我们随意改变了数据的排列。这显然不是我们想要做的事。</p><p>通常来所，你想要在某个数据集上fit一个模型，然后再将其transform。这是一个非常常见的任务。</p><ul><li><p>快捷方式：使用方法链。例如，<code>X_scaled = scaler.fit(X).transform(X)</code>。</p></li><li><p>高效的替代方法：使用<code>fit_transform</code>方法。例如，<code>X_scaled = scaler.fit_transform(X)</code>。</p></li></ul><p>所有具有<code>transform</code>方法的模型，也都具有一个<code>fit_transform</code>方法。虽然<code>fit_transform</code>不一定对所有模型都更加高效，但在尝试变换训练集时，使用这一方法仍然是很好的做法。</p><h1 id="预处理对监督学习的作用">预处理对监督学习的作用</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"></span><br><span class="line">cancer = load_breast_cancer()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">    cancer.data, cancer.target, random_state=<span class="number">1</span>)</span><br><span class="line">svm = SVC(C=<span class="number">100</span>)</span><br><span class="line">svm.fit(X_train, y_train)</span><br><span class="line">print(<span class="string">'Test set accuracy: &#123;:.2f&#125;'</span>.format(svm.score(X_test, y_test)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用0-1缩放进行预处理</span></span><br><span class="line">scaler = MinMaxScaler()</span><br><span class="line">scaler.fit(X_train)</span><br><span class="line">X_train_scaled = scaler.transform(X_train)</span><br><span class="line">X_test_scaled = scaler.transform(X_test)</span><br><span class="line"><span class="comment"># 在缩放后的训练数据上学习SVM</span></span><br><span class="line">svm.fit(X_train_scaled, y_train)</span><br><span class="line"><span class="comment"># 在缩放后的测试集上计算分数</span></span><br><span class="line">print(<span class="string">'Scaled test set accuracy: &#123;:.2f&#125;'</span>.format(</span><br><span class="line">    svm.score(X_test_scaled, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test set accuracy: 0.62</span><br><span class="line">Scaled test set accuracy: 0.97</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Machine Learning with Python </tag>
            
            <tag> unsupervised </tag>
            
            <tag> preprocessing </tag>
            
            <tag> scaling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无监督学习与预处理</title>
      <link href="/notes/introduction-to-ml-with-python/unsupervised-learning-and-preprocessing/"/>
      <url>/notes/introduction-to-ml-with-python/unsupervised-learning-and-preprocessing/</url>
      
        <content type="html"><![CDATA[<h1 id="无监督学习的类型">无监督学习的类型</h1><p>本章将研究两种类型的无监督学习：数据集变换与聚类。</p><p>数据集的<strong>无监督变换</strong>（unsupervised transformation）是创建数据新的表示的算法，与数据的原始表示相比，新的表示可能更容易被人或其他机器学习算法所理解。无监督变换的一个常见应用是<strong>降维</strong>（dimensionality reduction），它接受包含许多特征的数据的高维表示，并找到表示该数据的一种新方法，用较少的特征就可以概括其特性。降维的一个常见应用是为了可视化将数据降为二维。</p><p>无监督变换的另一个应用是找到“构成”数据的各个组成部分。这方面的一个例子就是对文本文档集合进行主题提取。这里的任务是找到每个文档中讨论的未知主题，并学习每个文档中出现了哪些主题。这可以用于追踪社交媒体上的话题讨论，比如选举、枪支管制或流行歌手等话题。</p><p>与之相反，<strong>聚类算法</strong>（clustering algorithm）将数据划分成不同的组，每组包含相似的物项。思考向社交媒体网站上传照片的例子。为了方便你整理照片，网站可能想要将同一个人的照片分在一组。但网站并不知道每张照片是谁，也不知道你的照片集中出现了多少个人。明智的做法是提取所有的人脸，并将看起来相似的人脸分在一组。但愿这些人脸对应同一个人，这样照片的分组也就完成了。</p><a id="more"></a><h1 id="无监督学习的挑战">无监督学习的挑战</h1><p>无监督学习的一个主要挑战就是评估算法是否学到了有用的东西。无监督学习算法一般用于不包含任何标签信息的数据，所以我们不知道正确的输出应该是什么。因此很难判断一个模型是否“表现很好”。例如，假设我们的聚类算法已经将所有的侧脸照片和所有的正面照片进行分组。这肯定是人脸照片集合的一种可能的划分方法，但并不是我们想要的那种方法。然而，我们没有办法“告诉”算法我们要的是什么，通常来说，评估无监督算法结果的唯一方法就是人工检查。</p><p>因此，如果数据科学家想要更好地理解数据，那么无监督算法通常可用于探索的目的，而不是作为大型自动化系统的一部分。无监督算法的另一个常见应用是作为监督算法的预处理步骤。学习数据的一种新的表示，有时可以提高监督算法的精度，或者可以减少内存占用和时间开销。</p><p>在开始学习“真正的”无监督算法之前，我们先简要讨论几种简单又常用的预处理方法。虽然预处理和缩放通常与监督学习算法一起使用，但缩放方法并没有用到与“监督”有关的信息，所以它是无监督的。</p><h1 id="预处理与缩放">预处理与缩放</h1><a href="/notes/introduction-to-ml-with-python/preprocess-and-scaling/" title="前往文章">前往文章</a><h1 id="降维特征提取与流形学习">降维、特征提取与流形学习</h1><a href="/notes/introduction-to-ml-with-python/dimensionality-reduction-feature-extraction-and-manifold-learning/" title="前往文章">前往文章</a><h1 id="聚类">聚类</h1><a href="/notes/introduction-to-ml-with-python/clustering/" title="前往文章">前往文章</a><h1 id="小结">小结</h1><p>本章介绍了一系列无监督学习算法，可用于探索性数据分析和预处理。找到数据的正确表示对于监督学习和无监督学习的成功通常都至关重要，预处理和分解方法在数据准备中具有重要作用。</p><p>分解、流形学习和聚类都是加深数据理解的重要工具，在没有监督信息的情况下，也是理解数据的仅有方法。即使在监督学习中，探索性工具对于更好地理解数据性质也很重要。通常来说，很难量化无监督算法的有用性，但这不应该妨碍你使用它们来深入理解数据。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Machine Learning with Python </tag>
            
            <tag> unsupervised </tag>
            
            <tag> preprocessing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络（深度学习）</title>
      <link href="/notes/introduction-to-ml-with-python/neural-networks-deep-learning/"/>
      <url>/notes/introduction-to-ml-with-python/neural-networks-deep-learning/</url>
      
        <content type="html"><![CDATA[<p>一类被称为神经网络的算法最近以“深度学习“的名字再度流行。虽然深度学习在许多机器学习应用中都有巨大的潜力，但深度学习算法往往经过精确调整，只适用于特定的使用场景。这里只讨论一些相对简单的方法，即用于分类和回归的<strong>多层感知机</strong>（multilayer perceptron，MLP），它可以作为研究更复杂的深度学习方法的起点。MLP也被称为（普通）前馈神经网络，有时也简称为神经网络。</p><h1 id="神经网络模型">神经网络模型</h1><p>MLP可以被视为广义的线性模型，执行多层处理后得到结论。</p><p>线性回归的预测公式为：</p><p><span class="math display">\[\hat y=w[0]*x[0]+w[1]*x[1]+\dots+w[p]*x[p]+b\]</span></p><p>简单来说，<span class="math inline">\(\hat y\)</span>是输入特征<span class="math inline">\(x[0]\)</span>到<span class="math inline">\(x[p]\)</span>的加权求和，权重为学到的系数<span class="math inline">\(w[0]\)</span>到<span class="math inline">\(w[p]\)</span>。我们可以将这个公式可视化。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = mglearn.plots.plot_logistic_regression_graph()</span><br><span class="line">g.render(filename=<span class="string">'visualization-of-logistic-regression'</span>,</span><br><span class="line">    view=<span class="literal">True</span>, format=<span class="string">'svg'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/visualization-of-logistic-regression.svg"></p><a id="more"></a><p>图中，左边的每个结点代表一个输入特征，连线代表学到的系数，右边的结点代表输出，是输入的加权求和。</p><p>在MLP中，多次重复这个计算加权求和的过程，首先计算代表中间过程的<strong>隐单元</strong>（hidden unit），然后再计算这些隐单元的加权求和并得到最终结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = mglearn.plots.plot_single_hidden_layer_graph()</span><br><span class="line">g.render(filename=<span class="string">'single-hidden-layer-mlp'</span>, format=<span class="string">'svg'</span>, view=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/visualization-of-single-hidden-layer-mlp.svg"></p><p>这个模型需要学习更多的系数（也叫作权重）：在每个输入与每个隐单元（隐单元组成了<strong>隐层</strong>）之间有一个系数，在每个隐单元与输出之间也有一个系数。</p><p>从数学的角度看，计算一系列加权求和与只计算一个加权求和是完全相同的，因此，为了让这个模型真正比线性模型更为强大，我们还需要一个技巧。在计算完每个隐单元的加权求和之后，对结果再应用一个非线性函数——通常是<strong>校正非线性</strong>（rectifying nonlinearity，也叫校正线性单元或relu）或<strong>正切双曲线</strong>（tangens hyperbolicus，tanh）。然后将这个函数的结果用于加权求和，计算得到输出<span class="math inline">\(\hat y\)</span>。这两个函数的可视化效果如图。relu截断小于0的值，而tanh在输出值较小时接近-1，在输出值较大时接近+1。有了这两种非线性函数，神经网络可以学习比线性模型复杂得多的函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">line = np.linspace(<span class="number">-3</span>, <span class="number">3</span>, <span class="number">100</span>)</span><br><span class="line">plt.plot(line, np.tanh(line), label=<span class="string">'tanh'</span>)</span><br><span class="line">plt.plot(line, np.maximum(line, <span class="number">0</span>), label=<span class="string">'relu'</span>)</span><br><span class="line">plt.legend(loc=<span class="string">'best'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'x'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'relu(x), tanh(x)'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/visualization-of-relu-and-tanh.png"></p><p>例如对上述的单隐层感知机，计算回归问题的<span class="math inline">\(\hat y\)</span>的完整公式如下：</p><p><span class="math display">\[\begin{aligned}h[0] &amp;= tanh(w[0, 0]*x[0]+w[1, 0]*x[1]+w[2, 0]*x[2]+w[3, 0]*x[3]+b[0])\\h[1] &amp;= tanh(w[0, 1]*x[0]+w[1, 1]*x[1]+w[2, 1]*x[2]+w[3, 1]*x[3]+b[1])\\h[2] &amp;= tanh(w[0, 2]*x[0]+w[1, 2]*x[1]+w[2, 2]*x[2]+w[3, 2]*x[3]+b[2])\\\hat y &amp;= v[0]*h[0]+v[1]*h[1]+v[2]*h[2]+b\end{aligned}\]</span></p><p>其中，<span class="math inline">\(w\)</span>是输入<span class="math inline">\(x\)</span>与隐层<span class="math inline">\(h\)</span>之间的权重，<span class="math inline">\(v\)</span>是隐层<span class="math inline">\(h\)</span>与输出<span class="math inline">\(\hat y\)</span>之间的权重。权重<span class="math inline">\(w\)</span>和<span class="math inline">\(v\)</span>要从数据中学习得到，<span class="math inline">\(x\)</span>是输入特征，<span class="math inline">\(\hat y\)</span>是计算得到的输出，<span class="math inline">\(h\)</span>是计算的中间结果。需要用户设置的一个重要参数是隐层中的结点个数。对于非常小或非常简单的数据集，这个值可以小到10；对于非常复杂的数据，这个值可以大到10000.也可以添加多个隐层。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = mglearn.plots.plot_two_hidden_layer_graph()</span><br><span class="line">g.render(filename=<span class="string">'visualization-of-two-hidden-layer-mlp'</span>,</span><br><span class="line">    view=<span class="literal">True</span>, format=<span class="string">'svg'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/visualization-of-two-hidden-layer-mlp.svg"></p><p>这些由许多计算层组成的大型神经网络，正是术语“深度学习”的灵感来源。</p><h1 id="神经网络调参">神经网络调参</h1><p>我们将MLPClassifier应用到two_moons数据集上，以此研究MLP的工作原理。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.neural_network.mlpclassifier" target="_blank" rel="noopener"><code>class sklearn.neural_network.MLPClassifier(hidden_layer_sizes=(100, ), activation=’relu’, solver=’adam’, alpha=0.0001, batch_size=’auto’, learning_rate=’constant’, learning_rate_init=0.001, power_t=0.5, max_iter=200, shuffle=True, random_state=None, tol=0.0001, verbose=False, warm_start=False, momentum=0.9, nesterovs_momentum=True, early_stopping=False, validation_fraction=0.1, beta_1=0.9, beta_2=0.999, epsilon=1e-08, n_iter_no_change=10)</code></a></p><p>Multi-layer Perceptron classifier.</p><p>This model optimizes the log-loss function using LBFGS or stochastic gradient descent.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X, y = make_moons(n_samples=<span class="number">100</span>, noise=<span class="number">0.25</span>, random_state=<span class="number">3</span>)</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">    X, y, stratify=y, random_state=<span class="number">42</span>)</span><br><span class="line">mlp = MLPClassifier(solver=<span class="string">'lbfgs'</span>, random_state=<span class="number">0</span>).fit(X_train, y_train)</span><br><span class="line">mglearn.plots.plot_2d_separator(mlp, X_train, fill=<span class="literal">True</span>, alpha=<span class="number">.3</span>)</span><br><span class="line">mglearn.discrete_scatter(X_train[:, <span class="number">0</span>], X_train[:, <span class="number">1</span>], y_train)</span><br><span class="line">plt.xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature 1'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-of-100-hidden-nodes-mlp.png"></p><p>如你所见，神经网络学到的决策边界完全是非线性的，但相对平滑。</p><p>默认情况下，MLP使用100个隐结点，这对于这个小型数据集来说已经相当多了。我们可以减少其数量（从而降低了模型复杂度），但仍然得到很好的结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mlp = MLPClassifier(solver=<span class="string">'lbfgs'</span>, random_state=<span class="number">0</span>, hidden_layer_sizes=[<span class="number">10</span>])</span><br><span class="line">mlp.fit(X_train, y_train)</span><br><span class="line">mglearn.plots.plot_2d_separator(mlp, X_train, fill=<span class="literal">True</span>, alpha=<span class="number">.3</span>)</span><br><span class="line">mglearn.discrete_scatter(X_train[:, <span class="number">0</span>], X_train[:, <span class="number">1</span>], y_train)</span><br><span class="line">plt.xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature 1'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-of-10-hidden-nodes-mlp.png"></p><p>只有10个隐单元时，决策边界看起来更加参差不齐。默认的非线性是relu。如果使用单隐层，那么决策函数将由10个直线段组成。如果想得到更加平滑的决策边界，可以添加更多的隐单元、添加第二个隐层或者使用tanh非线性。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用2个隐层，每个包含10个单元</span></span><br><span class="line">mlp = MLPClassifier(solver=<span class="string">'lbfgs'</span>, random_state=<span class="number">0</span>, hidden_layer_sizes=[<span class="number">10</span>, <span class="number">10</span>])</span><br><span class="line">mlp.fit(X_train, y_train)</span><br><span class="line">mglearn.plots.plot_2d_separator(mlp, X_train, fill=<span class="literal">True</span>, alpha=<span class="number">.3</span>)</span><br><span class="line">mglearn.discrete_scatter(X_train[:, <span class="number">0</span>], X_train[:, <span class="number">1</span>], y_train)</span><br><span class="line">plt.xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature 1'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-of-10-10-hidden-nodes-mlp.png"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用2个隐层，每个包含10个单元，这次使用tanh非线性</span></span><br><span class="line">mlp = MLPClassifier(solver=<span class="string">'lbfgs'</span>, activation=<span class="string">'tanh'</span>,</span><br><span class="line">    random_state=<span class="number">0</span>, hidden_layer_sizes=[<span class="number">10</span>, <span class="number">10</span>])</span><br><span class="line">mlp.fit(X_train, y_train)</span><br><span class="line">mglearn.plots.plot_2d_separator(mlp, X_train, fill=<span class="literal">True</span>, alpha=<span class="number">.3</span>)</span><br><span class="line">mglearn.discrete_scatter(X_train[:, <span class="number">0</span>], X_train[:, <span class="number">1</span>], y_train)</span><br><span class="line">plt.xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature 1'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-of-10-10-hidden-nodes-mlp-tanh.png"></p><p>最后，我们还可以利用L2惩罚使权重趋向于0，从而控制神经网络的复杂度，正如我们在岭回归和线性分类器中所做的那样。MLPClassifier中调节L2惩罚的参数是alpha（与线性回归模型中的相同），它的默认值很小（弱正则化）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">4</span>, figsize=(<span class="number">20</span>, <span class="number">8</span>))</span><br><span class="line"><span class="keyword">for</span> axx, n_hidden_nodes <span class="keyword">in</span> zip(axes, [<span class="number">10</span>, <span class="number">100</span>]):</span><br><span class="line">    <span class="keyword">for</span> ax, alpha <span class="keyword">in</span> zip(axx, [<span class="number">0.0001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>]):</span><br><span class="line">        mlp = MLPClassifier(solver=<span class="string">'lbfgs'</span>, random_state=<span class="number">0</span>, alpha=alpha,</span><br><span class="line">            hidden_layer_sizes=[n_hidden_nodes, n_hidden_nodes])</span><br><span class="line">        mlp.fit(X_train, y_train)</span><br><span class="line">        mglearn.plots.plot_2d_separator(mlp, X_train, fill=<span class="literal">True</span>, alpha=<span class="number">.3</span>, ax=ax)</span><br><span class="line">        mglearn.discrete_scatter(X_train[:, <span class="number">0</span>], X_train[:, <span class="number">1</span>], y_train, ax=ax)</span><br><span class="line">        ax.set_title(<span class="string">'n_hidden=[&#123;&#125;, &#123;&#125;]\nalpha=&#123;:.4f&#125;'</span>.format(</span><br><span class="line">            n_hidden_nodes, n_hidden_nodes, alpha))</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-of-mlp-for-different-parameters.png"></p><p>现在你可能已经认识到了，控制神经网络复杂度的方法有很多种：隐层的个数、每个隐层中的单元个数和正则化（alpha）。实际上还有更多，但这里不再过多介绍。</p><p><strong>神经网络的一个重要性质是，在开始学习之前其权重是随机设置的，这种随机初始化会影响学到的模型。</strong>也就是说，即使使用完全相同的参数，如果随机种子不同的话，我们也可能得到非常不一样的模型。<strong>如果网络很大，并且复杂度选择合理的话，那么这应该不会对精度有太大影响，但应该记住这一点（特别是对于较小的网络）</strong>。下图显示了几个模型的图像，所有模型都使用相同的参数设置（随机种子不同）进行学习。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">4</span>, figsize=(<span class="number">20</span>, <span class="number">8</span>))</span><br><span class="line"><span class="keyword">for</span> i, ax <span class="keyword">in</span> enumerate(axes.ravel()):</span><br><span class="line">    mlp = MLPClassifier(solver=<span class="string">'lbfgs'</span>, random_state=i,</span><br><span class="line">        hidden_layer_sizes=[<span class="number">100</span>, <span class="number">100</span>])</span><br><span class="line">    mlp.fit(X_train, y_train)</span><br><span class="line">    mglearn.plots.plot_2d_separator(mlp, X_train, fill=<span class="literal">True</span>, alpha=<span class="number">.3</span>, ax=ax)</span><br><span class="line">    mglearn.discrete_scatter(X_train[:, <span class="number">0</span>], X_train[:, <span class="number">1</span>], y_train, ax=ax)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-of-mlp-for-different-random-states.png"></p><h1 id="将神经网络应用于现实数据">将神经网络应用于现实数据</h1><p>为了在现实世界的数据上进一步理解神经网络，我们将MLPClassifier应用在乳腺癌数据集上，首先使用默认参数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'Cancer data per-feature maxima:\n&#123;&#125;'</span>.format(cancer.data.max(axis=<span class="number">0</span>)))</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">    cancer.data, cancer.target, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">mlp = MLPClassifier(random_state=<span class="number">42</span>)</span><br><span class="line">mlp.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Accuracy on training set: &#123;:.2f&#125;'</span>.format(mlp.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Accuracy on test set: &#123;:.2f&#125;'</span>.format(mlp.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cancer data per-feature maxima:</span><br><span class="line">[2.811e+01 3.928e+01 1.885e+02 2.501e+03 1.634e-01 3.454e-01 4.268e-01</span><br><span class="line"> 2.012e-01 3.040e-01 9.744e-02 2.873e+00 4.885e+00 2.198e+01 5.422e+02</span><br><span class="line"> 3.113e-02 1.354e-01 3.960e-01 5.279e-02 7.895e-02 2.984e-02 3.604e+01</span><br><span class="line"> 4.954e+01 2.512e+02 4.254e+03 2.226e-01 1.058e+00 1.252e+00 2.910e-01</span><br><span class="line"> 6.638e-01 2.075e-01]</span><br><span class="line">Accuracy on training set: 0.94</span><br><span class="line">Accuracy on test set: 0.92</span><br></pre></td></tr></table></figure><p>MLP的精度相当好，但没有其他模型好。与较早的SVC例子相同，原因可能在于数据的缩放。<strong>神经网络也要求所有输入特征的变化范围相似，最理想的情况均值为0、方差为1。</strong>我们必须对数据进行缩放以满足这些要求。这里将人工完成。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算训练集中每个特征的平均值</span></span><br><span class="line">mean_on_train = X_train.mean(axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 计算训练集中每个特征的标准差</span></span><br><span class="line">std_on_train = X_train.std(axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 减去平均值，然后乘以标准差的倒数</span></span><br><span class="line"><span class="comment"># 如此运算之后，mean=0，std=1</span></span><br><span class="line">X_train_scaled = (X_train - mean_on_train) / std_on_train</span><br><span class="line"><span class="comment"># 对测试集做相同的变换</span></span><br><span class="line">X_test_scaled = (X_test - mean_on_train) / std_on_train</span><br><span class="line"></span><br><span class="line">mlp = MLPClassifier(random_state=<span class="number">42</span>)</span><br><span class="line">mlp.fit(X_train_scaled, y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Accuracy on training set: &#123;:.2f&#125;'</span>.format(mlp.score(X_train_scaled, y_train)))</span><br><span class="line">print(<span class="string">'Accuracy on test set: &#123;:.2f&#125;'</span>.format(mlp.score(X_test_scaled, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ConvergenceWarning: Stochastic Optimizer: Maximum iterations (200) reached and the optimization hasn&apos;t converged yet.</span><br><span class="line">  % self.max_iter, ConvergenceWarning)</span><br><span class="line">Accuracy on training set: 0.99</span><br><span class="line">Accuracy on test set: 0.97</span><br></pre></td></tr></table></figure><p>缩放后的结果要好得多，而且也相当有竞争力。不过模型给出了一个警告，告诉我们已经达到了最大迭代次数，但还没有收束。这是用于学习模型的adam算法的一部分，告诉我们应该增加迭代次数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mlp = MLPClassifier(max_iter=<span class="number">1000</span>, random_state=<span class="number">42</span>)</span><br><span class="line">mlp.fit(X_train_scaled, y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Accuracy on training set: &#123;:.2f&#125;'</span>.format(mlp.score(X_train_scaled, y_train)))</span><br><span class="line">print(<span class="string">'Accuracy on test set: &#123;:.2f&#125;'</span>.format(mlp.score(X_test_scaled, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accuracy on training set: 1.00</span><br><span class="line">Accuracy on test set: 0.97</span><br></pre></td></tr></table></figure><p>增加迭代次数仅提高了训练集性能，但没有提高泛化性能。不过模型的表现相当不错。由于训练性能和测试性能之间仍有一些差距，所以我们可以尝试降低模型复杂度来得到更好的泛化性能。这里我们选择增大alpha参数（从默认的0.0001增大到1），以此向权重添加更强的正则化。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mlp = MLPClassifier(max_iter=<span class="number">1000</span>, alpha=<span class="number">1</span>, random_state=<span class="number">42</span>)</span><br><span class="line">mlp.fit(X_train_scaled, y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Accuracy on training set: &#123;:.2f&#125;'</span>.format(mlp.score(X_train_scaled, y_train)))</span><br><span class="line">print(<span class="string">'Accuracy on test set: &#123;:.2f&#125;'</span>.format(mlp.score(X_test_scaled, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accuracy on training set: 0.99</span><br><span class="line">Accuracy on test set: 0.98</span><br></pre></td></tr></table></figure><p>虽然可以分析神经网络学到了什么，但这通常比分析线性模型或基于树的模型更为复杂。要想观察模型学到了什么，一种方法是查看模型的权重。你可以在<code>scikit-learn</code>示例库中查看这样的一个<a href="https://scikit-learn.org/stable/auto_examples/neural_networks/plot_mnist_filters.html" target="_blank" rel="noopener">示例</a>。对于乳腺癌数据集，这可能有点难以理解。下面这张图显示了连接输入和第一个隐层之间的权重。图中的行对应30个输入特征，列对应100个隐单元。浅色代表较大的正值，而深色代表负值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">20</span>, <span class="number">5</span>))</span><br><span class="line">plt.imshow(mlp.coefs_[<span class="number">0</span>], interpolation=<span class="string">'none'</span>, cmap=<span class="string">'viridis'</span>)</span><br><span class="line">plt.yticks(range(<span class="number">30</span>), cancer.feature_names)</span><br><span class="line">plt.xlabel(<span class="string">'Columns in weight matrix'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Input feature'</span>)</span><br><span class="line">plt.colorbar()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/weights-of-first-hidden-layer-in-mlp.png"></p><p>我们可以推断，如果某个特征对所有隐单元的权重都很小，那么这个特征对模型来说就“不太重要”。与其他特征相比，“mean smoothness” “mean compactness”以及“smoothness error”和“fractal dimension error”之间的特征的权重都相对较小。这可能说明这些特征不太重要，也可能是我们没有用神经网络可以使用的方式来表示这些特征。</p><p>我们还可以将连接隐层和输出层的权重可视化，但它们更加难以理解。</p><p>虽然MLPClassifier和MLPRegressor为最常见的神经网络结构提供了易于使用的接口，但它们只包含神经网络潜在应用的一部分。对于Python用户来说，最为完善的是<code>keras</code>、<code>lasagna</code>和<code>tensor-flow</code>。<code>lasagna</code>是基于<code>theano</code>库构建的，而<code>keras</code>既可以用<code>tensor-flow</code>也可以用<code>theano</code>。这些库提供了更为灵活的接口，可以用来构建神经网络并跟踪深度学习研究的快速发展。所有流行的深度学习库也都允许使用高性能的图形处理单元（GPU），而<code>scikit-learn</code>不支持GPU。使用GPU可以将计算速度加快10到100倍，GPU对于将深度学习方法应用到大型数据集上至关重要。</p><h1 id="优点缺点和参数">优点、缺点和参数</h1><p>在机器学习的许多应用中，神经网络再次成为最先进的模型。它的主要优点之一是能够获取大量数据中包含的信息，并构建无比复杂的模型。给定足够的计算时间和数据，并且仔细调节参数，神经网络通常可以打败其他机器学习算法（无论是分类任务还是回归任务）。</p><p>神经网络——特别是功能强大的大型神经网络——通常需要很长的训练时间。它还需要仔细地预处理数据。与SVM类似，神经网络在“均匀”数据上的性能最好，其中“均匀”是指所有特征都具有相似的含义。如果数据包含不同种类的特征，那么基于树的模型可能表现得更好。神经网络调参本身也是一门艺术。调节神经网络模型和训练模型的方法有很多种，我们只是蜻蜓点水地尝试了几种而已。</p><h1 id="估计神经网络的复杂度">估计神经网络的复杂度</h1><p>最重要的参数是层数和每层的隐单元个数。你应该首先设置1个或2个隐层，然后可以逐步增加。每个隐层的结点个数通常与输入特征个数相近，但在几千个结点时很少会多于特征个数。</p><p>在考虑神经网络的模型复杂度时，一个有用的度量是学到的权重（或系数）的个数。如果你有一个包含100个特征的二分类数据集，模型有100个隐单元，那么输入层和第一个隐层之间就有<code>100*100=10000</code>个权重。在隐层和输出层之间还有<code>100*1=100</code>个权重，总共约10100个权重。</p><p><strong>神经网络调参的常用方法是，首先创建一个大到足以过拟合的网络，确保这个网络可以对任务进行学习。知道训练数据可以被学习之后，要么缩小网络，要么增大alpha来增强正则化，这可以提高泛化性能。</strong></p><p>在我们的实验中，主要关注模型的定义：层数、每层的结点个数、正则化和非线性。这些内容定义了我们想要学习的模型。还有一个问题是，<strong>如何</strong>学习模型或用来学习参数的算法，这一点由solver参数设定。solver参数有两个好用的选项。默认选项是'adam'，在大多数情况下效果都很好，但对数据的缩放相当敏感（因此，始终将数据缩放为均值为0、方差为1是很重要的）。另一个选项是'lbfgs'，其鲁棒性相当好，但在大型模型或大型数据集上的时间会比较长。还有更高级的'sgd'选项，许多深度学习研究人员都会用到。'sgd'选项还有许多其他参数需要调节，以便获得最佳结果。当你开始使用MLP时，我们建议使用'adam'和'lbfgs'。</p><p><em>fit会重置模型。<code>scikit-learn</code>模型的一个重要性质就是，调用fit总会重置模型之前学到的所有内容。你可以对一个模型多次调用fit，其结果与在“新“模型上调用fit是完全相同的。</em></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Machine Learning with Python </tag>
            
            <tag> classification </tag>
            
            <tag> neural network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>核支持向量机</title>
      <link href="/notes/introduction-to-ml-with-python/kernelized-support-vector-machine/"/>
      <url>/notes/introduction-to-ml-with-python/kernelized-support-vector-machine/</url>
      
        <content type="html"><![CDATA[<p>核支持向量机（通常简称为SVM）是可以推广到更复杂模型的扩展，这些模型无法被输入空间的超平面定义。虽然支持向量机可以同时用于分类和回归，但我们只会介绍用于分类的情况，它在SVC中实现。类似的概念也适用于支持向量回归，在SVR中实现。</p><h1 id="线性模型与非线性特征">线性模型与非线性特征</h1><p>线性模型在低维空间中可能非常受限，因为线和平面的灵活性有限。有一种方法可以让线性模型更加灵活，就是添加更多的特征——举个例子，添加输入特征的交互项或多项式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X, y = make_blobs(centers=<span class="number">4</span>, random_state=<span class="number">8</span>)</span><br><span class="line">y %= <span class="number">2</span></span><br><span class="line"></span><br><span class="line">mglearn.discrete_scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], y)</span><br><span class="line">plt.xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature 1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> LinearSVC</span><br><span class="line">linear_svm = LinearSVC().fit(X, y)</span><br><span class="line"></span><br><span class="line">mglearn.plots.plot_2d_separator(linear_svm, X)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/linear-svc-on-make-blobs.png"></p><a id="more"></a><p>用于分类的线性模型只能用一条直线来划分数据点，对这个数据集无法给出较好的结果。</p><p>现在我们对输入特征进行扩展，比如说添加第二个特征的平方（<code>feature1 ** 2</code>）作为一个新特征。现在我们将每个数据点表示为三维点<code>(feature0, feature1, feature1 ** 2)</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加第二个特征的平方，作为一个新特征</span></span><br><span class="line">X_new = np.hstack([X, X[:, <span class="number">1</span>:] ** <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D, axes3d</span><br><span class="line">figure = plt.figure()</span><br><span class="line"><span class="comment"># 3D可视化</span></span><br><span class="line">ax = Axes3D(figure, elev=<span class="number">-152</span>, azim=<span class="number">-26</span>)</span><br><span class="line"><span class="comment"># 首先画出所有y == 0的点，然后画出所有y == 1的点</span></span><br><span class="line">mask = y == <span class="number">0</span></span><br><span class="line">ax.scatter(X_new[mask, <span class="number">0</span>], X_new[mask, <span class="number">1</span>], X_new[mask, <span class="number">2</span>], c=<span class="string">'b'</span>,</span><br><span class="line">           cmap=mglearn.cm2, s=<span class="number">60</span>, edgecolor=<span class="string">'k'</span>)</span><br><span class="line">ax.scatter(X_new[~mask, <span class="number">0</span>], X_new[~mask, <span class="number">1</span>], X_new[~mask, <span class="number">2</span>], c=<span class="string">'r'</span>, marker=<span class="string">'^'</span>,</span><br><span class="line">           cmap=mglearn.cm2, s=<span class="number">60</span>, edgecolor=<span class="string">'k'</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">"feature0"</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">"feature1"</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">"feature1 ** 2"</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/datasets-blobs-3d.png"></p><p>在数据的新表示中，现在可以用线性模型（三维空间中的平面）将这两个类别分开。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">linear_svm_3d = LinearSVC().fit(X_new, y)</span><br><span class="line"><span class="comment"># ravel方法将数组展开</span></span><br><span class="line">coef, intercept = linear_svm_3d.coef_.ravel(), linear_svm_3d.intercept_</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示线性决策边界</span></span><br><span class="line">figure = plt.figure()</span><br><span class="line">ax = Axes3D(figure, elev=<span class="number">-152</span>, azim=<span class="number">-26</span>)</span><br><span class="line">xx = np.linspace(X_new[:, <span class="number">0</span>].min() - <span class="number">2</span>, X_new[:, <span class="number">0</span>].max() + <span class="number">2</span>, <span class="number">50</span>)</span><br><span class="line">yy = np.linspace(X_new[:, <span class="number">1</span>].min() - <span class="number">2</span>, X_new[:, <span class="number">1</span>].max() + <span class="number">2</span>, <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">XX, YY = np.meshgrid(xx, yy)</span><br><span class="line"><span class="comment"># model: y = x[0] * coef[0] + x[1] * coef[1] + x[2] * coef[3] + intercept</span></span><br><span class="line"><span class="comment"># boundary: 0 = x[0] * coef[0] + x[1] * coef[1] + x[2] * coef[3] + intercept</span></span><br><span class="line"><span class="comment"># 边界上的x[2] = (x[0] * coef[0] + x[1] * coef[1] + intercept) / -coef[2]</span></span><br><span class="line">ZZ = (coef[<span class="number">0</span>] * XX + coef[<span class="number">1</span>] * YY + intercept) / -coef[<span class="number">2</span>]</span><br><span class="line">ax.plot_surface(XX, YY, ZZ, rstride=<span class="number">8</span>, cstride=<span class="number">8</span>, alpha=<span class="number">0.3</span>)</span><br><span class="line">ax.scatter(X_new[mask, <span class="number">0</span>], X_new[mask, <span class="number">1</span>], X_new[mask, <span class="number">2</span>], c=<span class="string">'b'</span>,</span><br><span class="line">    cmap=mglearn.cm2, s=<span class="number">60</span>)</span><br><span class="line">ax.scatter(X_new[~mask, <span class="number">0</span>], X_new[~mask, <span class="number">1</span>], X_new[~mask, <span class="number">2</span>], c=<span class="string">'r'</span>,</span><br><span class="line">    cmap=mglearn.cm2, s=<span class="number">60</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">'feature0'</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">'feature1'</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">'feature1 ** 2'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-of-linear-svc-on-blobs-3d.png"></p><p>如果将线性SVM模型看作原始特征的函数，即<code>y = coef[0] * x[0] + coef[1] * x[1] + coef[2] * x[1] ** 2</code>，那么它实际上已经不是线性的了。它不是一条直线，而是一个椭圆。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.svm.linearsvc#sklearsn.svm.LinearSVC.decision_function" target="_blank" rel="noopener"><code>decision_function(X)</code></a></p><p>Predict confidence scores for samples. The confidence score for a sample is the signed distance of that sample to the hyperplane.</p></blockquote><blockquote><p><a href="https://devdocs.io/numpy~1.17/generated/numpy.c_" target="_blank" rel="noopener"><code>numpy.c_ = &lt;numpy.lib.index_tricks.CClass object&gt;</code></a></p><p>Translates slice objects to concatenation along the second axis.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.c_[np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]), np.array([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])]</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">6</span>]])</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ZZ = YY ** <span class="number">2</span>  <span class="comment"># 第三特征</span></span><br><span class="line"><span class="comment"># 预测(XX, YY, ZZ)</span></span><br><span class="line">dec = linear_svm_3d.decision_function(np.c_[XX.ravel(), YY.ravel(), ZZ.ravel()])</span><br><span class="line"><span class="comment"># 画出预测结果以边界(0)的位置</span></span><br><span class="line">plt.contour(XX, YY, dec.reshape(XX.shape), levels=[dec.min(), <span class="number">0</span>, dec.max()],</span><br><span class="line">    cmap=mglearn.cm2, alpha=<span class="number">0.5</span>)</span><br><span class="line">mglearn.discrete_scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], y)</span><br><span class="line">plt.xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature 1'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-of-linear-svc-on-blobs-2d.png"></p><h1 id="核技巧">核技巧</h1><p>这里需要记住的是，向数据表示中添加非线性特征，可以让线性模型变得更加强大。但是，通常来说我们并不知道要添加哪些特征，而且添加许多特征（比如100维特征空间所有可能的交互项）的计算开销可能会很大。<strong>幸运的是，有一种巧妙的数学技巧，让我们可以在更高维空间中学习分类器，而不用实际计算可能非常大的新数据表示。这种技巧叫作核技巧（kernel trick），它的原理是直接计算扩展特征表示中数据点之间的距离（更准确地说是内积），而不用实际对扩展进行计算</strong>。</p><p>对于支持向量机，将数据映射到更高维空间中有两种常用的方法：一种是<strong>多项式核</strong>，在一定阶数内计算原始特征所有可能的多项式（比如<code>feature1 ** 2 * feature2 ** 5</code>）；另一种是<strong>径向基函数（radial basis function，RBF）核</strong>，也叫高斯核。高斯核有点难以解释，因为它对应无限维的特征空间。一种对高斯核的解释是它考虑所有阶数的所有可能的多项式，但阶数越高，特征的重要性越小。</p><p>不过在实践中，核SVM背后的数学细节并不是很重要，可以简单地总结出使用RBF核SVM进行预测的方法——我们将在下一节介绍这方面的内容。</p><h1 id="理解svm">理解SVM</h1><p>在训练过程中，SVM学习每个训练数据点对于表示两个类别之间的决策边界的重要性。通常只有一部分训练数据点对于定义决策边界很重要：位于类别之间边界上的那些点。这些点叫作<strong>支持向量</strong>（support vector），支持向量机正是由此得名。</p><p>想要对新样本点进行预测，需要测量它与每个支持向量之间的距离。分类决策是基于它与支持向量之间的距离以及在训练过程中学到的支持向量重要性（保存在SVC的<code>dual_coef_</code>属性中）来做出的。</p><p>数据点之间的距离由高斯核给出：</p><p><span class="math display">\[k_{rbf}(x_1,x_2)=exp(-\gamma\left\| x_1-x_2\right\|^2)\]</span></p><p>这里<span class="math inline">\(x_1\)</span>和<span class="math inline">\(x_2\)</span>是数据点，<span class="math inline">\(\left\| x_1-x_2\right\|\)</span>表示欧式距离，<span class="math inline">\(\gamma\)</span>（gamma）是控制高斯核宽度的参数。</p><p>在forge数据集上训练SVM。决策边界用黑色表示，支持向量是尺寸较大的点。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.svm.svc" target="_blank" rel="noopener"><code>class sklearn.svm.SVC(C=1.0, kernel=’rbf’, degree=3, gamma=’auto_deprecated’, coef0=0.0, shrinking=True, probability=False, tol=0.001, cache_size=200, class_weight=None, verbose=False, max_iter=-1, decision_function_shape=’ovr’, random_state=None)</code></a></p><p>C-Support Vector Classification.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line">X, y = mglearn.tools.make_handcrafted_dataset()</span><br><span class="line">svm = SVC(kernel=<span class="string">'rbf'</span>, C=<span class="number">10</span>, gamma=<span class="number">0.1</span>).fit(X, y)</span><br><span class="line">mglearn.plots.plot_2d_separator(svm, X, eps=<span class="number">.5</span>)</span><br><span class="line">mglearn.discrete_scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], y)</span><br><span class="line"><span class="comment"># 画出支持向量</span></span><br><span class="line">sv = svm.support_vectors_</span><br><span class="line"><span class="comment"># 支持向量的类别标签由dual_coef_的正负号给出</span></span><br><span class="line">sv_labels = svm.dual_coef_.ravel() &gt; <span class="number">0</span></span><br><span class="line">mglearn.discrete_scatter(sv[:, <span class="number">0</span>], sv[:, <span class="number">1</span>], sv_labels, s=<span class="number">15</span>, markeredgewidth=<span class="number">3</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature 1'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-of-svm.png"></p><p>在这个例子中，SVM给出了非常平滑且非线性（不是直线）的边界。</p><h1 id="svm调参">SVM调参</h1><p>gamma参数是上一节给出的公式中的参数，用于控制高斯核的宽度。它决定了点与点之间“靠近”是指多大的距离。C参数是正则化参数，与线性模型中用到的类似。它限制每个点的重要性（或者更确切地说，每个点的<code>dual_coef_</code>）。</p><p>我们来看一下，改变这些参数时会发生什么。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, axes = plt.subplots(<span class="number">3</span>, <span class="number">3</span>, figsize=(<span class="number">15</span>, <span class="number">10</span>))</span><br><span class="line"><span class="keyword">for</span> ax, C <span class="keyword">in</span> zip(axes, [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">3</span>]):</span><br><span class="line">    <span class="keyword">for</span> a, gamma <span class="keyword">in</span> zip(ax, range(<span class="number">-1</span>, <span class="number">2</span>)):</span><br><span class="line">        mglearn.plots.plot_svm(log_C=C, log_gamma=gamma, ax=a)</span><br><span class="line">axes[<span class="number">0</span>, <span class="number">0</span>].legend([<span class="string">'class 0'</span>, <span class="string">'class 1'</span>, <span class="string">'sv class 0'</span>, <span class="string">'sv class 1'</span>],</span><br><span class="line">    ncol=<span class="number">4</span>, loc=(<span class="number">.9</span>, <span class="number">1.2</span>))</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-of-svm-for-different-parameters.png"></p><p>从左到右，我们将gamma的值从0.1增加到10。<strong>gamma较小，说明高斯核半径较大，许多点都被看作比较靠近。</strong>这一点可以在图中看出：左侧的图决策边界非常平滑，越向右的图决策边界更关注单个点。小的gamma值表示决策边界变化很慢，生成的事复杂度较低的模型，而大的gamma值则会生成更为复杂的模型。</p><p>从上到下，我们将参数C的值从0.1增加到1000。<strong>与线性模型相同，C值很小，说明模型非常受限，每个数据点的影响范围都有限。</strong>你可以看到，左上图的图中，决策边界看起来几乎是线性的，误分类的点对边界几乎没有任何影响。再看左下角的图，增大C之后这些点对模型的影响变大，使得决策边界发生弯曲来将这些点正确分类。</p><p>我们将RBF核SVM应用到乳腺癌数据集上。默认情况下，<code>C=1, gamma=1/n_features</code>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">    cancer.data, cancer.target, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">svc = SVC()</span><br><span class="line">svc.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Accuracy on training set: &#123;:.2f&#125;'</span>.format(svc.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Accuracy on test set: &#123;:.2f&#125;'</span>.format(svc.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accuracy on training set: 1.00</span><br><span class="line">Accuracy on test set: 0.63</span><br></pre></td></tr></table></figure><p>这个模型在训练集上的分数十分完美，但在测试集上的精度只有63%，存在相当严重的过拟合。<strong>虽然SVM的表现通常都很好，但它对参数的设定和数据的缩放非常敏感。特别地，它要求所有特征有相似的变化范围。</strong>我们来看一下每个特征的最小值和最大值，它们绘制在对数坐标上。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(X_train.min(axis=<span class="number">0</span>), <span class="string">'o'</span>, label=<span class="string">'min'</span>)</span><br><span class="line">plt.plot(X_train.max(axis=<span class="number">0</span>), <span class="string">'^'</span>, label=<span class="string">'max'</span>)</span><br><span class="line">plt.legend(loc=<span class="number">4</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Feature index'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature magnitude'</span>)</span><br><span class="line">plt.yscale(<span class="string">'log'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/features-magnitude-of-cancer.png"></p><p>从这张图中，我们可以确定乳腺癌数据集的特征具有完全不同的量级。这对其他模型来说（比如线性模型）可能是小问题，但对核SVM却有极大影响。我们来研究处理这个问题的几种方法： 。</p><h1 id="为svm预处理数据">为SVM预处理数据</h1><p>解决这个问题的一种方法就是对每个特征进行缩放，使其大致都位于同一范围。核SVM常用的缩放方法就是将所有特征缩放到0和1之间。现在我们来“人工”处理。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算训练集中每个特征的最小值</span></span><br><span class="line">min_on_training = X_train.min(axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 计算训练集中每个特征的范围（最大值-最小值）</span></span><br><span class="line">range_on_training = (X_train - min_on_training).max(axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 减去最小值，然后除以范围</span></span><br><span class="line"><span class="comment"># 这样每个特征都是min=0和max=1</span></span><br><span class="line">X_train_scaled = (X_train - min_on_training) / range_on_training</span><br><span class="line">print(<span class="string">'Minimum for each feature\n&#123;&#125;'</span>.format(X_train_scaled.min(axis=<span class="number">0</span>)))</span><br><span class="line">print(<span class="string">'Maximum for each feature\n&#123;&#125;'</span>.format(X_train_scaled.max(axis=<span class="number">0</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对测试集做相同的变换</span></span><br><span class="line">X_test_scaled = (X_test - min_on_training) / range_on_training</span><br><span class="line"></span><br><span class="line">svc = SVC()</span><br><span class="line">svc.fit(X_train_scaled, y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Accuracy on training set: &#123;:.3f&#125;'</span>.format(svc.score(X_train_scaled, y_train)))</span><br><span class="line">print(<span class="string">'Accuracy on test set: &#123;:.3f&#125;'</span>.format(svc.score(X_test_scaled, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Minimum for each feature</span><br><span class="line">[0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.</span><br><span class="line"> 0. 0. 0. 0. 0. 0.]</span><br><span class="line">Maximum for each feature</span><br><span class="line">[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.</span><br><span class="line"> 1. 1. 1. 1. 1. 1.]</span><br><span class="line">Accuracy on training set: 0.948</span><br><span class="line">Accuracy on test set: 0.951</span><br></pre></td></tr></table></figure><p>数据缩放的作用很大！<strong>实际上模型现在处于欠拟合的状态，因为训练集和测试集的性能非常接近，但还没有接近100%的精度。</strong>从这里开始，我们可以尝试增大C或gamma来拟合更为复杂的模型。例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">svc = SVC(C=<span class="number">1000</span>)</span><br><span class="line">svc.fit(X_train_scaled, y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Accuracy on training set: &#123;:.3f&#125;'</span>.format(svc.score(X_train_scaled, y_train)))</span><br><span class="line">print(<span class="string">'Accuracy on test set: &#123;:.3f&#125;'</span>.format(svc.score(X_test_scaled, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accuracy on training set: 0.988</span><br><span class="line">Accuracy on test set: 0.972</span><br></pre></td></tr></table></figure><p>在这个例子中，增大C可以显著改善模型，得到97.2%的精度。</p><h1 id="优点缺点和参数">优点、缺点和参数</h1><p>核支持向量机是非常强大的模型，在各种数据集上的表现都很好。SVM允许决策边界很复杂，即使数据只有几个特征。它在低维数据和高维数据（即很少特征和很多特征）上的表现都很好，但对样本个数的缩放表现不好。在有多达10000个样本的数据上运行SVM可能表现良好，但如果数据量达到100000甚至更大，在运行时间和内存使用方法可能会面临挑战。</p><p>SVM的另一个缺点是，预处理数据和调参都需要非常小心。这也是为什么如今很多应用中用的都是基于树的模型，比如随机森林或梯度提升（需要很少的预处理，甚至不需要预处理）。此外SVM模型很难检查，可能很难理解为什么会这么预测，而且也难以将模型向非专家进行解释。</p><p>不过SVM仍然是值得尝试的，特别是所有特征的测量单位相似（比如都是像素密度）而且范围也差不多时，</p><p>核SVM的重要参数是正则化参数C、核的选择以及与核相关的参数。RBF核只有一个参数gamma，它是高斯核宽度的倒数。gamma和C控制的都是模型复杂度，较大的值都对应更为复杂的模型。因此，这两个参数的设定通常是强烈相关的，应该同时调节。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Machine Learning with Python </tag>
            
            <tag> supervised </tag>
            
            <tag> classification </tag>
            
            <tag> SVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>决策树集成</title>
      <link href="/notes/introduction-to-ml-with-python/decision-tree-ensemble/"/>
      <url>/notes/introduction-to-ml-with-python/decision-tree-ensemble/</url>
      
        <content type="html"><![CDATA[<p><strong>集成</strong>（ensemble）是合并多个机器学习模型来构建更强大模型的方法。在机器学习文献中有很多模型都属于这一类，但已证明有两种集成模型对大量分类和回归的数据集都是有效的，二者都以决策树为基础，分别是随机森林（random forest）和梯度提升决策树（gradient boosted decision tree）。</p><h1 id="随机森林">随机森林</h1><p>决策树的一个主要缺点在于经常对训练数据过拟合。随机森林是解决这个问题的一种方法。随机森林本质上是许多决策树的集合，其中每棵树都和其他树略有不同。随机森林背后的思想是，每棵树的预测可能都相对较好，但可能对部分数据过拟合。如果构造很多树，并且每棵树的预测都很好，但都以不同的方式过拟合，那么我们可以对这些树的结果取平均值来降低过拟合。既能减少过拟合又能保持树的预测能力，这可以在数学上严格证明。</p><p>为了实现这一策略，我们需要构造许多决策树。每棵树都应该对目标值做出可以接受的预测，还应该与其他树不同。随机森林的名字来自于将随机性添加到树的构造过程中，以确保每棵树都各不相同。<strong>随机森林中树的随机化方法有两种：一种是通过选择用于构造树的数据点，另一种是通过选择每次划分测试的特征。</strong></p><a id="more"></a><h2 id="构造随机森林">构造随机森林</h2><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.ensemble.randomforestclassifier" target="_blank" rel="noopener"><code>class sklearn.ensemble.RandomForestClassifier(n_estimators=’warn’, criterion=’gini’, max_depth=None, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_features=’auto’, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, bootstrap=True, oob_score=False, n_jobs=None, random_state=None, verbose=0, warm_start=False, class_weight=None)</code></a></p></blockquote><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.ensemble.randomforestregressor" target="_blank" rel="noopener"><code>class sklearn.ensemble.RandomForestRegressor(n_estimators=’warn’, criterion=’mse’, max_depth=None, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_features=’auto’, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, bootstrap=True, oob_score=False, n_jobs=None, random_state=None, verbose=0, warm_start=False)</code></a></p></blockquote><p>想要构造一个随机森林模型，你需要确定用于构造的树的个数（<code>n_estimators</code>参数）。比如我们想要构造10棵树。这些树在构造时彼此完全独立，算法对每棵树进行不同的随机选择，以确保树和树之间是有区别的。想要构造一棵树，首先要对数据进行<strong>自助采样</strong>（bootstrap sample）。也就是说，从<code>n_samples</code>个数据点中有放回地重复随机抽取一个样本，共抽取<code>n_samples</code>次。这样会创建一个与原始数据集大小相同的数据集，但有些数据点会缺失（大约三分之一），有些会重复。</p><p>举例说明，比如我们想要创建列表['a', 'b', 'c', 'd']的自助采样。一种可能的自助采样是['b', 'd', 'd', 'c']，另一种可能的采样为['d', 'a', 'd', 'a']。</p><p>接下来，基于这个新创建的数据集来构造决策树。但是，要对我们在介绍决策树时描述的算法稍作修改。在每个结点处，算法随机选择特征的一个子集，并对其中一个特征寻找最佳测试，而不是对每个结点都寻找最佳测试。选择的特征个数由<code>max_features</code>参数来控制。每个结点中特征子集的选择是相互独立的，这样树的每个结点可以使用特征的不同子集来做出决策。</p><p>由于使用了自助采样，随机森林中构造每棵决策树的数据集都是略有不同的。由于每个结点的特征选择，每棵树中的每次划分都是基于特征的不同子集。这两种方法共同保证随机森林中所有树都不相同。</p><p>在这个过程中的一个关键参数是<code>max_features</code>。如果我们设置<code>max_features</code>等于<code>n_features</code>，那么每次划分都要考虑数据集的所有特征，在特征选择的过程中没有添加随机性（不过自助采样依然存在随机性））。如果设置<code>max_features</code>等于1，那么在划分时将无法选择对哪个特征进行测试，只能对随机选择的某个特征搜索不同的阈值。因此，如果<code>max_features</code>较大，那么随机森林中的树将会十分相似，利用最独特的特征可以轻松拟合数据。如果<code>max_features</code>较小，那么随机森林中的树将会差异很大，为了很好地拟合数据，每棵树的深度都要很大。</p><p>想要利用随机森林进行预测，算法首先对森林中的每棵树进行预测。对于回归问题，我们可以对这些结果取平均值作为最终预测。对于分类问题，则用到了“软投票”（soft voting）策略。也就是说，每棵树做出“软“预测，给出每个可能的输出标签的概率。对所有树的预测概率取平均值，然后将概率最大的类别作为预测结果。</p><h2 id="分析随机森林">分析随机森林</h2><p>下面将由5棵树组成的随机森林应用到前面研究过的<code>two_moons</code>数据集上：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_moons</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"></span><br><span class="line">X, y = make_moons(n_samples=<span class="number">100</span>, noise=<span class="number">0.25</span>, random_state=<span class="number">3</span>)</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, stratify=y, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">forest = RandomForestClassifier(n_estimators=<span class="number">5</span>, random_state=<span class="number">2</span>)</span><br><span class="line">forest.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">3</span>, figsize=(<span class="number">20</span>, <span class="number">10</span>))</span><br><span class="line"><span class="keyword">for</span> i, (ax, tree) <span class="keyword">in</span> enumerate(zip(axes.ravel(), forest.estimators_)):  <span class="comment"># 树被保存在estimator_属性中</span></span><br><span class="line">    ax.set_title(<span class="string">'Tree &#123;&#125;'</span>.format(i))</span><br><span class="line">    mglearn.plots.plot_tree_partition(X_train, y_train, tree, ax=ax)</span><br><span class="line"></span><br><span class="line">mglearn.plots.plot_2d_separator(forest, X_train, fill=<span class="literal">True</span>, ax=axes[<span class="number">-1</span>, <span class="number">-1</span>])</span><br><span class="line">axes[<span class="number">-1</span>, <span class="number">-1</span>].set_title(<span class="string">'Random Forest'</span>)</span><br><span class="line">mglearn.discrete_scatter(X_train[:, <span class="number">0</span>], X_train[:, <span class="number">1</span>], y_train)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-of-random-forest.png"></p><p>你可以清楚地看到，这5棵树学到的决策边界大不相同。每棵树都犯了一些错误，因为这里画出的一些训练点实际上并没有包含在树的训练集中，原因在于自助采样。</p><p>随机森林比单独每一棵树的过拟合都要小，给出的决策边界也更符合直觉。在任何实际应用中，我们会用到更多棵树（通常是几百或上千），从而得到更平滑的边界。</p><p>再举一个例子，我们将包含100棵树的随机森林应用在乳腺癌数据集上：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cancer = load_breast_cancer()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">    cancer.data, cancer.target, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">forest = RandomForestClassifier(n_estimators=<span class="number">100</span>, random_state=<span class="number">0</span>)</span><br><span class="line">forest.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Accuracy on training set: &#123;:.3f&#125;'</span>.format(forest.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Accuracy on test set: &#123;:.3f&#125;'</span>.format(forest.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accuracy on training set: 1.000</span><br><span class="line">Accuracy on test set: 0.972</span><br></pre></td></tr></table></figure><p>在没有调节任何参数的情况下，随机森林的精度为97%，比线性模型或单棵决策树都要好。我们可以调节<code>max_featues</code>参数，或者像单棵决策树那样进行预剪枝。但是，随机森林的默认参数通常就已经可以给出很好的结果。</p><p>与决策树类似，随机森林也可以给出特征重要性，计算方法是将森林中所有树的特征重要性求和并取平均。一般来说，随机森林给出的特征重要性要比单棵树给出的更为可靠。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plot_feature_importances_cancer(forest)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/feature-importances-of-random-forest.png"></p><p>如你所见，与单棵树相比，随机森林中有更多特征的重要性不为零。与单棵决策树类似，随机森林也给出了&quot;worst radius&quot;（最大半径）特征很大的重要性，但从总体来看，它实际上却选择&quot;worst perimeter&quot;（最大周长）作为信息量最大的特征。由于构造随机森林过程中的随机性，算法需要考虑多种可能的解释，结果就是随机森林比单棵树更能从总体把握数据的特征。</p><h2 id="优点缺点和参数">优点、缺点和参数</h2><p>用于回归和分类的随机森林是目前应用最广泛的机器学习方法之一。这种方法非常强大，通常不需要反复调节参数就可以给出很好的结果，也不需要对数据进行缩放。</p><p>从本质上看，随机森林拥有决策树的所有优点，同时弥补了决策树的一些缺陷。仍然使用决策树的一个原因是需要决策过程的紧凑表示。基本上不可能对几十棵甚至上百棵树做出详细解释，随机森林中树的深度往往比决策树还要大（因为用到了特征子集）。因此，如果你需要以可视化的方式向非专家总结预测过程，那么选择单棵决策树可能更好。虽然在大型数据集上构建随机森林可能比较费时间，但在一台计算机的多个CPU内核上并行计算也很容易。如果你用的是多核处理器，你可以用<code>n_jobs</code>参数来调节使用的内核个数。使用更多的CPU内核，可以让速度线性增加，但设置<code>n_jobs</code>大于内核个数是没有用的。你可以设置<code>n_jobs=-1</code>来使用计算机的所有内核。</p><p>你应该记住，随机森林本质上是随机的，设置不同的随机状态（或者不设置<code>random_state</code>参数）可以彻底改变构建的模型。森林中的树越多，它对随机状态选择的鲁棒性就越好。如果你希望结果可以重现，固定<code>random_state</code>是很重要的。</p><p>对于维度非常高的稀疏数据（比如文本数据），随机森林的表现往往不是很好。对于这种数据，使用线性模型可能更为合适。即使是非常大的数据集，随机森林的表现也通常也很好，训练过程很容易并行在功能强大的计算机的多个CPU内核上。不过，随机森林需要更大的内存，训练和预测的速度也比线性模型要慢。对一个应用来说，如果时间和内存很重要的话，那么换用线性模型可能更为明智。</p><p>需要调节的重要参数有<code>n_estimators</code>和<code>max_features</code>，可能还包括预剪枝选项（如<code>max_depth</code>）。<strong><code>n_estimators</code>总是越大越好。</strong>对更多的树取平均可以降低过拟合，从而得到鲁棒性更好的集成。不过收益是递减的，而且树越多需要的内存也越多，训练时间也越长。<strong>常用的经验法则就是“在你的时间/内存允许的情况下尽量多”。</strong></p><p>前面说过，<code>max_features</code>决定每棵树的随机性大小，较小的<code>max_features</code>可以降低过拟合。<strong>一般来说，好的经验就是使用默认值：对于分类，默认值是<code>max_features=sqrt(n_features)</code>；对于回归，默认值是<code>max_features=n_features</code>。</strong>增大<code>max_features</code>或<code>max_leaf_nodes</code>有时也可以提高性能。它还可以大大降低用于训练和预测的时间和空间要求。</p><h1 id="梯度提升回归树">梯度提升回归树</h1><p>梯度提升回归树是另一种集成方法，通过合并多个决策树来构建一个更为强大的模型。虽然名字中含有“回归”，但这个模型既可以用于回归也可以用于分类。与随机森林方法不同，梯度提升采用连续的方式构造树，每棵树都试图纠正前一棵树的错误。默认情况下，梯度提升回归树中没有随机化，而是用到了强预剪枝。梯度提升树通常使用深度很小（1到5之间）的树，这样模型占用的内存更少，预测速度也更快。</p><p>梯度提升背后的主要思想是合并许多简单的模型（在这个语境中叫作<strong>弱学习器</strong>），比如深度较小的树。每棵树只能对部分数据做出好的预测，因此，添加的树越来越多，可以不断迭代提高性能。</p><p>梯度提升树经常是机器学习竞赛的优胜者，并且广泛应用于业界。与随机森林相比，它通常对参数设置更为敏感，但如果参数设置正确的话，模型精度更高。</p><p>除了预剪枝与集成中树的数量之外，梯度提升的另一个重要参数是<code>learning_rate</code>（学习率），用于控制每棵树纠正前一棵树的错误的强度。较高的学习率意味着每棵树都可以做出较强的修正，这样模型更为复杂。通过增大<code>n_estimators</code>来向集成中添加更多树，也可以增加模型复杂度，因为模型有更多机会纠正训练集上的错误。</p><p>下面是在乳腺癌数据集上应用GradientBoostingClassifier的示例。默认使用100棵树，最大深度是3，学习率是0.1。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.ensemble.gradientboostingclassifier" target="_blank" rel="noopener"><code>class sklearn.ensemble.GradientBoostingClassifier(loss=’deviance’, learning_rate=0.1, n_estimators=100, subsample=1.0, criterion=’friedman_mse’, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_depth=3, min_impurity_decrease=0.0, min_impurity_split=None, init=None, random_state=None, max_features=None, verbose=0, max_leaf_nodes=None, warm_start=False, presort=’auto’, validation_fraction=0.1, n_iter_no_change=None, tol=0.0001)</code></a></p></blockquote><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.ensemble.gradientboostingregressor" target="_blank" rel="noopener"><code>class sklearn.ensemble.GradientBoostingRegressor(loss=’ls’, learning_rate=0.1, n_estimators=100, subsample=1.0, criterion=’friedman_mse’, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_depth=3, min_impurity_decrease=0.0, min_impurity_split=None, init=None, random_state=None, max_features=None, alpha=0.9, verbose=0, max_leaf_nodes=None, warm_start=False, presort=’auto’, validation_fraction=0.1, n_iter_no_change=None, tol=0.0001)</code></a></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> GradientBoostingClassifier</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">    cancer.data, cancer.target, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">gbrt = GradientBoostingClassifier(random_state=<span class="number">0</span>)</span><br><span class="line">gbrt.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Accuracy on training set: &#123;:.3f&#125;'</span>.format(gbrt.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Accuracy on test set: &#123;:.3f&#125;'</span>.format(gbrt.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accuracy on training set: 1.000</span><br><span class="line">Accuracy on test set: 0.965</span><br></pre></td></tr></table></figure><p>由于训练集进度达到100%，所以很可能存在过拟合。为了降低过拟合，我们可以限制最大深度来加强预剪枝，也可以降低学习率。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gbrt = GradientBoostingClassifier(random_state=<span class="number">0</span>, max_depth=<span class="number">1</span>)  <span class="comment"># 限制最大深度</span></span><br><span class="line">gbrt.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Accuracy on training set: &#123;:.3f&#125;'</span>.format(gbrt.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Accuracy on test set: &#123;:.3f&#125;'</span>.format(gbrt.score(X_test, y_test)))</span><br><span class="line"></span><br><span class="line">gbrt = GradientBoostingClassifier(random_state=<span class="number">0</span>, learning_rate=<span class="number">0.01</span>)  <span class="comment"># 降低学习率</span></span><br><span class="line">gbrt.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Accuracy on training set: &#123;:.3f&#125;'</span>.format(gbrt.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Accuracy on test set: &#123;:.3f&#125;'</span>.format(gbrt.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accuracy on training set: 0.991</span><br><span class="line">Accuracy on test set: 0.972</span><br><span class="line">Accuracy on training set: 0.988</span><br><span class="line">Accuracy on test set: 0.965</span><br></pre></td></tr></table></figure><p>降低模型复杂度的两种方法都降低了训练集精度，这和预期相同。在这个例子中，减小树的最大深度显著提升了模型性能。</p><p>对于其他基于决策树的模型，我们也可以将特征重要性可视化，以便更好地理解模型。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gbrt = GradientBoostingClassifier(random_state=<span class="number">0</span>, max_depth=<span class="number">1</span>)</span><br><span class="line">gbrt.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">plot_feature_importances_cancer(gbrt)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/feature-importances-of-gbrt.png"></p><p>可以看到，梯度体征树的特征重要性与随机森林的特征重要性有些类似，不过梯度提升完全忽略了某些特征。</p><p><strong>由于梯度提升和随机森林两种方法在类似的数据上表现得都很好，因此一种常用的方法就是先尝试随机森林，它的鲁棒性很好。如果随机森林效果很好，但预测时间太长，或者机器学习模型精度小数点后第二位的提高也很重要，那么切换成梯度提升通常会有用。</strong></p><h2 id="优点缺点和参数-1">优点、缺点和参数</h2><p>梯度提升决策树是监督学习中最强大也最常用的模型之一。其主要缺点是需要仔细调参，而且训练时间可能会比较长。与其他基于树的模型类似，这一算法不需要对数据进行缩放就可以表现得很好，而且也适用于二元特征与连续特征同时存在的数据集。<strong>与其他基于树的模型相同，它也通常不适用于高维稀疏数据。</strong></p><p>梯度提升树模型的主要参数包括树的数量<code>n_estimators</code>和学习率<code>learning_rate</code>，后者用于控制每棵树对前一棵树的错误的纠正强度。这两个参数高度相关，因为<code>learning_rate</code>越低，就需要更多的树来构建具有相似复杂度的模型。随机森林的<code>n_estimators</code>值总是越大越好，但梯度提升不同，增大<code>n_estimators</code>会导致模型更加复杂，进而可能导致过拟合。通常的做法是根据时间和内存的预算选择合适的<code>n_estimators</code>，然后对不同的<code>learning_rate</code>进行遍历。</p><p>另一个重要参数是<code>max_depth</code>（或<code>max_leaf_nodes</code>），用于降低每棵树的复杂度。梯度提升模型的<code>max_depth</code>通常都设置的很小，一般不超过5。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Machine Learning with Python </tag>
            
            <tag> supervised </tag>
            
            <tag> regression </tag>
            
            <tag> classification </tag>
            
            <tag> decision tree </tag>
            
            <tag> ensemble </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>决策树</title>
      <link href="/notes/introduction-to-ml-with-python/decision-trees/"/>
      <url>/notes/introduction-to-ml-with-python/decision-trees/</url>
      
        <content type="html"><![CDATA[<p>决策树是广泛用于分类和回归任务的模型。本质上，它是从一层层的if/else问题中进行学习，并得出结论。想象一下，你想要区分下面四种动物：熊、鹰、企鹅和海豚。你的目标是通过尽可能少的if/else问题来得到正确答案。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> graphviz</span><br><span class="line"></span><br><span class="line">mygraph = graphviz.Digraph(node_attr=&#123;<span class="string">'shape'</span>: <span class="string">'box'</span>&#125;,</span><br><span class="line">                           edge_attr=&#123;<span class="string">'labeldistance'</span>: <span class="string">"10.5"</span>&#125;,</span><br><span class="line">                           format=<span class="string">"svg"</span>)</span><br><span class="line">mygraph.node(<span class="string">"0"</span>, <span class="string">"有没有羽毛？"</span>)</span><br><span class="line">mygraph.node(<span class="string">"1"</span>, <span class="string">"会不会飞？"</span>)</span><br><span class="line">mygraph.node(<span class="string">"2"</span>, <span class="string">"有没有鳍？"</span>)</span><br><span class="line">mygraph.node(<span class="string">"3"</span>, <span class="string">"鹰"</span>)</span><br><span class="line">mygraph.node(<span class="string">"4"</span>, <span class="string">"企鹅"</span>)</span><br><span class="line">mygraph.node(<span class="string">"5"</span>, <span class="string">"海豚"</span>)</span><br><span class="line">mygraph.node(<span class="string">"6"</span>, <span class="string">"熊"</span>)</span><br><span class="line">mygraph.edge(<span class="string">"0"</span>, <span class="string">"1"</span>, label=<span class="string">"有"</span>)</span><br><span class="line">mygraph.edge(<span class="string">"0"</span>, <span class="string">"2"</span>, label=<span class="string">"没有"</span>)</span><br><span class="line">mygraph.edge(<span class="string">"1"</span>, <span class="string">"3"</span>, label=<span class="string">"会"</span>)</span><br><span class="line">mygraph.edge(<span class="string">"1"</span>, <span class="string">"4"</span>, label=<span class="string">"不会"</span>)</span><br><span class="line">mygraph.edge(<span class="string">"2"</span>, <span class="string">"5"</span>, label=<span class="string">"有"</span>)</span><br><span class="line">mygraph.edge(<span class="string">"2"</span>, <span class="string">"6"</span>, label=<span class="string">"没有"</span>)</span><br><span class="line">mygraph.render(view=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-tree-on-animal.svg"></p><p>用机器学习的语言来说就是，为了区分四类动物，我们利用三个特征（“有没有羽毛” “会不会飞”和“有没有鳍”）来构建一个模型。我们可以利用监督学习从数据中学习模型，而无需人为构建模型。</p><a id="more"></a><h1 id="构造决策树">构造决策树</h1><p>我们在一个二维分类数据集<code>two_moons</code>上构造决策树。这个数据集由2个半月形组成，每个类别都包含50个数据点。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_tree_progressive()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/datasets-two-moons.png"></p><p>学习决策树，就是学习一系列if/else问题，使我们能够以最快的速度得到正确答案。在机器学习中，这些问题叫作测试。数据通常并不是像动物的例子那样具有二元特征（是/否）的形式，而是表示为连续特征。用于连续数据的测试形式是：”特征i的值是否大于a？“</p><p>为了构造决策树，算法搜遍所有可能的测试，找出对目标变量来说信息量最大的那一个。下图展示了选出的第一个测试。</p><p><img src="/uploads/image/introduction-to-ml-with-python/depth-1-decision-tree-on-two-moons.png"></p><p>将数据集在x[1]=0.0596处垂直划分可以得到最多的信息，它在最大程度上将类别0中的点与类别1中的点进行区分。顶结点（也叫根结点）表示整个数据集。通过测试x[1]&lt;=0.0596的真假来对数据集进行划分，在图中表示为一条黑线。如果测试结果为真，那么将这个点分配给左结点，左结点里包含属于类别0的2个点和属于类别1的32个点。否则将这个点分配给右结点。这两个结点对应图中的顶部区域和底部区域。尽管第一次划分已经对两个类别做了很好的区分，但底部区域仍包含属于类别0的点，顶部区域也仍包含属于类别1的点。我们可以在两个区域中重复寻找最佳测试的过程，从而构建出更准确的模型。下图展示了信息量最大的下一次划分，这次划分是基于x[0]做出的，分为左右两个区域。</p><p><img src="/uploads/image/introduction-to-ml-with-python/depth-2-decision-tree-on-two-moons.png"></p><p>这一递归过程生成一棵二元决策树，其中每个结点都包含一个测试。由于每个测试仅关注一个特征，所以划分后的区域边界始终与坐标轴平行。</p><p>对数据反复进行递归划分，直到划分后的每个区域（决策树的每个叶结点）只包含单一目标值（单一类别或单一回归值）。如果树中某个叶结点所包含数据点的目标值都相同，那么这个叶结点就是纯的（pure）。这个数据集的最终划分如下图。想要对新数据点进行预测，首先要查看这个点位于特征空间划分的哪个区域，然后将该区域的多数目标值作为预测结果。</p><p><img src="/uploads/image/introduction-to-ml-with-python/depth-9-decision-tree-on-two-moons.png"></p><p>决策树也可以用于回归任务，使用的方法完全相同。预测的方法是，基于每个结点的测试对树进行遍历，最终找到新数据点所属的叶结点。这一数据点的输出即为此叶结点中所有训练点的平均目标值。</p><h1 id="控制决策树的复杂度">控制决策树的复杂度</h1><p>通常来说，构造决策树直到所有叶结点都是纯的叶结点，这会导致模型非常复杂，并且对训练数据高度过拟合。纯叶结点的存在说明这棵树在训练集上的精度是100%。训练集中的每个数据点都位于分类正确的叶结点中。在上图中可以看出过拟合，在所有属于类别0的点中有一块属于类别1的区域。另一方面，有一小条属于类别0的区域，包围着最右侧属于类别0的那个点。这并不是人们想象中决策边界的样子，这个决策边界过于关注远离同类别其他点的单个异常点。</p><p>防止过拟合有两种常见策略：一种是及早停止树的生长，也叫<strong>预剪枝</strong>（pre-pruning）；另一种是先构造树，但随后删除或折叠信息量很少的结点，也叫<strong>后剪枝</strong>（post-pruning）或<strong>剪枝</strong>（pruning）。预剪枝的限制条件可能包含限制树的最大深度、限制叶结点的最大数目，或者规定一个结点中数据点的最小数目来防止继续划分。</p><p>我们在乳腺癌数据集上更详细地看一下预剪枝的效果。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.tree.decisiontreeclassifier" target="_blank" rel="noopener"><code>class sklearn.tree.DecisionTreeClassifier(criterion=’gini’, splitter=’best’, max_depth=None, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_features=None, random_state=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, class_weight=None, presort=False)</code></a></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"></span><br><span class="line">cancer = load_breast_cancer()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(cancer.data,</span><br><span class="line">    cancer.target, stratify=cancer.target, random_state=<span class="number">42</span>)</span><br><span class="line">tree = DecisionTreeClassifier(random_state=<span class="number">0</span>)  <span class="comment"># 默认将树完全展开（所有叶结点都是纯的）</span></span><br><span class="line">tree.fit(X_train, y_train)</span><br><span class="line">print(<span class="string">'Accuracy on training set: &#123;:.3f&#125;'</span>.format(tree.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Accuracy on test set: &#123;:.3f&#125;'</span>.format(tree.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accuracy on training set: 1.000</span><br><span class="line">Accuracy on test set: 0.937</span><br></pre></td></tr></table></figure><p>不出所料，训练集上的精度是100%，这是因为叶结点都是纯的，树的深度很大，足以完美地记住训练数据的所有标签。测试集精度比线性模型略低，线性模型的精度约为95%。</p><p>如果我们不限制决策树的深度，它的深度和复杂度都可以变得特别大。因此，未剪枝的树容易过拟合，对新数据的泛化能力不佳。现在我们将预剪枝应用在决策树上，这可以在完美拟合训练数据之前阻止树的展开。一种选择是在到达一定深度后停止树的展开。这里我们设置<code>max_depth=4</code>，这意味着只可以连续问4个问题。限制树的深度可以减少过拟合。这会降低训练集的精度，但可以提高测试集的精度。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tree = DecisionTreeClassifier(max_depth=<span class="number">4</span>, random_state=<span class="number">0</span>)</span><br><span class="line">tree.fit(X_train, y_train)</span><br><span class="line">print(<span class="string">'Accuracy on training set: &#123;:.3f&#125;'</span>.format(tree.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Accuracy on test set: &#123;:.3f&#125;'</span>.format(tree.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accuracy on training set: 0.988</span><br><span class="line">Accuracy on test set: 0.951</span><br></pre></td></tr></table></figure><h1 id="分析决策树">分析决策树</h1><p>我们可以利用tree模块的export_graphviz函数来将树可视化。这个函数会生成一个.dot格式的文件，这是一种用于保存图形的文本文件格式。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.tree.export_graphviz#sklearn.tree.export_graphviz" target="_blank" rel="noopener"><code>sklearn.tree.export_graphviz(decision_tree, out_file=None, max_depth=None, feature_names=None, class_names=None, label=’all’, filled=False, leaves_parallel=False, impurity=True, node_ids=False, proportion=False, rotate=False, rounded=False, special_characters=False, precision=3)</code></a></p><p>Export a decision tree in DOT format.</p><p>This function generates a GraphViz representation of the decision tree, which is then written into <code>out_file</code>. Once exported, graphical renderings can be generated using, for example:</p><p><code>$ dot -Tps tree.dot -o tree.ps      (PostScript format)</code></p><p><code>$ dot -Tpng tree.dot -o tree.png    (PNG format)</code></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> export_graphviz</span><br><span class="line">export_graphviz(tree, out_file=<span class="string">'tree.dot'</span>, class_names=[<span class="string">'malignant'</span>, <span class="string">'benign'</span>],</span><br><span class="line">    feature_names=cancer.feature_names, impurity=<span class="literal">False</span>, filled=<span class="literal">True</span>)</span><br><span class="line">t = graphviz.render(engine=<span class="string">'dot'</span>, format=<span class="string">'svg'</span>, filepath=<span class="string">'tree.dot'</span>)</span><br><span class="line">graphviz.view(t)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-tree-on-breast-cancer.svg"></p><p>树的可视化有助于深入理解算法是如何进行预测的，也是易于向非专家解释的机器学习算法的优秀示例。不过，即使这里树的深度只有4层，也有点太大了。深度更大的树（深度为10并不罕见）更加难以理解。一种观察树的方法可能有用，就是找出大部分数据的实际路径。上图中每个结点的samples给出了该结点中的样本个数，values给出的是每个类别的样本个数。观察根结点右侧的子结点，我们发现它只包含8个良性样本，但有134个恶性样本。树的这一侧的其余分支只是利用一些更精细的区别将这8个良性样本分离出来。</p><p>再来看一下根结点左侧子结点，我们得到25个恶性样本和259个良性样本。几乎所有的良性样本（259个中的245个）最终都进入左侧第二个叶结点中，大部分其他叶结点都只包含很少的样本。</p><h1 id="树的特征重要性">树的特征重要性</h1><p>查看整个树可能非常费劲，除此之外，我们还可以利用一些有用的属性来总结树的工作原理。其中最常用的是<strong>特征重要性</strong>（feature importance），它为每个特征对树的决策的重要性进行排序。对于每个特征来说，它都是一个介于0和1之间的数字，其中0表示”根本没用到“，1表示”完美预测目标值“。特征重要性的求和始终为1:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'Feature importrances:\n&#123;&#125;'</span>.format(tree.feature_importances_))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_feature_importances_cancer</span><span class="params">(model)</span>:</span></span><br><span class="line">    n_features = cancer.data.shape[<span class="number">1</span>]</span><br><span class="line">    plt.barh(range(n_features), model.feature_importances_, align=<span class="string">'center'</span>)</span><br><span class="line">    plt.yticks(np.arange(n_features), cancer.feature_names)</span><br><span class="line">    plt.xlabel(<span class="string">'Feature importance'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'Feature'</span>)</span><br><span class="line"></span><br><span class="line">plot_feature_importances_cancer(tree)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Feature importrances:</span><br><span class="line">[0.         0.         0.         0.         0.         0.</span><br><span class="line"> 0.         0.         0.         0.         0.01019737 0.04839825</span><br><span class="line"> 0.         0.         0.0024156  0.         0.         0.</span><br><span class="line"> 0.         0.         0.72682851 0.0458159  0.         0.</span><br><span class="line"> 0.0141577  0.         0.018188   0.1221132  0.01188548 0.        ]</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/feature-importances-of-tree.png"></p><p>这里我们看到，顶部划分用到的特征（&quot;worst radius&quot;）是最重要的特征。这也证实了我们在分析树时的观察结论，即第一层划分已经将两个类别区分得很好。</p><p>但是，如果某个特征的feature_importances_很小，并不能说明这个特征没有提供任何信息。这只能说明该特征没有被树选中，可能是因为另一个特征也包含了同样的信息。</p><p>与线性模型的系数不同，特征的重要性始终为正数，也不能说明该特征对应哪个类别。特征重要性告诉我们&quot;worst radius&quot;（最大半径）特征很重要，但并没有告诉我们半径大表示样本是良性还是恶性。事实上，在特例和类别之间可能没有这样的简单关系，你可以在下面的例子中看出这一点。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tree = mglearn.plots.plot_tree_not_monotone()  <span class="comment"># 会生成mytree.dot文件</span></span><br></pre></td></tr></table></figure><p><code>$ dot -Tpng mytree.dot -o tree-not-monotone.png</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Feature importances: [0. 1.]</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/datasets-not-monotone.png"></p><p><img src="/uploads/image/introduction-to-ml-with-python/tree-not-monotone.png"></p><p>该图显示的是有两个特征和两个类别的数据集。这里所有信息都包含在x[1]中，没有用到x[0]。但x[1]和输出类别之间并不是单调关系，即我们不能这么说：“较大的x[1]对应类别0，较小的x[1]对应类别1“（反之亦然）。</p><h1 id="用于回归的决策树">用于回归的决策树</h1><p>虽然我们主要讨论的是用于分类的决策树，但对用于回归的决策树来说，所有内容都是类似的，在DecisionTreeRegressor中实现。回归树的用法和分析与分类树非常类似。但在将基于树的模型用于回归时，我们想要指出它的一个特殊性质。DecisionTreeRegressor（以及其他所有基于树的回归模型）不能<strong>外推</strong>（extrapolate），也不能在训练数据范围之外进行预测。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.tree.decisiontreeregressor" target="_blank" rel="noopener"><code>class sklearn.tree.DecisionTreeRegressor(criterion=’mse’, splitter=’best’, max_depth=None, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_features=None, random_state=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, presort=False)</code></a></p></blockquote><p>我们利用计算机内存（RAM）历史价格的数据集来更详细地研究这一点。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">ram_prices = pd.read_csv(os.path.join(mglearn.datasets.DATA_PATH, <span class="string">"ram_price.csv"</span>))</span><br><span class="line"></span><br><span class="line">plt.semilogy(ram_prices.date, ram_prices.price)</span><br><span class="line">plt.xlabel(<span class="string">"Year"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Price in $/Mbyte"</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/ram-price.png"></p><p>注意y轴的对数刻度。在用对数坐标轴绘图时，二者的线性关系看起来非常好，所以预测应该相对比较容易，除了一些不平滑之处之外。</p><p>我们将利用2000年前的历史数据来预测2000年后的价格，只用日期作为特征。我们将对比两个简单的模型：DecisionTreeRegressor和LinearRegression。我们对价格取对数，使得二者关系的线性相对更好。这对DecisionTreeRegressor不会产生什么影响，但对LinearRegression的影响却很大。训练模型并作出预测之后，我们应用指数映射来做对数变换的你运算。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor</span><br><span class="line"><span class="comment"># 利用历史数据预测2000年后的价格</span></span><br><span class="line">data_train = ram_prices[ram_prices.date &lt; <span class="number">2000</span>]</span><br><span class="line">data_test = ram_prices[ram_prices.date &gt;= <span class="number">2000</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于日期来预测价格</span></span><br><span class="line">X_train = data_train.date[:, np.newaxis]</span><br><span class="line"><span class="comment"># we use a log-transform to get a simpler relationship of data to target</span></span><br><span class="line">y_train = np.log(data_train.price)</span><br><span class="line"></span><br><span class="line">tree = DecisionTreeRegressor(max_depth=<span class="number">3</span>).fit(X_train, y_train)</span><br><span class="line">linear_reg = LinearRegression().fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对所有数据进行预测</span></span><br><span class="line">X_all = ram_prices.date[:, np.newaxis]</span><br><span class="line"></span><br><span class="line">pred_tree = tree.predict(X_all)</span><br><span class="line">pred_lr = linear_reg.predict(X_all)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数变换逆运算</span></span><br><span class="line">price_tree = np.exp(pred_tree)</span><br><span class="line">price_lr = np.exp(pred_lr)</span><br><span class="line"></span><br><span class="line">plt.semilogy(data_train.date, data_train.price, label=<span class="string">"Training data"</span>)</span><br><span class="line">plt.semilogy(data_test.date, data_test.price, label=<span class="string">"Test data"</span>)</span><br><span class="line">plt.semilogy(ram_prices.date, price_tree, label=<span class="string">"Tree prediction"</span>)</span><br><span class="line">plt.semilogy(ram_prices.date, price_lr, label=<span class="string">"Linear prediction"</span>)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/linear-regression-and-decision-tree-on-ram-price.png"></p><p>两个模型之间的差异非常明显。线性模型用一条直线对数据做近似，这是我们所知道的。这条线对测试数据给出了相当好的预测，不过忽略了训练数据和测试数据中一些更细微的变化。与之相反，树模型完美预测了训练数据。由于我们没有限制树的复杂度，因此它记住了整个数据集。但是一旦输入超出了模型训练数据的范围（新的预期价格比历史最低价格更低），模型就只能持续预测最后一个已知数据点。树不能在训练数据的范围之外生成“新的”响应，所有基于树的模型都有这个缺点。（实际上，利用基于树的模型可以做出非常好的预测，比如试图预测价格会上涨还是下跌）。这个例子的目的并不是要说明对时间序列来说树是一个不好的模型，而是为了说明树在预测方式上的特殊性质。）</p><h1 id="优点缺点和参数">优点、缺点和参数</h1><p>控制决策树模型复杂度的参数是预剪枝参数，它在树完全展开之前停止树的构造。通常来说，选择一种预剪枝策略（设置<code>max_depth</code>、<code>max_leaf_nodes</code>或<code>min_samples_leaf</code>）足以防止过拟合。</p><p>决策树有两个优点：一是得到的模型很容易可视化，非专家也很容易理解（至少对于较小的树而言）；二是算法完全不受数据缩放的影响。由于每个特征被单独处理，而且数据的划分也不依赖于缩放，因此决策树算法不需要特征预处理，比如归一化或标准化。特别是特征的尺度完全不一样时或二元特征和连续特征同时存在时，决策树的效果很好。</p><p>决策树的主要缺点在于：即使做了预剪枝，它也经常会过拟合，泛化性能很差。因此，在大多数应用中，往往使用集成方法来代替单棵决策树。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Machine Learning with Python </tag>
            
            <tag> supervised </tag>
            
            <tag> regression </tag>
            
            <tag> classification </tag>
            
            <tag> decision tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>朴素贝叶斯分类器</title>
      <link href="/notes/introduction-to-ml-with-python/naive-bayes-classifiers/"/>
      <url>/notes/introduction-to-ml-with-python/naive-bayes-classifiers/</url>
      
        <content type="html"><![CDATA[<h1 id="朴素贝叶斯分类器">朴素贝叶斯分类器</h1><p>朴素贝叶斯分类器是与线性模型非常相似的一种分类器，但它的训练速度往往更快。这种高效率所付出的代价是，朴素贝叶斯模型的泛化能力要比线性分类器稍差。</p><p>朴素贝叶斯模型如此搞笑的原因在于，它通过单独查看每个特征来学习参数，并从每个特征中收集简单的类别统计数据。scikit-learn中实现了三种朴素贝叶斯分类器：GaussianNB、BernoulliNB和MultinomialNB。GaussianNB可应用于任意连续数据，而BernoulliNB假定输入数据为二分类数据，MultinomialNB假定输入数据为计数数据（即每个特征代表某个对象的整数计数，比如一个单词在句子里出现的次数）。BernoulliNB和MultinomialNB主要用于文本数据分类。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.naive_bayes.gaussiannb" target="_blank" rel="noopener"><code>class sklearn.naive_bayes.GaussianNB(priors=None, var_smoothing=1e-09)</code></a></p></blockquote><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.naive_bayes.bernoullinb" target="_blank" rel="noopener"><code>class sklearn.naive_bayes.BernoulliNB(alpha=1.0, binarize=0.0, fit_prior=True, class_prior=None)</code></a></p></blockquote><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.naive_bayes.multinomialnb" target="_blank" rel="noopener"><code>class sklearn.naive_bayes.MultinomialNB(alpha=1.0, fit_prior=True, class_prior=None)</code></a></p></blockquote><a id="more"></a><p>BernoulliNB分类器计算每个类别中每个特征不为0的元素个数。用一个例子来说明会很容易理解：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],  <span class="comment"># 第1、3行数据的类别为0</span></span><br><span class="line">              [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>],    <span class="comment"># 类别为0的数据，第1个特征的值为1的个数为0，第2个...</span></span><br><span class="line">              [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],  <span class="comment"># 第2、4行数据的类别为1</span></span><br><span class="line">              [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">y = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">counts = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> label <span class="keyword">in</span> np.unique(y):  <span class="comment"># 对每个类进行遍历</span></span><br><span class="line">    <span class="comment"># 计算每个特征中1的个数</span></span><br><span class="line">    counts[label] = X[y == label].sum(axis=<span class="number">0</span>)</span><br><span class="line">print(<span class="string">'Feature counts:\n&#123;&#125;'</span>.format(counts))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Feature counts:</span><br><span class="line">&#123;0: array([0, 1, 0, 2]), 1: array([2, 0, 2, 1])&#125;</span><br></pre></td></tr></table></figure><p>另外两种朴素贝叶斯分类器计算的统计数据类型略有不同。MultinomialNB计算每个类别中每个特征的平均值，而GaussianNB会保存每个类别中每个特征的平均值和标准差。</p><p><strong>要想做出预测，需要将数据点与每个类别的统计数据进行比较，并将最匹配的类别作为预测结果。有趣的是，MultinomialNB和BernoulliNB预测公式的形式都与线性模型完全相同。</strong>不幸的是，朴素贝叶斯模型<code>coef_</code>的含义与线性模型稍有不同，因为<code>coef_</code>不同于<span class="math inline">\(w\)</span>。</p><h1 id="优点缺点和参数">优点、缺点和参数</h1><p>MultinomialNB和BernoulliNB都只有一个参数alpha，用于控制模型复杂度。alpha的工作原理是，算法向数据中添加alpha这么多的虚拟数据点，这些点对所有特征都取正值。这可以将统计数据“平滑化”（smoothing）。<strong>alpha越大，平滑化越强，模型复杂度就越低。算法性能对alpha值的鲁棒性相对较好，也就是说，alpha值对模型性能并不重要。但调整这个参数通常都会使精度略有提高。</strong></p><p>GaussianNB主要用于高维数据，而另外两种朴素贝叶斯模型则广泛用于稀疏计数数据，比如文本。MultinomialNB的性能通常要优于BernoulliNB，特别是在包含很多非零特征的数据集（即大型文档）上。</p><p>朴素贝叶斯模型的许多优点和缺点都与线性模型相同。它的训练和预测速度都很快，训练过程也很容易理解。该模型对高维稀疏数据的效果很好，对参数的鲁棒性也相对较好。朴素贝叶斯模型是很好的基准模型，常用于非常大的数据集，在这些数据集上即使训练线性模型可能也要花费大量时间。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Machine Learning with Python </tag>
            
            <tag> supervised </tag>
            
            <tag> classification </tag>
            
            <tag> naive bayes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性模型</title>
      <link href="/notes/introduction-to-ml-with-python/linear-models/"/>
      <url>/notes/introduction-to-ml-with-python/linear-models/</url>
      
        <content type="html"><![CDATA[<p>线性模型利用输入特征的<strong>线性函数</strong>（linear function）进行预测。</p><h1 id="用于回归的线性模型">用于回归的线性模型</h1><p>对于回归问题，线性模型预测的一般公式如下：</p><p><span class="math display">\[\hat y=w[0]*x[0]+w[1]*x[1]+\dots+w[p]*x[p]+b\]</span></p><p><span class="math inline">\(x[0]\)</span> 到 <span class="math inline">\(x[p]\)</span> 表示单个数据点的特征，<span class="math inline">\(w\)</span> 和 <span class="math inline">\(b\)</span> 是学习模型的参数，<span class="math inline">\(\hat y\)</span> 是模型的预测结果。对于单一特征的数据集，公式如下：</p><p><span class="math display">\[\hat y=w[0]*x[0]+b\]</span></p><p>这就是高中数学里的直线方程。这里 <span class="math inline">\(w[0]\)</span> 是斜率，<span class="math inline">\(b\)</span> 是y轴偏移。对于有更多特征的数据集，<span class="math inline">\(w\)</span> 包含沿每个特征坐标轴的斜率。或者，你也可以将预测的响应值看作输入特征的加权求和，权重（可以取负值）由 <span class="math inline">\(w\)</span> 的元素给出。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_linear_regression_wave()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">w[0]: 0.393906  b: -0.031804</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/linear-regression-on-wave.png"></p><p>用于回归的线性模型可以表示为这样的回归模型：对单一特征的预测结果是一条直线，两个特征时是一个平面，在更高维度时是一个超平面。</p><p>如果将直线的预测结果与KNeighborsRegressor的预测结果进行比较，你会发现直线的预测能力非常受限。似乎数据的所有细节都丢失了。从某种意义上来说，这种说法是正确的假设目标 <span class="math inline">\(y\)</span> 是特征的线性组合，这是一个非常强的（也有点不现实的）假设。<strong>观察一维数据得出的观点有些片面。对于有多个特征的数据集而言，线性模型可以非常强大。特别地，如果特征数量大于训练数据点的数量，任何目标 <span class="math inline">\(y\)</span> 都可以（在训练集上）用线性函数完美拟合（线性代数知识）。</strong></p><p>有许多不同的线性回归模型。这些模型之间的区别在于如何从训练数据中学习参数 <span class="math inline">\(w\)</span> 和 <span class="math inline">\(b\)</span>，以及如何控制模型复杂度。</p><h1 id="线性回归又名普通最小二乘法">线性回归（又名普通最小二乘法）</h1><p>线性回归，或者普通最小二乘法（ordinary least qsquarees, OLS），是回归问题最简单也最经典的线性方法。线性回归寻找参数 <span class="math inline">\(w\)</span> 和 <span class="math inline">\(b\)</span>，使得对训练集的预测值与真实的回归目标值 <span class="math inline">\(y\)</span> 之间的<strong>均方误差</strong>最小。均方误差（mean squared error）是预测值与真实值之差的平方和除以样本数。<strong>线性回归没有参数，这是一个优点，但也因此无法控制模型的复杂度。</strong></p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.linear_model.linearregression" target="_blank" rel="noopener"><code>class sklearn.linear_model.LinearRegression(fit_intercept=True, normalize=False, copy_X=True, n_jobs=None)</code></a></p><p>Ordinary least squares Linear Regression.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line">X, y = mglearn.datasets.make_wave(n_samples=<span class="number">60</span>)</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">lr = LinearRegression().fit(X_train, y_train)</span><br><span class="line"><span class="comment"># scikit-learn总是将从训练数据中得出的值保存在以下划线结尾的属性中，将其与用户设置的参数区分开</span></span><br><span class="line">print(<span class="string">'lr.coef_: &#123;&#125;'</span>.format(lr.coef_))  <span class="comment"># “斜率”w被保存在coef_属性中</span></span><br><span class="line">print(<span class="string">'lr.intercept_: &#123;&#125;'</span>.format(lr.intercept_))  <span class="comment"># “截距”b被保存在intercept_属性中</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'Training set score: &#123;:.2f&#125;'</span>.format(lr.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Test set score: &#123;:.2f&#125;'</span>.format(lr.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lr.coef_: [0.39390555]</span><br><span class="line">lr.intercept_: -0.031804343026759746</span><br><span class="line">Training set score: 0.67</span><br><span class="line">Test set score: 0.66</span><br></pre></td></tr></table></figure><p><span class="math inline">\(R^2\)</span> 约为 0.66，这个结果不是很好，但我们可以看到，训练集和测试集上的分数非常接近。这说明可能存在欠拟合，而不是过拟合（过拟合的特征是在训练集上的分数非常高，而在测试集上的分数非常低）。对于这个一维数据集来说，过拟合的风险很小，因为模型非常简单（或受限）。然而，对于更高维的数据集（即有大量特征的数据集），线性模型将变得更加强大，过拟合的可能性也会变大。</p><p>我们来看一下 LinearRegression 在更复杂的数据集上的表现，比如波士顿房价数据集。这个数据集有 506 个样本和 105 个导出特征。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X, y = mglearn.datasets.load_extended_boston()</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=<span class="number">0</span>)</span><br><span class="line">lr = LinearRegression().fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Train set score: &#123;:.2f&#125;'</span>.format(lr.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Test set score: &#123;:.2f&#125;'</span>.format(lr.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Train set score: 0.95</span><br><span class="line">Test set score: 0.61</span><br></pre></td></tr></table></figure><p>训练集和测试集之间的性能差异是过拟合的明显标志，因此我们应该试图找到一个可以控制复杂度的模型。标准线性回归最常用的替代方法之一就是<strong>岭回归</strong>（ridge regression）。</p><h1 id="岭回归">岭回归</h1><p>岭回归也是一种用于回归的线性模型，因此它的预测公式与普通最小二乘法相同。<strong>但在岭回归中，对系数 <span class="math inline">\(w\)</span> 的选择不仅要在训练数据上得到好的预测结果，而且还要拟合附加约束。我们还希望系数尽量小。</strong>换句话说，<span class="math inline">\(w\)</span> 的所有元素都应接近于 0。直观上来看，这意味着每个特征对输出的影响应尽可能小（即斜率很小），同时仍给出很好的预测结果。这种约束是所谓<strong>正则化</strong>（regularization）的一个例子。正则化是指对模型做显式约束，以避免过拟合。岭回归用到的这种被称为<strong>L2正则化</strong>。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.linear_model.ridge#sklearn.linear_model.Ridge" target="_blank" rel="noopener"><code>sklearn.linear_model.Ridge class sklearn.linear_model.Ridge(alpha=1.0, fit_intercept=True, normalize=False, copy_X=True, max_iter=None, tol=0.001, solver=’auto’, random_state=None)</code></a></p><p>Linear least squares with l2 regularization.</p><p>Minimizes the objective function:</p><p><span class="math inline">\(||y - Xw||^2_2 + alpha * ||w||^2_2\)</span>（从数学的观点来看，Ridge 惩罚了系数的 L2 范数或 <span class="math inline">\(w\)</span> 的欧式长度 <span class="math inline">\(||w||^2_2\)</span>）</p><p>This model solves a regression model where the loss function is the linear least squares function and regularization is given by the l2-norm.</p></blockquote><p>岭回归在 linear_model.Ridge 中实现。来看一下它对扩展的波士顿房价数据集的效果如何：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Ridge</span><br><span class="line"></span><br><span class="line">ridge = Ridge().fit(X_train, y_train)</span><br><span class="line">print(<span class="string">'Train set score: &#123;:.2f&#125;'</span>.format(ridge.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Test set score: &#123;:.2f&#125;'</span>.format(ridge.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Train set score: 0.89</span><br><span class="line">Test set score: 0.75</span><br></pre></td></tr></table></figure><p>Ridge 在训练集上的分数要低于 LinearRegression，但在测试集上的分数更高。这和我们的预期一致。线性回归对数据存在过拟合。Ridge 是一种约束更强的模型，所以更不容易过拟合。复杂度更小的模型意味着在训练集上的性能更差，但泛化性能更好。由于我们只对泛化性能感兴趣，所以应该选择 Ridge 模型而不是 LinearRegression 模型。</p><p>Ridge 模型在模型的简单性（系数都接近于 0）与训练集性能之间做出权衡。简单性和训练集性能二者对于模型的重要程度可以由用户通过设置 alpha 参数来指定。alpha 的最佳设定值取决于用到的具体数据集。增大 alpha 会使得系数更加趋向于 0，从而降低训练集性能，但可能会提高泛化性能。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ridge10 = Ridge(alpha=<span class="number">10</span>).fit(X_train, y_train)</span><br><span class="line">print(<span class="string">'Train set score: &#123;:.2f&#125;'</span>.format(ridge10.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Test set score: &#123;:.2f&#125;'</span>.format(ridge10.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Train set score: 0.79</span><br><span class="line">Test set score: 0.64</span><br></pre></td></tr></table></figure><p>减小 alpha 可以让系数受到的限制更小。对于非常小的 alpha 值，系数几乎没有受到限制，我们得到一个与 LinearRegression 类似的模型：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ridge01 = Ridge(alpha=<span class="number">0.1</span>).fit(X_train, y_train)</span><br><span class="line">print(<span class="string">'Train set score: &#123;:.2f&#125;'</span>.format(ridge01.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Test set score: &#123;:.2f&#125;'</span>.format(ridge01.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Train set score: 0.93</span><br><span class="line">Test set score: 0.77</span><br></pre></td></tr></table></figure><p>这里 alpha=0.1 似乎效果不错。我们可以尝试进一步减小 alpha 以提高泛化性能。</p><p>我们还可以查看 alpha 取不同值时模型的 <code>coef_</code> 属性，从而更加定性地理解 alpha 参数是如何改变模型的。更大的 alpha 表示约束更强的模型，所以大的 alpha 对应的 <code>coef_</code> 元素比小的 alpha 对应的 <code>coef_</code> 元素要小。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(ridge.coef_, <span class="string">'s'</span>, label=<span class="string">'Ridge alpha=1'</span>)</span><br><span class="line">plt.plot(ridge10.coef_, <span class="string">'^'</span>, label=<span class="string">'Ridge alpha=10'</span>)</span><br><span class="line">plt.plot(ridge01.coef_, <span class="string">'v'</span>, label=<span class="string">'Ridge alpha=0.1'</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(lr.coef_, <span class="string">'o'</span>, label=<span class="string">'LinearRegression'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Coefficient index'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Coefficient magnitude'</span>)</span><br><span class="line">plt.hlines(<span class="number">0</span>, <span class="number">0</span>, len(lr.coef_))</span><br><span class="line">plt.ylim(<span class="number">-25</span>, <span class="number">25</span>)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/coef_-of-ridge-and-linear-regression.png"></p><p>x 轴对应 <code>coef_</code> 的元素，y 轴对应元素的具体数值。对于 alpha=10，系数大多在 -3 和 3 之间。对于 alpha=1 的 Ridge 模型，系数要稍大一点。对于 alpha=0.1，点的范围更大。对于没有做正则化的线性回归（即 alpha=0），点的范围很大，许多点都超出了图像的范围。</p><p>还有一种方法可以用来理解正则化的影响，就是固定 alpha 值，但改变训练数据的量。我们对波士顿房价数据集做二次抽样，并在数据量逐渐增加的子数据集上分别对 LinearRegression 和 Ridge(alpha=1) 两个模型进行评估（将模型性能作为数据大小的函数进行绘图，这样的图像叫做<strong>学习曲线</strong>）。</p><p><img src="/uploads/image/introduction-to-ml-with-python/learning-curve-of-ridge-and-linear-regression.png"></p><p>无论是岭回归还是线性回归，所有数据集大小对应的训练分数都要高于测试分数。由于岭回归是正则化的，因此它的训练分数要整体低于线性回归的训练分数。但岭回归的测试分数要更高，特别是对较小的子数据集。如果少于 400 个数据点，线性回归学不到任何内容。随着模型可用数据越来越多，两个模型的性能都在提升，最终线性回归的性能追上了岭回归。这里要记住的是，<strong>如果有足够多的训练数据，正则化变得不那么重要，并且岭回归和线性回归将具有相同的性能</strong>（在这个例子中，二者相同恰好发生在整个数据集的情况下，这只是一个巧合）。还有一个有趣之处，就是线性回归的训练性能在下降。如果添加更多数据，模型将更加难以过拟合或记住所有的数据。</p><h1 id="lasso">lasso</h1><p>除了 Ridge，还有一种正则化的线性回归是 Lasso。与岭回归相同，使用 lasso 也是约束系数使其接近于 0，但用到的方法不同，叫做 L1 正则化。L1 正则化的结果是，使用 lasso 时某些系数<strong>刚好为 0</strong>。这说明某些特征被模型完全忽略。这可以看作是一种自动化的特征选择。某些系数刚好为 0，这样的模型更容易解释，也可以呈现模型最重要的特征。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.linear_model.lasso" target="_blank" rel="noopener"><code>class sklearn.linear_model.Lasso(alpha=1.0, fit_intercept=True, normalize=False, precompute=False, copy_X=True, max_iter=1000, tol=0.0001, warm_start=False, positive=False, random_state=None, selection=’cyclic’)</code></a></p><p>Linear Model trained with L1 prior as regularizer (aka the Lasso)</p><p>The optimization objective for Lasso is:</p><p><span class="math inline">\((1 / (2 * n\_samples)) * ||y - Xw||^2_2 + alpha * ||w||_1\)</span>（lasso 惩罚系数向量的 L1 范数或系数的绝对值之和 <span class="math inline">\(||w||_1\)</span>）</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Lasso</span><br><span class="line"></span><br><span class="line">lasso = Lasso().fit(X_train, y_train)</span><br><span class="line">print(<span class="string">'Training set score: &#123;:.2f&#125;'</span>.format(lasso.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Test set score: &#123;:.2f&#125;'</span>.format(lasso.score(X_test, y_test)))</span><br><span class="line">print(<span class="string">'Number of features used: &#123;&#125;'</span>.format(np.sum(lasso.coef_ != <span class="number">0</span>)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Training set score: 0.29</span><br><span class="line">Test set score: 0.21</span><br><span class="line">Number of features used: 4</span><br></pre></td></tr></table></figure><p>Lasso 在训练集与测试集上的表现都很差。这表示存在欠拟合，我们发现模型只用到了 105 个特征中的 4 个。与 Ridge 类似，Lasso 也有一个正则化参数 alpha，可以控制系数趋向于0的强度。<strong>为了降低欠拟合，我们尝试减小 alpha。这么做的同时，我们还需要增加 <code>max_iter</code> 的值（运行迭代的最大次数）</strong>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lasso001 = Lasso(alpha=<span class="number">0.01</span>, max_iter=<span class="number">100000</span>).fit(X_train, y_train)</span><br><span class="line">print(<span class="string">'Training set score: &#123;:.2f&#125;'</span>.format(lasso001.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Test set score: &#123;:.2f&#125;'</span>.format(lasso001.score(X_test, y_test)))</span><br><span class="line">print(<span class="string">'Number of features used: &#123;&#125;'</span>.format(np.sum(lasso001.coef_ != <span class="number">0</span>)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Training set score: 0.90</span><br><span class="line">Test set score: 0.77</span><br><span class="line">Number of features used: 33</span><br></pre></td></tr></table></figure><p>alpha 的值变小，我们可以拟合一个更复杂的模型，在训练集和测试集上的表现也更好。模型性能比使用 Ridge 时略好一点，而且我们只用到了 105 个特征中的 33 个。这样模型可能更容易理解。</p><p>但如果把 alpha 设得太小，那么就会消除正则化的效果，并出现过拟合，得到与 LinearRegression 类似的结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lasso00001 = Lasso(alpha=<span class="number">0.0001</span>, max_iter=<span class="number">100000</span>).fit(X_train, y_train)</span><br><span class="line">print(<span class="string">'Training set score: &#123;:.2f&#125;'</span>.format(lasso00001.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Test set score: &#123;:.2f&#125;'</span>.format(lasso00001.score(X_test, y_test)))</span><br><span class="line">print(<span class="string">'Number of features used: &#123;&#125;'</span>.format(np.sum(lasso00001.coef_ != <span class="number">0</span>)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Training set score: 0.95</span><br><span class="line">Test set score: 0.64</span><br><span class="line">Number of features used: 96</span><br></pre></td></tr></table></figure><p>再次对不同模型的系数进行作图。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(lasso.coef_, <span class="string">'s'</span>, label=<span class="string">'Lasso alpha=1'</span>)</span><br><span class="line">plt.plot(lasso001.coef_, <span class="string">'^'</span>, label=<span class="string">'Lasso alpha=0.01'</span>)</span><br><span class="line">plt.plot(lasso00001.coef_, <span class="string">'v'</span>, label=<span class="string">'Lasso alpha=0.0001'</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(ridge01.coef_, <span class="string">'o'</span>, label=<span class="string">'Ridge alpha=0.1'</span>)</span><br><span class="line">plt.legend(ncol=<span class="number">2</span>, loc=(<span class="number">0</span>, <span class="number">1.05</span>))</span><br><span class="line">plt.ylim(<span class="number">-25</span>, <span class="number">25</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Coefficient index'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Coefficient magnitude'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/learning-curve-of-lasso-and-ridge.png"></p><p>在 alpha=1 时，我们发现不仅大部分系数都是 0，而且其他系数也很小。将 alpha 减小至 0.01，大部分特征等于 0。alpha=0.0001 时，我们得到正则化很弱的模型，大部分系数都不为 0，并且还很大。图中用圆形表示 Ridge 的最佳结果。alpha=0.1 的 Ridge 模型的预测性能与 alpha=0.01 的 Lasso 模型类似，但 Ridge 模型的所有系数都不为 0。</p><p>在实践中，在两个模型中一般首选岭回归。但如果特征很多，你认为只有其中几个是重要的，那么选择 Lasso 可能更好。同样，如果你想要一个容易解释的模型，Lasso 可以给出更容易理解的模型，因为他只选择了一部分输入特征。scikit-learn 还提供了 ElasticNet 类，结合了 Lasso 和 Ridge 的惩罚项。在实践中，这种结合的效果最好，不过代价是要调节两个参数：一个用于 L1 正则化，一个用于 L2 正则化。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.linear_model.elasticnet" target="_blank" rel="noopener"><code>class sklearn.linear_model.ElasticNet(alpha=1.0, l1_ratio=0.5, fit_intercept=True, normalize=False, precompute=False, max_iter=1000, copy_X=True, tol=0.0001, warm_start=False, positive=False, random_state=None, selection=’cyclic’)</code></a></p><p>Linear regression with combined L1 and L2 priors as regularizer.</p><p>Minimizes the objective function:</p><p><span class="math display">\[1 / (2 * n\_samples) * ||y - Xw||^2_2+ alpha * l1\_ratio * ||w||_1+ 0.5 * alpha * (1 - l1\_ratio) * ||w||^2_2\]</span></p><p>If you are interested in controlling the L1 and L2 penalty separately, keep in mind that this is equivalent to:</p><p><code>a * L1 + b * L2</code></p><p>where:</p><p><code>alpha = a + b and l1_ratio = a / (a + b)</code></p></blockquote><h1 id="用于分类的线性模型">用于分类的线性模型</h1><p>线性模型也广泛应用于分类问题。我们首先来看二分类。这时可以利用下面的公式进行预测：</p><p><span class="math display">\[\hat y=w[0]*x[0]+w[1]*x[1]+\dots+w[p]*x[p]+b&gt;0\]</span></p><p>这个公式看起来与线性回归的公式非常类似，但我们没有返回特征的加权求和，而是为预测设置了阈值 0。如果函数值小于 0，我们就预测类别 -1；如果函数值大于 0，我们就预测类别 +1.对于所有用于分类的线性模型，这个预测规则都是通用的。同样，有很多种不同的方法来找出系数 <span class="math inline">\(w\)</span> 和截距 <span class="math inline">\(b\)</span>。</p><p>对于用于回归的线性模型，输出 <span class="math inline">\(\hat y\)</span> 是特征的线性函数，是直线、平面或超平面。对于用于分类的线性模型，<strong>决策边界</strong>是输入的线性函数。换句话说，（二元）线性分类器是利用直线、平面或超平面来分开两个类别的分类器。</p><p>学习线性模型有很多种算法。这些算法的区别在于以下两点：</p><ul><li>系数和截距的特定组合对训练数据拟合好坏的度量方法；</li><li>是否使用正则化，以及使用哪种正则化方法。</li></ul><p>不同的算法使用不同的方法来度量“对训练集拟合好坏”。由于数学上的技术原因，不可能调节 <span class="math inline">\(w\)</span> 和 <span class="math inline">\(b\)</span> 是的算法产生的误分类数量最少。对于我们的目的，以及对于许多应用而言，上面第一点（成为<strong>损失函数</strong>）的选择并不重要。</p><p>最常见的两种线性分类算法是 Logistic 回归（logistic regression，虽然名字中含有回归，但它是一种分类算法）和线性支持向量机（linear support vector machine，线性 SVM），前者在 <code>linear_model.LogisticRegression</code> 中实现，后者在 <code>svm.LinearSVC</code>（SVC代表支持向量分类器）中实现。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.linear_model.logisticregression" target="_blank" rel="noopener"><code>class sklearn.linear_model.LogisticRegression(penalty=’l2’, dual=False, tol=0.0001, C=1.0, fit_intercept=True, intercept_scaling=1, class_weight=None, random_state=None, solver=’warn’, max_iter=100, multi_class=’warn’, verbose=0, warm_start=False, n_jobs=None)</code></a></p></blockquote><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.svm.linearsvc" target="_blank" rel="noopener"><code>class sklearn.svm.LinearSVC(penalty=’l2’, loss=’squared_hinge’, dual=True, tol=0.0001, C=1.0, multi_class=’ovr’, fit_intercept=True, intercept_scaling=1, class_weight=None, verbose=0, random_state=None, max_iter=1000)</code></a></p></blockquote><p>我们可以将 LogisticRegression 和 LinearSVC 模型应用到 forge 数据集上，并将线性模型找到的决策边界可视化。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> LinearSVC</span><br><span class="line"></span><br><span class="line">X, y = mglearn.datasets.make_forge()</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">3</span>))</span><br><span class="line"><span class="keyword">for</span> model, ax <span class="keyword">in</span> zip([LinearSVC(), LogisticRegression()], axes):</span><br><span class="line">    clf = model.fit(X, y)</span><br><span class="line">    mglearn.plots.plot_2d_separator(clf, X, fill=<span class="literal">False</span>, eps=<span class="number">0.5</span>, ax=ax, alpha=<span class="number">.7</span>)</span><br><span class="line">    mglearn.discrete_scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], y, ax=ax)</span><br><span class="line">    ax.set_title(<span class="string">'&#123;&#125;'</span>.format(clf.__class__.__name__))</span><br><span class="line">    ax.set_xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">'Feature 1'</span>)</span><br><span class="line">axes[<span class="number">0</span>].legend()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-of-logistic-regression-and-linear-svc.png"></p><p>两个模型得到了相似的决策边界。注意，两个模型中都有两个点的分类是错误的。两个模型都默认使用 L2 正则化，就像 Ridge 对回归所做的那样。</p><p>对于 LogisticRegression 和 LinearSVC，决定正则化强度的权衡参数叫作 C。C 值越大，对应的正则化越弱。换句话说，如果 C 值较大，那么 LogisticRegression 和 LinearSVC 将尽可能将训练集拟合到最好，而如果 C 值较小，那么模型更强调使系数向量 <span class="math inline">\(w\)</span> 接近于0。</p><p>参数 C 的作用还有另一个有趣之处。较小的C值可以让算法尽量适应“大多数”数据点，而较大的 C 值更强调每个数据点都分类正确的重要性。下面是使用 LinearSVC 的图示：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_linear_svc_regularization()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-of-linear-svc.png"></p><p>在左侧的图中，C 值很小，对应强正则化。大部分属于 0 的点都位于底部，大部分属于类别 1 的点都位于顶部。强正则化的模型会选择一条相对水平的线，有两个点分类错误。在中间的图中，C 值稍大，模型更关注两个分类错误的样本，是决策边界的斜率变大。最后，在右侧的图中，模型的 C 值非常大，使得决策边界的斜率也很大，现在这个模型对类别 0 中的所有点的分类都是正确的。类别 1 中仍有 1 个点分类错误，这是因为对这个数据集来说，不可能用一条直线将所有点都分类正确。右侧图中的模型尽量使所有点的分类都正确，但可能无法掌握类别的整体分布。换句话说，这个模型很可能过拟合。</p><p>与回归的情况类似，用于分类的线性模型在低维空间中看起来非常受限，决策边界只能是直线或平面。同样，在高维空间中，用于分类的线性模型变得非常强大，当考虑更多的特征时，避免过拟合变得越来越重要。</p><p>我们在乳腺癌数据集上详细分析 LogisticRegression：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_breast_cancer</span><br><span class="line"></span><br><span class="line">cancer = load_breast_cancer()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(cancer.data,</span><br><span class="line">    cancer.target, stratify=cancer.target, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">logreg = LogisticRegression().fit(X_train, y_train)</span><br><span class="line">print(<span class="string">'Training set score: &#123;:.3f&#125;'</span>.format(logreg.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Test set score: &#123;:.3f&#125;'</span>.format(logreg.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Training set score: 0.955</span><br><span class="line">Test set score: 0.958</span><br></pre></td></tr></table></figure><p>C=1 的默认值给出了相当好的性能，在训练集和测试集上都达到 95% 的精度。<strong>但由于训练集和测试集的性能非常接近，所以模型很可能是欠拟合的。</strong>我们尝试增大 C 来拟合一个更灵活的模型：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logreg100 = LogisticRegression(C=<span class="number">100</span>).fit(X_train, y_train)</span><br><span class="line">print(<span class="string">'Training set score: &#123;:.3f&#125;'</span>.format(logreg100.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Test set score: &#123;:.3f&#125;'</span>.format(logreg100.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Training set score: 0.967</span><br><span class="line">Test set score: 0.965</span><br></pre></td></tr></table></figure><p>使用 C=100 可以得到更高的训练集精度，也得到了稍高的测试集精度，这也证实了我们的直觉，即更复杂的模型应该性能更好。</p><p>我们还可以研究使用正则化强度更强的模型时会发生什么。设置 C=0.01。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logreg001 = LogisticRegression(C=<span class="number">0.01</span>).fit(X_train, y_train)</span><br><span class="line">print(<span class="string">'Training set score: &#123;:.3f&#125;'</span>.format(logreg001.score(X_train, y_train)))</span><br><span class="line">print(<span class="string">'Test set score: &#123;:.3f&#125;'</span>.format(logreg001.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Training set score: 0.934</span><br><span class="line">Test set score: 0.930</span><br></pre></td></tr></table></figure><p>正如我们所料，在将已经欠拟合的模型（C=1）继续向左移动，训练集和测试集的精度都比采用默认参数时更小。</p><p>最后，来看一下正则化参数 C 取三个不同的值时模型学到的系数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(logreg.coef_.T, <span class="string">'o'</span>, label=<span class="string">'C=1'</span>)</span><br><span class="line">plt.plot(logreg100.coef_.T, <span class="string">'^'</span>, label=<span class="string">'C=100'</span>)</span><br><span class="line">plt.plot(logreg001.coef_.T, <span class="string">'v'</span>, label=<span class="string">'C=0.01'</span>)</span><br><span class="line">plt.xticks(range(cancer.data.shape[<span class="number">1</span>]), cancer.feature_names, rotation=<span class="number">90</span>)</span><br><span class="line">plt.hlines(<span class="number">0</span>, <span class="number">0</span>, cancer.data.shape[<span class="number">1</span>])</span><br><span class="line">plt.ylim(<span class="number">-5</span>, <span class="number">5</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Coefficient index'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Coefficient magnitude'</span>)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/learning-curve-of-logistic-regression-l2.png"></p><p>由于 LogisticRegression 默认应用 L2 正则化，所以其结果与 Ridge 的结果类似。更强的正则化使得系数更趋向于 0，但系数永远不会正好等于 0。</p><p>如果想要一个可解释性更强的模型，使用 L1 正则化可能更好，因为它约束模型只是用少数几个特征。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> C, marker <span class="keyword">in</span> zip([<span class="number">0.001</span>, <span class="number">1</span>, <span class="number">100</span>], [<span class="string">'o'</span>, <span class="string">'^'</span>, <span class="string">'v'</span>]):</span><br><span class="line">    lr_l1 = LogisticRegression(C=C, penalty=<span class="string">'l1'</span>).fit(X_train, y_train)</span><br><span class="line">    print(<span class="string">'Training accuracy of l1 logreg with C=&#123;:.3f&#125;: &#123;:.2f&#125;'</span>.format(</span><br><span class="line">        C, lr_l1.score(X_train, y_train)))</span><br><span class="line">    print(<span class="string">'Test accuracy of l1 logreg with C=&#123;:.3f&#125;: &#123;:.2f&#125;'</span>.format(</span><br><span class="line">        C, lr_l1.score(X_test, y_test)))</span><br><span class="line"></span><br><span class="line">    plt.plot(lr_l1.coef_.T, marker, label=<span class="string">'C=&#123;:.3f&#125;'</span>.format(C))</span><br><span class="line"></span><br><span class="line">plt.xticks(range(cancer.data.shape[<span class="number">1</span>]), cancer.feature_names, rotation=<span class="number">90</span>)</span><br><span class="line">plt.hlines(<span class="number">0</span>, <span class="number">0</span>, cancer.data.shape[<span class="number">1</span>])</span><br><span class="line">plt.xlabel(<span class="string">'Coefficient index'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Coefficient magnitude'</span>)</span><br><span class="line">plt.ylim(<span class="number">-5</span>, <span class="number">5</span>)</span><br><span class="line">plt.legend(loc=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Training accuracy of l1 logreg with C=0.001: 0.91</span><br><span class="line">Test accuracy of l1 logreg with C=0.001: 0.92</span><br><span class="line">Training accuracy of l1 logreg with C=1.000: 0.96</span><br><span class="line">Test accuracy of l1 logreg with C=1.000: 0.96</span><br><span class="line">Training accuracy of l1 logreg with C=100.000: 0.99</span><br><span class="line">Test accuracy of l1 logreg with C=100.000: 0.98</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/learning-curve-of-logistic-regression-l1.png"></p><p>如你所见，使用二分类的线性模型与用于回归的线性模型有许多相似之处。与用于回归的线性模型一样，模型的主要差别在于 penalty 参数，这个参数会影响正则化，也会影响模型是使用所有可用特征还是只选择特征的一个子集。</p><h1 id="用于多分类的线性模型">用于多分类的线性模型</h1><p>许多线性分类模型只适用于二分类问题，不能轻易推广到多类别问题（除了 Logistic 回归）。将二分类算法推广到多分类算法的一种常见方法是”<strong>一对其余</strong>“（one-vs.-rest）方法。在“一对其余”方法中，对每个类别都学习一个二分类模型，将这个类别与所有其他类别尽量分开，这样就生成了与类别个数一样多的二分类模型。在测试点上运行所有二分类器来进行预测。在对应类别上分数最高的分类器“胜出”，将增额类别标签返回作为预测结果。</p><p>每个类别都对应一个二类分类器，这样每个类被也都有一个系数 <span class="math inline">\(w\)</span> 向量和一个截距 <span class="math inline">\(b\)</span>。下面给出的是分类置信方程，其结果中最大值对应的类别即为预测的类别标签：</p><p><span class="math display">\[w[0]*x[0]+w[1]*x[1]+\dots+w[p]*x[p]+b\]</span></p><p>多分类 Logistic 回归背后的数学与“一对其余”方法稍有不同，但它也是对每个类别都有一个系数向量和一个截距，也使用了相同的预测方法。</p><p>我们将“一对其余”方法应用在一个简单的三分类数据集上。我们用到了一个二维数据集，每个列别德数据都是从一个高斯分布中采样得出的。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.datasets.make_blobs#sklearn.datasets.make_blobs" target="_blank" rel="noopener"><code>sklearn.datasets.make_blobs(n_samples=100, n_features=2, centers=None, cluster_std=1.0, center_box=(-10.0, 10.0), shuffle=True, random_state=None)</code></a></p><p>Generate isotropic Gaussian blobs for clustering.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line"></span><br><span class="line">X, y = make_blobs(random_state=<span class="number">42</span>)</span><br><span class="line">mglearn.discrete_scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], y)</span><br><span class="line">plt.xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature 1'</span>)</span><br><span class="line">plt.legend([<span class="string">'Class 0'</span>, <span class="string">'Class 1'</span>, <span class="string">'Class 2'</span>])</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/datasets-blobs.png"></p><p>在这个数据集上训练一个 LinearSVC 分类器：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">linear_svm = LinearSVC().fit(X, y)</span><br><span class="line">print(<span class="string">'Coefficient shape: '</span>, linear_svm.coef_.shape)</span><br><span class="line">print(<span class="string">'Intercept shape: '</span>, linear_svm.intercept_.shape)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Coefficient shape:  (3, 2)  # 每行包括三个类别之一的系数向量，数据有两个特征，因此系数有两个元素</span><br><span class="line">Intercept shape:  (3,)  # 每个类别的截距</span><br></pre></td></tr></table></figure><p>将这 3 个二类分类器给出的直线可视化：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.discrete_scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], y)</span><br><span class="line">line = np.linspace(<span class="number">-15</span>, <span class="number">15</span>)</span><br><span class="line"><span class="keyword">for</span> coef, intercept, color <span class="keyword">in</span> zip(linear_svm.coef_, linear_svm.intercept_,</span><br><span class="line">                                  [<span class="string">'b'</span>, <span class="string">'r'</span>, <span class="string">'g'</span>]):</span><br><span class="line">    <span class="comment"># model: y = coef[0] * x[0] + coef[1] * x[1] + intercept</span></span><br><span class="line">    <span class="comment"># boundary: 0 = coef[0] * x[0] + coef[1] * x[1] + intercept</span></span><br><span class="line">    <span class="comment"># 边界上的x[1] = -(coef[0] * x[0] + intercept) / coef[1]</span></span><br><span class="line">    plt.plot(line, -(line * coef[<span class="number">0</span>] + intercept) / coef[<span class="number">1</span>], c=color)</span><br><span class="line">plt.ylim(<span class="number">-10</span>, <span class="number">15</span>)</span><br><span class="line">plt.xlim(<span class="number">-10</span>, <span class="number">8</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature 1'</span>)</span><br><span class="line">plt.legend([<span class="string">'Class 0'</span>, <span class="string">'Class 1'</span>, <span class="string">'Class 2'</span>, <span class="string">'Line class 0'</span>, <span class="string">'Line class 1'</span>,</span><br><span class="line">            <span class="string">'Line class 2'</span>], loc=(<span class="number">1.01</span>, <span class="number">0.3</span>))</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-one-vs-rest.png"></p><p>图像中间的三角形区域属于哪一个类别呢，3 个二类分类器都将这一区域内的点划为“其余”。这里的点应该划归到哪一个类别呢？答案是分类方程结果最大的那个类别，即最接近的那条线对应的类别。下面的例子给出了二维空间中所有区域的预测结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_2d_classification(linear_svm, X, fill=<span class="literal">True</span>, alpha=<span class="number">.7</span>)</span><br><span class="line"></span><br><span class="line">mglearn.discrete_scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], y)</span><br><span class="line">line = np.linspace(<span class="number">-15</span>, <span class="number">15</span>)</span><br><span class="line"><span class="keyword">for</span> coef, intercept, color <span class="keyword">in</span> zip(linear_svm.coef_, linear_svm.intercept_,</span><br><span class="line">                                  [<span class="string">'b'</span>, <span class="string">'r'</span>, <span class="string">'g'</span>]):</span><br><span class="line">    plt.plot(line, -(line * coef[<span class="number">0</span>] + intercept) / coef[<span class="number">1</span>], c=color)</span><br><span class="line">plt.ylim(<span class="number">-10</span>, <span class="number">15</span>)</span><br><span class="line">plt.xlim(<span class="number">-10</span>, <span class="number">8</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Feature 1'</span>)</span><br><span class="line">plt.legend([<span class="string">'Class 0'</span>, <span class="string">'Class 1'</span>, <span class="string">'Class 2'</span>, <span class="string">'Line class 0'</span>, <span class="string">'Line class 1'</span>,</span><br><span class="line">            <span class="string">'Line class 2'</span>], loc=(<span class="number">1.01</span>, <span class="number">0.3</span>))</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-one-vs-rest-fill.png"></p><h1 id="优点缺点和参数">优点、缺点和参数</h1><p>线性模型的主要参数是正则化参数，在回归模型中叫作 alpha，在 LinearSVC 和 LogisticRegression 中叫作 C。<strong>alpha 值较大或 C 值较小，说明模型比较简单。特别是对于回归模型而言，调节这些参数非常重要。通常在对数尺度上对 C 和 alpha 进行搜索。你还需要确定的是用 L1 正则化还是 L2 正则化。</strong>如果你假定只有几个特征是真正重要的，那么你应该用 L1 正则化，否则应默认使用 L2 正则化。如果模型的可解释性很重要的话，使用 L1 也会有帮助。由于 L1 只用到几个特征，所以更容易解释哪些特征对模型是重要的，以及这些特征的作用。</p><p>线性模型的训练速度非常快，预测速度也很快。这种模型可以推广到非常大的数据集，对稀疏数据也很有效。如果你的数据包含数十万甚至上百万个样本，你可能需要研究如何使用 LogisticRegression 和 Ridge 模型的 solver='sag' 选项，在处理大型数据时，这一选项比默认值要更快。其他选项还有 SGDClassifier 类和 SGDRegression 类，它们对本节介绍的线性模型实现了可扩展性更强的版本。</p><p>线性模型的另一个优点在于，利用我们之前见过的用于回归和分类的公式，理解如何进行预测是相对比较容易的。不幸的是，往往并不完全清楚系数为什么是这样的。如果你的数据集中包含高度相关的特征，这一问题尤为突出。在这种情况下，可能很难对系数做出解释。</p><p><strong>如果特征数量大于样本数量，线性模型的表现通常都很好。</strong>他也常用于非常大的数据集，只是因为训练其他模型并不可行。但在更低维的空间中，其他模型的泛化性能可能更好。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Machine Learning with Python </tag>
            
            <tag> supervised </tag>
            
            <tag> regression </tag>
            
            <tag> classification </tag>
            
            <tag> ridge </tag>
            
            <tag> lasso </tag>
            
            <tag> linear model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k近邻</title>
      <link href="/notes/introduction-to-ml-with-python/k-nearest-neighbors/"/>
      <url>/notes/introduction-to-ml-with-python/k-nearest-neighbors/</url>
      
        <content type="html"><![CDATA[<p>k-NN算法可以说是最简单的机器学习算法。构建的模型只需要保存训练数据集即可。想要对新数据点做出预测，算法会在训练数据集中找到最近的数据点，也就是它的“最近邻”。</p><h1 id="k近邻分类">k近邻分类</h1><p>k-NN算法最简单的版本只考虑一个最近邻，也就是与我们想要预测的数据点最近的训练数据点。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_knn_classification(n_neighbors=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>单一最近邻模型对forge数据集的预测：</p><p><img src="/uploads/image/introduction-to-ml-with-python/1-nn-classfication-on-forge.png"></p><a id="more"></a><p>除了考虑最近邻，还可以考虑任意个（k个）邻居。这也是k近邻算法名字的来历。在考虑多余一个邻居的情况时，我们用“投票法”（voting）来指定标签。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_knn_classification(n_neighbors=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/3-nn-classfication-on-forge.png"></p><p>现在看一下如何通过scikit-learn来应用k近邻算法。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.neighbors.kneighborsclassifier" target="_blank" rel="noopener"><code>class sklearn.neighbors.KNeighborsClassifier(n_neighbors=5, weights=’uniform’, algorithm=’auto’, leaf_size=30, p=2, metric=’minkowski’, metric_params=None, n_jobs=None, **kwargs)</code></a></p><p>Classifier implementing the k-nearest neighbors vote.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X, y = mglearn.datasets.make_forge()  <span class="comment"># 原始数据集</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=<span class="number">0</span>)  <span class="comment"># 分成训练集和测试集</span></span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line">clf = KNeighborsClassifier(n_neighbors=<span class="number">3</span>)  <span class="comment"># 初始化分类器</span></span><br><span class="line">clf.fit(X_train, y_train)  <span class="comment"># 用训练集对其拟合</span></span><br><span class="line">clf.score(X_test, y_test)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.8571428571428571  # 模型的精度约为86%</span><br></pre></td></tr></table></figure><h1 id="分析kneighborsclassifier">分析KNeighborsClassifier</h1><p>对于二维数据集，我们可以在平面上画出所有可能的测试点的预测结果。根据平面中每个点所属的类别对平面进行着色。这样就可以查看<strong>决策边界</strong>（decision boundary）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, axes = plt.subplots(<span class="number">1</span>, <span class="number">3</span>, figsize=(<span class="number">10</span>, <span class="number">3</span>))</span><br><span class="line"><span class="keyword">for</span> n_neighbors, ax <span class="keyword">in</span> zip([<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>], axes):</span><br><span class="line">    clf = KNeighborsClassifier(n_neighbors=n_neighbors).fit(X, y)</span><br><span class="line">    mglearn.plots.plot_2d_separator(clf, X, fill=<span class="literal">True</span>, eps=<span class="number">0.5</span>, ax=ax, alpha=<span class="number">.4</span>)</span><br><span class="line">    mglearn.discrete_scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], y, ax=ax)</span><br><span class="line">    ax.set_title(<span class="string">'&#123;&#125; neighbor(s)'</span>.format(n_neighbors))</span><br><span class="line">    ax.set_xlabel(<span class="string">'feature 0'</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">'feature 1'</span>)</span><br><span class="line">axes[<span class="number">0</span>].legend(loc=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-of-knn.png"></p><p>从图中可以看出，使用单一邻居绘制的决策边界紧跟着训练数据。随着邻居个数越来越多，决策边界也越来越平滑。更平滑的边界对应更简单的模型。换句话说，使用更少的邻居对应更高的模型复杂度，而使用更多的邻居对应更低的模型复杂度。假如考虑极端情况，即邻居个数等于训练集中所有数据点的个数，那么每个测试点的邻居都完全相同（即所有训练点），所有预测结果也完全相同（即训练集中出现次数最多的类别）。</p><p>在现实世界的乳腺癌数据集上研究模型复杂度和泛化能力之间的关系。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_breast_cancer</span><br><span class="line"></span><br><span class="line">cancer = load_breast_cancer()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">    cancer.data, cancer.target, stratify=cancer.target, random_state=<span class="number">66</span>)</span><br><span class="line"></span><br><span class="line">training_accuracy, test_accuracy = [], []</span><br><span class="line">neighbors_settings = range(<span class="number">1</span>, <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n_neighbors <span class="keyword">in</span> neighbors_settings:</span><br><span class="line">    clf = KNeighborsClassifier(n_neighbors=n_neighbors)</span><br><span class="line">    clf.fit(X_train, y_train)</span><br><span class="line">    training_accuracy.append(clf.score(X_train, y_train))</span><br><span class="line">    test_accuracy.append(clf.score(X_test, y_test))</span><br><span class="line"></span><br><span class="line">plt.plot(neighbors_settings, training_accuracy, label=<span class="string">'training accuracy'</span>)</span><br><span class="line">plt.plot(neighbors_settings, test_accuracy, label=<span class="string">'test accuracy'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Accuracy'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'n_neighbors'</span>)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/k-neighbors-classification-on-breast-cancer.png"></p><p>单一邻居的模型过于复杂。与之相反，当考虑10个邻居时，模型又过于简单，性能甚至变差。最佳性能在中间的某处，邻居个数大约为6。</p><h1 id="k近邻回归">k近邻回归</h1><p>k近邻算法还可以用于回归。还是从单一近邻开始，这次使用wave数据集。利用单一邻居的预测结果就是最近邻的目标值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_knn_regression(n_neighbors=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/1-nn-regression-on-wave.png"></p><p>同样，也可以用多个近邻进行回归，预测结果为这些近邻的平均值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_knn_regression(n_neighbors=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/3-nn-regression-on-wave.png"></p><p>用于回归的k近邻算法在scikit-learn的KNeighborsRegressor类中实现。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.neighbors.kneighborsregressor" target="_blank" rel="noopener"><code>class sklearn.neighbors.KNeighborsRegressor(n_neighbors=5, weights=’uniform’, algorithm=’auto’, leaf_size=30, p=2, metric=’minkowski’, metric_params=None, n_jobs=None, **kwargs)</code></a></p><p>Regression based on k-nearest neighbors.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsRegressor</span><br><span class="line"></span><br><span class="line">X, y = mglearn.datasets.make_wave(n_samples=<span class="number">40</span>)</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">reg = KNeighborsRegressor(n_neighbors=<span class="number">3</span>)</span><br><span class="line">reg.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Test set predictions:\n&#123;&#125;'</span>.format(reg.predict(X_test)))</span><br><span class="line">print(<span class="string">'Test set R^2: &#123;:.2f&#125;'</span>.format(reg.score(X_test, y_test)))  <span class="comment"># 决定系数</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test set predictions:</span><br><span class="line">[-0.05396539  0.35686046  1.13671923 -1.89415682 -1.13881398 -1.63113382</span><br><span class="line">  0.35686046  0.91241374 -0.44680446 -1.13881398]</span><br><span class="line">Test set R^2: 0.83</span><br></pre></td></tr></table></figure><p>我们可以用score方法来评估模型，对于回归问题，这一方法返回的是<span class="math inline">\(R^2\)</span>分数。<span class="math inline">\(R^2\)</span>分数也叫作决定系数，是回归模型预测的优度度量，位于0到1之间。<span class="math inline">\(R^2\)</span>等于1对应完美预测，<span class="math inline">\(R^2\)</span>等于0对应常数模型，即总是预测训练集响应（y_train)的平均值。</p><h1 id="分析kneighborsregression">分析KNeighborsRegression</h1><p>对于wave一维数据集，可以查看所有特征取值对应的预测结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, axes = plt.subplots(<span class="number">1</span>, <span class="number">3</span>, figsize=(<span class="number">15</span>, <span class="number">4</span>))</span><br><span class="line"><span class="comment"># 创建1000个数据点，在-3和3之间均匀分布</span></span><br><span class="line">line = np.linspace(<span class="number">-3</span>, <span class="number">3</span>, <span class="number">1000</span>).reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> n_neighbors, ax <span class="keyword">in</span> zip([<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>], axes):</span><br><span class="line">    reg = KNeighborsRegressor(n_neighbors=n_neighbors)</span><br><span class="line">    reg.fit(X_train, y_train)</span><br><span class="line">    ax.plot(line, reg.predict(line))</span><br><span class="line">    ax.plot(X_train, y_train, <span class="string">'^'</span>, c=mglearn.cm2(<span class="number">0</span>), markersize=<span class="number">8</span>)</span><br><span class="line">    ax.plot(X_test, y_test, <span class="string">'v'</span>, c=mglearn.cm2(<span class="number">1</span>), markersize=<span class="number">8</span>)</span><br><span class="line">    ax.set_title(<span class="string">'&#123;&#125; neighbor(s)\n train score: &#123;:.2f&#125; test score: &#123;:.2f&#125;'</span>.format(</span><br><span class="line">        n_neighbors, reg.score(X_train, y_train), reg.score(X_test, y_test)))</span><br><span class="line">    ax.set_xlabel(<span class="string">'Feature'</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">'Target'</span>)</span><br><span class="line">axes[<span class="number">0</span>].legend([<span class="string">'Model predictions'</span>, <span class="string">'Training data/target'</span>, <span class="string">'Test data/target'</span>],</span><br><span class="line">    loc=<span class="string">'best'</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/k-neighbors-regression-on-wave.png"></p><p>从图中可以看出，仅使用单一邻居，训练集中的每个点都对预测结果有显著影响，预测结果的图像经过所有数据点。这导致预测结果非常不稳定。考虑更多的邻居之后，预测结果变得更加平滑，但对训练数据的拟合也不好。</p><h1 id="优点缺点和参数">优点、缺点和参数</h1><p>一般来说，KNeighbors分类器有2个重要参数：邻居个数与数据点之间距离的度量方法。在实践中，使用较小的邻居个数（比如3个或5个）往往可以得到比较好的结果，但你应该调节这个参数。距离使用欧式距离，它在许多情况下的效果都很好。</p><p>k-NN的优点之一就是模型很容易理解，通常不需要过多调节就可以得到不错的性能。在考虑使用更高级的技术之前，尝试此算法是一种很好的基准方法。构建最近邻模型的速度通常很快，但如果训练集很大（特征数很多或者样本数很大），预测速度可能会比较慢。<strong>使用k-NN算法时，对数据进行预处理是很重要的。</strong>这一算法对于有很多特征的数据集往往效果不好，对于大多数特征的大多数取值都为0的数据集（所谓的<strong>稀疏数据集</strong>）来说，这一算法的效果尤为不好。</p><p>虽然k近邻算法很容易理解，但由于预测速度慢且不能处理具有很多特征的数据集，所以在实践中往往不会用到。线性模型就没有这两个缺点。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Machine Learning with Python </tag>
            
            <tag> supervised </tag>
            
            <tag> regression </tag>
            
            <tag> classification </tag>
            
            <tag> KNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>监督学习</title>
      <link href="/notes/introduction-to-ml-with-python/supervised-learning/"/>
      <url>/notes/introduction-to-ml-with-python/supervised-learning/</url>
      
        <content type="html"><![CDATA[<p>每当想要根据给定输入预测某个结果，并且还有输入/输出对的示例时，都应该使用监督学习。这些输入/输出对构成了训练集，我们利用它来构建机器学习模型。我们的目标是对从未见过的新数据做出准确预测。监督学习通常需要人力来构建训练集，但之后的任务本来非常费力甚至无法完成，现在却可以自动完成，通常速度也很快。</p><h1 id="分类和回归">分类和回归</h1><p>监督机器学习问题主要有两种，分别叫做分类（classification）与回归（regression）。</p><p>分类问题的目标是预测类别标签（class label），这些标签来自预定义的可选列表。分类问题有时可分为而分类（binary classification）和多分类（multiclass classification）。</p><p>在二分类问题中，我们通常将其中一个类别称为正类（positive class），另一个类别称为反类（negative class）。而鸢尾花的例子则属于多分类问题。另一个多分类的例子是根据网站上的文本预测网站所用的语言。这里的类别就是预定义的语言列表。</p><p>回归任务的目标是预测一个连续值，编程术语叫做浮点数（floating-point number），数学术语叫做实数（real number）。根据教育水平、年龄和居住地来预测一个人的年收入，这就是回归的一个例子。在预测收入时，预测值是一个金额，可以在给定范围内任意取值。回归任务的另一个例子是，根据上一年的产量、天气和农场员工数等属性来预测农场的产量。同样，产量也可以取任意数值。</p><a id="more"></a><p>区分分类任务和回归任务有一个简单的方法，就是问一个问题：输出是否具有某种连续性。如果在可能的结果之间具有连续性，那么它就是一个回归问题。想想预测年收入的例子，输出具有非常明显的连续性。一年赚40000美元还是40001美元并没有实质差别，即时两者金额不同。如果我们的算法在本应预测40000美元时的预测结果是39990美元或40001美元，不必过分在意。</p><p>与此相反，对于识别网站语言的任务来说，并不存在程度问题。网站使用的要么是这种语言，要么是那种语言。在语言之间不存在连续性，在英语和法语之间不存在其他语言。</p><h1 id="泛化过拟合与欠拟合">泛化、过拟合与欠拟合</h1><p>在监督学习中，我们想要在训练数据上构建模型，然后能够对没见过的新数据（这些新数据与训练集具有相同的特性）做出准确预测。如果一个模型能够对没见过的数据做出准确预测，我们就说它能够从训练集泛化（generalize）到测试集。我们想要构建一个泛化精度尽可能高的模型。</p><p>通常来说，我们构建模型，使其在训练集上能够做出准确预测。如果训练集和测试集足够相似，我们预计模型在测试集上也能做出准确预测。不过在某些情况下这一点并不成立。例如，如果我们可以构建非常复杂的模型，那么在训练集上的精度可以想多高就多高。</p><p>为了说明这一点，我们来看一个虚构的例子。比如有一个新手数据科学家，已知之前船的买家记录和对买船不感兴趣的顾客记录，想要预测某个顾客是否会买船（在现实世界中，这实际上是一个非常复杂的问题。虽然我们知道其他顾客还没有从我们这里买过船，但他们可能已经在其他人那里买过了，或者仍在存钱并打算将来再买）。目标是向可能购买的人发送促销电子邮件，而不去打扰那些不感兴趣的顾客。</p><p>判断一个算法在新数据上表现好坏的唯一度量，就是在测试集上的评估。然而从直觉上看（在数学上也可以证明这一点，奥卡姆剃刀理论），我们认为简单的模型对新数据的泛化能力更好。如果规律是“年龄大于50岁的人想要买船”，并且还可以解释所有顾客的行为，那么我们将更相信这条规律，而不是与年龄、子女和婚姻状况都有关系的那条规律。因此，我们总想找到最简单的模型。构建一个对现有信息量来说过于复杂的模型，这被称之为过拟合（overfitting）。如果你在拟合模型时过分关注训练集的细节，得到了一个在训练集上表现很好、但不能泛化到新数据上的模型，那么就存在过拟合。与之相反，如果你的模型过于简单——比如说，“有房子的人都买船”——那么你可能无法抓住数据的全部内容以及数据中的变化，你的模型甚至在训练集上的表现就很差。选择过于简单的模型被称为欠拟合（underfitting）。</p><p>我们的模型越复杂，在训练数据上的预测结果就越好。但是，如果我们的模型过于复杂，我们开始过多关注训练集中每个单独的数据点，模型就不能很好地泛化到新数据上。二者之间存在一个最佳位置，可以得到最好的泛化性能。这就是我们想要的模型。</p><p><img src="/uploads/image/introduction-to-ml-with-python/trade-off-of-model-complexity-against-training-and-test-accuracy.png"></p><h2 id="模型复杂度与数据集大小的关系">模型复杂度与数据集大小的关系</h2><p>需要注意，模型复杂度与训练数据集中的输入的变化密切相关：数据集中包含的数据点的变化范围越大，在不发生过拟合的前提下你可以使用的模型就越复杂。通常来说，收集更多的数据点可以有更大的变化范围，所以更大的数据集可以用来构建更复杂的模型。但是，仅复制相同的数据点或收集非常相似的数据是无济于事的。</p><p>收集更多数据，适当构建更复杂的模型，对监督学习任务往往特别有用。在现实世界中，你往往能够决定收集多少数据，这可能比模型调参更为有效。永远不要低谷更多数据的力量！</p><h1 id="监督学习算法">监督学习算法</h1><h2 id="一些样本数据集">一些样本数据集</h2><p>用模拟的forge数据集来说明分类算法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> mglearn</span><br><span class="line"></span><br><span class="line">X, y = mglearn.datasets.make_forge()</span><br><span class="line">mglearn.discrete_scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], y)</span><br><span class="line">plt.legend([<span class="string">'Class 0'</span>, <span class="string">'Class 1'</span>], loc=<span class="number">4</span>)</span><br><span class="line">plt.xlabel(<span class="string">'First feature'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Second feature'</span>)</span><br><span class="line">print(X.shape)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(26, 2)  # 26行数据，每个数据有2个特征</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/datasets-forge.png"></p><p>用模拟的wave数据集来说明回归算法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X, y = mglearn.datasets.make_wave(n_samples=<span class="number">40</span>)</span><br><span class="line">plt.plot(X, y, <span class="string">'o'</span>)</span><br><span class="line">plt.ylim(<span class="number">-3</span>, <span class="number">3</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Feature'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Target'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/datasets-wave.png"></p><p><strong>从特征较少的数据集（也叫低维数据集）中得出的结论可能并不适用于特征较多的数据集（也叫高维数据集）。</strong></p><p>分类数据集，乳腺癌数据集。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_breast_cancer</span><br><span class="line">cancer = load_breast_cancer()</span><br><span class="line">print(<span class="string">'Keys:'</span>, cancer.keys())</span><br><span class="line">print(<span class="string">'Shape:'</span>, cancer.data.shape)</span><br><span class="line">print(<span class="string">'Feature names:\n&#123;&#125;'</span>.format(cancer.feature_names))  <span class="comment"># 30个特征的名字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">print(<span class="string">'Counter:'</span>, &#123;n: v <span class="keyword">for</span> n, v <span class="keyword">in</span>  <span class="comment"># 按恶性和良性计数</span></span><br><span class="line">                   zip(cancer.target_names, np.bincount(cancer.target))&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Keys: dict_keys([&apos;data&apos;, &apos;target&apos;, &apos;target_names&apos;, &apos;DESCR&apos;, &apos;feature_names&apos;, &apos;filename&apos;])</span><br><span class="line">Shape: (569, 30)</span><br><span class="line">Feature names:</span><br><span class="line">[&apos;mean radius&apos; &apos;mean texture&apos; &apos;mean perimeter&apos; &apos;mean area&apos;</span><br><span class="line"> &apos;mean smoothness&apos; &apos;mean compactness&apos; &apos;mean concavity&apos;</span><br><span class="line"> &apos;mean concave points&apos; &apos;mean symmetry&apos; &apos;mean fractal dimension&apos;</span><br><span class="line"> &apos;radius error&apos; &apos;texture error&apos; &apos;perimeter error&apos; &apos;area error&apos;</span><br><span class="line"> &apos;smoothness error&apos; &apos;compactness error&apos; &apos;concavity error&apos;</span><br><span class="line"> &apos;concave points error&apos; &apos;symmetry error&apos; &apos;fractal dimension error&apos;</span><br><span class="line"> &apos;worst radius&apos; &apos;worst texture&apos; &apos;worst perimeter&apos; &apos;worst area&apos;</span><br><span class="line"> &apos;worst smoothness&apos; &apos;worst compactness&apos; &apos;worst concavity&apos;</span><br><span class="line"> &apos;worst concave points&apos; &apos;worst symmetry&apos; &apos;worst fractal dimension&apos;]</span><br><span class="line">Counter: &#123;&apos;malignant&apos;: 212, &apos;benign&apos;: 357&#125;</span><br></pre></td></tr></table></figure><p>回归数据集，波士顿房价数据集。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_boston</span><br><span class="line">boston = load_boston()</span><br><span class="line">print(boston.data.shape)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(506, 13)</span><br></pre></td></tr></table></figure><p>对于我们的目的而言，我们需要扩展这个数据集，输入特征不仅包括这13个测量结果，还包括这些特征之间的乘积（也叫交互项）。换句话说，我们不仅将犯罪率和公路可达性作为特征，还将犯罪率和公路可达性的乘积作为特征。这个导出的数据集可以用mglearn.load_extended_boston函数加载。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X, y = mglearn.datasets.load_extended_boston()</span><br><span class="line">print(X.shape)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(506, 104)</span><br></pre></td></tr></table></figure><h2 id="k近邻">k近邻</h2><a href="/notes/introduction-to-ml-with-python/k-nearest-neighbors/" title="前往文章">前往文章</a><h2 id="线性模型">线性模型</h2><a href="/notes/introduction-to-ml-with-python/linear-models/" title="前往文章">前往文章</a><h2 id="朴素贝叶苏分类器">朴素贝叶苏分类器</h2><a href="/notes/introduction-to-ml-with-python/naive-bayes-classifiers/" title="前往文章">前往文章</a><h2 id="决策树">决策树</h2><a href="/notes/introduction-to-ml-with-python/decision-trees/" title="前往文章">前往文章</a><h2 id="决策树集成">决策树集成</h2><a href="/notes/introduction-to-ml-with-python/decision-tree-ensemble/" title="前往文章">前往文章</a><h2 id="核支持向量机">核支持向量机</h2><a href="/notes/introduction-to-ml-with-python/kernelized-support-vector-machine/" title="前往文章">前往文章</a><h2 id="神经网络深度学习">神经网络（深度学习）</h2><a href="/notes/introduction-to-ml-with-python/neural-networks-deep-learning/" title="前往文章">前往文章</a><h1 id="分类器的不确定度估计">分类器的不确定度估计</h1><p>我们还没有谈到<code>scikit-learn</code>接口的另一个有用之处，就是分类器能够给出预测的不正确度估计。一般来说，你感兴趣的不仅是分类器会预测一个测试点属于哪个类别，还包括它对这个预测的置信度。在实践中，不同类型的错误会在现实应用中导致非常不同的结果。想象一个用于测试癌症的医疗应用。假阳性预测可能只会让“患者”接受额外的测试，但假阴性却可能导致重病没有得到治疗。</p><p><code>scikit-learn</code>中有两个函数可用于获取分类器的不确定度估计：<code>decision_function</code>和<code>predict_proba</code>。大多数分类器（但不是全部）都至少有其中一个函数，很多分类器两个都有。我们来构建一个GradientBoostingClassifier分类器（同时拥有<code>decision_function</code>和<code>predict_proba</code>两个方法），看一下这两个函数对一个模拟的二维数据集的作用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_circles</span><br><span class="line">X, y = make_circles(noise=<span class="number">0.25</span>, factor=<span class="number">0.5</span>, random_state=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了便于说明，我们将两个类别重命名为"blue"和"red"</span></span><br><span class="line">y_named = np.array([<span class="string">'blue'</span>, <span class="string">'red'</span>])[y]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们可以对任意个数组调用train_test_split</span></span><br><span class="line"><span class="comment"># 所有数组的划分都是一致的</span></span><br><span class="line">X_train, X_test, y_train_named, y_test_named, y_train, y_test = \</span><br><span class="line">    train_test_split(X, y_named, y, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建梯度提升模型</span></span><br><span class="line">gbrt = GradientBoostingClassifier(random_state=<span class="number">0</span>)</span><br><span class="line">gbrt.fit(X_train, y_train_named)</span><br></pre></td></tr></table></figure><h2 id="决策函数">决策函数</h2><p>对于二分类的情况，<code>decision_function</code>返回值的形状是<code>(n_samples,)</code>，为每个样本都返回一个浮点数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'X_test.shape: &#123;&#125;'</span>.format(X_test.shape))</span><br><span class="line">print(<span class="string">'Decision function shape: &#123;&#125;'</span>.format(</span><br><span class="line">    gbrt.decision_function(X_test).shape))</span><br><span class="line"><span class="comment"># 显示decision_function的前几个元素</span></span><br><span class="line">print(<span class="string">'Decision function:\n&#123;&#125;'</span>.format(gbrt.decision_function(X_test)[:<span class="number">6</span>]))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X_test.shape: (25, 2)</span><br><span class="line">Decision function shape: (25,)</span><br><span class="line">Decision function:</span><br><span class="line">[ 4.13592629 -1.7016989  -3.95106099 -3.62599351  4.28986668  3.66166106]</span><br></pre></td></tr></table></figure><p>这个值表示模型对该数据点属于“正”类的置信程度。正值表示对正类的偏好，负值表示对“反类”（其他类）的偏好。</p><p>我们可以通过仅查看决策函数的正负号来再现预测值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'Thresholded decision function:\n&#123;&#125;'</span>.format(</span><br><span class="line">    gbrt.decision_function(X_test) &gt; <span class="number">0</span>))</span><br><span class="line">print(<span class="string">"Predictions:\n&#123;&#125;"</span>.format(gbrt.predict(X_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thresholded decision function:</span><br><span class="line">[ True False False False  True  True False  True  True  True False  True</span><br><span class="line">  True False  True False False False  True  True  True  True  True False</span><br><span class="line"> False]</span><br><span class="line">Predictions:</span><br><span class="line">[&apos;red&apos; &apos;blue&apos; &apos;blue&apos; &apos;blue&apos; &apos;red&apos; &apos;red&apos; &apos;blue&apos; &apos;red&apos; &apos;red&apos; &apos;red&apos; &apos;blue&apos;</span><br><span class="line"> &apos;red&apos; &apos;red&apos; &apos;blue&apos; &apos;red&apos; &apos;blue&apos; &apos;blue&apos; &apos;blue&apos; &apos;red&apos; &apos;red&apos; &apos;red&apos; &apos;red&apos;</span><br><span class="line"> &apos;red&apos; &apos;blue&apos; &apos;blue&apos;]</span><br></pre></td></tr></table></figure><p>对于二分类问题，“反类”始终是<code>classes_</code>属性的第一个元素，“正”类是<code>classes_</code>的第二个元素。因此，如果你想要完全再现predict的输出，需要利用<code>classes_</code>属性。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将布尔值True/False转换成0和1</span></span><br><span class="line">greater_zero = (gbrt.decision_function(X_test) &gt; <span class="number">0</span>).astype(int)</span><br><span class="line"><span class="comment"># 利用0和1作为classes_的索引</span></span><br><span class="line">pred = gbrt.classes_[greater_zero]</span><br><span class="line"><span class="comment"># pred与gbrt.predict的输出完全相同</span></span><br><span class="line">print(<span class="string">'pred is equal to predictions: &#123;&#125;'</span>.format(</span><br><span class="line">    np.all(pred == gbrt.predict(X_test))))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pred is equal to predictions: True</span><br></pre></td></tr></table></figure><p><code>decision_function</code>可以在任意范围取值，这取决于数据和模型参数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">decision_function = gbrt.decision_function(X_test)</span><br><span class="line">print(<span class="string">"Decision function minimum: &#123;:.2f&#125; maximum: &#123;:.2f&#125;"</span>.format(</span><br><span class="line">    np.min(decision_function), np.max(decision_function)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Decision function minimum: -7.69 maximum: 4.29</span><br></pre></td></tr></table></figure><p>由于可以任意缩放，因此<code>decision_function</code>的输出往往很难解释。</p><p>在下面的例子中，我们利用颜色编码在二维平面中画出所有点的<code>decision_function</code>，还有决策边界。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fit, axes = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">13</span>, <span class="number">5</span>))</span><br><span class="line">mglearn.tools.plot_2d_separator(gbrt, X, ax=axes[<span class="number">0</span>], alpha=<span class="number">.4</span>,</span><br><span class="line">    fill=<span class="literal">True</span>, cm=mglearn.cm2)</span><br><span class="line">scores_image = mglearn.tools.plot_2d_scores(gbrt, X, ax=axes[<span class="number">1</span>],</span><br><span class="line">    alpha=<span class="number">.4</span>, cm=mglearn.ReBl)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax <span class="keyword">in</span> axes:</span><br><span class="line">    <span class="comment"># 画出训练点和测试点</span></span><br><span class="line">    mglearn.discrete_scatter(X_test[:, <span class="number">0</span>], X_test[:, <span class="number">1</span>], y_test,</span><br><span class="line">        markers=<span class="string">'^'</span>, ax=ax)</span><br><span class="line">    mglearn.discrete_scatter(X_train[:, <span class="number">0</span>], X_train[:, <span class="number">1</span>], y_train,</span><br><span class="line">        markers=<span class="string">'o'</span>, ax=ax)</span><br><span class="line">    ax.set_xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">'Feature 1'</span>)</span><br><span class="line">cbar = plt.colorbar(scores_image, ax=axes.tolist())</span><br><span class="line">axes[<span class="number">0</span>].legend([<span class="string">'Test class 0'</span>, <span class="string">'Test class 1'</span>, <span class="string">'Train class 0'</span>,</span><br><span class="line">    <span class="string">'Train class 1'</span>], ncol=<span class="number">4</span>, loc=(<span class="number">.1</span>, <span class="number">1.05</span>))</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-and-decision-function-of-gbrt.png"></p><p>既给出预测结果，又给出分类器的置信程度，这样给出的信息量更大。但在上面的决策函数图像（右）中，很难分辨出两个类别之间的边界。</p><h2 id="预测概率">预测概率</h2><p><code>predict_proba</code>的输出是每个类别的概率，通常比<code>decision_function</code>的输出更容易理解。对于二分类问题，它的形状始终是<code>(n_samples, 2)</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'Shape of probabilities: &#123;&#125;'</span>.format(gbrt.predict_proba(X_test).shape))</span><br><span class="line"><span class="comment"># 显示predict_proba的前几个元素</span></span><br><span class="line">print(<span class="string">'Predicted probabilities:\n&#123;&#125;'</span>.format(</span><br><span class="line">    gbrt.predict_proba(X_test[:<span class="number">6</span>])))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Shape of probabilities: (25, 2)</span><br><span class="line">Predicted probabilities:</span><br><span class="line">[[0.01573626 0.98426374]</span><br><span class="line"> [0.84575649 0.15424351]</span><br><span class="line"> [0.98112869 0.01887131]</span><br><span class="line"> [0.97406775 0.02593225]</span><br><span class="line"> [0.01352142 0.98647858]</span><br><span class="line"> [0.02504637 0.97495363]]</span><br></pre></td></tr></table></figure><p>每行的第一个元素是第一个类别的估计概率，第二个元素是第二个类别的估计概率。由于<code>predict_proba</code>的输出是一个概率，因此总是在0和1之间，两个类别的元素之和始终为1，因此只有一个类别的概率超过50%。这个类别就是模型的预测结果（由于概率是浮点数，所以不太可能两个都等于0.500。但如果出现了这种情况，预测结果是随机选择的）。</p><p>在上一个输出中可以看到，分类器对大部分点的置信程度都是相对较高的。<strong>不确定度大小实际上反映了数据依赖于模型和参数的不确定度。过拟合更强的模型可能会做出置信程度更高的预测，即使可能是错的。复杂度越低的模型通常对预测的不确定度越大。</strong>如果模型给出的不确定度符合实际情况，那么这个模型被称为<strong>校正</strong>（calibrated）模型。在校正模型中，如果预测有70%的确定度，那么它在70%的情况下正确。</p><p>在下面的例子中，我们再次给出该数据集的决策边界，以及类别1的预测概率。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fit, axes = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">13</span>, <span class="number">5</span>))</span><br><span class="line">mglearn.tools.plot_2d_separator(gbrt, X, ax=axes[<span class="number">0</span>], alpha=<span class="number">.4</span>,</span><br><span class="line">    fill=<span class="literal">True</span>, cm=mglearn.cm2)</span><br><span class="line">scores_image = mglearn.tools.plot_2d_scores(gbrt, X, ax=axes[<span class="number">1</span>],</span><br><span class="line">    alpha=<span class="number">.4</span>, cm=mglearn.ReBl, function=<span class="string">'predict_proba'</span>)  <span class="comment"># proba</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax <span class="keyword">in</span> axes:</span><br><span class="line">    <span class="comment"># 画出训练点和测试点</span></span><br><span class="line">    mglearn.discrete_scatter(X_test[:, <span class="number">0</span>], X_test[:, <span class="number">1</span>], y_test,</span><br><span class="line">        markers=<span class="string">'^'</span>, ax=ax)</span><br><span class="line">    mglearn.discrete_scatter(X_train[:, <span class="number">0</span>], X_train[:, <span class="number">1</span>], y_train,</span><br><span class="line">        markers=<span class="string">'o'</span>, ax=ax)</span><br><span class="line">    ax.set_xlabel(<span class="string">'Feature 0'</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">'Feature 1'</span>)</span><br><span class="line">cbar = plt.colorbar(scores_image, ax=axes.tolist())</span><br><span class="line">axes[<span class="number">0</span>].legend([<span class="string">'Test class 0'</span>, <span class="string">'Test class 1'</span>, <span class="string">'Train class 0'</span>,</span><br><span class="line">    <span class="string">'Train class 1'</span>], ncol=<span class="number">4</span>, loc=(<span class="number">.1</span>, <span class="number">1.05</span>))</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/decision-boundary-and-predict-proba-of-gbrt.png"></p><p>这张图中的边界更加明确，不确定的小块区域清晰可见。</p><h2 id="多分类问题的不确定度">多分类问题的不确定度</h2><p>到目前为止，我们只讨论了二分类问题中的不确定度估计。但<code>decision_function</code>和<code>predict_proba</code>也适用于多分类问题。我们将这两个函数应用于鸢尾花（Iris）数据集，这是一个三分类数据集。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"></span><br><span class="line">iris = load_iris()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">    iris.data, iris.target, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">gbrt = GradientBoostingClassifier(learning_rate=<span class="number">0.01</span>, random_state=<span class="number">0</span>)</span><br><span class="line">gbrt.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Decision function shape: &#123;&#125;'</span>.format(gbrt.decision_function(X_test).shape))</span><br><span class="line"><span class="comment"># 显示决策函数的前几个元素</span></span><br><span class="line">print(<span class="string">'Decision function:\n&#123;&#125;'</span>.format(gbrt.decision_function(X_test)[:<span class="number">6</span>, :]))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Decision function shape: (38, 3)</span><br><span class="line">Decision function:</span><br><span class="line">[[-1.9957153   0.04758118 -1.92721297]</span><br><span class="line"> [ 0.0614655  -1.90755689 -1.92793177]</span><br><span class="line"> [-1.99058105 -1.87637856  0.09686741]</span><br><span class="line"> [-1.9957153   0.04758118 -1.92721297]</span><br><span class="line"> [-1.99730166 -0.13469231 -1.20341532]</span><br><span class="line"> [ 0.0614655  -1.90755689 -1.92793177]]</span><br></pre></td></tr></table></figure><p>对于多分类的情况，<code>decision_function</code>的形状为<code>(n_samples, n_classes)</code>，每一列对应每个类别的“确定度分数”，分数较高的类别可能性更大，得分较低的类别可能性较小。你可以找出每个数据点的最大元素，从而利用这些分数再现预测结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'Argmax of decision function:\n&#123;&#125;'</span>.format(</span><br><span class="line">    np.argmax(gbrt.decision_function(X_test), axis=<span class="number">1</span>)))</span><br><span class="line">print(<span class="string">'Predictions:\n&#123;&#125;'</span>.format(gbrt.predict(X_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Argmax of decision function:</span><br><span class="line">[1 0 2 1 1 0 1 2 1 1 2 0 0 0 0 1 2 1 1 2 0 2 0 2 2 2 2 2 0 0 0 0 1 0 0 2 1</span><br><span class="line"> 0]</span><br><span class="line">Predictions:</span><br><span class="line">[1 0 2 1 1 0 1 2 1 1 2 0 0 0 0 1 2 1 1 2 0 2 0 2 2 2 2 2 0 0 0 0 1 0 0 2 1</span><br><span class="line"> 0]</span><br></pre></td></tr></table></figure><p><code>predict_proba</code>输出的形状相同，也是<code>(n_samples, n_classes)</code>。同样，每个数据点所有可能类别的概率之和为1。同样可以通过计算<code>predict_proba</code>的argmax来再现预测结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示predict_proba的前几个元素</span></span><br><span class="line">print(<span class="string">'Predicted probabilities:\n&#123;&#125;'</span>.format(gbrt.predict_proba(X_test)[:<span class="number">6</span>]))</span><br><span class="line"><span class="comment"># 显示每行的和都是1</span></span><br><span class="line">print(<span class="string">'Sums: &#123;&#125;'</span>.format(gbrt.predict_proba(X_test)[:<span class="number">6</span>].sum(axis=<span class="number">1</span>)))</span><br><span class="line"><span class="comment"># 通过计算predict_proba的argmax来再现预测结果</span></span><br><span class="line">print(<span class="string">'Argmax of predicted probabilities:\n&#123;&#125;'</span>.format(</span><br><span class="line">    np.argmax(gbrt.predict_proba(X_test), axis=<span class="number">1</span>)))</span><br><span class="line">print(<span class="string">'Predictions:\n&#123;&#125;'</span>.format(gbrt.predict(X_test)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Predicted probabilities:</span><br><span class="line">[[0.10217734 0.78840063 0.10942203]</span><br><span class="line"> [0.7834712  0.1093673  0.1071615 ]</span><br><span class="line"> [0.09818079 0.11005862 0.79176059]</span><br><span class="line"> [0.10217734 0.78840063 0.10942203]</span><br><span class="line"> [0.10360014 0.66723882 0.22916105]</span><br><span class="line"> [0.7834712  0.1093673  0.1071615 ]]</span><br><span class="line">Sums: [1. 1. 1. 1. 1. 1.]</span><br><span class="line">Argmax of predicted probabilities:</span><br><span class="line">[1 0 2 1 1 0 1 2 1 1 2 0 0 0 0 1 2 1 1 2 0 2 0 2 2 2 2 2 0 0 0 0 1 0 0 2 1</span><br><span class="line"> 0]</span><br><span class="line">Predictions:</span><br><span class="line">[1 0 2 1 1 0 1 2 1 1 2 0 0 0 0 1 2 1 1 2 0 2 0 2 2 2 2 2 0 0 0 0 1 0 0 2 1</span><br><span class="line"> 0]</span><br></pre></td></tr></table></figure><p>总之，<code>predict_proba</code>和<code>decision_function</code>的形状始终相同，都是<code>(n_samples, n_classes)</code>——除了二分类特殊情况下的<code>decision_function</code>。对于二分类的情况，<code>decision_function</code>只有一列，对应“正”类<code>classes_[1]</code>。这主要是由于历史原因。</p><p>如果有<code>n_classes</code>列，你可以通过计算每一列的argmax来再现预测结果。但如果类别是字符串，或者整数，但不是从0开始的连续整数的话，一定要小心。如果你想要对比predict的结果与<code>decision_function</code>或<code>predict_proba</code>的结果，一定要用分类器的<code>classes_</code>属性来获取真实的属性名称。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logreg = LogisticRegression()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用iris数据集的类别名称来表示每一个目标值</span></span><br><span class="line">named_target = iris.target_names[y_train]</span><br><span class="line">logreg.fit(X_train, named_target)</span><br><span class="line">print(<span class="string">'unique classes in training data: &#123;&#125;'</span>.format(logreg.classes_))</span><br><span class="line">print(<span class="string">'predictions: &#123;&#125;'</span>.format(logreg.predict(X_test)[:<span class="number">10</span>]))</span><br><span class="line"></span><br><span class="line">argmax_dec_func = np.argmax(logreg.decision_function(X_test), axis=<span class="number">1</span>)</span><br><span class="line">print(<span class="string">'argmax of decision function: &#123;&#125;'</span>.format(argmax_dec_func[:<span class="number">10</span>]))</span><br><span class="line">print(<span class="string">'argmax combined with classes_: &#123;&#125;'</span>.format(</span><br><span class="line">    logreg.classes_[argmax_dec_func][:<span class="number">10</span>]))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unique classes in training data: [&apos;setosa&apos; &apos;versicolor&apos; &apos;virginica&apos;]</span><br><span class="line">predictions: [&apos;versicolor&apos; &apos;setosa&apos; &apos;virginica&apos; &apos;versicolor&apos; &apos;versicolor&apos; &apos;setosa&apos;</span><br><span class="line"> &apos;versicolor&apos; &apos;virginica&apos; &apos;versicolor&apos; &apos;versicolor&apos;]</span><br><span class="line">argmax of decision function: [1 0 2 1 1 0 1 2 1 1]</span><br><span class="line">argmax combined with classes_: [&apos;versicolor&apos; &apos;setosa&apos; &apos;virginica&apos; &apos;versicolor&apos; &apos;versicolor&apos; &apos;setosa&apos;</span><br><span class="line"> &apos;versicolor&apos; &apos;virginica&apos; &apos;versicolor&apos; &apos;versicolor&apos;]</span><br></pre></td></tr></table></figure><h1 id="小结">小结</h1><p>欠拟合是指一个模型无法获取训练数据中的所有变化；过拟合是指模型过分关注训练数据，但对新数据的泛化性能不好。</p><p>关于何时使用哪种模型，下面是一份快速总结。</p><ul><li><p>最近邻</p><p>适用于小型数据集，是很好的基准模型，很容易理解。</p></li><li><p>线性模型</p><p>非常可靠的首选算法，适用于非常大的数据集，也适用于高维数据。</p></li><li><p>朴素贝叶斯</p><p>只适用于分类问题。比线性模型速度还快，适用于非常大的数据集和高维数据。精度通常要低于线性模型。</p></li><li><p>决策树</p><p>进度很快，不需要数据缩放，可以可视化，很容易理解。</p></li><li><p>随机森林</p><p>几乎总是比单棵决策树的表现要好，鲁棒性很好，非常强大。不需要数据缩放。不适用于高维稀疏数据。</p></li><li><p>梯度提升决策树</p><p>精度通常比随机森林略高。与随机森林相比，训练速度满，但预测速度更快，需要的内存也更少。比随机森林需要更多的参数调节。</p></li><li><p>支持向量机</p><p>对于特征含义相似的中等大小的数据集很强大。需要数据缩放，对参数敏感。</p></li><li><p>神经网络</p><p>可以构建非常复杂的模型，特别是对于大型数据集而言。对数据缩放敏感，对参数选取敏感。大型网络需要很长的训练时间。</p></li></ul><p>面对新数据集，通常最好先从简单模型开始，比如线性模型、朴素贝叶斯或最近邻分类器，看能得到什么样的结果。对数据有了进一步了解之后，你可以考虑用于构建更复杂模型的算法，比如随机森林、梯度提升决策树、SVM或神经网络。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Machine Learning with Python </tag>
            
            <tag> supervised </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类元编程</title>
      <link href="/notes/fluent-python/class-metaprogramming/"/>
      <url>/notes/fluent-python/class-metaprogramming/</url>
      
        <content type="html"><![CDATA[<blockquote><p>（元类）是深奥的知识，99%的用户都无需关注。如果你想知道是否需要使用元类，我告诉你，不需要（真正需要使用元类的人确信他们需要，无需解释原因）。</p><p>——Tim Peters（Timsort算法的发明者，活跃的Python贡献者）</p></blockquote><p>类元编程是指在运行时创建或定制类的技艺。在Python中，类是一等对象，因此任何时候都可以使用函数新建类，而无需使用class关键字。类装饰器也是函数，不过能够审查、修改，甚至把被装饰的类替换成其他类。</p><p>元类是类元编程最高级的工具：使用元类可以创建具有某种特质的全新类种，例如抽象基类。元类功能强大，但是难以掌握。类装饰器能使用更简单的方式解决更多问题。</p><p><strong>除非开发框架，否则不要编写元类</strong>。</p><a id="more"></a><h1 id="类工厂函数">类工厂函数</h1><p>本书多次提高标准库中的一个类工厂函数——collections.namedtuple。我们把一个类名和几个属性名传给这个函数，它会创建一个tuple的子类，其中的元素通过名称获取，还为调试提供了友好的字符串表示形式（<code>__repr__</code>）。</p><p>有时，我觉得应该有类似的工厂函数，用于创建可变对象。假设我在编写一个宠物点应用程序时，我想把狗的数据当作简单的记录处理。编写下面的样板代码让人厌烦：</p><figure class="highlight python"><figcaption><span>dog.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, weight, owner)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.owner = owner</span><br></pre></td></tr></table></figure><p>各个字段名称出现了3次。写了这么多样板代码，甚至字符串表示形式都不友好：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> dog <span class="keyword">import</span> Dog</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rex = Dog(<span class="string">'Rex'</span>, <span class="number">30</span>, <span class="string">'Bob'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rex</span><br><span class="line">&lt;dog.Dog object at <span class="number">0x10dbd3ef0</span>&gt;</span><br></pre></td></tr></table></figure><p>参考collections.namedtuple，下面我们创建一个record_factory函数，即时创建简单的类（如Dog）。</p><figure class="highlight python"><figcaption><span>record_factory.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record_factory</span><span class="params">(cls_name, field_names)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:  <span class="comment"># 体现了鸭子类型：尝试在逗号或空格处拆分field_names</span></span><br><span class="line">        field_names = field_names.replace(<span class="string">','</span>, <span class="string">' '</span>).split()</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        <span class="keyword">pass</span>  <span class="comment"># 如果失败，那么假定field_names本就是可迭代的对象</span></span><br><span class="line">    field_names = tuple(field_names)  <span class="comment"># 一个元素对应一个属性名</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        attrs = dict(zip(self.__slots__, args))  <span class="comment"># 位置参数</span></span><br><span class="line">        attrs.update(kwargs)  <span class="comment"># 关键字参数</span></span><br><span class="line">        <span class="keyword">for</span> name, value <span class="keyword">in</span> attrs.items():</span><br><span class="line">            setattr(self, name, value)  <span class="comment"># 设值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> self.__slots__:</span><br><span class="line">            <span class="keyword">yield</span> getattr(self, name)  <span class="comment"># 按顺序产值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span>  <span class="comment"># 生成友好的字符串表示形式</span></span><br><span class="line">        values = <span class="string">', '</span>.join(<span class="string">'&#123;&#125;=&#123;!r&#125;'</span>.format(*i) <span class="keyword">for</span> i</span><br><span class="line">                            <span class="keyword">in</span> zip(self.__slots__, self))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&#123;&#125;(&#123;&#125;)'</span>.format(self.__class__.__name__, values)</span><br><span class="line"></span><br><span class="line">    cls_attrs = dict(__slots__ = field_names,</span><br><span class="line">                     __init__ = __init__,</span><br><span class="line">                     __iter__ = __iter__,</span><br><span class="line">                     __repr__ = __repr__)</span><br><span class="line">    <span class="comment"># 调用type构造方法，构建新类</span></span><br><span class="line">    <span class="keyword">return</span> type(cls_name, (object,), cls_attrs)</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> record_factory <span class="keyword">import</span> record_factory</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Dog = record_factory(<span class="string">'Dog'</span>, <span class="string">'name weight owner'</span>)  <span class="comment"># 签名与namedtuple类似</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rex = Dog(<span class="string">'Rex'</span>, <span class="number">30</span>, <span class="string">'Bob'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rex  <span class="comment"># 友好的字符串表示形式</span></span><br><span class="line">Dog(name=<span class="string">'Rex'</span>, weight=<span class="number">30</span>, owner=<span class="string">'Bob'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name, weight, owner = rex  <span class="comment"># 便利地拆包</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name, weight</span><br><span class="line">(<span class="string">'Rex'</span>, <span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"&#123;2&#125;'s dog weights &#123;1&#125;kg"</span>.format(*rex)  <span class="comment"># 传给format等函数时也可以拆包</span></span><br><span class="line"><span class="string">"Bob's dog weights 32kg"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rex.weight = <span class="number">32</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rex</span><br><span class="line">Dog(name=<span class="string">'Rex'</span>, weight=<span class="number">32</span>, owner=<span class="string">'Bob'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Dog.__mro__  <span class="comment"># 继承自object，与创建它的工厂函数没有关系</span></span><br><span class="line">(&lt;class 'record_factory.Dog'&gt;, &lt;class 'object'&gt;)</span><br></pre></td></tr></table></figure><p><strong>通常，我们把type视作函数，因为我们像函数那样使用它</strong>，例如，调用type(my_object)获取对象所属的类——作用与<code>my_object.__class__</code>相同。然而，type是一个类。传入三个参数可以新建一个类。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/functions#type" target="_blank" rel="noopener"><code>class type(object)</code></a></p><p><code>class type(name, bases, dict)</code></p><p>With one argument, return the type of an object. The return value is a type object and generally the same object as returned by <code>object.__class__</code>.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MyClass = type(<span class="string">'MyClass'</span>, (MySuperClass, MyMixin), &#123;<span class="string">'x'</span>: <span class="number">42</span>, <span class="string">'x2'</span>: <span class="keyword">lambda</span> self: self.x * <span class="number">2</span>&#125;)</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(MySuperClass, MyMixin)</span>:</span></span><br><span class="line">    x = <span class="number">42</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x2</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.x * <span class="number">2</span></span><br></pre></td></tr></table></figure><p>让人觉得新奇的是，<strong>type的实例是类</strong>。</p><p>总之，<code>record_factory</code>函数的最后一行会构建一个类，类的名称是<code>cls_name</code>参数的值，唯一的直接超类是object，有<code>__slots__</code>、<code>__init__</code>、<code>__iter__</code>和<code>__repr__</code>四个类属性，其中后三个是实例方法。</p><p>把三个参数传给type是动态创建类的常用方式。如果查看namedtuple函数的远吗，你会发现另一个种方式：先声明一个<code>_class_template</code>变量，其值是字符串形式的源码模板；然后在namedtuple函数中调用<code>_class_template.format(...)</code>方法，填充模板里的空白；最后，使用内置的exec函数计算得到的源码字符串。</p><p>在Python中做元编程时，最好不用exec和eval函数。如果接收的字符串（或片段）来自不可信的源，那么这两个函数会带来严重的安全风险。Python提供了充足的内省工具，大多数时候都不需要使用exec和eval函数。然而，Python核心开发者实现namedtuple函数时选择了使用exec函数，这样做是为了让生成的类代码能通过<code>._source</code>属性获取。</p><p>record_factory函数创建的类，其实例有个局限——不能序列化，即不能使用pickle模块里的dump/load函数处理。如果想了解完整的方案，请分析collections.namedtuple函数的源码，搜索“pickling”这个词。</p><h1 id="定制描述符的类装饰器">定制描述符的类装饰器</h1><p>LineItem示例还有个问题没有解决：储存属性的名称不具有描述性，即属性（如weight）的值存储在名为<code>_Quantity#0</code>的实例属性中，这样的名称有点不便于调试。如果储存属性的名称中包含托管属性的名称更好：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>LineItem.weight.storage_name</span><br><span class="line"><span class="string">'_Quantity#weight'</span></span><br></pre></td></tr></table></figure><p>我们不能使用描述性的储存属性名称，因为实例化描述符时无法得知托管属性的名称。可是，一旦组建好整个类，而且把描述符绑定到类属性上之后，我们就可以审查类，并为描述符设值合理的储存属性名称。</p><p>LineItem类的<code>__new__</code>方法可以做到这一点，因此，在<code>__init__</code>方法中使用描述符时，储存属性已经设置了正确的名称。为了解决这个问题而使用<code>__new__</code>方法纯属白费力气：每次新建LineItem实例时都会运行<code>__new__</code>方法中的逻辑，可是，一旦LineItem类构建好了，描述符与托管属性之间的绑定就不会变了。因此，我们要在创建类时设置储存属性的名称。使用类装饰器或元类可以做到这一点。</p><p>类装饰器与函数装饰器非常类似，是参数为类对象的函数，返回原来的类或修改后的类。</p><figure class="highlight python"><figcaption><span>model_v5.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoStorage</span>:</span></span><br><span class="line">    __counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        cls = self.__class__</span><br><span class="line">        prefix = cls.__name__</span><br><span class="line">        index = cls.__counter</span><br><span class="line">        self.storage_name = <span class="string">'_&#123;&#125;#&#123;&#125;'</span>.format(prefix, index)</span><br><span class="line">        cls.__counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> getattr(instance, self.storage_name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        setattr(instance, self.storage_name, value)  <span class="comment"># 无验证</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Validate</span><span class="params">(abc.ABC, AutoStorage)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        value = self.validate(instance, value)  <span class="comment"># 委托validate方法</span></span><br><span class="line">        super().__set__(instance, value)  <span class="comment"># 然后把返回的value传给超类的__set__方法，存储值</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, instance, value)</span>:</span>  <span class="comment"># 抽象方法</span></span><br><span class="line">        <span class="string">"""return validated value or raise ValueError"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span><span class="params">(Validate)</span>:</span></span><br><span class="line">    <span class="string">"""a number greater than zero"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonBlank</span><span class="params">(Validate)</span>:</span></span><br><span class="line">    <span class="string">"""a string with at least one non-space character"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        value = value.strip()</span><br><span class="line">        <span class="keyword">if</span> len(value) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value cannot be empty or blank'</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>model_v6.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> model_v5 <span class="keyword">import</span> Validate, Quantity, NonBlank</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">entity</span><span class="params">(cls)</span>:</span>  <span class="comment"># 参数是一个类</span></span><br><span class="line">    <span class="keyword">for</span> key, attr <span class="keyword">in</span> cls.__dict__.items():</span><br><span class="line">        <span class="keyword">if</span> isinstance(attr, Validate):</span><br><span class="line">            type_name = type(attr).__name__</span><br><span class="line">            <span class="comment"># 使用描述符类的名称和托管属性的名称命名storage_name</span></span><br><span class="line">            attr.storage_name = <span class="string">'_&#123;&#125;#&#123;&#125;'</span>.format(type_name, key)</span><br><span class="line">    <span class="keyword">return</span> cls  <span class="comment"># 返回修改后的类</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>bulkfood_v6.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> model_v6 <span class="keyword">as</span> model</span><br><span class="line"></span><br><span class="line"><span class="meta">@model.entity  # LineItem类唯一的变化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">    description = model.NonBlank()</span><br><span class="line">    weight = model.Quantity()</span><br><span class="line">    price = model.Quantity()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, price)</span>:</span></span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> bulkfood_v6 <span class="keyword">import</span> LineItem</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>raisins = LineItem(<span class="string">'Golden raisins'</span>, <span class="number">10</span>, <span class="number">6.95</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(raisins)[:<span class="number">3</span>]</span><br><span class="line">[<span class="string">'_NonBlank#description'</span>, <span class="string">'_Quantity#price'</span>, <span class="string">'_Quantity#weight'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>LineItem.description.storage_name</span><br><span class="line"><span class="string">'_NonBlank#description'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>raisins.description</span><br><span class="line"><span class="string">'Golden raisins'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(raisins, <span class="string">'_NonBlank#description'</span>)</span><br><span class="line"><span class="string">'Golden raisins'</span></span><br></pre></td></tr></table></figure><p>类装饰器能以比较简单的方式做到以前需要使用元类去做的事情——创建类时定制类。<strong>类装饰器有个重大缺点：只对直接依附的类有效。这意味着，被装饰的类的子类可能继承也可能不继承装饰器所做的改动，具体情况视改动的方式而定。</strong>接下来会探讨这个问题，并给出解决方案。</p><h1 id="导入时和运行时比较">导入时和运行时比较</h1><p>为了正确地做元编程，你必须知道Python解释器什么时候计算各个代码块。Python程序员会区分“导入时”和“运行时”，不过这两个术语没有严格的定义，而且二者之间存在着灰色地带。在导入时，解释器会从上到下一次性解析完模块的源码，然后生成用于执行的字节码。如果句法有错误，就在此时报告。如果本地的文件夹中有<code>__pycache__</code>文件夹中有最新的.pyc文件，解释器会跳过上述步骤，因为已经有运行所需的字节码了。</p><p>编译肯定是导入时的活动，不过那个时期还会做其他事，因为Python中的语句几乎都是可执行的，也就是说语句可能会运行用户代码，修改用户程序的状态。尤其是import语句，它不只是声明（Java中的import语句则只是声明，用于告知编辑器需要特定的包），在进程中首次导入模块时，还会运行所导入模块中的全部顶层代码——以后导入相同的模块则使用缓存，只做名称绑定。哪些顶层代码可以做任何事，包括通常在“运行时”做的事，例如连接数据库（虽然不应该这么做，但是可以做到）。因此，“导入时”和“运行时”之间的界限是模糊的：import语句可以触发任何“运行时”行为。</p><p>导入时会”运行全部顶层代码“，但是”顶层代码”会经过一些加工。导入模块时，解释器会执行顶层的def语句，解释器会编译函数的定义体（首次导入模块时），把函数对象绑定到对应的全局名称上，但是显然解释器不会执行函数的定义体。通常这意味着解释器在导入时定义顶层函数，但是仅当在运行时调用函数时才会执行函数的定义体。</p><p>对类来说，情况就不同了：在导入时，解释器会执行每个类的定义体，甚至会执行嵌套类的定义体。执行类定义体的结果是，定义了类的属性和方法，并构建了类的对象。从这个意义上理解，类的定义体属于”顶层代码“，因为它在导入时运行。</p><p>下面的示例帮助我们理解“导入时”和“运行时”的区别。</p><figure class="highlight python"><figcaption><span>evaltime.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> evalsupport <span class="keyword">import</span> deco_alpha</span><br><span class="line"></span><br><span class="line">print(<span class="string">'&lt;[1]&gt; evaltime module start'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassOne</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[2]&gt; ClassOne body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[3]&gt; ClassOne.__init__'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[4]&gt; ClassOne.__del__'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_x</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[5]&gt; ClassOne.method_x'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ClassTwo</span><span class="params">(object)</span>:</span></span><br><span class="line">            print(<span class="string">'&lt;[6]&gt; ClassTwo body'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@deco_alpha</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassThree</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[7]&gt; ClassThree body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_y</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[8]&gt; ClassThree.method_y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassFour</span><span class="params">(ClassThree)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[9]&gt; ClassFour body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_y</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[10]&gt; ClassFour.method_y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'&lt;[11]&gt; ClassOne tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    one = ClassOne()</span><br><span class="line">    one.method_x()</span><br><span class="line">    print(<span class="string">'&lt;[12]&gt; ClassThree tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    three = ClassThree()</span><br><span class="line">    three.method_y()</span><br><span class="line">    print(<span class="string">'&lt;[13]&gt; ClassFour tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    four = ClassFour()</span><br><span class="line">    four.method_y()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'&lt;[14]&gt; evaltime module end'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>evalsupport.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># evaltime.py导入的模块</span></span><br><span class="line">print(<span class="string">'&lt;[100]&gt; evalsupport module start'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco_alpha</span><span class="params">(cls)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[200]&gt; deco_alpha'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_1</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[300]&gt; deco_alpha:inner_1'</span>)</span><br><span class="line"></span><br><span class="line">    cls.method_y = inner_1</span><br><span class="line">    <span class="keyword">return</span> cls</span><br><span class="line"></span><br><span class="line"><span class="comment"># BEGIN META_ALEPH</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MetaAleph</span><span class="params">(type)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[400]&gt; MetaAleph body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, name, bases, dic)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[500]&gt; MetaAleph.__init__'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner_2</span><span class="params">(self)</span>:</span></span><br><span class="line">            print(<span class="string">'&lt;[600]&gt; MetaAleph.__init__:inner_2'</span>)</span><br><span class="line"></span><br><span class="line">        cls.method_z = inner_2</span><br><span class="line"><span class="comment"># END META_ALEPH</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'&lt;[700]&gt; evalsupport module end'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> evaltime  <span class="comment"># 导入模块</span></span><br><span class="line">&lt;[<span class="number">100</span>]&gt; evalsupport module start  <span class="comment"># evalsupport模块的所有顶层代码在导入时运行</span></span><br><span class="line">&lt;[<span class="number">400</span>]&gt; MetaAleph body</span><br><span class="line">&lt;[<span class="number">700</span>]&gt; evalsupport module end</span><br><span class="line">&lt;[<span class="number">1</span>]&gt; evaltime module start</span><br><span class="line">&lt;[<span class="number">2</span>]&gt; ClassOne body</span><br><span class="line">&lt;[<span class="number">6</span>]&gt; ClassTwo body  <span class="comment"># 嵌套的函数定义体也会执行</span></span><br><span class="line">&lt;[<span class="number">7</span>]&gt; ClassThree body</span><br><span class="line">&lt;[<span class="number">200</span>]&gt; deco_alpha</span><br><span class="line">&lt;[<span class="number">9</span>]&gt; ClassFour body</span><br><span class="line">&lt;[<span class="number">14</span>]&gt; evaltime module end</span><br></pre></td></tr></table></figure><p>对于第一个示例，要注意以下几点：</p><ol type="1"><li>这个场景由简单的import evaltime语句触发。</li><li>解释器会执行所导入模块及其依赖中的每个类定义体。</li><li>解释器先计算类的定义体，然后调用依附在类上的装饰器函数，这是合理的行为，因为必须先构建对象，装饰器才有类对象可处理。</li><li>在这个场景中，只运行了一个用户定义的函数或方法——deco_alpha装饰器。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python evaltime.py</span><br><span class="line">&lt;[<span class="number">100</span>]&gt; evalsupport module start</span><br><span class="line">&lt;[<span class="number">400</span>]&gt; MetaAleph body</span><br><span class="line">&lt;[<span class="number">700</span>]&gt; evalsupport module end</span><br><span class="line">&lt;[<span class="number">1</span>]&gt; evaltime module start</span><br><span class="line">&lt;[<span class="number">2</span>]&gt; ClassOne body</span><br><span class="line">&lt;[<span class="number">6</span>]&gt; ClassTwo body</span><br><span class="line">&lt;[<span class="number">7</span>]&gt; ClassThree body</span><br><span class="line">&lt;[<span class="number">200</span>]&gt; deco_alpha</span><br><span class="line">&lt;[<span class="number">9</span>]&gt; ClassFour body</span><br><span class="line">&lt;[<span class="number">11</span>]&gt; ClassOne tests ..............................</span><br><span class="line">&lt;[<span class="number">3</span>]&gt; ClassOne.__init__</span><br><span class="line">&lt;[<span class="number">5</span>]&gt; ClassOne.method_x</span><br><span class="line">&lt;[<span class="number">12</span>]&gt; ClassThree tests ..............................</span><br><span class="line">&lt;[<span class="number">300</span>]&gt; deco_alpha:inner_1</span><br><span class="line">&lt;[<span class="number">13</span>]&gt; ClassFour tests ..............................</span><br><span class="line">&lt;[<span class="number">10</span>]&gt; ClassFour.method_y</span><br><span class="line">&lt;[<span class="number">14</span>]&gt; evaltime module end</span><br><span class="line">&lt;[<span class="number">4</span>]&gt; ClassOne.__del__  <span class="comment"># 程序结束时，绑定在全局变量one上的ClassOne实例才会被垃圾回收程序回收</span></span><br></pre></td></tr></table></figure><p>第二个示例主要想说明的是，类装饰器可能对子类没有影响。我们把ClassFour定义为ClassThree的子类。ClassThree类上依附的<code>@deco_alpha</code>装饰器把<code>method_y</code>方法替换掉了，但是这对ClassFour类根本没有影响。当然，如果<code>ClassFour.method_y</code>方法使用super调用<code>ClassThree.method_y</code>方法，我们便会看到装饰器起作用，执行<code>inner_1</code>函数。</p><p>与此不同的是，如果想定制整个类层次结构，而不是一次只制定一个类，使用元类更高效。</p><h1 id="元类基础知识">元类基础知识</h1><p>元类是制造类的工厂，不过不是函数，而是类。根据Python对象模型，类是对象，因此类肯定是另外某个类的实例。默认情况下，Python中类是type类的实例。也就是说，type是大多数内置的类和用户定义的类的元类：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'spam'</span>.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">str</span>.<span class="title">__class__</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">type</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">from</span> <span class="title">bulkfood_v6</span> <span class="title">import</span> <span class="title">LineItem</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">LineItem</span>.<span class="title">__class__</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">type</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span>.<span class="title">__class__</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">type</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>注意，我没有说str和LineItem继承自type。我的意思是，str和LineItem是type的实例。这两个类是object的子类。下图可能有助于你理清这个奇怪的现象。</p><img src="http://www.plantuml.com/plantuml/svg/NOn12eCm50Ntdk9TuES09MGlz18nVM9AVnJpDuA7hqGArUKCp4pvHL0Nsw3KWMkNFh5MsBOGtYijDX52rvJ87Z0FRoOxXNVkpWxLrZzwviBUg7WSnrognPA8UJoUPmc_YqYhBk8NVW40"><p>object类和type类之间的关系很独特：object是type的实例，而type是object的子类。这种关系很“神奇”，无法使用Python代码表述，因为定义其中一个之前另一个必须存在。type是自身的实例这一点也很神奇。</p><p>除了type，标准库中还有一些别的元类，例如ABCMeta和Enum。如下所示，Iterable所属的类是ABCMeta。Iterable是抽象类，而ABCMeta不是——不管怎样，Iterable是ABCMeta的实例。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> collections</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>collections.Iterable.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">abc</span>.<span class="title">ABCMeta</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">import</span> <span class="title">abc</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">abc</span>.<span class="title">ABCMeta</span>.<span class="title">__class__</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">type</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">abc</span>.<span class="title">ABCMeta</span>.<span class="title">__mro__</span></span></span><br><span class="line"><span class="class"><span class="params">(&lt;class <span class="string">'abc.ABCMeta'</span>&gt;, &lt;class <span class="string">'type'</span>&gt;, &lt;class <span class="string">'object'</span>&gt;)</span></span></span><br></pre></td></tr></table></figure><p>向上追溯，ABCMeta最终所属的类也是type。所有类都直接或间接地是type的实例，不过只有元类同时也是type的子类。<strong>若想理解元类，一定要知道这种关系：元类（如ABCMeta））从type继承了构建类的能力。</strong></p><img src="http://www.plantuml.com/plantuml/svg/FOmn3eCm40Hxl-8-00-84598bIAFk3CRGOG1-Iu5KXuVOmFbhcPc67iGmceR1GH1T7vYLR9j1JLDW74-sjQng4NsHaz3P9dW2bJNjCW7texzgogwTuzNKkcM6lgLqbpUgLBGGbsX4zzRvvdTSLRZsIExVm00"><p>我们要抓住的重点是，<strong>所有类都是type的实例，但是元类还是type的子类</strong>，因此可以作为制造类的工厂。具体来说，元类可以通过实现<code>__init__</code>方法定制实例。元类的<code>__init__</code>方法可以做到类装饰器能做的任何事情，但是作用更大，如接下来的示例。</p><figure class="highlight python"><figcaption><span>evaltime_meta.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> evalsupport <span class="keyword">import</span> deco_alpha</span><br><span class="line"><span class="keyword">from</span> evalsupport <span class="keyword">import</span> MetaAleph</span><br><span class="line"></span><br><span class="line">print(<span class="string">'&lt;[1]&gt; evaltime_meta module start'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@deco_alpha</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassThree</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[2]&gt; ClassThree body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_y</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[3]&gt; ClassThree.method_y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassFour</span><span class="params">(ClassThree)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[4]&gt; ClassFour body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_y</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[5]&gt; ClassFour.method_y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassFive</span><span class="params">(metaclass=MetaAleph)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[6]&gt; ClassFive body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[7]&gt; ClassFive.__init__'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_z</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[8]&gt; ClassFive.method_y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassSix</span><span class="params">(ClassFive)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[9]&gt; ClassSix body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_z</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[10]&gt; ClassSix.method_y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'&lt;[11]&gt; ClassThree tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    three = ClassThree()</span><br><span class="line">    three.method_y()</span><br><span class="line">    print(<span class="string">'&lt;[12]&gt; ClassFour tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    four = ClassFour()</span><br><span class="line">    four.method_y()</span><br><span class="line">    print(<span class="string">'&lt;[13]&gt; ClassFive tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    five = ClassFive()</span><br><span class="line">    five.method_z()</span><br><span class="line">    print(<span class="string">'&lt;[14]&gt; ClassSix tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    six = ClassSix()</span><br><span class="line">    six.method_z()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'&lt;[15]&gt; evaltime_meta module end'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> evaltime_meta</span><br><span class="line">&lt;[<span class="number">100</span>]&gt; evalsupport module start</span><br><span class="line">&lt;[<span class="number">400</span>]&gt; MetaAleph body</span><br><span class="line">&lt;[<span class="number">700</span>]&gt; evalsupport module end</span><br><span class="line">&lt;[<span class="number">1</span>]&gt; evaltime_meta module start</span><br><span class="line">&lt;[<span class="number">2</span>]&gt; ClassThree body</span><br><span class="line">&lt;[<span class="number">200</span>]&gt; deco_alpha</span><br><span class="line">&lt;[<span class="number">4</span>]&gt; ClassFour body</span><br><span class="line">&lt;[<span class="number">6</span>]&gt; ClassFive body</span><br><span class="line">&lt;[<span class="number">500</span>]&gt; MetaAleph.__init__  <span class="comment"># 创建ClassFive时调用了MetaAleph.__init__方法</span></span><br><span class="line">&lt;[<span class="number">9</span>]&gt; ClassSix body</span><br><span class="line">&lt;[<span class="number">500</span>]&gt; MetaAleph.__init__  <span class="comment"># 创建ClassSix时也调用了</span></span><br><span class="line">&lt;[<span class="number">15</span>]&gt; evaltime_meta module end</span><br></pre></td></tr></table></figure><p>Python解释器计算ClassFive类的定义体时没有调用type构建具体的类定义体，而是调用MetaAleph类。<code>MetaAleph.__init__</code>方法有四个参数。</p><p>self：这是要初始化的类对象。编写元类时，通常会把self参数改为cls，表明要构建的实例是类。</p><p>name、bases、dict：与构建类时传给type的参数一样。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python evaltime_meta.py</span><br><span class="line">&lt;[<span class="number">100</span>]&gt; evalsupport module start</span><br><span class="line">&lt;[<span class="number">400</span>]&gt; MetaAleph body</span><br><span class="line">&lt;[<span class="number">700</span>]&gt; evalsupport module end</span><br><span class="line">&lt;[<span class="number">1</span>]&gt; evaltime_meta module start</span><br><span class="line">&lt;[<span class="number">2</span>]&gt; ClassThree body</span><br><span class="line">&lt;[<span class="number">200</span>]&gt; deco_alpha</span><br><span class="line">&lt;[<span class="number">4</span>]&gt; ClassFour body</span><br><span class="line">&lt;[<span class="number">6</span>]&gt; ClassFive body</span><br><span class="line">&lt;[<span class="number">500</span>]&gt; MetaAleph.__init__</span><br><span class="line">&lt;[<span class="number">9</span>]&gt; ClassSix body</span><br><span class="line">&lt;[<span class="number">500</span>]&gt; MetaAleph.__init__</span><br><span class="line">&lt;[<span class="number">11</span>]&gt; ClassThree tests ..............................</span><br><span class="line">&lt;[<span class="number">300</span>]&gt; deco_alpha:inner_1  <span class="comment"># 装饰器依附到ClassThree类上之后，method_y方法被替换了</span></span><br><span class="line">&lt;[<span class="number">12</span>]&gt; ClassFour tests ..............................</span><br><span class="line">&lt;[<span class="number">5</span>]&gt; ClassFour.method_y  <span class="comment"># 虽然ClassFour是ClassThree的子类，但是没有依附装饰器，不受影响</span></span><br><span class="line">&lt;[<span class="number">13</span>]&gt; ClassFive tests ..............................</span><br><span class="line">&lt;[<span class="number">7</span>]&gt; ClassFive.__init__</span><br><span class="line">&lt;[<span class="number">600</span>]&gt; MetaAleph.__init__:inner_2  <span class="comment"># MetaAleph.__init__方法替换了ClassFive.method_z方法</span></span><br><span class="line">&lt;[<span class="number">14</span>]&gt; ClassSix tests ..............................</span><br><span class="line">&lt;[<span class="number">7</span>]&gt; ClassFive.__init__</span><br><span class="line">&lt;[<span class="number">600</span>]&gt; MetaAleph.__init__:inner_2  <span class="comment"># ClassSix.method_z方法也被替换了</span></span><br><span class="line">&lt;[<span class="number">15</span>]&gt; evaltime_meta module end</span><br></pre></td></tr></table></figure><p>注意，ClassSix类没有直接引用MetaAleph类，但是却受到了影响，因为它是ClassFive的子类，进而也是MetaAleph类的实例，所有由<code>MetaAleph.__init__</code>方法初始化。</p><p>如果想进一步定制类，可以在元类中实现<code>__new__</code>方法。不过，通常情况下实现<code>__init__</code>方法就够了。</p><h1 id="定制描述符的元类">定制描述符的元类</h1><p>现在，我们可以实践这些理论了。我们将创建一个元类，让描述符以最佳的方式自动创建储存属性的名称。</p><figure class="highlight python"><figcaption><span>model_v7.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> model_v5 <span class="keyword">import</span> Validate, Quantity, NonBlank</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EntityMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="string">"""元类，用于创建带有验证字段的业务实体"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, name, bases, attr_dict)</span>:</span></span><br><span class="line">        super().__init__(name, bases, attr_dict)  <span class="comment"># 调用type.__init__方法</span></span><br><span class="line">        <span class="keyword">for</span> key, attr <span class="keyword">in</span> attr_dict.items():  <span class="comment"># 修改storage_name，与@entity装饰器的逻辑一样</span></span><br><span class="line">            <span class="keyword">if</span> isinstance(attr, Validate):</span><br><span class="line">                type_name = type(attr).__name__</span><br><span class="line">                attr.storage_name = <span class="string">'_&#123;&#125;#&#123;&#125;'</span>.format(type_name, key)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span><span class="params">(metaclass=EntityMeta)</span>:</span>  <span class="comment"># 这个类只是为了用起来便利：用户直接继承Entity类即可</span></span><br><span class="line">    <span class="string">"""带有验证字段的业务实体"""</span>         <span class="comment"># 无需关心EntityMeta元类，甚至不需要知道它的存在</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>bulkfood_v7.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> model_v7 <span class="keyword">as</span> model</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span><span class="params">(model.Entity)</span>:</span>  <span class="comment"># 继承Entity类</span></span><br><span class="line">    description = model.NonBlank()</span><br><span class="line">    weight = model.Quantity()</span><br><span class="line">    price = model.Quantity()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, price)</span>:</span></span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br></pre></td></tr></table></figure><img src="http://www.plantuml.com/plantuml/svg/bL71QeGm5BpdAm9xAyr-G16XXHuAtK8fz1go-ggX9X7pR2dgl_TLZRfg2_La9ZFptanodG87K-8NDs3EKB6aKDxpsnhT2xfAPS2ZA0MVLBgaSnppXd7wf4nSRP44FoS_KALL1dgWCO2vIplYQQjHoZMQmGxeUx1ZwkonKWdoLrNeL26a-qjif1TW4smw_Z7waFUGxxbM5ZMb_jjtetjozgvGzft_L_YeBJmWc51VC3e45-tiS1DMEto2pd9SWMMbazyg3hFkU-e9KD6Mn58zlDVQ9BnuxrRCnRF54xH2JCMjyP27pSqASJN7lg5fGo0fh-c_pq6ZfqAtz4KpH9okH5sADXv3icNMut54IHv5sdfKDW7ktkBu6m00"><h1 id="元类的特殊方法__prepare__">元类的特殊方法<code>__prepare__</code></h1><p>在某些应用中，可能需要知道类的属性定义的顺序。例如，对读写CSV文件的库来说，用户定义的类可能想把类中按顺序声明的字段与CSV文件中各列的顺序对应起来。</p><p>type构造方法及元类的<code>__new__</code>和<code>__init__</code>方法都会收到要计算的类的定义体，形式是名称到属性的映像。然而在默认情况下，那个映射是字典；也就是说，元类或装饰器获得映像时，属性在类定义体中的顺序已经丢失了。</p><p>这个问题的解决方法是，使用Python3引入的特殊方法<code>__prepare__</code>。这个特殊方法只在元类中有用，而且必须声明为类方法（即，要使用@classmethod装饰器定义）。解释器调用元类的<code>__new__</code>方法之前会先调用<code>__prepare__</code>方法，使用类定义体中的属性创建映射。<code>__prepare__</code>方法的第一个参数是元类，随后两个参数分别是要构建的类的映射和基类组成的元组，返回值必须是映射。元类构建新类时，<code>__prepare__</code>方法返回的映射会传给<code>__new__</code>方法的最后一个参数，然后再传给<code>__init__</code>方法。</p><p>理论听起来很复杂，但是我见过的<code>__prepare__</code>方法都十分简单。</p><figure class="highlight python"><figcaption><span>model_v8.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> model_v5 <span class="keyword">import</span> Validate, Quantity, NonBlank</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EntityMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="string">"""元类，用于创建带有验证字段的业务实体"""</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__prepare__</span><span class="params">(cls, name, bases)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> collections.OrderedDict()  <span class="comment"># 返回空的OrderDict实例</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, name, bases, attr_dict)</span>:</span>  <span class="comment"># OrderedDict实例会绑定到attr_dict上</span></span><br><span class="line">        super().__init__(name, bases, attr_dict)</span><br><span class="line">        cls._field_names = []  <span class="comment"># 在要构建的类中创建一个_field_names属性</span></span><br><span class="line">        <span class="keyword">for</span> key, attr <span class="keyword">in</span> attr_dict.items():  <span class="comment"># 因此for循环迭代attr_dict时会按添加的顺序迭代</span></span><br><span class="line">            <span class="keyword">if</span> isinstance(attr, Validate):</span><br><span class="line">                type_name = type(attr).__name__</span><br><span class="line">                attr.storage_name = <span class="string">'_&#123;&#125;#&#123;&#125;'</span>.format(type_name, key)</span><br><span class="line">                cls._field_names.append(key)  <span class="comment"># 把各个Validate字段添加到_field_names</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span><span class="params">(metaclass=EntityMeta)</span>:</span></span><br><span class="line">    <span class="string">"""带有验证字段的业务实体"""</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">field_names</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> cls._field_names:</span><br><span class="line">            <span class="keyword">yield</span> name</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>bulkfood_v8.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> model_v8 <span class="keyword">as</span> model  <span class="comment"># 从v8中导入，其他不变</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span><span class="params">(model.Entity)</span>:</span></span><br><span class="line">    description = model.NonBlank()</span><br><span class="line">    weight = model.Quantity()</span><br><span class="line">    price = model.Quantity()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, price)</span>:</span></span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> bulkfood_v8 <span class="keyword">import</span> LineItem</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name <span class="keyword">in</span> LineItem.field_names():</span><br><span class="line"><span class="meta">... </span>    print(name)</span><br><span class="line">...</span><br><span class="line">description</span><br><span class="line">weight</span><br><span class="line">price</span><br></pre></td></tr></table></figure><p>在现实世界中，框架和库会使用元类协助程序员执行很多任务，例如：</p><ul><li>验证属性</li><li>一次把装饰器依附到多个类上</li><li>序列化对象或转换数据</li><li>对象关系映射</li><li>基于对象的持久存储</li><li>动态转换使用其他语言编写的类结构</li></ul><h1 id="类作为对象">类作为对象</h1><p>Python数据模型为每个类定义了很多属性，其中三个属性在本书中已经见过多次：<code>__mro__</code>、<code>__class__</code>和<code>__name__</code>。此外，还有以下属性。</p><ul><li><p><code>cls.__bases__</code></p><p>由类的基类组成的元组。</p></li><li><p><code>cls.__qualname__</code></p><p>Python3.3新引入的属性，其值是类或函数的限定名称，即从模块的全局作用域到类的点分路径。</p></li><li><p><code>cls.__subclasses__()</code></p><p>这个方法返回一个列表，包含类的直接子类。这个方法的实现使用弱引用，防止在超类和子类之间出现循环引用（子类在<code>__bases__</code>属性中存储指向超类的强引用）。这个方法返回的列表中是内存里现存的子类。</p></li><li><p><code>cls.mro()</code></p><p>构建类时，如果需要获取存储在类属性<code>__mro__</code>中的超类元组，解释器会调用这个方法。元类可以覆盖这个方法，定制要构建的类解析方法的顺序。</p></li></ul><p>dir函数不会列出本节提到的任何一个属性。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> metaprogramming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>属性描述符</title>
      <link href="/notes/fluent-python/attribute-descriptors/"/>
      <url>/notes/fluent-python/attribute-descriptors/</url>
      
        <content type="html"><![CDATA[<p>描述符是对多个属性运用相同存取逻辑的一种方式。描述符是实现了特定协议的类，这个协议包括<code>__get__</code>、<code>__set__</code>和<code>__delete__</code>方法。property类实现了完整的描述符协议。通常，可以只实现部分协议。除了特性之外，使用描述符的还有方法及classmethod和staticmethod装饰器。</p><h1 id="描述符示例验证属性">描述符示例：验证属性</h1><h2 id="lineitem类第3版一个简单的描述符">LineItem类第3版：一个简单的描述符</h2><p>实现了<code>__get__</code>、<code>__set__</code>或<code>__delete__</code>方法的类是描述符。描述符的用法是，创建一个实例，作为另一个类的类属性。</p><p>把quantity特性工厂函数重构成Quantity描述符类。LineItem类的UML示意图如下。</p><img src="http://www.plantuml.com/plantuml/svg/XP0zIyD06CVt-nGF7GK3xIWXk-3YNZZEz6mFaal9NH490GSNApPhwH0GGHSvqaryQRzCaylcL_1CsgGKnDkU__rVuETwH0Wudn0kcRm6snvGuOPiB8FGSI12O9um1nbIp8bFAo7ogHm5WnWmPfn9Z0zLGN_56BbL-ndZz5HIVrktMs01h-uhoeOZ2T5s9gx4SSXSUg3zCoic5pAGn3ExF90KEaMIbEjClpxhvSVtvo9NgPvbVTx8-KDIAgKNj-Q_0qG0x-wITtEj7kjOCPss2PLkLlTzdZzbnNosUNitbdoP5ZSl-oqznBjWDL0Hxu7bqKjfDIHG0znoMZmdKAgL_bBrUjtREktZetqhnXKY0-5lHqqMuny0"><p>weight和price是依附在LineItem类上的Quantity类的实例，不过LineItem实例也有自己的weight和price属性，存储着相应的值。即LineItem会有两个weight属性：一个是LineItem的类属性（UML图中的<u>weight</u>和<u>price</u>，他们是描述符Quantity的实例），一个是LineItem对象的实例属性（UML图中的weight {storage}和price {storage}，他们是float值）。</p><a id="more"></a><p>Quantity实例是LineItem类的类属性，这一点一定要理解。下图的涂鸦展示了描述符类、LineItem类以及它们的实例之间的关系。</p><p><img src="/uploads/image/fluent-python/MGN-sketch.png"></p><p>在图中，类被画成了“机器”（有操纵杆和刻度盘的设备），用于生产小怪兽（实例）。小怪兽与生产它的机器具有相同的颜色。在这个示例中，LineItem生产了三个小怪兽，每个小怪兽有3个单元格，表示三个属性（description、weight和price）。Quantity实例是描述符，因此有个放大镜，用于获取值（<code>__get__</code>），以及一个手抓，用于设置值（<code>__set__</code>）。</p><figure class="highlight python"><figcaption><span>bulkfood_v3.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, storage_name)</span>:</span></span><br><span class="line">        self.storage_name = storage_name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span>  <span class="comment"># 基于协议实现</span></span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:  <span class="comment"># 必须直接托管__dict__属性，若使用内置的setattr函数，会再次触发</span></span><br><span class="line">            instance.__dict__[self.storage_name] = value  <span class="comment"># __set__方法，导致无限递归</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">    weight = Quantity(<span class="string">'weight'</span>)  <span class="comment"># 绑定给weight属性，storage_name='weight'</span></span><br><span class="line">    price = Quantity(<span class="string">'price'</span>)  <span class="comment"># 小缺点，重复输入了属性名称</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, price)</span>:</span></span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> bulkfood_v3 <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>truffle = LineItem(<span class="string">'White truffle'</span>, <span class="number">100</span>, <span class="number">0</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"/Users/cws/Desktop/bulkfood_v3.py"</span>, line <span class="number">19</span>, <span class="keyword">in</span> __init__</span><br><span class="line">    self.price = price</span><br><span class="line">  File <span class="string">"/Users/cws/Desktop/bulkfood_v3.py"</span>, line <span class="number">10</span>, <span class="keyword">in</span> __set__</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line">ValueError: value must be &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure><p>你可能想把各个托管属性的值直接存在描述符实例中，但是这种做法是错误的。也就是说，在<code>__set__</code>方法中，应该像下面这样写：<code>instance.__dict__[self.storage_name] = value</code>；而不能试图使用下面这种错误的写法：<code>self.__dict__[self.storage_name] = value</code>。这里，self是描述符实例，它其实是托管类的类属性。同一时刻，内存中可能有几千个LineItem实例，不过只会有两个描述符实例：LineItem.weight和LineItem.price。因此，存储在描述符实例中的数据，其实会变成LineItem类的类属性，从而由全部LineItem实例共享。</p><p>示例有个缺点，在托管类的定义体中实例化描述符时要重复输入属性的名称。如果能像<code>weight = Quantity()</code>这样声明就好了。可问题是，赋值语句右手边的表达式先执行，而此时变量还不存在。Quantity()表达式计算的结果是创建描述符实例，而此时Quantity类中的代码无法猜出要把描述符绑定给哪个变量。</p><h2 id="lineitem类第4版自动获取储存属性的名称">LineItem类第4版：自动获取储存属性的名称</h2><p>本节介绍一个不太优雅但是可行的方案，解决重复输入名称的问题。更好的解决方案是使用类装饰器或元类。</p><p>为了避免在描述符声明语句中重复输入属性名，我们将为每个Quantity实例的storage_name属性生成一个独一无二的字符串。即实例属性weight在<code>__dict__</code>中的键不是'weight'，而是由描述符生成的一个字符串，通过描述符的<code>__set__</code>或<code>__get__</code>方法访问该属性。</p><figure class="highlight python"><figcaption><span>bulkfood_v4.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span>:</span></span><br><span class="line">    __counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        cls = self.__class__</span><br><span class="line">        prefix = cls.__name__</span><br><span class="line">        index = cls.__counter</span><br><span class="line">        self.storage_name = <span class="string">'_&#123;&#125;#&#123;&#125;'</span>.format(prefix, index)  <span class="comment"># index独一无二</span></span><br><span class="line">        cls.__counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> getattr(instance, self.storage_name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:</span><br><span class="line">            setattr(instance, self.storage_name, value)  <span class="comment"># 这里可以使用内置的setattr函数</span></span><br><span class="line">        <span class="keyword">else</span>:                                            <span class="comment"># 因为存储属性的名称不同，不会无限递归</span></span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">    weight = Quantity()</span><br><span class="line">    price = Quantity()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, price)</span>:</span></span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> bulkfood_v4 <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coconuts = LineItem(<span class="string">'Brazilian coconut'</span>, <span class="number">20</span>, <span class="number">17.95</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coconuts.weight, coconuts.price  <span class="comment"># 使用描述符</span></span><br><span class="line">(<span class="number">20</span>, <span class="number">17.95</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(coconuts, <span class="string">'_Quantity#0'</span>)  <span class="comment"># 读取储存属性</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><p>注意，<code>__get__</code>方法有三个参数：self、instance和owner。owner参数是托管类（如LineItem）的引用，通过描述符从托管类中获取属性时用得到。如果使用LineItem.weight从类中获取托管属性，描述符的<code>__get__</code>方法接收到的instance参数值是None。因此，下述控制台会话才会抛出AttributeError异常：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> bulkfood_v4 <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>LineItem.weight</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"/Users/cws/Desktop/bulkfood_v4.py"</span>, line <span class="number">12</span>, <span class="keyword">in</span> __get__</span><br><span class="line">    <span class="keyword">return</span> getattr(instance, self.storage_name)</span><br><span class="line">AttributeError: <span class="string">'NoneType'</span> object has no attribute <span class="string">'_Quantity#0'</span></span><br></pre></td></tr></table></figure><p>抛出AttributeError异常是实现<code>__get__</code>方法的方式之一，如果选择这么做，应该修改错误消息，去掉令人困惑的NoneType和_Quantity#0，这是实现细节。把错误消息改成&quot;'LineItem' class has no such attribute&quot;更好。最好能给出缺少的属性名，但是在这个示例中，描述符不知道托管属性的名称，因此目前只能做到这样。</p><p>此外，为了给用户提供内省和其他元编程技术支持，通过类访问托管属性时，最好让<code>__get__</code>方法返回描述符实例。</p><figure class="highlight python"><figcaption><span>bulkfood_v4.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改后的__get__方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> self  <span class="comment"># 如果不是通过实例调用，返回描述符自身</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> getattr(instance, self.storage_name)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> bulkfood_v4 <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>LineItem.price</span><br><span class="line">&lt;bulkfood_v4.Quantity object at <span class="number">0x10cc31550</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>br_nuts = LineItem(<span class="string">'Brazil nuts'</span>, <span class="number">10</span>, <span class="number">34.95</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>br_nuts.price</span><br><span class="line"><span class="number">34.95</span></span><br></pre></td></tr></table></figure><p>你可能觉得就为了管理几个属性而编写这么多代码不值得，但是要知道，描述符逻辑现在被抽象到单独的代码单元中了。通常，我们不会在使用描述符的模块中定义描述符，而是在一个单独的实用工具模块中定义，以便在整个应用中使用——如果开发的是框架，甚至会在多个应用中使用。</p><h2 id="特性工厂函数和描述符类的比较">特性工厂函数和描述符类的比较</h2><p>特性工厂函数若想实现增强的描述符类并不难。<code>__counter</code>变量的实现方式是个难点，不过我们可以把它定义成工厂函数对象的属性，以便在多次调用之间持续存在。</p><figure class="highlight python"><figcaption><span>bulkfood_v4prop.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quantity</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        quantity.counter += <span class="number">1</span></span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        quantity.counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    storage_name = <span class="string">'_&#123;&#125;:&#123;&#125;'</span>.format(<span class="string">'quantity'</span>, quantity.counter)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qty_getter</span><span class="params">(instance)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> getattr(instance, storage_name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qty_setter</span><span class="params">(instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:</span><br><span class="line">            setattr(instance, storage_name, value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> property(qty_getter, qty_setter)</span><br></pre></td></tr></table></figure><p>你更喜欢哪种方式？我喜欢描述符类那种方式，主要有下列两个原因。</p><ul><li>描述符类可以用子类扩展；若想重用工厂函数中的代码，除了复制粘贴，很难有其他方法。</li><li>与特性工厂函数使用函数属性和闭包保持状态相比，在类属性和实例属性中保持状态更易于理解。</li></ul><p>总之，从某种程度上来讲，特性工厂函数模式较简单，可是描述符类方式更易扩展，而且应用也更广泛。</p><h2 id="lineitem类第5版一种新型描述符">LineItem类第5版：一种新型描述符</h2><p>我们虚构的有机食物网店遇到一个问题：不知怎么回事儿，有个商品的描述信息为空，导致无法下订单。为了避免这个问题，我们要再创建一个描述符，NonBlank。在设计NonBlank的过程中，我们发现，它与Quantity描述符很像，只是验证逻辑不同。</p><p>回想Quantity的功能，我们注意到它做了两件不同的事：管理托管实例中的储存属性，以及验证用于设置那两个属性的值。由此可知，我们可以重构，并创建两个基类。</p><img src="http://www.plantuml.com/plantuml/svg/ZPBVIW915CRlzodc1No14A4U88YWgs2PTYTTMcTZTmn2ZUoFuIBfXOeL61AeIPfBteI5JpCpwrMlqBZZcffGStS-VkUSxvmpcWaT1socYBLBB1l64OX6TUHejd4iubWCf1KWdgfgLWeJP0UH8r4LmoGAX7GIaOIbPmLdO8EewgeQHsj49n2p2hO80YOw91l0l-bIjyFxJLxEquiExTMfrs3dRNv_nKebVppWBotkZVQnFtpqXqyIdrA23K057ZZ4XXe1Uz0qT4YGldwYNpwMn7HO9WjEPdL2exOHJmYdhF1ClUh2ueIjgKltq_UQj5UMBbjv_b0xcxLWjNVsLXNgu99NEdHyFMcEUCMJCEqt-Er0L0ZxpUbWqactwB_clZwAp7NzN54ej5rXXJeVtScM4f-RrOAxxgGW9WOv_MC52oFAl6qBRvaG7u7_9ovzeKpaP_tAmY4oaSZSqweUzlm6"><p>Validate、Quantity和NonBlank三个类之间的关系体现了模板方法设计模式。具体而言，<code>validate.__set__</code>方法正是模板方法的例证：</p><blockquote><p>一个模板方法用一些抽象的操作定义一个算法，而子类将重定义这些操作以提供具体的行为。</p></blockquote><figure class="highlight python"><figcaption><span>model_v5.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoStorage</span>:</span></span><br><span class="line">    __counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        cls = self.__class__</span><br><span class="line">        prefix = cls.__name__</span><br><span class="line">        index = cls.__counter</span><br><span class="line">        self.storage_name = <span class="string">'_&#123;&#125;#&#123;&#125;'</span>.format(prefix, index)</span><br><span class="line">        cls.__counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> getattr(instance, self.storage_name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        setattr(instance, self.storage_name, value)  <span class="comment"># 无验证</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Validate</span><span class="params">(abc.ABC, AutoStorage)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        value = self.validate(instance, value)  <span class="comment"># 委托validate方法</span></span><br><span class="line">        super().__set__(instance, value)  <span class="comment"># 然后把返回的value传给超类的__set__方法，存储值</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, instance, value)</span>:</span>  <span class="comment"># 抽象方法</span></span><br><span class="line">        <span class="string">"""return validated value or raise ValueError"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span><span class="params">(Validate)</span>:</span></span><br><span class="line">    <span class="string">"""a number greater than zero"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonBlank</span><span class="params">(Validate)</span>:</span></span><br><span class="line">    <span class="string">"""a string with at least one non-space character"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        value = value.strip()</span><br><span class="line">        <span class="keyword">if</span> len(value) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value cannot be empty or blank'</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>bulkfood_v5.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> model_v5 <span class="keyword">as</span> model</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">    description = model.NonBlank()  <span class="comment"># 除此之外的其余代码不变</span></span><br><span class="line">    weight = model.Quantity()</span><br><span class="line">    price = model.Quantity()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, price)</span>:</span></span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br></pre></td></tr></table></figure><p>本章演示了<strong>描述符的典型用途——管理数据属性。</strong>这种描述符也叫覆盖型描述符，因为描述符的<code>__set__</code>方法使用托管实例中的同名属性覆盖（即插手接管）了要设置的属性。不过也有非覆盖型描述符。</p><h1 id="覆盖型与非覆盖型描述符对比">覆盖型与非覆盖型描述符对比</h1><p><strong>Python存取属性的方式特别不对等。通过实例读取属性时，通常返回的是实例中定义的属性；但是，如果实例中没有指定的属性，那么会获取类属性。而为实例中的属性赋值时，通常会在实例中创建属性，根本不影响类。</strong></p><p>这种不对等的处理方式对描述符也有影响。其实，根据是否定义<code>__set__</code>方法，描述符可分为两大类。</p><figure class="highlight python"><figcaption><span>descriptorkinds.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">### 辅助函数，仅用于显示 ###</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cls_name</span><span class="params">(obj_or_cls)</span>:</span></span><br><span class="line">    cls = type(obj_or_cls)</span><br><span class="line">    <span class="keyword">if</span> cls <span class="keyword">is</span> type:</span><br><span class="line">        cls = obj_or_cls</span><br><span class="line">    <span class="keyword">return</span> cls.__name__.split(<span class="string">'.'</span>)[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(obj)</span>:</span></span><br><span class="line">    cls = type(obj)</span><br><span class="line">    <span class="keyword">if</span> cls <span class="keyword">is</span> type:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;class &#123;&#125;&gt;'</span>.format(obj.__name__)</span><br><span class="line">    <span class="keyword">elif</span> cls <span class="keyword">in</span> [type(<span class="literal">None</span>), int]:</span><br><span class="line">        <span class="keyword">return</span> repr(obj)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;&#123;&#125; object&gt;'</span>.format(cls_name(obj))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_args</span><span class="params">(name, *args)</span>:</span></span><br><span class="line">    pseudo_args = <span class="string">', '</span>.join(display(x) <span class="keyword">for</span> x <span class="keyword">in</span> args)</span><br><span class="line">    print(<span class="string">'-&gt; &#123;&#125;.__&#123;&#125;__(&#123;&#125;)'</span>.format(cls_name(args[<span class="number">0</span>]), name, pseudo_args))</span><br><span class="line"></span><br><span class="line"><span class="comment">### 对这个示例重要的类 ###</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Overriding</span>:</span></span><br><span class="line">    <span class="string">"""覆盖型描述符，也称数据描述符或强制描述符"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        print_args(<span class="string">'get'</span>, self, instance, owner)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        print_args(<span class="string">'set'</span>, self, instance, value)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OverridingNoGet</span>:</span></span><br><span class="line">    <span class="string">"""没有``__get__``方法的覆盖型描述符"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        print_args(<span class="string">'set'</span>, self, instance, value)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonOverriding</span>:</span>  <span class="comment"># 没有__set__方法</span></span><br><span class="line">    <span class="string">"""非覆盖型描述符，也称非数据描述符或遮盖型描述符"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        print_args(<span class="string">'get'</span>, self, instance, owner)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Managed</span>:</span>  <span class="comment"># 托管类，使用各个描述符类的一个实例</span></span><br><span class="line">    over = Overriding()</span><br><span class="line">    over_no_get = OverridingNoGet()</span><br><span class="line">    non_over = NonOverriding()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self)</span>:</span>  <span class="comment"># 方法也是描述符</span></span><br><span class="line">        print(<span class="string">'-&gt; Managed.spam(&#123;&#125;)'</span>.format(display(self)))</span><br></pre></td></tr></table></figure><h2 id="覆盖型描述符">覆盖型描述符</h2><p>实现<code>__set__</code>方法的描述符属于覆盖型描述符，会覆盖对实例属性的赋值操作。特性也是覆盖型描述符：如果没有提供设值函数，property类中的<code>__set__</code>方法会抛出AttributeError异常，指明那个属性是只读的。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> descriptorkinds <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Managed()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over  <span class="comment"># 触发__get__方法，第二个参数的值是托管实例</span></span><br><span class="line">-&gt; Overriding.__get__(&lt;Overriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Managed.over  <span class="comment"># Managed.over触发的__get__方法，第二个参数的值是None</span></span><br><span class="line">-&gt; Overriding.__get__(&lt;Overriding object&gt;, None, &lt;class Managed&gt;)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over = <span class="number">7</span>  <span class="comment"># 赋值</span></span><br><span class="line">-&gt; Overriding.__set__(&lt;Overriding object&gt;, &lt;Managed object&gt;, 7)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over  <span class="comment"># 读取</span></span><br><span class="line">-&gt; Overriding.__get__(&lt;Overriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.__dict__[<span class="string">'over'</span>] = <span class="number">7</span>  <span class="comment"># 跳过描述符赋值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vars(obj)</span><br><span class="line">&#123;<span class="string">'over'</span>: <span class="number">7</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over  <span class="comment"># 即使有名为over的实例属性，Managed.over描述符仍会覆盖读取obj.over</span></span><br><span class="line">-&gt; Overriding.__get__(&lt;Overriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;)</span><br></pre></td></tr></table></figure><h2 id="没有__get__方法的覆盖型描述符">没有<code>__get__</code>方法的覆盖型描述符</h2><p>描述符可以只实现<code>__set__</code>方法，此时，只有写操作由描述符处理。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over_no_get  <span class="comment"># 因为OverridingNoGet描述符没有__get__方法，读操作返回的是描述符实例</span></span><br><span class="line">&lt;descriptorkinds.OverridingNoGet object at <span class="number">0x10fd71860</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Managed.over_no_get</span><br><span class="line">&lt;descriptorkinds.OverridingNoGet object at <span class="number">0x10fd71860</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over_no_get = <span class="number">7</span>  <span class="comment"># 有__set__方法，赋值时会触发</span></span><br><span class="line">-&gt; OverridingNoGet.__set__(&lt;OverridingNoGet object&gt;, &lt;Managed object&gt;, 7)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over_no_get  <span class="comment"># 由于__set__方法没有存储值，只是打印了消息，此处依然返回实例对象</span></span><br><span class="line">&lt;descriptorkinds.OverridingNoGet object at <span class="number">0x10fd71860</span>&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.__dict__[<span class="string">'over_no_get'</span>] = <span class="number">9</span>  <span class="comment"># 跳过描述符赋值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over_no_get  <span class="comment"># 读值操作，由于没有__get__方法，实例属性遮盖了描述符</span></span><br><span class="line"><span class="number">9</span>                    <span class="comment"># 但是只有读操作是如此</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over_no_get = <span class="number">7</span></span><br><span class="line">-&gt; OverridingNoGet.__set__(&lt;OverridingNoGet object&gt;, &lt;Managed object&gt;, 7)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over_no_get</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><h2 id="非覆盖型描述符">非覆盖型描述符</h2><p>没有实现<code>__set__</code>方法的描述符是非覆盖型描述符。如果设置了同名的实例属性，描述符会被遮盖，致使描述符无法处理那个实例的那个属性。方法是以非覆盖型描述符实现的。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.non_over  <span class="comment"># 触发__get__方法</span></span><br><span class="line">-&gt; NonOverriding.__get__(&lt;NonOverriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.non_over = <span class="number">7</span>  <span class="comment"># 赋值，现在obj有个名为non_over的实例属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.non_over  <span class="comment"># 读值，实例属性遮盖了obj的同名描述符</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Managed.non_over  <span class="comment"># 描述符依然存在</span></span><br><span class="line">-&gt; NonOverriding.__get__(&lt;NonOverriding object&gt;, None, &lt;class Managed&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> obj.non_over  <span class="comment"># 删除实例属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.non_over  <span class="comment"># 能触发__get__方法了</span></span><br><span class="line">-&gt; NonOverriding.__get__(&lt;NonOverriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;)</span><br></pre></td></tr></table></figure><h2 id="在类中覆盖描述符">在类中覆盖描述符</h2><p>依附在<strong>类</strong>上的描述符无法控制为类属性赋值的操作。这意味着为类属性赋值能覆盖描述符属性。</p><p>不管描述符是不是覆盖型，为类属性赋值都能覆盖描述符。这是一种猴子布丁技术。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Managed()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Managed.over = <span class="number">1</span>  <span class="comment"># 覆盖类属性，不会触发__set__方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Managed.over_no_get = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Managed.non_over = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over, obj.over_no_get, obj.non_over</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><strong>示例揭示了读写属性的另一种不对等：读类属性的操作可以由依附在托管类上定义有<code>__get__</code>方法的描述符处理，但是写类属性的操作不会由依附在托管类上定义有<code>__set__</code>方法的描述符处理。</strong></p><p>若想控制设置类属性的操作，要把描述符依附在类的类上，即依附在元类上。默认情况下，对用户定义的类来说，其元类是type，而我们不能为type添加属性。</p><h1 id="方法是描述符">方法是描述符</h1><p>在类中定义的函数属于绑定方法（bound method），因为用户定义的函数都有<code>__get__</code>方法，所以依附到类上时，就相当于描述符。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> descriptorkinds <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Managed()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.spam  <span class="comment"># 获取的是绑定方法对象</span></span><br><span class="line">&lt;bound method Managed.spam of &lt;descriptorkinds.Managed object at <span class="number">0x10251dcf8</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Managed.spam  <span class="comment"># 获取的是函数</span></span><br><span class="line">&lt;function Managed.spam at <span class="number">0x102528158</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.spam = <span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.spam</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><p>函数没有实现<code>__set__</code>方法，因此是非覆盖型描述符。从示例中还可以看出一个重要信息：obj.spam和Managed.spam获取的是不同的对象。与描述符一样，通过托管类访问时，函数的<code>__get__</code>方法会返回自身的引用。但是，通过实例访问时，函数的<code>__get__</code>方法返回的是绑定方法对象：一种可调用的对象，里面包装着函数，并把托管实例（例如obj）绑定给函数的第一个参数（即self），这与functools.partial函数的行为一致。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> collections</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Text</span><span class="params">(collections.UserString)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">'Text(&#123;!r&#125;)'</span>.format(self.data)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> self[::<span class="number">-1</span>]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word = Text(<span class="string">'forward'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word  <span class="comment"># 实例</span></span><br><span class="line">Text(<span class="string">'forward'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word.reverse()  <span class="comment"># 调用实例方法</span></span><br><span class="line">Text(<span class="string">'drawrof'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Text.reverse(Text(<span class="string">'backward'</span>))  <span class="comment"># 在类上调用方法相当于调用函数，传入self参数</span></span><br><span class="line">Text(<span class="string">'drawkcab'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(Text.reverse), type(word.reverse)  <span class="comment"># 类型不同，前者是函数，后者是方法</span></span><br><span class="line">(&lt;class 'function'&gt;, &lt;class 'method'&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(Text.reverse, [<span class="string">'repaid'</span>, (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>), Text(<span class="string">'stressed'</span>)]))  <span class="comment"># 该函数可以处理其他对象</span></span><br><span class="line">[<span class="string">'diaper'</span>, (<span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>), Text(<span class="string">'desserts'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Text.reverse.__get__(word)  <span class="comment"># 调用函数的__get__方法传入实例时，得到的是绑定到那个实例上的方法</span></span><br><span class="line">&lt;bound method Text.reverse of Text(<span class="string">'forward'</span>)&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Text.reverse.__get__(<span class="literal">None</span>, Text)  <span class="comment"># 如果instance的值是None，得到的是函数本身</span></span><br><span class="line">&lt;function Text.reverse at <span class="number">0x1025281e0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word.reverse  <span class="comment"># word.reverse表达式其实会调用Text.reverse.__get__(word)，返回对应的绑定方法</span></span><br><span class="line">&lt;bound method Text.reverse of Text(<span class="string">'forward'</span>)&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word.reverse.__self__  <span class="comment"># 绑定方法对象有个__self__属性，值是调用这个方法的实例引用</span></span><br><span class="line">Text(<span class="string">'forward'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word.reverse.__func__ <span class="keyword">is</span> Text.reverse  <span class="comment"># __func__属性是依附在托管类上那个原始函数的引用</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word.reverse.__call__()  <span class="comment"># __call__方法用于处理真正的调用过程。这个方法会调用__func__属性</span></span><br><span class="line">Text(<span class="string">'drawrof'</span>)              <span class="comment"># 引用的原始函数，把函数的第一个参数设为绑定方法的__self__属性</span></span><br><span class="line">                             <span class="comment"># 这就是形参self的隐式绑定方式</span></span><br></pre></td></tr></table></figure><p>函数会变成绑定方法，这是Python语言底层使用描述符的最好例证。</p><h1 id="描述符用法建议">描述符用法建议</h1><ul><li><p>使用特性以保持简单</p><p>内置的propety类创建的其实是覆盖型描述符，<code>__set__</code>方法和<code>__get__</code>方法都实现了，即便不定义设值方法也是如此。特性的<code>__set__</code>方法默认抛出AttributeError: can't set attribute，因此创建只读属性最简单的方式是使用特性，这能避免下一条所述的问题。</p></li><li><p>只读描述符必须有<code>__set__</code>方法</p><p>如果使用描述符类实现只读属性，要记住，<code>__get__</code>和<code>__set__</code>两个方法必须都定义，否则，实例的同名属性会遮盖描述符。只读属性的<code>__set__</code>方法只需抛出AttributeError异常，并提供合适的错误信息。</p></li><li><p>用于验证的描述符可以只有<code>__set__</code>方法</p><p>对仅用于验证的描述符来说，<code>__set__</code>方法应该检查value参数获得的值，如果有效，使用描述符实例的名称为键，直接在实例的<code>__dict__</code>属性中设置。这样，从实例中读取同名属性的速度很快，因为不用经过<code>__get__</code>方法处理。</p></li><li><p>仅有<code>__get__</code>方法的描述符可以实现高速缓存</p><p>如果只编写了<code>__get__</code>方法，那么创建的是非覆盖型描述符。这种描述符可用于执行某些耗费资源的计算，然后为实例设置同名属性，缓存结果。同名实例属性会遮盖描述符，因此后续访问会直接从实例的<code>__dict__</code>属性中获取值，而不会再触发描述符的<code>__get__</code>方法。</p></li><li><p>非特殊的方法可以被实例属性遮盖</p><p>由于函数和方法只实现了<code>__get__</code>方法，它们不会处理同名实例属性的赋值操作。因此，像<code>my_obj.the_method = 7</code>这样简单赋值之后，后续通过该实例访问the_method得到的是数字7——但是不影响类或其他实例。然而，特殊方法不受这个问题的影响。解释器只会在类中寻找特殊方法，也就是说，repr(x)执行的其实是<code>x.__class__.__repr__(x)</code>，因此x的<code>__repr__</code>属性对repr(x)方法调用没有影响。出于同样的原因，实例的<code>__getattr__</code>属性不会破坏常规的属性访问规则。</p></li></ul><h1 id="描述符的文档字符串和覆盖删除操作">描述符的文档字符串和覆盖删除操作</h1><p>描述符类的文档字符串用于注解托管类中的各个描述符实例。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> bulkfood_v5 <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(LineItem)</span><br><span class="line">Help on <span class="class"><span class="keyword">class</span> <span class="title">LineItem</span> <span class="title">in</span> <span class="title">module</span> <span class="title">bulkfood_v5</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span><span class="params">(builtins.object)</span></span></span><br><span class="line"><span class="class"> |  <span class="title">Methods</span> <span class="title">defined</span> <span class="title">here</span>:</span></span><br><span class="line"> |  </span><br><span class="line"> |  __init__(self, description, weight, price)</span><br><span class="line"> |      Initialize self.  See help(type(self)) <span class="keyword">for</span> accurate signature.</span><br><span class="line"> |  </span><br><span class="line"> |  subtotal(self)</span><br><span class="line"> |  </span><br><span class="line"> |  ----------------------------------------------------------------------</span><br><span class="line"> |  Data descriptors defined here:</span><br><span class="line"> |  </span><br><span class="line"> |  __dict__</span><br><span class="line"> |      dictionary <span class="keyword">for</span> instance variables (<span class="keyword">if</span> defined)</span><br><span class="line"> |  </span><br><span class="line"> |  __weakref__</span><br><span class="line"> |      list of weak references to the object (<span class="keyword">if</span> defined)</span><br><span class="line"> |  </span><br><span class="line"> |  description</span><br><span class="line"> |      a string <span class="keyword">with</span> at least one non-space character</span><br><span class="line"> |  </span><br><span class="line"> |  price</span><br><span class="line"> |      a number greater than zero</span><br><span class="line"> |  </span><br><span class="line"> |  weight</span><br><span class="line"> |      a number greater than zero</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(LineItem.weight)  <span class="comment"># 提示的信息有点不足</span></span><br><span class="line">Help on Quantity <span class="keyword">in</span> module model_v5 object:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span><span class="params">(Validate)</span></span></span><br><span class="line"><span class="class"> |  <span class="title">a</span> <span class="title">number</span> <span class="title">greater</span> <span class="title">than</span> <span class="title">zero</span></span></span><br><span class="line"><span class="class"> |  </span></span><br><span class="line"><span class="class"> |  <span class="title">Method</span> <span class="title">resolution</span> <span class="title">order</span>:</span></span><br><span class="line"> |      Quantity</span><br><span class="line"> |      Validate</span><br><span class="line"> |      abc.ABC</span><br><span class="line"> |      AutoStorage</span><br><span class="line"> |      builtins.object</span><br><span class="line"> |  </span><br><span class="line"> |  Methods defined here:</span><br><span class="line"> |  </span><br><span class="line"> |  validate(self, instance, value)</span><br><span class="line"> |      <span class="keyword">return</span> validated value <span class="keyword">or</span> <span class="keyword">raise</span> ValueError</span><br><span class="line"> |  </span><br><span class="line"> |  ----------------------------------------------------------------------</span><br><span class="line"> |  Data <span class="keyword">and</span> other attributes defined here:</span><br><span class="line"> |  </span><br><span class="line"> |  __abstractmethods__ = frozenset()</span><br><span class="line"> |  </span><br><span class="line"> |  ----------------------------------------------------------------------</span><br><span class="line"> |  Methods inherited <span class="keyword">from</span> Validate:</span><br><span class="line"> |  </span><br><span class="line"> |  __set__(self, instance, value)</span><br><span class="line"> |  </span><br><span class="line"> |  ----------------------------------------------------------------------</span><br><span class="line"> |  Data descriptors inherited <span class="keyword">from</span> abc.ABC:</span><br><span class="line"> |  </span><br><span class="line"> |  __dict__</span><br><span class="line"> |      dictionary <span class="keyword">for</span> instance variables (<span class="keyword">if</span> defined)</span><br><span class="line"> |  </span><br><span class="line"> |  __weakref__</span><br><span class="line"> |      list of weak references to the object (<span class="keyword">if</span> defined)</span><br><span class="line"> |  </span><br><span class="line"> |  ----------------------------------------------------------------------</span><br><span class="line"> |  Methods inherited <span class="keyword">from</span> AutoStorage:</span><br><span class="line"> |  </span><br><span class="line"> |  __get__(self, instance, owner)</span><br><span class="line"> |  </span><br><span class="line"> |  __init__(self)</span><br><span class="line"> |      Initialize self.  See help(type(self)) <span class="keyword">for</span> accurate signature.</span><br></pre></td></tr></table></figure><p>对LineItem类来说，如果能说明weight必须以千克为单位就好了。这对特性来说小菜一碟，因为各个特性只处理特定的托管属性。可是对描述符来说，weight和price使用的都是Quantity描述符类。定制各个描述符实例的帮助文本特别难。有一种方法是为各个描述符实例动态构建包装类。</p><p>对删除托管属性处理时，在描述符类中，实现常规的<code>__get__</code>和（或）<code>__set__</code>方法之外，可以实现<code>__delete__</code>方法，或者只实现<code>__delete__</code>方法。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> attribute descriptors </tag>
            
            <tag> property </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断一个数是否是质数</title>
      <link href="/programming/check-whether-a-number-is-prime-or-not/"/>
      <url>/programming/check-whether-a-number-is-prime-or-not/</url>
      
        <content type="html"><![CDATA[<ul><li><code>concurrent.futures.ProcessPoolExecutor</code> 文档。</li><li>如何快速判断一个数是否是质数。</li><li>回顾参数化装饰器和协程的用法。</li></ul><h1 id="processpoolexecutor-示例">ProcessPoolExecutor 示例</h1><p>使用<a href="https://devdocs.io/python~3.6/library/concurrent.futures#concurrent.futures.ProcessPoolExecutor" target="_blank" rel="noopener"><code>concurrent.futures.ProcessPoolExecutor</code></a>实现并行。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">PRIMES = [</span><br><span class="line">    <span class="number">112272535095293</span>,</span><br><span class="line">    <span class="number">112582705942171</span>,</span><br><span class="line">    <span class="number">112272535095293</span>,</span><br><span class="line">    <span class="number">115280095190773</span>,</span><br><span class="line">    <span class="number">115797848077099</span>,</span><br><span class="line">    <span class="number">1099726899285419</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_prime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:  <span class="comment"># 是否能被2整除</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 不能的话继续检测</span></span><br><span class="line">    sqrt_n = int(math.floor(math.sqrt(n)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, sqrt_n + <span class="number">1</span>, <span class="number">2</span>):  <span class="comment"># 检测能否被 3 5 7 ... floor(sqrt(n))</span></span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:                 <span class="comment"># 因为不能被2整除，所以也不能被2的倍数整除</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ProcessPoolExecutor() <span class="keyword">as</span> executor:</span><br><span class="line">        <span class="keyword">for</span> number, prime <span class="keyword">in</span> zip(PRIMES, executor.map(is_prime, PRIMES)):</span><br><span class="line">            print(<span class="string">'%d is prime: %s'</span> % (number, prime))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="优化-is_prime-函数">优化 is_prime 函数</h1><p>示例中用到 <code>is_prime</code> 函数来检测一个数是否为质数。趁此机会学习了一下 <code>is_prime</code> 的优化方案。<a href="https://www.geeksforgeeks.org/python-program-to-check-whether-a-number-is-prime-or-not/" target="_blank" rel="noopener">原文</a></p><p>上述 <code>is_prime</code> 并不通用，因为它没有考虑边界情况（2 是质数）。考虑到函数的输入 n 远远大于 2，示例中这样做没什么问题。</p><p>下面单独讨论如何更高效判断一个数是否是质数。根据质数的定义，质数只能被 1 和自身整除，所以最直白的算法是依次检测能否被 <code>2 3 ... n-1</code> 整除。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_prime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="comment"># Corner cases</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">3</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Check from 2 to n-1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>优化的做法是排除检测某些不可能整除的值，例如前文见过的跳过所有偶数以及大于 <span class="math inline">\(\lfloor \sqrt{n}\rfloor\)</span> 的整数。</p><p>更进一步，我们可以利用下述结论：<strong>所有的质数，都是 <span class="math inline">\(6k\pm 1\)</span> 的形式，除了2和3</strong>。因此，如果一个数不能被 2 或 3 整除的话，那么在接下来的检测中，我们只需检测能否被 <span class="math inline">\(6k\pm 1\)</span> 整除即可。因为所有的整数都能表示为 <span class="math inline">\(6k\pm i,\quad i=-1,0,1,2,3,4\)</span>，其中 <span class="math inline">\(6k+0\)</span>、<span class="math inline">\(6k+2\)</span> 和 <span class="math inline">\(6k+4\)</span> 能被2整除，<span class="math inline">\(6k+3\)</span> 能被 3 整数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="comment"># Corner cases</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">3</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># This is checked so that we can skip</span></span><br><span class="line">    <span class="comment"># middle five numbers in below loop</span></span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">or</span> n % <span class="number">3</span> == <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">  </span><br><span class="line">    i = <span class="number">5</span></span><br><span class="line">    <span class="keyword">while</span>(i * i &lt;= n):</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span> <span class="keyword">or</span> n % (i + <span class="number">2</span>) == <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        i = i + <span class="number">6</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h1 id="多线程与多进程">多线程与多进程</h1><figure class="highlight python"><figcaption><span>prime.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">PRIMES = [</span><br><span class="line">    <span class="number">112272535095293</span>,</span><br><span class="line">    <span class="number">112582705942171</span>,</span><br><span class="line">    <span class="number">112272535095293</span>,</span><br><span class="line">    <span class="number">115280095190773</span>,</span><br><span class="line">    <span class="number">115797848077099</span>,</span><br><span class="line">    <span class="number">1099726899285419</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_prime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="comment"># Corner cases</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">3</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># This is checked so that we can skip</span></span><br><span class="line">    <span class="comment"># middle five numbers in below loop</span></span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">or</span> n % <span class="number">3</span> == <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">  </span><br><span class="line">    i = <span class="number">5</span></span><br><span class="line">    <span class="keyword">while</span>(i * i &lt;= n):</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span> <span class="keyword">or</span> n % (i + <span class="number">2</span>) == <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        i = i + <span class="number">6</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">()</span>:</span>  <span class="comment"># 利用协程计算平均值</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span> average</span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(n_time=<span class="number">10</span>)</span>:</span>  <span class="comment"># 一个参数化的装饰器，重复运行函数并计算平均耗时</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*args)</span>:</span></span><br><span class="line">            avg = averager()</span><br><span class="line">            next(avg)  <span class="comment"># 预激</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(n_time):</span><br><span class="line">                t = time.time()</span><br><span class="line">                func(*args)</span><br><span class="line">                elapsed = time.time() - t</span><br><span class="line">                means = avg.send(elapsed)</span><br><span class="line">            print(<span class="string">'run &#123;&#125; &#123;&#125; times, average &#123;:.4f&#125; s'</span>.format(func, n_time, means))</span><br><span class="line">        <span class="keyword">return</span> clocked</span><br><span class="line">    <span class="keyword">return</span> decorate</span><br><span class="line"></span><br><span class="line"><span class="meta">@test(5)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main_sequence</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> PRIMES:</span><br><span class="line">        is_prime(number)</span><br><span class="line"></span><br><span class="line"><span class="meta">@test(5)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main_multithread</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor() <span class="keyword">as</span> executor:</span><br><span class="line">        executor.map(is_prime, PRIMES)</span><br><span class="line"></span><br><span class="line"><span class="meta">@test(5)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main_multiprocess</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ProcessPoolExecutor() <span class="keyword">as</span> executor:</span><br><span class="line">        executor.map(is_prime, PRIMES)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main_sequence()</span><br><span class="line">    main_multithread()</span><br><span class="line">    main_multiprocess()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python prime.py</span><br><span class="line">run &lt;function main_sequence at <span class="number">0x10ca98268</span>&gt; <span class="number">5</span> times, average <span class="number">2.1310</span> s</span><br><span class="line">run &lt;function main_multithread at <span class="number">0x10ca98378</span>&gt; <span class="number">5</span> times, average <span class="number">2.1739</span> s</span><br><span class="line">run &lt;function main_multiprocess at <span class="number">0x10ca98488</span>&gt; <span class="number">5</span> times, average <span class="number">0.6985</span> s</span><br></pre></td></tr></table></figure><p>对于计算是否是质数这种 CPU 密集型作业，多线程没有优势，甚至比按序计算还慢一点点。而多进程则明显要快很多。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> parallelism </tag>
            
            <tag> prime number </tag>
            
            <tag> concurrent </tag>
            
            <tag> decorators </tag>
            
            <tag> coroutines </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特性</title>
      <link href="/notes/fluent-python/property/"/>
      <url>/notes/fluent-python/property/</url>
      
        <content type="html"><![CDATA[<h1 id="使用特性验证属性">使用特性验证属性</h1><h2 id="lineitem类第1版表示订单中商品的类">LineItem类第1版：表示订单中商品的类</h2><figure class="highlight python"><figcaption><span>bulkfood_v1.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, pricre)</span>:</span></span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight  <span class="comment"># 可能为负值（无效输入）</span></span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br></pre></td></tr></table></figure><p>我们可以修改LineItem类的接口，使用读值方法和设值方法管理weight属性。这是Java采用的方式，这里也完全可行。但是，如果能直接设定商品的weight属性，则显得更自然。此外，系统可能在生产环境中，而其他部分已经直接访问item.weight了。此时，符合Python风格的做法是，把数据属性换成特性。</p><h2 id="lineitem类第2版能验证值的特性">LineItem类第2版：能验证值的特性</h2><figure class="highlight python"><figcaption><span>bulkfood_v2.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, price)</span>:</span></span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight  <span class="comment"># 这里已经使用特性的设值方法了</span></span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weight</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__weight  <span class="comment"># 真正的值存储在私有属性__weight中</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @weight.setter  # 被装饰的读值方法有个setter属性，这个属性也是装饰器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weight</span><span class="params">(self, value)</span>:</span>  <span class="comment"># 这个装饰器把读值方法和设值方法绑定在一起</span></span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:</span><br><span class="line">            self.__weight = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python -i bulkfood_v2.py</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>walnuts = LineItem(<span class="string">'walnuts'</span>, <span class="number">0</span>, <span class="number">100.0</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"bulkfood_v2.py"</span>, line <span class="number">5</span>, <span class="keyword">in</span> __init__</span><br><span class="line">    self.weight = weight  <span class="comment"># 这里已经使用特性的设值方法了</span></span><br><span class="line">  File <span class="string">"bulkfood_v2.py"</span>, line <span class="number">20</span>, <span class="keyword">in</span> weight</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line">ValueError: value must be &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure><p>现在，我们禁止用户为weight属性提供负值或零。我们也可以把price属性变成特性，但是这样我们的代码就存在一些重复。去除重复的方式是抽象。抽象特性的定义有两种方式：使用特性工厂函数，或者使用描述符类。后者更灵活。其实，特性本身就是使用描述符类实现的。</p><h1 id="特性全解析">特性全解析</h1><p>虽然内置的property经常用作装饰器，但它其实是一个类。在Python中函数和类通常可以互换，因为二者都是可调用的对象，而且没有实例化对象的new运算符，所以调用构造方法与调用工厂函数没有区别。此外，只要能返回新的可调用对象，代替被装饰的函数，二者都可以用作装饰器。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/functions#property" target="_blank" rel="noopener"><code>class property(fget=None, fset=None, fdel=None, doc=None)</code></a></p><p>Return a property attribute.</p><p>A typical use is to define a managed attribute <code>x</code>:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._x = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getx</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setx</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._x = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delx</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">del</span> self._x</span><br><span class="line"></span><br><span class="line">    x = property(getx, setx, delx, <span class="string">"I'm the 'x' property."</span>)</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p>在某些情况下，这种经典形式比装饰器句法好，稍后讨论的特性工厂函数就是一例。但是，在方法众多的类定义体中使用装饰器的话，一眼就能看出哪些是读值方法，哪些是设值方法，而不用按照惯例，在方法名的前面加上set和get。</p><h2 id="特性会覆盖实例属性">特性会覆盖实例属性</h2><p>特性都是类属性，但是特性管理的其实是实例属性的存取。如果实例和所属的类有同名数据属性，那么实例属性会覆盖（或称遮盖）类属性——至少通过那个实例读取属性时是这样。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Class</span>:</span></span><br><span class="line"><span class="meta">... </span>    data = <span class="string">'the class data attr'</span>  <span class="comment"># 类属性</span></span><br><span class="line"><span class="meta">... </span>    @property</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">prop</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> <span class="string">'the prop value'</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Class()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vars(obj)  <span class="comment"># 实例属性是空的</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.data  <span class="comment"># 通过实例获取到了类属性</span></span><br><span class="line"><span class="string">'the class data attr'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.data = <span class="string">'bar'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vars(obj)</span><br><span class="line">&#123;<span class="string">'data'</span>: <span class="string">'bar'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.data  <span class="comment"># 普通属性：实例属性覆盖类属性</span></span><br><span class="line"><span class="string">'bar'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Class.data  <span class="comment"># Class.data属性的值完好无损</span></span><br><span class="line"><span class="string">'the class data attr'</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Class.prop  <span class="comment"># 特性是类属性</span></span><br><span class="line">&lt;property object at <span class="number">0x10c59b7c8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.prop</span><br><span class="line"><span class="string">'the prop value'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.prop = <span class="string">'foo'</span>  <span class="comment"># 无法设值prop实例属性</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: can‘t set attribute</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.__dict__[<span class="string">'prop'</span>] = <span class="string">'foo'</span>  <span class="comment"># 可以直接存到字典中</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vars(obj)</span><br><span class="line">&#123;<span class="string">'data'</span>: <span class="string">'bar'</span>, <span class="string">'prop'</span>: <span class="string">'foo'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.prop  <span class="comment"># 仍会运行特性的读值方法，即特性会覆盖实例属性</span></span><br><span class="line"><span class="string">'the prop value'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Class.prop = <span class="string">'baz'</span>  <span class="comment"># 覆盖特性，销毁特性对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.prop</span><br><span class="line"><span class="string">'foo'</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.data  <span class="comment"># 实例属性</span></span><br><span class="line"><span class="string">'bar'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Class.data  <span class="comment"># 类属性</span></span><br><span class="line"><span class="string">'the class data attr'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Class.data = property(<span class="keyword">lambda</span> self: <span class="string">'the "data" prop value'</span>)  <span class="comment"># 覆盖类属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.data  <span class="comment"># 实例属性被特性遮盖了</span></span><br><span class="line"><span class="string">'the "data" prop value'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> Class.data  <span class="comment"># 删除特性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.data</span><br><span class="line"><span class="string">'bar'</span></span><br></pre></td></tr></table></figure><p><strong>对于覆盖性描述符（overriding descriptor，特性其实是覆盖性描述符），obj.attr这样的表达式不会从obj开始寻找attr，而是从<code>obj.__class__</code>开始，而且，仅当类中没有名为attr的特性时，Python才会在obj实例中寻找。</strong></p><h2 id="特性的文档">特性的文档</h2><p>如果使用经典调用句法，为property对象设值文档字符串的方法是传入doc参数。使用装饰器创建property对象时，读值方法（有@property装饰器的方法）的文档字符串作为一个整体，变成特性的文档。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    @property</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>            <span class="string">"""The bar attribute"""</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> self.__dict__[<span class="string">'bar'</span>]</span><br><span class="line"><span class="meta">... </span>    @bar.setter</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self, value)</span>:</span></span><br><span class="line"><span class="meta">... </span>            self.__dict__[<span class="string">'bar'</span>] = value</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(Foo)</span><br><span class="line"></span><br><span class="line">Help on <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="title">in</span> <span class="title">module</span> <span class="title">__main__</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(builtins.object)</span></span></span><br><span class="line"><span class="class"> |  <span class="title">Data</span> <span class="title">descriptors</span> <span class="title">defined</span> <span class="title">here</span>:</span></span><br><span class="line"> |  </span><br><span class="line"> |  __dict__</span><br><span class="line"> |      dictionary <span class="keyword">for</span> instance variables (<span class="keyword">if</span> defined)</span><br><span class="line"> |  </span><br><span class="line"> |  __weakref__</span><br><span class="line"> |      list of weak references to the object (<span class="keyword">if</span> defined)</span><br><span class="line"> |  </span><br><span class="line"> |  bar</span><br><span class="line"> |      The bar attribute</span><br><span class="line">(END)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(Foo.bar)</span><br><span class="line"></span><br><span class="line">Help on property:</span><br><span class="line"></span><br><span class="line">    The bar attribute</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure><h1 id="定义一个特性工厂函数">定义一个特性工厂函数</h1><figure class="highlight python"><figcaption><span>bulkfood_v2prop.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quantity</span><span class="params">(storage_name)</span>:</span>  <span class="comment"># 特性工厂函数</span></span><br><span class="line">    <span class="comment"># storage_name确定特性的数据存储在哪儿，对weight特性来说，存储的名称是'weight'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qty_getter</span><span class="params">(instance)</span>:</span>  <span class="comment"># 参数可以命名为self，但是会有点奇怪，因为它不是类方法</span></span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[storage_name]  <span class="comment"># 跳过特性，直接读取，避免无限递归</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qty_setter</span><span class="params">(instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:  <span class="comment"># 验证</span></span><br><span class="line">            instance.__dict__[storage_name] = value  <span class="comment"># 跳过特性</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> property(qty_getter, qty_setter)  <span class="comment"># 返回特性</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">    weight = quantity(<span class="string">'weight'</span>)  <span class="comment"># 使用特性工厂创建特性</span></span><br><span class="line">    price = quantity(<span class="string">'price'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, price)</span>:</span></span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python -i bulkfood_v2prop.py</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nutmeg = LineItem(<span class="string">'Moluccan nutmeg'</span>, <span class="number">8</span>, <span class="number">13.95</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(vars(nutmeg).items())</span><br><span class="line">[(<span class="string">'description'</span>, <span class="string">'Moluccan nutmeg'</span>), (<span class="string">'price'</span>, <span class="number">13.95</span>), (<span class="string">'weight'</span>, <span class="number">8</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nutmeg.price = <span class="number">0</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"bulkfood_v2prop.py"</span>, line <span class="number">10</span>, <span class="keyword">in</span> qty_setter</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line">ValueError: value must be &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure><h1 id="处理属性删除操作">处理属性删除操作</h1><p>对象的属性可以使用del语句删除。使用Python编程时不常删除属性，通过特性删除属性更少见。但是，Python支持这么做。</p><figure class="highlight python"><figcaption><span>blackknight.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlackKnight</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.members = [<span class="string">'an arm'</span>, <span class="string">'another arm'</span>,</span><br><span class="line">                        <span class="string">'a leg'</span>, <span class="string">'another leg'</span>]</span><br><span class="line">        self.phrases = [<span class="string">"‘Tis but a scratch."</span>,</span><br><span class="line">                        <span class="string">"It‘s just a flesh wound."</span>,</span><br><span class="line">                        <span class="string">"I‘m invincible!"</span>,</span><br><span class="line">                        <span class="string">"All right, we’ll call it a draw."</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">member</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'next member is:'</span>)</span><br><span class="line">        <span class="keyword">return</span> self.members[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @member.deleter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">member</span><span class="params">(self)</span>:</span>  <span class="comment"># 特性一次删除两个属性中的零号元素</span></span><br><span class="line">        text = <span class="string">'BLACK KNIGHT (losed &#123;&#125;)\n-- &#123;&#125;'</span></span><br><span class="line">        print(text.format(self.members.pop(<span class="number">0</span>), self.phrases.pop(<span class="number">0</span>)))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python -i blackknight.py</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>knight = BlackKnight()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>knight.member</span><br><span class="line">next member <span class="keyword">is</span>:</span><br><span class="line"><span class="string">'an arm'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> knight.member</span><br><span class="line">BLACK KNIGHT (losed an arm)</span><br><span class="line">-- ‘Tis but a scratch.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> knight.member</span><br><span class="line">BLACK KNIGHT (losed another arm)</span><br><span class="line">-- It’s just a flesh wound.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> knight.member</span><br><span class="line">BLACK KNIGHT (losed a leg)</span><br><span class="line">-- I‘m invincible!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> knight.member</span><br><span class="line">BLACK KNIGHT (losed another leg)</span><br><span class="line">-- All right, we’ll call it a draw.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> knight.member</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"blackknight.py"</span>, line <span class="number">19</span>, <span class="keyword">in</span> member</span><br><span class="line">    print(text.format(self.members.pop(<span class="number">0</span>), self.phrases.pop(<span class="number">0</span>)))</span><br><span class="line">IndexError: pop <span class="keyword">from</span> empty list</span><br></pre></td></tr></table></figure><p>如果不使用装饰器的经典调用语法，可以在property中设值fdel函数。如果不使用特性，还可以实现低层特殊的<code>__delattr__</code>方法处理删除属性操作。</p><h1 id="处理属性的重要属性和函数">处理属性的重要属性和函数</h1><h2 id="影响属性处理方式的特殊属性">影响属性处理方式的特殊属性</h2><p><code>__class__</code>：对象所属类的引用（即<code>obj.__class__</code>与<code>type(obj)</code>的作用相同）。</p><p><code>__dict__</code>：一个映射，存储对象或类的可写属性。有<code>__dict__</code>属性的对象，任何时候都能随意设置新属性。如果类有<code>__slots__</code>属性，它的实例可能没有<code>__dict__</code>属性。</p><p><code>__slots__</code>：类可以定义这个属性，限制实例能有哪些属性。<code>__slots__</code>属性的值是一个字符串构成的元组，指明允许有的属性。如果<code>__slots__</code>中没有<code>__dict__</code>，那么该类的实例没有<code>__dict__</code>属性，实例只允许有指定名称的属性。（<code>__slots__</code>属性的值虽然可以是一个列表，但是最好始终使用元组，因为处理完类的定义体之后再修改<code>__slots__</code>列表没有任何作用，所以使用可变的序列容易让人误解）</p><h2 id="处理属性的内置函数">处理属性的内置函数</h2><p>下述5个内置函数对对象的属性做读、写和内省操作。</p><ul><li><code>dir([object])</code>：列出对象的大多数属性。dir函数的目的是交互式使用，因此没有提供完整的属性列表，只列出一组“重要的”属性名。dir函数能审查有或没有<code>__dict__</code>属性的对象。dir函数不会列出<code>__dict__</code>属性本身，但会列出其中的键。dir函数也不会列出类的几个特殊属性，例如<code>__mro__</code>、<code>__bases__</code>和<code>__name__</code>。如果没有指定可选的object参数，dir函数会列出当前作用域中的名称。</li><li><code>getattr(object, name[, default])</code>：从object对象中获取name字符串对应的属性。获取的属性可能来自对象所属的类或超类。如果没有指定的属性，getattr函数抛出AttributeError异常，或者返回default参数的值。</li><li><code>hasattr(object, name)</code>：如果object对象中存在指定的属性，或者能以某种方式（例如继承）通过object对象获取指定的属性，返回True。这个函数的实现方式是调用getattr(object, name)函数，看看是否抛出AttributeError异常。</li><li><code>setattr(object, name, value)</code>：把object对象指定属性的值设为value，前提是object对象能接受那个值。这个函数可能会创建一个新属性，或覆盖现有属性。</li><li><code>vars([object])</code>：返回object对象的<code>__dict__</code>属性；如果实例所属的类定义了<code>__slots__</code>属性，实例没有<code>__dict__</code>属性，那么vars函数不能处理那个实例（相反，dir函数能处理这样的实例）。如果没有指定参数，那么vars函数的作用与locals函数一样：返回表示本地作用域的字典。</li></ul><h2 id="处理属性的特殊方法">处理属性的特殊方法</h2><p>在用户自已定义的类中，下述特殊方法用于获取、设置、删除和列出属性。</p><p>使用点号或内置的getattr、hasattr和setattr函数存取属性都会触发下述列表中相应的特殊方法。但是，直接通过实例的<code>__dict__</code>属性读写属性不会触发这些特殊方法——如果需要，通常会使用这种方式跳过特殊方法。</p><p><strong>对用户自己定义的类来说，如果隐式调用特殊方法，仅当特殊方法在对象所属的类型上定义，而不是在对象的实例字典中定义时，才能确保调用成功。也就是说，要假定特殊方法从类上获取，即便操作目标是实例也是如此。因此，特殊方法不会被同名实例属性遮盖。</strong></p><ul><li><code>__delattr__(self, name)</code>：只要使用del语句删除属性，就会调用这个方法。例如,del obj.attr语句触发<code>Class.__delattr__(obj, 'attr')</code>方法。</li><li><code>__dir__(self)</code>：把对象传给dir函数时调用，列出属性。例如，dir(obj)触发<code>Class.__dir__(obj)</code>方法。</li><li><code>__getattr__(self, name)</code>：仅当获取指定的属性失败，搜索过obj、Class和超类之后调用。</li><li><code>__getattribute__(self, name)</code>：尝试获取指定的属性时总会调用这个方法。不过，寻找的属性是特殊属性或特殊方法时除外。点号与getattr和hasattr内置函数会触发这个方法。调用<code>__getattribute__</code>方法且抛出AttributeError异常时，才会调用<code>__getattr__</code>方法。为了在获取obj实例的属性时不导致无限递归，<code>__getattribute__</code>方法的实现要使用<code>super().__getattribute__(obj, name)</code>。</li><li><code>__setattr__(self, name, value)</code>：尝试设置指定的属性时总会调用这个方法。点号和setattr内置函数会触发这个方法。例如，obj.attr和getattr(obj, 'attr', 42)都会触发<code>Class.__setattr__(obj, 'attr', 42)</code>方法。</li></ul><p><strong>特殊方法<code>__getattribute__</code>和<code>__setattr__</code>不管怎样都会调用，几乎会影响每一次属性存取，因此比<code>__getattr__</code>方法（只处理不存在的属性名）更难正确使用。与定义这些特殊方法相比，使用特性或描述符相对不易出错。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> decorators </tag>
            
            <tag> Fluent Python </tag>
            
            <tag> property </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用动态属性转换数据</title>
      <link href="/notes/fluent-python/data-wrangling-with-dynamic-attributes/"/>
      <url>/notes/fluent-python/data-wrangling-with-dynamic-attributes/</url>
      
        <content type="html"><![CDATA[<p>在Python中，数据的属性和处理数据的方法统称属性（attribute）。其实，方式只是可调用的属性。除了这二者之外，我们还可以创建特性（property），在不改变接口的前提下，使用存取方法（即读值方法和设值方法）修改数据属性。这与统一访问原则相符：不管服务是由存储还是计算实现的，一个模块提供的所有服务都应该通过统一的方式使用。</p><p>除了特性，Python还提供了丰富的API，用于控制属性的访问权限，以及实现动态属性。使用点号访问属性时（如obj.attr），Python解释器会调用特殊的方法（如<code>__getattr__</code>和<code>__setattr__</code>）计算属性。用户自己定义的类可以通过<code>__getattr__</code>方法实现“虚拟属性”，当访问不存在的属性时，即时计算属性的值。</p><p>动态创建属性是一种元编程，框架的作者经常这么做。然而，在Python中，相关的基础技术十分简单，任何人都可以使用，甚至在日常的数据转换任务中也能用到。下面以这种任务开启本章的话题。</p><a id="more"></a><h1 id="使用动态属性转换数据">使用动态属性转换数据</h1><figure class="highlight json"><figcaption><span>osconfeed.json</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">"Schedule"</span>:</span><br><span class="line">  &#123; <span class="attr">"conferences"</span>: [&#123;<span class="attr">"serial"</span>: <span class="number">115</span> &#125;],</span><br><span class="line">    <span class="attr">"events"</span>: [</span><br><span class="line">      &#123; <span class="attr">"serial"</span>: <span class="number">34505</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Why Schools Don ́t Use Open Source to Teach Programming"</span>,</span><br><span class="line">        <span class="attr">"event_type"</span>: <span class="string">"40-minute conference session"</span>,</span><br><span class="line">        <span class="attr">"time_start"</span>: <span class="string">"2014-07-23 11:30:00"</span>,</span><br><span class="line">        <span class="attr">"time_stop"</span>: <span class="string">"2014-07-23 12:10:00"</span>,</span><br><span class="line">        <span class="attr">"venue_serial"</span>: <span class="number">1462</span>,</span><br><span class="line">        <span class="attr">"description"</span>: <span class="string">"Aside from the fact that high school programming..."</span>,</span><br><span class="line">        <span class="attr">"website_url"</span>: <span class="string">"http://oscon.com/oscon2014/public/schedule/detail/34505"</span>,</span><br><span class="line">        <span class="attr">"speakers"</span>: [<span class="number">157509</span>],</span><br><span class="line">        <span class="attr">"categories"</span>: [<span class="string">"Education"</span>] &#125;,</span><br><span class="line">      &#123; <span class="attr">"更多条记录"</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"speakers"</span>: [</span><br><span class="line">      &#123; <span class="attr">"serial"</span>: <span class="number">157509</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Robert Lefkowitz"</span>,</span><br><span class="line">        <span class="attr">"photo"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"url"</span>: <span class="string">"http://sharewave.com/"</span>,</span><br><span class="line">        <span class="attr">"position"</span>: <span class="string">"CTO"</span>,</span><br><span class="line">        <span class="attr">"affiliation"</span>: <span class="string">"Sharewave"</span>,</span><br><span class="line">        <span class="attr">"twitter"</span>: <span class="string">"sharewaveteam"</span>,</span><br><span class="line">        <span class="attr">"bio"</span>: <span class="string">"Robert  ́r0ml ́ Lefkowitz is the CTO at Sharewave, a startup..."</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">"更多条记录"</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"venues"</span>: [</span><br><span class="line">      &#123; <span class="attr">"serial"</span>: <span class="number">1462</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"F151"</span>,</span><br><span class="line">        <span class="attr">"category"</span>: <span class="string">"Conference Venues"</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">"更多条记录"</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>osconfeed.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">URL = <span class="string">'http://www.oreilly.com/pub/sc/osconfeed'</span></span><br><span class="line">JSON = <span class="string">'data/osconfeed.json'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(JSON):  <span class="comment"># 如果文件不存在就去下载</span></span><br><span class="line">        msg = <span class="string">'downloading &#123;&#125; to &#123;&#125;'</span>.format(URL, JSON)</span><br><span class="line">        warnings.warn(msg)  <span class="comment"># 发出警告</span></span><br><span class="line">        <span class="comment"># 在with语句中使用两个上下文管理器</span></span><br><span class="line">        <span class="keyword">with</span> urlopen(URL) <span class="keyword">as</span> remote, open(JSON, <span class="string">'wb'</span>) <span class="keyword">as</span> local:</span><br><span class="line">            local.write(remote.read())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(JSON) <span class="keyword">as</span> fp:</span><br><span class="line">        <span class="keyword">return</span> json.load(fp)  <span class="comment"># 返回Python原生对象</span></span><br></pre></td></tr></table></figure><h1 id="使用动态属性访问json类数据">使用动态属性访问JSON类数据</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> osconfeed <span class="keyword">import</span> load</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>feed = load()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(feed[<span class="string">'Schedule'</span>].keys())  <span class="comment"># feed是一个字典，里面嵌套这字典和列表</span></span><br><span class="line">[<span class="string">'conferences'</span>, <span class="string">'events'</span>, <span class="string">'speakers'</span>, <span class="string">'venues'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key, value <span class="keyword">in</span> sorted(feed[<span class="string">'Schedule'</span>].items()):</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'&#123;:3&#125; &#123;&#125;'</span>.format(len(value), key))</span><br><span class="line">...</span><br><span class="line">  <span class="number">1</span> conferences</span><br><span class="line"><span class="number">494</span> events</span><br><span class="line"><span class="number">357</span> speakers</span><br><span class="line"> <span class="number">53</span> venues</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>feed[<span class="string">'Schedule'</span>][<span class="string">'speakers'</span>][<span class="number">-1</span>][<span class="string">'name'</span>]  <span class="comment"># 最后一位演讲者的名字</span></span><br><span class="line"><span class="string">'Carina C. Zona'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>feed[<span class="string">'Schedule'</span>][<span class="string">'speakers'</span>][<span class="number">-1</span>][<span class="string">'serial'</span>]  <span class="comment"># 最后一位演讲者的编号</span></span><br><span class="line"><span class="number">141590</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>feed[<span class="string">'Schedule'</span>][<span class="string">'events'</span>][<span class="number">40</span>][<span class="string">'name'</span>]  <span class="comment"># 事件名称</span></span><br><span class="line"><span class="string">'There *Will* Be Bugs'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>feed[<span class="string">'Schedule'</span>][<span class="string">'events'</span>][<span class="number">40</span>][<span class="string">'speakers'</span>]  <span class="comment"># 事件的演讲者列表</span></span><br><span class="line">[<span class="number">3471</span>, <span class="number">5199</span>]</span><br></pre></td></tr></table></figure><h2 id="使用动态属性访问json类数据-1">使用动态属性访问JSON类数据</h2><p>feed['Schedule']['events'][40]['name']这种句法很冗长。在JavaScript中，可以使用feed.Schedule.events[40].name获取那个值。在Python中，可以实现一个近似字典的类（网上有大量实现，最常提到的一个实现是<a href="https://pypi.python.org/pypi/attrdict" target="_blank" rel="noopener">AttrDict</a>，还有一个实现能快速创建嵌套的映射——<a href="https://pypi.python.org/pypi/addict" target="_blank" rel="noopener">addict</a>），达到同样的效果。</p><figure class="highlight python"><figcaption><span>explore0.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrozenJSON</span>:</span></span><br><span class="line">    <span class="string">"""一个只读接口，使用属性表示法访问JSON类对象</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, mapping)</span>:</span></span><br><span class="line">        self.__data = dict(mapping)  <span class="comment"># 使用mapping创建一个字典副本</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(self.__data, name):  <span class="comment"># name是__data的属性</span></span><br><span class="line">            <span class="keyword">return</span> getattr(self.__data, name)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 从__data中获取name键对应的元素</span></span><br><span class="line">            <span class="keyword">try</span>:  <span class="comment"># 捕获异常的姿势可能不正确</span></span><br><span class="line">                <span class="keyword">return</span> FrozenJSON.build(self.__data[name])</span><br><span class="line">            <span class="keyword">except</span> KeyError:  <span class="comment"># 可能出现KeyError异常</span></span><br><span class="line">                msg = <span class="string">'&#123;!r&#125; object has no attribute &#123;!r&#125;'</span></span><br><span class="line">                <span class="comment"># 属性访问应该抛出AttributeError</span></span><br><span class="line">                <span class="keyword">raise</span> AttributeError(msg.format(type(self).__name__, name))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(cls, obj)</span>:</span>  <span class="comment"># 备选构造方法</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(obj, abc.Mapping):  <span class="comment"># 是映射</span></span><br><span class="line">            <span class="keyword">return</span> cls(obj)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(obj, abc.MutableSequence):  <span class="comment"># 是列表</span></span><br><span class="line">            <span class="keyword">return</span> [cls.build(item) <span class="keyword">for</span> item <span class="keyword">in</span> obj]</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 其他</span></span><br><span class="line">            <span class="keyword">return</span> obj</span><br></pre></td></tr></table></figure><p>我们要记住重要的一点，<strong>仅当无法使用常规的方式获取属性（即在实例、类或超类中找不到指定的属性），解释器才会调用特殊的<code>__getattr__</code>方法。</strong>这个方法首先查看<code>self.__data</code>字典有没有指定名称的属性（不是键），这样FrozenJSON实例便可以处理字典的所有方法，例如把items方法委托给<code>self.__data.items</code>方法。如果<code>self.__data</code>没有指定名称的属性，那么<code>__getattr__</code>方法以那个名称为键，从<code>self.__data</code>中获取一个元素，传给FrozenJSON.build方法。这样就能深入JSON数据的嵌套结构，使用类方法build把每一层嵌套转换成一个FrozenJSON实例。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> osconfeed <span class="keyword">import</span> load</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> explore0 <span class="keyword">import</span> FrozenJSON</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>raw_feed = load()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>feed = FrozenJSON(raw_feed)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(feed.Schedule.speakers)</span><br><span class="line"><span class="number">357</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(feed.Schedule.keys())</span><br><span class="line">[<span class="string">'conferences'</span>, <span class="string">'events'</span>, <span class="string">'speakers'</span>, <span class="string">'venues'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>talk = feed.Schedule.events[<span class="number">40</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(talk)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">explore0</span>.<span class="title">FrozenJSON</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">talk</span>.<span class="title">name</span></span></span><br><span class="line"><span class="class">'<span class="title">There</span> *<span class="title">Will</span>* <span class="title">Be</span> <span class="title">Bugs</span>'</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">talk</span>.<span class="title">flavor</span></span></span><br><span class="line"><span class="class"><span class="title">Traceback</span> <span class="params">(most recent call last)</span>:</span></span><br><span class="line">  File <span class="string">"/Users/cws/Desktop/explore0.py"</span>, line <span class="number">15</span>, <span class="keyword">in</span> __getattr__</span><br><span class="line">    <span class="keyword">return</span> FrozenJSON.build(self.__data[name])</span><br><span class="line">KeyError: <span class="string">'flavor'</span>  <span class="comment"># 这个也出来了？</span></span><br><span class="line"></span><br><span class="line">During handling of the above exception, another exception occurred:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"/Users/cws/Desktop/explore0.py"</span>, line <span class="number">19</span>, <span class="keyword">in</span> __getattr__</span><br><span class="line">    <span class="keyword">raise</span> AttributeError(msg.format(type(self).__name__, name))</span><br><span class="line">AttributeError: <span class="string">'FrozenJSON'</span> object has no attribute <span class="string">'flavor'</span></span><br></pre></td></tr></table></figure><p>注意，我们没有缓存或转换原始数据源。在迭代数据源的过程中，嵌套的数据结构不断被转换成FrozenJSON对象。这么做没问题，因为数据集不大，而且这个脚本只用于访问或转换数据。</p><p>从随机源中生成或仿效动态属性名的脚本都必须处理一个问题：原始数据中的键可能不适合作为属性名。</p><h2 id="处理无效属性名">处理无效属性名</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>grad = FrozenJSON(&#123;<span class="string">'name'</span>: <span class="string">'Jim Bo'</span>, <span class="string">'class'</span>: <span class="number">1982</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grad.<span class="keyword">class</span>  <span class="comment"># 无法读取，因为在Python中class是保留字</span></span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    grad.<span class="keyword">class</span></span><br><span class="line">             ^</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(grad, <span class="string">'class'</span>)  <span class="comment"># 可以这么做，但是不够便利</span></span><br><span class="line"><span class="number">1982</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>explore1.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword  <span class="comment"># 检查关键字</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># FrozenJSON类中修改</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, mapping)</span>:</span></span><br><span class="line">        self.__data = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> mapping.items():  <span class="comment"># 检查每个键名</span></span><br><span class="line">            <span class="keyword">if</span> keyword.iskeyword(key):  <span class="comment"># 在关键字的属性后面加_</span></span><br><span class="line">                key += <span class="string">'_'</span></span><br><span class="line">            self.__data[key] = value</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> osconfeed <span class="keyword">import</span> load</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grad = FrozenJSON(&#123;<span class="string">'name'</span>: <span class="string">'Jim Bo'</span>, <span class="string">'class'</span>: <span class="number">1982</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grad.class_  <span class="comment"># 这样访问</span></span><br></pre></td></tr></table></figure><p>如果JSON对象中的键不是有效的Python标识符，也会遇到类似的问题：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = FrozenJSON(&#123;<span class="string">'2be'</span>:<span class="string">'or not'</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x<span class="number">.2</span>be</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    x<span class="number">.2</span>be</span><br><span class="line">      ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><p>这种有问题的键在Python3中易于检测，因为str类提供的isidentifier方法能根据语言的语法判断s是否为有效的Python标识符。但是，把无效的标识符变成有效的属性名却不容易。对此，有两个简单的解决方法，一个是抛出异常，另一个是把无效的键换成通用名称，例如attr_0、attr_1，等等。</p><p>类方法build把嵌套结构转换成FrozenJSON实例或FrozenJSON实例列表，因为<code>__getattr__</code>方法使用这个方法访问属性时，能为不同的值返回不同类型的对象。除了在类方法中实现这样的逻辑之外，还可以在特殊的<code>__new__</code>方法中实现。</p><h2 id="使用__new__方法以灵活的方式创建对象">使用<code>__new__</code>方法以灵活的方式创建对象</h2><p>我们通常把<code>__init__</code>称为构造方法，这是从其他语言借鉴过来的术语。其实，用于构建实例的是特殊方法<code>__new__</code>：这是个类方法（使用特殊方式处理，因此不必使用@classmethod装饰器），必须返回一个实例。返回的实例会作为第一个参数（即self）传给<code>__init__</code>方法。因为调用<code>__init__</code>方法时要传入实例，而且禁止返回任何值，所以<code>__init__</code>方法其实是“初始化方法”。真正的构造方法是<code>__new__</code>。我们几乎不需要自己编写<code>__new__</code>方法，因为从object类继承的实现已经足够了。</p><p>从<code>__new__</code>方法到<code>__init__</code>方法，是最常见的，但不是唯一的。<code>__new__</code>方法也可以返回其他类的实例，此时，解释器不会调用<code>__init__</code>方法。</p><p>也就是说，Python构建对象的过程可以使用下述伪代码概括：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构建对象的伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object_maker</span><span class="params">(the_class, some_arg)</span>:</span></span><br><span class="line">    new_object = the_class.__new__(some_arg)</span><br><span class="line">    <span class="keyword">if</span> isinstance(new_object, the_class):</span><br><span class="line">        the_class.__init__(new_object, some_arg)</span><br><span class="line">    <span class="keyword">return</span> new_object</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下述两个语句的作用基本等效</span></span><br><span class="line">x = Foo(<span class="string">'bar'</span>)</span><br><span class="line">x = object_maker(Foo, <span class="string">'bar'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>explore2.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrozenJSON</span>:</span></span><br><span class="line">    <span class="string">"""一个只读接口，使用属性表示法访问JSON类对象</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, arg)</span>:</span>  <span class="comment"># 第一个参数是类本身</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(arg, abc.Mapping):</span><br><span class="line">            <span class="keyword">return</span> super().__new__(cls)  <span class="comment"># 默认的行为</span></span><br><span class="line">        <span class="keyword">elif</span> isinstance(arg, abc.MutableSequence):</span><br><span class="line">            <span class="keyword">return</span> [cls(item) <span class="keyword">for</span> item <span class="keyword">in</span> arg]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> arg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, mapping)</span>:</span></span><br><span class="line">        self.__data = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> mapping.items():</span><br><span class="line">            <span class="keyword">if</span> iskeyword(key):</span><br><span class="line">                key += <span class="string">'_'</span></span><br><span class="line">            self.__data[key] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(self.__data, name):</span><br><span class="line">            <span class="keyword">return</span> getattr(self.__data, name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> FrozenJSON(self.__data[name])  <span class="comment"># 直接调用构造方法</span></span><br></pre></td></tr></table></figure><p><code>__new__</code>方法的第一个参数是类，因为创建的对象通常是那个类的实例。所以，在<code>FrozenJSON.__new__</code>方法中，<code>super().__new__(cls)</code>表达式会调用<code>object.__new__(FrozenJSON)</code>，而object类构建的实例其实是FrozenJSON实例，即那个实例的<code>__class__</code>属性存储的是FrozenJSON类的引用。不过，真正的构建操作由解释器调用C语言实现的<code>object.__new__</code>方法执行。</p><p>OSCON的JSON数据源有一个明显的缺点：索引为40的事件，即名为'There *Will* Be Bugs'的那个，有两位演讲者，3471和5199，但却不容易找到他们，因为提供的是编号，而 Schedule.speakers列表没有使用编号建立索引。此外，每条事件记录中都有venue_serial字段，存储的值也是编号，但是如果想找到对应的记录，那就要线性搜索Schedule.venues列表。接下来的任务是，调整数据结构，以便自动获取所链接的记录。</p><h2 id="使用shelve模块调整oscon数据源的结构">使用shelve模块调整OSCON数据源的结构</h2><p>标准库中有个<a href="https://devdocs.io/python~3.6/library/shelve" target="_blank" rel="noopener">shelve</a>（架子）模块，shelve模块提供了pickle（泡菜，Python对象序列化格式的名字）存储方式。</p><p><a href="https://devdocs.io/python~3.6/library/shelve#shelve.open" target="_blank" rel="noopener">shelve.open</a>高阶函数返回一个shelve.Shelf实例，这是简单的键值对象数据库，背后由<a href="https://devdocs.io/python~3.6/library/dbm" target="_blank" rel="noopener">dbm</a>模块支持，具有下述特点：</p><ul><li>shelve.Shelf是abc.MutableMapping的子类，因此提供了处理映射类型的重要方法。</li><li>此外，shelve.Shelf类还提供了几个管理I/O的方法，如sync和close；它也是一个上下文管理器。</li><li>只要把新值赋予键，就会保存键和值。</li><li>键必须是字符串。</li><li>值必须是pickle模块能处理的对象。</li></ul><p>shelve模块为识别OSCON的日程数据提供了一种简单有效的方式。我们将从JSON文件中读取所有记录，将其存在一个shelve.Shelf对象中，键由记录类型和编号组成（例如，'event.33950'或'speaker.3471'），而值是我们即将定义的Record类的实例。</p><figure class="highlight python"><figcaption><span>schedule1.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> osconfeed</span><br><span class="line"></span><br><span class="line">DB_NAME = <span class="string">'data/schedule1_db'</span></span><br><span class="line">CONFERENCE = <span class="string">'conference.115'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Record</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        self.__dict__.update(kwargs)  <span class="comment"># 更新实例的__dict__属性</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_db</span><span class="params">(db)</span>:</span></span><br><span class="line">    raw_data = osconfeed.load()  <span class="comment"># 加载数据</span></span><br><span class="line">    warnings.warn(<span class="string">'loading '</span> + DB_NAME)</span><br><span class="line">    <span class="keyword">for</span> collection, rec_list <span class="keyword">in</span> raw_data[<span class="string">'Schedule'</span>].items():</span><br><span class="line">        record_type = collection[:<span class="number">-1</span>]  <span class="comment"># 去掉尾部's'后的集合名，例如event</span></span><br><span class="line">        <span class="keyword">for</span> record <span class="keyword">in</span> rec_list:</span><br><span class="line">            key = <span class="string">'&#123;&#125;.&#123;&#125;'</span>.format(record_type, record[<span class="string">'serial'</span>])</span><br><span class="line">            record[<span class="string">'serial'</span>] = key  <span class="comment"># 把serial的值设置为完整的键：type.serial</span></span><br><span class="line">            db[key] = Record(**record)  <span class="comment"># 在数据库中存储Record实例</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python -i schedule1.py  <span class="comment"># 启动加载了schedule1模块的控制台</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> shelve</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db = shelve.open(DB_NAME)  <span class="comment"># 打开数据库，或者新建一个</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> CONFERENCE <span class="keyword">not</span> <span class="keyword">in</span> db:  <span class="comment"># 判断数据库是否填充</span></span><br><span class="line"><span class="meta">... </span>    load_db(db)  <span class="comment"># 加载数据库</span></span><br><span class="line">...</span><br><span class="line">schedule1.py:<span class="number">14</span>: UserWarning: loading data/schedule1_db</span><br><span class="line">  warnings.warn(<span class="string">'loading '</span> + DB_NAME)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>speaker = db[<span class="string">'speaker.3471'</span>]  <span class="comment"># 一条speaker记录</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(speaker)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Record</span>'&gt;</span></span><br><span class="line">&gt;&gt;&gt; speaker.name, speaker.twitter  # 在某些应用中，Record类可能要处理不能作为属性名使用的键</span><br><span class="line">(<span class="string">'Anna Ravenscroft'</span>, <span class="string">'annaraven'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db.close()  <span class="comment"># 关闭Shelf对象。如果可以，使用with块确保Shelf对象会关闭</span></span><br></pre></td></tr></table></figure><p>FrozenJSON类要递归转换嵌套的映射和列表；而Record类不需要这么做，因为转换好的数据集中没有嵌套的映射和列表，记录中只有字符串、整数、字符串列表和整数列表。FrozenJSON类要访问内嵌的<code>__data</code>（值是字典）属性，而现在我们不需要这么做了（因为<code>self.__dict__.update(kwargs)</code>已经将传入的键值对保存到实例属性中了）。</p><p>Python标准库中至少有两个与Record类似的类，其实例可以有任意个属性，由传给构造方法的关键字参数构建——<a href="https://devdocs.io/python~3.6/library/multiprocessing#multiprocessing.managers.Namespace" target="_blank" rel="noopener">multiprocessing.managers.Namespace</a>类和<a href="https://devdocs.io/python~3.6/library/argparse#argparse.Namespace" target="_blank" rel="noopener">argparse.Namespace</a>类。之所以自己实现Record，是为了说明一个重要的做法：在<code>__init__</code>方法中更新实例的<code>__dict__</code>属性。</p><h2 id="使用特性获取链接的记录">使用特性获取链接的记录</h2><p>我们可以扩展Record类，让它提供一个有用的服务：自动获取event记录引用的venue和speaker记录，而不是编号。</p><img src="http://www.plantuml.com/plantuml/svg/TOzH3i8W44J_UugzW3VmKo_W1KWBeoLAmMKrQR1t5ojfBAdxHTumkpEzDI2u82Cvk0xSw5iR8vsWFHjA3UL93j9xCv5ITh2YL4rnpsmgraEtDaTfnUhypNHhtw94o7_niY6U8RgdDDyhh8x42FmJwlZ482LHVZv0AR0FO1c_rXZGNi6nvbihIx_zQxUKRPRM7pfVUmC0"><p>Record：<code>__init__</code>方法不变；为了辅助测试，增加了<code>__eq__</code>方法。</p><p>DbRecord：Record类的子类，添加了<code>__db</code>类属性，用于设置和获取<code>__db</code>属性的set_db和get_db静态方法，用于从数据库中获取记录的fetch类方法，以及辅助调试和测试的<code>__repr__</code>实例方法。</p><p>Event：DbRecord类的子类，添加了用于获取所链接记录的venue和speakers属性，以及特殊的<code>__repr__</code>方法。</p><figure class="highlight python"><figcaption><span>schedule2.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> osconfeed</span><br><span class="line"></span><br><span class="line">DB_NAME = <span class="string">'data/schedule2_db'</span></span><br><span class="line">CONFERENCE = <span class="string">'conference.115'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Record</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        self.__dict__.update(kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(other, Record):</span><br><span class="line">            <span class="keyword">return</span> self.__dict__ == other.__dict__</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MissingDatabaseError</span><span class="params">(RuntimeError)</span>:</span>  <span class="comment"># 自定义的异常通常是标志类</span></span><br><span class="line">    <span class="string">"""需要数据库但没有指定数据库时抛出"""</span>   <span class="comment"># 没有定义体，写一个文档字符串</span></span><br><span class="line">                                        <span class="comment"># 说明异常的用途，比pass语句要好</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DbRecord</span><span class="params">(Record)</span>:</span>  <span class="comment"># 扩展Record类</span></span><br><span class="line"></span><br><span class="line">    __db = <span class="literal">None</span>  <span class="comment"># 存储一个打开的Shelf数据库引用</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod  # 静态方法，以此强调不管调用多少次</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_db</span><span class="params">(db)</span>:</span>  <span class="comment"># 效果始终一样</span></span><br><span class="line">        DbRecord.__db = db</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_db</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> DbRecord.__db</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod  # 类方法，在子类中易于定制它的行为</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(cls, ident)</span>:</span></span><br><span class="line">        db = cls.get_db()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> db[ident]  <span class="comment"># 从数据库中获取</span></span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="keyword">if</span> db <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 数据库为空时，抛出自定义异常</span></span><br><span class="line">                msg = <span class="string">"database not set; call '&#123;&#125;.set_db(my_db)'"</span></span><br><span class="line">                <span class="keyword">raise</span> MissingDatabseError(msg.format(cls.__name__))</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 否则重新抛出TypeError，因为我们不知道怎么处理</span></span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(self, <span class="string">'serial'</span>):</span><br><span class="line">            cls_name = self.__class__.__name__</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'&lt;&#123;&#125; serial=&#123;!r&#125;&gt;'</span>.format(cls_name, self.serial)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 调用继承的方法</span></span><br><span class="line">            <span class="keyword">return</span> super().__repr__()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span><span class="params">(DbRecord)</span>:</span>  <span class="comment"># 扩展DbRecord类</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">venue</span><span class="params">(self)</span>:</span>  <span class="comment"># venue特性</span></span><br><span class="line">        key = <span class="string">'venue.&#123;&#125;'</span>.format(self.venue_serial)</span><br><span class="line">        <span class="keyword">return</span> self.__class__.fetch(key)  <span class="comment"># 不直接使用self.fetch(key)</span></span><br><span class="line">        <span class="comment"># 对这个OSCON数据源来说，可以使用后者，因为事件记录都没有'fetch'键</span></span><br><span class="line">        <span class="comment"># 哪怕只有一个事件记录有名为'fetch'的键，那么在那个Event实例中</span></span><br><span class="line">        <span class="comment"># self.fetch获取的是fetch字段的值，而不是继承自DbRecord的fetch类方法</span></span><br><span class="line">        <span class="comment"># 这个缺陷不明显，很容易被测试忽略</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speakers</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">'_speaker_objs'</span>):</span><br><span class="line">            <span class="comment"># 从__dict__实例属性中获取</span></span><br><span class="line">            <span class="comment"># self.speakers会出现无限递归，因为特性的公开名称也是speakers</span></span><br><span class="line">            spkr_serials = self.__dict__[<span class="string">'speakers'</span>]</span><br><span class="line">            fetch = self.__class__.fetch  <span class="comment"># 获取类方法的引用</span></span><br><span class="line">            self._speaker_objs = [fetch(<span class="string">'speaker.&#123;&#125;'</span>.format(key))</span><br><span class="line">                                  <span class="keyword">for</span> key <span class="keyword">in</span> spkr_serials]</span><br><span class="line">        <span class="keyword">return</span> self._speaker_objs</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(self, <span class="string">'name'</span>):</span><br><span class="line">            cls_name = self.__class__.__name__</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'&lt;&#123;&#125; &#123;!r&#125;&gt;'</span>.format(cls_name, self.name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> super().__repr__()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_db</span><span class="params">(db)</span>:</span></span><br><span class="line">    raw_data = osconfeed.load()</span><br><span class="line">    warnings.warn(<span class="string">'loading '</span> + DB_NAME)</span><br><span class="line">    <span class="keyword">for</span> collection, rec_list <span class="keyword">in</span> raw_data[<span class="string">'Schedule'</span>].items():</span><br><span class="line">        record_type = collection[:<span class="number">-1</span>]</span><br><span class="line">        cls_name = record_type.capitalize()  <span class="comment"># 首字母大写，例如Event</span></span><br><span class="line">        <span class="comment"># 从模块的全局作用域中获取对应的对象，默认使用DbRecord</span></span><br><span class="line">        <span class="comment"># 只有事件类型的记录有自定义的类——Event。不过，如果定义了</span></span><br><span class="line">        <span class="comment"># Speaker或Venue类，load_db函数构建和保存记录时会自动使用这两个类</span></span><br><span class="line">        cls = globals().get(cls_name, DbRecord)</span><br><span class="line">        <span class="keyword">if</span> inspect.isclass(cls) <span class="keyword">and</span> issubclass(cls, DbRecord):</span><br><span class="line">            factory = cls</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            factory = DbRecord</span><br><span class="line">        <span class="keyword">for</span> record <span class="keyword">in</span> rec_list:</span><br><span class="line">            key = <span class="string">'&#123;&#125;.&#123;&#125;'</span>.format(record_type, record[<span class="string">'serial'</span>])</span><br><span class="line">            record[<span class="string">'serial'</span>] = key</span><br><span class="line">            db[key] = factory(**record)</span><br></pre></td></tr></table></figure><p><strong>从数据中创建实例属性的名称时有可能会引入缺陷，因为类属性（例如方法）可能被遮盖，或者由于意外覆盖现有的实例属性而丢失数据。这个问题可能是Python字典不能像JavaScript对象那样（obj.key）访问的原因。</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python -i schedule2.py</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> shelve</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db = shelve.open(DB_NAME)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>load_db(db)</span><br><span class="line">schedule2.py:<span class="number">85</span>: UserWarning: loading data/schedule2_db</span><br><span class="line">  warnings.warn(<span class="string">'loading '</span> + DB_NAME)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db[<span class="string">'event.33950'</span>]  <span class="comment"># 现在获取的是记录对象，而不是编号</span></span><br><span class="line">&lt;Event <span class="string">'There *Will* Be Bugs'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>DbRecord.set_db(db)  <span class="comment"># 将数据库放入类中，方便操作</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>event = DbRecord.fetch(<span class="string">'event.33950'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>event.venue  <span class="comment"># 返回记录</span></span><br><span class="line">&lt;DbRecord serial=<span class="string">'venue.1449'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>event.venue.name  <span class="comment"># 找出venue.name更容易了</span></span><br><span class="line"><span class="string">'Portland 251'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> spkr <span class="keyword">in</span> event.speakers:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'&#123;0.serial&#125;: &#123;0.name&#125;'</span>.format(spkr))</span><br><span class="line">...</span><br><span class="line">speaker<span class="number">.3471</span>: Anna Ravenscroft</span><br><span class="line">speaker<span class="number">.5199</span>: Alex Martelli</span><br></pre></td></tr></table></figure><p>特性经常用于把公开的属性变成使用读值方法和设值方法管理的属性，且在不影响代码的前提下实施业务规则。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> attribute </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>让pyplot支持汉字</title>
      <link href="/programming/support-chinese-character-in-pyplot/"/>
      <url>/programming/support-chinese-character-in-pyplot/</url>
      
        <content type="html"><![CDATA[<p><a href="https://devdocs.io/matplotlib~3.1/font_manager_api#matplotlib.font_manager.FontProperties" target="_blank" rel="noopener"><code>class matplotlib.font_manager.FontProperties(family=None, style=None, variant=None, weight=None, stretch=None, size=None, fname=None)</code></a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib.font_manager <span class="keyword">import</span> FontProperties</span><br><span class="line"></span><br><span class="line">font = FontProperties(fname=<span class="string">'/System/Library/Fonts/PingFang.ttc'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># in most functions, key is fontproperties (see valid kwargs in pyplot)</span></span><br><span class="line">plt.text(<span class="number">0</span>, <span class="number">0</span>, <span class="string">'你好！'</span>, fontproperties=font, ha=<span class="string">'center'</span>)</span><br><span class="line">x = np.linspace(-np.pi, np.pi, <span class="number">201</span>)</span><br><span class="line">plt.plot(x, np.sin(x), label=<span class="string">'sin函数'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'x轴'</span>, fontproperties=font)</span><br><span class="line">plt.ylabel(<span class="string">'y轴'</span>, fontproperties=font)</span><br><span class="line"></span><br><span class="line"><span class="comment"># in legend, key is prop</span></span><br><span class="line">plt.legend(prop=font, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="/uploads/image/support-chinese-character.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pyplot中合法的kwargs关键字</title>
      <link href="/documentation/valid-kwargs-in-pyplot/"/>
      <url>/documentation/valid-kwargs-in-pyplot/</url>
      
        <content type="html"><![CDATA[<p><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text" target="_blank" rel="noopener"><code>class matplotlib.text.Text(x=0, y=0, text='', color=None, verticalalignment='baseline', horizontalalignment='left', multialignment=None, fontproperties=None, rotation=None, linespacing=None, rotation_mode=None, usetex=None, wrap=False, **kwargs)</code></a></p><table><colgroup><col style="width: 28%"><col style="width: 71%"></colgroup><thead><tr class="header"><th style="text-align: left;">Property</th><th style="text-align: left;">Description</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_agg_filter#matplotlib.artist.Artist.set_agg_filter" target="_blank" rel="noopener"><code>agg_filter</code></a></td><td style="text-align: left;">a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_alpha#matplotlib.artist.Artist.set_alpha" target="_blank" rel="noopener"><code>alpha</code></a></td><td style="text-align: left;">float</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_animated#matplotlib.artist.Artist.set_animated" target="_blank" rel="noopener"><code>animated</code></a></td><td style="text-align: left;">bool</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_backgroundcolor" target="_blank" rel="noopener"><code>backgroundcolor</code></a></td><td style="text-align: left;">color</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_bbox" target="_blank" rel="noopener"><code>bbox</code></a></td><td style="text-align: left;">dict with properties for <a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.patches.fancybboxpatch#matplotlib.patches.FancyBboxPatch" target="_blank" rel="noopener"><code>patches.FancyBboxPatch</code></a></td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_clip_box" target="_blank" rel="noopener"><code>clip_box</code></a></td><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/transformations#matplotlib.transforms.Bbox" target="_blank" rel="noopener"><code>Bbox</code></a></td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_clip_on" target="_blank" rel="noopener"><code>clip_on</code></a></td><td style="text-align: left;">bool</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_clip_path" target="_blank" rel="noopener"><code>clip_path</code></a></td><td style="text-align: left;">[(<a href="https://devdocs.io/matplotlib~3.1/path_api#matplotlib.path.Path" target="_blank" rel="noopener"><code>Path</code></a>, <a href="https://devdocs.io/matplotlib~3.1/transformations#matplotlib.transforms.Transform" target="_blank" rel="noopener"><code>Transform</code></a>)</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_color" target="_blank" rel="noopener"><code>color</code></a> or c</td><td style="text-align: left;">color</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_contains#matplotlib.artist.Artist.set_contains" target="_blank" rel="noopener"><code>contains</code></a></td><td style="text-align: left;">callable</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_figure#matplotlib.artist.Artist.set_figure" target="_blank" rel="noopener"><code>figure</code></a></td><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure" target="_blank" rel="noopener"><code>Figure</code></a></td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_fontfamily" target="_blank" rel="noopener"><code>fontfamily</code></a> or family</td><td style="text-align: left;">{FONTNAME, 'serif', 'sans-serif', 'cursive', 'fantasy', 'monospace'}</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_fontproperties" target="_blank" rel="noopener"><code>fontproperties</code></a> or font_properties</td><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/font_manager_api#matplotlib.font_manager.FontProperties" target="_blank" rel="noopener"><code>font_manager.FontProperties</code></a></td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_fontsize" target="_blank" rel="noopener"><code>fontsize</code></a> or size</td><td style="text-align: left;">{size in points, 'xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'}</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_fontstretch" target="_blank" rel="noopener"><code>fontstretch</code></a> or stretch</td><td style="text-align: left;">{a numeric value in range 0-1000, 'ultra-condensed', 'extra-condensed', 'condensed', 'semi-condensed', 'normal', 'semi-expanded', 'expanded', 'extra-expanded', 'ultra-expanded'}</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_fontstyle" target="_blank" rel="noopener"><code>fontstyle</code></a> or style</td><td style="text-align: left;">{'normal', 'italic', 'oblique'}</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_fontvariant" target="_blank" rel="noopener"><code>fontvariant</code></a> or variant</td><td style="text-align: left;">{'normal', 'small-caps'}</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_fontweight" target="_blank" rel="noopener"><code>fontweight</code></a> or weight</td><td style="text-align: left;">{a numeric value in range 0-1000, 'ultralight', 'light', 'normal', 'regular', 'book', 'medium', 'roman', 'semibold', 'demibold', 'demi', 'bold', 'heavy', 'extra bold', 'black'}</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_gid#matplotlib.artist.Artist.set_gid" target="_blank" rel="noopener"><code>gid</code></a></td><td style="text-align: left;">str</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_horizontalalignment" target="_blank" rel="noopener"><code>horizontalalignment</code></a> or ha</td><td style="text-align: left;">{'center', 'right', 'left'}</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_in_layout#matplotlib.artist.Artist.set_in_layout" target="_blank" rel="noopener"><code>in_layout</code></a></td><td style="text-align: left;">bool</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_label#matplotlib.artist.Artist.set_label" target="_blank" rel="noopener"><code>label</code></a></td><td style="text-align: left;">object</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_linespacing" target="_blank" rel="noopener"><code>linespacing</code></a></td><td style="text-align: left;">float (multiple of font size)</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_multialignment" target="_blank" rel="noopener"><code>multialignment</code></a> or ma</td><td style="text-align: left;">{'left', 'right', 'center'}</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_path_effects#matplotlib.artist.Artist.set_path_effects" target="_blank" rel="noopener"><code>path_effects</code></a></td><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/patheffects_api#matplotlib.patheffects.AbstractPathEffect" target="_blank" rel="noopener"><code>AbstractPathEffect</code></a></td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_picker#matplotlib.artist.Artist.set_picker" target="_blank" rel="noopener"><code>picker</code></a></td><td style="text-align: left;">None or bool or float or callable</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_position" target="_blank" rel="noopener"><code>position</code></a></td><td style="text-align: left;">(float, float)</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_rasterized#matplotlib.artist.Artist.set_rasterized" target="_blank" rel="noopener"><code>rasterized</code></a></td><td style="text-align: left;">bool or None</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_rotation" target="_blank" rel="noopener"><code>rotation</code></a></td><td style="text-align: left;">{angle in degrees, 'vertical', 'horizontal'}</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_rotation_mode" target="_blank" rel="noopener"><code>rotation_mode</code></a></td><td style="text-align: left;">{None, 'default', 'anchor'}</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_sketch_params#matplotlib.artist.Artist.set_sketch_params" target="_blank" rel="noopener"><code>sketch_params</code></a></td><td style="text-align: left;">(scale: float, length: float, randomness: float)</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_snap#matplotlib.artist.Artist.set_snap" target="_blank" rel="noopener"><code>snap</code></a></td><td style="text-align: left;">bool or None</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_text" target="_blank" rel="noopener"><code>text</code></a></td><td style="text-align: left;">object</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_transform#matplotlib.artist.Artist.set_transform" target="_blank" rel="noopener"><code>transform</code></a></td><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/transformations#matplotlib.transforms.Transform" target="_blank" rel="noopener"><code>Transform</code></a></td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_url#matplotlib.artist.Artist.set_url" target="_blank" rel="noopener"><code>url</code></a></td><td style="text-align: left;">str</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_usetex" target="_blank" rel="noopener"><code>usetex</code></a></td><td style="text-align: left;">bool or None</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_verticalalignment" target="_blank" rel="noopener"><code>verticalalignment</code></a> or va</td><td style="text-align: left;">{'center', 'top', 'bottom', 'baseline', 'center_baseline'}</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_visible#matplotlib.artist.Artist.set_visible" target="_blank" rel="noopener"><code>visible</code></a></td><td style="text-align: left;">bool</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_wrap" target="_blank" rel="noopener"><code>wrap</code></a></td><td style="text-align: left;">bool</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_x" target="_blank" rel="noopener"><code>x</code></a></td><td style="text-align: left;">float</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_y" target="_blank" rel="noopener"><code>y</code></a></td><td style="text-align: left;">float</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_zorder#matplotlib.artist.Artist.set_zorder" target="_blank" rel="noopener"><code>zorder</code></a></td><td style="text-align: left;">float</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用asyncio包处理并发</title>
      <link href="/notes/fluent-python/concurrency-with-asyncio/"/>
      <url>/notes/fluent-python/concurrency-with-asyncio/</url>
      
        <content type="html"><![CDATA[<blockquote><p>并发（concurrency）是指一次处理多件事，关于结构。并行（parallelism）是指一次做多件事，关于执行。并发用于定制方案，用来解决可能（但未必）并行的问题。</p><p>Rob Pike（Go 语言的创造者之一）</p></blockquote><p>真正的并行需要多个核心。现代的笔记本电脑有 4 个CPU核心，但是通常不经意间就有超过 100 个进程同时运行。因此，实际上大多数过程都是并发处理的，而不是并行处理。计算机始终运行着 100 多个进程，确保每个进程都有机会取得进展，不过 CPU 本身同时做的事情不能超过四件。</p><p>asyncio 包使用事件循环驱动的协程实现并发。<em>Guido van Rossum 在 Python 仓库之外开发 asyncio 包，把这个项目的代号命名为 Tulip（郁金香）。Python3.4 把 Tulip 添加到标准库中时，把它重命名为 asyncio。</em></p><h1 id="线程与协程对比">线程与协程对比</h1><p>在控制台中显示一个由 ASCII 字符 &quot;<code>|/-\</code>&quot; 构成的动画旋转指针。一个借由 threading 模块使用线程实现，一个借由 asyncio 包使用协程实现。对比两种实现，理解如何不使用线程来实现并发行为。</p><a id="more"></a><h2 id="线程实现">线程实现</h2><p>使用 threading 模块使用线程实现。</p><figure class="highlight python"><figcaption><span>spinner_thread.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Signal</span>:</span>  <span class="comment"># 定义一个简单的可变对象，用于从外部控制线程</span></span><br><span class="line">    go = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spin</span><span class="params">(msg, signal)</span>:</span>  <span class="comment"># 这个函数会在单独的线程中运行</span></span><br><span class="line">    write, flush = sys.stdout.write, sys.stdout.flush</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> itertools.cycle(<span class="string">'|/-\\'</span>):  <span class="comment"># 无限循环</span></span><br><span class="line">        status = char + <span class="string">' '</span> + msg</span><br><span class="line">        write(status)</span><br><span class="line">        flush()</span><br><span class="line">        write(<span class="string">'\x08'</span> * len(status))  <span class="comment"># 动画的诀窍所在，使用退格符（\x08）把光标移回来</span></span><br><span class="line">        time.sleep(<span class="number">.1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> signal.go:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        write(<span class="string">' '</span> * len(status) + <span class="string">'\x08'</span> * len(status))  <span class="comment"># 使用空格清除状态消息，把光标移回开头</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">slow_function</span><span class="params">()</span>:</span>  <span class="comment"># 假设这是耗时的计算</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)  <span class="comment"># sleep函数会阻塞主线程，不过一定要这么做，以便释放GIL（全局解释器锁）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">supervisor</span><span class="params">()</span>:</span>  <span class="comment"># 这个函数设置从属线程，显示线程对象，运行耗时的计算，最后杀死线程</span></span><br><span class="line">    signal = Signal()</span><br><span class="line">    spinner = threading.Thread(target=spin, args=(<span class="string">'thinking!'</span>, signal))</span><br><span class="line">    print(<span class="string">'spinner object:'</span>, spinner)</span><br><span class="line">    spinner.start()  <span class="comment"># 启动从属线程</span></span><br><span class="line">    result = slow_function()  <span class="comment"># 运行slow_function函数，阻塞主线程。同时，从属线程以动画形式显示旋转指针</span></span><br><span class="line">    signal.go = <span class="literal">False</span>  <span class="comment"># 改变状态，spin函数会终止循环</span></span><br><span class="line">    spinner.join()  <span class="comment"># 等待spinner线程结束</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    result = supervisor()</span><br><span class="line">    print(<span class="string">'Answer:'</span>, result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python spinner_thread.py  # 运行查看动画</span><br><span class="line">spinner object: &lt;Thread(Thread-1, initial)&gt;</span><br><span class="line">Answer: 42!</span><br></pre></td></tr></table></figure><p><strong>Python 没有提供终止线程的 API，这是有意为之的。若想关闭线程，必须给线程发送消息。</strong>这里，使用的是 signal.go 属性：在主线程中把它设为 False 后，spinner 线程最终会注意到，然后干净地退出。</p><h2 id="协程实现">协程实现</h2><p>使用 <code>@asyncio.coroutine</code> 装饰器替代线程，实现相同的行为。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine  # 打算交给asyncio处理的协程建议使用@asyncio.coroutine装饰</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spin</span><span class="params">(msg)</span>:</span>  <span class="comment"># 这里不需要signal参数</span></span><br><span class="line">    write, flush = sys.stdout.write, sys.stdout.flush</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> itertools.cycle(<span class="string">'|/-\\'</span>):</span><br><span class="line">        status = char + <span class="string">' '</span> + msg</span><br><span class="line">        write(status)</span><br><span class="line">        flush()</span><br><span class="line">        write(<span class="string">'\x08'</span> * len(status))</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">.1</span>)  <span class="comment"># 代替time.sleep(.1)，这样的休眠不会阻塞事件循环</span></span><br><span class="line">        <span class="keyword">except</span> asyncio.CancelledError:  <span class="comment"># 若发出了取消请求，会在yield处抛出CancelledError异常</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        write(<span class="string">' '</span> * len(status) + <span class="string">'\x08'</span> * len(status))</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">slow_function</span><span class="params">()</span>:</span>  <span class="comment"># 协程，在用休眠假装进行I/O操作时，使用yield from继续执行事件循环</span></span><br><span class="line">    <span class="comment"># 假装等待I/O一段时间</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">3</span>)  <span class="comment"># 把控制权交给主循环，在休眠结束后恢复这个协程</span></span><br><span class="line">                                 <span class="comment"># 若使用time.sleep(3)，则控制权回不到主循环，</span></span><br><span class="line">                                 <span class="comment"># spinner无法得到运行时间，也就看不到旋转动画和提示消息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">supervisor</span><span class="params">()</span>:</span>  <span class="comment"># 协程，使用yield from驱动slow_function函数</span></span><br><span class="line">    spinner = asyncio.<span class="keyword">async</span>(spin(<span class="string">'thinking!'</span>))  <span class="comment"># async函数排定协程的运行时间，使用一个Task对象包装协程</span></span><br><span class="line">    print(<span class="string">'spinner object:'</span>, spinner)</span><br><span class="line">    result = <span class="keyword">yield</span> <span class="keyword">from</span> slow_function()  <span class="comment"># 驱动slow_function函数。结束后，获取返回值。同时，事件循环继续运行</span></span><br><span class="line">                                         <span class="comment"># 因为slow_function函数最后使用yield from表达式把控制权交回给了主循环</span></span><br><span class="line">                                         <span class="comment"># 若使用result = slow_function()，则同样看不到动画和提示消息</span></span><br><span class="line">    spinner.cancel()  <span class="comment"># Task对象可以取消，取消后会在协程当前暂停的yield处抛出CancelledError异常</span></span><br><span class="line">                      <span class="comment"># 协程可以捕获这个异常，也可以延迟取消，甚至拒绝取消</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    loop = asyncio.get_event_loop()  <span class="comment"># 获取事件循环的引用</span></span><br><span class="line">    result = loop.run_until_complete(supervisor())  <span class="comment"># 驱动supervisor协程， 让它运行完毕</span></span><br><span class="line">    loop.close()</span><br><span class="line">    print(<span class="string">'Answer:'</span>, result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python spinner_asyncio.py  # 运行查看动画</span><br><span class="line">spinner object: &lt;Task pending coro=&lt;spin() running at spinner_asyncio.py:5&gt;&gt;</span><br><span class="line">Answer: 42!</span><br></pre></td></tr></table></figure><p><strong>除非想阻塞主线程，从而冻结事件循环或整个应用，否则不要在 asyncio 协程中使用 time.sleep 函数。如果协程需要在一段时间内什么也不做，应该使用 yield from asyncio.sleep(DELAY)。</strong></p><p>使用 <code>@asyncio.coroutine</code> 装饰器不是强制要求，但是强烈建议这么做，因为这样能在一众普通的函数中把协程凸显出来，也有助于调试：如果还没从中产出值，协程就被垃圾回收了（意味着有操作未完成，因此有可能是个缺陷），那就可以发出警告。这个装饰器不会预激协程。</p><p>supervisor 函数是这两个示例的核心。下面详细对比二者。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 线程版</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">supervisor</span><span class="params">()</span>:</span></span><br><span class="line">    signal = Signal()</span><br><span class="line">    spinner = threading.Thread(target=spin, args=(<span class="string">'thinking!'</span>, signal))</span><br><span class="line">    print(<span class="string">'spinner object:'</span>, spinner)</span><br><span class="line">    spinner.start()</span><br><span class="line">    result = slow_function()</span><br><span class="line">    signal.go = <span class="literal">False</span></span><br><span class="line">    spinner.join()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 异步版</span></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">supervisor</span><span class="params">()</span>:</span></span><br><span class="line">    spinner = asyncio.<span class="keyword">async</span>(spin(<span class="string">'thinking!'</span>))</span><br><span class="line">    print(<span class="string">'spinner object:'</span>, spinner)</span><br><span class="line">    result = <span class="keyword">yield</span> <span class="keyword">from</span> slow_function()</span><br><span class="line">    spinner.cancel()</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>这两种实现之间的主要区别概述如下：</p><ul><li>asyncio.Task 对象差不多与 threadig.Thread 对象等效。Task 对象像是实现协作式多任务的库中的绿色线程。</li><li>Task 对象用于驱动协程，Thread 对象用于调用可调用的对象。</li><li>Task 对象不由自己动手实例化，而是通过把协程传给 asyncio.async 函数或 loop.create_task 方法获取。</li><li>获取的 Task 对象已经排定了运行时间（例如，由 asyncio.async 函数排定）；Thread 实例必须调用 start 方法，明确告知让它运行。</li><li>在线程版 supervisor 函数中，slow_function 函数是普通的函数，直接由线程调用。在异步版 supervisor 函数中，slow_function 函数是协程，由 yield from驱动。</li><li>没有 API 能从外部终止线程，因为线程随时可能被中断，导致系统处于无效状态。如果想终止任务，可以使用 Task.cancel 实例方法，在协程内部抛出 CancelledError 异常。协程可以在暂停的 yield 处捕获这个异常，处理终止请求。</li><li>supervisor 协程必须在 main 函数中由 loop.run_until_complete 方法执行。</li></ul><p>如果使用线程做过重要的编程，你就直到写出程序有多么困难，因为调度程序任何时候都能中断线程。必须记住保留锁，去保护程序中的重要部分，防止多步操作在执行的过程中中断，防止数据处于无效状态。</p><p>而协程默认会做好全方位保护，以防止中断。我们必须显示产出才能让程序的余下部分运行。对协程来说，无需保留锁，在多个线程之间同步操作，协程自身就会同步，因为在任意时刻只有一个协程运行。想交出控制权时，可以使用 yield 或 yield from 把控制权交还调度程序。这就是能够安全地取消协程的原因：按照定义，协程只能在暂停的 yield 处取消，因此可以处理 CancelledError 异常，执行清理操作。</p><p>下面说明 asyncio.Future 类与 concurrent.futures.Future 类之间的区别。</p><h2 id="asyncio.future故意不阻塞">asyncio.Future：故意不阻塞</h2><p><strong>asyncio.Future 类与 concurrent.futures.Future 类的接口基本一致，不过实现方式不同，不可以互换。</strong></p><p>期物只是调度执行某物的结果。在 asyncio 包中，BaseEventLoop.create_task 方法接收一个协程，排定它的运行时间，然后返回一个 asyncio.Task 实例——也是 asyncio.Future 类的实例，因为 Task 是 Future 的子类，用于包装协程。这与调用 Executor.submit 方法创建 concurrent.futures.Future 实例是一个道理。</p><p>与 concurrent.futures.Future 类似，asyncio.Future 类也提供了 done、add_done_callback 和 result 等方法。前两个方法的用法类似，不过 result 方法差别很大。</p><p>asyncio.Future.result 方法没有参数，因此不能指定超时时间。此外，如果调用 result 方法时期物还没运行完毕，那么 result 方法不会阻塞去等待结果，而是抛出 asyncio.InvalidStatueError 异常。</p><p>然而，获取 asyncio.Future 对象的结果通常使用 yield from，从中产出结果。</p><p>使用 yield from 处理期物，等待期物运行完毕这一步无需我们关心，而且不会阻塞事件循环，因为在 asyncio 包中，yield from 的作用是把控制权还给事件循环。</p><p>注意，使用 yield from 处理期物，与使用 add_done_callback 方法处理协程的作用一样：延迟的操作结束后，事件循环不会出发回调对象，而是设置期物的返回值；而 yield from 表达式则在暂停的协程中生成返回值，恢复执行协程。</p><p><strong>总之，因为 asyncio.Future 类的目的是与 yield from 一起使用，所以通常不需要使用以下方法。</strong></p><ul><li><p>无需调用 my_future.add_done_callback，因为可以直接把想在期物运行结束后执行的操作放在协程中 yield from my_future 表达式的后面。这是协程的一大优势：协程是可以暂停和恢复的函数。</p></li><li><p>无需调用 my_future.result，因为 yield from 从期物中产出的值就是结果（例如，result = yield from my_future）。</p></li></ul><p>当然，有时也需要使用 done、add_done_callback 和 result 方法。但一般情况下，asyncio.Future 对象由 yield from 驱动，而不是靠调用这些方法驱动。</p><p>下面分析 yield from 和 asyncio 包的 API 如何拉近期物、任务和协程的关系。</p><h2 id="从期物任务和协程中产出">从期物、任务和协程中产出</h2><p>在 asyncio 包中，期物和协程的关系紧密，因为可以使用 yield from从asyncio.Future 对象中产出结果。这意味着，如果 foo 是协程函数（调用后返回协程对象），抑或是返回 Future 或 Task 实例的普通函数，那么可以这样写：<code>res = yield from foo()</code>。这是 asyncio 包的 API 中很多地方可以互换协程与期物的原因之一。</p><h1 id="从回调到期物到协程">从回调到期物到协程</h1><p>使用协程做面向事件编程，需要下一番功夫才能掌握，因此最好知道，与经典的回调式编程相比，协程有哪些改进。</p><p>“回调地狱”：如果一个操作需要依赖之前操作的结果，那就得嵌套回调。如果要连续做 3 次异步调用，那就需要嵌套 3 层回调。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JavaScript中的回调地狱：嵌套匿名函数，也称为灾难金字塔</span></span><br><span class="line">api_call1(request1, <span class="function"><span class="keyword">function</span> (<span class="params">response1</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第一步</span></span><br><span class="line">    <span class="keyword">var</span> request2 = step1(response1);  <span class="comment">// 处理回调收到的响应</span></span><br><span class="line">    aip_call2(requset2, <span class="function"><span class="keyword">function</span> (<span class="params">response2</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 第二步</span></span><br><span class="line">        ver request3 = step2(response2);</span><br><span class="line">        api_call3(request3, <span class="function"><span class="keyword">function</span> (<span class="params">response3</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 第三步</span></span><br><span class="line">            step(response3)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python中的回调地狱：链式回调</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stage1</span><span class="params">(response1)</span>:</span></span><br><span class="line">    request2 = step1(response1)</span><br><span class="line">    api_call2(request2, stage2)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stage2</span><span class="params">(response2)</span>:</span></span><br><span class="line">    request3 = step2(response2)</span><br><span class="line">    api_call3(request3, stage3)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stage3</span><span class="params">(response3)</span>:</span></span><br><span class="line">    step3(response3)</span><br><span class="line"></span><br><span class="line">api_call(request1, stage1)</span><br></pre></td></tr></table></figure><p>虽然代码的排布方式差异很大，但是作用却完全相同。JavaScript 示例也能改写成链式风格，但是 Python 代码不能改写成嵌套风格，因为 lambda 表达式句法上有限制。</p><p>上述组织代码的方式导致代码难以阅读，也更难编写：每个函数做一部分工作，设置下一个回调，然后返回，让事件循环继续运行。这样，所有本地的上下文都会丢失。执行下一个回调时（例如 stage2），就无法获取 request2 的值。如果需要那个值，那就必须依靠闭包，或者把它存储在外部数据结构中，以便在处理过程的不同阶段使用。</p><p>在这个问题上，协程能发挥很大的作用。在协程汇总，如果要连续执行 3 个异步操作，只需使用 yield 3 次，让事件循环继续运行。准备好结果后，调用 send 方法，激活协程。对事件循环来说，这种做法与调用回调类似。但是对使用协程式异步 API 的用户来说，情况就大为不同了：3 次操作都在同一个函数定义体中，像是顺序代码，能在处理过程中使用局部变量保留整个任务的上下文。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">three_stages</span><span class="params">(request1)</span>:</span></span><br><span class="line">    response1 = <span class="keyword">yield</span> <span class="keyword">from</span> api_call1(request1)</span><br><span class="line">    <span class="comment"># 第一步</span></span><br><span class="line">    request2 = step1(response1)</span><br><span class="line">    response2 = <span class="keyword">yield</span> <span class="keyword">from</span> api_call2(request2)</span><br><span class="line">    <span class="comment"># 第二步</span></span><br><span class="line">    request3 = step2(response2)</span><br><span class="line">    response3 = <span class="keyword">yield</span> <span class="keyword">from</span> api_call3(request3)</span><br><span class="line">    <span class="comment"># 第三步</span></span><br><span class="line">    step3(response3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># three_stages(request1)  # 不能直接调用</span></span><br><span class="line">loop.create_task(three_stages(request1))  <span class="comment"># 必须显示调度执行</span></span><br></pre></td></tr></table></figure><p>与前一个示例相比，使用协程容易理解多了：操作的 3 个步骤依次写在同一个函数中。这样，后续处理便于使用前一步的结果；而且提供了上下文，能通过异常来报告错误。</p><p>假设在上一个示例中处理 <code>api_call2(request2, stage2)</code> 调用（stage1 函数最后一行）时抛出了 I/O 异常，这个异常无法在 stage1 函数中捕获，因为 api_call2 是异步调用，在还未执行任何 I/O 操作时就会立即返回。在基于回调的 API 中，这个问题的解决方法是为每个异步调用注册两个回调，一个用于处理操作成功时的结果，另一个用于处理错误。一旦涉及错误处理，回调地狱的危害程度就会迅速增大。</p><p>与此相比，使用协程时三步操作的所有异步调用都在同一个函数中（three_stages），如果异步调用 api_call1、api_call2 和 api_call3 会抛出异常，那么可以把相应的 yield from 表达式放在 try/except 块中处理异常。这么做比陷入回调地狱好多了，但是我不会把这种方式称为协程天堂，毕竟我们还要付出代价。我们不能使用常规的函数，必须使用协程，而且要习惯 yield from ——这是第一个障碍。只要函数中有 yield from，函数就会变成协程，而协程不能直接调用。我们必须使用事件循环显示排定协程的执行时间，或者在其他排定了执行时间的协程中使用 yield from 表达式把它激活。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> concurrency </tag>
            
            <tag> asyncio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习引言</title>
      <link href="/notes/introduction-to-ml-with-python/introduction-to-machine-learning/"/>
      <url>/notes/introduction-to-ml-with-python/introduction-to-machine-learning/</url>
      
        <content type="html"><![CDATA[<p>机器学习（machine learning）是从数据中提取知识。它是统计学、人工智能和计算机科学交叉的研究领域，也被称为预测分析（predictive analytics）或统计学习（statistical learning）。</p><h1 id="为何选择机器学习">为何选择机器学习</h1><p>在“智能”应用的早期，许多系统使用人为制订的“if”和“else”决策规则来处理数据，或根据用户输入的内容进行调整。想象有一个垃圾邮件过滤器，其任务是酌情将收到的某些邮件移动到垃圾邮件文件夹。你可以创建一个关键词黑名单，所有包含这些关键词的邮件都会被标记为垃圾邮件。这是用专家设计的规则体系来设计“智能”应用的一个示例。人为制订的决策规则对某些应用来说是可行的，特别是人们对其模型处理过程非常熟悉的应用。但是，人为制订决策规则主要有两个缺点。</p><ul><li>做决策所需要的逻辑只适用于单一领域和单项任务。任务哪怕稍有变化，都可能需要重写整个系统。</li><li>想要制订规则，需要对人类专家的决策过程有很深刻的理解。</li></ul><p>这种人为制订规则的方法并不适用的一个例子就是图像中的人脸检测。如今，每台智能手机都能够检测到图像中的人脸。但直到2001年，人脸检测问题才得到解决。其主要问题在于，计算机“感知”像素（像素组成了计算机中的图像）的方式与人类感知面部的方式有非常大的不同。正是由于这种表征差异，人类想要制订出一套好的规则来描述数字图像中的人脸构成，基本上是不可能的。</p><p>但有了机器学习算法，仅向程序输入海量人脸图像，就足以让算法确定识别人脸需要哪些特征。</p><a id="more"></a><h1 id="机器学习能够解决的问题">机器学习能够解决的问题</h1><p>从输入/输出对中进行学习的机器学习算法叫作监督学习算法（supervised learning algorithm），因为每个用于算法学习的样例都对应一个预期输出，好像有一个“老师”在监督着算法。虽然创建一个包含输入和输出的数据集往往费时又费力，但监督学习算法很好理解，其性能也易于测量。如果你的应用可以表示成一个监督学习问题，并且你能够创建包含预期输出的数据集，那么机器学习很可能可以解决你的问题。</p><p>监督机器学习任务的示例如下。</p><ul><li>识别信封上手写的邮政编码</li><li>基于医学影像判断肿瘤是否为良性</li><li>检测信用卡交易中的诈骗行</li></ul><p>另一类算法是无监督学习算法（unsupervised learning algorithm）。在无监督学习中，只有输入数据是已知的，没有为算法提供输出数据。虽然这种算法有许多成功的应用，但理解和评估这些算法往往更加困难。</p><p>无监督学习的示例如下。</p><ul><li>确定一系列博客文章的主题</li><li>将客户分成具有相似偏好的群组</li><li>检测网站的异常访问模式</li></ul><p>无论是监督学习任务还是无监督学习任务，将输入数据表征为计算机可以理解的形式都是十分重要的。通常来说，将数据想象成表格是很有用的。你想要处理的每一个数据点（每一封电子邮件、每一名客户、每一次交易）对应表格中的一行，描述该数据点的每一项属性（比如客户年龄、交易金额或交易地点）对应表格中的一列。</p><p>在机器学习中，这里的每个实体或每一行被称为一个样本（sample）或数据点，而每一列（用来描述这些实体的属性）则被称为特征（feature）。</p><h1 id="第一个应用鸢尾花分类">第一个应用：鸢尾花分类</h1><p>假设有一名植物学爱好者对她发现的鸢尾花的品种很感兴趣。她收集了每朵鸢尾花的一些测量数据：花瓣的长度和宽度以及花萼的长度和宽度，所有测量结果的单位都是厘米。</p><p>她还有一些鸢尾花的测量数据，这些花之前已经被植物学专家鉴定为属于setosa、versicolor或virginica三个品种之一。对于这些测量数据，她可以确定每朵鸢尾花所属的品种。我们假设这位植物学爱好者在野外只会遇到这三种鸢尾花。</p><p>我们的目标是构建一个机器学习模型，可以从这些已知品种的鸢尾花测量数据中进行学习，从而能够预测新鸢尾花的品种。</p><p>因为我们有已知品种的鸢尾花的测量数据，所以这是一个监督学习问题。在这个问题中，我们要在多个选项中预测其中一个（鸢尾花的品种）。这是一个分类（classification）问题的示例。可能的输出（鸢尾花的不同品种）叫作类别（class）。数据集中的每朵鸢尾花都属于三个类别之一，所以这是一个三分类问题。</p><p>单个数据点（一朵鸢尾花）的预期输出是这朵花的品种。对于一个数据点来说，它的品种叫作标签（label）。</p><h2 id="初识数据">初识数据</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iris_dataset = load_iris()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iris_dataset.keys()</span><br><span class="line">dict_keys([<span class="string">'data'</span>, <span class="string">'target'</span>, <span class="string">'target_names'</span>, <span class="string">'DESCR'</span>, <span class="string">'feature_names'</span>, <span class="string">'filename'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iris_dataset.target_names  <span class="comment"># 两种访问访问，属性或键</span></span><br><span class="line">array([<span class="string">'setosa'</span>, <span class="string">'versicolor'</span>, <span class="string">'virginica'</span>], dtype=<span class="string">'&lt;U10'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iris_dataset[<span class="string">'feature_names'</span>]</span><br><span class="line">[<span class="string">'sepal length (cm)'</span>, <span class="string">'sepal width (cm)'</span>, <span class="string">'petal length (cm)'</span>, <span class="string">'petal width (cm)'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iris_dataset.data.shape</span><br><span class="line">(<span class="number">150</span>, <span class="number">4</span>)  <span class="comment"># 鸢尾花有150行数据，每行数据有4个特征</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iris_dataset.target.shape</span><br><span class="line">(<span class="number">150</span>,)  <span class="comment"># 150行数据所属的类</span></span><br></pre></td></tr></table></figure><h2 id="衡量模型是否成功训练数据与测试数据">衡量模型是否成功：训练数据与测试数据</h2><p>我们不能将用于构建模型的数据（训练数据）用于评估模型。因为模型会一直记住整个训练集，所以对于训练集中的任何数据点总会预测正确的标签。这种“记忆”无法告诉我们模型的泛化（generalize）能力如何。</p><p>我们要用新数据来评估模型的性能。通常的做法是将收集好的带标签数据分成两部分。一部分数据用于构建机器学习模型，叫做训练数据（training data）或训练集（training set）。其余的数据用来评估模型性能，叫做测试数据（test data）、测试集（test set）或留出集（hold-out set）。</p><p>scikit-learn中的train_test_split函数可以打乱数据集并进行划分。这个函数默认将75%的行数据及对应标签作为训练集，剩下25%的数据及其标签作为测试集。训练集与测试集的分配比例可以是随意的，但使用25%的数据作为测试集是很好的经验法则。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.model_selection.train_test_split#sklearn.model_selection.train_test_split" target="_blank" rel="noopener"><code>sklearn.model_selection.train_test_split(*arrays, **options)</code></a></p><p>Split arrays or matrices into random train and test subsets.</p></blockquote><p>scikit-learn中的数据通常用大写的X表示，而标签用小写的y表示。这是受到了数学标准公式f(x)=y的启发，其中x是函数的输入，y是输出。我们用大写的X是因为数据是一个二维数组（矩阵），用小写的y是因为目标是一个一维数组（向量），这也是数学中的约定。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line"><span class="meta">... </span>    iris_dataset.data, iris_dataset.target, random_state=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>在对数据进行拆分之前，train_test_split函数利用伪随机数生成器将数据集打乱。如果只是将最后25%的数据作为测试集，那么所有数据点的标签都是2，因为数据点是按标签排序的。测试集中只有三个类别之一，这无法告诉我们模型的泛化能力如何，所以将数据打乱，确保测试集中包含所有类别的数据。</p><p>为了确保多次运行同一函数能够得到相同的输出，利用random_state参数指定了随机数生成器种子。这样函数输出就是固定不变的，所以这行代码的输出始终相同。</p><p>train_test_split函数的输出为X_train、X_test、y_train和y_test，它们都是NumPy数组。X_train包含75%的行数据，X_test包含剩下的 25%:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_train.shape, y_train.shape</span><br><span class="line">((<span class="number">112</span>, <span class="number">4</span>), (<span class="number">112</span>,))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_test.shape, y_test.shape</span><br><span class="line">((<span class="number">38</span>, <span class="number">4</span>), (<span class="number">38</span>,))</span><br></pre></td></tr></table></figure><h2 id="要事第一观察数据">要事第一：观察数据</h2><p>在构建机器学习模型之前，通常最好检查一下数据，看看如果不用机器学习能不能轻松完成任务，或者需要的信息有没有包含在数据中。</p><p>此外，检查数据也是发现异常值和特殊值的好方法。举个例子，可能有些鸢尾花的测量单位是英寸而不是厘米。在现实世界中，经常会遇到不一致的数据和意料之外的测量数据。</p><p>检查数据的最佳方法之一就是将其可视化。一种可视化方法是绘制散点图（scatter plot）。数据散点图将一个特征作为x轴，另一个特征作为y轴，将每一个数据点绘制为图上的一个点。不幸的是，计算机屏幕只有两个维度，所以我们一次只能绘制两个特征（也可能是3个）。用这种方法难以对多于3个特征的数据集作图。解决这个问题的一种方法是绘制散点图矩阵（pair plot），从而可以两两查看所有的特征。如果特征数不多的话，这种方法是合理的。但是你应该记住，散点图矩阵无法同时显示所有特征之间的关系，所以这种可视化方法可能无法展示数据的某些有趣内容。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> mglearn</span><br><span class="line"><span class="comment"># 利用X_train中的数据创建DataFrame</span></span><br><span class="line"><span class="comment"># 利用iris_dataset.feature_names中的字符串对数据列进行标记</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iris_dataframe = pd.DataFrame(X_train, columns=iris_dataset.feature_names)</span><br><span class="line"><span class="comment"># 利用DataFrame创建散点图矩阵，按y_train着色</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grr = pd.scatter_matrix(iris_dataframe, c=y_train, figsize=(<span class="number">15</span>, <span class="number">15</span>), marker=<span class="string">'o'</span>,</span><br><span class="line"><span class="meta">... </span>    hist_kwds=&#123;<span class="string">'bins'</span>: <span class="number">20</span>&#125;, s=<span class="number">60</span>, alpha=<span class="number">.8</span>, cmap=mglearn.cm3)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.show()</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-ml-with-python/iris-dataframe.png"></p><p>从图中可以看出，利用花瓣和花萼的测量数据基本可以将三个类别区分开。这说明机器学习模型很可能可以学会区分它们。</p><h2 id="构建第一个模型k近邻算法">构建第一个模型：k近邻算法</h2><p>构建此模型只需要保存训练集即可。要对一个新的数据点作出预测，算法会在训练集中寻找与这个新数据点距离最近的数据点，然后将找到的数据点的标签赋予这个新数据点。</p><p>k的含义是，我们可以考虑训练集中与新数据点最近的任意k个邻居，而不是只考虑最近的那一个。然后，我们可以用这些邻居中数量最多的类别做出预测。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>knn = KNeighborsClassifier(n_neighbors=<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>knn.fit(X_train, y_train)  <span class="comment"># 基于训练集构建模型，fit方法返回knn对象本身并做原处修改</span></span><br><span class="line">KNeighborsClassifier(algorithm=<span class="string">'auto'</span>, leaf_size=<span class="number">30</span>, metric=<span class="string">'minkowski'</span>,</span><br><span class="line">                     metric_params=<span class="literal">None</span>, n_jobs=<span class="literal">None</span>, n_neighbors=<span class="number">1</span>, p=<span class="number">2</span>,</span><br><span class="line">                     weights=<span class="string">'uniform'</span>)</span><br></pre></td></tr></table></figure><h2 id="做出预测">做出预测</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_new = np.array([[<span class="number">5</span>, <span class="number">2.9</span>, <span class="number">1</span>, <span class="number">.2</span>]])  <span class="comment"># 将测量的数据放入二维数组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_new.shape</span><br><span class="line">(<span class="number">1</span>, <span class="number">4</span>)  <span class="comment"># 我们有1行数据，每行数据有4个特征</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>prediction = knn.predict(X_new)  <span class="comment"># predict的参数必须是二维数组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>prediction</span><br><span class="line">array([<span class="number">0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iris_dataset.target_names[<span class="number">0</span>]</span><br><span class="line"><span class="string">'setosa'</span>  <span class="comment"># 这朵花属于setosa品种</span></span><br></pre></td></tr></table></figure><h2 id="评估模型">评估模型</h2><p>这里需要用到之前创建的测试集。这些数据没有用于构建模型，但我们直到测试集中每朵鸢尾花的实际品种。</p><p>因此，我们可以对测试数据中的每朵鸢尾花进行预测，并将预测结果与标签进行对比。我们可以通过计算精确度（accuracy）来衡量模型的优劣，精度就是品种预测正确的花所占的比例。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>y_pred = knn.predict(X_test)  <span class="comment"># 先预测</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y_pred</span><br><span class="line">array([<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>,</span><br><span class="line">       <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.mean(y_pred == y_test)  <span class="comment"># 再通过np.mean函数计算精度</span></span><br><span class="line"><span class="number">0.9736842105263158</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>knn.score(X_test, y_test)  <span class="comment"># 或者通过score方法计算精度</span></span><br><span class="line"><span class="number">0.9736842105263158</span></span><br></pre></td></tr></table></figure><p>对于这个模型来说，测试集的精度约为0.97，也就是说，对于测试集中的鸢尾花，我们的预测有97%是正确的。这让我们有信心将模型应用于新数据，并相信模型在约97%的情况下都是正确的。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Machine Learning with Python </tag>
            
            <tag> classification </tag>
            
            <tag> kmeans </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用futures处理并发</title>
      <link href="/notes/fluent-python/concurrency-with-futures/"/>
      <url>/notes/fluent-python/concurrency-with-futures/</url>
      
        <content type="html"><![CDATA[<p>本章讨论Python3.2引入的concurrent.futures模块。“期物”（future）是译者自创的词。期物指一种对象，表示异步执行的操作。</p><h1 id="示例网络下载的三种风格">示例：网络下载的三种风格</h1><p>为了高效处理网络I/O，需要使用并发，因为网络有很高的延迟，所以为了不浪费CPU周期去等待，最好在收到网络相应之前做些其他的事。本章有3个示例程序，从网上下载20个国家的国旗图像。第一个示例程序是依序下载的：下载完一个图像，并将其保存在硬盘中之后，才请求下一个图像。另外两个脚本是并发下载（分别使用concurrent.futres模块和asyncio包）的：几乎同时请求所有图像，每下载完一个文件就保存一个文件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python flags.py</span><br><span class="line">BD BR CD CN DE EG ET FR ID IN IR JP MX NG PH PK RU TR US VN</span><br><span class="line">20 flags downloaded in 3.41s</span><br><span class="line">$ python flags_threadpool.py</span><br><span class="line">IN ID CN EG TR NG JP FR DE PK VN RU ET MX PH US IR CD BR BD</span><br><span class="line">20 flags downloaded in 0.20s</span><br><span class="line">$ python flags_asyncio.py</span><br><span class="line">JP CN PK PH EG FR TR BD IN ET RU BR DE ID US NG MX IR CD VN</span><br><span class="line">20 flags downloaded in 0.26s</span><br></pre></td></tr></table></figure><p>两个并发下载的脚本之间性能差异不大，不过都比依序下载的脚本快5倍多（原书是5倍多，我的结果相差更大）。这只是一个特别小的任务，如果把下载的文件数量增加到几百个，并发下载的脚本能比依序下载的脚本快20倍或更多。将这三个脚本一起演示是为了表明一个观点：<strong>在I/O密集型应用中，如果代码写的正确，那么不管使用哪种并发策略（使用线程或asyncio包），吞吐量都比依序执行的代码高得多。</strong></p><a id="more"></a><h2 id="依序下载的脚本">依序下载的脚本</h2><figure class="highlight python"><figcaption><span>flags.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests  <span class="comment"># 导入requests库，这个库不在标准库中</span></span><br><span class="line"></span><br><span class="line">POP20_CC = (<span class="string">'CN IN US ID BR PK NG BD RU JP '</span></span><br><span class="line">            <span class="string">'MX PH VN ET EG DE IR TR CD FR'</span>).split()</span><br><span class="line"></span><br><span class="line">BASE_URL = <span class="string">'http://flupy.org/data/flags'</span></span><br><span class="line"></span><br><span class="line">DEST_DIR = <span class="string">'downloads/'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_flag</span><span class="params">(img, filename)</span>:</span></span><br><span class="line">    path = os.path.join(DEST_DIR, filename)</span><br><span class="line">    <span class="keyword">with</span> open(path, <span class="string">'wb'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(img)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flag</span><span class="params">(cc)</span>:</span></span><br><span class="line">    url = <span class="string">'&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif'</span>.format(BASE_URL, cc=cc.lower())</span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    <span class="keyword">return</span> resp.content</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(text)</span>:</span></span><br><span class="line">    print(text, end=<span class="string">' '</span>)</span><br><span class="line">    sys.stdout.flush()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> cc <span class="keyword">in</span> sorted(cc_list):  <span class="comment"># 按序下载</span></span><br><span class="line">        image = get_flag(cc)</span><br><span class="line">        show(cc)</span><br><span class="line">        save_flag(image, cc.lower() + <span class="string">'.gif'</span>)</span><br><span class="line">    <span class="keyword">return</span> len(cc_list)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(download_many)</span>:</span></span><br><span class="line">    t0 = time.time()</span><br><span class="line">    count = download_many(POP20_CC)</span><br><span class="line">    elapsed = time.time() - t0</span><br><span class="line">    msg = <span class="string">'\n&#123;&#125; flags downloaded in &#123;:.2f&#125;s'</span></span><br><span class="line">    print(msg.format(count, elapsed))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main(download_many)</span><br></pre></td></tr></table></figure><h2 id="使用concurrent.futures模块下载">使用concurrent.futures模块下载</h2><p>concurrent.futures模块的主要特色是ThreadPoolExecutor和ProcessPoolExecutor类，这两个类实现的接口能分别在不同的线程或进程中执行可调用的对象。这两个类在内部维护这一个工作线程或进程池，以及要执行的任务队列。不过，这个接口抽象的层级很高，像下载国旗这种简单的案例，无需关心任何细节。</p><figure class="highlight python"><figcaption><span>flags_threadpool.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flags <span class="keyword">import</span> save_flag, get_flag, show, main  <span class="comment"># 重用函数</span></span><br><span class="line"></span><br><span class="line">MAX_WOKERS = <span class="number">20</span>  <span class="comment"># 设置最大线程数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_one</span><span class="params">(cc)</span>:</span>  <span class="comment"># 下载一个国旗，这是在各个线程中执行的函数</span></span><br><span class="line">    image = get_flag(cc)</span><br><span class="line">    show(cc)</span><br><span class="line">    save_flag(image, cc.lower() + <span class="string">'.gif'</span>)</span><br><span class="line">    <span class="keyword">return</span> cc</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list)</span>:</span></span><br><span class="line">    wokers = min(MAX_WOKERS, len(cc_list))  <span class="comment"># 避免创建多余的线程</span></span><br><span class="line">    <span class="comment"># executor.__exit__方法会调用executor.shutdown(wait=True)方法</span></span><br><span class="line">    <span class="comment"># 它会在所有线程都执行完毕前阻塞线程</span></span><br><span class="line">    <span class="keyword">with</span> futures.ThreadPoolExecutor(wokers) <span class="keyword">as</span> executor:</span><br><span class="line">        res = executor.map(download_one, sorted(cc_list))  <span class="comment"># 返回一个生成器</span></span><br><span class="line">    <span class="keyword">return</span> len(list(res))  <span class="comment"># 获取各个函数返回的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main(download_many)</span><br></pre></td></tr></table></figure><h3 id="期物在哪里">期物在哪里</h3><p>期物是concurrent.futures模块和asyncio包的重要组件，可是，作为这两个库的用户，我们有时却见不到期物。</p><p>从Python3.4起，标准库中有两个名为Future的类：concurrent.futures.Future和asyncio.Future。这两个类的作用相同：两个Future类的实例都表示可能已经完成或者尚未完成的延迟计算。这与Twisted引擎中的Deferred类、Tornado框架中的Future类，以及多个JavaScript库中的Promise对象类似。</p><p>期物封装待完成的操作，可以放入队列，完成的状态可以查询，得到结果（或抛出异常）后可以获取结果（或异常）。</p><p>我们要记住一件事：<strong>通常情况下自己不应该创建期物，而只能由并发框架（concurrent.futures或asyncio）实例化。</strong>原因很简单：期物表示终将发生的事情，而确定某件事会发生的唯一方式是执行的时间已经排定。因此，只有排定把某件事交给concurrent.futures.Executor子类处理时，才会创建concurrent.futures.Future实例。例如，Executor.submit方法的参数是一个可调用的对象，调用这个方法后会为传入的可调用对象排期，并返回一个期物。</p><p>客户端代码不应该改变期物的状态，并发框架在期物表示的延迟计算结束后会改变期物的状态，而我们无法控制计算何时结束。</p><p>这两种期物都有done方法，这个方法不阻塞，返回值是布尔值，指明期物链接的可调用对象是否已经执行。客户端代码通常不会询问期物是否运行结束，而是会等待通知。因此，两个Future类都有add_done_callback方法：这个方法只有一个参数，类型是可调用的对象，期物运行结束后会调用指定的可调用对象。</p><p>此外，还有result方法。在期物运行结束后调用的话，这个方法在两个Future类中的作用相同：返回可调用对象的结果，或者重新抛出执行可调用的对象时抛出的异常。可是，如果期物没有运行结束，result方法在两个Future类中的行为相差很大。对concurrency.futures.Future实例来说，调用f.result()方法会阻塞调用方所在的线程，直到有结果可以返回。此时，result方法可以接收可选的timeout参数，如果在指定的时间内没有运行完毕，会抛出TimeoutError异常。asyncio.Future.result方法不支持设定超过时间，在那个库中获取期物的结果最好使用yield from结构。不过，对concurrency.futures.Future实例不能这么做。</p><p>这两个库中有几个函数会返回期物，其他函数则使用期物，以易于用户理解的方式实现自身。Executor.map方法属于后者：返回值是一个迭代器，迭代器的<code>__next__</code>方法调用各个期物的result方法，因此我们得到的是各个期物的结果，而非期物本身。</p><p>为了从实用的角度理解期物，我们可以实用concurrent.futures.as_completed函数重写示例。这个函数的参数是一个期物列表，返回值是一个迭代器，在期物运行结束后产出期物。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list)</span>:</span></span><br><span class="line">    cc_list = cc_list[:<span class="number">5</span>]  <span class="comment"># 使用5个做演示</span></span><br><span class="line">    <span class="keyword">with</span> futures.ThreadPoolExecutor(max_workers=<span class="number">3</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        to_do = []</span><br><span class="line">        <span class="keyword">for</span> cc <span class="keyword">in</span> sorted(cc_list):</span><br><span class="line">            future = executor.submit(download_one, cc)  <span class="comment"># 排定可调用对象的执行时间，返回一个期物</span></span><br><span class="line">            to_do.append(future)</span><br><span class="line">            msg = <span class="string">'Scheduled for &#123;&#125;: &#123;&#125;'</span></span><br><span class="line">            print(msg.format(cc, future))</span><br><span class="line">        results = []</span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> futures.as_completed(to_do):  <span class="comment"># 在期物运行结束后产出期物</span></span><br><span class="line">            res = future.result()  <span class="comment"># 这次不会阻塞，因为future由as_completed函数产出</span></span><br><span class="line">            msg = <span class="string">'&#123;&#125; result: &#123;!r&#125;'</span></span><br><span class="line">            print(msg.format(future, res))</span><br><span class="line">            results.append(res)</span><br><span class="line">        <span class="keyword">return</span> len(results)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python flags_threadpool.py</span><br><span class="line">Scheduled for BR: &lt;Future at 0x1031a25f8 state=running&gt;</span><br><span class="line">Scheduled for CN: &lt;Future at 0x1031ae0f0 state=running&gt;</span><br><span class="line">Scheduled for ID: &lt;Future at 0x1031ae6a0 state=running&gt;  # 最大3个</span><br><span class="line">Scheduled for IN: &lt;Future at 0x1031bb080 state=pending&gt;</span><br><span class="line">Scheduled for US: &lt;Future at 0x1031bb160 state=pending&gt;</span><br><span class="line">CN &lt;Future at 0x1031ae0f0 state=finished returned str&gt; result: &apos;CN&apos;</span><br><span class="line">ID BR &lt;Future at 0x1031ae6a0 state=finished returned str&gt; result: &apos;ID&apos;</span><br><span class="line">&lt;Future at 0x1031a25f8 state=finished returned str&gt; result: &apos;BR&apos;</span><br><span class="line">IN &lt;Future at 0x1031bb080 state=finished returned str&gt; result: &apos;IN&apos;</span><br><span class="line">US &lt;Future at 0x1031bb160 state=finished returned str&gt; result: &apos;US&apos;</span><br><span class="line"></span><br><span class="line">5 flags downloaded in 0.32s</span><br></pre></td></tr></table></figure><p>多次运行脚本看到的结果有所不同。如果把max_workers参数的值增大到5，结果的顺序变化更多。把max_workers参数的值设为1，代码依序运行，结果的顺序始终与调用submit方法的顺序一致。</p><h2 id="使用asyncio模块下载">使用asyncio模块下载</h2><figure class="highlight python"><figcaption><span>flags_asyncio.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这段脚本与原文的脚本代码不同，使用了Python3.5引入的async和await关键字</span></span><br><span class="line"><span class="comment"># 原脚本中的一些写法可能不再是推荐写法了，愿脚本的代码也不进行分析了</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> aiohttp  <span class="comment"># 它不在标准库中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flags <span class="keyword">import</span> BASE_URL, save_flag, show, main</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_flag</span><span class="params">(client, cc)</span>:</span></span><br><span class="line">    url = <span class="string">'&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif'</span>.format(BASE_URL, cc=cc.lower())</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> client.get(url) <span class="keyword">as</span> resp:</span><br><span class="line">        <span class="keyword">assert</span> resp.status == <span class="number">200</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> resp.read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">download_one</span><span class="params">(cc)</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> client:</span><br><span class="line">        image = <span class="keyword">await</span> get_flag(client, cc)</span><br><span class="line">        show(cc)</span><br><span class="line">        save_flag(image, cc.lower() + <span class="string">'.gif'</span>)</span><br><span class="line">        <span class="keyword">return</span> cc</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list)</span>:</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    to_do = [download_one(cc) <span class="keyword">for</span> cc <span class="keyword">in</span> sorted(cc_list)]</span><br><span class="line">    <span class="comment"># 虽然函数名是wait，但它不是阻塞性函数。wait是一个协程，等传给它所有协程运行完毕后结束</span></span><br><span class="line">    wait_coro = asyncio.wait(to_do)</span><br><span class="line">    <span class="comment"># 执行事件循环，直到wait_coro运行结束；事件循环运行的过程中，这个脚本会在这里阻塞</span></span><br><span class="line">    res, _ = loop.run_until_complete(wait_coro)</span><br><span class="line">    loop.close()  <span class="comment"># 关闭事件循环</span></span><br><span class="line">    <span class="keyword">return</span> len(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main(download_many)</span><br></pre></td></tr></table></figure><p>严格来说，我们目前测试的并发脚本都不能并行下载。使用concurrent.futures库实现的那两个示例受GIL（Global Interpreter Lock，全局解释器锁）的限制，而使用asyncio库实现的脚本在单个线程中运行。</p><ul><li>既然Python线程受GIL的限制，任何时候都只允许运行一个线程，那么flags_threadpool.py脚本的下载速度怎么会比flags.py脚本快5倍？这是因为GIL几乎对<strong>I/O密集型</strong>处理无害。原因见下一节阻塞型I/O和GIL。</li><li>flags_asyncio.py脚本和flags.py脚本都在单个线程中运行，前者怎么会比后者快5倍？原因见下下一节避免阻塞型调用。</li></ul><h1 id="阻塞型io和gil">阻塞型I/O和GIL</h1><p>CPython解释器本身就不是线程安全的，因此有全局解释器锁（GIL），一次只允许使用一个线程执行Python字节码（这是CPython解释器的局限，与Python语言本身无关）。因此，一个Python进程通常不能同时使用多个CPU核心。</p><p>编写Python代码时无法控制GIL；不过，执行耗时的任务时，可以使用一个内置的函数或一个使用C语言编写的扩展释放GIL。其实，有个使用C语言编写的Python库能管理GIL，自行启动操作系统线程，利用全部可用的CPU核心。这样做会极大地增加库代码的复杂度，因此大多数库的作者都不这么做。</p><p>然而，<strong>标准库中的所有执行阻塞型I/O操作的函数，在等待操作系统返回结果时都会释放GIL。这意味着在Python语言这个层次上可以使用多线程，而I/O密集型Python程序能从中受益：一个Python线程等待网络响应时，阻塞型I/O函数会释放GIL，再运行一个线程。</strong></p><p>下面简单说明如何在<strong>CPU密集型</strong>作业中使用concurrent.futures模块轻松绕开GIL。</p><h1 id="避免阻塞型调用">避免阻塞型调用</h1><p>用asyncio包时，我们编写的异步代码中包含由asyncio本身驱动的协程（即委派生成器），而生成器最终把职责委托给asyncio包或第三方库（如aiohttp）中的协程。这种处理方式相当于架起了管道，让asyncio事件循环（通过我们编写的协程）驱动执行低层异步I/O操作的库函数。</p><p>有两种方法能避免阻塞型调用中止整个应用程序的进程：</p><ul><li>在单独的线程中运行各个阻塞型操作</li><li>把每个阻塞型操作转换成非阻塞的异步调用使用</li></ul><p>多个线程是可以的，但是各个操作系统线程（Python使用的是这种线程）消耗的内存达兆字节（具体的量取决于操作系统种类）。如果要处理几千个连接，而每个连接都使用一个线程的话，我们负担不起。</p><p>为了降低内存的消耗，通常使用回调来实现异步调用。使用回调时，我们不等待响应，而是注册一个函数，在发生某件事时调用。这样，所有调用都是非阻塞的。因为回调简单，而且消耗低，所以Ryan Dahl（Node.js的发明者）用户这种方式。</p><p>当然，只有异步应用程序底层的事件循环能依靠各种基础设置的中断、线程、轮询和后台进程等，确保多个并发请求能取得进展并最终完成，这样才能使用回调。事件循环获得响应后，会回过头来调用我们指定的回调。不过，如果做法正确，事件循环和应用代码共用的主线程绝不会阻塞。</p><p>把生成器当作协程使用是异步编程的另一种方式。对事件循环来说，调用回调与在暂停的协程上调用send方法效果差不多。各个暂停的协程是要消耗内存，但是比线程消耗的内存数量级小。而且，协程能避免可怕的“回调地狱”。</p><p>flags.py脚本依序下载，而每次下载都要用几十亿个CPU周期等待即过。其实，CPU同时做了很多事，只是没有运行你的程序。与此相比，在flags_asyncio.py脚本中，在download_many函数中调用loop.run_until_complete方法时，事件循环驱动各个download_one协程，各个download_one协程中又驱动各个get_flag协程，运行到client.get(url)。这些调用都不会阻塞，因此在零点几秒内所有请求全部开始。</p><p>asyncio的基础设施获得第一个响应后，事件循环把响应发给等待结果的get_flag协程。得到响应后，get_flag向前执行，调用resp.read方法，然后把控制权还给主循环。（我不确定这段描述是否符合<code>return await resp.read()</code>的运行过程；作为参考，原脚本的代码是<code>return yield from resp.read()</code>）</p><p>因为异步操作是交叉执行的，所以并发下载多张图像所需的总时间比依序下载少得多。</p><h1 id="使用concurrent.futures模块启动进程">使用concurrent.futures模块启动进程</h1><p>concurrent.futures模块的文档副标题是“Launching parallel tasks”（执行并行任务）。这个模块实现的是真正的并行计算，因为它使用ProcessPoolExecutor类把工作分配给多个Python进程处理。因此，如果需要做CPU密集型处理，使用这个模块能绕开GIL，利用所有可用CPU核心。</p><p><a href="https://devdocs.io/python~3.6/library/concurrent.futures#concurrent.futures.ProcessPoolExecutor" target="_blank" rel="noopener">ProcessPoolExecutor</a>和<a href="https://devdocs.io/python~3.6/library/concurrent.futures#concurrent.futures.ThreadPoolExecutor" target="_blank" rel="noopener">ThreadPoolExecutor</a>类都实现了通用的Executor接口，因此使用concurrent.futures模块能特别轻松地把基于线程的方案转成基于进程的方案。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list)</span>:</span></span><br><span class="line">    workers = min(MAX_WORKERS, len(cc_list))</span><br><span class="line">    <span class="keyword">with</span> futures.ThreadPoolExecutor(workers) <span class="keyword">as</span> executor:  <span class="comment"># 基于线程</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> futures.ProcessPoolExecutor() <span class="keyword">as</span> executor:  <span class="comment"># 基于进程</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p><code>ThreadPoolExecutor.__init__</code>方法需要<code>max_workers</code>参数，指定线程池中线程的数量。在ProcessPoolExecutor类中，那个参数是可选的，而且大多数情况下不实用——默认值是<code>os.cpu_count()</code>函数返回的CPU数量。这样处理说得通，因为对于CPU密集型的处理来说，不可能要求使用超过CPU数量的workers。而对I/O密集型处理来说，可以在一个ThreadPoolExecutor实例中使用10个、100个或1000个线程；最佳线程数取决于做的是什么事，以及可用内存有多少，因此要仔细测试才能找到最佳的线程数。</p><h1 id="实验executor.map方法">实验Executor.map方法</h1><p>若想并发运行多个可调用的对象，最简单的方式是使用示例中见过的Executor.map方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep, strftime</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(*args)</span>:</span>  <span class="comment"># 打印传入的参数并在前加一个时间戳</span></span><br><span class="line">    print(strftime(<span class="string">'[%H:%M:%S]'</span>), end=<span class="string">' '</span>)</span><br><span class="line">    print(*args)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loiter</span><span class="params">(n)</span>:</span></span><br><span class="line">    msg = <span class="string">'&#123;&#125;loiter(&#123;&#125;): doing nothing for &#123;&#125;s...'</span></span><br><span class="line">    display(msg.format(<span class="string">'\t'</span>*n, n, n))</span><br><span class="line">    sleep(n)</span><br><span class="line">    msg = <span class="string">'&#123;&#125;loiter(&#123;&#125;): done.'</span></span><br><span class="line">    display(msg.format(<span class="string">'\t'</span>*n, n))</span><br><span class="line">    <span class="keyword">return</span> n * <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    display(<span class="string">'Script starting.'</span>)</span><br><span class="line">    executor = futures.ThreadPoolExecutor(max_workers=<span class="number">3</span>)</span><br><span class="line">    results = executor.map(loiter, range(<span class="number">5</span>))</span><br><span class="line">    display(<span class="string">'results:'</span>, results)  <span class="comment"># 返回的是生成器，目前不会阻塞</span></span><br><span class="line">    display(<span class="string">'Waiting for individual results:'</span>)</span><br><span class="line">    <span class="keyword">for</span> i, result <span class="keyword">in</span> enumerate(results):</span><br><span class="line">        display(<span class="string">'result &#123;&#125;: &#123;&#125;'</span>.format(i, result))</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python demo_executor_map.py</span><br><span class="line">[21:31:07] Script starting.</span><br><span class="line">[21:31:07] loiter(0): doing nothing for 0s...</span><br><span class="line">[21:31:07] loiter(0): done.</span><br><span class="line">[21:31:07]     loiter(1): doing nothing for 1s...</span><br><span class="line">[21:31:07]         loiter(2): doing nothing for 2s...</span><br><span class="line">[21:31:07] results: &lt;generator object Executor.map.&lt;locals&gt;.result_iterator at 0x10cd970f8&gt;</span><br><span class="line">[21:31:07] Waiting for individual results:</span><br><span class="line">[21:31:07] result 0: 0  # loiter(0)运行结束了，第一个worker就可以启动第四个线程，运行loiter(3)</span><br><span class="line">[21:31:07]             loiter(3): doing nothing for 3s...</span><br><span class="line">[21:31:08]     loiter(1): done.</span><br><span class="line">[21:31:08]                 loiter(4): doing nothing for 4s...</span><br><span class="line">[21:31:08] result 1: 10</span><br><span class="line">[21:31:09]         loiter(2): done.</span><br><span class="line">[21:31:09] result 2: 20</span><br><span class="line">[21:31:10]             loiter(3): done.</span><br><span class="line">[21:31:10] result 3: 30</span><br><span class="line">[21:31:12]                 loiter(4): done.</span><br><span class="line">[21:31:12] result 4: 40</span><br></pre></td></tr></table></figure><p>第一个线程执行loiter(0)，因此会休眠0秒，甚至会在第二个线程开始之前就结束，不过具体情况因人而异：对线程来说，你永远不知道某一时刻事件的具体排序；有可能在另一台设备中会看到loiter(1)在loiter(0)结束之前开始，这是因为sleep函数总会释放GIL。因此，即便休眠0秒，Python也可能会切换到另一个线程。</p><p><strong>Executor.map函数易于使用，不过有个特性可能有用，也可能没用，具体情况取决于需求：这个函数返回结果的顺序与调用开始的顺序一致。如果第一个调用生成结果用时10秒，而其他调用只用1秒，代码会阻塞10秒，获取map方法返回的生成器产出的第一个结果。在此之后，获取后续结果时不会阻塞，因为后续的调用已经结束。如果必须等到获取所有结果后再处理，这种行为没问题；不过，通常更可取的方式是，不管提交的顺序，只要有结果就获取。为此，要把Executor.submit方法和futures.as_completed函数结合起来使用（之前的示例中演示过如何组合使用）。</strong></p><p>executor.submit和futures.as_completed这个组合比executor.map更灵活，因为submit方法能处理不同的可调用对象和参数，而executor.map只能处理参数不同的同一个可调用对象。此外，传给futures.as_completed函数的期物集合可以来自Executor实例，例如一些由ThreadPoolExecutor实例创建，另一些由ProcessPoolExecutor实例创建。</p><h1 id="显示下载进度并处理错误节选">显示下载进度并处理错误（节选）</h1><h2 id="依序下载">依序下载</h2><p>在download_one函数中处理HTTP 404错误，其他异常则向上冒泡，交给download_many函数处理。</p><figure class="highlight python"><figcaption><span>flags2_sequential.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flag</span><span class="params">(base_url, cc)</span>:</span></span><br><span class="line">    url = <span class="string">'&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif'</span>.format(base_url, cc=cc.lower())</span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    <span class="keyword">if</span> resp.status_code != <span class="number">200</span>:</span><br><span class="line">        resp.raise_for_status()  <span class="comment"># 状态码不是200时，抛出异常</span></span><br><span class="line">    <span class="keyword">return</span> resp.content</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_one</span><span class="params">(cc, base_url, verbose=False)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        image = get_flag(base_url, cc)</span><br><span class="line">    <span class="keyword">except</span> requests.exceptions.HTTPError <span class="keyword">as</span> exc:  <span class="comment"># 捕获异常</span></span><br><span class="line">        res = exc.response</span><br><span class="line">        <span class="keyword">if</span> res.status_code == <span class="number">404</span>:  <span class="comment"># 单独处理404异常</span></span><br><span class="line">            status = HTTPStatus.not_found  <span class="comment"># HTTPStatus是自定义的Enum对象</span></span><br><span class="line">            msg = <span class="string">'not found'</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 抛出其他异常</span></span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 没有异常时</span></span><br><span class="line">        save_flag(image, cc.lower() + <span class="string">'.gif'</span>)</span><br><span class="line">        status = HTTPStatus.ok</span><br><span class="line">        msg = <span class="string">'OK'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> verbose:  <span class="comment"># 是否显示消息</span></span><br><span class="line">        print(cc, msg)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result(status, cc)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list, base_url, verbose, max_req)</span>:</span></span><br><span class="line">    counter = collections.Counter()  <span class="comment"># 计数</span></span><br><span class="line">    cc_iter = sorted(cc_list)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> verbose:  <span class="comment"># 是否显示进度条</span></span><br><span class="line">        <span class="comment"># 把cc_iter传给tqdm函数，返回一个迭代器，产出cc_iter中的元素，还会显示进度条动画</span></span><br><span class="line">        cc_iter = tqdm.tqdm(cc_iter)</span><br><span class="line">    <span class="keyword">for</span> cc <span class="keyword">in</span> cc_iter:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            res = download_one(cc, base_url, verbose)</span><br><span class="line">        <span class="keyword">except</span> requests.exceptions.HTTPError <span class="keyword">as</span> exc:  <span class="comment"># 与HTTP有关且download_one中没处理的异常</span></span><br><span class="line">            error_msg = <span class="string">'HTTP error &#123;res.status_code&#125; - &#123;res.reasion&#125;'</span></span><br><span class="line">            error_msg = errormsg.format(res=exc.response)</span><br><span class="line">        <span class="keyword">except</span> requests.exceptions.ConnectionError <span class="keyword">as</span> exc:  <span class="comment"># 与网络有关的异常</span></span><br><span class="line">            error_msg = <span class="string">'Connection error'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            error_msg = <span class="string">''</span></span><br><span class="line">            status = res.status</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> error_msg:</span><br><span class="line">            status = HTTPStatus.error</span><br><span class="line">        counter[status] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> verbose <span class="keyword">and</span> error_msg:</span><br><span class="line">            print(<span class="string">'*** Error for &#123;&#125;: &#123;&#125;'</span>.format(cc, error_msg))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> counter</span><br></pre></td></tr></table></figure><h2 id="使用futures.as_completed函数">使用futures.as_completed函数</h2><p>为了集成TQDM进度条，并处理各次请求中的错误，flags2_threadpool.py脚本用到futures.ThreadPoolExecutor类和futures.as_completed函数。</p><figure class="highlight python"><figcaption><span>flags2_threadpool.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list, base_url, verbose, concur_req)</span>:</span></span><br><span class="line">    counter = collections.Counter()</span><br><span class="line">    <span class="keyword">with</span> futures.ThreadPoolExecutor(max_workers=concur_req) <span class="keyword">as</span> executor:</span><br><span class="line">        to_do_map = &#123;&#125;  <span class="comment"># 把各个Future实例（表示一次下载）映射到相应的国家代码</span></span><br><span class="line">        <span class="keyword">for</span> cc <span class="keyword">in</span> sorted(cc_list):</span><br><span class="line">            future = executor.submit(download_one, cc, base_url, verbose)  <span class="comment"># 排定执行时间</span></span><br><span class="line">            to_do_map[future] = cc</span><br><span class="line">        done_iter = futures.as_completed(to_do_map)  <span class="comment"># 返回一个迭代器，在期物运行结束后产出期物</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> verbose:</span><br><span class="line">            <span class="comment"># done_iter没有__len__方法，必须通过total参数告诉tqdm函数预期的元素数量</span></span><br><span class="line">            done_iter = tqdm.tqdm(done_iter, total=len(cc_list))</span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> done_iter:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                res = future.result()  <span class="comment"># 不会阻塞，因为as_completed函数只返回已经运行结束的期物</span></span><br><span class="line">            <span class="keyword">except</span> requests.exceptions.HTTPError <span class="keyword">as</span> exc:</span><br><span class="line">                error_msg = <span class="string">'HTTP &#123;res.status_code&#125; - &#123;res.reason&#125;'</span></span><br><span class="line">                error_msg = error_msg.format(res=exc.response)</span><br><span class="line">            <span class="keyword">except</span> requests.exceptions.ConnectionError <span class="keyword">as</span> exc:</span><br><span class="line">                error_msg = <span class="string">'Connection error'</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                error_msg = <span class="string">''</span></span><br><span class="line">                status = res.status</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> error_msg:</span><br><span class="line">                status = HTTPStatus.error</span><br><span class="line">            counter[status] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> verbose <span class="keyword">and</span> error_msg:</span><br><span class="line">                cc = to_do_map[future]</span><br><span class="line">                print(<span class="string">'*** Error for &#123;&#125;: &#123;&#125;'</span>.format(cc, error_msg))</span><br><span class="line">    <span class="keyword">return</span> counter</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> concurrency </tag>
            
            <tag> futures </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用协程做离散事件仿真</title>
      <link href="/notes/fluent-python/coroutines-for-discrete-event-simulation/"/>
      <url>/notes/fluent-python/coroutines-for-discrete-event-simulation/</url>
      
        <content type="html"><![CDATA[<p>在计算机科学领域，仿真是协程的经典应用。</p><p>协程是asyncio包的基础构建。通过仿真系统能说明如何使用协程代替线程实现并发的活动。</p><h1 id="离散事件仿真简介">离散事件仿真简介</h1><p>离散事件仿真（Discrete Event Simulation，DES）是一种把系统建模成一系列事件的仿真类型。在离散事件仿真中，仿真“钟”向前推进的量不是固定的，而是直接推进到下一个事件模型的模拟时间。加入我们抽象模拟出租车的运营过程，其中一个事件是乘客上车，下一个事件则是乘客下车。不管乘客坐了5分钟还是50分钟，一旦乘客下车，仿真钟就会更新，指向此次运营的结束时间。使用离散事件仿真可以在不到一秒钟的事件模拟一年的出租车运营过程。这与连续仿真不同，连续仿真的仿真钟以固定的量（通常很小）不断向前推进。</p><p>显然，回合制游戏就是离散事件仿真的例子：游戏的状态只在玩家操作时变化，而且一旦玩家决定下一步怎么走了，仿真钟就会冻结。而实时游戏则是连续仿真，仿真钟一直在运行，游戏的状态在一秒钟之内更新很多次，因此反应慢的玩家特别吃亏。</p><p>这两种仿真类型都能使用多线程或在单个线程中使用面向事件的编程技术实现。可以说，为了实现连续仿真，在多个线程中处理实时并行的操作更自然。而协程恰好为实现离散事件仿真提供了合理的抽象。SimPy是一个实现离散时间仿真的Python包，通过一个协程表示离散事件仿真系统中的各个进程。</p><p>本节说明如何只使用标准库提供的功能实现一个特别简单的离散事件仿真系统。</p><a id="more"></a><h1 id="出租车队运营仿真">出租车队运营仿真</h1><figure class="highlight python"><figcaption><span>taxi_sim.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">DEFAULT_NUMBER_OF_TAXIS = <span class="number">3</span>  <span class="comment"># 默认出租车数量</span></span><br><span class="line">DEFAULT_END_TIME = <span class="number">180</span>       <span class="comment"># 默认仿真钟结束时间</span></span><br><span class="line">SEARCH_DURATION = <span class="number">5</span>          <span class="comment"># 默认（空车）徘徊时间</span></span><br><span class="line">TRIP_DURATION = <span class="number">20</span>           <span class="comment"># 默认载客行驶时间</span></span><br><span class="line">DEPARTURE_INTERVAL = <span class="number">5</span>       <span class="comment"># 默认出库间隔时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 属性分别为 发生时间, 协程的key, 事件的名称</span></span><br><span class="line">Event = collections.namedtuple(<span class="string">'Event'</span>, <span class="string">'time proc action'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">taxi_process</span><span class="params">(ident, trips, start_time=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">"""每次状态变化时向仿真程序产出一个事件"""</span></span><br><span class="line">    time = <span class="keyword">yield</span> Event(start_time, ident, <span class="string">'leave garage'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(trips):</span><br><span class="line">        time = <span class="keyword">yield</span> Event(time, ident, <span class="string">'pick up passenger'</span>)</span><br><span class="line">        time = <span class="keyword">yield</span> Event(time, ident, <span class="string">'drop off passenger'</span>)</span><br><span class="line">    <span class="keyword">yield</span> Event(time, ident, <span class="string">'going home'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simulator</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, procs_map)</span>:</span>  <span class="comment"># 初始化时传入所有出租车的协程</span></span><br><span class="line">        self.events = queue.PriorityQueue()</span><br><span class="line">        self.procs = dict(procs_map)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, end_time)</span>:</span></span><br><span class="line">        <span class="string">"""调度并显示事件，直到时间结束"""</span></span><br><span class="line">        <span class="comment"># 调度各辆出租车的第一个事件</span></span><br><span class="line">        <span class="keyword">for</span> _, proc <span class="keyword">in</span> sorted(self.procs.items()):</span><br><span class="line">            first_event = next(proc)  <span class="comment"># 预激</span></span><br><span class="line">            self.events.put(first_event)  <span class="comment"># 将第一个事件放入events</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 此次仿真的主循环</span></span><br><span class="line">        sim_time = <span class="number">0</span>  <span class="comment"># 仿真钟</span></span><br><span class="line">        <span class="keyword">while</span> sim_time &lt; end_time:</span><br><span class="line">            <span class="keyword">if</span> self.events.empty():  <span class="comment"># 所有事件都已完成，即各出租车完成出库，完成指定数目的行程，入库</span></span><br><span class="line">                print(<span class="string">'*** end of events ***'</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            current_event = self.events.get()  <span class="comment"># 获得最早发生的事件</span></span><br><span class="line">            sim_time, proc_id, previous_action = current_event  <span class="comment"># 拆包</span></span><br><span class="line">            print(<span class="string">'taxi:'</span>, proc_id, proc_id * <span class="string">'    '</span>, current_event)  <span class="comment"># 打印事件内容</span></span><br><span class="line">            active_proc = self.procs[proc_id]  <span class="comment"># 根据事件的协程的key得到产出该事件的协程（出租车）</span></span><br><span class="line">            next_time = sim_time + compute_duration(previous_action)  <span class="comment"># 计算下一个事件的事件</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                next_event = active_proc.send(next_time)  <span class="comment"># 发送到协程，并得到协程可能产出的事件</span></span><br><span class="line">            <span class="keyword">except</span> StopIteration:  <span class="comment"># 如果协程结束</span></span><br><span class="line">                <span class="keyword">del</span> self.procs[proc_id]  <span class="comment"># 删除该协程</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.events.put(next_event)  <span class="comment"># 否则将产出的事件加入到优先队列中</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 如果因为超时而停止，则输出还有多少事件</span></span><br><span class="line">            msg = <span class="string">'*** end of simulation time: &#123;&#125; events pending ***'</span></span><br><span class="line">            print(msg.format(self.events.qsize()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_duration</span><span class="params">(previous_action)</span>:</span></span><br><span class="line">    <span class="string">"""使用指数分布计算操作的耗时"""</span></span><br><span class="line">    <span class="keyword">if</span> previous_action <span class="keyword">in</span> [<span class="string">'leave garage'</span>, <span class="string">'drop off passenger'</span>]:</span><br><span class="line">        <span class="comment"># 新状态是四处徘徊</span></span><br><span class="line">        interval = SEARCH_DURATION</span><br><span class="line">    <span class="keyword">elif</span> previous_action == <span class="string">'pick up passenger'</span>:</span><br><span class="line">        <span class="comment"># 新状态是行程开始</span></span><br><span class="line">        interval = TRIP_DURATION</span><br><span class="line">    <span class="keyword">elif</span> previous_action == <span class="string">'going home'</span>:</span><br><span class="line">        interval = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'Unknown previous_action: %s'</span> % previous_action)</span><br><span class="line">    <span class="keyword">return</span> int(random.expovariate(<span class="number">1</span>/interval)) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(end_time=DEFAULT_END_TIME, num_taxis=DEFAULT_NUMBER_OF_TAXIS, seed=None)</span>:</span></span><br><span class="line">    <span class="string">"""初始化随机生成器，构建过程，运行仿真程序"""</span></span><br><span class="line">    <span class="keyword">if</span> seed <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        random.seed(seed)  <span class="comment"># 获得可复现的结果</span></span><br><span class="line">    taxis = &#123;i: taxi_process(i, (i+<span class="number">1</span>)*<span class="number">2</span>, i*DEPARTURE_INTERVAL)</span><br><span class="line">             <span class="keyword">for</span> i <span class="keyword">in</span> range(num_taxis)&#125;  <span class="comment"># 协程的字典，每辆出租车对应一个协程</span></span><br><span class="line">    sim = Simulator(taxis)  <span class="comment"># 初始化</span></span><br><span class="line">    sim.run(end_time)  <span class="comment"># 运行仿真</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">'Taxi fleet simulator.'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-e'</span>, <span class="string">'--end-time'</span>, type=int, default=DEFAULT_END_TIME,</span><br><span class="line">                        help=<span class="string">'simulation end time; default = %s'</span></span><br><span class="line">                        % DEFAULT_END_TIME)</span><br><span class="line">    parser.add_argument(<span class="string">'-t'</span>, <span class="string">'--taxis'</span>, type=int, default=DEFAULT_NUMBER_OF_TAXIS,</span><br><span class="line">                        help=<span class="string">'number of taxis running; default = %s'</span></span><br><span class="line">                        % DEFAULT_NUMBER_OF_TAXIS)</span><br><span class="line">    parser.add_argument(<span class="string">'-s'</span>, <span class="string">'--seed'</span>, type=int, default=<span class="literal">None</span>,</span><br><span class="line">                        help=<span class="string">'random generator seed (for testing)'</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    main(args.end_time, args.taxis, args.seed)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/fluent-python/sample-run-with-three-taxis.png"></p><p>运行taxi_sim.py创建3辆车的输出示例。-s 3参数设置随机数生成器的种子，这样在调试和演示时可以重复运行程序，输出相同的结果。不同颜色的箭头是后来加上的，表示不同出租车的行程。有了箭头，能直观地看出如何使用协程管理并发的活动。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python taxi_sim.py -s 3 -e 60</span><br><span class="line">taxi: 0  Event(time=0, proc=0, action=&apos;leave garage&apos;)</span><br><span class="line">taxi: 0  Event(time=2, proc=0, action=&apos;pick up passenger&apos;)</span><br><span class="line">taxi: 1      Event(time=5, proc=1, action=&apos;leave garage&apos;)</span><br><span class="line">taxi: 1      Event(time=8, proc=1, action=&apos;pick up passenger&apos;)</span><br><span class="line">taxi: 2          Event(time=10, proc=2, action=&apos;leave garage&apos;)</span><br><span class="line">taxi: 2          Event(time=15, proc=2, action=&apos;pick up passenger&apos;)</span><br><span class="line">taxi: 2          Event(time=17, proc=2, action=&apos;drop off passenger&apos;)</span><br><span class="line">taxi: 0  Event(time=18, proc=0, action=&apos;drop off passenger&apos;)</span><br><span class="line">taxi: 2          Event(time=18, proc=2, action=&apos;pick up passenger&apos;)</span><br><span class="line">taxi: 2          Event(time=25, proc=2, action=&apos;drop off passenger&apos;)</span><br><span class="line">taxi: 1      Event(time=27, proc=1, action=&apos;drop off passenger&apos;)</span><br><span class="line">taxi: 2          Event(time=27, proc=2, action=&apos;pick up passenger&apos;)</span><br><span class="line">taxi: 0  Event(time=28, proc=0, action=&apos;pick up passenger&apos;)</span><br><span class="line">taxi: 2          Event(time=40, proc=2, action=&apos;drop off passenger&apos;)</span><br><span class="line">taxi: 2          Event(time=44, proc=2, action=&apos;pick up passenger&apos;)</span><br><span class="line">taxi: 1      Event(time=55, proc=1, action=&apos;pick up passenger&apos;)</span><br><span class="line">taxi: 1      Event(time=59, proc=1, action=&apos;drop off passenger&apos;)</span><br><span class="line">taxi: 0  Event(time=65, proc=0, action=&apos;drop off passenger&apos;)</span><br><span class="line">*** end of simulation time: 3 events pending ***</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> coroutines </tag>
            
            <tag> Fluent Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协程</title>
      <link href="/notes/fluent-python/coroutines/"/>
      <url>/notes/fluent-python/coroutines/</url>
      
        <content type="html"><![CDATA[<p>字典为动词 “to yield” 给出了两个释义：产出和让步。对于 Python 生成器中的 yield 来说，这两个含义都成立。<code>yield item</code> 这行代码会产出一个值，提供给 <code>next(...)</code> 的调用方；此外，还会作出让步，暂停执行生成器，让调用方继续工作，直到需要使用另一个值时再调用 <code>next()</code>。调用方会从生成器中拉取值。</p><h1 id="用作协程的生成器的基本行为">用作协程的生成器的基本行为</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可能是协程最简单的使用演示</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">simple_coroutine</span><span class="params">()</span>:</span>  <span class="comment"># 定义体中有yield关键字</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'-&gt; coroutine started'</span>)</span><br><span class="line"><span class="meta">... </span>    x = <span class="keyword">yield</span>  <span class="comment"># yield在表达式中使用</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'-&gt; coroutine received:'</span>, x)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro = simple_coroutine()  <span class="comment"># 与创建生成器一样，调用函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro  <span class="comment"># 得到生成器对象</span></span><br><span class="line">&lt;generator object simple_coroutine at <span class="number">0x101df2888</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(my_coro)  <span class="comment"># 首先要调用next()函数，因为生成器还没有启动</span></span><br><span class="line">-&gt; coroutine started  # 生成器启动，在yield处暂停</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro.send(<span class="number">42</span>)  <span class="comment"># 发送数据</span></span><br><span class="line">-&gt; coroutine received: 42  # 协程恢复，继续运行，打印出内容</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration  <span class="comment"># 生成器运行到末尾，抛出StopIteration异常</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>协程可以身处四个状态中的一个。当前状态可以使用 <code>inspect.getgeneratorstate(...)</code> 函数确定，该函数会返回下述字符串中的一个。</p><p><code>'GEN_CREATED'</code>：等待开始执行。</p><p><code>'GEN_RUNNING'</code>：解释器正在执行。只有在多线程应用中才能看到这个状态。此外，生成器对象在自己身上调用 getgeneratorstate 函数也行，不过这样做没什么用。</p><p><code>'GEN_SUSPENDED'</code>：在 yield 表达式出暂停。</p><p><code>'GEN_CLOSED'</code>：执行结束。</p><p>因为 send 方法的参数会成为暂停的 yield 表达式的值，所以，仅当协程处于暂停状态时才能调用 send 方法，例如 <code>my_coro.send(42)</code>。不过，如果协程还没激活（即，状态是 <code>'GEN_CREATED'</code>），情况就不同了。因此，始终要调用 <code>next(my_coro)</code> 激活协程；也可以调用 <code>my_coro.send(None)</code>，效果一样。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro = simple_coroutine()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro.send(<span class="number">42</span>)  <span class="comment"># 协程未激活</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: can‘t send non-<span class="literal">None</span> value to a just-started generator  <span class="comment"># 错误消息明确</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(my_coro), my_coro.send(<span class="number">42</span>)  <span class="comment"># 先激活</span></span><br><span class="line">-&gt; coroutine started</span><br><span class="line">-&gt; coroutine received: 42</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">simple_coro2</span><span class="params">(a)</span>:</span>  <span class="comment"># 举个产出多个值的例子</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'-&gt; Started: a ='</span>, a)</span><br><span class="line"><span class="meta">... </span>    b = <span class="keyword">yield</span> a  <span class="comment"># 产出a后暂停执行</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'-&gt; Received: b ='</span>, b)</span><br><span class="line"><span class="meta">... </span>    c = <span class="keyword">yield</span> a + b</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'-&gt; Received: c ='</span>, c)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro2 = simple_coro2(<span class="number">14</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> inspect <span class="keyword">import</span> getgeneratorstate</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getgeneratorstate(my_coro2)</span><br><span class="line"><span class="string">'GEN_CREATED'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(my_coro2)  <span class="comment"># 激活协程</span></span><br><span class="line">-&gt; Started: a = 14  # 输出的内容</span><br><span class="line"><span class="number">14</span>  <span class="comment"># 产出的内容</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getgeneratorstate(my_coro2)  <span class="comment"># 在第一个yield表达式处暂停，等待调用者为b赋值</span></span><br><span class="line"><span class="string">'GEN_SUSPENDED'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro2.send(<span class="number">28</span>)  <span class="comment"># 为b赋值</span></span><br><span class="line">-&gt; Received: b = 28</span><br><span class="line"><span class="number">42</span>  <span class="comment"># 产出a+b，然后在第二个yield表达式处暂停，等待为c赋值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro2.send(<span class="number">99</span>)</span><br><span class="line">-&gt; Received: c = 99</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getgeneratorstate(my_coro2)  <span class="comment"># 协程结束</span></span><br><span class="line"><span class="string">'GEN_CLOSED'</span></span><br></pre></td></tr></table></figure><h1 id="使用协程计算移动平均值">使用协程计算移动平均值</h1><p>在讨论闭包时，我们分别用类和高阶函数实现了该功能。下面展示如何使用协程实现相同的功能。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    total = <span class="number">0.0</span></span><br><span class="line"><span class="meta">... </span>    count = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    average = <span class="literal">None</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># 无限循环，仅当调用方在协程上调用.close()方法，或者协程被垃圾回收程序回收时，这个协程才会终止</span></span><br><span class="line"><span class="meta">... </span>        term = <span class="keyword">yield</span> average  <span class="comment"># 首次会产出None</span></span><br><span class="line"><span class="meta">... </span>        total += term  <span class="comment"># 使用协程的好处是，total和count声明为局部变量即可</span></span><br><span class="line"><span class="meta">... </span>        count += <span class="number">1</span>     <span class="comment"># 无需使用实例属性或闭包在多次调用之间保持上下文</span></span><br><span class="line"><span class="meta">... </span>        average = total/count</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg = averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="literal">None</span>)  <span class="comment"># 使用.send(None)方式激活协程</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">10</span>)</span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">30</span>)</span><br><span class="line"><span class="number">20.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">5</span>)</span><br><span class="line"><span class="number">15.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getgeneratorstate(coro_avg)</span><br><span class="line"><span class="string">'GEN_CLOSED'</span></span><br></pre></td></tr></table></figure><h1 id="预激协程的装饰器">预激协程的装饰器</h1><p>如果不预激，那么协程没什么用。为了简化协程的用法，有时会使用一个预激装饰器。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">coroutine</span><span class="params">(func)</span>:</span>  <span class="comment"># 定义的预激装饰器</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">"""装饰器：向前直行到第一个yield表达式，预激func"""</span></span><br><span class="line"><span class="meta">... </span>    @wraps(func)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">primer</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>        gen = func(*args, **kwargs)  <span class="comment"># 调用被装饰的函数</span></span><br><span class="line"><span class="meta">... </span>        next(gen)  <span class="comment"># 激活生成器</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> gen  <span class="comment"># 返回生成器</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> primer  <span class="comment"># 返回包装好的方法</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>averager = coroutine(averager)  <span class="comment"># 装饰averager函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg = averager()  <span class="comment"># 创建一个生成器对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getgeneratorstate(coro_avg)  <span class="comment"># 已经准备好，可以接受值了</span></span><br><span class="line"><span class="string">'GEN_SUSPENDED'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">10</span>)</span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">30</span>)</span><br><span class="line"><span class="number">20.0</span></span><br></pre></td></tr></table></figure><p>很多框架都提供了处理协程的特殊装饰器，不过不是所有的装饰器都用于预激协程，有些会提供其他服务，例如勾入事件循环。</p><p>使用 yield from 句法调用协程时，会自动预激，因此与示例中的 <code>@coroutine</code> 装饰器不兼容。Python3.4 标准库里的 <code>asyncio.coroutine</code> 装饰器不会预激协程，因此能兼容 yield from 句法。</p><h1 id="终止协程和异常处理">终止协程和异常处理</h1><p>协程中未处理的异常会向上冒泡，传给 next 函数或 send 方法的调用方（即触发协程的对象）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg = averager()  <span class="comment"># 预激的协程</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">40</span>)</span><br><span class="line"><span class="number">40.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">50</span>)</span><br><span class="line"><span class="number">45.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="string">'spam'</span>)  <span class="comment"># 发送的不是数字，协程会因此终止</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">7</span>, <span class="keyword">in</span> averager</span><br><span class="line">TypeError: unsupported operand type(s) <span class="keyword">for</span> +=: <span class="string">'float'</span> <span class="keyword">and</span> <span class="string">'str'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">60</span>)  <span class="comment"># 无法重新激活</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><p>上例暗示了终止协程的一种方式：<strong>发送某个哨符值，让协程退出。</strong>内置的 None 和 Ellipsis 等常量经常用作哨符值。Ellipsis 的优点是，数据流中不太常用这个值。我还见过有人把 StopIteration 类（类本身，而不是实例，也不抛出）作为哨符值：<code>my_coro.send(StopIteration)</code>。</p><p>从 Python2.5 开始，客户代码可以在生成器对象上调用两个方法，显式地把异常发给协程。这两个方法是 throw 和 close。</p><p><code>generator.throw(exc_type[, exc_value[, traceback]])</code></p><p>致使生成器在暂停的 yield 表达式处抛出指定的异常。如果生成器处理了抛出的异常，代码会向前执行到下一个 yield 表达式，而产出的值会成为调用 <code>generator.throw</code> 方法得到的返回值。如果生成器没有处理抛出的异常，异常会向上冒泡，传到调用方的上下文中。</p><p><code>generator.close()</code></p><p>致使生成器在暂停的 yield 表达式处抛出 GeneratorExit 异常。如果生成器没有处理这个异常，或者抛出了 StopIteration 异常（通常是指运行到结尾），调用方不会报错。如果收到 GeneratorExit 异常，生成器一定不能产出值，否则解释器会抛出 RuntimeError 异常。生成器抛出的其他异常会向上冒泡，传给调用方。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">DemoException</span><span class="params">(Exception)</span>:</span> <span class="keyword">pass</span>  <span class="comment"># 为演示定义的异常</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">demo_exc_handling</span><span class="params">()</span>:</span>  <span class="comment"># 学习在协程中处理异常</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'-&gt; coroutine started'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>            x = <span class="keyword">yield</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">except</span> DemoException:  <span class="comment"># 特别处理DemoException异常</span></span><br><span class="line"><span class="meta">... </span>            print(<span class="string">'*** DemoException handled. Continuing...'</span>)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">else</span>:  <span class="comment"># 如果没有异常，那么显示接收到的值</span></span><br><span class="line"><span class="meta">... </span>            print(<span class="string">'-&gt; coroutine received: &#123;!r&#125;'</span>.format(x))</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> RuntimeError(<span class="string">'This line should never run.'</span>)  <span class="comment"># 这行代码不会执行，因为只有未处理的异常</span></span><br><span class="line"><span class="meta">... </span>                                        <span class="comment"># 才会中止无限循环，而一旦出现未处理的异常，协程会立即终止</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>exc_coro = demo_exc_handling()  <span class="comment"># 创建</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(exc_coro)  <span class="comment"># 激活</span></span><br><span class="line">-&gt; coroutine started</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>exc_coro.send(<span class="number">11</span>)</span><br><span class="line">-&gt; coroutine received: 11</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>exc_coro.throw(DemoException)</span><br><span class="line">*** DemoException handled. Continuing...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> inspect <span class="keyword">import</span> getgeneratorstate</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getgeneratorstate(exc_coro)  <span class="comment"># DemoException异常不会导致协程中止</span></span><br><span class="line"><span class="string">'GEN_SUSPENDED'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>exc_coro.throw(ZeroDivisionError)  <span class="comment"># 未处理的异常会导致协程中止</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">5</span>, <span class="keyword">in</span> demo_exc_handling</span><br><span class="line">ZeroDivisionError</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getgeneratorstate(exc_coro)</span><br><span class="line"><span class="string">'GEN_CLOSED'</span></span><br></pre></td></tr></table></figure><p>如果不管协程如何结束都想做些清理工作，要把协程定义体中相关代码放入 try/finally 块中。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo_finally</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'-&gt; coroutine started'</span>)</span><br><span class="line">    <span class="keyword">try</span>:  <span class="comment"># 定义体放入try/finally块中</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                x = <span class="keyword">yield</span></span><br><span class="line">            <span class="keyword">except</span> DemoException:</span><br><span class="line">                print(<span class="string">'*** DemoException handled. Continuing...'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">'-&gt; coroutine received: &#123;!r&#125;'</span>.format(x))</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        print(<span class="string">'-&gt; coroutine ending'</span>)</span><br></pre></td></tr></table></figure><h1 id="让协程返回值">让协程返回值</h1><p>为了说明如何返回值，每次激活协程时不会产出移动平均值。这么做是为了强调某些协程不会产出值，而是在最后返回一个值（通常是某种累计值）。</p><figure class="highlight python"><figcaption><span>coroaverager2.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Result = namedtuple(<span class="string">'Result'</span>, <span class="string">'count average'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">()</span>:</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">if</span> term <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 为了返回值，协程必须正常终止，因此加了个判断条件</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br><span class="line">    <span class="keyword">return</span> Result(count, average)  <span class="comment"># 在Python3.3之前，如果生成器返回值，解释器会报句法错误</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> coroaverager2 <span class="keyword">import</span> averager</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg = averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(coro_avg)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">6.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    coro_avg.send(<span class="literal">None</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> StopIteration <span class="keyword">as</span> exc:</span><br><span class="line"><span class="meta">... </span>    result = exc.value  <span class="comment"># 异常对象的value属性保存着返回的值</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result</span><br><span class="line">Result(count=<span class="number">3</span>, average=<span class="number">15.5</span>)</span><br></pre></td></tr></table></figure><p><strong>return 表达式的值会偷偷传给调用方，赋值给 StopIteration 异常的一个属性。</strong>这样做有点不合常理，但是能保留生成器对象的常规行为——耗尽时抛出 StopIteration 异常。</p><p>获取协程的返回值虽然要饶个圈子，但这是 PEP 380 定义的方式，当我们意识到这一点后就说得通了：yield from 结构会在内部自动捕获 StopIteration 异常。这种处理方式与 for 循环处理 StopIteration 异常的方式一样：循环机制使用用于易于理解的方式处理异常。<strong>对 yield from 结构来说，解释器不仅会捕获 StopIteration 异常，还会把 value 属性的值变成 yield from 表达式的值</strong>。</p><h1 id="使用-yield-from">使用 yield from</h1><p>yield from 是全新的语言结构，它的作用比 yield 多很多。在生成器 gen 中使用 <code>yield from subgen()</code> 时，subgen 会获得控制权，把产出的值传给 gen 的调用方，即调用方可以直接控制 subgen。与此同时，gen 会阻塞，等待 subgen 终止。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">'AB'</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">yield</span> c</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">3</span>):</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">yield</span> i</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(gen())</span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span>  <span class="comment"># 可以改写为</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="keyword">from</span> <span class="string">'AB'</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="keyword">from</span> range(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(gen())</span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">chain</span><span class="params">(*iterables)</span>:</span>  <span class="comment"># python版本的chain函数，原函数用C语言编写并且做了优化</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> it <span class="keyword">in</span> iterables:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">yield</span> <span class="keyword">from</span> it</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = tuple(range(<span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(chain(s, t))</span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>yield from x 表达式对 x 对象所做的第一个件事是，调用 <code>iter(x)</code>，从中获取迭代器。因此，x 可以是任何可迭代的对象。</p><p>可是，如果 yield from 结构唯一的作用是替代产出值的嵌套 for 循环，这个结构很有可能不会添加到 Python 语言中。yield from 结构的本质作用无法通过简单的可迭代对象说明，而要发散思维，使用嵌套的生成器。因此，引入 yield from 结构的 PEP 380 才起了 ”Syntax for Delegatinig to a Subgenerator“（”把职责委托给子生成器的句法“）这个标题。</p><p><strong>yield from 的主要功能是打开双向通道，把最外层的调用方与最内层的子生成器连接起来，这样二者可以直接发送和产出值，还可以直接传入异常，而不用在位于中间的协程中添加大量处理异常的样板代码。</strong>有个这个结构，协程可以通过以前不可能的方式委托职责。</p><p>若想使用 yield from 结构，就要大幅改动代码。为了说明需要改动的部分，PEP 380 使用了一些专门的术语。</p><p>委派生成器：包含 <code>yield from &lt;iterable&gt;</code> 表达式的生成器函数。</p><p>子生成器：从 yield from 表达式中 <code>&lt;iterable&gt;</code> 部分获取的生成器。这就是 PEP 380 的标题中所说的子生成器（subgenerator）。</p><p>调用方：调用委派生成器的客户端代码。</p><p><img src="/uploads/image/fluent-python/yield_from_at_work.png"></p><p>委派生成器在 yield from 表达式处暂停时，调用方可以直接把数据发给子生成器，子生成器再把产出的值发给调用方。子生成器返回之后，解释器会抛出 StopIteration 异常，并把返回值附加到异常对象上，此时委派生成器会恢复。</p><figure class="highlight python"><figcaption><span>coroaverager3.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Result = namedtuple(<span class="string">'Result'</span>, <span class="string">'count average'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">()</span>:</span>  <span class="comment"># 代码不变，这里作为子生成器使用</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">if</span> term <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 至关重要的终止条件。如果不这么做，使用yield from</span></span><br><span class="line">            <span class="keyword">break</span>         <span class="comment"># 调用这个协程的生成器会永远阻塞</span></span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br><span class="line">    <span class="keyword">return</span> Result(count, average)  <span class="comment"># 返回的Result会成为调用方中yield from表达式的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 委派生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grouper</span><span class="params">(results, key)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># grouper发送的每个值都会经由yield from处理，通过管道传给averager实例</span></span><br><span class="line">        <span class="comment"># grouper会在yield from表达式处暂停，等待averager实例处理客户端发来的值</span></span><br><span class="line">        <span class="comment"># averager实例运行完毕后，返回的值绑定到results[key]上</span></span><br><span class="line">        results[key] = <span class="keyword">yield</span> <span class="keyword">from</span> averager()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端代码，即调用方。这是驱动一切的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(data)</span>:</span></span><br><span class="line">    results = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key, values <span class="keyword">in</span> data.items():</span><br><span class="line">        group = grouper(results, key)  <span class="comment"># 创建group协程</span></span><br><span class="line">        next(group)  <span class="comment"># 预激</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> values:  <span class="comment"># 把各个value传给grouper。传入的值最终到达averager函数中term = yield那一行</span></span><br><span class="line">            group.send(value)  <span class="comment"># grouper永远不知道传入的值是什么</span></span><br><span class="line">        <span class="comment"># 把None传入grouper，导致当前的averager实例终止，也让grouper继续运行</span></span><br><span class="line">        <span class="comment"># 如果没有这一行，那么averager子生成器永远不会终止，委派生成器group永远不会再次激活</span></span><br><span class="line">        <span class="comment"># 因此永远不会为results[key]赋值</span></span><br><span class="line">        group.send(<span class="literal">None</span>)  </span><br><span class="line">    report(results)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出报告</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">report</span><span class="params">(results)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> key, result <span class="keyword">in</span> sorted(results.items()):</span><br><span class="line">        group, unit = key.split(<span class="string">';'</span>)</span><br><span class="line">        print(<span class="string">'&#123;:2&#125; &#123;:5&#125; averaging &#123;:.2f&#125;&#123;&#125;'</span>.format(</span><br><span class="line">            result.count, group, result.average, unit))</span><br><span class="line"></span><br><span class="line">data = &#123;  <span class="comment"># 男女学生的体重和身高</span></span><br><span class="line">    <span class="string">'girls;kg'</span>:</span><br><span class="line">        [<span class="number">40.9</span>, <span class="number">38.5</span>, <span class="number">44.3</span>, <span class="number">42.2</span>, <span class="number">45.2</span>, <span class="number">41.7</span>, <span class="number">44.5</span>, <span class="number">39.0</span>, <span class="number">40.6</span>, <span class="number">44.5</span>],</span><br><span class="line">    <span class="string">'girls;m'</span>:</span><br><span class="line">        [<span class="number">1.6</span>, <span class="number">1.51</span>, <span class="number">1.4</span>, <span class="number">1.3</span>, <span class="number">1.41</span>, <span class="number">1.39</span>, <span class="number">1.33</span>, <span class="number">1.46</span>, <span class="number">1.45</span>, <span class="number">1.43</span>],</span><br><span class="line">    <span class="string">'boys;kg'</span>:</span><br><span class="line">        [<span class="number">39.0</span>, <span class="number">40.8</span>, <span class="number">43.2</span>, <span class="number">40.8</span>, <span class="number">43.1</span>, <span class="number">38.6</span>, <span class="number">41.4</span>, <span class="number">40.6</span>, <span class="number">36.3</span>],</span><br><span class="line">    <span class="string">'boys;m'</span>:</span><br><span class="line">        [<span class="number">1.38</span>, <span class="number">1.5</span>, <span class="number">1.32</span>, <span class="number">1.25</span>, <span class="number">1.37</span>, <span class="number">1.48</span>, <span class="number">1.25</span>, <span class="number">1.49</span>, <span class="number">1.46</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main(data)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python coroaverager3.py</span><br><span class="line"> 9 boys  averaging 40.42kg</span><br><span class="line"> 9 boys  averaging 1.39m</span><br><span class="line">10 girls averaging 42.14kg</span><br><span class="line">10 girls averaging 1.43m</span><br></pre></td></tr></table></figure><p>grouper 函数中循环的目的：在 <code>averager()</code> 返回结果，并将结果绑定到 <code>results[key]</code> 上之后，生成器能够继续运行至下一个 yield 处，而不是抛出 StopIteration 异常。如果不使用循环，下面的方法同样可以完成任务。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grouper</span><span class="params">(results, key)</span>:</span></span><br><span class="line">    results[key] = <span class="keyword">yield</span> <span class="keyword">from</span> averager()</span><br><span class="line">    _ = <span class="keyword">yield</span>  <span class="comment"># group.send(None)之后，group会暂停在此处，然后调用方会重新</span></span><br><span class="line">               <span class="comment"># 创建grouper并绑定到group变量上，旧的grouper会被垃圾回收程序回收</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grouper</span><span class="params">(results, key)</span>:</span></span><br><span class="line">    results[key] = <span class="keyword">yield</span> <span class="keyword">from</span> averager()  <span class="comment"># 不做处理</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(data)</span>:</span></span><br><span class="line">    results = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key, values <span class="keyword">in</span> data.items():</span><br><span class="line">        <span class="comment"># 其他代码</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            group.send(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:  <span class="comment"># 在调用方捕获异常</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    report(results)</span><br></pre></td></tr></table></figure><p>示例展示了 yield from 结构最简单的用法，只有一个委派生成器和一个子生成器。因为委派生成器相当于管道，所以可以把任意数量个委派生成器连接在一起：一个委派生成器使用 yield from 调用一个子生成器，而那个子生成器本身也是委派生成器，使用 yield from 调用另一个子生成器，以此类推。最终，这个链条要以一个只使用 yield 表达式的简单生成器结束；不过，也能以任何可迭代的对象结束（yield from iterable）。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> coroutines </tag>
            
            <tag> Fluent Python </tag>
            
            <tag> yield </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上下文管理器和else块</title>
      <link href="/notes/fluent-python/context-managers-and-else-blocks/"/>
      <url>/notes/fluent-python/context-managers-and-else-blocks/</url>
      
        <content type="html"><![CDATA[<h1 id="if语句之外的else块">if语句之外的else块</h1><p>else子句不仅能在if语句中使用，还能在for、while和try语句中使用。for/else、while/else和try/else的语义关系紧密，不过与if/else差别很大。</p><p>for：仅当for循环运行完毕时（即for循环没有被break语句终止）才运行else块。</p><p>while：仅当while循环因为条件为假值而退出时（即while循环没有被break语句终止）才运行else块。</p><p>try：仅当try块中没有异常抛出时才运行else块。else子句抛出的异常不会由前面的except子句处理。</p><p>在所有情况下，如果异常或者return、break或continue语句导致控制权跳到了复合语句的主块之外，else子句也会被跳过。</p><p>在这些语句中使用else子句通常能让代码更易于阅读，而且能省去一些麻烦，不用设值控制标志或者添加额外的if语句。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在循环中使用else子句</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> my_list:</span><br><span class="line">    <span class="keyword">if</span> item.flavor == <span class="string">'banana'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">'No banana flavor found!'</span>)</span><br><span class="line"><span class="comment"># 这样呢，我就是不喜欢用for/else</span></span><br><span class="line">have_banana_flavor = any(item.flavor == <span class="string">'banana'</span> <span class="keyword">for</span> item <span class="keyword">in</span> my_list)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> have_banana_flavor:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">'No banana flavor found!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在try/except块中使用else子句</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    dangerous_call()</span><br><span class="line">    after_call()  <span class="comment"># after_call()不应该放在try块中，为了清晰和准确，try块中</span></span><br><span class="line"><span class="keyword">except</span> OSError:   <span class="comment"># 应该只包含抛出预期异常的语句</span></span><br><span class="line">    log(<span class="string">'OSError...'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因此，像下面这样写更好</span></span><br><span class="line"><span class="keyword">try</span>:  <span class="comment"># try块防守的是可能出现的错误</span></span><br><span class="line">    dangerous_call()</span><br><span class="line"><span class="keyword">except</span> OSError:</span><br><span class="line">    log(<span class="string">'OSError...'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    after_call()</span><br></pre></td></tr></table></figure><p>在Python中，try/except不仅用于处理错误，还常用于控制流程。为此，Python官方词汇表还定义了一个缩略词（口号）。</p><p><strong>EAFP</strong>：取得原谅比获得许可容易（easier to ask for forgiveness than permission）。这是一种常见的Python编程风格，先假定存在有效的键或属性，如果假定不成立，那么捕获异常。这种风格简单明快，特点是代码中有很多try和except语句。与其他很多语言一样，这种风格的对立面是LBYL风格。</p><p><strong>LBYL</strong>：三思而后行（look before you leap）。这种编程风格在调用函数或查找属性或键之前显式测试前提条件。与EAFP风格相反，这种风格的特点是代码中有很多if语句。在多线程环境中，LBYL风格可能会在“检查”和“行事”的空当引入条件竞争。例如，对if key in mapping: return mapping[key]这段代码来说，如果在测试之后，但是在查找之前，另一个线程从映射中删除了那个键，那么这段代码就会失败。这个问题可以用锁或者EAFP风格解决。如果选择EAFP风格，那就要更深入地了解else子句，并在try/except语句中合理使用。</p><h1 id="上下文管理器和with块">上下文管理器和with块</h1><p>上下文管理器对象存在的目的是管理with语句，就像迭代器的存在是为了管理for语句一样。</p><p>with语句的目的是简化try/finally模式。这种模式用于保证一段代码运行完毕后执行某项操作，即便那段代码由于异常、return语句或sys.exit()调用而中止，也会执行指定的操作。finally子句中的代码通常用于释放重要的资源，或者还原临时变更的状态。</p><p>上下文管理器协议包含<code>__enter__</code>和<code>__exit__</code>两个方法。with语句开始运行时，会在上下文管理器对象上调用<code>__enter__</code>方法。with语句运行结束后，会在上下文管理器对象上调用<code>__exit__</code>方法，以此扮演finally子句的角色。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最常见的例子是确保关闭文件对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'class.wsd'</span>) <span class="keyword">as</span> fp:  <span class="comment"># fp绑定到打开的文件上，因为文件的__enter__方法返回self</span></span><br><span class="line"><span class="meta">... </span>    src = fp.read(<span class="number">60</span>)  <span class="comment"># 读取一些数据</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(src)</span><br><span class="line"><span class="number">60</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp  <span class="comment"># fp仍然可用，与函数和模块不同，with块没有定义新的作用域</span></span><br><span class="line">&lt;_io.TextIOWrapper name=<span class="string">'class.wsd'</span> mode=<span class="string">'r'</span> encoding=<span class="string">'UTF-8'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp.closed, fp.encoding  <span class="comment"># 可以读取fp对象的属性</span></span><br><span class="line">(<span class="literal">True</span>, <span class="string">'UTF-8'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp.read(<span class="number">60</span>)  <span class="comment"># 但不能在fp上执行I/O操作，因为在with块的末尾，调用TextIOWrapper.__exit__方法把文件关闭了</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: I/O operation on closed file.</span><br></pre></td></tr></table></figure><p><strong>执行with后面的表达式得到的结果是上下文管理器对象，不过把值绑定到目标变量上（as子句）是在上下文管理器对象上调用<code>__enter__</code>方法的结果。</strong>碰巧，示例中的open()函数返回TextIOWrapper类的实例，而该实例的<code>__enter__</code>方法返回self。不过<code>__enter__</code>方法除了返回上下文管理器之外，还可能返回其他对象。</p><p>不管控制流程以哪种方式退出with块，都会在上下文管理器对象上调用<code>__exit__</code>方法，而不是在<code>__enter__</code>方法返回的对象上调用。</p><p>with语句的as子句是可选的。对open函数来说，必须加上as子句，以便获取文件的引用。不过，有些上下文管理器会返回None，因为没什么有用的对象能提供给用户。</p><figure class="highlight python"><figcaption><span>mirror.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LookingGlass</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">import</span> sys</span><br><span class="line">        self.original_write = sys.stdout.write</span><br><span class="line">        sys.stdout.write = self.reverse_write  <span class="comment"># 通过猴子补丁替换成自己的反向输出方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'ABCDE'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_write</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.original_write(text[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_value, traceback)</span>:</span>  <span class="comment"># 如果一切正常，传入的参数是None, None, None</span></span><br><span class="line">        <span class="keyword">import</span> sys</span><br><span class="line">        sys.stdout.write = self.original_write  <span class="comment"># 退出时再换回来</span></span><br><span class="line">        <span class="keyword">if</span> exc_type <span class="keyword">is</span> ZeroDivisionError:  <span class="comment"># 如果有ZeroDivisionError类型异常</span></span><br><span class="line">            print(<span class="string">'Please DO NOT divide by zero!'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span>  <span class="comment"># 返回True，告诉解释器，异常已经处理了</span></span><br><span class="line">        <span class="comment"># 如果__exit__方法返回None，或者True之外的值，with块中的任何异常都会向上冒泡</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> mirror <span class="keyword">import</span> LookingGlass</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> LookingGlass() <span class="keyword">as</span> what:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Hello World!'</span>)</span><br><span class="line"><span class="meta">... </span>    print(what)</span><br><span class="line">...</span><br><span class="line">!dlroW olleH  <span class="comment"># 在with块中输出的内容都是反向的</span></span><br><span class="line">EDCBA</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>what  <span class="comment"># __enter__返回的结果存在what变量中</span></span><br><span class="line"><span class="string">'ABCDE'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(what)  <span class="comment"># 输出不再反向了</span></span><br><span class="line">ABCDE</span><br></pre></td></tr></table></figure><p><strong>在实际使用中，如果应用程序接管了标准输出，可能会把sys.stdout换成类似文件的其他对象，然后再切换成原来的版本。</strong><a href="https://devdocs.io/python~3.6/library/contextlib#contextlib.redirect_stdout" target="_blank" rel="noopener">contextlib.redirect_stdout</a>上下文管理器就是这么做的：只需传入类似文件的对象，用于替代sys.stdout。</p><p>解释器调用<code>__enter__</code>方法时，除了隐式的self之外，不会传入任何参数。传给<code>__exit__</code>方法的三个参数如下：</p><p>exc_type：异常类（例如ZeroDivisionError）。</p><p>exc_value：异常实例。有时会有参数传给异常构造方法，例如错误消息，这些参数可以使用exc_value.args获取。</p><p>traceback：trackback对象。</p><p>在try/finally语句的finally块中调用sys.exc_info()得到的就是<code>__exit__</code>接收的这三个参数。鉴于with语句是为了取代大多数try/finally语句，而且通常需要调用sys.exc_info()来判断做什么清理操作，这种行为是合理的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 上下文管理器的具体工作方式</span></span><br><span class="line"><span class="comment"># 在这个示例中，我们在with块之外使用LookingGlass类</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>manager = LookingGlass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>manager</span><br><span class="line">&lt;mirror.LookingGlass object at <span class="number">0x104f5f390</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>monster = manager.__enter__()  <span class="comment"># 从此进入镜中世界</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>monster</span><br><span class="line"><span class="string">'EDCBA'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>monster == <span class="string">'ABCDE'</span></span><br><span class="line">eurT</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>manager</span><br><span class="line">&gt;<span class="number">093</span>f5f401x0 ta tcejbo ssalGgnikooL.rorrim&lt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>manager.__exit__(<span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>)  <span class="comment"># 退出</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>monster</span><br><span class="line"><span class="string">'ABCDE'</span></span><br></pre></td></tr></table></figure><h1 id="contextlib模块中的实用工具">contextlib模块中的实用工具</h1><p>除了前面提到的redirect_stdout函数，contextlib模块中还有一些类和其他函数，使用范围更广。</p><p>closing：如果对象提供了close()方法，但没有实现<code>__enter__/__exit__</code>协议，那么可以使用这个函数构建上下文管理器。</p><p>suppress：构建临时忽略指定异常的上下文管理器。</p><p><span class="citation" data-cites="contextmanager">@contextmanager</span>：这个装饰器把简单的生成器函数变成上下文管理器，这样就不用创建类去实现管理器协议了。</p><p>ContextDecorator：这是个基类，用于定义基于类的上下文管理器。这种上下文管理器也能用于装饰器函数，在受管理的上下文中运行整个函数。</p><p>ExitStack：这个上下文管理器能进入多个上下文管理器。with块结束时，ExitStack按照后进先出的顺序调用栈中各个上下文管理器的<code>__exit__</code>方法。如果事先不知道with块要进入多少个上下文管理器，可以使用这个类。例如，同时打开任意一个文件列表中的所有文件。</p><p>在这些实用工具中，使用最广泛的是@contextmanager装饰器。这个装饰器也有迷惑人的一面，因为它与迭代无关，却要使用yield语句。</p><h1 id="使用contextmanager">使用@contextmanager</h1><p><span class="citation" data-cites="contextmanager装饰器能减少创建上下文管理器的样板代码量">@contextmanager装饰器能减少创建上下文管理器的样板代码量</span>，因为不用编写一个完整的类，定义<code>__enter__</code>和<code>__exit__</code>方法，而只需实现有一个yield语句的生成器，生成想让<code>__enter__</code>方法返回的值。</p><p>在使用@contextmanager装饰的生成器中，yield语句的作用是把函数的定义体分成两部分：yield语句前面的所有代码在with块开始时（即解释器调用<code>__enter__</code>方法时）执行，yield语句后面的代码在with块结束时（即调用<code>__exit__</code>方法时）执行。</p><figure class="highlight python"><figcaption><span>mirror_gen.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextlib.contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">looking_glass</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    original_write = sys.stdout.write</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_write</span><span class="params">(text)</span>:</span></span><br><span class="line">        original_write(text[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    sys.stdout.write = reverse_write</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'ABCDE'</span></span><br><span class="line">    sys.stdout.write = original_write</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> mirror_gen <span class="keyword">import</span> looking_glass</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> looking_glass() <span class="keyword">as</span> what:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Hello World!'</span>)</span><br><span class="line"><span class="meta">... </span>    print(what)</span><br><span class="line">...</span><br><span class="line">!dlroW olleH</span><br><span class="line">EDCBA</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>what</span><br><span class="line"><span class="string">'ABCDE'</span></span><br></pre></td></tr></table></figure><p>其实，contextlib.contextmanager装饰器会把函数包含成实现<code>__enter__</code>和<code>__exit__</code>方法的类。这个类的<code>__enter__</code>方法有如下作用：</p><ol type="1"><li>调用生成器函数，保存生成器对象（这里把它称为gen）。</li><li>调用next(gen)，执行到yield关键字所在的位置。</li><li>返回next(gen)产出的值，以便把产出的值绑定到with/as语句中的目标变量上。</li></ol><p>with块终止时，<code>__exit__</code>方法会做以下几件事：</p><ol type="1"><li>检查有没有把异常传给exc_type；如果有，调用gen.throw(exception)，在生成器函数定义体中包含yield关键字的那一行抛出异常。</li><li>否则，调用next(gen)，继续执行生成器函数定义体中yield语句之后的代码。</li></ol><p>上述示例中有一个严重的错误：如果在with块中抛出了异常，Python解释器会将其捕获，然后再looking_glass函数的yield表达式里再次抛出。但是，那里没有处理错误的代码，因此looking_glass函数会终止，永远无法恢复成原来的sys.stdout.write方法，导致系统处于无效状态。</p><p>下面的实例中添加了一些代码，特别用于处理ZeroDivisionError异常；这样，在功能上它就与基于类的实现等效了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextlib.contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">looking_glass</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    original_write = sys.stdout.write</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_write</span><span class="params">(text)</span>:</span></span><br><span class="line">        original_write(text[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    sys.stdout.write = reverse_write</span><br><span class="line">    msg = <span class="string">''</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">'ABCDE'</span></span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        msg = <span class="string">'Please DO NOT divide by zero!'</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        sys.stdout.write = original_write  <span class="comment"># 撤销猴子补丁</span></span><br><span class="line">        <span class="keyword">if</span> msg:  <span class="comment"># 有错误消息就输出</span></span><br><span class="line">            print(msg)</span><br></pre></td></tr></table></figure><p>前面说过，为了告诉解释器异常已经处理了，<code>__exit__</code>方法会返回True，此时解释器会压制异常。如果<code>__exit__</code>方法没有显式返回一个值，那么解释器得到的是None，然后向上冒泡异常。<strong>使用@contextmanager装饰器时，默认的行为是相反的：装饰器提供的<code>__exit__</code>方法假定发给生成器的所有异常都得到处理了，因此应该压制异常。</strong>如果不想让@contextmanager压制异常，必须在被装饰的函数中显式重新抛出异常。</p><p><strong>使用@contextmanager装饰器时，要把yield语句放在try/finally语句中（或者放在with语句中），这是无法避免的，因为我们永远不知道上下文管理器的用户会在with块中做什么。</strong></p><p>除了标准库中举的例子之外，Martijn Pieters实现的原地文件重写上下文管理器<a href="http://www.zopatista.com/python/2013/11/26/inplace-file-rewriting/" target="_blank" rel="noopener"><code>inplace</code></a>是@contextmanager不错的使用实例。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用inplace上下文管理器，它为同一个文件提供了两个句柄，以便同时读写同一个文件</span></span><br><span class="line"><span class="keyword">with</span> inplace(csvfilename, <span class="string">'r'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> (infh, outfh):</span><br><span class="line">    reader = csv.reader(infh)</span><br><span class="line">    writer = csv.writer(outfh)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        row += [<span class="string">'new'</span>, <span class="string">'columns'</span>]</span><br><span class="line">        writer.writerow(row)</span><br></pre></td></tr></table></figure><p><strong>在@contextmanager装饰器装饰的生成器中，yield与迭代没有任何关系。</strong>在本节所举的示例中，生成器函数的作用更像是协程：执行到某一点时暂停，让客户代码运行，直到客服让协程继续做事。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> contextlib </tag>
            
            <tag> with </tag>
            
            <tag> for/else </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标准库中的生成器函数</title>
      <link href="/notes/fluent-python/generator-functions-in-standard-library/"/>
      <url>/notes/fluent-python/generator-functions-in-standard-library/</url>
      
        <content type="html"><![CDATA[<p>本节专注于通用的函数：参数为任意的可迭代对象，返回值是生成器，用于生成选中的、计算出的和重新排列的元素。</p><h1 id="用于过滤">用于过滤</h1><p>从输入的可迭代对象中产出元素的子集，而且不修改元素本身。</p><table><colgroup><col style="width: 10%"><col style="width: 20%"><col style="width: 70%"></colgroup><thead><tr class="header"><th>模块</th><th>函数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>itertools</code></td><td><code>compress(it, selector_it)</code></td><td>并行处理两个可迭代对象；如果 <code>selector_it</code> 中的元素是真值，产出 <code>it</code> 中对应的元素</td></tr><tr class="even"><td><code>itertools</code></td><td><a href="https://devdocs.io/python~3.6/library/itertools#itertools.dropwhile" target="_blank" rel="noopener"><code>dropwhile(predicate, it)</code></a></td><td>扔掉满足条件的元素，<code>predicate</code> 首次返回 <code>Flase</code> 时，停止检查，产出后续元素（不再检查）</td></tr><tr class="odd"><td>内置</td><td><code>filter(predicate, it)</code></td><td>把 <code>it</code> 中的各个元素传给 <code>predicate</code>，如果 <code>predicate(item)</code> 返回真值，那么产出对应的元素；如果 <code>predicate</code> 是 <code>None</code>，那么只产出真值元素</td></tr><tr class="even"><td><code>itertools</code></td><td><code>filterfalse(predicate, it)</code></td><td>与 <code>filter</code> 函数的作用类似，不过 <code>predicate</code> 的逻辑是相反的：<code>predicate</code> 返回假值时产出对应的元素</td></tr><tr class="odd"><td><code>itertools</code></td><td><code>islice(it, stop)</code> 或 <code>islice(it, start, stop, step=1</code></td><td>产出 <code>it</code> 的切片，作用类似于 <code>s[:stop]</code> 或 <code>s[start:stop:step]</code>，不过 <code>it</code> 可以是任何可迭代的对象，而且这个函数实现的是惰性操作</td></tr><tr class="even"><td><code>itertools</code></td><td><a href="https://devdocs.io/python~3.6/library/itertools#itertools.takewhile" target="_blank" rel="noopener"><code>takewhile(predicate, it)</code></a></td><td>产出满足条件的元素，<code>predicate</code> 首次返回 <code>False</code> 时立即停止，不产出后续元素</td></tr></tbody></table><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">vowel</span><span class="params">(c)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> c.lower() <span class="keyword">in</span> <span class="string">'aeiou'</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(filter(vowel, <span class="string">'Aardvark'</span>))</span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> itertools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.filterfalse(vowel, <span class="string">'Aardvark'</span>))</span><br><span class="line">[<span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'v'</span>, <span class="string">'r'</span>, <span class="string">'k'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.dropwhile(vowel, <span class="string">'Aardvark'</span>))</span><br><span class="line">[<span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'v'</span>, <span class="string">'a'</span>, <span class="string">'r'</span>, <span class="string">'k'</span>]  <span class="comment"># 'r'是首个不满足条件的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.takewhile(vowel, <span class="string">'Aardvark'</span>))</span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'a'</span>]  <span class="comment"># 'A', 'a'都满足条件，'r'是首个不满足条件的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.compress(<span class="string">'Aardvark'</span>, (<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>)))</span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.islice(<span class="string">'Aardvark'</span>, <span class="number">4</span>))</span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'a'</span>, <span class="string">'r'</span>, <span class="string">'d'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.islice(<span class="string">'Aardvark'</span>, <span class="number">4</span>, <span class="number">7</span>))</span><br><span class="line">[<span class="string">'v'</span>, <span class="string">'a'</span>, <span class="string">'r'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.islice(<span class="string">'Aardvark'</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>))</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>]</span><br></pre></td></tr></table></figure><h1 id="用于映射">用于映射</h1><table><colgroup><col style="width: 10%"><col style="width: 20%"><col style="width: 70%"></colgroup><thead><tr class="header"><th>模块</th><th>函数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>itertools</code></td><td><code>accumulate(it, [func]</code></td><td>产出累计的总和；如果提供了 <code>func</code>，那么把前两个元素传给它，然后把计算结果和下一个元素传给它，以此类推，最后产出结果</td></tr><tr class="even"><td>内置</td><td><code>enumerate(iterable, start=0)</code></td><td>产出由两个元素构成的元素，结构是 <code>(index, item)</code>，其中 <code>index</code> 从 <code>start</code> 开始计数，<code>item</code> 则从 <code>iterable</code> 中获取</td></tr><tr class="odd"><td>内置</td><td><code>map(func, it1, [it2, ..., itN])</code></td><td>把 <code>it</code> 中的各个元素传给 <code>func</code>，产出结果；如果传入 N 个可迭代的对象，那么 <code>func</code> 必须能接受 N 个参数，而且要并行处理各个可迭代的对象</td></tr><tr class="even"><td><code>itertools</code></td><td><code>starmap(func, it)</code></td><td>把 <code>it</code> 中的各个元素传给 <code>func</code>，产出结果；输入的可迭代对象应该产出可迭代的元素 <code>iit</code>，然后以 <code>func(*iit)</code> 这种形式调用 <code>func</code></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sample = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.accumulate(sample))  <span class="comment"># 累加</span></span><br><span class="line">[<span class="number">5</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">32</span>, <span class="number">35</span>, <span class="number">35</span>, <span class="number">44</span>, <span class="number">45</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.accumulate(sample, min))  <span class="comment"># 计算最小值</span></span><br><span class="line">[<span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.accumulate(sample, max))  <span class="comment"># 计算最大值</span></span><br><span class="line">[<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> operator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.accumulate(sample, operator.mul))  <span class="comment"># 累乘</span></span><br><span class="line">[<span class="number">5</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">320</span>, <span class="number">2240</span>, <span class="number">13440</span>, <span class="number">40320</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.accumulate(range(<span class="number">1</span>, <span class="number">11</span>), operator.mul))  <span class="comment"># 从1!到10!</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>, <span class="number">720</span>, <span class="number">5040</span>, <span class="number">40320</span>, <span class="number">362880</span>, <span class="number">3628800</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(enumerate(<span class="string">'albatroz'</span>, <span class="number">1</span>))</span><br><span class="line">[(<span class="number">1</span>, <span class="string">'a'</span>), (<span class="number">2</span>, <span class="string">'l'</span>), (<span class="number">3</span>, <span class="string">'b'</span>), (<span class="number">4</span>, <span class="string">'a'</span>), (<span class="number">5</span>, <span class="string">'t'</span>), (<span class="number">6</span>, <span class="string">'r'</span>), (<span class="number">7</span>, <span class="string">'o'</span>), (<span class="number">8</span>, <span class="string">'z'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(operator.mul, range(<span class="number">11</span>), range(<span class="number">11</span>)))  <span class="comment"># 0到10的平方</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(operator.mul, range(<span class="number">11</span>), [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>]))  <span class="comment"># 短的iterator结束时停止</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">4</span>, <span class="number">16</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(<span class="keyword">lambda</span> a, b: (a, b), range(<span class="number">11</span>), [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>]))  <span class="comment"># 等同于zip</span></span><br><span class="line">[(<span class="number">0</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">8</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.starmap(operator.mul, enumerate(<span class="string">'albatroz'</span>, <span class="number">1</span>)))  <span class="comment"># 根据所在位置重复相应次数</span></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'ll'</span>, <span class="string">'bbb'</span>, <span class="string">'aaaa'</span>, <span class="string">'ttttt'</span>, <span class="string">'rrrrrr'</span>, <span class="string">'ooooooo'</span>, <span class="string">'zzzzzzzz'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.starmap(<span class="keyword">lambda</span> a, b: b/a,</span><br><span class="line"><span class="meta">... </span>    enumerate(itertools.accumulate(sample), <span class="number">1</span>)))  <span class="comment"># 计算均值</span></span><br><span class="line">[<span class="number">5.0</span>, <span class="number">4.5</span>, <span class="number">3.6666666666666665</span>, <span class="number">4.75</span>, <span class="number">5.2</span>, <span class="number">5.333333333333333</span>, <span class="number">5.0</span>, <span class="number">4.375</span>, <span class="number">4.888888888888889</span>, <span class="number">4.5</span>]</span><br></pre></td></tr></table></figure><h1 id="用于合并">用于合并</h1><table><colgroup><col style="width: 10%"><col style="width: 20%"><col style="width: 70%"></colgroup><thead><tr class="header"><th>模块</th><th>函数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>itertools</code></td><td><code>chain(it1, ..., itN)</code></td><td>先产出 <code>it1</code> 中的所有元素，然后产出 <code>it2</code> 中的所有元素，以此类推，无缝连接在一起</td></tr><tr class="even"><td><code>itertools</code></td><td><code>chain.from_iterable(it)</code></td><td>产出 <code>it</code> 生成的各个可迭代对象中的元素，一个接一个，无缝连接在一起；<code>it</code> 应该产出可迭代元素，例如可迭代的对象列表</td></tr><tr class="odd"><td><code>itertools</code></td><td><code>product(it1, ..., itN, repeat=1)</code></td><td>计算笛卡尔积：从输入的各个可迭代元素中获取元素，合并成由 N 个元素组成的元组，与嵌套的 <code>for</code> 循环效果一样；<code>repeat</code> 指明重复处理多少次输入的可迭代对象</td></tr><tr class="even"><td>内置</td><td><code>zip(it1, ..., itN)</code></td><td>并行从输入的各个可迭代对象中获取元素，产出由 N 个元素组成的元组，只要有一个可迭代的对象到头了，就默默地停止</td></tr><tr class="odd"><td><code>itertools</code></td><td><code>zip_longest(it1, ..., itN, fillvalue=None)</code></td><td>并行从输入的各个可迭代对象中获取元素，产出由 N 个元素组成的元组，等到最长的可迭代对象到头后才停止，空缺的值使用 <code>fillvalue</code> 填充</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.chain(<span class="string">'ABC'</span>, range(<span class="number">2</span>)))</span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.chain(enumerate(<span class="string">'ABC'</span>)))  <span class="comment"># 如果只传入一个可迭代的对象，那么chain函数没什么用</span></span><br><span class="line">[(<span class="number">0</span>, <span class="string">'A'</span>), (<span class="number">1</span>, <span class="string">'B'</span>), (<span class="number">2</span>, <span class="string">'C'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.chain.from_iterable(enumerate(<span class="string">'ABC'</span>)))  <span class="comment"># 各元素本身必须是可迭代对象</span></span><br><span class="line">[<span class="number">0</span>, <span class="string">'A'</span>, <span class="number">1</span>, <span class="string">'B'</span>, <span class="number">2</span>, <span class="string">'C'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(<span class="string">'ABC'</span>, range(<span class="number">5</span>)))</span><br><span class="line">[(<span class="string">'A'</span>, <span class="number">0</span>), (<span class="string">'B'</span>, <span class="number">1</span>), (<span class="string">'C'</span>, <span class="number">2</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(<span class="string">'ABC'</span>, range(<span class="number">5</span>), [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]))  <span class="comment"># 最短的iterator到头时停止</span></span><br><span class="line">[(<span class="string">'A'</span>, <span class="number">0</span>, <span class="number">10</span>), (<span class="string">'B'</span>, <span class="number">1</span>, <span class="number">20</span>), (<span class="string">'C'</span>, <span class="number">2</span>, <span class="number">30</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.zip_longest(<span class="string">'ABC'</span>, range(<span class="number">5</span>)))  <span class="comment"># 最长的iterator到头时停止，默认用None填充空缺的值</span></span><br><span class="line">[(<span class="string">'A'</span>, <span class="number">0</span>), (<span class="string">'B'</span>, <span class="number">1</span>), (<span class="string">'C'</span>, <span class="number">2</span>), (<span class="literal">None</span>, <span class="number">3</span>), (<span class="literal">None</span>, <span class="number">4</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.zip_longest(<span class="string">'ABC'</span>, range(<span class="number">5</span>), fillvalue=<span class="string">'?'</span>))  <span class="comment"># 使用指定字符填充</span></span><br><span class="line">[(<span class="string">'A'</span>, <span class="number">0</span>), (<span class="string">'B'</span>, <span class="number">1</span>), (<span class="string">'C'</span>, <span class="number">2</span>), (<span class="string">'?'</span>, <span class="number">3</span>), (<span class="string">'?'</span>, <span class="number">4</span>)]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.product(<span class="string">'ABC'</span>, range(<span class="number">2</span>)))  <span class="comment"># 生成3*2个元组</span></span><br><span class="line">[(<span class="string">'A'</span>, <span class="number">0</span>), (<span class="string">'A'</span>, <span class="number">1</span>), (<span class="string">'B'</span>, <span class="number">0</span>), (<span class="string">'B'</span>, <span class="number">1</span>), (<span class="string">'C'</span>, <span class="number">0</span>), (<span class="string">'C'</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>suits = <span class="string">'spades hearts diamonds clubs'</span>.split()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.product(<span class="string">'AK'</span>, suits))</span><br><span class="line">[(<span class="string">'A'</span>, <span class="string">'spades'</span>), (<span class="string">'A'</span>, <span class="string">'hearts'</span>), (<span class="string">'A'</span>, <span class="string">'diamonds'</span>), (<span class="string">'A'</span>, <span class="string">'clubs'</span>), (<span class="string">'K'</span>, <span class="string">'spades'</span>), (<span class="string">'K'</span>, <span class="string">'hearts'</span>), (<span class="string">'K'</span>, <span class="string">'diamonds'</span>), (<span class="string">'K'</span>, <span class="string">'clubs'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.product(<span class="string">'ABC'</span>))  <span class="comment"># 如果传入一个可迭代的对象，产出的是一系列只有一个元素的元组，不是特别有用</span></span><br><span class="line">[(<span class="string">'A'</span>,), (<span class="string">'B'</span>,), (<span class="string">'C'</span>,)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.product(<span class="string">'ABC'</span>, repeat=<span class="number">2</span>))  <span class="comment"># 重复2次</span></span><br><span class="line">[(<span class="string">'A'</span>, <span class="string">'A'</span>), (<span class="string">'A'</span>, <span class="string">'B'</span>), (<span class="string">'A'</span>, <span class="string">'C'</span>), (<span class="string">'B'</span>, <span class="string">'A'</span>), (<span class="string">'B'</span>, <span class="string">'B'</span>), (<span class="string">'B'</span>, <span class="string">'C'</span>), (<span class="string">'C'</span>, <span class="string">'A'</span>), (<span class="string">'C'</span>, <span class="string">'B'</span>), (<span class="string">'C'</span>, <span class="string">'C'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.product(range(<span class="number">2</span>), repeat=<span class="number">3</span>))</span><br><span class="line">[(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rows = itertools.product(<span class="string">'AB'</span>, range(<span class="number">2</span>), repeat=<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> row <span class="keyword">in</span> rows: print(row)</span><br><span class="line">...</span><br><span class="line">(<span class="string">'A'</span>, <span class="number">0</span>, <span class="string">'A'</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="string">'A'</span>, <span class="number">0</span>, <span class="string">'A'</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="string">'A'</span>, <span class="number">0</span>, <span class="string">'B'</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="string">'A'</span>, <span class="number">0</span>, <span class="string">'B'</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="string">'A'</span>, <span class="number">1</span>, <span class="string">'A'</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="string">'A'</span>, <span class="number">1</span>, <span class="string">'A'</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="string">'A'</span>, <span class="number">1</span>, <span class="string">'B'</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="string">'A'</span>, <span class="number">1</span>, <span class="string">'B'</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="string">'B'</span>, <span class="number">0</span>, <span class="string">'A'</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="string">'B'</span>, <span class="number">0</span>, <span class="string">'A'</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="string">'B'</span>, <span class="number">0</span>, <span class="string">'B'</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="string">'B'</span>, <span class="number">0</span>, <span class="string">'B'</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="string">'B'</span>, <span class="number">1</span>, <span class="string">'A'</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="string">'B'</span>, <span class="number">1</span>, <span class="string">'A'</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="string">'B'</span>, <span class="number">1</span>, <span class="string">'B'</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="string">'B'</span>, <span class="number">1</span>, <span class="string">'B'</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h1 id="用于扩展元素">用于扩展元素</h1><table><colgroup><col style="width: 10%"><col style="width: 20%"><col style="width: 70%"></colgroup><thead><tr class="header"><th>模块</th><th>函数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>itertools</code></td><td><code>combinations(it, out_len)</code></td><td>把 <code>it</code> 产出的 <code>out_len</code> 个元素组合在一起，然后产出</td></tr><tr class="even"><td><code>itertools</code></td><td><code>combinations_with_replacement(it, out_len)</code></td><td>把 <code>it</code> 产出的 <code>out_len</code> 个元素组合在一起，然后产出，包含相同元素的组合</td></tr><tr class="odd"><td><code>itertools</code></td><td><code>count(start=0, step=1)</code></td><td>从 <code>start</code> 开始不断产出数字，按 <code>step</code> 指定的步幅增加</td></tr><tr class="even"><td><code>itertools</code></td><td><code>cycle(it)</code></td><td>从 <code>it</code> 中产出各个元素，存储各个元素的副本，然后按顺序重复不断地产出各个元素</td></tr><tr class="odd"><td><code>itertools</code></td><td><code>permutations(it, out_len=None)</code></td><td>把 <code>out_len</code> 个 <code>it</code> 产出的元素排列在一起，然后产出这些排列；<code>out_len</code> 的默认值等于 <code>len(list(it))</code></td></tr><tr class="even"><td><code>itertools</code></td><td><code>repeat(item, [times])</code></td><td>重复不断地产出指定的元素，除非提供 <code>times</code>，指定次数</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct = itertools.count()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(ct), next(ct), next(ct)  <span class="comment"># 不能使用ct构建列表，因为ct是无穷的</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)                                              <span class="comment"># 如果使用islice或takewhile函数，</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.islice(itertools.count(<span class="number">1</span>, <span class="number">.3</span>), <span class="number">3</span>))  <span class="comment"># 可以从count生成器中构建列表</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">1.3</span>, <span class="number">1.6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cy = itertools.cycle(<span class="string">'ABC'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.islice(cy, <span class="number">7</span>))  <span class="comment"># cy同样是无穷的</span></span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'A'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rp = itertools.repeat(<span class="number">7</span>)  <span class="comment"># 无限产出7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(rp), next(rp)</span><br><span class="line">(<span class="number">7</span>, <span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.repeat(<span class="number">8</span>, <span class="number">4</span>))  <span class="comment"># 限制次数</span></span><br><span class="line">[<span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(operator.mul, range(<span class="number">11</span>), itertools.repeat(<span class="number">5</span>)))  <span class="comment"># 乘数固定为5</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">50</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.combinations(<span class="string">'ABC'</span>, <span class="number">2</span>))  <span class="comment"># 不同元素的组合，次序不重要</span></span><br><span class="line">[(<span class="string">'A'</span>, <span class="string">'B'</span>), (<span class="string">'A'</span>, <span class="string">'C'</span>), (<span class="string">'B'</span>, <span class="string">'C'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.combinations_with_replacement(<span class="string">'ABC'</span>, <span class="number">2</span>))  <span class="comment"># 可包含相同元素的组合</span></span><br><span class="line">[(<span class="string">'A'</span>, <span class="string">'A'</span>), (<span class="string">'A'</span>, <span class="string">'B'</span>), (<span class="string">'A'</span>, <span class="string">'C'</span>), (<span class="string">'B'</span>, <span class="string">'B'</span>), (<span class="string">'B'</span>, <span class="string">'C'</span>), (<span class="string">'C'</span>, <span class="string">'C'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.permutations(<span class="string">'ABC'</span>, <span class="number">2</span>))  <span class="comment"># 排列，次序重要</span></span><br><span class="line">[(<span class="string">'A'</span>, <span class="string">'B'</span>), (<span class="string">'A'</span>, <span class="string">'C'</span>), (<span class="string">'B'</span>, <span class="string">'A'</span>), (<span class="string">'B'</span>, <span class="string">'C'</span>), (<span class="string">'C'</span>, <span class="string">'A'</span>), (<span class="string">'C'</span>, <span class="string">'B'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.product(<span class="string">'ABC'</span>, repeat=<span class="number">2</span>))  <span class="comment"># 'ABC'和'ABC'（repeat=2的效果）的笛卡尔积</span></span><br><span class="line">[(<span class="string">'A'</span>, <span class="string">'A'</span>), (<span class="string">'A'</span>, <span class="string">'B'</span>), (<span class="string">'A'</span>, <span class="string">'C'</span>), (<span class="string">'B'</span>, <span class="string">'A'</span>), (<span class="string">'B'</span>, <span class="string">'B'</span>), (<span class="string">'B'</span>, <span class="string">'C'</span>), (<span class="string">'C'</span>, <span class="string">'A'</span>), (<span class="string">'C'</span>, <span class="string">'B'</span>), (<span class="string">'C'</span>, <span class="string">'C'</span>)]</span><br></pre></td></tr></table></figure><h1 id="用于重新排列元素">用于重新排列元素</h1><table><colgroup><col style="width: 10%"><col style="width: 20%"><col style="width: 70%"></colgroup><thead><tr class="header"><th>模块</th><th>函数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>itertools</code></td><td><code>groupby(it, key=None)</code></td><td>产出由两个元素组成的元素，形式为 <code>(key, group)</code>，其中 <code>key</code> 是分组标准，<code>group</code> 是生成器，用于产出分组里的元素</td></tr><tr class="even"><td>内置</td><td><code>reversed(seq)</code></td><td>从后向前，倒序产出 <code>seq</code> 中的元素；<code>seq</code> 必须是序列，或者是实现了 <code>__reversed__</code> 特殊方法的对象</td></tr><tr class="odd"><td><code>itertools</code></td><td><code>tee(it, n=2)</code></td><td>产出一个由 n 个生成器组成的元组，每个生成器用于单独产出输入的可迭代对象中的元素</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.groupby(<span class="string">'LLLLAAGGG'</span>))</span><br><span class="line">[(<span class="string">'L'</span>, &lt;itertools._grouper object at <span class="number">0x103db4710</span>&gt;), (<span class="string">'A'</span>, &lt;itertools._grouper object at <span class="number">0x103db4390</span>&gt;), (<span class="string">'G'</span>, &lt;itertools._grouper object at <span class="number">0x103db4748</span>&gt;)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> char, group <span class="keyword">in</span> itertools.groupby(<span class="string">'LLLLAAGGG'</span>):</span><br><span class="line"><span class="meta">... </span>    print(char, <span class="string">'-&gt;'</span>, list(group))</span><br><span class="line">...</span><br><span class="line">L -&gt; ['L', 'L', 'L', 'L']</span><br><span class="line">A -&gt; ['A', 'A']</span><br><span class="line">G -&gt; ['G', 'G', 'G']</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>animals = [<span class="string">'duck'</span>, <span class="string">'eagle'</span>, <span class="string">'rat'</span>, <span class="string">'giraffe'</span>, <span class="string">'bear'</span>,</span><br><span class="line"><span class="meta">... </span>            <span class="string">'bat'</span>, <span class="string">'dolphin'</span>, <span class="string">'shark'</span>, <span class="string">'lion'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>animals.sort(key=len)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>animals</span><br><span class="line">[<span class="string">'rat'</span>, <span class="string">'bat'</span>, <span class="string">'duck'</span>, <span class="string">'bear'</span>, <span class="string">'lion'</span>, <span class="string">'eagle'</span>, <span class="string">'shark'</span>, <span class="string">'giraffe'</span>, <span class="string">'dolphin'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> length, group <span class="keyword">in</span> itertools.groupby(animals, len):</span><br><span class="line"><span class="meta">... </span>    print(length, <span class="string">'-&gt;'</span>, list(group))</span><br><span class="line">...</span><br><span class="line">3 -&gt; ['rat', 'bat']</span><br><span class="line">4 -&gt; ['duck', 'bear', 'lion']</span><br><span class="line">5 -&gt; ['eagle', 'shark']</span><br><span class="line">7 -&gt; ['giraffe', 'dolphin']</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> length, group <span class="keyword">in</span> itertools.groupby(reversed(animals), len):</span><br><span class="line"><span class="meta">... </span>    print(length, <span class="string">'-&gt;'</span>, list(group))</span><br><span class="line">...</span><br><span class="line">7 -&gt; ['dolphin', 'giraffe']</span><br><span class="line">5 -&gt; ['shark', 'eagle']</span><br><span class="line">4 -&gt; ['lion', 'bear', 'duck']</span><br><span class="line">3 -&gt; ['bat', 'rat']</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.tee(<span class="string">'ABC'</span>))</span><br><span class="line">[&lt;itertools._tee object at <span class="number">0x103db68c8</span>&gt;, &lt;itertools._tee object at <span class="number">0x103db6788</span>&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g1, g2 = itertools.tee(<span class="string">'ABC'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g1), next(g2)</span><br><span class="line">(<span class="string">'A'</span>, <span class="string">'A'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g2)</span><br><span class="line"><span class="string">'B'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(g1)</span><br><span class="line">[<span class="string">'B'</span>, <span class="string">'C'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(g2)</span><br><span class="line">[<span class="string">'C'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(*itertools.tee(<span class="string">'ABC'</span>)))</span><br><span class="line">[(<span class="string">'A'</span>, <span class="string">'A'</span>), (<span class="string">'B'</span>, <span class="string">'B'</span>), (<span class="string">'C'</span>, <span class="string">'C'</span>)]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> generators </tag>
            
            <tag> itertools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可迭代对象、迭代器和生成器</title>
      <link href="/notes/fluent-python/iterables-iterators-and-generators/"/>
      <url>/notes/fluent-python/iterables-iterators-and-generators/</url>
      
        <content type="html"><![CDATA[<h1 id="sentence类第1版单词序列">Sentence类第1版：单词序列</h1><figure class="highlight python"><figcaption><span>sentence.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">        self.words = RE_WORD.findall(text)  <span class="comment"># 返回全部菲重叠匹配</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.words[index]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.words)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Sentence(%s)'</span> % reprlib.repr(self.text)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sentence <span class="keyword">import</span> Sentence</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Sentence(<span class="string">'"The time has come," the Walrus said,'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">Sentence(<span class="string">'"The time ha... Walrus said,'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(s)  <span class="comment"># Sentence实例是可迭代的，因此可以用于构建列表和其他可迭代的类型</span></span><br><span class="line">[<span class="string">'The'</span>, <span class="string">'time'</span>, <span class="string">'has'</span>, <span class="string">'come'</span>, <span class="string">'the'</span>, <span class="string">'Walrus'</span>, <span class="string">'said'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(s, abc.Iterable)  <span class="comment"># 虽然可以迭代，但无法通过isinstance检测</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(Sentence, abc.Iterable)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>解释器需要迭代对象x时，会自动调用iter(x)。内置的iter函数有以下作用。</p><ol type="1"><li>检查对象是否实现了<code>__iter__</code>方法，如果实现了就调用它，获取一个迭代器。</li><li>如果没有实现<code>__iter__</code>方法，但是实现了<code>__getitem__</code>方法，Python会创建一个迭代器，尝试按顺序获取元素。</li><li>如果尝试失败，Python抛出TypeError异常，通常会提示“C object is not iterable”，其中C是目标对象所属的类。</li></ol><p>任何Python序列都可迭代的原因是，它们都实现了<code>__getitem__</code>方法。其实，标准的序列也都实现了<code>__iter__</code>方法，因此你也应该这么做。之所以对<code>__getitem__</code>方法做特殊处理，是为了向后兼容，而未来可能不会再这么做。</p><p>因为abc.Iterable类实现了<code>__subclasshook__</code>方法，该方法将定义了<code>__iter__</code>方法的类认作自己的虚拟子类。因此，虽然Sentence类可以迭代，但是无法通过issubclass(Sentence, abc.Iterable)测试。</p><p><strong>从Python3.4开始，检查对象x能否迭代，最准确的方法是：调用iter(x)函数，如果不可迭代，再处理TypeError异常。</strong>这比使用isinstance(x, abc.Iterable)更准确，因为iter(x)函数会考虑到遗留的<code>__getitem__</code>方法，而abc.Iterable类则不考虑。</p><h2 id="可迭代的对象与迭代器的对比">可迭代的对象与迭代器的对比</h2><p>可迭代的对象：使用iter内置函数可以获取迭代器的对象。如果对象实现了能返回迭代器的<code>__iter__</code>方法，那么对象就是可迭代的。序列都可以迭代；实现了<code>__getitem__</code>方法，而且其参数是从零开始的索引，这种对象也可以迭代。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> char <span class="keyword">in</span> s:  <span class="comment"># 使用for循环迭代，背后有迭代器，但是看不到</span></span><br><span class="line"><span class="meta">... </span>    print(char)</span><br><span class="line">...</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it = iter(s)  <span class="comment"># 使用迭代器迭代</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>        print(next(it))</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">except</span> StopIteration:  <span class="comment"># 迭代器到头</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">del</span> it  <span class="comment"># 释放引用</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">break</span></span><br><span class="line">...</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br></pre></td></tr></table></figure><img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYIamgBYbAJ2vHy2n9BKfCoabLgEPI089gc4IjGdLkQab6VagjGdny9b1HV3nNBPgsalmYlDhoKYjAWDh02h0ObfTVagfGb9cUKQAGdmPt25ZvqzRjJ_PEVZwh1IQgLmVJ-6pQpcURfq9KxPhoOltI5_kdF9qzxycEXYSxLi6SzNJTl2VxkhbIyr8KGBPWimge2cn8IcgQ0jnmZUBKd3HDAx0421IbbfGMvIc0H1KKb1KWLa4CVpPdpOjTgn5Mm0FIfaPN5s45N5XFJyyE4MnM2i_cjJpTlGi0"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterator</span><span class="params">(Iterable)</span>:</span>  <span class="comment"># abc.Iterator类源码</span></span><br><span class="line"></span><br><span class="line">    __slots__ = ()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'Return the next item from the iterator. When exhausted, raise StopIteration'</span></span><br><span class="line">        <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__subclasshook__</span><span class="params">(cls, C)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">is</span> Iterator:</span><br><span class="line">            <span class="keyword">if</span> (any(<span class="string">"__next__"</span> <span class="keyword">in</span> B.__dict__ <span class="keyword">for</span> B <span class="keyword">in</span> C.__mro__) <span class="keyword">and</span></span><br><span class="line">                any(<span class="string">"__iter__"</span> <span class="keyword">in</span> B.__dict__ <span class="keyword">for</span> B <span class="keyword">in</span> C.__mro__)):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Sentence(<span class="string">'A B'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it = iter(s)  <span class="comment"># 获取迭代器</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)  <span class="comment"># 获取下一个单词</span></span><br><span class="line"><span class="string">'A'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)</span><br><span class="line"><span class="string">'B'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)  <span class="comment"># 迭代到头</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(it)  <span class="comment"># 迭代器空了</span></span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(iter(s))  <span class="comment"># 重新构建迭代器</span></span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'B'</span>]</span><br></pre></td></tr></table></figure><h1 id="sentence类第2版典型的迭代器">Sentence类第2版：典型的迭代器</h1><figure class="highlight python"><figcaption><span>sentence_iter.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span>  <span class="comment"># 使用迭代器模式实现Sentence类</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">        self.words = RW_WORD.findall(text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Sentence(%s)'</span> % reprlib.repr(self.text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span>  <span class="comment"># 实例化并返回一个迭代器</span></span><br><span class="line">        <span class="keyword">return</span> SentenceIterator(self.words)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SentenceIterator</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        self.words = words  <span class="comment"># 引用单词列表</span></span><br><span class="line">        self.index = <span class="number">0</span>  <span class="comment"># 下一个要获取的单词</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            word = self.words[index]  <span class="comment"># 获取索引位上的单词</span></span><br><span class="line">        <span class="keyword">except</span> IndexError:  <span class="comment"># 如果索引位上没有单词</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration()  <span class="comment"># 抛出StopIteration异常</span></span><br><span class="line">        self.index += <span class="number">1</span>  <span class="comment"># 递增索引</span></span><br><span class="line">        <span class="keyword">return</span> word  <span class="comment"># 返回单词</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span>  <span class="comment"># 迭代器应该一直可以迭代</span></span><br><span class="line">        <span class="keyword">return</span> self  <span class="comment"># 因此__iter__方法应该返回自身</span></span><br></pre></td></tr></table></figure><p>对这个示例来说，其实没必要在SentenceIterator类中实现<code>__iter__</code>方法，不过这么做是对的，因为迭代器应该实现<code>__next__</code>和<code>__iter__</code>两个方法，而且这么做能让迭代器通过<code>issubclass(SentenceIterator, abc.Iterator)</code>测试。如果让SentenceIterator类继承abc.Iterator类，那么它会继承<code>abc.Iterator.__iter__</code>这个具体方法。</p><h2 id="把sentence编程迭代器坏主意">把Sentence编程迭代器：坏主意</h2><p>构建可迭代的对象和迭代器时经常会出现错误，原因是混淆了二者。可迭代的对象有个<code>__iter__</code>方法，每次都实例化一个新的迭代器；而迭代器要实现<code>__next__</code>方法，返回单个元素，此外还要实现<code>__iter__</code>方法，返回迭代器本身。</p><p>除了<code>__iter__</code>方法之外，你可能还想在Sentence类中实现<code>__next__</code>方法，让Sentence实例既是可迭代的对象，也是自身的迭代器。可是，这种想法非常糟糕。</p><p>迭代器模式可用来：（出自《设计模式：可复用面向对象软件的基础》）</p><ul><li>访问一个聚合对象的内容而无需暴露它的内部表示</li><li>支持对聚合对象的多种遍历</li><li>为遍历不同的聚合结构提供一个同一的接口（既支持多态迭代）</li></ul><p>为了“支持多种遍历”，必须能从同一个可迭代的实例中获取多个独立的迭代器，而且各个迭代器要能维护自身的内部状态，因此这一模式正确的实现方式是，每次调用iter(my_iterable)都构建一个独立的迭代器。</p><h1 id="sentence类第3版生成器函数">Sentence类第3版：生成器函数</h1><p>用生成器函数代替SentenceIterator类。</p><figure class="highlight python"><figcaption><span>sentence_gen.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">        self.words = RE_WORD.findall(text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Sentence(%s)'</span> % reprlib.repr(self.text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> self.words:</span><br><span class="line">            <span class="keyword">yield</span> word  <span class="comment"># 产出当前的word</span></span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><code>__iter__</code>方法的return语句不是必要的；这个函数可以直接“落空”，自动返回。不管有没有return语句，生成器函数都不会抛出StopIteration异常，而是在生成完全部值之后直接退出。</p><h2 id="生成器函数的工作原理">生成器函数的工作原理</h2><p>只要Python函数的定义体中有yield关键字，该函数就是生成器函数。调用生成器函数时，会返回一个生成器对象。也就是说，生成器函数是生成器工厂。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span>  <span class="comment"># 只要包含关键字yield，该函数就是生成器函数</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'start'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">1</span>  <span class="comment"># 生成器函数的定义体中通常都有循环</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'continue'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">2</span>  <span class="comment"># 不过这不是必要条件</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'end'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen  <span class="comment"># 函数对象</span></span><br><span class="line">&lt;function gen at <span class="number">0x10094ec80</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen()  <span class="comment"># 调用时返回一个生成器对象</span></span><br><span class="line">&lt;generator object gen at <span class="number">0x10094dba0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> gen():</span><br><span class="line"><span class="meta">... </span>    print(i)</span><br><span class="line">...</span><br><span class="line">start</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">end</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = gen()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)  <span class="comment"># 第一次调用，会打印'start'，然后停在第一个yield语句</span></span><br><span class="line">start</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)  <span class="comment"># 第二次调用，打印'continue'，停在第二个yield语句</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)  <span class="comment"># 第三次调用，打印'end'，到达定义体末尾，抛出异常</span></span><br><span class="line">end</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><h1 id="sentence类第4版惰性实现">Sentence类第4版：惰性实现</h1><p>惰性求值（lazy evaluation）和及早求值（eager evaluation）是编程语言理论方面的技术用语。</p><p>目前实现的几版Sentence类都不够惰性，因为<code>__init__</code>方法急迫地构建好了文本中的单词列表，然后将其绑定到self.words属性上。这样就得处理整个文本，列表使用的内存量可能与文本本身一样多（获取更多，这取决于文本中有多少非单词字符）。如果只需迭代前几个单词，大多数工作都是白费力气。</p><p>只要使用Python3，思索着做某件事有没有懒惰的方式，答案通常都是肯定的。re.finditer函数是re.findall函数的惰性版本，返回一个生成器，按需生成re.MatchObject实例。如果有很多匹配，re.finditer函数能节省大量内存。</p><figure class="highlight python"><figcaption><span>sentence_gen2.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Sentence(%s)'</span> % reprlib.repr(self.text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> match <span class="keyword">in</span> RE_WORD.finditer(self.text):</span><br><span class="line">            <span class="keyword">yield</span> match.group()  <span class="comment"># 提取具体文本</span></span><br></pre></td></tr></table></figure><h1 id="sentence类第5版生成器表达式">Sentence类第5版：生成器表达式</h1><p>生成器表达式可以理解为列表推导的惰性版本：不会迫切地构建列表，而是返回一个生成器，按需惰性生成元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'yield 1'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'yield 2'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res1 = [x * <span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> gen()]  <span class="comment"># 列表推导</span></span><br><span class="line"><span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">yield</span> <span class="number">2</span>  <span class="comment"># gen函数全部运行</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res1</span><br><span class="line">[<span class="number">3</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res2 = (x * <span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> gen())  <span class="comment"># 生成器，gen函数没有运行，故没有任何输出</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res2</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x10094daf0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> res2:  <span class="comment"># 循环迭代res2时，gen函数才会真正执行</span></span><br><span class="line"><span class="meta">... </span>    print(i)</span><br><span class="line">...</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="keyword">yield</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>sentence_genexp.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Sentence(%s)'</span> % reprlib.repr(self.text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (match.group() <span class="keyword">for</span> match <span class="keyword">in</span> RE_WORD.finditer(self.text))</span><br></pre></td></tr></table></figure><p><code>__iter__</code>不是生成器函数了（没有yield），而是使用生成器表达式构建生成器，然后将其返回。不过，最终的效果一样：调用<code>__iter__</code>方法会得到一个生成器对象。生成器表达式是语法糖：完全可以替换成生成器函数，不过有时使用生成器表达式更便利。</p><h1 id="何时使用生成器表达式">何时使用生成器表达式</h1><p>生成器表达式是创建生成器的简洁句法，这样无需先定义函数再调用。不过生成器函数灵活得多，可以使用多个语句实现复杂的逻辑，也可以作为协程使用。</p><p>遇到简单的情况时，可以使用生成器表达式，因为这样扫一眼就知道代码的作用；如果生成器表达式要分成多行写，倾向于定义生成器函数，以便提高可读性。此外，生成器函数有名称，因此可以重用。</p><h1 id="另一个示例等差数列生成器">另一个示例：等差数列生成器</h1><p>典型的迭代器模式作用很简单——遍历数据结构。不过，即便不是从集合中获取元素，而是获取序列中即时生成的下一个值时，也用得到这种基于方法的标准接口。例如，内置的range函数用于生成有穷整数等差数列（Arithmetic Progression，AP），itertools.count函数用于生成无穷等差数列。</p><figure class="highlight python"><figcaption><span>arithmetic_progression.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArithmeticProgression</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, begin, step, end=None)</span>:</span></span><br><span class="line">        self.begin = begin</span><br><span class="line">        self.step = step</span><br><span class="line">        self.end = end  <span class="comment"># None -&gt; 无穷数列</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        result = type(self.begin + self.step)(self.begin)  <span class="comment"># 强制转换类型</span></span><br><span class="line">        forever = self.end <span class="keyword">is</span> <span class="literal">None</span>  <span class="comment"># 提高可读性</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> forever <span class="keyword">or</span> result &lt; self.end:</span><br><span class="line">            <span class="keyword">yield</span> result</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">            result = self.begin + self.step * index  <span class="comment"># 没有累加，为了降低处理浮点数时累积效应致错的风险</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> arithmetic_progression <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ap = ArithmeticProgression(<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>)  <span class="comment"># 整型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(ap)</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ap = ArithmeticProgression(<span class="number">1</span>, <span class="number">.5</span>, <span class="number">3</span>)  <span class="comment"># 浮点型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(ap)</span><br><span class="line">[<span class="number">1.0</span>, <span class="number">1.5</span>, <span class="number">2.0</span>, <span class="number">2.5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ap = ArithmeticProgression(<span class="number">0</span>, <span class="number">1</span>/<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(ap)</span><br><span class="line">[<span class="number">0.0</span>, <span class="number">0.3333333333333333</span>, <span class="number">0.6666666666666666</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ap = ArithmeticProgression(<span class="number">0</span>, Fraction(<span class="number">1</span>, <span class="number">3</span>), <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(ap)</span><br><span class="line">[Fraction(<span class="number">0</span>, <span class="number">1</span>), Fraction(<span class="number">1</span>, <span class="number">3</span>), Fraction(<span class="number">2</span>, <span class="number">3</span>)]  <span class="comment"># 第一个数被转换成了Fraction类型</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ap = ArithmeticProgression(<span class="number">0</span>, Decimal(<span class="string">'.1'</span>), <span class="number">.3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(ap)</span><br><span class="line">[Decimal(<span class="string">'0'</span>), Decimal(<span class="string">'0.1'</span>), Decimal(<span class="string">'0.2'</span>)]</span><br></pre></td></tr></table></figure><p>这个简单的示例，说明了如何使用生成器函数实现特殊的<code>__iter__</code>方法。然而，如果一个类只是为了构建生成器而去实现<code>__iter__</code>方法，那还不如使用生成器函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aritprog_gen</span><span class="params">(begin, step, end=None)</span>:</span></span><br><span class="line">    result = type(self.begin + self.step)(self.begin)</span><br><span class="line">    forever = self.end <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> forever <span class="keyword">or</span> result &lt; self.end:</span><br><span class="line">        <span class="keyword">yield</span> result</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">        result = self.begin + self.step * index</span><br></pre></td></tr></table></figure><h2 id="使用itertools模块生成等差数列">使用itertools模块生成等差数列</h2><p>Python3.4中的<a href="https://devdocs.io/python~3.6/library/itertools" target="_blank" rel="noopener">itertools</a>模块提供了19个生成器函数，结合起来使用能实现很多有趣的用法。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/itertools#itertools.count" target="_blank" rel="noopener"><code>itertools.count(start=0, step=1)</code></a></p><p>Make an iterator that returns evenly spaced values starting with number start. Often used as an argument to map() to generate consecutive data points. Also, used with zip() to add sequence numbers. Roughly equivalent to:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(start=<span class="number">0</span>, step=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="comment"># count(10) --&gt; 10 11 12 13 14 ...</span></span><br><span class="line">    <span class="comment"># count(2.5, 0.5) -&gt; 2.5 3.0 3.5 ...</span></span><br><span class="line">    n = start</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        n += step</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>When counting with floating point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: <code>(start + step * i for i in count())</code>.</p></blockquote><p>itertools.count函数返回的生成器能生成等差数列。然而，itertools.count函数从不停止。因此，如果调用list(count())，Python会创建一个特别大的列表，超出可用内存，在调用失败之前，电脑会疯狂地运转。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/itertools#itertools.takewhile" target="_blank" rel="noopener"><code>itertools.takewhile(predicate, iterable)</code></a></p><p>Make an iterator that returns elements from the iterable as long as the predicate is true. Roughly equivalent to:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">takewhile</span><span class="params">(predicate, iterable)</span>:</span></span><br><span class="line">    <span class="comment"># takewhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 1 4</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">if</span> predicate(x):</span><br><span class="line">            <span class="keyword">yield</span> x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure></blockquote><p>itertools.takewhile函数则不同，它会生成一个使用另一个生成器的生成器，在指定的条件计算结果为false时停止。因此，可以把这两个函数结合在一起使用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> itertools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen = itertools.takewhile(<span class="keyword">lambda</span> n: n &lt; <span class="number">3</span>, itertools.count(<span class="number">1</span>, <span class="number">.5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(gen)</span><br><span class="line">[<span class="number">1</span>, <span class="number">1.5</span>, <span class="number">2.0</span>, <span class="number">2.5</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aritprog_gen</span><span class="params">(begin, step, end=None)</span>:</span>  <span class="comment"># 利用已有的生成器实现</span></span><br><span class="line">    first = type(begin + step)(begin)</span><br><span class="line">    ap_gen = itertools.count(first, step)</span><br><span class="line">    <span class="keyword">if</span> end <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        ap_gen = itertools.takewhile(<span class="keyword">lambda</span> n: n &lt; end, ap_gen)</span><br><span class="line">    <span class="keyword">return</span> ap_gen</span><br></pre></td></tr></table></figure><h1 id="python3.3中新出现的句法yield-from">Python3.3中新出现的句法：yield from</h1><p>如果生成器函数需要产出另一个生成器生成的值，传统的解决方法是使用嵌套的for循环。例如，chain生成器的等价实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chain</span><span class="params">(*iterables)</span>:</span></span><br><span class="line">    <span class="comment"># chain('ABC', 'DEF') --&gt; A B C D E F</span></span><br><span class="line">    <span class="keyword">for</span> it <span class="keyword">in</span> iterables:</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> it:  <span class="comment"># 使用循环</span></span><br><span class="line">            <span class="keyword">yield</span> element</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chain</span><span class="params">(*iterables)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> it <span class="keyword">in</span> iterables:</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> it  <span class="comment"># 使用yield from</span></span><br></pre></td></tr></table></figure><p>在这个示例中使用yield from是对的，而且代码读起来更顺畅，不过感觉更像是语法糖。除了代替循环之外，yield from还会创建通道，把内层生成器直接与外层生成器的客户端联系起来。把生成器当成协程使用时，这个通道特别重要，不仅能为客户端代码生成值，还能使用客户端提供的值。</p><h1 id="深入分析iter函数">深入分析iter函数</h1><p>在Python中迭代对象x时会调用iter(x)。可是，iter函数还有一个鲜为人知的用法：传入两个参数，使用常规的函数或任何可调用的对象创建迭代器。这样使用时，第一个参数必须是可调用的对象，用于不断调用（没有参数），产出各个值。第二个值是哨符，这是个标记值，当可调用的对象返回这个值时，触发迭代器抛出StopIteration异常，而不产出哨符。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/functions#iter" target="_blank" rel="noopener"><code>iter(object[, sentinel])</code></a></p><p>Return an iterator object. The first argument is interpreted very differently depending on the presence of the second argument. Without a second argument, object must be a collection object which supports the iteration protocol (the <code>__iter__()</code> method), or it must support the sequence protocol (the <code>__getitem__()</code> method with integer arguments starting at 0). If it does not support either of those protocols, TypeError is raised. If the second argument, sentinel, is given, then object must be a callable object. The iterator created in this case will call object with no arguments for each call to its <code>__next__()</code> method; if the value returned is equal to sentinel, StopIteration will be raised, otherwise the value will be returned.</p><p>One useful application of the second form of iter() is to read lines of a file until a certain line is reached. The following example reads a file until the readline() method returns an empty string:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'mydata.txt'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> iter(fp.readline, <span class="string">''</span>):  <span class="comment"># 逐行读取文件，直到遇到空行或者到达文件末尾</span></span><br><span class="line">        process_line(line)</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">d6</span><span class="params">()</span>:</span>  <span class="comment"># 掷骰子</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> randint(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d6_iter = iter(d6, <span class="number">1</span>)  <span class="comment"># 掷到1为止，但不会产出1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d6_iter  <span class="comment"># 返回的是一个callable_iterator对象</span></span><br><span class="line">&lt;callable_iterator object at <span class="number">0x101472e10</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> roll <span class="keyword">in</span> d6_iter:</span><br><span class="line"><span class="meta">... </span>    print(roll)</span><br><span class="line">...</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(d6_iter)  <span class="comment"># 与常规迭代器一样，一旦耗尽就没用了，想重新开始，必须再次创建</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> generators </tag>
            
            <tag> iterables </tag>
            
            <tag> iterators </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符重载</title>
      <link href="/notes/fluent-python/operator-overloading/"/>
      <url>/notes/fluent-python/operator-overloading/</url>
      
        <content type="html"><![CDATA[<h1 id="运算符重载基础">运算符重载基础</h1><p>在某些圈子中，运算符重载的名声并不好。这个语言特性可能（已经）被滥用，让程序员困惑，导致缺陷和意料之外的性能瓶颈。但是，如果使用得到，API会变得好用，代码变得易于阅读。Python施加了一些限制，做好了灵活性、可用性和安全性方面的平衡：</p><ul><li>不能重载内置类型的运算符</li><li>不能新建运算符，只能重载现有的</li><li>某些运算符不能重载——is、and、or和not（不过位运算符&amp;、｜和～可以）</li></ul><p>在Vector类中重载运算符，并修复==运算符可能出现的错误。</p><figure class="highlight python"><figcaption><span>vector.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    typecode = <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, components)</span>:</span></span><br><span class="line">        self._components = array(self.typecode, components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span>  <span class="comment"># 支持 == 中缀运算符，但是有错误</span></span><br><span class="line">        <span class="keyword">return</span> tuple(self) == tuple(other)  <span class="comment"># Vector([3, 4]) == (3, 4)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> math.sqrt(sum(x * x <span class="keyword">for</span> x <span class="keyword">in</span> self))</span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="一元运算符">一元运算符</h1><p><code>- (__neg__)</code>：一元取负算术运算符。如果x是-2，那么-x == 2。</p><p><code>+ (__pos__)</code>：一元取正算术运算符。通常，x == -x，但是也有例外。</p><p><code>~ (__invert__)</code>：对整数按位取反，定义为~x == -(x+1)。如果x是2，那么~x == -3。</p><p>Python语言参考手册还把内置的<code>abs(...)</code>函数列为一元运算符。它对应的特殊方法是<code>__abs__</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在Vector类中定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span>  <span class="comment"># 返回标量</span></span><br><span class="line">    <span class="keyword">return</span> math.sqrt(sum(x * x <span class="keyword">for</span> x <span class="keyword">in</span> self))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__neg__</span><span class="params">(self)</span>:</span>  <span class="comment"># 返回同属一类的实例</span></span><br><span class="line">    <span class="keyword">return</span> Vector(-x <span class="keyword">for</span> x <span class="keyword">in</span> self)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__pos__</span><span class="params">(self)</span>:</span>  <span class="comment"># 返回self的副本</span></span><br><span class="line">    <span class="keyword">return</span> Vector(self)</span><br></pre></td></tr></table></figure><p>我们不打算实现<code>__invert__</code>方法，因此如果用户在Vector实例上尝试计算~v，Python会抛出TypeError，而且输出明确的错误消息，&quot;bad operand type for unary ~: 'Vector'&quot;。</p><h2 id="x-和-x-何时不相等">x 和 +x 何时不相等</h2><p>第一例与decimal.Decimal类有关。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> decimal</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ctx = decimal.getcontext()  <span class="comment"># 当前上下文</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ctx.prec = <span class="number">40</span>  <span class="comment"># 精度设为40</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one_third = decimal.Decimal(<span class="string">'1'</span>) / decimal.Decimal(<span class="string">'3'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one_third</span><br><span class="line">Decimal(<span class="string">'0.3333333333333333333333333333333333333333'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one_third == +one_third</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ctx.prec = <span class="number">28</span>  <span class="comment"># 改变精度</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one_third == +one_third</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>+one_third  <span class="comment"># +one_third的精度与one_third的精度不一样</span></span><br><span class="line">Decimal(<span class="string">'0.3333333333333333333333333333'</span>)</span><br></pre></td></tr></table></figure><p>第二例与collections.Counter类有关。</p><p>Counter类实现了几个算术运算符，例如中缀运算符+，作用是把两个Counter实例的计数器加在一起。然而，从实用角度出发，Counter相加时，负值和零值计数会从结果中剔除。而一元运算符+等同于加上一个空Counter，因此它产生一个新的Counter且保留大于零的计数器。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct = Counter(<span class="string">'abracadabra'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct[<span class="string">'r'</span>] = <span class="number">-3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct[<span class="string">'d'</span>] = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct</span><br><span class="line">Counter(&#123;<span class="string">'a'</span>: <span class="number">5</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">1</span>, <span class="string">'d'</span>: <span class="number">0</span>, <span class="string">'r'</span>: <span class="number">-3</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>+ct</span><br><span class="line">Counter(&#123;<span class="string">'a'</span>: <span class="number">5</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct == +ct</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="重载向量加法运算符">重载向量加法运算符</h1><p>序列应该支持<code>+</code>运算符（用于拼接），以及<code>*</code>运算符（用于重复复制）。然而，对Vector类型来说，使用向量数学运算实现<code>+</code>和<code>*</code>运算符更有意义。</p><p>如果尝试把两个不同长度Vector实例加在一起会怎样？此时可以抛出错误，但是根据实际运行情况（例如信息检索），最好使用零填充较短的那个向量。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> vector <span class="keyword">import</span> Vector</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v2 = Vector([<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + v2</span><br><span class="line">Vector([<span class="number">9.0</span>, <span class="number">11.0</span>, <span class="number">13.0</span>])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v3 = Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + v3</span><br><span class="line">Vector([<span class="number">4.0</span>, <span class="number">6.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>])</span><br></pre></td></tr></table></figure><p>确定基本要求后，<code>__add__</code>方法的实现如下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在Vector类中定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    pairs = itertools.zip_longest(self, other, fillvalue=<span class="number">0.0</span>)</span><br><span class="line">    <span class="keyword">return</span> Vector(a + b <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs)</span><br></pre></td></tr></table></figure><p><strong>实现一元运算符和中缀运算符的特殊方法一定不能修改操作数。使用这些运算符的表达式期待结果是新对象。只有增量赋值表达式可能会修改第一个操作数（self）。</strong></p><p>上述的<code>__add__</code>方法也支持Vector之外的对象。这是因为<code>__add__</code>使用了zip_longest，它能处理任何可迭代对象，而且构造新Vector实例的生成器表达式仅仅是把zip_longest生成的值对相加，因此可以使用任何生成数字元素的可迭代对象。然而，如果对调操作数，混合类型的加法就会失败。</p><p>为了支持涉及不同类型的运算，Python为中缀运算符特殊方法提供了特殊的分派机制。对表达式 a + b 来说，解释器会执行以下几步操作。</p><ol type="1"><li><p>如果a有<code>__add__</code>方法，而且返回值不是NotImplemented，调用<code>a.__add__(b)</code>，然后返回结果。</p></li><li><p>如果a没有<code>__add__</code>方法，或者调用<code>__add__</code>方法返回NotImplemented，检查b有没有<code>__radd__</code>方法（<code>__add__</code>的“反向”reversed版本），如果有，而且没有返回NotImplemented，调用<code>b.__radd__(a)</code>，然后返回结果。</p></li><li><p>如果b没有<code>__radd__</code>方法，或者调用<code>__radd__</code>方法返回NotImplemented，抛出TypeError，并在错误消息中指明操作类型不支持。</p></li></ol><img src="http://www.plantuml.com/plantuml/svg/bP2zJiCm58NtFCLLfoBK3XaPkZ6mCB57Dhb09F8ZnnswC24XaA11G8jeLRPE20O6H47gqzZfnYlWsB4980Q695V7dyyzEGTHY81nnWSGOhxBeen7QUBbd7245e5re2qWEKH9rkTEbjFJeo0WOHW4SlGgdsz4CVvulpVa7h7Swk9534UaQzasNIllZiktApcRQdOVEQ6MDhgyVTfE-LQS7MAC2SUmOPsaF587pdvvBIQpXXr3tcSkF3KfsLynwVUOjElWDlcTan9Fls43nF1S59UhPL4-Zik7-R_p-_Q6F9k8ayNE8CDDnbAc6QmcJzSDdPvkKprcfDNoOcu5tPwIr4hFp4gq7TLVwBYR5URKNbsMSwIre_x32jMIqdIW6ZFdNrjyQ-X3Wsmiydzk-WG0"><p><strong>别把NotImplemented和NotImplementedError搞混了。前者是特殊的单例值，如果中缀运算符特殊方法不能处理给定的操作数，那么要把它返回（return）给解释器。而NotImplementedError是一种异常，抽象类中占位方法把它抛出（raise），提醒子类必须覆盖。</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在Vector类中定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    pairs = itertools.zip_longest(self, other, fillvalue=<span class="number">0.0</span>)</span><br><span class="line">    <span class="keyword">return</span> Vector(a + b <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__radd__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self + other  <span class="comment"># 直接委托__add__，处理数字和向量时，+可以交换，但是拼接序列时不行。</span></span><br></pre></td></tr></table></figure><p><strong>一般来说，如果中缀运算符的正向方法只处理与self属于同一类型的操作数，那就无需实现对应的反向方法，因为按照定义，反向方法是为了处理类型不同的操作数。</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> vector <span class="keyword">import</span> Vector</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + (<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">Vector([<span class="number">5.0</span>, <span class="number">5.0</span>, <span class="number">5.0</span>])  <span class="comment"># __add__方法可以处理任何具有数值元素的可迭代对象</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + <span class="number">1</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"/Users/cws/Desktop/vector.py"</span>, line <span class="number">49</span>, <span class="keyword">in</span> __add__</span><br><span class="line">    pairs = itertools.zip_longest(self, other, fillvalue=<span class="number">0.0</span>)</span><br><span class="line">TypeError: zip_longest argument <span class="comment">#2 must support iteration  # 错误消息明确</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + <span class="string">'abc'</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"/Users/cws/Desktop/vector.py"</span>, line <span class="number">50</span>, <span class="keyword">in</span> __add__</span><br><span class="line">    <span class="keyword">return</span> Vector(a + b <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs)</span><br><span class="line">  File <span class="string">"/Users/cws/Desktop/vector.py"</span>, line <span class="number">11</span>, <span class="keyword">in</span> __init__</span><br><span class="line">    self._components = array(self.typecode, components)</span><br><span class="line">  File <span class="string">"/Users/cws/Desktop/vector.py"</span>, line <span class="number">50</span>, <span class="keyword">in</span> &lt;genexpr&gt;</span><br><span class="line">    <span class="keyword">return</span> Vector(a + b <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs)</span><br><span class="line">TypeError: unsupported operand type(s) <span class="keyword">for</span> +: <span class="string">'float'</span> <span class="keyword">and</span> <span class="string">'str'</span>  <span class="comment"># 问题严重</span></span><br></pre></td></tr></table></figure><p>v1 + 'abc'是无法计算的：如果由于类型不兼容而导致运算符特殊方法无法返回有效的结果，那么应该返回NotImplemented。如果抛出异常，就终止了运算符分派机制。对TypeError来说，通常最好将其捕获，然后返回NotImplemented。这样，解释器会尝试调用反向运算符方法，如果操作数是不同的类型，对调之后，反向运算符方法可能会正确计算。</p><p>为了遵守鸭子类型精神，我们不能测试other操作数的类型，或者它的元素的类型。我们要捕获异常，然后返回NotImplemented。如果解释器还未反转操作数，那么它将尝试去做。如果反方向方法返回NotImplemented，那么Python会抛出TypeError，并返回一个标准的错误消息。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在Vector类中定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span>  <span class="comment"># 最终版本</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pairs = itertools.zip_longest(self, other, fillvalue=<span class="number">0.0</span>)</span><br><span class="line">        <span class="keyword">return</span> Vector(a + b <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs)</span><br><span class="line">    <span class="keyword">except</span> TypeError:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br></pre></td></tr></table></figure><h1 id="重载标量乘法运算符">重载标量乘法运算符<code>*</code></h1><p>标量积（scalar product）：<code>Vector([1, 2, 3]) * x</code>，x是数字，结果是一个新Vector实例，各个分量都会乘以x。这也叫元素级乘法（elementwise multiplication）。</p><p>向量点积（dot product）：矩阵乘法。NumPy等库目前的做法是，不重载这两种意义的<code>*</code>，只用<code>*</code>计算标量积。例如，在NumPy中，点积使用<code>numpy.dot()</code>函数计算。</p><p><em>从Python3.5起，<code>@</code>记号可以用作中缀点积运算符。</em></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在Vector类中定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, scalar)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Vector(n * scalar <span class="keyword">for</span> n <span class="keyword">in</span> self)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__rmul__</span><span class="params">(self, scalar)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self * scalar</span><br></pre></td></tr></table></figure><p>这两个方法确实可用，但是提供不兼容的操作数时会出问题。scalar参数的值要是数字，与浮点数相乘得到的积是另一个浮点数。因此，不能使用复数，但可以是int、bool（int的子类），甚至fractions.Fraction实例等标量。</p><p>我们可以采用鸭子类型技术，在<code>__mul__</code>方法中捕获TypeError。但是，这个问题有个更易于理解的方式，而且也更合理：白鹅类型。我们将使用isinstance()检查scalar的类型，但是不硬编码具体的类型，而是检查numbers.Real抽象基类。这个抽象基类涵盖了我们所需的全部类型，而且还支持以后声明为numbers.Real抽象基类的真实子类或虚拟子类的数值类型。（decimal.Decimal没有把自己注册为numbers.Real的虚拟子类。因此，Vector类不会处理decimal.Decimal数字）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numbers</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在类中定义</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, scalar)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(scalar, numbers.Real):  <span class="comment"># 显示检查抽象类型</span></span><br><span class="line">            <span class="keyword">return</span> Vector(n * scalar <span class="keyword">for</span> n <span class="keyword">in</span> self)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NotImplemented</span>  <span class="comment"># 返回NotImplemented，让Python尝试在scalar操作数上调用__rmul__方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__rmul__</span><span class="params">(self, scalar)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self * scalar</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__matmul__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> sum(a * b <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(self, other))</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__rmatmul__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self @ other  <span class="comment"># 委托</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> vector <span class="keyword">import</span> Vector</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 * <span class="number">11</span></span><br><span class="line">Vector([<span class="number">11.0</span>, <span class="number">22.0</span>, <span class="number">33.0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">11</span> * v1</span><br><span class="line">Vector([<span class="number">11.0</span>, <span class="number">22.0</span>, <span class="number">33.0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 * <span class="literal">True</span></span><br><span class="line">Vector([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 * Fraction(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">Vector([<span class="number">0.3333333333333333</span>, <span class="number">0.6666666666666666</span>, <span class="number">1.0</span>])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>va = Vector([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vz = Vector([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>va @ vz</span><br><span class="line"><span class="number">38.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>] @ vz  <span class="comment"># 反向调用成功</span></span><br><span class="line"><span class="number">380.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>va @ <span class="number">3</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unsupported operand type(s) <span class="keyword">for</span> @: <span class="string">'Vector'</span> <span class="keyword">and</span> <span class="string">'int'</span></span><br></pre></td></tr></table></figure><h1 id="中缀运算符方法的名称">中缀运算符方法的名称</h1><table><thead><tr class="header"><th>运算符</th><th>正向方法</th><th>反向方法</th><th>就地（in-place）方法</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>+</code></td><td><code>__add__</code></td><td><code>__radd__</code></td><td><code>__iadd__</code></td><td>加法或拼接</td></tr><tr class="even"><td><code>-</code></td><td><code>__sub__</code></td><td><code>__rsub__</code></td><td><code>__isub__</code></td><td>减法</td></tr><tr class="odd"><td><code>*</code></td><td><code>__mul__</code></td><td><code>__rmul__</code></td><td><code>__imul__</code></td><td>乘法或重复复制</td></tr><tr class="even"><td><code>/</code></td><td><code>__truediv__</code></td><td><code>__rtruediv__</code></td><td><code>__itruediv__</code></td><td>除法</td></tr><tr class="odd"><td><code>//</code></td><td><code>__floordiv__</code></td><td><code>__rfloordiv__</code></td><td><code>__ifloordiv__</code></td><td>整除</td></tr><tr class="even"><td><code>%</code></td><td><code>__mod__</code></td><td><code>__rmod__</code></td><td><code>__imod__</code></td><td>取模</td></tr><tr class="odd"><td><code>divmod()</code></td><td><code>__divmod__</code></td><td><code>__rdivmod__</code></td><td><code>__idivmod__</code></td><td>返回由整除的商和模数组成的元组</td></tr><tr class="even"><td><code>**, pow()</code></td><td><code>__pow__</code></td><td><code>__rpow__</code></td><td><code>__ipow__</code></td><td>取幂</td></tr><tr class="odd"><td><code>@</code></td><td><code>__matmul__</code></td><td><code>__rmatmul__</code></td><td><code>__imatmul__</code></td><td>矩阵乘法</td></tr><tr class="even"><td><code>&amp;</code></td><td><code>__and__</code></td><td><code>__rand__</code></td><td><code>__iand__</code></td><td>位与</td></tr><tr class="odd"><td><code>|</code></td><td><code>__or__</code></td><td><code>__ror__</code></td><td><code>__ior__</code></td><td>位或</td></tr><tr class="even"><td><code>^</code></td><td><code>__xor__</code></td><td><code>__rxor__</code></td><td><code>__ixor__</code></td><td>位异或</td></tr><tr class="odd"><td><code>&lt;&lt;</code></td><td><code>__lshift__</code></td><td><code>__rlshift__</code></td><td><code>__ilshift__</code></td><td>按位左移</td></tr><tr class="even"><td><code>&gt;&gt;</code></td><td><code>__rshift__</code></td><td><code>__rrshift__</code></td><td><code>__irshift</code></td><td>按位右移</td></tr></tbody></table><h1 id="众多比较运算符">众多比较运算符</h1><p>Python解释器对众多比较运算符的处理与前文类似，不过在两个方面有重大区别。</p><ul><li>正向和反向调用使用的是同一系列方法。</li><li>对<code>==</code>和<code>!=</code>来说，如果反向调用失败，Python会比较对象的ID，而不抛出TypeError。</li></ul><table><thead><tr class="header"><th>分组</th><th>中缀运算符</th><th>正向方法调用</th><th>反向方法调用</th><th>后备机制</th></tr></thead><tbody><tr class="odd"><td>相等性</td><td><code>a == b</code></td><td><code>a.__eq__(b)</code></td><td><code>b.__eq__(a)</code></td><td>返回<code>id(a) == id(b)</code></td></tr><tr class="even"><td></td><td><code>a != b</code></td><td><code>a.__ne__(b)</code></td><td><code>b.__ne__(a)</code></td><td>返回<code>not (a == b)</code></td></tr><tr class="odd"><td>排序</td><td><code>a &gt; b</code></td><td><code>a.__gt__(b)</code></td><td><code>b.__lt__(a)</code></td><td>抛出<code>TypeError</code></td></tr><tr class="even"><td></td><td><code>a &lt; b</code></td><td><code>a.__lt__(b)</code></td><td><code>b.__gt__(a)</code></td><td>抛出<code>TypeError</code></td></tr><tr class="odd"><td></td><td><code>a &gt;= b</code></td><td><code>a.__ge__(b)</code></td><td><code>b.__le__(a)</code></td><td>抛出<code>TypeError</code></td></tr><tr class="even"><td></td><td><code>a &lt;= b</code></td><td><code>a.__le__(b)</code></td><td><code>b.__ge__(a)</code></td><td>抛出<code>TypeError</code></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在Vector类中定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (len(self) == len(other) <span class="keyword">and</span>    <span class="comment"># 等价于 tuple(self) == tuple(other)</span></span><br><span class="line">            all(a == b <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(self, other)))  <span class="comment"># 但是明显此法更高效</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> vector <span class="keyword">import</span> Vector</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>va = Vector([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vb = Vector(range(<span class="number">1</span>, <span class="number">4</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>va == vb</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>va == (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>va == (1, 2, 3)的结果不是很理想，对操作数过度宽容可能导致令人惊讶的结果，而程序员讨厌惊喜。从Python自身来找线索，我们发现[1,2] == (1,2)的结果是False，因此，我们要保守一点，做些类型检查。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在Vector类中定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(other, Vector):</span><br><span class="line">        <span class="keyword">return</span> (len(self) == len(other) <span class="keyword">and</span></span><br><span class="line">                all(a ==b <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(self, other)))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span>  <span class="comment"># 让Python编辑器处理</span></span><br></pre></td></tr></table></figure><p>我们不用实现<code>__ne__</code>方法，因为从object继承的<code>__ne__</code>方法的后备行为满足了我们的需求。从object中继承的<code>__ne__</code>方法，运作方式与下述代码类似，不过原版是用C语言实现的：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__ne__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    eq_result = self == other</span><br><span class="line">    <span class="keyword">if</span> eq_result <span class="keyword">is</span> <span class="built_in">NotImplemented</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> eq_result</span><br></pre></td></tr></table></figure><h1 id="增量赋值运算符">增量赋值运算符</h1><p>Vector类已经支持增量赋值运算符<code>+=</code>和<code>*=</code>了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> vector <span class="keyword">import</span> Vector</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1_alias = v1</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(v1)</span><br><span class="line"><span class="number">4358324120</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 += Vector([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(v1)  <span class="comment"># v1重新绑定了实例</span></span><br><span class="line"><span class="number">4359075992</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1</span><br><span class="line">Vector([<span class="number">5.0</span>, <span class="number">7.0</span>, <span class="number">9.0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1_alias  <span class="comment"># 原来的实例没有变</span></span><br><span class="line">Vector([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 *= <span class="number">2</span>  <span class="comment"># 增量乘法运算</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1</span><br><span class="line">Vector([<span class="number">10.0</span>, <span class="number">14.0</span>, <span class="number">18.0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(v1)</span><br><span class="line"><span class="number">4359074872</span></span><br></pre></td></tr></table></figure><p>如果一个类没有实现就地运算符，增量赋值运算只是语法糖：a += b的作用与a = a + b完全一样。对不可变类型来说，这是预期的行为，而且，如果定义了<code>__add__</code>方法的话，不用编写额外的代码，+=就能使用。</p><p>然而，如果实现了就地运算符方法，例如<code>__iadd__</code>方法，计算a += b的结果时会调用它。这种运算符的名称表明，它们会就地修改左操作数，而不会创建新的对象作为结果。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> overloading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承的优缺点</title>
      <link href="/notes/fluent-python/inheritance-for-good-or-for-worse/"/>
      <url>/notes/fluent-python/inheritance-for-good-or-for-worse/</url>
      
        <content type="html"><![CDATA[<h1 id="子类化内置类型很麻烦">子类化内置类型很麻烦</h1><p>在Python2.2之前，内置类型（如list或dict）不能子类化。在Python2.2之后，内置类型可以子类化了，但是有个重要的注意事项：<strong>内置类型（使用C语言编写）不会调用用户定义的类覆盖的特殊方法。</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">DoppelDict</span><span class="params">(dict)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line"><span class="meta">... </span>            super().__setitem__(key, [value] * <span class="number">2</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd = DoppelDict(one=<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd</span><br><span class="line">&#123;<span class="string">'one'</span>: <span class="number">1</span>&#125;  <span class="comment"># __init__方法没有调用覆盖的__setitem__方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd[<span class="string">'two'</span>] = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd</span><br><span class="line">&#123;<span class="string">'two'</span>: [<span class="number">2</span>, <span class="number">2</span>], <span class="string">'one'</span>: <span class="number">1</span>&#125;  <span class="comment"># []运算符调用了</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd.update(three=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd</span><br><span class="line">&#123;<span class="string">'three'</span>: <span class="number">3</span>, <span class="string">'two'</span>: [<span class="number">2</span>, <span class="number">2</span>], <span class="string">'one'</span>: <span class="number">1</span>&#125;  <span class="comment"># upate方法没调用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd.get(<span class="string">'three'</span>)  <span class="comment"># get方法没调用</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>原生类型的这种行为违背了面向对象编程的一个基本原则：<strong>始终应该从示例（self）所属的类开始搜索方法，即使在超类中调用也是如此。</strong>在这种糟糕的局面中，<code>__missing__</code>方法却能按预期方式工作，不过这只是特例。</p><a id="more"></a><p>不只是实例内部的调用有这个问题，内置类型的方法调用的其他类的方法，如果被覆盖了，也不会被调用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">AnswerDict</span><span class="params">(dict)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span> <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ad = AnswerDict(a=<span class="string">'foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ad[<span class="string">'a'</span>]  <span class="comment"># 实例内部</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.update(ad)  <span class="comment"># 内置dict类型读取AnswerDict实例的值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'a'</span>]  <span class="comment"># 没有调用覆盖的__getitem__方法</span></span><br><span class="line"><span class="string">'foo'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="string">'foo'</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>不要子类化内置类型，用户自己定义的类应该继承collections模块中的类，例如UserDict、UserList和UserString，这些类做了特殊设计，因此易于扩展。</strong></p><h1 id="多重继承和方法解析顺序">多重继承和方法解析顺序</h1><p>任何实现多重继承的语言都要处理潜在的命名冲突，这种冲突由不相关的祖先类实现同名方法引起。这种冲突称为“菱形问题”。</p><figure class="highlight python"><figcaption><span>diamond.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'A ping:'</span>, self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pong</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'B pong:'</span>, self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pong</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'C pong:'</span>, self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B, C)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().ping()</span><br><span class="line">        print(<span class="string">'D ping:'</span>, self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pingpong</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.ping()</span><br><span class="line">        super().ping()</span><br><span class="line">        self.pong()</span><br><span class="line">        super().pong()</span><br><span class="line">        C.pong(self)</span><br></pre></td></tr></table></figure><img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pYnApabDuSe0SL9p2qeg5N9JSvDIYxYISnABYnKS5Qgv582W83ClNKEJgnOgx0GJpaSHTiOkx89g28m9L-MeO5EZgwlW16BewIaummJ03BreeDjIKlDYzO0Ad20IBY06K2M8rhC3gdD6KUS2ueFL0G00"><p>说明“菱形问题”的UML类图。虚线箭头是该示例的方法解析顺序。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> diamond <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = D()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.pong()  <span class="comment"># 直接调用，按MRO搜索，运行的是B类中的版本</span></span><br><span class="line">B pong: &lt;diamond.D object at <span class="number">0x10d5d4e80</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.pong(d)  <span class="comment"># 调用指定超类中的方法，此时要把实例作为显式参数传入</span></span><br><span class="line">C pong: &lt;diamond.D object at <span class="number">0x10d5d4e80</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>D.__mro__  <span class="comment"># D类的__mro__属性</span></span><br><span class="line">(&lt;class 'diamond.D'&gt;, &lt;class 'diamond.B'&gt;, &lt;class 'diamond.C'&gt;, &lt;class 'diamond.A'&gt;, &lt;class 'object'&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.pingpong()</span><br><span class="line">A ping: &lt;diamond.D object at <span class="number">0x10d5d4e80</span>&gt;</span><br><span class="line">D ping: &lt;diamond.D object at <span class="number">0x10d5d4e80</span>&gt;  <span class="comment"># 前两行是self.ping()的结果</span></span><br><span class="line">A ping: &lt;diamond.D object at <span class="number">0x10d5d4e80</span>&gt;  <span class="comment"># super().ping()</span></span><br><span class="line">B pong: &lt;diamond.D object at <span class="number">0x10d5d4e80</span>&gt;  <span class="comment"># self.pong()</span></span><br><span class="line">B pong: &lt;diamond.D object at <span class="number">0x10d5d4e80</span>&gt;  <span class="comment"># super().pong()</span></span><br><span class="line">C pong: &lt;diamond.D object at <span class="number">0x10d5d4e80</span>&gt;  <span class="comment"># C.pong(d)</span></span><br></pre></td></tr></table></figure><p>Python能区分d.pong()调用的是哪个方法，是因为Python会按照特定的顺序遍历继承图。这个顺序叫方法解析顺序（Method Resolution Order，MRO）。类都有一个名为<code>__mro__</code>的属性，它的值是一个元组，按照方法解析顺序列出各个超类，从当前类一直向上，直到object类。方法解析顺序不仅考虑继承图，还考虑子类声明中列出超类的顺序。如果把D类声明为<code>class D(C, B):</code>，那么D类的<code>__mro__</code>属性就会不一样，先搜索C类，再搜索B类。</p><p>若想把方法委托给超类，推荐的方式是使用内置的super()函数，最安全，也不易过时。调用框架或不受自己控制的类层次结构中的方法时，尤其适合使用super()。使用super()调用方法时，会遵守方法解析顺序。然而，有时可能需要绕过方法解析顺序，直接调用某个超类的方法。例如C.pong(d)。注意，直接在类上调用实例方法时，必须显式地传入self参数，因为这样访问的是未绑定方法（unbound method）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">print_mro</span><span class="params">(cls)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">', '</span>.join(c.__name__ <span class="keyword">for</span> c <span class="keyword">in</span> cls.__mro__))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_mro(bool)</span><br><span class="line">bool, int, object</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numbers</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_mro(numbers.Integral)</span><br><span class="line">Integral, Rational, Real, Complex, Number, object</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> io</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_mro(io.BytesIO)</span><br><span class="line">BytesIO, _BufferedIOBase, _IOBase, object  <span class="comment"># 以Base结尾的是抽象基类</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_mro(io.TextIOWrapper)</span><br><span class="line">TextIOWrapper, _TextIOBase, _IOBase, object</span><br></pre></td></tr></table></figure><p>多重继承能发挥积极作用。《设计模式:可复用面向对象软件的基础》一书中的适配器模式用的就是多重继承，因此使用多重继承肯定没有错（那本书中的其他22个设计模式都使用单继承，因此多重继承显然不是灵丹妙药)。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> inheritance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标准库中的抽象基类</title>
      <link href="/notes/fluent-python/abc-s-in-standard-library/"/>
      <url>/notes/fluent-python/abc-s-in-standard-library/</url>
      
        <content type="html"><![CDATA[<h1 id="abc-模块中的抽象基类">abc 模块中的抽象基类</h1><p>Python3.4 在 <code>collections.abc</code> 模块中定义了 16 个抽象基类（Python3.6 定义了 25 个），简要的 UML 类图如下。</p><img src="http://www.plantuml.com/plantuml/svg/TP513e8m44NtdA8Nu0Rkt6YCAnFs0qoaILiGXXYCXpS2RMTQtRxv_tVcjzCjAhG3BSgYhN4ie9veX8RKcN24sc0anzuHQCT5D_t2bYd06EavmTH9ikPIpqFmCQDhcEOAmw3TdKiecrOQdmpEz7tdHzOso2A3WSHkTfAv5rmIKe6PSME-8tLubsMyJEAmaiH-eLHCHUWvyIVS1sHoAjPlIToCUQUGqG_5UgHFs2T9pxjI34C-KcAYo6BN0OMksVEfE1lzDyMF-W00"><a id="more"></a><ul><li><p>Iterable、Container 和 Sized</p><p>各个集合应该继承这三个抽象基类，或者至少实现兼容的协议。</p></li><li><p>Sequence、Mapping 和 Set</p><p>这三个是主要的不可变集合类型，而且各自都有可变的子类。</p></li><li><p>MappingView</p><p>在 Python3 中，映射方法 <code>.items()</code>、<code>.keys()</code>、<code>.values()</code> 返回的对象分别是 ItemsView、KeysView 和 ValuesView 的实例。前两个类还从 Set 类继承了丰富的接口。</p></li><li><p>Callable 和 Hashable</p><p>这两个抽象基类与集合没有太大的关系，只不过因为 <code>collections.abc</code> 是标准库中定义抽象基类的第一个模块，而它们又太重要了，因此才把它们放到 <code>collections.abc</code> 模块中。这两个抽象基类的主要作用是为内置函数 isinstance 提供支持，以一种安全的方式判断对象能不能调用或散列。若想检查是否能调用，可以使用内置的 <code>callable()</code> 函数；但是没有类似的 <code>hashable()</code> 函数，因此测试对象是否可散列，最好使用 <code>isinstance(my_obj, Hashable)</code>。</p></li><li><p>Iterator</p><p>注意它是 Iterable 的子类。</p></li></ul><p>继 <code>collections.abc</code> 之后，标准库中最有用的抽象基类包是 numbers。</p><h1 id="抽象基类的数字塔">抽象基类的数字塔</h1><img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYIamgBYbAJ2vHy2j5vJldvnRaf5OW189I4tEGU8abcVbvo2AUUIMfwKL04OX92ZOrkhfmKw0qH11i4eY0Sc56mHWGOPXv0000"><p>如果想检查一个数是不是整数，可以使用 <code>instance(x, numbers.Integral)</code>，这样代码就能接受 int、bool（int 的子类），或者外部库使用 numbers 抽象基类注册的其他类型。</p><p>与之类似，如果一个值可能是浮点数类型，可以使用 <code>instance(x, numbers.Real)</code> 检查。这样代码就能接受 bool、int、float、fractions.Fraction，或者外部库提供的非复数类型。</p><p><code>decimal.Decimal</code> 没有注册为 <code>numbers.Real</code> 的虚拟子类。原因是，如果你的程序需要 Decimal 的精度，要防止与其他低精度数字类型混淆，尤其是浮点数。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口：协议</title>
      <link href="/notes/fluent-python/interfaces-protocols/"/>
      <url>/notes/fluent-python/interfaces-protocols/</url>
      
        <content type="html"><![CDATA[<h1 id="python文化中的接口和协议">Python文化中的接口和协议</h1><p>接口在动态类型语言中是怎么运作的呢？首先，基本的事实是，Python语言没有interface关键字，而且除了抽象基类，每个类都有接口：类实现或继承的公开属性（方法或数据属性），包括特殊方法，如<code>__getitem__</code>或<code>__add__</code>。</p><p>按照定义，受保护的属性和私有属性不在接口中：即便“受保护的”属性也只是采用命名约定实现的（单个前导下划线）；私有属性可以轻松地访问，原因也是如此。不要违背这些约定有意访问私有属性。</p><p>另一方面，不要觉得把公开数据属性放入对象的接口中不妥，因为如果需要，总能实现读值方法和设值方法，把数据属性变成特性，使用obj.attr句法的客户代码不会收到影响。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span>:</span></span><br><span class="line">    typecode = <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = float(x)  <span class="comment"># x和y是公开数据属性</span></span><br><span class="line">        self.y = float(y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (i <span class="keyword">for</span> i <span class="keyword">in</span> (self.x, self.y))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 其他方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重构：把x和y变成只读特性，但是Vector2d的基本接口没变：</span></span><br><span class="line"><span class="comment"># 用户仍能读取my_vector.x和my_vector.y</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span>:</span></span><br><span class="line">    typecode = <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.__x = float(x)</span><br><span class="line">        self.__y = float(y)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__x</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">y</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__y</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 不受影响</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (i <span class="keyword">for</span> i <span class="keyword">in</span> (self.x, self.y))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 其他方法</span></span><br></pre></td></tr></table></figure><p>关于接口，这里有个实用的补充定义：对象公开方法的子集，让对象在系统中扮演特定的角色。Python文档中的“文件类对象”或“可迭代对象”就是这个意思，这种说法指的不是特定的类。</p><p>协议是接口，但不是正式的（只由文档和约定定义），因此协议不能像正式接口那样施加限制。一个类可能只实现部分接口，这是允许的。</p><h1 id="python喜欢序列">Python喜欢序列</h1><img src="http://www.plantuml.com/plantuml/svg/VP113i8W44Ntd68kq1kuS-NQ0n0AFvQaK8MfKIjt5rDj0mjc-UU_p9y_M0E2k_AJ75oF85GVEIZDT9myA-iHQ16KPt7WOJA9bhybaPHwTKKfHThP4oEeVaGJjTbKOcVxWcao8to5u3R3w_Qb2pWVSvdyUheyfRbuezhyKbPgm1qXmjGRwmqUfQIdsNEElFTvU7VT5bniNPNosaMXVG00"><p>箭头由子类指向超类，以斜体显示的是抽象方法。</p><p>现在，看看示例中的Foo类。它没有继承abc.Sequence，而且只实现了序列协议的一个方法<code>__getitem__</code>（没有实现<code>__len__</code>方法）。这样足够访问元素、迭代和使用in运算符了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, pos)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> range(<span class="number">0</span>, <span class="number">30</span>, <span class="number">10</span>)[pos]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">1</span>]</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> f: print(i)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">20</span> <span class="keyword">in</span> f</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">15</span> <span class="keyword">in</span> f</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>Python数据模型的哲学是尽量支持基本协议。对序列来说，即便是最简单的实现，Python也会力求做到最好。鉴于序列协议的重要性，如果没有<code>__iter__</code>和<code>__contains__</code>方法，Python会调用<code>__getitem__</code>方法，设法让迭代和in运算符可用。Python中的迭代是鸭子类型的一种极端形式：为了迭代对象，解释器会尝试调用两个不同的方法。</p><h1 id="使用猴子补丁在运行时实现协议">使用猴子补丁在运行时实现协议</h1><p>示例中的FrenchDeck类有个重大缺陷：无法洗牌。如果FrenchDeck实例的行为像序列，那么它就不需要shuffle方法，因为已经有random.shuffle函数可用。如果遵守既定协议，很有可能增加利用现有的标准库和第三方代码的可能性，这得益于鸭子类型。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/random#random.shuffle" target="_blank" rel="noopener"><code>random.shuffle(x[, random])</code></a></p><p>Shuffle the sequence x in place.</p></blockquote><figure class="highlight python"><figcaption><span>frenchdeck.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">Card = collections.namedtuple(<span class="string">'Card'</span>, [<span class="string">'rank'</span>, <span class="string">'suit'</span>])</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrenchDeck</span>:</span>  <span class="comment"># 实现序列协议的FrenchDeck类</span></span><br><span class="line">    ranks = [str(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">11</span>)] + list(<span class="string">'JQKA'</span>)</span><br><span class="line">    suits = <span class="string">'spades diamonds clubs hearts'</span>.split()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._cards = [Card(rank, suit) <span class="keyword">for</span> suit <span class="keyword">in</span> self.suits</span><br><span class="line">                       <span class="keyword">for</span> rank <span class="keyword">in</span> self.ranks]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._cards)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._cards[item]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> frenchdeck <span class="keyword">import</span> FrenchDeck</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> random <span class="keyword">import</span> shuffle</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck = FrenchDeck()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shuffle(deck)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"/Users/cws/opt/anaconda3/envs/python36/lib/python3.6/random.py"</span>, line <span class="number">277</span>, <span class="keyword">in</span> shuffle</span><br><span class="line">    x[i], x[j] = x[j], x[i]</span><br><span class="line">TypeError: <span class="string">'FrenchDeck'</span> object does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure><p>然而，如果尝试打乱FrenchDeck实例，会出现异常。错误消息相当明确，对象不支持为元素赋值。FrenchDeck只实现了不可变序列协议，可变的序列还必须提供<code>__setitem__</code>方法。Python是动态语言，因此我们可以在运行时修正这个问题，甚至还可以在交互式控制台中。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">set_card</span><span class="params">(deck, position, card)</span>:</span></span><br><span class="line"><span class="meta">... </span>    deck._cards[position] = card</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>FrenchDeck.__setitem__ = set_card</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shuffle(deck)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[:<span class="number">5</span>]</span><br><span class="line">[Card(rank=<span class="string">'5'</span>, suit=<span class="string">'spades'</span>), Card(rank=<span class="string">'5'</span>, suit=<span class="string">'clubs'</span>), Card(rank=<span class="string">'Q'</span>, suit=<span class="string">'clubs'</span>), Card(rank=<span class="string">'10'</span>, suit=<span class="string">'clubs'</span>), Card(rank=<span class="string">'5'</span>, suit=<span class="string">'hearts'</span>)]</span><br></pre></td></tr></table></figure><p>特殊方法<code>__setitem__</code>的签名在语言参考中使用的是self、key和value，而这里使用的是deck、position和card。这么做是为了告诉你，每个Python方法说到底都是普通函数，把第一个参数命名为self只是一种约定。在控制台会话中使用那几个参数没问题，不过在Python源码文件中最好按照文档那样使用self、key和value。</p><p>这里的关键是，<code>set_card</code>函数要知道deck对象有一个名为<code>_cards</code>的属性，而且<code>_cards</code>的只必须是可变序列。然后，我们把<code>set_card</code>函数赋值给特殊方法<code>__setitem__</code>，从而把它依附到FrenchDeck类上。这种技术叫猴子补丁：在运行时修改类或模块，而不改动源码。猴子补丁很强大，但是打补丁的代码与要打补丁的程序耦合十分紧密，而且往往要处理隐藏和没有文档的部分。</p><p>除了举例说明猴子补丁之外，示例还强调了协议是动态的：random.shuffle函数不关心参数的类型，只要那个对象实现了部分可变序列协议即可。即便对象一开始没有所需的方法也没关系，后来再提供也行。目前，本章讨论的主题是“鸭子类型”：对象的类型无关紧要，只要实现了特定的协议即可。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> protocols </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口：抽象基类</title>
      <link href="/notes/fluent-python/interfaces-abc-s/"/>
      <url>/notes/fluent-python/interfaces-abc-s/</url>
      
        <content type="html"><![CDATA[<p>抽象基类与描述符和元类一样，适用于构建框架的工具。因此，只有少数Python开发者编写的抽象基类不会对用户施加不必要的限制，让他们做无用功。不建议自己编写抽象基类，因为很容易过度设计。只要正确使用现有的抽象基类，就能获得99.9%的好处，而不用冒着设计不当导致的巨大风险。</p><p>引入抽象基类之前，Python就已经非常成功了，即便现在也很少有代码使用抽象基类。</p><h1 id="抽象基类">抽象基类</h1><p>Python的抽象基类有一个重要的实用优势：可以使用register类方法在终端用户的代码中把某个类”声明“为一个抽象基类的“虚拟”子类。为此，被注册的类必须满足抽象基类对方法名称和签名的要求，最重要的是要满足底层语义契约；但是，开发那个类时不用了解抽象基类，更不用继承抽象类。这大大地打破了严格的耦合，与面向对象编程人员掌握的知识有很大的出入，因此使用继承时要小心。</p><p>有时，为了让抽象基类识别子类，甚至不用注册。其实，抽象基类的本质就是几个特殊方法。例如：</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Struggle</span>:</span>  <span class="comment"># 无继承</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span> <span class="keyword">return</span> <span class="number">23</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(Struggle(), abc.Sized)  <span class="comment"># 无注册abc.Sized.register(Struggle)</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(Struggle, abc.Sized)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>可以看出，无需注册，abc.Sized也能把Struggle识别为自己的子类，只要实现了特殊方法<code>__len__</code>即可。要使用正确的句法和语义，前者要求没有参数，后者要求返回一个非负整数，指明对象的长度。如果不使用规定的句法和语义实现特殊方法，会导致非常严重的问题。</p><p>如果实现的类体现了numbers、collections.abc或其他框架中抽象基类的概念，要么继承相应的抽象基类（必要时），要么把类注册到相应的抽象基类中。开始开发程序时，不要使用提供注册功能的库或框架，要自己动手注册；如果必要检查参数的类型（这是最常见的），例如检查是不是序列，那就这样做：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">isinstance(the_arg, collections.abc.Sequece)</span><br></pre></td></tr></table></figure><p>继承抽象基类很简单，只需要实现所需的方法，这样也能明确表明开发者的意图。这一意图还能通过注册虚拟子类来实现。此外，使用isinstance和issubclass测试抽象基类更为人接受。过去，这两个函数用来测试鸭子类型，但用于抽象基类会更灵活。毕竟，如果某个组件没有继承抽象基类，事后还可以注册，让显式类型检查通过。</p><p>然而，即便是抽象基类，也不能滥用isinstance检查，用的多了可能导致代码异味，即表明面向对象设计得不好。<strong>在一连串if/elif/elif中使用isinstance检查，然后根据对象的类型执行不同的操作，通常是不好的做法；此时应该使用多态，即采用一定的方式定义类，让解释器把调用分派给正确的方法，而不使用if/elif/elif块硬编码分派逻辑。</strong></p><p><strong>具体使用时，上述建议有一个常见的例外：有些Python API接受一个字符串或字符串序列；因为字符串是序列类型，所以为了把它和其他不可变序列区分开，最简单的方式是使用isinstance(x, str)检查。</strong></p><blockquote><p>尽管抽象基类使得类型检查变得更容易了，但不应该在程序中过度使用它。Python的核心在于它是一门动态语言，它带来了极大的灵活性。如果处处都强制实行类型约束，那么会使代码变得更加复杂，而本不应该如此。我们应该拥抱Python的灵活性。</p><p>——David Beazley和Brian Jones 《Python Cookbook(第3版)中文版》</p></blockquote><p>另一方面，如果必须强制执行API契约，通常可以使用isinstance检查抽象基类。“老兄，如果你想调用我，必须实现这个”，正如本书技术审校Lennart Regebro所说的。这对采用插入式架构的系统来说特别有用。在框架之外，鸭子类型通常比类型检查更简单，也更灵活。</p><p>例如，本书有几个示例要使用序列，把它当成列表处理。我没有检查参数的类型是不是list，而是直接接受参数，立即使用它构建一个列表（list(x)）。这样，我就可以接受任何可迭代对象；如果参数不是可迭代对象，调用立即失败，并且提供非常清晰的错误消息。当然，如果序列太长（复制开销很大）或者需要就地修改序列而导致无法复制参数，就不能采用这种方式；此时，使用isinstance(x, abc.MutableSequence)更好。如果可以接受任何可迭代对象，也可以调用iter(x)函数获得一个迭代器。</p><p>模仿collections.namedtuple处理<code>field_names</code>参数的方式也是一例：<code>field_names</code>的值可以是单个字符串，以空格或逗号分隔标识符，也可以是一个标识符序列。此时可能想使用isinstance，但我会使用鸭子类型。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:  <span class="comment"># 假设是单个字符串</span></span><br><span class="line">    field_names = field_names.replace(<span class="string">','</span>, <span class="string">' '</span>).split()  <span class="comment"># 试图替换并拆分</span></span><br><span class="line"><span class="keyword">except</span> AttributeError:  <span class="comment"># 抱歉，field_names看起来不像是字符串...</span></span><br><span class="line">    <span class="keyword">pass</span>                <span class="comment"># 没有.replace方法，或者返回值不能使用.split方法拆分</span></span><br><span class="line"><span class="comment"># 假设已经是由名称组成的可迭代对象了</span></span><br><span class="line">field_names = tuple(field_names)  <span class="comment"># 确保是可迭代对象，也为了保存一份副本，使用所得值创建一个元组</span></span><br></pre></td></tr></table></figure><h1 id="定义抽象基类的子类">定义抽象基类的子类</h1><img src="http://www.plantuml.com/plantuml/svg/ZLBB4e8m3Bpp5Vq1_i2R9m-U_02ca1tf37rOWgCY_svLK5iLpN6pEybkKYk2W7Py51gwXCzasRAN5OkbDIoLWHTz9aBr6bnR6aG_KGPH5DMTrHP5DZorAuQNPODPgGgaMBPH9z2ife599DXrCDNyf2qu3DD1UUNaeM9oP2FfZ5icgCSUlWMb7MK8XnYgR6VuTULrnzTi_jgyZJR_p24qFpZ163n_CI-TWw4O6-t580xyHdJMfKfjztWBKHBTxlPygiKvpn_NonuF4yFtXqYmARS0frbU0000"><p>Sequence和MutableSequence抽象基类的方法不全是抽象的。以斜体显示的名称是抽象类和抽象方法。</p><figure class="highlight python"><figcaption><span>frenchdeck2.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">Card = collections.namedtuple(<span class="string">'Card'</span>, [<span class="string">'rank'</span>, <span class="string">'suit'</span>])</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrenchDeck2</span><span class="params">(collections.MutableSequence)</span>:</span>  <span class="comment"># 继承抽象基类</span></span><br><span class="line">    ranks = [str(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">11</span>)] + list(<span class="string">'JQKA'</span>)</span><br><span class="line">    suits = <span class="string">'spades diamonds clubs hearts'</span>.split()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._cards = [Card(rank, suit) <span class="keyword">for</span> suit <span class="keyword">in</span> self.suits</span><br><span class="line">                                        <span class="keyword">for</span> rank <span class="keyword">in</span> self.ranks]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._cards)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, position)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._cards[position]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, position, value)</span>:</span>  <span class="comment"># 支持洗牌必须实现__setitem__方法</span></span><br><span class="line">        self._cards[position] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span><span class="params">(self, position)</span>:</span>  <span class="comment"># 必须实现的基类抽象方法</span></span><br><span class="line">        <span class="keyword">del</span> self._cards[position]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, position, value)</span>:</span>  <span class="comment"># 必须实现的基类抽象方法</span></span><br><span class="line">        self._cards.insert(position, value)</span><br></pre></td></tr></table></figure><p>导入时（加载并编译frenchdeck2.py模块时），Python不会检查抽象方法的实现，在运行时实例化FrenchDeck2类时才会真正检查。因此，如果没有正确实现某个抽象方法，Python会抛出TypeError异常，并把错误消息设为&quot;Cant' instantiate abstract class FrenchDeck2 with abstract method <code>__delitem__</code>, insert&quot;。正是这个原因，即便FrenchDeck2类不需要<code>__delitem__</code>和insert提供的行为，也要实现，因为MutableSequence抽象基类需要它们。</p><p>我们还可以覆盖从抽象基类继承的方法，以更高效的方式重新实现。例如，<code>__contains__</code>方法会全面扫描序列，可是，如果你定义的序列按顺序保存元素，那就可以重新定义<code>__contains__</code>方法，使用bisect函数做二分查找，从而提升搜索速度。</p><h1 id="定义并使用一个抽象基类">定义并使用一个抽象基类</h1><p>为了证明有必要定义抽象基类，我们要在框架中找到使用它的场景。想象一下这个场景：你要在网站或移动应用中显示随机广告，但是在整个广告清单轮转一遍之前，不重复显示广告。假设我们构建一个广告管理框架，名为ADAM。它的职责之一是，支持用户提供随机挑选的无重复类。为了让ADAM的用户明确理解“随机挑选的无重复”组件是什么意思，我们将定义一个抽象基类。</p><p>受到“栈”和“队列”（以物体的排列方式说明抽象接口）启发，我将使用现实世界中的物品命名这个抽象基类：宾果机和彩票机是随机从有限的集合中挑选物品的机器，选出的物品没有重复，直到选完为止。我们把这个抽象基类命名为Tombola，这是宾果机和打乱数字的滚动容器的意大利名。</p><p>Tombola抽象基类有四个方法，其中两个是抽象方法。</p><ul><li><code>.load(...)</code>：把元素放入容器。</li><li><code>.pick()</code>：从容器中随机拿出一个元素，返回选中的元素。</li></ul><p>另外两个是具体方法：</p><ul><li><code>.loaded()</code>：如果容器中至少有一个元素，返回True。</li><li><code>.inspect()</code>返回一个有序元组，由容器中的现有元素构成，不会修改容器的内容（内部的顺序不保留）。</li></ul><img src="http://www.plantuml.com/plantuml/svg/dL2n3e8m4DtvYXjrW0ymX05NHlUcBHTiB9IqXuOW_sv56ekBqPkkxrxVlNjdLIDWszC8BRO2RSA58yibmScqmcWEKmA-fe3Fe0slT_jFj5VoigAfhwLvCZ5mLUTwbEHVSo8rTmvArJNco1jSTp2cEaMChH-YFP4uOv9hlP22JcM8q8wbDZUqlsXzyVUAe5AE8C-lojB0DRX1BDEYcFvH3gdczpHz1x25D_T4eooB71sy9ukDRz5YNHGF"><figure class="highlight python"><figcaption><span>tombola.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tombola</span><span class="params">(abc.ABC)</span>:</span>  <span class="comment"># 自定义的抽象基类要继承abc.ABC</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod        # 抽象方法使用abstractmethod装饰器标记</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">(self, iterable)</span>:</span>  <span class="comment"># 而且定义体中通常只有文档字符串</span></span><br><span class="line">        <span class="string">"""从可迭代对象中添加元素"""</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""随机删除元素，然后将其返回。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        如果实例为空，这个方法应该抛出LookupError。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loaded</span><span class="params">(self)</span>:</span>  <span class="comment"># 具体方法</span></span><br><span class="line">        <span class="string">"""如果至少有一个元素，返回True，否则返回False。"""</span></span><br><span class="line">        <span class="keyword">return</span> bool(self.inspect())  <span class="comment"># 具体方法只能依赖抽象基类定义的接口</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inspect</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回一个有序元组，由当前元素构成。"""</span></span><br><span class="line">        items = []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># 我们不知道具体子类如何存储元素，不过为了得到inpect的结果</span></span><br><span class="line">            <span class="keyword">try</span>:     <span class="comment"># 我们可以不断调用.pick()方法，把Tombola清空</span></span><br><span class="line">                items.append(self.pick())</span><br><span class="line">            <span class="keyword">except</span> LookupError:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        self.load(items)  <span class="comment"># 然后再使用.load(...)把所有元素放回去</span></span><br><span class="line">        <span class="keyword">return</span> tuple(sorted(items))</span><br></pre></td></tr></table></figure><p><strong>其实，抽象方法可以有实现代码。即便实现了，子类也必须覆盖抽象方法，但是在子类中可以使用super()函数调用抽象方法，为它添加功能，而不是从头开始实现。</strong></p><p>示例中的inspect()方法实现的方式有些笨拙，不过却表明，有了pick()和load(...)方法，若想查看Tombola中的内容，可以先把所有元素挑出，然后再放回去。这个示例的目的是强调抽象基类可以提供具体方法，只要依赖接口中的其他方法就行。Tombola的具体子类知晓内部数据结构，可以覆盖inspect()方法，使用更聪明的方式实现，但这不是强制要求。</p><p>loaded()方法没有那么笨拙，但是耗时：调用inspect()方法构建有序元组的目的仅仅是在其上调用bool()函数。这样做是可以的，但是具体子类可以做的更好。</p><p>self.pick()抛出LookupError这一事实也是接口的一部分，但是在Python中没办法声明，只能在文档中说明。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BaseException</span><br><span class="line"> +-- Exception</span><br><span class="line">      +-- LookupError</span><br><span class="line">      |    +-- IndexError</span><br><span class="line">      |    +-- KeyError</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> tombola <span class="keyword">import</span> Tombola</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Fake</span><span class="params">(Tombola)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="number">13</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fake  <span class="comment"># 创建子类，不会报错</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Fake</span>'&gt;</span></span><br><span class="line">&gt;&gt;&gt; f = Fake()  # 尝试实例化Fake时抛出了TypeError</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: Can<span class="string">'t instantiate abstract class Fake with abstract methods load  # Python认为Fake是抽象类，因为它没有实现load方法</span></span><br></pre></td></tr></table></figure><h2 id="抽象基类句法详解">抽象基类句法详解</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tombola</span><span class="params">(abc.ABC)</span>:</span>  <span class="comment"># Python3.4之后</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tombola</span><span class="params">(metaclass=abc.ABCMeta)</span>:</span>  <span class="comment"># Python3.4之前</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tombola</span><span class="params">(object)</span>:</span></span><br><span class="line">    __metaclass__ = abc.ABCMeta  <span class="comment"># Python2</span></span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>声明抽象类方法的推荐方式是：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyABC</span><span class="params">(abc.ABC)</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">an_abstract_classmethod</span><span class="params">(cls, ...)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>在函数上堆叠装饰器的顺序通常很重要，<a href="https://devdocs.io/python~3.6/library/abc#abc.abstractmethod" target="_blank" rel="noopener">@abstractmethod的文档</a>就特别指出：</p><blockquote><p>When abstractmethod() is applied in combination with other method descriptors, it should be applied as the innermost decorator.</p></blockquote><h2 id="定义tombola抽象基类的子类">定义Tombola抽象基类的子类</h2><figure class="highlight python"><figcaption><span>bingo.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> tombola <span class="keyword">import</span> Tombola</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BingoCage</span><span class="params">(Tombola)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, items)</span>:</span></span><br><span class="line">        self._randomizer = random.SystemRandom()</span><br><span class="line">        self._items = []</span><br><span class="line">        self.load(items)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">(self, items)</span>:</span></span><br><span class="line">        self._items.extend(item)</span><br><span class="line">        self._randomizer.shuffle(self._items)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self._items.pop()</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">raise</span> LookupError(<span class="string">'pick from empty BingoCage'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.pick()</span><br></pre></td></tr></table></figure><p>BingoCage从Tombola中继承了耗时的loaded方法和笨拙的inspect方法。</p><figure class="highlight python"><figcaption><span>lotto.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> tombola <span class="keyword">import</span> Tombola</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LotteryBlower</span><span class="params">(Tombola)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, iterable)</span>:</span></span><br><span class="line">        self._balls = list(iterable)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">(self, iterable)</span>:</span></span><br><span class="line">        self._balls.extend(iterable)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            position = random.randrange(len(self._balls))</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">raise</span> LookupError(<span class="string">'pick from empty LotteryBlower'</span>)</span><br><span class="line">        <span class="keyword">return</span> self._balls.pop(position)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loaded</span><span class="params">(self)</span>:</span>  <span class="comment"># 覆盖基类方法</span></span><br><span class="line">        <span class="keyword">return</span> bool(self._balls)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inspect</span><span class="params">(self)</span>:</span>  <span class="comment"># 覆盖基类方法</span></span><br><span class="line">        <span class="keyword">return</span> tuple(sorted(self._balls))</span><br></pre></td></tr></table></figure><h2 id="tombola的虚拟子类">Tombola的虚拟子类</h2><p>白鹅类型的一个基本特性：即便不继承，也有办法把一个类注册为抽象基类的虚拟子类。这样做时，我们保证注册的类忠实地实现了抽象基类定义的接口，而Python会相信我们，从而不做检查（即便在实例化时也不会检查）。如果我们说谎了，那么常规的运行时异常会把我们捕获。</p><p>注册虚拟子类的方式是在抽象基类上调用register方法。这么做之后，注册的类会变成抽象基类的虚拟子类，而且issubclass和isinstance等函数都能识别，但是注册的类不会从抽象基类中继承任何方法或属性。</p><p>register方法通常作为普通的函数调用，不过也可以作为装饰器使用。</p><img src="http://www.plantuml.com/plantuml/svg/ROz93i8m34NtEOKlG0w0Aau0AzXN6RxQY0mbCHAexTqfWmG4lBAVRFdztbaGmi1N2WWQMIXTE2l3j3kpqXvxdCw81i9uLGfvLvX6GKkD0TmdErFRkkYuRMlg4Mk82oFQUb6dvEjDAQMOtpQ757JowcNncBP_L0PdZj_49sL_2IhcOXbWUFbOnQPcajbrFSjdz3KrJKQtjCYmcuruq6PQhTvIuYLxlvKVhlNj3G00"><figure class="highlight python"><figcaption><span>tombolist.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randrange</span><br><span class="line"><span class="keyword">from</span> tombola <span class="keyword">import</span> Tombola</span><br><span class="line"></span><br><span class="line"><span class="meta">@Tombola.register  # 把TomboList注册为Tombola的虚拟子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TomboList</span><span class="params">(list)</span>:</span>  <span class="comment"># TomboList扩展list</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self:  <span class="comment"># 从list继承__bool__方法，列表不为空时返回True</span></span><br><span class="line">            position = randrange(len(self))</span><br><span class="line">            <span class="keyword">return</span> self.pop(position)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> LookupError(<span class="string">'pop from empty TomboList'</span>)</span><br><span class="line"></span><br><span class="line">    load = list.extend  <span class="comment"># TomboList.load与list.extend一样</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># loaded = list.__bool__ 是错误的，因为list没有实现__bool__方法</span></span><br><span class="line">    <span class="comment"># 而内置的bool函数在没有实现__bool__方法时还可以使用__len__方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loaded</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(self)  <span class="comment"># 委托bool函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inspect</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> tuple(sorted(self))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是Python3.3之前的版本，不能把register当作类装饰器使用，必须使用标准的调用句法</span></span><br><span class="line"><span class="comment"># Tombola.register(TomboList)</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> tombola <span class="keyword">import</span> Tombola</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> tombolist <span class="keyword">import</span> TomboList</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(TomboList, Tombola)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = TomboList(range(<span class="number">100</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(t, Tombola)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>然而，类的继承关系在一个特殊的类属性中指定——<code>__mro__</code>，即方法解析顺序（Method Resolution Order）。这个属性的作用很简单，按顺序列出类及其超类，Python会按照这个顺序搜索方法。查看TomboList类的<code>__mro__</code>属性，你会发现它只列出了“真实的”超类，即list和object。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>TomboList.__mro__</span><br><span class="line">(&lt;class 'tombolist.TomboList'&gt;, &lt;class 'list'&gt;, &lt;class 'object'&gt;)</span><br></pre></td></tr></table></figure><p><code>TomboList.__mro__</code>中没有Tombola，因此TomboList没有从Tombola中继承任何方法。</p><h1 id="鹅的行为有可能像鸭子">鹅的行为有可能像鸭子</h1><p>即便不注册，抽象基类也能把一个类识别为虚拟子类。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Struggle</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span> <span class="keyword">return</span> <span class="number">23</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(Struggle(), abc.Sized)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(Struggle, abc.Sized)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>这是因为abc.Sized实现了一个特殊的类方法，名为<code>__subclasshook__</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sized</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line"></span><br><span class="line">    __slots__ = ()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__subclasshook__</span><span class="params">(cls, C)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">is</span> Sized:</span><br><span class="line">            <span class="keyword">if</span> any(<span class="string">"__len__"</span> <span class="keyword">in</span> B.__dict__ <span class="keyword">for</span> B <span class="keyword">in</span> C.__mro__):  <span class="comment"># 对C及其超类中所列的类来说，如果有名为__len__的属性</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span>  <span class="comment"># 返回True，表明C是Sized的虚拟子类</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span>  <span class="comment"># 否则返回NotImplemented</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://devdocs.io/python~3.6/library/abc#abc.ABCMeta.__subclasshook__" target="_blank" rel="noopener"><code>__subclasshook__(subclass)</code></a></p><p><strong>(Must be defined as a class method.)</strong></p><p>Check whether subclass is considered a subclass of this ABC.This means that you can customize the behavior of issubclass further without the need to call register() on every class you want to consider a subclass of the ABC. (This class method is called from the <strong>subclasscheck</strong>() method of the ABC.)</p><p>This method should return True, False or NotImplemented.If it returns True, the subclass is considered a subclass of this ABC.If it returns False, the subclass is not considered a subclass of this ABC, even if it would normally be one.If it returns NotImplemented, the subclass check is continued with the usual mechanism.</p></blockquote><p><code>__subclasshook__</code>在白鹅类型中添加了一些鸭子类型的踪迹。</p><p>在自己定义的抽象基类中要不要实现<code>__subclasshook__</code>方法呢？可能不需要。我在Python源码中只见到Sized这一个抽象基类实现了<code>__subclasshook__</code>方法，而Sized只声明了一个特殊方法，因此只用检查这么一个特殊方法。鉴于<code>__len__</code>方法的“特殊性”，我们基本可以确定它能做到该做的事。但是对其他特殊方法和基本的抽象基类来说，很难这么肯定。</p><p>例如，虽然映射实现了<code>__len__</code>、<code>__getitem__</code>和<code>__iter__</code>，但是不应该把它们视作Sequence的子类型，因为不能使用整数偏移值获取元素，也不能保证元素的顺序。当然，OrderedDict除外，它保留了插入元素的顺序，但是不支持通过偏移获取元素。</p><p>自己实现的<code>__subclasshook__</code>方法还可以检查方法签名和其他特性，但我觉得不值得这么做。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列的修改、散列和切片</title>
      <link href="/notes/fluent-python/sequence-hacking-hashing-and-slicing/"/>
      <url>/notes/fluent-python/sequence-hacking-hashing-and-slicing/</url>
      
        <content type="html"><![CDATA[<h1 id="表示多维向量的vector类">表示多维向量的Vector类</h1><p>本章定义的Vector类是为了教学而使用的例子。如果在实际使用中需要做向量运算，应该使用NumPy和SciPy。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    typecode = <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, components)</span>:</span></span><br><span class="line">        <span class="comment"># 使用组合模式实现，向量的分量存储在浮点数数组中</span></span><br><span class="line">        self._components = array(self.typecode, components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 使用reprlib.repr()函数获取self._components的有限长度表示形式</span></span><br><span class="line">        <span class="comment"># 如 array('d', [0.0, 1.0, 2.0, 3.0, 4.0, ...])</span></span><br><span class="line">        components = reprlib.repr(self._components)</span><br><span class="line">        <span class="comment"># 去掉 [] 外面的字符</span></span><br><span class="line">        <span class="comment"># 我希望Vector实例的表示形式是 Vector([3.0, 4.0, 5.0])这样</span></span><br><span class="line">        <span class="comment"># 而不是 Vector(array('d', [3.0, 4.0, 5.0]))</span></span><br><span class="line">        <span class="comment"># 因为Vector实例中的数组是实现细节</span></span><br><span class="line">        <span class="comment"># 这两种所构建的Vector对象是一样的，所以我选择使用更简单的句法</span></span><br><span class="line">        components = components[components.find(<span class="string">'['</span>):<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Vector(&#123;&#125;)'</span>.format(components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(tuple(self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bytes__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (bytes([ord(self.typecode)]) +</span><br><span class="line">                bytes(self._components))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> tuple(self) == tuple(other)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 不能使用hypot方法了，先计算所有分量的平方和，在使用sqrt方法</span></span><br><span class="line">        <span class="keyword">return</span> math.sqrt(sum(x * x <span class="keyword">for</span> x <span class="keyword">in</span> self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(abs(self))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">frombytes</span><span class="params">(cls, octets)</span>:</span></span><br><span class="line">        typecode = chr(octets[<span class="number">0</span>])</span><br><span class="line">        memv = memoryview(octets[<span class="number">1</span>:]).cast(typecode)</span><br><span class="line">        <span class="keyword">return</span> cls(memv)</span><br></pre></td></tr></table></figure><p>如果Vector实例的分量超过6个，repr()生成的字符串就会使用...省略一部分。包含大量元素的集合类型一定要这么做，因为字符串表示形式是用于调试的（因此不想让大型对象在控制台或日志中输出几千行内容）。使用reprlib模块可以生成长度有限的表示形式。</p><a id="more"></a><p>编写<code>__repr__</code>方法时，本可以使用这个表达式生成简化的components显示形式：<code>reprlib.repr(list(self._components))</code>。然而，这么做有点浪费，因为要把<code>self._components</code>中的每个元素复制到一个列表中，然后使用列表的表示形式。我没有这么做，而是直接把<code>self._components</code>传给reprlib.repr函数，然后去掉[]外面的字符。</p><h1 id="协议和鸭子类型">协议和鸭子类型</h1><p>在Python中创建功能完善的序列类型无需使用继承，只需实现符合序列<strong>协议</strong>的方法。</p><p>在面向对象编程中，协议是非正式的接口，只在文档中定义，在代码中不定义。例如，Python的序列协议只需要<code>__len__</code>和<code>__getitem__</code>两个方法。任何类，只要使用标准的签名和语义实现了这两个方法，就能用在任何期待序列的地方。即便它是object的子类也无妨，我们说它是序列，因为它的行为像序列，这才是重点。</p><p>协议是非正式的，没有强制力，因此如果你知道类的具体使用场景，通常只需要实现一个协议的部分。例如，为了支持迭代，只需实现<code>__getitem__</code>方法，没必要提供<code>__len__</code>方法。</p><h1 id="可切片的序列">可切片的序列</h1><p>如果能委托给对象中的序列属性（如<code>self._componetns</code>数组），支持序列协议特别简单。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    <span class="comment"># 省略</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._components[index]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(v1)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1[<span class="number">0</span>], v1[<span class="number">-1</span>]</span><br><span class="line">(<span class="number">3.0</span>, <span class="number">5.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v7 = Vector(range(<span class="number">7</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v7[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">array(<span class="string">'d'</span>, [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>])</span><br></pre></td></tr></table></figure><p>可以看到，现在连切片都支持了，不过尚不完美。如果Vector实例的切片也是Vector实例，而不是数组，那就更好了。想想内置的序列类型，切片得到的都是各自类型的新实例，而不是其他类型。为了把Vector实例的切片也变成Vector实例，我们不能简单地委托给数组切片。我们要分析给<code>__getitem__</code>方法的参数，做适当的处理。</p><h2 id="切片原理">切片原理</h2><p>一例胜千言。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MySeq</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> index  <span class="comment"># 直接返回index</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = MySeq()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>]  <span class="comment"># 单个索引</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>:<span class="number">4</span>]  <span class="comment"># 1:4表示法变成了一个slice对象</span></span><br><span class="line">slice(<span class="number">1</span>, <span class="number">4</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>]</span><br><span class="line">slice(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>, <span class="number">9</span>]  <span class="comment"># 如果[]中有逗号，那么__getitem__收到的是元组</span></span><br><span class="line">(slice(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>), <span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>, <span class="number">7</span>:<span class="number">9</span>]  <span class="comment"># 元组中可以有多个切片对象</span></span><br><span class="line">(slice(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>), slice(<span class="number">7</span>, <span class="number">9</span>, <span class="literal">None</span>))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>slice  <span class="comment"># slice是内置的类型</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">slice</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">dir</span><span class="params">(slice)</span></span></span><br><span class="line">['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'indices', 'start', 'step', 'stop']</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(slice.indices)  <span class="comment"># slice.indices方法有很大的作用，但鲜为人知</span></span><br><span class="line">Help on method_descriptor:</span><br><span class="line"></span><br><span class="line">indices(...)</span><br><span class="line">    S.indices(len) -&gt; (start, stop, stride)</span><br><span class="line"></span><br><span class="line">    Assuming a sequence of length len, calculate the start <span class="keyword">and</span> stop</span><br><span class="line">    indices, <span class="keyword">and</span> the stride length of the extended slice described by</span><br><span class="line">    S. Out of bounds indices are clipped <span class="keyword">in</span> a manner consistent <span class="keyword">with</span> the</span><br><span class="line">    handling of normal slices.</span><br><span class="line">    <span class="comment"># 中文翻译 #</span></span><br><span class="line">    给定长度为len的序列，计算S表示的扩展切片的起始（start）和结尾（stop）索引，以及步幅（stride）。超出边界的索引会被截掉，这与常规切片的处理方式一样。</span><br></pre></td></tr></table></figure><p>indices方法开放了内置序列实现的棘手逻辑，用于优雅地处理缺失索引和负数索引，以及长度超过目标序列的切片。这个方法会“整顿”元组，把start、stop和stride都变成非负数，而且都落在指定长度序列的边界内。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设有个长度为5的序列，例如'ABCDE'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>slice(<span class="literal">None</span>, <span class="number">10</span>, <span class="number">2</span>).indices(<span class="number">5</span>)</span><br><span class="line">(<span class="number">0</span>, <span class="number">5</span>, <span class="number">2</span>)  <span class="comment"># 'ABCDE'[:10:2]等同于'ABCDE'[0, 5, 2]</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>slice(<span class="number">-3</span>, <span class="literal">None</span>, <span class="literal">None</span>).indices(<span class="number">5</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>)  <span class="comment"># 'ABCDE'[-3:]等同于'ABCDE'[2:5:1]</span></span><br></pre></td></tr></table></figure><p>在Vector类中无需使用slice.indices()方法，因为收到切片参数时，会委托_components数组处理。但是，如果没有底层序列类型作为依靠，那么使用这个方法能节省大量时间。</p><h2 id="能处理切片的__getitem__方法">能处理切片的<code>__getitem__</code>方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numbers  <span class="comment"># 开头导入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类中定义</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        cls = type(self)</span><br><span class="line">        <span class="keyword">if</span> isinstance(index, slice):  <span class="comment"># 切片</span></span><br><span class="line">            <span class="keyword">return</span> cls(self._components[index])</span><br><span class="line">        <span class="keyword">elif</span> isinstance(index, numbers.Integral):  <span class="comment"># 单个索引</span></span><br><span class="line">            <span class="keyword">return</span> self._components[index]</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 否则抛出异常</span></span><br><span class="line">            msg = <span class="string">'&#123;cls.__name__&#125; indices must be integers'</span></span><br><span class="line">            <span class="keyword">raise</span> TypeError(msg.format(cls=cls))  <span class="comment"># 为了创建符合Python风格的对象，我们要模仿Python内置的对象</span></span><br></pre></td></tr></table></figure><p>大量使用isinstance可能表明面向对象设计得不好，不过在<code>__getitem__</code>方法中使用它处理切片是合理的。numbers.Integral是一个抽象基类（Abstract Base Class，ABC），在isinstance中使用抽象基类做测试能让API更灵活且更容易更新。</p><h1 id="动态存取属性">动态存取属性</h1><p>Vector类没办法通过名称访问向量的分量（如v.x）。现在我们处理的向量可能有大量分量。不过，若能通过单个字母访问前几个分量的话会比较方便。</p><p>比如，用x、y、z和t代替v[0], v[1], v[2]和v[3]。我们可以在Vector中编写四个特性，但这样太麻烦。特殊方法<code>__getattr__</code>提供了更好的方式。属性查找失败后，解释器会调用<code>__getattr__</code>方法。简单来说，对my_obj.x表达式，Python会检查my_obj实例有没有名为x的属性；如果没有，到类（<code>my_obj.__class__</code>）中查找；如果还没有，顺着继承树继续查找（属性查找机制比这复杂的多）。如果依旧找不到，调用my_obj所属类中定义的<code>__getattr__</code>方法，传入self和属性名称的字符形式（如'x'）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 类中定义</span></span><br><span class="line">shortcut_names = <span class="string">'xyzt'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        cls = type(self)</span><br><span class="line">        <span class="keyword">if</span> len(name) == <span class="number">1</span>:</span><br><span class="line">            pos = cls.shortcut_names.find(name)</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= pos &lt; len(self._components):</span><br><span class="line">                <span class="keyword">return</span> self._components[pos]</span><br><span class="line">        msg = <span class="string">'&#123;.__name__!r&#125; object has no attribute &#123;!r&#125;'</span></span><br><span class="line">        <span class="keyword">raise</span> AttributeError(msg.format(cls, name))</span><br></pre></td></tr></table></figure><p><code>__getattr__</code>方法的实现不难，但是这样实现还不够。看看示例中古怪的交互行为。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v = Vector(range(<span class="number">5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v</span><br><span class="line">Vector([<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v.x</span><br><span class="line"><span class="number">0.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v.x = <span class="number">10</span>  <span class="comment"># 实例v中会新增一个属性x</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v.x  <span class="comment"># 属性x存在于实例中，因此直接返回它，不会调用__getattr__方法</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v  <span class="comment"># 向量的分量不会变</span></span><br><span class="line">Vector([<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>])</span><br></pre></td></tr></table></figure><p>为了避免这种现象，要改写Vector类中设置属性的逻辑。在Vector类中，如果为名称是单个小写字母的属性赋值，抛出AttributeError。为此，要实现<code>__setattr__</code>方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 类中定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line">        cls = type(slef)</span><br><span class="line">        <span class="keyword">if</span> len(name) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> name <span class="keyword">in</span> cls.shortcut_names:</span><br><span class="line">                error = <span class="string">'readonly attribute &#123;attr_name!r&#125;'</span></span><br><span class="line">            <span class="keyword">elif</span> name.islower():  <span class="comment"># 禁止为单个小写字母属性赋值</span></span><br><span class="line">                error = <span class="string">"can't set attributes 'a' to 'z' in &#123;cls_name!r&#125;"</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                error = <span class="string">''</span></span><br><span class="line">            <span class="keyword">if</span> error:</span><br><span class="line">                msg = error.format(cls_name=cls.__name__, attr_name=name)</span><br><span class="line">                <span class="keyword">raise</span> AttributeError(msg)</span><br><span class="line">        super().__setattr__(name, value)  <span class="comment"># 默认情况，在超类上调用__setattr__方法，提供标准行为</span></span><br></pre></td></tr></table></figure><p>不建议只为了避免创建实例属性而使用<code>__slots__</code>属性。<code>__slots__</code>属性只应该用于节省内存，而且仅当内存严重不足时才应该这么做。</p><p>虽然这个示例不支持为Vector分量赋值，但是有一个问题需要特别注意：多数时候，如果实现了<code>__getattr__</code>方法，那么也要定义<code>__setattr__</code>方法，以防对象的行为不一致。</p><h1 id="散列和快速等值测试">散列和快速等值测试</h1><p>我们要再次实现<code>__hash__</code>方法。加上现有的<code>__eq__</code>方法，这会把Vector实例变成可散列的对象。Vector2d中的<code>__hash__</code>方法简单地计算hash(self.x) ^ hash(self.y)。这一次，我们要使用异或运算符依次计算各个分量的散列值，像这样：v[0] ^ v[1] ^ v[2]...。这正是functools.reduce函数的作用。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/functools#functools.reduce" target="_blank" rel="noopener"><code>functools.reduce(function, iterable[, initializer])</code></a></p><p>Apply function of two arguments cumulatively to the items of sequence, from left to right, so as to reduce the sequence to a single value. For example, <code>reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])</code> calculates <code>((((1+2)+3)+4)+5)</code>.</p></blockquote><p>functools.reduce()的原理。它的关键思想是，把一系列值归约成单个值。reduce()函数的第一个参数是接受两个参数的函数，第二个参数是一个可迭代的对象。假如有个接受两个参数的fn函数和一个lst列表。调用reduce(fn, lst)时，fn会应用到第一对元素上，即fn(lst[0], lst[1])，生成第一个结果r1。然后，fn会应用到r1和下一个元素上，即fn(r1, lst[2])，生成第二个结果r2...直到最后一个元素，返回最后得到的结果rN。</p><p>使用reduce函数时最好提供第三个参数，这样能避免这个异常：TypeError: reduce() of empty sequence with no initial value。如果序列为空，initializer是返回的结果；否则，在归约中使用它作为第一个参数，因此应该使用恒等值。比如，对<code>+</code>、<code>|</code>和<code>^</code>来说，initializer应该是0；而对<code>*</code>和<code>&amp;</code>来说，应该是1。</p><p>回到散列问题上，计算聚合异或有3种方式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算整数0～5的累计异或</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">6</span>):  <span class="comment"># 使用循环</span></span><br><span class="line"><span class="meta">... </span>    n ^= i</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> functools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>functools.reduce(<span class="keyword">lambda</span> a, b: a^b, range(<span class="number">6</span>))  <span class="comment"># 使用匿名函数和reduce函数</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> operator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>functools.reduce(operator.xor, range(<span class="number">6</span>))  <span class="comment"># 使用运算符函数和reduce函数</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>编写<code>Vector.__hash__</code>方法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类中定义</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span>  <span class="comment"># 为了提高比较效率</span></span><br><span class="line">        <span class="comment"># tuple(self) == tuple(other) 要完整复制两个操作数</span></span><br><span class="line">        <span class="comment"># 构建两个元组，效率十分低下</span></span><br><span class="line">        <span class="keyword">if</span> len(self) != len(other):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 长度比较非常有必要，因为一旦有一个输入耗尽</span></span><br><span class="line">        <span class="comment"># zip函数会立即停止生成值，而不发出警告</span></span><br><span class="line">        <span class="comment"># 若无长度比较，可能会发生 Vector([1]) == Vector([1, 2]) is True</span></span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(self, other):</span><br><span class="line">            <span class="keyword">if</span> a != b:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">        hashes = (hash(x) <span class="keyword">for</span> x <span class="keyword">in</span> self._components)  <span class="comment"># 创建一个生成器表达式，惰性计算各个分量的散列值</span></span><br><span class="line">        <span class="keyword">return</span> functools.reduce(operator.xor, hashes, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/fluent-python/map-reduce.png"></p><p>示例中实现的<code>__hash__</code>方法是一种映射归约计算。把函数应用到各个元素上，生成一个新序列（映射，map），然后计算聚合值（规约，reduce）。映射过程计算各个分量的散列值，归约过程则使用xor运算符聚合所有散列值。把生成器表达式替换成map方法，映射过程更明显：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">    hashes = map(hash, self._components)  <span class="comment"># 与Python3生成器表达式原理一样</span></span><br><span class="line">    <span class="keyword">return</span> functools.reduce(operator.xor, hashes)</span><br></pre></td></tr></table></figure><p>示例中的<code>__eq__</code>方法的效率很好（不过Vector([1, 2] == (1, 2)的问题仍然存在），不过用于计算聚合值的整个for循环可以替换成一行all函数调用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> len(self) == len(other) <span class="keyword">and</span> all(a == b <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(self, other))</span><br></pre></td></tr></table></figure><p><em>zip函数的名字取自拉链系结物（zipper fastener），因为这个物品用于把两个拉链边的链牙咬合在一起，这形象地说明了zip(left, right)的作用。zip函数与文件压缩没有关系。</em></p><p>zip函数在当一个可迭代对象耗尽后，它不发出警告就停止。itertools.zip_longest函数的行为有所不同：使用可选的fillvalue填充缺失的值，因此可以继续产出，直到最长的可迭代对象耗尽。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/itertools#itertools.zip_longest" target="_blank" rel="noopener"><code>itertools.zip_longest(*iterables, fillvalue=None)</code></a></p><p>Make an iterator that aggregates elements from each of the iterables. If the iterables are of uneven length, missing values are filled-in with fillvalue. Iteration continues until the longest iterable is exhausted.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>zip(range(<span class="number">3</span>), <span class="string">'ABCDE'</span>)</span><br><span class="line">&lt;zip object at <span class="number">0x10cc9c088</span>&gt;  <span class="comment"># zip返回一个生成器</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(range(<span class="number">3</span>), <span class="string">'ABCDE'</span>))</span><br><span class="line">[(<span class="number">0</span>, <span class="string">'A'</span>), (<span class="number">1</span>, <span class="string">'B'</span>), (<span class="number">2</span>, <span class="string">'C'</span>)]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(range(<span class="number">2</span>), <span class="string">'ABC'</span>, <span class="string">'DEFG'</span>))</span><br><span class="line">[(<span class="number">0</span>, <span class="string">'A'</span>, <span class="string">'D'</span>), (<span class="number">1</span>, <span class="string">'B'</span>, <span class="string">'E'</span>)]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> itertools <span class="keyword">import</span> zip_longest</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip_longest(range(<span class="number">2</span>), <span class="string">'ABC'</span>, <span class="string">'DEFG'</span>, fillvalue=<span class="number">-1</span>))</span><br><span class="line">[(<span class="number">0</span>, <span class="string">'A'</span>, <span class="string">'D'</span>), (<span class="number">1</span>, <span class="string">'B'</span>, <span class="string">'E'</span>), (<span class="number">-1</span>, <span class="string">'C'</span>, <span class="string">'F'</span>), (<span class="number">-1</span>, <span class="number">-1</span>, <span class="string">'G'</span>)]</span><br></pre></td></tr></table></figure><h1 id="格式化">格式化</h1><p>Vector类的<code>__format__</code>方法与Vector2d类的相似，但是不使用极坐标，而使用球面坐标（也叫超球面坐标，hyperspherical coordinate），因为Vector类支持n个维度，而超过四维后，球体变成了“超球体”。因此，我们会把自定义格式后缀‘p’变成‘h’。</p><p>在小幅度改动<code>__format__</code>方法之前，我们要定义两个辅助方法：一个是angle(n)，用于计算某个角坐标；另一个是angles()，返回由所有角坐标构成的可迭代对象。我们不会讲解其中涉及的数学原理，如果你好奇的话，可以查看维基百科中的“<a href="https://en.wikipedia.org/wiki/N-sphere" target="_blank" rel="noopener">n为球体</a>”词条，那里有几个公式，我就是使用它们把Vector实例分量数组内的笛卡尔坐标转换成球面坐标的。</p><p>最终版的doctest和全部代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">A multidimensional ``Vector`` class, take 5</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">A ``Vector`` is built from an iterable of numbers::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; Vector([3.1, 4.2])</span></span><br><span class="line"><span class="string">    Vector([3.1, 4.2])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; Vector((3, 4, 5))</span></span><br><span class="line"><span class="string">    Vector([3.0, 4.0, 5.0])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; Vector(range(10))</span></span><br><span class="line"><span class="string">    Vector([0.0, 1.0, 2.0, 3.0, 4.0, ...])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests with two dimensions (same results as ``vector2d_v1.py``)::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 = Vector([3, 4])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; x, y = v1</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; x, y</span></span><br><span class="line"><span class="string">    (3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1</span></span><br><span class="line"><span class="string">    Vector([3.0, 4.0])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone = eval(repr(v1))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 == v1_clone</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print(v1)</span></span><br><span class="line"><span class="string">    (3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; octets = bytes(v1)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; octets</span></span><br><span class="line"><span class="string">    b'd\\x00\\x00\\x00\\x00\\x00\\x00\\x08@\\x00\\x00\\x00\\x00\\x00\\x00\\x10@'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(v1)</span></span><br><span class="line"><span class="string">    5.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; bool(v1), bool(Vector([0, 0]))</span></span><br><span class="line"><span class="string">    (True, False)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Test of ``.frombytes()`` class method:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone = Vector.frombytes(bytes(v1))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone</span></span><br><span class="line"><span class="string">    Vector([3.0, 4.0])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 == v1_clone</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests with three dimensions::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 = Vector([3, 4, 5])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; x, y, z = v1</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; x, y, z</span></span><br><span class="line"><span class="string">    (3.0, 4.0, 5.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1</span></span><br><span class="line"><span class="string">    Vector([3.0, 4.0, 5.0])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone = eval(repr(v1))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 == v1_clone</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print(v1)</span></span><br><span class="line"><span class="string">    (3.0, 4.0, 5.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(v1) # doctest:+ELLIPSIS</span></span><br><span class="line"><span class="string">    7.071067811...</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; bool(v1), bool(Vector([0, 0, 0]))</span></span><br><span class="line"><span class="string">    (True, False)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests with many dimensions::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v7 = Vector(range(7))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v7</span></span><br><span class="line"><span class="string">    Vector([0.0, 1.0, 2.0, 3.0, 4.0, ...])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(v7) # doctest:+ELLIPSIS</span></span><br><span class="line"><span class="string">    9.53939201...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Test of ``.__bytes__`` and ``.frombytes()`` methods::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 = Vector([3, 4, 5])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone = Vector.frombytes(bytes(v1))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone</span></span><br><span class="line"><span class="string">    Vector([3.0, 4.0, 5.0])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 == v1_clone</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of sequence behavior::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 = Vector([3, 4, 5])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; len(v1)</span></span><br><span class="line"><span class="string">    3</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1[0], v1[len(v1)-1], v1[-1]</span></span><br><span class="line"><span class="string">    (3.0, 5.0, 5.0)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Test of slicing::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v7 = Vector(range(7))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v7[-1]</span></span><br><span class="line"><span class="string">    6.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v7[1:4]</span></span><br><span class="line"><span class="string">    Vector([1.0, 2.0, 3.0])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v7[-1:]</span></span><br><span class="line"><span class="string">    Vector([6.0])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v7[1,2]</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">      ...</span></span><br><span class="line"><span class="string">    TypeError: Vector indices must be integers</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of dynamic attribute access::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v7 = Vector(range(10))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v7.x</span></span><br><span class="line"><span class="string">    0.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v7.y, v7.z, v7.t</span></span><br><span class="line"><span class="string">    (1.0, 2.0, 3.0)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Dynamic attribute lookup failures::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v7.k</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">      ...</span></span><br><span class="line"><span class="string">    AttributeError: 'Vector' object has no attribute 'k'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v3 = Vector(range(3))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v3.t</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">      ...</span></span><br><span class="line"><span class="string">    AttributeError: 'Vector' object has no attribute 't'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v3.spam</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">      ...</span></span><br><span class="line"><span class="string">    AttributeError: 'Vector' object has no attribute 'spam'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of hashing::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 = Vector([3, 4])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v2 = Vector([3.1, 4.2])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v3 = Vector([3, 4, 5])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v6 = Vector(range(6))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; hash(v1), hash(v3), hash(v6)</span></span><br><span class="line"><span class="string">    (7, 2, 1)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Most hash values of non-integers vary from a 32-bit to 64-bit CPython build::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; import sys</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; hash(v2) == (384307168202284039 if sys.maxsize &gt; 2**32 else 357915986)</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of ``format()`` with Cartesian coordinates in 2D::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 = Vector([3, 4])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(v1)</span></span><br><span class="line"><span class="string">    '(3.0, 4.0)'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(v1, '.2f')</span></span><br><span class="line"><span class="string">    '(3.00, 4.00)'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(v1, '.3e')</span></span><br><span class="line"><span class="string">    '(3.000e+00, 4.000e+00)'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of ``format()`` with Cartesian coordinates in 3D and 7D::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v3 = Vector([3, 4, 5])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(v3)</span></span><br><span class="line"><span class="string">    '(3.0, 4.0, 5.0)'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector(range(7)))</span></span><br><span class="line"><span class="string">    '(0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0)'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of ``format()`` with spherical coordinates in 2D, 3D and 4D::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector([1, 1]), 'h') # doctest:+ELLIPSIS</span></span><br><span class="line"><span class="string">    '&lt;1.414213..., 0.785398...&gt;'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector([1, 1]), '.3eh')</span></span><br><span class="line"><span class="string">    '&lt;1.414e+00, 7.854e-01&gt;'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector([1, 1]), '0.5fh')</span></span><br><span class="line"><span class="string">    '&lt;1.41421, 0.78540&gt;'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector([1, 1, 1]), 'h') # doctest:+ELLIPSIS</span></span><br><span class="line"><span class="string">    '&lt;1.73205..., 0.95531..., 0.78539...&gt;'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector([2, 2, 2]), '.3eh')</span></span><br><span class="line"><span class="string">    '&lt;3.464e+00, 9.553e-01, 7.854e-01&gt;'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector([0, 0, 0]), '0.5fh')</span></span><br><span class="line"><span class="string">    '&lt;0.00000, 0.00000, 0.00000&gt;'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector([-1, -1, -1, -1]), 'h') # doctest:+ELLIPSIS</span></span><br><span class="line"><span class="string">    '&lt;2.0, 2.09439..., 2.18627..., 3.92699...&gt;'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector([2, 2, 2, 2]), '.3eh')</span></span><br><span class="line"><span class="string">    '&lt;4.000e+00, 1.047e+00, 9.553e-01, 7.854e-01&gt;'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector([0, 1, 0, 0]), '0.5fh')</span></span><br><span class="line"><span class="string">    '&lt;1.00000, 1.57080, 0.00000, 0.00000&gt;'</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> numbers</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    typecode = <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, components)</span>:</span></span><br><span class="line">        self._components = array(self.typecode, components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        components = reprlib.repr(self._components)</span><br><span class="line">        components = components[components.find(<span class="string">'['</span>):<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Vector(&#123;&#125;)'</span>.format(components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(tuple(self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bytes__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (bytes([ord(self.typecode)]) +</span><br><span class="line">                bytes(self._components))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (len(self) == len(other) <span class="keyword">and</span></span><br><span class="line">                all(a == b <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(self, other)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">        hashes = (hash(x) <span class="keyword">for</span> x <span class="keyword">in</span> self)</span><br><span class="line">        <span class="keyword">return</span> functools.reduce(operator.xor, hashes, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> math.sqrt(sum(x * x <span class="keyword">for</span> x <span class="keyword">in</span> self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(abs(self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        cls = type(self)</span><br><span class="line">        <span class="keyword">if</span> isinstance(index, slice):</span><br><span class="line">            <span class="keyword">return</span> cls(self._components[index])</span><br><span class="line">        <span class="keyword">elif</span> isinstance(index, numbers.Integral):</span><br><span class="line">            <span class="keyword">return</span> self._components[index]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msg = <span class="string">'&#123;.__name__&#125; indices must be integers'</span></span><br><span class="line">            <span class="keyword">raise</span> TypeError(msg.format(cls))</span><br><span class="line"></span><br><span class="line">    shortcut_names = <span class="string">'xyzt'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        cls = type(self)</span><br><span class="line">        <span class="keyword">if</span> len(name) == <span class="number">1</span>:</span><br><span class="line">            pos = cls.shortcut_names.find(name)</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= pos &lt; len(self._components):</span><br><span class="line">                <span class="keyword">return</span> self._components[pos]</span><br><span class="line">        msg = <span class="string">'&#123;.__name__!r&#125; object has no attribute &#123;!r&#125;'</span></span><br><span class="line">        <span class="keyword">raise</span> AttributeError(msg.format(cls, name))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">angle</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        r = math.sqrt(sum(x * x <span class="keyword">for</span> x <span class="keyword">in</span> self[n:]))</span><br><span class="line">        a = math.atan2(r, self[n<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">if</span> (n == len(self) - <span class="number">1</span>) <span class="keyword">and</span> (self[<span class="number">-1</span>] &lt; <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> math.pi * <span class="number">2</span> - a</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">angles</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (self.angle(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span>, len(self)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__format__</span><span class="params">(self, fmt_spec=<span class="string">''</span>)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> fmt_spec.endswith(<span class="string">'h'</span>): <span class="comment"># hyperspherical coordinates</span></span><br><span class="line">            fmt_spec = fmt_spec[:<span class="number">-1</span>]</span><br><span class="line">            coords = itertools.chain([abs(self)], self.angles())</span><br><span class="line">            outer_fmt = <span class="string">'&lt;&#123;&#125;&gt;'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            coords = self</span><br><span class="line">            outer_fmt = <span class="string">'(&#123;&#125;)'</span></span><br><span class="line">        components = (format(c, fmt_spec) <span class="keyword">for</span> c <span class="keyword">in</span> coords)</span><br><span class="line">        <span class="keyword">return</span> outer_fmt.format(<span class="string">', '</span>.join(components))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">frombytes</span><span class="params">(cls, octets)</span>:</span></span><br><span class="line">        typecode = chr(octets[<span class="number">0</span>])</span><br><span class="line">        memv = memoryview(octets[<span class="number">1</span>:]).cast(typecode)</span><br><span class="line">        <span class="keyword">return</span> cls(memv)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>符合Python风格的对象</title>
      <link href="/notes/fluent-python/a-pythonic-object/"/>
      <url>/notes/fluent-python/a-pythonic-object/</url>
      
        <content type="html"><![CDATA[<p>得益于Python数据模型，自定义类型的行为可以像内置类型那样自然。实现如此自然的行为，靠的不是继承，而是鸭子类型（duck typing）：我们只需按照预定行为实现对象所需的方法即可。</p><h1 id="对象表示形式">对象表示形式</h1><p>每门面向对象的语言至少都有一种获取对象的字符串表示形式的标准方式。Python提供了两种方式。</p><p>repr()：以便于开发者理解的方式返回对象的字符串表示形式，由特殊方法<code>__repr__</code>支持。</p><p>str()：以便于用户理解的方式返回对象的字符串表示形式，由特殊方法<code>__str__</code>支持。</p><p>为了给对象提供其他的表示形式，还会用到另外两个特殊方法：<code>__bytes__</code>和<code>__format__</code>。<code>__bytes__</code>方法与<code>__str__</code>方法类似，bytes()函数调用它获取对象的字节序列表示形式。而<code>__format__</code>方法会被内置的format()函数和str.format()方法调用，使用特殊的格式代码显示对象的字符串表示形式。</p><a id="more"></a><h1 id="再谈向量类">再谈向量类</h1><p>为了说明用于生成对象表示形式的众多方法，我们将使用一个Vector2d类。</p><figure class="highlight python"><figcaption><span>vector2d.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span>:</span></span><br><span class="line">    typecode = <span class="string">'d'</span>  <span class="comment"># 类属性，在实例和字节序列之间转换时使用</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = float(x)  <span class="comment"># 把x和y转换成浮点数，尽早捕获错误</span></span><br><span class="line">        self.y = float(y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span>  <span class="comment"># 把Vector2d变成可迭代对象，这样才能拆包</span></span><br><span class="line">        <span class="keyword">return</span> (i <span class="keyword">for</span> i <span class="keyword">in</span> (self.x, self.y))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span>  <span class="comment"># __repr__方法使用&#123;!r&#125;获取各个分量的表示形式，然后插值，构成一个字符串</span></span><br><span class="line">        class_name = type(self).__name__</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&#123;&#125;(&#123;!r&#125;, &#123;!r&#125;)'</span>.format(class_name, *self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>  <span class="comment"># 从可迭代的实例中可以轻松地得到一个元组</span></span><br><span class="line">        <span class="keyword">return</span> str(tuple(self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bytes__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (bytes([ord(self.typecode)]) +  <span class="comment"># 为了生成字节序列，把typecode转换成字节序列，然后</span></span><br><span class="line">                bytes(array(self.typecode, self)))  <span class="comment"># 迭代实例，得到一个数组，再把数组转换成字节序列</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span>  <span class="comment"># 可用，但有点问题，比如Vector2d(3, 4) == [3, 4]的结果会是True。</span></span><br><span class="line">        <span class="keyword">return</span> tuple(self) == tuple(other)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> math.hypot(self.x, self.y)  <span class="comment"># 模是x和y分量构成的直角三角形的斜边长</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(abs(self))  <span class="comment"># abs(0.0)是False，非零值是True</span></span><br></pre></td></tr></table></figure><p>Vector2d实例具有以下基本行为：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector2d(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(v1.x, v1.y)  <span class="comment"># 实例的分量可以直接通过属性访问</span></span><br><span class="line"><span class="number">3.0</span> <span class="number">4.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = v1  <span class="comment"># 实例可以拆包成变量元组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y</span><br><span class="line">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1  <span class="comment"># repr函数调用实例，得到的结果类似于构建实例的源码</span></span><br><span class="line">Vector2d(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1_clone = eval(repr(v1))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 == v1_clone</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(v1)  <span class="comment"># print函数会调用str函数</span></span><br><span class="line">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>octets = bytes(v1)  <span class="comment"># bytes函数会调用__bytes__方法，生成实例的二进制表示形式</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>octets</span><br><span class="line"><span class="string">b'd\\x00\\x00\\x00\\x00\\x00\\x00\\x08@\\x00\\x00\\x00\\x00\\x00\\x00\\x10@'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>abs(v1)  <span class="comment"># abs函数会调用__abs__方法，返回实例的模</span></span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(v1), bool(Vector2d(<span class="number">0</span>, <span class="number">0</span>))  <span class="comment"># bool函数会调用__bool__方法，如果实例的模为0，返回False，否则返回True</span></span><br><span class="line"><span class="literal">True</span>, <span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="备选构造方法">备选构造方法</h1><p>我么可以把Vector2d实例转换成字节序列；同理，也应该能从字节序列转换成Vector2d实例。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在类中定义</span></span><br><span class="line"><span class="meta">@classmethod  # 类方法：从字节序列转换成Vector2d实例</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">frombytes</span><span class="params">(cls, octets)</span>:</span>  <span class="comment"># 不用传入self参数，相反，要通过cls传入类本身</span></span><br><span class="line">    typecode = chr(octets[<span class="number">0</span>])  <span class="comment"># 从第一个字节中读取typecode</span></span><br><span class="line">    memv = memoryview(octets[<span class="number">1</span>:]).cast(typecode)  <span class="comment"># 使用传入的octets字节序列创建一个memoryview，然后使用typecode转换</span></span><br><span class="line">    <span class="keyword">return</span> cls(*memv)  <span class="comment"># 拆包转换后的memoryview，得到构造方法所需的一对参数</span></span><br></pre></td></tr></table></figure><h2 id="classmethod与staticmethod">classmethod与staticmethod</h2><p>classmethod装饰器定义操作类，而不是操作实例的方法。classmethod改变了调用方法的方式，因此类方法的第一个参数是类本身，而不是实例。classmethod最常见的用途是定义备选构造方法。按照约定，类方法的第一个参数名为cls（但是Python不介意具体怎么命名）。</p><p>staticmethod装饰器也会改变方法的调用方式，但是第一个参数不是特殊的值。其实，静态方法就是普通的函数，只是碰巧在类的定义体中，而不是在模块层定义。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>:</span></span><br><span class="line"><span class="meta">... </span>    @classmethod</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">klassmeth</span><span class="params">(*args)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> args  <span class="comment"># 返回全部参数</span></span><br><span class="line"><span class="meta">... </span>    @staticmethod</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">statmeth</span><span class="params">(*args)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> args  <span class="comment"># 返回全部参数</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Demo.klassmeth()  <span class="comment"># 不管怎样调用类方法，第一个参数始终是Demo类</span></span><br><span class="line">(&lt;class '__main__.Demo'&gt;,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Demo.klassmeth(<span class="string">'spam'</span>)</span><br><span class="line">(&lt;class '__main__.Demo'&gt;, 'spam')</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Demo.statmeth()  <span class="comment"># 静态方法的行为与普通的函数类似</span></span><br><span class="line">()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Demo.statmeth(<span class="string">'spam'</span>)</span><br><span class="line">(<span class="string">'spam'</span>,)</span><br></pre></td></tr></table></figure><h1 id="格式化显示">格式化显示</h1><p>内置的format()函数和str.format()方法把各个类型的格式化方法委托给相应的<code>.__format__(format_spec)</code>方法。format_spec是格式说明符，它是：</p><ul><li>format(my_obj, format_spec)的第二个参数，或者</li><li>str.format()方法的格式字符串，{}里代换字段中冒号后面的部分。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>brl = <span class="number">1</span>/<span class="number">2.43</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>brl</span><br><span class="line"><span class="number">0.4115226337448559</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(brl, <span class="string">'0.4f'</span>)  <span class="comment"># 格式说明符是 '0.4f'</span></span><br><span class="line"><span class="string">'0.4115'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'1 BRL = &#123;rate:0.2f&#125; USD'</span>.format(rate=brl)  <span class="comment"># 格式说明符是 '0.2f'</span></span><br><span class="line"><span class="string">'1 BRL = 0.41 USD'</span></span><br></pre></td></tr></table></figure><p>'{rate:0.2f}'这样的格式字符串包含两部分，冒号左边的'rate'在代换字段句法中是字段名，冒号后面的'0.2f'是格式说明符。格式说明符使用的表示法叫格式规范微语言（“<a href="https://devdocs.io/python~3.6/library/string#formatspec" target="_blank" rel="noopener">Format Specification Mini-LMini-Language</a>“）。</p><p>格式规范微语言是可扩展的，因为各个类可以自行决定如果解释format_spec参数。例如，datetime模块中的类，它们的<code>__format__</code>方法使用的格式代码与strftime()函数一样。下面是内置的format()函数和str.format()方法的几个示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(now, <span class="string">'%H:%M:%S'</span>)</span><br><span class="line"><span class="string">'11:46:10'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"It's now &#123;:%I:%M %p&#125;"</span>.format(now)</span><br><span class="line"><span class="string">"It's now 11:46 AM"</span></span><br></pre></td></tr></table></figure><p>如果类没有定义<code>__format__</code>方法，从object继承的方法会返回str(my_object)。然而没如果传入格式说明符，<code>object.__format__</code>方法会抛出TypeError。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector2d(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(v1)  <span class="comment"># 若没有定义__format__方法，则返回str(v1)</span></span><br><span class="line"><span class="string">'(3.0, 4.0)'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(v1, <span class="string">'.3f'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">TypeError: unsupported format string passed to Vector2d.__format__</span><br></pre></td></tr></table></figure><p>我们将自己实现微语言来解决这个问题。首先，假设用户提供的格式说明符是用于格式化向量中各个浮点数分量的，想达到的效果是：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector2d(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(v1)</span><br><span class="line"><span class="string">'(3.0, 4.0)'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(v1, <span class="string">'.2f'</span>)</span><br><span class="line"><span class="string">'(3.00, 4.00)'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(v1, <span class="string">'.3e'</span>)</span><br><span class="line"><span class="string">'(3.000e+00, 4.000e+00)'</span></span><br></pre></td></tr></table></figure><p>实现这种输出的<code>__format__</code>方法如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在类中定义</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__format__</span><span class="params">(self, fmt_spec=<span class="string">''</span>)</span>:</span></span><br><span class="line">    components = (format(c, fmt_spec) <span class="keyword">for</span> c <span class="keyword">in</span> self)  <span class="comment"># 使用内置的format函数把fmt_spec应用到向量的各个分量上</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'(&#123;&#125;, &#123;&#125;)'</span>.format(*components)</span><br></pre></td></tr></table></figure><p>下面要在微语言中添加一个自定义的格式代码：如果格式说明符以'p'结尾，那么在极坐标中显示向量，即&lt;r, <span class="math inline">\(\theta\)</span>&gt;，其中r是模，<span class="math inline">\(\theta\)</span>是弧度；其他部分（'p'之前的部分）像往常那样解释。</p><p>对极坐标来说，我们已经定义了计算模的<code>__abs__</code>方法，因此还要定义一个简单的angle方法，使用math.atan2()函数计算角度。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在类中定义</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">angle</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> math.atan2(self.y, self.x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__format__</span><span class="params">(self, fmt_spec)</span>:</span>  <span class="comment"># 增强型__format__方法</span></span><br><span class="line">    <span class="keyword">if</span> fmt_spec.endswith(<span class="string">'p'</span>):</span><br><span class="line">        fmt_spec = fmt_spec[:<span class="number">-1</span>]</span><br><span class="line">        coords = (abs(self), self.angle())  <span class="comment"># 极坐标</span></span><br><span class="line">        outer_fmt = <span class="string">'&lt;&#123;&#125;, &#123;&#125;&gt;'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        coords = self</span><br><span class="line">        outer_fmt = <span class="string">'(&#123;&#125;, &#123;&#125;)'</span></span><br><span class="line">    components = (format(c, fmt_spec) <span class="keyword">for</span> c <span class="keyword">in</span> coords)</span><br><span class="line">    <span class="keyword">return</span> outer_fmt.format(*components)</span><br></pre></td></tr></table></figure><p>示例中的代码得到的结果如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(Vector2d(<span class="number">1</span>, <span class="number">1</span>), <span class="string">'p'</span>)</span><br><span class="line"><span class="string">'&lt;1.4142135623730951, 0.7853981633974483&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(Vector2d(<span class="number">1</span>, <span class="number">1</span>), <span class="string">'.3ep'</span>)</span><br><span class="line"><span class="string">'&lt;1.414e+00, 7.854e-01&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(Vector2d(<span class="number">1</span>, <span class="number">1</span>), <span class="string">'0.5fp'</span>)</span><br><span class="line"><span class="string">'&lt;1.41421, 0.78540&gt;'</span></span><br></pre></td></tr></table></figure><h1 id="可散列的vector2d">可散列的Vector2d</h1><p>目前Vector2d实例是不可散列的，因此不能放入集合（set）中。为了把Vector2d实例变成可散列的，必须使用<code>__hash__</code>方法（还需要<code>__eq__</code>方法）。此外，还要让向量不可变，为此，我们要把x和y分量设为只读属性。（要想创建可散列的类型，不一定要实现特性，也不一定要保护实例属性。只需正确地实现<code>__hash__</code>和<code>__eq__</code>方法即可。但是实例的散列值绝不应该变化，因此借机提到了只读属性）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 类中定义</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">    self.__x = x  <span class="comment"># 使用两个前导下划线，把属性标记为私有的</span></span><br><span class="line">    self.__y = y</span><br><span class="line"></span><br><span class="line"><span class="meta">@property  # @property装饰器把读值方法标记为特性</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.__x</span><br><span class="line"></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">y</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.__y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他方法保持不变，通过self.x和self.y读取公开特性，而不必读取私有属性</span></span><br></pre></td></tr></table></figure><p>让这些向量不可变是有原因的，因为这样才能实现<code>__hash__</code>方法。这个方法应该返回一个整数，理想情况下还要考虑对象属性的散列值（<code>__eq__</code>方法也要使用），因为相等的对象应该具有相同的散列值。根据<a href="https://docs.python.org/3/reference/datamodel.html" target="_blank" rel="noopener">特殊方法<code>__hash__</code>的文档</a>，最好使用位运算符异或（^）混合各分量的散列值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在类中定义</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> hash(self.x) ^ hash(self.y)</span><br></pre></td></tr></table></figure><p>完整代码清单，包含全部doctest。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">A two-dimensional vector class</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 = Vector2d(3, 4)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print(v1.x, v1.y)</span></span><br><span class="line"><span class="string">    3.0 4.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; x, y = v1</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; x, y</span></span><br><span class="line"><span class="string">    (3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1</span></span><br><span class="line"><span class="string">    Vector2d(3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone = eval(repr(v1))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 == v1_clone</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print(v1)</span></span><br><span class="line"><span class="string">    (3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; octets = bytes(v1)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; octets b'd\\x00\\x00\\x00\\x00\\x00\\x00\\x08@\\x00\\x00\\x00\\x00\\x00\\x00\\x10@'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(v1)</span></span><br><span class="line"><span class="string">    5.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; bool(v1), bool(Vector2d(0, 0))</span></span><br><span class="line"><span class="string">    (True, False)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Test of ``.frombytes()`` class method:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone = Vector2d.frombytes(bytes(v1))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone</span></span><br><span class="line"><span class="string">    Vector2d(3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 == v1_clone</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of ``format()`` with Cartesian coordinates:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(v1)</span></span><br><span class="line"><span class="string">    '(3.0, 4.0)'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(v1, '.2f')</span></span><br><span class="line"><span class="string">    '(3.00, 4.00)'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(v1, '.3e')</span></span><br><span class="line"><span class="string">    '(3.000e+00, 4.000e+00)'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of the ``angle`` method::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; Vector2d(0, 0).angle()</span></span><br><span class="line"><span class="string">    0.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; Vector2d(1, 0).angle()</span></span><br><span class="line"><span class="string">    0.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; epsilon = 10**-8</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(Vector2d(0, 1).angle() - math.pi/2) &lt; epsilon</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(Vector2d(1, 1).angle() - math.pi/4) &lt; epsilon</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of ``format()`` with polar coordinates:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector2d(1, 1), 'p') # doctest:+ELLIPSIS</span></span><br><span class="line"><span class="string">    '&lt;1.414213..., 0.785398...&gt;'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector2d(1, 1), '.3ep')</span></span><br><span class="line"><span class="string">    '&lt;1.414e+00, 7.854e-01&gt;'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector2d(1, 1), '0.5fp')</span></span><br><span class="line"><span class="string">    '&lt;1.41421, 0.78540&gt;'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of `x` and `y` read-only properties:</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1.x, v1.y</span></span><br><span class="line"><span class="string">    (3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1.x = 123</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">      ...</span></span><br><span class="line"><span class="string">    AttributeError: can't set attribute</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of hashing:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 = Vector2d(3, 4)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v2 = Vector2d(3.1, 4.2)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; hash(v1), hash(v2)</span></span><br><span class="line"><span class="string">    (7, 384307168202284039)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; len(set([v1, v2]))</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span>:</span></span><br><span class="line">    typecode = <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.__x = float(x)</span><br><span class="line">        self.__y = float(y)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__x</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">y</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (i <span class="keyword">for</span> i <span class="keyword">in</span> (self.x, self.y))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        class_name = type(self).__name__</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&#123;&#125;(&#123;!r&#125;, &#123;!r&#125;)'</span>.format(class_name, *self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(tuple(self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bytes__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (bytes([ord(self.typecode)]) +</span><br><span class="line">                bytes(array(self.typecode, self)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> tuple(self) == tuple(other)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> hash(self.x) ^ hash(self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> math.hypot(self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(abs(self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">angle</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> math.atan2(self.y, self.x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__format__</span><span class="params">(self, fmt_spec=<span class="string">''</span>)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> fmt_spec.endswith(<span class="string">'p'</span>):</span><br><span class="line">            fmt_spec = fmt_spec[:<span class="number">-1</span>]</span><br><span class="line">            coords = (abs(self), self.angle())</span><br><span class="line">            outer_fmt = <span class="string">'&lt;&#123;&#125;, &#123;&#125;&gt;'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            coords = self</span><br><span class="line">            outer_fmt = <span class="string">'(&#123;&#125;, &#123;&#125;)'</span></span><br><span class="line">            components = (format(c, fmt_spec) <span class="keyword">for</span> c <span class="keyword">in</span> coords)</span><br><span class="line">        <span class="keyword">return</span> outer_fmt.format(*components)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">frombytes</span><span class="params">(cls, octets)</span>:</span></span><br><span class="line">        typecode = chr(octets[<span class="number">0</span>])</span><br><span class="line">        memv = memoryview(octets[<span class="number">1</span>:]).cast(typecode)</span><br><span class="line">        <span class="keyword">return</span> cls(*memv)</span><br></pre></td></tr></table></figure><h1 id="python的私有属性和受保护的属性">Python的私有属性和“受保护的”属性</h1><p>Python不能像Java那样使用private修饰符创建私有属性，但是Python有个简单的机制，能避免子类意外覆盖“私有”属性。举个例子，有人编写了一个名为Dog的类，这个类的内部用到了mood实例属性，但是没有将其开放。现在，你创建了Dog的子类：Beagle。如果你在毫不知情的情况下又创建了名为mood的实例属性，那么在继承的方法中就会把Dog类的mood属性覆盖掉。这是个难以调试的问题。</p><p>为了避免这种情况，如果以<code>__mood</code>的形式命名实例属性，Python会把属性名存入实例的<code>__dict__</code>属性中，而且会在前面加上一个下划线和类名。因此，对Dog类来说，<code>__mood</code>会变成<code>_Dog__mood</code>；对Beagle类来说，会变成<code>_Beagle__mood</code>。这个语言特性叫名称改写（name mangling）。名称改写是一种安全措施，不能保证万无一失：它的目的是避免意外访问，不能防止故意做错事。</p><p>以上一节定义的Vector2d类为例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector2d(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1.__dict__</span><br><span class="line">&#123;<span class="string">'_Vector2d__x'</span>: <span class="number">3.0</span>, <span class="string">'_Vector2d__y'</span>: <span class="number">4.0</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1._Vector2d__x  <span class="comment"># 故意访问</span></span><br><span class="line"><span class="number">3.0</span></span><br></pre></td></tr></table></figure><p>不是所有Python程序员都喜欢名称改写功能，也不是所有人都喜欢<code>self.__x</code>这种不对称的名称。有些人不喜欢这种句法，他们约定使用一个下环线前缀编写“受保护”的属性（如<code>self._x</code>）。批评使用两个下划线这种改写机制的人认为，应该使用命名约定来避免意外覆盖属性。</p><blockquote><p>绝对不要使用两个前导下划线，这是很烦人的自私行为。如果担心命名冲突，应该明确使用一种名称改写方式（如<code>_MyThing_blahblah</code>）。这其实与使用双下划线一样，不过自己定的规则比双下划线易于理解。</p><p>—— Ian Bicking，<a href="http://pythonpaste.org/StyleGuide.html" target="_blank" rel="noopener">Paste的风格指南</a></p></blockquote><p>Python解释器不会对使用单个下划线的属性名做特殊处理，不过这是很多Python程序员严格遵守的约定，他们不会在类外部访问这种属性（不过在模块中，顶层名称使用一个前导下划线的话，的确会有影响：对from mymod import *来说，mymod中前缀为下划线的名称不会被导入。然而，依旧可以使用from mymod import _privatefunc将其导入）。遵守使用一个下划线标记对象的私有属性很容易，就像遵守使用全大写字母编写常量那样容易。</p><p>Vector2d的分量都是”私有的“，而且Vector2d实例都是”不可变的”。我用了两对引号，这是因为并不能真正实现私有和不可变。</p><h1 id="使用__slots__类属性节省空间">使用<code>__slots__</code>类属性节省空间</h1><p>默认情况下，Python在各个实例中名为<code>__dict__</code>的字典里存储实例属性。为了使用底层的散列表提升访问速度，字典会消耗大量内存。如果要处理数百万个属性不多的实例，通过<code>__slots__</code>类属性，能节省大量内存，方法是让解释器在元组中存储实例属性，而不使用字典。（继承自超类的<code>__slots__</code>属性没有效果。Python只会使用各个类中定义的<code>__slots__</code>属性）</p><p>定义<code>__slots__</code>的方式是，创建一个类属性，使用<code>__slots__</code>这个名字，并把它的值设为一个字符串构成的可迭代对象，其中各个元素表示各个实例属性。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span>:</span></span><br><span class="line">    __solots__ = (<span class="string">'__x'</span>, <span class="string">'__y'</span>)</span><br><span class="line"></span><br><span class="line">    typecode = <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类方法</span></span><br></pre></td></tr></table></figure><p>如果要处理数百万个数值对象，应该使用NumPy数组。NumPy数组能高效使用内存，而且提供了高度优化的数值处理函数，其中很多都一次操作整个数组。</p><p>在类中定义<code>__slots__</code>属性之后，实例不能再有<code>__slots__</code>中所列名称之外的其他属性。这只是一个副作用，不是<code>__slots__</code>存在的真正原因，不要使用<code>__slots__</code>属性禁止类的用户新增实例。<code>__slots__</code>是用于优化的，不是为了约束程序员。</p><p>然而，“节省的内存也可能被再次吃掉”：如果把'<code>__dict__</code>'这个名称添加到<code>__slots__</code>中，实例会在元组中保存各个实例的属性，此外还支持动态创建属性，这些属性存储在常规的<code>__dict__</code>中。当然，把'<code>__dict__</code>'添加到<code>__slots__</code>中可能完全违背了初衷，这取决于各个实例的静态属性和动态属性的数量及其用法。</p><p>此外，还有一个实例属性可能需要注意，即<code>__weakref__</code>属性，为了让对象支持弱引用，必须有这个属性。用户定义的类中默认就有<code>__weakref__</code>属性。可是，如果类中定义了<code>__slots__</code>属性，而且想把实例作为弱引用的目标，那么要把'<code>__weakref__</code>'添加到<code>__slots__</code>中。</p><p>综上，<code>__slots__</code>属性有些需要注意的地方，而且不能滥用，不能使用它限制用户能赋值的属性。处理列表数据时<code>__slots__</code>属性最有用，例如模式固定的数据库记录，以及特大型数据库。然而，如果你经常处理大量数据，一定要了解一下<a href="http://www.numpy.org" target="_blank" rel="noopener">NumPy</a>；此外，数据分析库<a href="http://pandas.pydata.org" target="_blank" rel="noopener">pandas</a>也值得了解，这个库可以处理非数值数据，而且能导入/导出很多不同的列表数据格式。</p><p>总之，如果使用得当，<code>__slots__</code>能显著节省内存，不过要注意以下几点：</p><ul><li>每个子类都要定义<code>__slots__</code>属性，因为解释器会忽略继承的<code>__slots__</code>属性。</li><li>实例只能拥有<code>__slots__</code>中列出的属性，除非把'<code>__dict__</code>'加入<code>__slots__</code>中（这样做就失去了节省内存的功效）。</li><li>如果不把'<code>__weakref__'</code>加入<code>__slots__</code>，实例就不能作为弱引用的目标。</li></ul><h1 id="覆盖类属性">覆盖类属性</h1><p>Python有个很独特的特性：类属性可用于为实例属性提供默认值。Vector2d中有个typecode类属性，<code>__bytes__</code>方法两次用到了它，而且都故意使用self.typecode读取它的值。因此Vector2d实例本身没有typecode属性，所以self.typecode默认获取的是Vector2d.typecode类属性的值。</p><p>但是，如果为不存在的实例属性赋值，会新建实例属性。假如我们为typecode实例属性赋值，那么同名类属性不受影响。然而，自此之后，实例读取的self.typecode是实例属性typecode，也就是把同名类属性遮盖了。借助这一特性，可以为各个实例的typecode属性定制不同的值。</p><p>Vector2d.typecode属性的默认值是'd'，即转换成字节序列时使用8字节双精度浮点数表示向量的各个分量。如果转换之前把Vector2d实例的typecode属性设为'f'，那么使用4字节的单精度浮点数表示各个分量。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector2d(<span class="number">1.1</span>, <span class="number">2.2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dumpd = bytes(v1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dumpd</span><br><span class="line"><span class="string">b'd\x9a\x99\x99\x99\x99\x99\xf1?\x9a\x99\x99\x99\x99\x99\x01@'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(dumpd)</span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1.typecode = <span class="string">'f'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dumpf = bytes(v1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dumpf</span><br><span class="line"><span class="string">b'f\xcd\xcc\x8c?\xcd\xcc\x0c@'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(dumpf)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Vector2d.typecode, v1.typecode</span><br><span class="line">(<span class="string">'d'</span>, <span class="string">'f'</span>)</span><br></pre></td></tr></table></figure><p>如果想修改类属性的值，必须直接在类上修改，不能通过实例修改。如果想修改所有实例（没有typecode实例变量）的typecode属性的默认值，可以这么做：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Vector2d.typecode = <span class="string">'f'</span></span><br></pre></td></tr></table></figure><p>然而，有种修改方法更符合Python风格，而且效果持久，也更有针对性。类属性是公开的，因此会被子类继承，于是经常会创建一个子类，只用于定制类的数据属性。Diango基于类的视图就大量使用了这个技术。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShortVector2d</span><span class="params">(Vector2d)</span>:</span></span><br><span class="line">    typecode = <span class="string">'f'</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象引用、可变性和垃圾回收</title>
      <link href="/notes/fluent-python/object-references-mutability-and-recycling/"/>
      <url>/notes/fluent-python/object-references-mutability-and-recycling/</url>
      
        <content type="html"><![CDATA[<h1 id="变量不是盒子">变量不是盒子</h1><p>以一个比喻说明Python的变量：变量是标注，而不是盒子。首先，我们要抛弃变量是存储数据的盒子这一错误观念。Python变量类似于Java中的引用式变量，因此最好把他们理解为附加在对象上的标注。在示例所示的交互式控制台中，无法使用“变量是盒子”做解释。而便利贴则指出了变量的正确工作方式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/fluent-python/variables-as-sticky-notes.png"></p><p>赋值方式：对引用式变量来说，说把变量分配给对象更合理，反过来说就有问题。毕竟，对象在赋值之前就创建了。下面的示例证明赋值语句的右边先执行。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Gizmo</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">'Gizmo id: %d'</span> %id(self))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = Gizmo()</span><br><span class="line">Gizmo id: <span class="number">4533161544</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = Gizmo() * <span class="number">10</span>  <span class="comment"># 在乘法运算中使用Gizmo实例会抛出异常</span></span><br><span class="line">Gizmo id: <span class="number">4533161376</span>  <span class="comment"># 在尝试求积之前会创建一个新的Gizmo实例</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unsupported operand type(s) <span class="keyword">for</span> *: <span class="string">'Gizmo'</span> <span class="keyword">and</span> <span class="string">'int'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir()  <span class="comment"># dir()的结果表明变量y没有被创建</span></span><br><span class="line">[<span class="string">'Gizmo'</span>, <span class="string">'__annotations__'</span>, <span class="string">'__builtins__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__loader__'</span>, <span class="string">'__name__'</span>, <span class="string">'__package__'</span>, <span class="string">'__spec__'</span>, <span class="string">'x'</span>]</span><br></pre></td></tr></table></figure><p>为了理解Python中的赋值居于，应该始终先读右边。对象在右边创建或获取，在此之后左边的变量才会绑定到对象上，这就像为对象贴上标注。因为变量只不过是标注，所以无法租出为对象贴上多个标注。贴的多个标注，就是别名。</p><h1 id="标识相等性和别名">标识、相等性和别名</h1><p>Lewis Carroll是Charles Lutwidge Dodgson教授的笔名。Carroll先生指的就是Dodgson教授，二者是同一个人。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>charles = &#123;<span class="string">'name'</span>: <span class="string">'Charles L. Dodgson'</span>, <span class="string">'born'</span>: <span class="number">1832</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lweis = charles</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lweis <span class="keyword">is</span> charles</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(charles), id(lweis)</span><br><span class="line">(<span class="number">4531455896</span>, <span class="number">4531455896</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lweis[<span class="string">'balance'</span>] = <span class="number">950</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>charles</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'Charles L. Dodgson'</span>, <span class="string">'born'</span>: <span class="number">1832</span>, <span class="string">'balance'</span>: <span class="number">950</span>&#125;</span><br></pre></td></tr></table></figure><p>然而，假如有冒充者（Alexander Pedachenko博士）生于1832年，声称他是Charles L. Dodgson。这个冒充者的证件可能一样，但是Pedachenko博士不是Dodgson教授。</p><p><img src="/uploads/image/fluent-python/python-is-and-equal.png"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>alex = &#123;<span class="string">'name'</span>: <span class="string">'Charles L. Dodgson'</span>, <span class="string">'born'</span>: <span class="number">1832</span>, <span class="string">'balance'</span>: <span class="number">950</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>alex == charles</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>alex <span class="keyword">is</span> <span class="keyword">not</span> charles</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(alex), id(charles)</span><br><span class="line">(<span class="number">4533183904</span>, <span class="number">4531455896</span>)</span><br></pre></td></tr></table></figure><p>每个变量都有标识、类型和值。对象一旦创建，它的标识绝不会变。is运算符比较两个对象的标识：id()函数返回对象表示的整数标识。</p><p>对象ID的真正意义在不同的实现中有所不同。在CPython中，id()返回对象的内存地址，但是在其他Python解释器中可能是别的值。关键是，ID一定是唯一的数值标注，而且在对象的生命周期中绝不会变。</p><h2 id="在和is之间选择">在==和is之间选择</h2><p>==运算符比较两个对象的值（对象中保存的数据），而is比较对象的标识。（==相当于Java中的equal()方法，而is相当于Java中的==）。通常，我们关注的是值，而不是标识，因此Python代码中==的出现频率比is高。</p><p><strong>然而，在变量和单例值之间比较时，应该使用is。目前，最常使用is检查变量绑定的值是不是None。</strong>下面是推荐的写法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>is运算符比==速度快，因为它不能重载，所以Python不用寻找并调用特殊方法，而是直接比较两个整数ID。而a==b是语法糖，等同于<code>a.__eq__(b)</code>。继承自object的<code>__eq__</code>方法比较两个对象的ID，结果与is一样，但是多数内置类型使用更有意义的方式覆盖了<code>__eq__</code>方法，会考虑对象属性的值。相等性测试可能涉及大量处理工作，例如，比较大型集合或嵌套层级深的机构时。</p><h2 id="元组的相对不变性">元组的相对不变性</h2><p>元素与多数Python集合（列表、字典、集，等等）一样，保存的是对象的引用（str、bytes和array.array等单一类型序列是扁平的，它们保存的不是引用，而是在连续的内容中保存数据本身）。如果引用的元素是可变的，即使元组本身不可变，元素依然可变。也就是说，元组的不可变性其实是指tuple数据结构的物理内容（即保存的引用）不可变，与引用的对象无关。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 == t2, t1 <span class="keyword">is</span> t2  <span class="comment"># t1与t2相等，但不是同一个对象</span></span><br><span class="line">(<span class="literal">True</span>, <span class="literal">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(t1[<span class="number">-1</span>])</span><br><span class="line"><span class="number">4533178056</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1[<span class="number">-1</span>].append(<span class="number">99</span>)  <span class="comment"># 改变t[-1]的内容</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(t1[<span class="number">-1</span>])  <span class="comment"># t[-1]的标识没变</span></span><br><span class="line"><span class="number">4533178056</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 == t2  <span class="comment"># 内容不再相等</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>来自2.6.1节的一个谜题：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>] += [<span class="number">50</span>, <span class="number">60</span>]</span><br></pre></td></tr></table></figure><p>上述两个表达式的运行结果是哪一个？</p><ol type="a"><li><p>t变成(1, 2, [30, 40, 50, 60])。</p></li><li><p>因为tuple不支持对它的元素赋值，所以会抛出TypeError异常。</p></li><li><p>以上两个都不是。</p></li><li><p>a和b都是对的。</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ========== 谜题答案 ==========</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>] += [<span class="number">50</span>, <span class="number">60</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>])  <span class="comment"># 由此可见谜题的答案是 d</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(<span class="string">'s[a] += b'</span>)  <span class="comment"># 查看 s[a] += b 背后的字节码</span></span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_NAME                <span class="number">0</span> (s)</span><br><span class="line">              <span class="number">2</span> LOAD_NAME                <span class="number">1</span> (a)</span><br><span class="line">              <span class="number">4</span> DUP_TOP_TWO</span><br><span class="line">              <span class="number">6</span> BINARY_SUBSCR                       <span class="comment"># 将s[a]的值存入TOS(Top Of Stack，栈的顶端)</span></span><br><span class="line">              <span class="number">8</span> LOAD_NAME                <span class="number">2</span> (b)</span><br><span class="line">             <span class="number">10</span> INPLACE_ADD                         <span class="comment"># 计算TOS += b。这一步能够完成，是因为TOS指向的是一个可变对象</span></span><br><span class="line">             <span class="number">12</span> ROT_THREE</span><br><span class="line">             <span class="number">14</span> STORE_SUBSCR                        <span class="comment"># s[a] = TOS赋值。这一步失败，是因为s是不可变的元组</span></span><br><span class="line">             <span class="number">16</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">18</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><p>这其实是个非常罕见的边界情况，在15年的Python生涯中，我还没见过谁在这个地方吃过亏。至此我得到了3个教训。</p><ul><li>不要把可变对象放在元组里面。</li><li>增量赋值不是一个原子操作。我们刚才也看到了，它虽然抛出了异常，但还是完成了操作。</li><li>查看Python的字节码并不难，而且它对我们了解代码背后的运行机制很有帮助。</li></ul><h1 id="默认做浅复制">默认做浅复制</h1><p>复制列表（或多数内置的可变集合）最简单的方式是使用内置的类型构造方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="number">3</span>, [<span class="number">55</span>, <span class="number">44</span>], (<span class="number">7</span>, <span class="number">8</span> ,<span class="number">9</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 = list(l1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 == l1, l2 <span class="keyword">is</span> l1  <span class="comment"># 二者相等，但不是同一个对象</span></span><br><span class="line">(<span class="literal">True</span>, <span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>对列表和其他可变序列来说，还能使用简洁的l2=l1[:]语句创建副本。然而，构造方法或[:]做的是浅复制（即复制了最外层容器，副本中的元素是源容器中元素的引用）。如果所有元素都是不可变的，那么这样没有问题，还能节省内存。但是，如果有可变的元素，可能就会导致意想不到的问题。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="number">3</span>, [<span class="number">66</span>, <span class="number">55</span>, <span class="number">44</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 = list(l1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1[<span class="number">1</span>] <span class="keyword">is</span> l2[<span class="number">1</span>], l1[<span class="number">2</span>] <span class="keyword">is</span> l2[<span class="number">2</span>]  <span class="comment"># 浅复制复制的是引用</span></span><br><span class="line">(<span class="literal">True</span>, <span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1.append(<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1[<span class="number">1</span>].remove(<span class="number">55</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1</span><br><span class="line">[<span class="number">3</span>, [<span class="number">66</span>, <span class="number">44</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>), <span class="number">100</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2</span><br><span class="line">[<span class="number">3</span>, [<span class="number">66</span>, <span class="number">44</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2[<span class="number">1</span>] += [<span class="number">33</span>, <span class="number">22</span>]  <span class="comment"># 对可变的对象来说，+=运算符就地修改列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2[<span class="number">2</span>] += (<span class="number">10</span>, <span class="number">11</span>)  <span class="comment"># 对元组来说，+=运算符创建一个新元组，然后重新绑定给变量</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1</span><br><span class="line">[<span class="number">3</span>, [<span class="number">66</span>, <span class="number">44</span>, <span class="number">33</span>, <span class="number">22</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>), <span class="number">100</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2</span><br><span class="line">[<span class="number">3</span>, [<span class="number">66</span>, <span class="number">44</span>, <span class="number">33</span>, <span class="number">22</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>)]</span><br></pre></td></tr></table></figure><h2 id="为任意对象做深复制和浅复制">为任意对象做深复制和浅复制</h2><p>copy模块提供的deepcopy和copy函数能为任意对象做深复制和浅复制。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bus</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, passengers=None)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> passengers <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="meta">... </span>            self.passengers = []</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>            self.passengers = list(passengers)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.passengers.append(name)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">drop</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.passengers.remove(name)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> copy <span class="keyword">import</span> copy, deepcopy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1 = Bus([<span class="string">'Alice'</span>, <span class="string">'Bill'</span>, <span class="string">'Claire'</span>, <span class="string">'David'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2 = copy(bus1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3 = deepcopy(bus1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(bus1), id(bus2), id(bus3)  <span class="comment"># 3个不同的实例</span></span><br><span class="line">(<span class="number">4533933560</span>, <span class="number">4533933840</span>, <span class="number">4533934232</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1.drop(<span class="string">'Bill'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2.passengers  <span class="comment"># bus1中的Bill下车后，bus2中也没有他了</span></span><br><span class="line">[<span class="string">'Alice'</span>, <span class="string">'Claire'</span>, <span class="string">'David'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3.passengers</span><br><span class="line">[<span class="string">'Alice'</span>, <span class="string">'Bill'</span>, <span class="string">'Claire'</span>, <span class="string">'David'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(bus1.passengers), id(bus2.passengers), id(bus3.passengers)  <span class="comment"># 审查passengers属性，bus1和bus2共享同一个列表对象（浅复制）</span></span><br><span class="line">(<span class="number">4533897800</span>, <span class="number">4533897800</span>, <span class="number">4533249800</span>)</span><br></pre></td></tr></table></figure><p>一般来说，深复制不是件简单的事。如果对象有循环引用，那么这个朴素的算法会进入无限循环。deepcopy函数会记住已经复制的对象，因此能优雅地处理循环引用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [a, <span class="number">30</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>, [[...], <span class="number">30</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = deepcopy(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>, [[...], <span class="number">30</span>]]</span><br></pre></td></tr></table></figure><p>此外，深复制有时可能太深了。例如，对象可能会引用不该复制的外部资源或单例值。我们可以实现特殊方法<code>__copy__()</code>和<code>__deepcopy__()</code>，控制copy和deepcopy的行为。</p><h1 id="函数的参数作为引用时">函数的参数作为引用时</h1><p>Python唯一支持的参数传递模式是共享参数（call by sharing）。多数面向对象语言都采用这一模式。共享传参指函数的各个形式参数获得实参中各个引用的副本，也就是说，函数内部的形参是实参的别名。这种方案的结果是，函数可能会修改作为参数传入的可变对象，但是无法修改那些对象的标识。</p><h2 id="不要使用可变类型作为参数的默认值">不要使用可变类型作为参数的默认值</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">HauntedBus</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">"""备受幽灵乘客折磨的校车"""</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, passengers=[])</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.passengers = passengers</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.passengers.append(name)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">drop</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.passengers.remove(name)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1 = HauntedBus([<span class="string">'Alice'</span>, <span class="string">'Bill'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1.pick(<span class="string">'Charlie'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1.drop(<span class="string">'Alice'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1.passengers</span><br><span class="line">[<span class="string">'Bill'</span>, <span class="string">'Charlie'</span>]  <span class="comment"># 不使用默认值没什么问题</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2 = HauntedBus()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2.pick(<span class="string">'Carrie'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2.passengers</span><br><span class="line">[<span class="string">'Carrie'</span>]  <span class="comment"># 使用默认值，目前为止也没什么问题</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3 = HauntedBus()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3.passengers  <span class="comment"># bus3不是预期中的空车</span></span><br><span class="line">[<span class="string">'Carrie'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3.pick(<span class="string">'Dave'</span>)  <span class="comment"># Dave登上bus3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2.passengers  <span class="comment"># Dave出现在了bus2中</span></span><br><span class="line">[<span class="string">'Carrie'</span>, <span class="string">'Dave'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3.passengers <span class="keyword">is</span> bus2.passengers  <span class="comment"># passergers属性是同一个对象</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>问题在于，没有指定初始乘客的HauntedBus实例会共享同一个乘客列表。这是因为self.passengers变成了passengers参数默认值的别名。出现这个问题的根源是，默认值在定义函数时计算（通常在加载模块时），因此默认值变成了函数对象的属性。因此，如果默认值是可变对象，而且修改了它的值，那么后续的函数调用都会受到影响。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>HauntedBus.__init__.__defaults__</span><br><span class="line">([<span class="string">'Carrie'</span>, <span class="string">'Dave'</span>],)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>HauntedBus.__init__.__defaults__[<span class="number">0</span>] <span class="keyword">is</span> bus2.passengers <span class="keyword">is</span> bus3.passengers</span><br><span class="line"><span class="literal">True</span>  <span class="comment"># 使用默认值的实例，其passengers属性实际上都是默认值[]的别名</span></span><br></pre></td></tr></table></figure><h2 id="防御可变参数">防御可变参数</h2><p>如果定义的函数接收可变参数，应该谨慎考虑调用方是否期望修改传入的参数。具体情况具体分析，这其实需要函数的编写者和调用方达成共识。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">TwilightBus</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">"""让乘客销声匿迹的校车</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    一个简单的类，说明接受可变参数的风险"""</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, passengers=None)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> passengers <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="meta">... </span>            self.passengers = <span class="literal">None</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>            self.passengers = passengers  <span class="comment"># self.passengers变成passengers的别名</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.passengers.append(name)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">drop</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.passengers.remove(name)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>basketball_team = [<span class="string">'Sue'</span>, <span class="string">'Tina'</span>, <span class="string">'Maya'</span>, <span class="string">'Diana'</span>, <span class="string">'Pat'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus = TwilightBus(basketball_team)  <span class="comment"># self.passengers变成了实参basketball_team的别名</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus.drop(<span class="string">'Tina'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus.drop(<span class="string">'Pat'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>basketball_team  <span class="comment"># 下车的学生从篮球队中消失了</span></span><br><span class="line">[<span class="string">'Sue'</span>, <span class="string">'Maya'</span>, <span class="string">'Diana'</span>]</span><br></pre></td></tr></table></figure><p>TwilightBus违反了设计接口的最佳实践，即“最少惊讶原则”。正确的做法是，校车自己维护乘客列表。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, passengers=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> passengers <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self.passengers = []</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.passengers = list(passengers)  <span class="comment"># 修改此处，创建passengers的副本，然后赋值给self.passengers</span></span><br></pre></td></tr></table></figure><p>在内部像这样处理乘客列表，就不会影响初始化校车时传入的参数了。此外，这种处理方式还更灵活：现在传给passengers参数的值可以是元组或任何其他可迭代对象，例如set对象，甚至数据库查询结果。</p><h1 id="del和垃圾回收">del和垃圾回收</h1><p>del语句删除名称，而不是对象。del命令可能会导致对象被当作垃圾回收，但是仅当删除的变量保存的是对象的最后一个引用，或者无法得到对象时（如果两个对象相互引用，当它们的引用只存在二者之间时，垃圾回收程序会判定它们无法获取，进而把它们都销毁）。重新绑定也可能会导致对象的引用数量归零，导致对象被销毁。</p><p>有个<code>__del__</code>特殊方法，它是他不会销毁实例，不应该在代码中调用。即将销毁实例时，Python解释器会调用<code>__del__</code>方法，给实例最后的机会，释放外部资源。自己编写的代码很少需要实现<code>__del__</code>。</p><p>在CPython中，垃圾回收使用的主要算法是引用计数。实际上，每个对象都会统计有多少引用指向自己。当引用计数归零时，对象立即就被销毁：CPython会在对象上调用<code>__del__</code>方法（如果定义了），然后释放分配给对象的内存。CPython 2.0增加了分代垃圾回收算法，用于检测引用循环中涉及的对象组——如果一组对象之间全是相互引用，即使再出色的引用方式也会导致组中的对象不可获取。Python的其他实现有更复杂的垃圾回收程序，而且不依赖引用计数，这意味着，对象的引用数量归零时可能不会立即调用<code>__del__</code>方法。</p><p>对了演示对象生命结束时的情形，使用weakref.finalize注册一个回调函数，在销毁对象时调用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> weakref</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = s1  <span class="comment"># s1和s2指向同一个集合</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">bye</span><span class="params">()</span>:</span>  <span class="comment"># 这个函数一定不能是要销毁的对象的绑定方法，否则会有一个指向对象的引用</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Gone with the wind...'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ender = weakref.finalize(s1, bye)  <span class="comment"># 在s1引用的对象上注册bye回调，finalize持有&#123;1, 2, 3&#125;的弱引用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ender.alive</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> s1  <span class="comment"># 删除引用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ender.alive  <span class="comment"># 对象依然存在</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = <span class="string">'spam'</span>  <span class="comment"># 重新绑定了s2，原来的集合对象无法获取，对象被销毁了</span></span><br><span class="line">Gone <span class="keyword">with</span> the wind...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ender.alive</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="弱引用">弱引用</h1><p>弱引用不会增加对象的引用数量。引用的目标对象称为所指对象（referent）。因此，弱引用不会妨碍所指对象被当作垃圾回收。弱引用在缓存应用中很有用，因为我们不想仅因为被缓存引用着而始终保存缓存对象。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_set = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref = weakref.ref(a_set)  <span class="comment"># 创建弱引用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref  <span class="comment"># 审查</span></span><br><span class="line">&lt;weakref at <span class="number">0x10e3dae08</span>; to <span class="string">'set'</span> at <span class="number">0x10e326ac8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref()  <span class="comment"># 调用wref()返回的是被引用的对象。因为这是控制台会话，所以&#123;0, 1&#125;会绑定给 _ 变量</span></span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_set = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;  <span class="comment"># &#123;0, 1&#125;的引用数减少了，但是 _ 变量仍然指代它</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref()  <span class="comment"># 依旧返回&#123;0, 1&#125;</span></span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref() <span class="keyword">is</span> <span class="literal">None</span>  <span class="comment"># 计算表达式时，&#123;0, 1&#125;存在，因此返回False，随后 _ 绑定到结果值False，现在&#123;0, 1&#125;没有强引用了</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref() <span class="keyword">is</span> <span class="literal">None</span>  <span class="comment"># &#123;0, 1&#125;对象不存在了，所以返回True</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p><a href="http://docs.python.org/3/library/weakref.html" target="_blank" rel="noopener">weakref模块的文档</a>指出，weakref.ref类其实是底层接口，供高级用途使用，多数程序最好使用weakref集合和finalize。也就是说，应该使用WeakKeyDictionary、WeakValueDictionary、WeakSet和finalize（在内部使用弱引用），不要自己动手创建并处理weakref.ref实例。</p><h2 id="weakvaluedictionary简介">WeakValueDictionary简介</h2><p>WeakValueDictionary类实现的是一种可变映射，里面的值是对象的弱引用，被引用的对象在程序的其他地方被当作垃圾回收后，对应的键会自动从WeakValueDictionary中删除。因此WeakValueDictionary经常用于缓存。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Cheese</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, kind)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.kind = kind</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">'Cheese(%r)'</span> % self.kind</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> weakref</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stock = weakref.WeakValueDictionary()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>catalog = [Cheese(<span class="string">'Red Leicester'</span>), Cheese(<span class="string">'Tilsit'</span>), Cheese(<span class="string">'Brie'</span>), Cheese(<span class="string">'Parmesan'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> cheese <span class="keyword">in</span> catalog:  <span class="comment"># 循环中cheese是全局变量，循环结束后也不会消失</span></span><br><span class="line"><span class="meta">... </span>    stock[cheese.kind] = cheese</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(stock.keys())  <span class="comment"># stock是完整的</span></span><br><span class="line">[<span class="string">'Brie'</span>, <span class="string">'Parmesan'</span>, <span class="string">'Red Leicester'</span>, <span class="string">'Tilsit'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> catalog</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(stock.keys())  <span class="comment"># 为什么会剩下一个</span></span><br><span class="line">[<span class="string">'Parmesan'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> cheese  <span class="comment"># 临时变量cheese引用了对象，导致该变量存在时间比预期长</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(stock.keys())</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><p>与WeakValueDictionary对应的是WeakKeyDictionary，后者的键是弱引用。WeakKeyDictionary实例可以为应用中其他部分拥有的对象附加数据，这样就无需为对象添加属性。这对覆盖属性访问权限的对象尤其有用。WeakSet类：保存元素弱引用的集合类。元素没有强应用时，集合会把它删除。</p><h2 id="弱引用的局限">弱引用的局限</h2><p>不是每个Python对象都可以作为弱引用的目标（或称所指对象）。基本的list和dict实例不能作为所指对象，但是他们的子类可以轻松地解决这个问题。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="string">"""list的子类，实例可以作为弱引用的目标"""</span></span><br><span class="line"></span><br><span class="line">a_list = MyList(range(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># a_list可以作为弱引用的目标</span></span><br><span class="line">wref_to_a_list = weakref.ref(a_list)</span><br></pre></td></tr></table></figure><p>set实例可以作为所指对象（因此前面的实例才使用{0, 1}），用户定义的类型也没问题（Cheese类）。但是，int和tuple实例不能作为弱引用的目标，甚至它们的子类也不行。这些局限基本上是CPython的实现细节，在其他Python解释器中情况可能不一样，这些局限是内部优化导致的结果。</p><h1 id="python对不可变类型施加的把戏">Python对不可变类型施加的把戏</h1><p>对元组t来说，t[:]不创建副本，而是返回同一个对象的引用。此外，tuple(t)获得的也是同一个元组的引用。在Python控制台中输入help(tuple)，你会看到这句话：“If the argument is a tuple, the return value is the same object.”。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 = tuple(t1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 <span class="keyword">is</span> t1</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t3 = t1[:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t3 <span class="keyword">is</span> t1</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>str、bytes和frozenset实例也有这种行为。frozenset实例不是序列，不能使用fs[:]，但是fs.copy()具有相同的效果：它会欺骗你，返回同一个对象的引用，而不是创建一个副本。copy方法不会复制所有对象，这是一个善意的谎言，为的是接口的兼容性：这使得frozenset的兼容性比set强。两个不可变对象是同一个对象还是副本，对最终用户来说没有区别。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t3 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 <span class="keyword">is</span> t3  <span class="comment"># t1和t3不是同一个对象</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = <span class="string">'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = <span class="string">'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 <span class="keyword">is</span> s2  <span class="comment"># 奇怪的事情发生了，s1和s2指代同一个字符串</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>共享字符串字面量是一种优化措施，称为驻留（interning）。CPython还会在小的整数上使用这个优化措施，防止重复创建“热门”数字。注意，CPython不会驻留所有字符串和整数，驻留的条件是实现细节，而且没有文档说明。因此，千万不要依赖字符串或整数的驻留！比较字符串或整数是否相等时，应该使用==，而不是is。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标准库中的装饰器</title>
      <link href="/notes/fluent-python/decorators-in-standard-library/"/>
      <url>/notes/fluent-python/decorators-in-standard-library/</url>
      
        <content type="html"><![CDATA[<p>标准库中最值得关注的两个装饰器是lru_cache和全新的singledispatch（Python3.4新增）。这两个装饰器都在functools模块中定义。</p><h1 id="使用lru_cache做备忘">使用lru_cache做备忘</h1><p>functools.lru_cache实现了备忘（memoization）功能。这是一项优化技术，它把耗时的函数的结果保存起来，避免传入相同的参数时重复计算。LRU三个字母是“Least Recently Used”的缩写，表明缓存不会无限制增长，一段时间不用的缓存条目会被扔掉。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/functools#functools.lru_cache" target="_blank" rel="noopener"><code>@functools.lru_cache(maxsize=128, typed=False)</code></a></p><p>maxsize参数指定存储多少个调用的结果。缓存满了之后，旧的结果会被扔掉，腾出空间。为了得到最佳性能，maxsize应该设为2的幂。</p><p>Typed参数如果设为True，把不同类型参数得到的结果分开保存，即把通常认为相同的浮点数和整数参数（如1和1.0）区分开。</p><p>lru_cache使用字典存储结果，而且键根据调用时传入的定位参数和关键字参数创建，所以被lru_cache装饰的函数，它的所有参数都必须是可散列的。</p></blockquote><a id="more"></a><p>生成第n个斐波那契这种慢速递归函数适合使用lru_cache。</p><figure class="highlight python"><figcaption><span>clockdemo.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        t0 = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        elapsed = time.time() - t0</span><br><span class="line">        name = func.__name__</span><br><span class="line">        arg_lst = []</span><br><span class="line">        <span class="keyword">if</span> args:</span><br><span class="line">            arg_lst.append(<span class="string">', '</span>.join(repr(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args))</span><br><span class="line">        <span class="keyword">if</span> kwargs:</span><br><span class="line">            pairs = [<span class="string">'%s=%r'</span> % (k, w) <span class="keyword">for</span> k, w <span class="keyword">in</span> sorted(kwargs.items())]</span><br><span class="line">            arg_lst.append(<span class="string">', '</span>.join(pairs))</span><br><span class="line">        arg_str = <span class="string">', '</span>.join(arg_lst)</span><br><span class="line">        print(<span class="string">'[%0.8fs] %s(%s) -&gt; %r '</span> % (elapsed, name, arg_str, result))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clocked</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> clockdemo <span class="keyword">import</span> clock</span><br><span class="line"></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">2</span>) + fibonacci(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(fibonacci(<span class="number">6</span>))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[0.00000095s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000095s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00005102s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00000072s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000787s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00001478s] fibonacci(3) -&gt; 2</span><br><span class="line">[0.00007391s] fibonacci(4) -&gt; 3</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000691s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00001407s] fibonacci(3) -&gt; 2</span><br><span class="line">[0.00000119s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000691s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000095s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000834s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00001383s] fibonacci(3) -&gt; 2</span><br><span class="line">[0.00002813s] fibonacci(4) -&gt; 3</span><br><span class="line">[0.00005007s] fibonacci(5) -&gt; 5</span><br><span class="line">[0.00013185s] fibonacci(6) -&gt; 8</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>浪费时间的地方很明显：fibonacci(1)调用了8次，fibonacci(2)调用了5次……下面使用缓存实现，速度更快。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">from</span> clockdemo <span class="keyword">import</span> clock</span><br><span class="line"></span><br><span class="line"><span class="meta">@functools.lru_cache()  # 必须加括号，因为lru_cache可以接受配置参数，lru_cache应用到clock返回的函数上</span></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">2</span>) + fibonacci(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(fibonacci(<span class="number">6</span>))</span><br></pre></td></tr></table></figure><p>执行时间减半了，而且n的每个值只调用一次函数。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[0.00000000s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000119s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00004601s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00000119s] fibonacci(3) -&gt; 2</span><br><span class="line">[0.00005412s] fibonacci(4) -&gt; 3</span><br><span class="line">[0.00000000s] fibonacci(5) -&gt; 5</span><br><span class="line">[0.00006390s] fibonacci(6) -&gt; 8</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>除了优化递归算法之外，lru_cache在从Web中获取信息的应用中也能发挥巨大作用。</p><h1 id="单分派泛函数">单分派泛函数</h1><p>假设我们在开发一个调试Web应用的工具，想生成HTML，显示不同类型的Python对象。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> html</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">htmlize</span><span class="params">(obj)</span>:</span></span><br><span class="line">    content = html.escape(repr(obj))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;pre&gt;&#123;&#125;&lt;/pre&gt;'</span>.format(content)</span><br></pre></td></tr></table></figure><p>这个函数适用于任何Python类型，但是现在想做个扩展，让它使用特别的方式显示某些类型。</p><ul><li>str: 把内部的换行符替换为'&lt;br&gt;\n'；不使用&lt;pre&gt;，而是使用&lt;p&gt;。</li><li>int: 以十进制和十六进制显示数字。</li><li>list: 输出一个HTML列表，根据各个元素的类型进行格式化。</li></ul><p>因为Python不支持重载方法或函数，所以不能使用不同的签名定义htmlize的变体，也无法使用不同的方式处理不同的数据类型。在Python中，一种常见的做法是把htmlize变成一个分派函数，使用一串if/elif/elif，调用专门的函数，如htmlize_str、htmlize_int，等等。这样不便于模块的用户扩展，还显得笨拙：时间一长，分派函数htmlize会变得很大，而且它与各个专门函数之间的耦合也很紧密。</p><p>Python3.4新增的functools.singledispatch装饰器可以把整体方案拆分成多个模块，甚至可以为你无法修改的类提供专门的函数。使用@singledispatch装饰的普通函数会变成泛函数（generic function）：根据第一个参数的类型，以不同方式执行相同操作的一组函数。（这才称得上是单分派。如果根据多个参数选择专门的函数，那就是多分派了。）具体做法如下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"><span class="keyword">import</span> numbers</span><br><span class="line"><span class="keyword">import</span> html</span><br><span class="line"></span><br><span class="line"><span class="meta">@singledispatch  # 标记处理object函数的基函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">htmlize</span><span class="params">(obj)</span>:</span></span><br><span class="line">    content = html.escape(repr(obj))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;pre&gt;&#123;&#125;&lt;/pre&gt;'</span>.format(content)</span><br><span class="line"></span><br><span class="line"><span class="meta">@htmlize.register(str)  # 专门函数，函数名称无关紧要，_是个不错的选择</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(text)</span>:</span></span><br><span class="line">    content = html.escape(text).replace(<span class="string">'\n'</span>, <span class="string">'&lt;br&gt;\n'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;p&gt;&#123;0&#125;&lt;/p&gt;'</span>.format(content)</span><br><span class="line"></span><br><span class="line"><span class="meta">@htmlize.register(numbers.Integral)  # numbers.Integral是int的虚拟超类</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;pre&gt;&#123;0&#125; (0x&#123;0:x&#125;)&lt;/pre&gt;'</span>.format(n)</span><br><span class="line"></span><br><span class="line"><span class="meta">@htmlize.register(tuple)  # 可以叠放多个register装饰器，让同一个函数支持不同类型</span></span><br><span class="line"><span class="meta">@htmlize.register(abc.MutableSequence)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(seq)</span>:</span></span><br><span class="line">    inner = <span class="string">'&lt;/li&gt;\n&lt;li&gt;'</span>.join(htmlize(item) <span class="keyword">for</span> item <span class="keyword">in</span> seq)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;ul&gt;\n&lt;li&gt;'</span> + inner + <span class="string">'&lt;/li&gt;\n&lt;/ul&gt;'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(repr(htmlize(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)), <span class="string">'\n'</span>)</span><br><span class="line">    print(repr(htmlize(abs)), <span class="string">'\n'</span>)</span><br><span class="line">    print(repr(htmlize(<span class="string">'Heimlich &amp; Co.\n- a game'</span>)), <span class="string">'\n'</span>)</span><br><span class="line">    print(repr(htmlize(<span class="number">42</span>)), <span class="string">'\n'</span>)</span><br><span class="line">    print(htmlize([<span class="string">'alpha'</span>, <span class="number">66</span>, &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;]))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;&lt;pre&gt;&#123;1, 2, 3&#125;&lt;/pre&gt;&apos;</span><br><span class="line"></span><br><span class="line">&apos;&lt;pre&gt;&amp;lt;built-in function abs&amp;gt;&lt;/pre&gt;&apos;</span><br><span class="line"></span><br><span class="line">&apos;&lt;p&gt;Heimlich &amp;amp; Co.&lt;br&gt;\n- a game&lt;/p&gt;&apos;</span><br><span class="line"></span><br><span class="line">&apos;&lt;pre&gt;42 (0x2a)&lt;/pre&gt;&apos;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;&lt;p&gt;alpha&lt;/p&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;pre&gt;66 (0x42)&lt;/pre&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;pre&gt;&#123;1, 2, 3&#125;&lt;/pre&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>只要可能，注册的专门函数应该处理抽象基类（如numbers.Integral和abc.MutableSequence），不要处理具体实现类（如int和list）。这样，代码支持的兼容类型更广泛。</p><p>singledispatch机制的一个显著特征是，你可以在系统的任何地方和任何模块中注册专门函数。如果后来在新的模块中定义了新的类型，可以轻松地添加一个新的专门函数用来处理那个类型。此外，还可以为不是自己编写的或者不能修改的类添加自定义函数。</p><p>singledispatch提供的特性很多，这个机制最好的文档是 <a href="https://www.python.org/dev/peps/pep-0443/" target="_blank" rel="noopener">PEP 443 —— Single-dispatch generic functions</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> decorators </tag>
            
            <tag> Fluent Python </tag>
            
            <tag> lru_cache </tag>
            
            <tag> singledispatch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现一个简单的装饰器</title>
      <link href="/notes/fluent-python/implementing-a-simple-decorator/"/>
      <url>/notes/fluent-python/implementing-a-simple-decorator/</url>
      
        <content type="html"><![CDATA[<h1 id="一个简单的clock装饰器">一个简单的clock装饰器</h1><p>定义一个装饰器，它会在每次调用被装饰的函数时计时，然后把经过的时间、传入的参数和调用的结果打印出来。</p><figure class="highlight python"><figcaption><span>clockdeco_demo.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*args)</span>:</span>  <span class="comment"># 定义内部函数clocked，它接受任意个定位参数</span></span><br><span class="line">        t0 = time.perf_counter()</span><br><span class="line">        result = func(*args)  <span class="comment"># func是自由变量</span></span><br><span class="line">        elapsed = time.perf_counter() - t0</span><br><span class="line">        name = func.__name__</span><br><span class="line">        arg_str = <span class="string">', '</span>.join(repr(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args)</span><br><span class="line">        print(<span class="string">'[%0.8fs] %s(%s) -&gt; %r'</span> % (elapsed, name, arg_str, result))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clocked  <span class="comment"># 返回内部函数，取代被装饰的函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@clock  # 示例</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snooze</span><span class="params">(seconds)</span>:</span></span><br><span class="line">    time.sleep(seconds)</span><br><span class="line"></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'*'</span> * <span class="number">40</span>, <span class="string">'Calling snooze(.123)'</span>)</span><br><span class="line">    snooze(<span class="number">.123</span>)</span><br><span class="line">    print(<span class="string">'*'</span> * <span class="number">40</span>, <span class="string">'Calling factorial(6)'</span>)</span><br><span class="line">    print(<span class="string">'6! ='</span>, factorial(<span class="number">6</span>))</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**************************************** Calling snooze(.123)</span><br><span class="line">[0.12325113s] snooze(0.123) -&gt; None</span><br><span class="line">**************************************** Calling factorial(6)</span><br><span class="line">[0.00000078s] factorial(1) -&gt; 1</span><br><span class="line">[0.00003158s] factorial(2) -&gt; 2</span><br><span class="line">[0.00010166s] factorial(3) -&gt; 6</span><br><span class="line">[0.00043166s] factorial(4) -&gt; 24</span><br><span class="line">[0.00044242s] factorial(5) -&gt; 120</span><br><span class="line">[0.00045205s] factorial(6) -&gt; 720</span><br><span class="line">6! = 720</span><br></pre></td></tr></table></figure><h1 id="工作原理">工作原理</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">factorial = clock(factorial)</span><br></pre></td></tr></table></figure><p>因此，在两个示例中，factorial会作为func参数传给clock。然后，clock函数会返回clocked函数，Python解释器在背后会把clocked赋值给factorial。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> clockdeco_demo  <span class="comment"># 导入模块</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>clockdeco_demo.factorial.__name__  <span class="comment"># factorial的__name__</span></span><br><span class="line"><span class="string">'clocked'</span></span><br></pre></td></tr></table></figure><p>所以，现在factorial保存的是clocked函数的引用。自此之后，每次调用factorial(n)，执行的都是clocked(n)。这是装饰器的典型行为：把被装饰的函数替换成新函数，二者接受相同的参数，而且（通常）返回被装饰的函数本该返回的值，同时还会做些额外操作。</p><p><em>Gamma等人写的《设计模式：可复用面向对象软件的基础》一书是这样概述装饰器模式的：“动态地给一个对象添加一些额外的职责。”函数装饰器符合这一说法，但是，在实现层面，Python装饰器与GoF所述的装饰器没有多少相似之处。</em></p><p>上例实现的clock装饰器有几个缺点：不支持关键字参数，而且遮盖了被装饰函数的<code>__name__</code>和<code>__doc__</code>属性，下面使用functools.wraps装饰器把相关的属性从func复制到clocked中。此外，还能正确处理关键字参数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(func)</span>:</span>  <span class="comment"># 新版clock</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)  # 标准库中的装饰器之一</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*args, **kwargs)</span>:</span>  <span class="comment"># 接受定位和关键字参数</span></span><br><span class="line">        t0 = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        elapsed = time.time() - t0</span><br><span class="line">        name = func.__name__</span><br><span class="line">        arg_lst = []</span><br><span class="line">        <span class="keyword">if</span> args:</span><br><span class="line">            arg_lst.append(<span class="string">', '</span>.join(repr(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args))</span><br><span class="line">        <span class="keyword">if</span> kwargs:</span><br><span class="line">            pairs = [<span class="string">'%s=%r'</span> % (k, w) <span class="keyword">for</span> k, w <span class="keyword">in</span> sorted(kwargs.items())]</span><br><span class="line">            arg_lst.append(<span class="string">', '</span>.join(pairs))</span><br><span class="line">        arg_str = <span class="string">', '</span>.join(arg_lst)</span><br><span class="line">        print(<span class="string">'[%0.8fs] %s(%s) -&gt; %r '</span> % (elapsed, name, arg_str, result))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clocked</span><br><span class="line"></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  <span class="comment"># 测试</span></span><br><span class="line">    print(<span class="string">'6! ='</span>, factorial(n=<span class="number">6</span>))</span><br><span class="line">    print(factorial.__name__)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[0.00000000s] factorial(1) -&gt; 1</span><br><span class="line">[0.00003505s] factorial(2) -&gt; 2</span><br><span class="line">[0.00014687s] factorial(3) -&gt; 6</span><br><span class="line">[0.00014997s] factorial(4) -&gt; 24</span><br><span class="line">[0.00015521s] factorial(5) -&gt; 120  # 递归是通过定位传入的</span><br><span class="line">[0.00015807s] factorial(n=6) -&gt; 720  # 最外层是通过关键词传入的</span><br><span class="line">6! = 720</span><br><span class="line">factorial  # 函数的__name__属性也被复制过来了</span><br></pre></td></tr></table></figure><h1 id="叠放装饰器">叠放装饰器</h1><p>把 <span class="citation" data-cites="d1">@d1</span> 和 <span class="citation" data-cites="d2">@d2</span> 两个装饰器按顺序应用到 f 函数上，作用相当于 <code>f = d1(d2(f)</code>)。在<a href="/notes/fluent-python/decorators-in-standard-library/" title="标准库中的函数">标准库中的函数</a>一节中使用过该技巧：<span class="citation" data-cites="lru_cache">@lru_cache</span> 应用到 <span class="citation" data-cites="clock">@clock</span> 装饰 fibonacci 得到的结果上。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@d1</span></span><br><span class="line"><span class="meta">@d2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'f'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'f'</span>)</span><br><span class="line"></span><br><span class="line">f = d1(d2(f))</span><br></pre></td></tr></table></figure><h1 id="参数化装饰器">参数化装饰器</h1><p>解析源码中的装饰器时，Python把被装饰的函数作为第一个参数传给装饰器函数。那怎么让装饰器接受其他参数呢？答案是：创建一个装饰器工厂函数，把参数传给它，返回一个装饰器，然后再把它应用到要装饰的函数上。例如下面的装饰器。</p><figure class="highlight python"><figcaption><span>registration.py</span></figcaption><table><tr><td class="code"><pre><span class="line">registry = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">'running register(%s)'</span> % func)</span><br><span class="line">    registry.append(func)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f1()'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'running main()'</span>)</span><br><span class="line">print(<span class="string">'registry -&gt;'</span>, registry)</span><br><span class="line">f1()</span><br></pre></td></tr></table></figure><p>为了便于启用或禁用register执行的函数注册功能，为它提供一个可选的active参数，设为False时，不注册被装饰的函数。</p><figure class="highlight python"><figcaption><span>registration_param.py</span></figcaption><table><tr><td class="code"><pre><span class="line">registry = set()  <span class="comment"># 便于添加和删除对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(active=True)</span>:</span>  <span class="comment"># 接受一个可选的关键字参数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span>  <span class="comment"># 真正的装饰器，其参数是函数</span></span><br><span class="line">        print(<span class="string">'running register(active=%s)-&gt;decorate(%s)'</span> % (active, func))</span><br><span class="line">        <span class="keyword">if</span> active:</span><br><span class="line">            registry.add(func)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            registry.discard(func)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> func  <span class="comment"># 返回一个函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decorate  <span class="comment"># register时装饰器工厂函数，因此返回decorate</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@register(active=False)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f1()'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@register()  # 即使不传入参数，也必须作为函数调用（@register()）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f2()'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f3()'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> registration_param <span class="keyword">import</span> *  <span class="comment"># 导入</span></span><br><span class="line">running register(active=False)-&gt;decorate(&lt;function f1 at 0x109fd0bf8&gt;)</span><br><span class="line">running register(active=True)-&gt;decorate(&lt;function f2 at 0x109fd0c80&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>registry</span><br><span class="line">&#123;&lt;function f2 at <span class="number">0x109fd0c80</span>&gt;&#125;  <span class="comment"># 只有f2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>register()(f3)  <span class="comment"># register()返回decoratro，然后应用到f3上</span></span><br><span class="line">running register(active=True)-&gt;decorate(&lt;function f3 at 0x109fd0b70&gt;)</span><br><span class="line">&lt;function f3 at <span class="number">0x109fd0b70</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>registry</span><br><span class="line">&#123;&lt;function f2 at <span class="number">0x109fd0c80</span>&gt;, &lt;function f3 at <span class="number">0x109fd0b70</span>&gt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>register(active=<span class="literal">False</span>)(f2)  <span class="comment"># 删除f2</span></span><br><span class="line">running register(active=False)-&gt;decorate(&lt;function f2 at 0x109fd0c80&gt;)</span><br><span class="line">&lt;function f2 at <span class="number">0x109fd0c80</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>registry</span><br><span class="line">&#123;&lt;function f3 at <span class="number">0x109fd0b70</span>&gt;&#125;</span><br></pre></td></tr></table></figure><p>参数化装饰器的远离相当复杂，刚刚讨论的比大多数都简单。参数化装饰器通常会把被装饰的函数替换掉，而且结构上需要多一层嵌套。接下来会探讨这种函数金字塔。</p><h1 id="参数化clock装饰器">参数化clock装饰器</h1><p>为clock装饰器添加一个功能：让用户传入一个格式字符串，控制被装饰函数的输出。</p><figure class="highlight python"><figcaption><span>clockdeco_param.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">DEFAULT_FMT = <span class="string">'[&#123;elapsed:0.8f&#125;s] &#123;name&#125;(&#123;args&#125;) -&gt; &#123;result&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(fmt=DEFAULT_FMT)</span>:</span>  <span class="comment"># 装饰器工厂函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span>  <span class="comment"># 真正的装饰器</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*_args)</span>:</span>  <span class="comment"># 包装被装饰的函数</span></span><br><span class="line">            t0 = time.time()</span><br><span class="line">            _result = func(*_args)  <span class="comment"># 调用被装饰的函数</span></span><br><span class="line">            elapsed = time.time() - t0</span><br><span class="line">            name = func.__name__</span><br><span class="line">            args = <span class="string">', '</span>.join(repr(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> _args)</span><br><span class="line">            result = repr(_result)</span><br><span class="line">            print(fmt.format(**locals()))  <span class="comment"># 引用clock的局部变量</span></span><br><span class="line">            <span class="keyword">return</span> _result  <span class="comment"># 返回被装饰函数返回的值</span></span><br><span class="line">        <span class="keyword">return</span> clocked</span><br><span class="line">    <span class="keyword">return</span> decorate</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line"><span class="meta">    @clock()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">snooze</span><span class="params">(seconds)</span>:</span></span><br><span class="line">        time.sleep(seconds)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @clock('&#123;name&#125;: &#123;elapsed&#125;s')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">snooze1</span><span class="params">(seconds)</span>:</span></span><br><span class="line">        time.sleep(seconds)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @clock('&#123;name&#125;(&#123;args&#125;) dt=&#123;elapsed:0.3f&#125;s')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">snooze2</span><span class="params">(seconds)</span>:</span></span><br><span class="line">        time.sleep(seconds)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> func <span class="keyword">in</span> [snooze, snooze1, snooze2]:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            func(<span class="number">.123</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[0.12812114s] snooze(0.123) -&gt; None</span><br><span class="line">[0.12493706s] snooze(0.123) -&gt; None</span><br><span class="line">[0.12483931s] snooze(0.123) -&gt; None</span><br><span class="line">snooze1: 0.12311005592346191s</span><br><span class="line">snooze1: 0.12802791595458984s</span><br><span class="line">snooze1: 0.12346792221069336s</span><br><span class="line">snooze2(0.123) dt=0.124s</span><br><span class="line">snooze2(0.123) dt=0.123s</span><br><span class="line">snooze2(0.123) dt=0.124s</span><br></pre></td></tr></table></figure><p><em>Graham Dumpleton和Lennart Regebro（Fluent Python一书的技术审校之一）认为，装饰器最好通过实现<code>__call__</code>方法的类实现，不应该通过函数实现。</em></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> decorators </tag>
            
            <tag> Fluent Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数装饰器和闭包</title>
      <link href="/notes/fluent-python/function-decorators-and-closures/"/>
      <url>/notes/fluent-python/function-decorators-and-closures/</url>
      
        <content type="html"><![CDATA[<p>函数装饰器用于在源码中“标记”函数，以某种方式增强函数的行为。这是一项强大的功能，但是若想掌握，必须理解闭包。除了在装饰器中有用处之外，闭包还是回调式异步编程和函数式编程风格的基础。</p><h1 id="装饰器基础知识">装饰器基础知识</h1><p>装饰器是可调用的对象，其参数是另一个函数（被装饰的函数）。装饰器可能会处理被装饰的函数，然后把它返回，或者将其替换成另一个函数或可调用对象。</p><p>假如有个名为decorate的装饰器，下述两种写法的效果一样：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写法1</span></span><br><span class="line"><span class="meta">@decorate</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running target()'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写法2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running target()'</span>)</span><br><span class="line"></span><br><span class="line">target = decorate(target)</span><br></pre></td></tr></table></figure><a id="more"></a><p>两个代码片段执行完毕后得到的是decorate(target)返回的函数。为了确认被装饰的函数会被替换，看一个实例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">'running inner()'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> inner  <span class="comment"># 返回inner函数</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@deco  <span class="comment"># 使用deco装饰target函数</span></span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'running target()'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>target()</span><br><span class="line">running inner()  <span class="comment"># 被装饰的target函数其实会运行inner</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>target  <span class="comment"># 审查对象，target现在是inner的引用</span></span><br><span class="line">&lt;function deco.&lt;locals&gt;.inner at <span class="number">0x106580d08</span>&gt;</span><br></pre></td></tr></table></figure><p>装饰器可以像常规的可调用对象那样调用，其参数是另一个函数。有时，这样做更方便，尤其是做元编程（在运行时改变程序的行为）时。</p><ul><li>装饰器的一大特性是，能把被装饰的函数替换成其他函数。</li><li>第二个特性是，装饰器在加载模块时立即执行。</li></ul><h1 id="python何时执行装饰器">Python何时执行装饰器</h1><p>装饰器的一个关键特性是，它们在被装饰的函数定义之后立即运行。这通常是在导入时（即Python加载模块时）。</p><figure class="highlight python"><figcaption><span>registration.py</span></figcaption><table><tr><td class="code"><pre><span class="line">registry = []  <span class="comment"># 保存被@register装饰的函数引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(func)</span>:</span>  <span class="comment"># 参数是函数</span></span><br><span class="line">    print(<span class="string">'running register(%s'</span> % func)  <span class="comment"># 为了演示，显示被装饰的函数</span></span><br><span class="line">    registry.append(func)  <span class="comment"># 存入被装饰的函数</span></span><br><span class="line">    <span class="keyword">return</span> func  <span class="comment"># 返回值是函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">     print(<span class="string">'running f1()'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f2()'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">()</span>:</span>  <span class="comment"># f1和f2被装饰，f3没有装饰</span></span><br><span class="line">    print(<span class="string">'running f3()'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running main()'</span>)</span><br><span class="line">    print(<span class="string">'registry -&gt;'</span>, registry)</span><br><span class="line">    f1()</span><br><span class="line">    f2()</span><br><span class="line">    f3()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()  <span class="comment"># 作为脚本运行时才调用main()</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python registration.py  <span class="comment"># 把registration.py当作脚本运行时</span></span><br><span class="line">running register(&lt;function f1 at <span class="number">0x10a8e46a8</span>&gt;</span><br><span class="line">running register(&lt;function f2 at <span class="number">0x10a8e4730</span>&gt;</span><br><span class="line">running main()</span><br><span class="line">registry -&gt; [&lt;function f1 at 0x10a8e46a8&gt;, &lt;function f2 at 0x10a8e4730&gt;]</span><br><span class="line">running f1()</span><br><span class="line">running f2()</span><br><span class="line">running f3()</span><br><span class="line"></span><br><span class="line">$ python  <span class="comment"># 运行python解释器</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> registration  <span class="comment"># 导入模块</span></span><br><span class="line">running register(&lt;function f1 at <span class="number">0x10e893b70</span>&gt;</span><br><span class="line">running register(&lt;function f2 at <span class="number">0x10e893bf8</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>registration.registry  <span class="comment"># 查看registry的值</span></span><br><span class="line">[&lt;function f1 at <span class="number">0x10e893b70</span>&gt;, &lt;function f2 at <span class="number">0x10e893bf8</span>&gt;]</span><br></pre></td></tr></table></figure><p>上例主要想强调，函数装饰器在导入模块时立即执行（register运行了两次，分别装饰了f1和f2），而被装饰的函数只有在明确调用时运行。这突出了导入时和运行时之间的区别。</p><p>考虑到装饰器在真实代码中的常用方式，上例有两个不寻常的地方。</p><ul><li>装饰器函数与被装饰的函数在同一个模块中定义。实际情况是，装饰器通常在一个模块中定义，然后应用到其他模块中的函数上。</li><li>register装饰器返回的函数与通过参数传入的函数相同。实际上，大多数装饰器会在内部定义一个函数，然后将其返回。</li></ul><p>虽然register装饰器原封不动地返回被装饰的函数，到那时这种技术并非没有用处。很多Python Web框架使用这样的装饰器把函数添加到某种中央注册处，例如把URL模式映射到生成HTTP响应的函数上的注册处。这种注册装饰器可能会也可能不会修改被装饰的函数。</p><h1 id="使用装饰器改进策略模式">使用装饰器改进策略模式</h1><p>回顾，支持<a href="/notes/fluent-python/design-patterns-with-first-class-functions/" title="选择最佳策略">选择最佳策略</a>的简单方案：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fidelity_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""为积分为1000或以上的顾客提供5%折扣"""</span></span><br><span class="line">    <span class="keyword">return</span> order.total() * <span class="number">.05</span> <span class="keyword">if</span> order.customer.fidelity &gt;= <span class="number">1000</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bulk_item_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""单个商品为20个或以上时提供10%折扣"""</span></span><br><span class="line">    discount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> order.cart:</span><br><span class="line">        <span class="keyword">if</span> item.quantity &gt;= <span class="number">20</span>:</span><br><span class="line">            discount += item.total() * <span class="number">.1</span></span><br><span class="line">    <span class="keyword">return</span> discount</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">large_order_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""订单中的不同商品达到10个或以上时提供7%折扣"""</span></span><br><span class="line">    distinct_items = &#123;item.product <span class="keyword">for</span> item <span class="keyword">in</span> order.cart&#125;</span><br><span class="line">    <span class="keyword">if</span> len(distinct_items) &gt;= <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">return</span> order.total() * <span class="number">.07</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">promos = [fidelity_promo, bulk_item_promo, large_order_promo]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""选择可用的最佳折扣"""</span></span><br><span class="line">    <span class="keyword">return</span> max(promo(order) <span class="keyword">for</span> promo <span class="keyword">in</span> promos)  <span class="comment"># 返回折扣额度最大的那个</span></span><br></pre></td></tr></table></figure><p>该方案的主要问题是，定义体中有函数的名称，但是best_promo用来判断哪个折扣幅度最大的promos列表中也有函数名称。这种重复是个问题，因为新增策略函数后可能会忘记把它添加到promos列表中，导致best_promo忽略新策略，而不报错，为系统引入了不易察觉的缺陷。下面使用注册装饰器解决这个问题。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">promos = []  <span class="comment"># 列表起初是空的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">promotion</span><span class="params">(promo_func)</span>:</span></span><br><span class="line">    promos.append(promo_func)  <span class="comment"># 添加到promos列表中</span></span><br><span class="line">    <span class="keyword">return</span> promo_func  <span class="comment"># 原封不动返回</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@promotion  # 装饰策略</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fidelity_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""为积分为1000或以上的顾客提供5%折扣"""</span></span><br><span class="line">    <span class="keyword">return</span> order.total() * <span class="number">.05</span> <span class="keyword">if</span> order.customer.fidelity &gt;= <span class="number">1000</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@promotion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bulk_item_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""单个商品为20个或以上时提供10%折扣"""</span></span><br><span class="line">    discount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> order.cart:</span><br><span class="line">        <span class="keyword">if</span> item.quantity &gt;= <span class="number">20</span>:</span><br><span class="line">            discount += item.total() * <span class="number">.1</span></span><br><span class="line">    <span class="keyword">return</span> discount</span><br><span class="line"></span><br><span class="line"><span class="meta">@promotion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">large_order_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""订单中的不同商品达到10个或以上时提供7%折扣"""</span></span><br><span class="line">    distinct_items = &#123;item.product <span class="keyword">for</span> item <span class="keyword">in</span> order.cart&#125;</span><br><span class="line">    <span class="keyword">if</span> len(distinct_items) &gt;= <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">return</span> order.total() * <span class="number">.07</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_promo</span><span class="params">(order)</span>:</span>  <span class="comment"># 不变</span></span><br><span class="line">    <span class="string">"""选择可用的最佳折扣"""</span></span><br><span class="line">    <span class="keyword">return</span> max(promo(order) <span class="keyword">for</span> promo <span class="keyword">in</span> promos)</span><br></pre></td></tr></table></figure><p>与使用globals()或用insepect找出全部策略的方案相比，使用装饰器有几个优点。</p><ul><li>促销策略函数无须使用特殊的名称（即不用以_promo结尾）。</li><li><span class="citation" data-cites="promotion装饰器突出了被装饰的函数的作用">@promotion装饰器突出了被装饰的函数的作用</span>，还便于临时禁用某个促销策略：只需把装饰器注释掉。</li><li>促销折扣策略可以在其他模块中定义，在系统中的任何地方都行，只要使用@promotion装饰即可。</li></ul><p>不过，多数装饰器会修改被装饰的函数。通常它们会定义一个内部函数，然后将其返回，替换被装饰的函数。使用内部函数的代码几乎都要靠闭包才能正确运作。</p><h1 id="变量作用域规则">变量作用域规则</h1><p>为了理解闭包，先了解Python中的变量作用域。示例 一个函数，读取一个局部变量和一个全局变量。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(a)</span>:</span></span><br><span class="line">        print(a)</span><br><span class="line">        print(b)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">3</span>, <span class="keyword">in</span> f1</span><br><span class="line">NameError: name <span class="string">'b'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">6</span>  <span class="comment"># 先给全局变量b赋值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">3</span>)  <span class="comment"># 再调用就不会出错</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p>下面看一个可能会让你吃惊的示例。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(a)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(a)</span><br><span class="line"><span class="meta">... </span>    print(b)</span><br><span class="line"><span class="meta">... </span>    b = <span class="number">9</span>  <span class="comment"># 由于给变量b赋值，编译器将b归类为局部变量</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2(<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span>  <span class="comment"># print(a)执行了</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">3</span>, <span class="keyword">in</span> f2</span><br><span class="line">UnboundLocalError: local variable <span class="string">'b'</span> referenced before assignment  <span class="comment"># 局部变量'b'未定义</span></span><br></pre></td></tr></table></figure><p>Python编译函数的定义体时，它判断b是局部变量，因为在函数中给它赋值了。生成的字节码（可以用dis.dis(f2)查看f2的字节码）证实了这种判断，Python会尝试从本地环境获取b。后面调用f2(3)时，f2的定义体会获取并打印局部变量a的值，但是尝试获取局部变量b的值时，发现b没有绑定值。</p><p>这不是缺陷，而是设计选择：Python不要求声明变量，但是假定在函数定义体中赋值的变量是局部变量。JavaScript也不要求声明变量，但是如果忘记把变量声明为局部变量（使用var），可能会在不知情的情况下获取全局变量。</p><p>如果在函数中赋值时想让解释器把b当成全局变量，要使用global声明。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">(a)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">global</span> b</span><br><span class="line"><span class="meta">... </span>    print(a)</span><br><span class="line"><span class="meta">... </span>    print(b)</span><br><span class="line"><span class="meta">... </span>    b = <span class="number">9</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f3(<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f3(<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><h1 id="闭包">闭包</h1><p>在函数内部定义函数不常见，直到开始使用匿名函数才会这样做。而且，只有涉及嵌套函数时才有闭包问题。其实，闭包指延伸了作用域的函数，其中包括函数定义体中引用、但是不在定义体中定义的非全局变量。函数是不是匿名的没有关系，关键是它能访问定义体之外定义的非全局变量。</p><p>假如有个名为avg的函数，它的作用是计算不断增加的系列值的均值。例如，整个历史中某个商品的平均收盘价。每天都会增加新价格，因此平均值要考虑至目前为止所有的价格。起初，avg是这样使用的：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">10</span>)</span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">11</span>)</span><br><span class="line"><span class="number">10.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">12</span>)</span><br><span class="line"><span class="number">11.0</span></span><br></pre></td></tr></table></figure><p>avg从何而来，它又在哪里保存历史值呢？下面看两种实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Averager</span><span class="params">()</span>:</span>  <span class="comment"># 使用类实现</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.series = []</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, new_value)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.series.append(new_value)</span><br><span class="line"><span class="meta">... </span>        total = sum(self.series)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> total / len(self.series)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg = Averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">1</span>)</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg = Averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">10</span>)</span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">11</span>)</span><br><span class="line"><span class="number">10.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">12</span>)</span><br><span class="line"><span class="number">11.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.series  <span class="comment"># 历史值保存在实例的series属性中</span></span><br><span class="line">[<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span>  <span class="comment"># 函数式实现</span></span><br><span class="line"><span class="meta">... </span>    series = []  <span class="comment"># series是make_averager的局部变量</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line"><span class="meta">... </span>        series.append(new_value)  <span class="comment"># 访问了定义体之外的局部变量</span></span><br><span class="line"><span class="meta">... </span>        total = sum(series)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> total / len(series)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> averager</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg = make_averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">10</span>)</span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">11</span>)</span><br><span class="line"><span class="number">10.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">12</span>)</span><br><span class="line"><span class="number">11.0</span></span><br></pre></td></tr></table></figure><p>函数式实现中的avg函数在哪里寻找series呢？注意，series是make_averager函数的局部变量，因为那个函数的定义体中初始化了series。可是，调用avg(10)时，make_averager函数已经返回了，而它的本地作用域也一去不复返了。</p><p>在averager函数中，series是自由变量（free variable），这是一个技术术语，指未在本地作用域中绑定的变量（series的绑定发生在make_averager定义体中）。</p><p><img src="/uploads/image/fluent-python/closure-and-free-variable.png"></p><p>averager的闭包延伸到那个函数的作用域之外，包含自由变量series的绑定。审查返回的averager对象：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__code__.co_varnames</span><br><span class="line">(<span class="string">'new_value'</span>, <span class="string">'total'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__code__.co_freevars</span><br><span class="line">(<span class="string">'series'</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__closure__</span><br><span class="line">(&lt;cell at <span class="number">0x106562738</span>: list object at <span class="number">0x10658fd48</span>&gt;,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__closure__[<span class="number">0</span>].cell_contents</span><br><span class="line">[<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]</span><br></pre></td></tr></table></figure><p>综上，闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时，虽然定义作用域不可用了，但是仍能使用那些绑定。注意，只有嵌套在其他函数中的函数（本例的averager函数）才可能需要处理不在全局作用域中的外部变量（本例的series）。</p><h1 id="nonlocal声明">nonlocal声明</h1><p>在上例中，我们把所有值存储在历史数列中，然后在每次调用averager时使用sum求和。更好的实现方式是，只存储目前的总值和元素个数，然后使用这两个数计算均值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    count = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    total = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line"><span class="meta">... </span>        count += <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>        total += new_value</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> total / count</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> averager</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg = make_averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">10</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">5</span>, <span class="keyword">in</span> averager</span><br><span class="line">UnboundLocalError: local variable <span class="string">'count'</span> referenced before assignment</span><br></pre></td></tr></table></figure><p>为什么想象中的自由变量count会变成局部变量呢？</p><p><strong>问题是，当count是任何不可变类型（数字、字符串、元组等）时，count += 1语句的作用其实与count = count + 1一样。因此，在averager定义体中为count赋值了，这会把count变成局部变量。total变量也受这个问题影响。</strong></p><p><strong>对不可变类型来说，只能读取，不能更新。如果尝试重新绑定，例如count = count + 1，其实会隐式创建局部变量count。这样，count就不是自由变量，因此不会保存在闭包中。</strong></p><p>Python3引入了nonlocal声明。它的作用是把变量标记为自由变量，即使在函数中为变量赋予新值了，也会变成自由变量。如果为nonlocal声明的变量赋予新值，闭包中保存的绑定会更新。使用nonlocal修正后的函数如下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> count, total</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        total += new_value</span><br><span class="line">        <span class="keyword">return</span> total / count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> decorators </tag>
            
            <tag> Fluent Python </tag>
            
            <tag> strategy </tag>
            
            <tag> closures </tag>
            
            <tag> global </tag>
            
            <tag> nonlocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML类图</title>
      <link href="/documentation/uml-class-diagram/"/>
      <url>/documentation/uml-class-diagram/</url>
      
        <content type="html"><![CDATA[<p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html" target="_blank" rel="noopener">看懂UML类图和时序图</a></p><p><a href="https://plantuml.com/zh/class-diagram" target="_blank" rel="noopener">类图的语法和功能</a></p><h1 id="从一个示例开始">从一个示例开始</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title 示例</span><br><span class="line">abstract 车 &lt;&lt;abstract&gt;&gt;</span><br><span class="line">hide empty fields</span><br><span class="line">hide empty methods</span><br><span class="line">小汽车 .up.|&gt; 车 : 实现</span><br><span class="line">自行车 .up.|&gt; 车 : 实现</span><br><span class="line">SUV -left-|&gt; 小汽车 : 泛化</span><br><span class="line">小汽车 “1” *-down- “4” 轮胎 : 组合</span><br><span class="line">小汽车 “1” *-down- “1” 发动机 : 组合</span><br><span class="line">学生 .right.&gt; 自行车 : 依赖</span><br><span class="line">班级 “1” -up-o “many” 学生 : 聚合</span><br><span class="line">学生 “1” -down- “1” 身份证 : 关联</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><img src="http://www.plantuml.com/plantuml/svg/AyaioKbLUBvarvDztLo9ISKbHOd99GelzYvJiB61SUtik38oKr8LKdCBIYeLSbDparABk9vkw7-sSIz8eLvfWLwD7LYFbSBJTVEUzstWUj6-wiN27boomQ5X2hevgMabka0PX45M2iysptxQCmt9x4SDSmmVDSnLqD9DoI_FqmNnJK3y5tlNlMZk0-fulhlbwOGE_3h0_AVz4vzshNWsPnUIfhNBda-Phw1Nb9cUKQ87T2FSqLOAJ_RDVR5r6jVp_hNFTos76w9RMg2R3-Bb9kPLWas5666byA9n5fAHSFMeRdYnQ_MJtNjVh6y41KNhvXUDKm00"><ul><li>小汽车与自行车和抽象类车之间的关系为<strong>实现</strong>关系，使用带空心箭头的虚线表示。</li><li>小汽车与SUV之间的关系是<strong>泛化</strong>关系，使用带空心箭头的实线表示。</li><li>小汽车与发动机、轮胎之间是<strong>组合</strong>关系，使用带实心箭头的实线表示。</li><li>学生与班级之间是<strong>聚合</strong>关系，使用带空心箭头的实线表示。</li><li>学生与身份证之间是<strong>关联</strong>关系，使用一根实线表示。</li><li>学生上学需要用到自行车，与自行车是一种<strong>依赖</strong>关系，使用带箭头的虚线表示。</li></ul><a id="more"></a><h1 id="类之间的关系">类之间的关系</h1><h2 id="泛化和实现">泛化和实现</h2><p>泛化关系（generalization）：最终代码中，泛化关系表现为继承非抽象类或实现接口（需要编程语言支持）。</p><p>实现关系（realize）： 最终代码中，实现关系表现为继承抽象类。</p><h2 id="聚合和组合">聚合和组合</h2><p>聚合关系（aggregation）：表示整体由部分构成，与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在。例如，部门撤销了，人员不会消失，他们依然存在。</p><p>组合关系（composition）：组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了。例如，公司不存在了，部门也将不存在了。</p><h2 id="关联和依赖">关联和依赖</h2><p>关联关系（association）：描述不同类的对象之间的结构关系，它是一种静态关系，通常与运行状态无关，一般由常识等因素决定。关联关系是一种“强关联”的关系。比如，乘车人和车票、学生与学校之间就是一种关联关系。关联关系默认不强调方向，表示对象相互知道。在最终代码中，关联对象通常是以成员变量的形式实现的。</p><p>依赖关系（dependency）：描述一个对象在运行期间会用到另一个对象。与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化，依赖关系也可能发生变化。显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单项依赖，杜绝双向依赖的产生。在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，使用对方的方法和属性。</p>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UML </tag>
            
            <tag> plantuml </tag>
            
            <tag> design patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用一等函数实现设计模式</title>
      <link href="/notes/fluent-python/design-patterns-with-first-class-functions/"/>
      <url>/notes/fluent-python/design-patterns-with-first-class-functions/</url>
      
        <content type="html"><![CDATA[<p>虽然设计模式与语言无关，但这并不意味着每一个模式都能在每一门语言中使用。1996年，Peter Norvig在题为“<a href="http://norvig.com/design-patterns/" target="_blank" rel="noopener">Design Patterns in Dynamic Languages</a>”的演讲中指出，Gamma等人合著的《设计模式：可复用面向对象软件的基础》一书中有23个模式，其中有16个在动态语言中“不见了，或者简化了”（参见第9张幻灯片）。他讨论的是Lisp和Dylan，不过很多相关的动态特性在Python中也能找到。</p><p>具体而言，Norvig建议在有一等函数的语言中重新审视策略、命令、模板方法和访问者模式。通常，我们可以把这些模式中涉及的某些类的实例替换成简单的函数，从而减少样板代码。</p><h1 id="重构策略模式">重构策略模式</h1><h2 id="经典的策略模式">经典的策略模式</h2><p>《设计模式：可复用面向对象软件的基础》一书是这样概率策略模式的：定义一系列算法，把它们一一封装起来，并且使它们可以相互替换。本模式使得算法可以独立于使用它的客户而变化。</p><a id="more"></a><p>电商领域有个功能明显可以使用策略模式，根据客户的属性或订单中的商品计算折扣。假如一个网店制定了下述折扣规则。</p><ul><li>有1000或以上积分的顾客，每个订单享5%折扣。</li><li>同一订单中，单个商品的数量达到20个或以上，享10%折扣。</li><li>订单中的不同商品达到10个或以上，享7%折扣。</li></ul><p>简单起见，假定一个订单一次只能享用一个折扣。</p><img src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYIiv9B2vMy2zAIIrIgEPI08AI_9B470rDC3kbD1N8gkLAJ2ekAKfCBb48AChFpI_9pC-3Agw6oTGgf6GM9-UNvfM0DK2CTGDQbvDPKWdM1TM1HPbJQKwsPqbgBW5bFeb5wQbWb-9K2F57lYx2dLm85zlKwEgYEWbT4iKXw99erdFbvPUaAYWzsT7rP4VtisdjIWg9nGfvXb3XvskdFP-w529c11LxshhzoTx9o3B6N7c62df5cUaP9NgGEE3ACrBGoqbD0_8HNa0DHZqza4RKC8E8eGSGM1G0"><p>上下文：把一些计算委托给实现不同算法的可互换组建，它提供服务。在这个电商示例中，上下文是Order，它会根据不同的算法计算促销折扣。</p><p>策略：实现不同算法的组件共同的接口。</p><p>具体策略：策略的具体子类。</p><p>按照《设计模式：可复用面向对象软件的基础》一书的说明，具体策略由上下文类的客户选择。在这个示例中，实例化订单之前，系统会以某种方式选择一种促销折扣策略，然后把它传给Order构造方法。具体怎么选择策略，不在这个模式的职责范围内。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Customer = namedtuple(<span class="string">'Customer'</span>, <span class="string">'name fidelity'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, product, quantity, price)</span>:</span></span><br><span class="line">        self.product = product</span><br><span class="line">        self.quantity = quantity</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.price * self.quantity</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span>  <span class="comment"># 上下文</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, customer, cart, promotion=None)</span>:</span></span><br><span class="line">        self.customer = customer</span><br><span class="line">        self.cart = list(cart)</span><br><span class="line">        self.promotion = promotion</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">'__total'</span>):</span><br><span class="line">            self.__total = sum(item.total() <span class="keyword">for</span> item <span class="keyword">in</span> self.cart)</span><br><span class="line">        <span class="keyword">return</span> self.__total</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">due</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.promotion <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            discount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            discount = self.promotion.discount(self)</span><br><span class="line">        <span class="keyword">return</span> self.total() - discount</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        fmt = <span class="string">'&lt;Order total: &#123;:.2f&#125; due: &#123;:.2f&#125;&gt;'</span></span><br><span class="line">        <span class="keyword">return</span> fmt.format(self.total(), self.due())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promotion</span><span class="params">(ABC)</span>:</span>  <span class="comment"># 策略:抽象基类</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">discount</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="string">"""返回折扣金额(正值)"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FidelityPromo</span><span class="params">(Promotion)</span>:</span>  <span class="comment"># 第一个具体策略</span></span><br><span class="line">    <span class="string">"""为积分为1000或以上的顾客提供5%折扣"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">discount</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> order.total() * <span class="number">.05</span> <span class="keyword">if</span> order.customer.fidelity &gt;= <span class="number">1000</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BulkItemPromo</span><span class="params">(Promotion)</span>:</span>  <span class="comment"># 第二个具体策略</span></span><br><span class="line">    <span class="string">"""单个商品为20个或以上时提供10%折扣"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">discount</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        discount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> order.cart:</span><br><span class="line">            <span class="keyword">if</span> item.quantity &gt;= <span class="number">20</span>:</span><br><span class="line">                discount += item.total() * <span class="number">.1</span></span><br><span class="line">        <span class="keyword">return</span> discount</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LargeOrderPromo</span><span class="params">(Promotion)</span>:</span>  <span class="comment"># 第三个具体策略</span></span><br><span class="line">    <span class="string">"""订单中的不同商品达到10个或以上时提供7%折扣"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">discount</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        distinct_items = &#123;item.product <span class="keyword">for</span> item <span class="keyword">in</span> order.cart&#125;</span><br><span class="line">        <span class="keyword">if</span> len(distinct_items) &gt;= <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> order.total() * <span class="number">.07</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>Promotion定义为抽象基类（Abstract Base Class, ABC），这么做是为了使用@abstractmethod装饰器，从而明确表明所用的模式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>joe = Customer(<span class="string">'John Doe'</span>, <span class="number">0</span>)  <span class="comment"># joe积分为0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ann = Customer(<span class="string">'Ann Smith'</span>, <span class="number">1100</span>)  <span class="comment"># ann积分1100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cart = [LineItem(<span class="string">'banana'</span>, <span class="number">4</span>, <span class="number">.5</span>),</span><br><span class="line"><span class="meta">... </span>        LineItem(<span class="string">'apple'</span>, <span class="number">10</span>, <span class="number">1.5</span>),</span><br><span class="line"><span class="meta">... </span>        LineItem(<span class="string">'watermellon'</span>, <span class="number">5</span>, <span class="number">5.0</span>)]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(joe, cart, FidelityPromo())  <span class="comment"># joe不享折扣</span></span><br><span class="line">&lt;Order total: <span class="number">42.00</span> due: <span class="number">42.00</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(ann, cart, FidelityPromo())  <span class="comment"># ann享有5%积分折扣</span></span><br><span class="line">&lt;Order total: <span class="number">42.00</span> due: <span class="number">39.90</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>banana_cart = [LineItem(<span class="string">'banana'</span>, <span class="number">30</span>, <span class="number">.5</span>),</span><br><span class="line"><span class="meta">... </span>               LineItem(<span class="string">'apple'</span>, <span class="number">10</span>, <span class="number">1.5</span>)]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(joe, banana_cart, BulkItemPromo())  <span class="comment"># 香蕉个数超过20个，香蕉享10%折扣</span></span><br><span class="line">&lt;Order total: <span class="number">30.00</span> due: <span class="number">28.50</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>long_order = [LineItem(str(item_code), <span class="number">1</span>, <span class="number">1.0</span>) <span class="keyword">for</span> item_code <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(joe, long_order, LargeOrderPromo())  <span class="comment"># long_order不同商品达到10个，享7%折扣</span></span><br><span class="line">&lt;Order total: <span class="number">10.00</span> due: <span class="number">9.30</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(joe, cart, LargeOrderPromo())  <span class="comment"># cart不同商品有3个，不能享折扣</span></span><br><span class="line">&lt;Order total: <span class="number">42.00</span> due: <span class="number">42.00</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="使用函数实现策略模式">使用函数实现策略模式</h2><p>在上述示例中，每个具体策略都是一个类，而且都只定义了一个方法，即discount。此外，策略实例没有状态（没有实例属性）。它们看起来像是普通的函数——的确如此。下面是对示例的重构，把具体策略换成了简单的函数，而且去掉了Promo抽象类。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Customer = namedtuple(<span class="string">'Customer'</span>, <span class="string">'name fidelity'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, product, quantity, price)</span>:</span></span><br><span class="line">        self.product = product</span><br><span class="line">        self.quantity = quantity</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.price * self.quantity</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span>  <span class="comment"># 上下文</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, customer, cart, promotion=None)</span>:</span></span><br><span class="line">        self.customer = customer</span><br><span class="line">        self.cart = list(cart)</span><br><span class="line">        self.promotion = promotion</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">'__total'</span>):</span><br><span class="line">            self.__total = sum(item.total() <span class="keyword">for</span> item <span class="keyword">in</span> self.cart)</span><br><span class="line">        <span class="keyword">return</span> self.__total</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">due</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.promotion <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            discount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            discount = self.promotion(self)  <span class="comment"># 计算折扣只需调用self.promotion()函数</span></span><br><span class="line">        <span class="keyword">return</span> self.total() - discount</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        fmt = <span class="string">'&lt;Order total: &#123;:.2f&#125; due: &#123;:.2f&#125;&gt;'</span></span><br><span class="line">        <span class="keyword">return</span> fmt.format(self.total(), self.due())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 无抽象类</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fidelity_promo</span><span class="params">(order)</span>:</span>  <span class="comment"># 各个策略都是函数</span></span><br><span class="line">    <span class="string">"""为积分为1000或以上的顾客提供5%折扣"""</span></span><br><span class="line">    <span class="keyword">return</span> order.total() * <span class="number">.05</span> <span class="keyword">if</span> order.customer.fidelity &gt;= <span class="number">1000</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bulk_item_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""单个商品为20个或以上时提供10%折扣"""</span></span><br><span class="line">    discount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> order.cart:</span><br><span class="line">        <span class="keyword">if</span> item.quantity &gt;= <span class="number">20</span>:</span><br><span class="line">            discount += item.total() * <span class="number">.1</span></span><br><span class="line">    <span class="keyword">return</span> discount</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">large_order_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""订单中的不同商品达到10个或以上时提供7%折扣"""</span></span><br><span class="line">    distinct_items = &#123;item.product <span class="keyword">for</span> item <span class="keyword">in</span> order.cart&#125;</span><br><span class="line">    <span class="keyword">if</span> len(distinct_items) &gt;= <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">return</span> order.total() * <span class="number">.07</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>新的Order类使用起来更简单。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>joe = Customer(<span class="string">'John Doe'</span>, <span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ann = Customer(<span class="string">'Ann Smith'</span>, <span class="number">1100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cart = [LineItem(<span class="string">'banana'</span>, <span class="number">4</span>, <span class="number">.5</span>),</span><br><span class="line"><span class="meta">... </span>        LineItem(<span class="string">'apple'</span>, <span class="number">10</span>, <span class="number">1.5</span>),</span><br><span class="line"><span class="meta">... </span>        LineItem(<span class="string">'watermellon'</span>, <span class="number">5</span>, <span class="number">5.0</span>)]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(joe, cart, fidelity_promo)  <span class="comment"># 没必要实例化对象，把函数作为参数传入</span></span><br><span class="line">&lt;Order total: <span class="number">42.00</span> due: <span class="number">42.00</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(ann, cart, fidelity_promo)</span><br><span class="line">&lt;Order total: <span class="number">42.00</span> due: <span class="number">39.90</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>banana_cart = [LineItem(<span class="string">'banana'</span>, <span class="number">30</span>, <span class="number">.5</span>),</span><br><span class="line"><span class="meta">... </span>               LineItem(<span class="string">'apple'</span>, <span class="number">10</span>, <span class="number">1.5</span>)]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(joe, banana_cart, bulk_item_promo)</span><br><span class="line">&lt;Order total: <span class="number">30.00</span> due: <span class="number">28.50</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>long_order = [LineItem(str(item_code), <span class="number">1</span>, <span class="number">1.0</span>) <span class="keyword">for</span> item_code <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(joe, long_order, large_order_promo)</span><br><span class="line">&lt;Order total: <span class="number">10.00</span> due: <span class="number">9.30</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(joe, cart, large_order_promo)</span><br><span class="line">&lt;Order total: <span class="number">42.00</span> due: <span class="number">42.00</span>&gt;</span><br></pre></td></tr></table></figure><p>至此，我们使用函数实现了策略模式，由此也出现了其他可能性。假设我们想创建一个“元策略”，让它为指定的订单选择最佳折扣。</p><h2 id="选择最佳策略简单的方式">选择最佳策略：简单的方式</h2><p>best_promo函数的实现特别简单：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">promos = [fidelity_promo, bulk_item_promo, large_order_promo]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""选择可用的最佳折扣"""</span></span><br><span class="line">    <span class="keyword">return</span> max(promo(order) <span class="keyword">for</span> promo <span class="keyword">in</span> promos)  <span class="comment"># 返回折扣额度最大的那个</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(joe, long_order, best_promo)  <span class="comment"># 订购多种商品时，选择larger_order_promo</span></span><br><span class="line">&lt;Order total: <span class="number">10.00</span> due: <span class="number">9.30</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(joe, banana_cart, best_promo)  <span class="comment"># 订购大量香蕉时，选择bulk_item_promo</span></span><br><span class="line">&lt;Order total: <span class="number">30.00</span> due: <span class="number">28.50</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(ann, cart, best_promo)  <span class="comment"># 为忠实顾客ann提供fidelity_promo优惠的折扣</span></span><br><span class="line">&lt;Order total: <span class="number">42.00</span> due: <span class="number">39.90</span>&gt;</span><br></pre></td></tr></table></figure><p>虽然上述示例可用，而且易读，但是有些重复可能会导致不易察觉的缺陷：若想添加新的促销策略，要定义相应的函数，还要记得把它添加到promos列表中；否则，当新促销函数显式地作为参数传给Order时，它是可用的，但是best_promo不会考虑它。继续往下读，了解这个问题的几种解决方案。</p><h2 id="找出模块中的全部策略">找出模块中的全部策略</h2><p>在Python中，模块也是一等对象，而且标准库提供了几个处理模块的函数。</p><blockquote><p><code>globals()</code></p><p>返回一个字典，表示当前的全局符号表。这个符号表始终针对当前模块（对函数或方法来说，是指定义它们的模块，而不是调用它们的模块）。</p></blockquote><p>示例：使用globals函数帮助best_promo自动找到其他可用的*_promo函数，过程优点曲折。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">promos = [globals()[name] <span class="keyword">for</span> name <span class="keyword">in</span> globals()</span><br><span class="line">          <span class="keyword">if</span> name.endswith(<span class="string">'_promo'</span>)</span><br><span class="line">          <span class="keyword">and</span> name != <span class="string">'best_promo'</span>]  <span class="comment"># 过滤掉best_promo自身，防止无限递归</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""选择可用的最佳折扣"""</span></span><br><span class="line">    <span class="keyword">return</span> max(promo(order) <span class="keyword">for</span> promo <span class="keyword">in</span> promos)</span><br></pre></td></tr></table></figure><p>收集所有可用促销的另一种方法是，在一个单独的模块中保存所有策略函数，把best_promo排除在外。</p><figure class="highlight python"><figcaption><span>promotions.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fidelity_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""为积分为1000或以上的顾客提供5%折扣"""</span></span><br><span class="line">    <span class="keyword">return</span> order.total() * <span class="number">.05</span> <span class="keyword">if</span> order.customer.fidelity &gt;= <span class="number">1000</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bulk_item_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""单个商品为20个或以上时提供10%折扣"""</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">large_order_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""订单中的不同商品达到10个或以上时提供7%折扣"""</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> promotions</span><br><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">promos = [func <span class="keyword">for</span> name, func <span class="keyword">in</span> inspect.getmembers(promotions, inspect.isfunction)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""选择可用的最佳折扣"""</span></span><br><span class="line">    <span class="keyword">return</span> max(promo(order) <span class="keyword">for</span> promo <span class="keyword">in</span> promos)</span><br></pre></td></tr></table></figure><p>不管怎么命名策略函数，上述示例都可用。唯一重要的是，promotions模块只能包含计算订单折扣的函数。如果有人在promotions模块中使用不同的签名定义函数，那么best_promo函数尝试将其应用到订单上时会出错。可以添加更为严格的测试，审查传给实例的参数，进一步过滤函数。上述示例的目的不是提供完善的方案，而是强调模块内省的一种用途。</p><p>动态收集促销折扣函数更为显式的一种方案是使用简单的装饰器。</p><h1 id="命令模式">命令模式</h1><p>命令设计模式也可以通过把函数作为参数传递而简化。</p><img src="http://www.plantuml.com/plantuml/svg/XPB1IiD054NtynMFhdIHG6kpAuBejkXUHAR9mmvqPa9c0fLQ4AJWIX3x1Q8W2EhABgH_KzD-Xed9n9cuw2plE-zov_A6B4907kjBuCW7c91mH9M2WpWUiP1g9aMbz56aX0wKJcYeuL1oJaK44mBvcnXz2ZZ6CDMuiqkcrU9nZCB5_pCdL6dS1lLfcCXjq94CKuv2Lm0J2XDzhd6iVo6pthloF3kPEx3Zk1Cx0x5AWfvhLxG5qZCz4UU3dhTVvoH_edJTxTwyqo6B8XHd2RiOwaP0rxj1EfP2QeJMzzjZThjOlxwtW2eGxKhUVDoivo-RwrafTmnzlrnzFPNQNgLbTy_P_BD6kmQTBLRB1tiX8A8Dlk-Sa-Y0NrwJoUmNpdQP-KPXsiqdTKzs7SKySFzTIiw9b59z4CrcHF03"><p>菜单驱动的文本编辑器的UML类图，使用命令设计模式实现。各个命令可以有不同的接收者（实现操作的对象）。对PasteCommand来说，接收者是Document。对OpenCommand来说，接收者是应用程序。</p><p>命令模式的目的是解耦调用操作对象（调用者）和提供实现的对象（接收者）。这个模式的做法是，在二者之间放一个Command对象，让它实现只有一个方法（execute）的接口，调用接收者中的方法执行所需的操作。这样，调用者无需了解接收者的接口，而且不同的接收者可以适应不同的Command子类。调用者有一个具体的命令，通过调用execute方法执行。MacroCommand可能保存一系列命令，它的execute()方法会在各个命令上调用相同的方法。</p><p>我们可以不为调用者提供一个Command实例，而是给它一个函数。此时，调用者不用调用command.execute()，直接调用command()即可。MacroCommand可以实现成定义了<code>__call__</code>方法的类。这样，MacroCommand的实例就是可调用对象，各自维护着一个函数列表，供以后调用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MacroCommand</span>:</span></span><br><span class="line">    <span class="string">"""一个执行一组命令的命令"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, commands)</span>:</span></span><br><span class="line">        self.commands = list(commands)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> command <span class="keyword">in</span> self.commands:</span><br><span class="line">            command()</span><br></pre></td></tr></table></figure><p>使用一等函数对命令模式的重新审视到此结束。站在一定高度上看，这里采用的方式与策略模式所用的类似：<strong>把实现单方法接口的类的实例替换成可调用对象</strong>。毕竟，每个Python可调用对象都实现了单方法接口，这个方法就是<code>__call__</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> command </tag>
            
            <tag> design patterns </tag>
            
            <tag> Fluent Python </tag>
            
            <tag> first-class functions </tag>
            
            <tag> strategy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>networkx all simple paths</title>
      <link href="/source-code/networkx-all-simple-paths/"/>
      <url>/source-code/networkx-all-simple-paths/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><figcaption><span>simple_paths.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">all_simple_paths</span><span class="params">(G, source, target, cutoff=None)</span>:</span></span><br><span class="line">    <span class="string">"""Generate all simple paths in the graph G from source to target.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    A simple path is a path with no repeated nodes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    G : NetworkX graph</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    source : node</span></span><br><span class="line"><span class="string">       Starting node for path</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    target : nodes</span></span><br><span class="line"><span class="string">       Single node or iterable of nodes at which to end path</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    cutoff : integer, optional</span></span><br><span class="line"><span class="string">        Depth to stop the search. Only paths of length &lt;= cutoff are returned.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    path_generator: generator</span></span><br><span class="line"><span class="string">       A generator that produces lists of simple paths.  If there are no paths</span></span><br><span class="line"><span class="string">       between the source and target within the given cutoff the generator</span></span><br><span class="line"><span class="string">       produces no output.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Examples</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    This iterator generates lists of nodes::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; G = nx.complete_graph(4)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; for path in nx.all_simple_paths(G, source=0, target=3):</span></span><br><span class="line"><span class="string">        ...     print(path)</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">        [0, 1, 2, 3]</span></span><br><span class="line"><span class="string">        [0, 1, 3]</span></span><br><span class="line"><span class="string">        [0, 2, 1, 3]</span></span><br><span class="line"><span class="string">        [0, 2, 3]</span></span><br><span class="line"><span class="string">        [0, 3]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    You can generate only those paths that are shorter than a certain</span></span><br><span class="line"><span class="string">    length by using the `cutoff` keyword argument::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; paths = nx.all_simple_paths(G, source=0, target=3, cutoff=2)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; print(list(paths))</span></span><br><span class="line"><span class="string">        [[0, 1, 3], [0, 2, 3], [0, 3]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    To get each path as the corresponding list of edges, you can use the</span></span><br><span class="line"><span class="string">    :func:`networkx.utils.pairwise` helper function::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; paths = nx.all_simple_paths(G, source=0, target=3)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; for path in map(nx.utils.pairwise, paths):</span></span><br><span class="line"><span class="string">        ...     print(list(path))</span></span><br><span class="line"><span class="string">        [(0, 1), (1, 2), (2, 3)]</span></span><br><span class="line"><span class="string">        [(0, 1), (1, 3)]</span></span><br><span class="line"><span class="string">        [(0, 2), (2, 1), (1, 3)]</span></span><br><span class="line"><span class="string">        [(0, 2), (2, 3)]</span></span><br><span class="line"><span class="string">        [(0, 3)]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Pass an iterable of nodes as target to generate all paths ending in any of several nodes::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; G = nx.complete_graph(4)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; for path in nx.all_simple_paths(G, source=0, target=[3, 2]):</span></span><br><span class="line"><span class="string">        ...     print(path)</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">        [0, 1, 2]</span></span><br><span class="line"><span class="string">        [0, 1, 2, 3]</span></span><br><span class="line"><span class="string">        [0, 1, 3]</span></span><br><span class="line"><span class="string">        [0, 1, 3, 2]</span></span><br><span class="line"><span class="string">        [0, 2]</span></span><br><span class="line"><span class="string">        [0, 2, 1, 3]</span></span><br><span class="line"><span class="string">        [0, 2, 3]</span></span><br><span class="line"><span class="string">        [0, 3]</span></span><br><span class="line"><span class="string">        [0, 3, 1, 2]</span></span><br><span class="line"><span class="string">        [0, 3, 2]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Iterate over each path from the root nodes to the leaf nodes in a</span></span><br><span class="line"><span class="string">    directed acyclic graph using a functional programming approach::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; from itertools import chain</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; from itertools import product</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; from itertools import starmap</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; from functools import partial</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt;</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; chaini = chain.from_iterable</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt;</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; G = nx.DiGraph([(0, 1), (1, 2), (0, 3), (3, 2)])</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; roots = (v for v, d in G.in_degree() if d == 0)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; leaves = (v for v, d in G.out_degree() if d == 0)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; all_paths = partial(nx.all_simple_paths, G)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; list(chaini(starmap(all_paths, product(roots, leaves))))</span></span><br><span class="line"><span class="string">        [[0, 1, 2], [0, 3, 2]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The same list computed using an iterative approach::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; G = nx.DiGraph([(0, 1), (1, 2), (0, 3), (3, 2)])</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; roots = (v for v, d in G.in_degree() if d == 0)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; leaves = (v for v, d in G.out_degree() if d == 0)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; all_paths = []</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; for root in roots:</span></span><br><span class="line"><span class="string">        ...     for leaf in leaves:</span></span><br><span class="line"><span class="string">        ...         paths = nx.all_simple_paths(G, root, leaf)</span></span><br><span class="line"><span class="string">        ...         all_paths.extend(paths)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; all_paths</span></span><br><span class="line"><span class="string">        [[0, 1, 2], [0, 3, 2]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Iterate over each path from the root nodes to the leaf nodes in a</span></span><br><span class="line"><span class="string">    directed acyclic graph passing all leaves together to avoid unnecessary</span></span><br><span class="line"><span class="string">    compute::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; G = nx.DiGraph([(0, 1), (2, 1), (1, 3), (1, 4)])</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; roots = (v for v, d in G.in_degree() if d == 0)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; leaves = [v for v, d in G.out_degree() if d == 0]</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; all_paths = []</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; for root in roots:</span></span><br><span class="line"><span class="string">        ...     paths = nx.all_simple_paths(G, root, leaves)</span></span><br><span class="line"><span class="string">        ...     all_paths.extend(paths)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; all_paths</span></span><br><span class="line"><span class="string">        [[0, 1, 3], [0, 1, 4], [2, 1, 3], [2, 1, 4]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Notes</span></span><br><span class="line"><span class="string">    -----</span></span><br><span class="line"><span class="string">    This algorithm uses a modified depth-first search to generate the</span></span><br><span class="line"><span class="string">    paths [1]_.  A single path can be found in $O(V+E)$ time but the</span></span><br><span class="line"><span class="string">    number of simple paths in a graph can be very large, e.g. $O(n!)$ in</span></span><br><span class="line"><span class="string">    the complete graph of order $n$.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    References</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    .. [1] R. Sedgewick, "Algorithms in C, Part 5: Graph Algorithms",</span></span><br><span class="line"><span class="string">       Addison Wesley Professional, 3rd ed., 2001.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    See Also</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    all_shortest_paths, shortest_path</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> source <span class="keyword">not</span> <span class="keyword">in</span> G:</span><br><span class="line">        <span class="keyword">raise</span> nx.NodeNotFound(<span class="string">'source node %s not in graph'</span> % source)</span><br><span class="line">    <span class="keyword">if</span> target <span class="keyword">in</span> G:</span><br><span class="line">        targets = &#123;target&#125;</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            targets = set(target)</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="keyword">raise</span> nx.NodeNotFound(<span class="string">'target node %s not in graph'</span> % target)</span><br><span class="line">    <span class="keyword">if</span> source <span class="keyword">in</span> targets:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">if</span> cutoff <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        cutoff = len(G) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> cutoff &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">if</span> G.is_multigraph():</span><br><span class="line">        <span class="keyword">return</span> _all_simple_paths_multigraph(G, source, targets, cutoff)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> _all_simple_paths_graph(G, source, targets, cutoff)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># source: single node</span></span><br><span class="line"><span class="comment"># targets: set of nodes</span></span><br><span class="line"><span class="comment"># cutoff: maximum edges in a path</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_all_simple_paths_graph</span><span class="params">(G, source, targets, cutoff)</span>:</span></span><br><span class="line">    visited = collections.OrderedDict.fromkeys([source])</span><br><span class="line">    stack = [iter(G[source])]  <span class="comment"># 添加邻接结点。G[node]类似于字典，key是邻接结点，value是边的属性</span></span><br><span class="line">    <span class="keyword">while</span> stack:  <span class="comment"># len(stack) &gt; 0时，bool(stack) = True</span></span><br><span class="line">        children = stack[<span class="number">-1</span>]</span><br><span class="line">        child = next(children, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> child <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            stack.pop()  <span class="comment"># 回退到上一个访问结点</span></span><br><span class="line">            visited.popitem()  <span class="comment"># 已访问结点做同样的操作</span></span><br><span class="line">        <span class="keyword">elif</span> len(visited) &lt; cutoff:</span><br><span class="line">            <span class="keyword">if</span> child <span class="keyword">in</span> visited:  <span class="comment"># 跳过已访问结点</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> child <span class="keyword">in</span> targets:</span><br><span class="line">                <span class="keyword">yield</span> list(visited) + [child]</span><br><span class="line">            visited[child] = <span class="literal">None</span>  <span class="comment"># 将当前结点放入visited中，值无所谓，这里用的是None</span></span><br><span class="line">            <span class="keyword">if</span> targets - set(visited.keys()):  <span class="comment"># 如果存在尚未访问的目标</span></span><br><span class="line">                stack.append(iter(G[child]))  <span class="comment"># 当前结点的邻接结点入栈</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 所有目标均已访问</span></span><br><span class="line">                visited.popitem()  <span class="comment"># 停止寻找</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># len(visited) == cutoff:</span></span><br><span class="line">            <span class="comment"># set(children) | &#123;child&#125;: 剩余的未访问结点</span></span><br><span class="line">            <span class="keyword">for</span> target <span class="keyword">in</span> (targets &amp; (set(children) | &#123;child&#125;)) - set(visited.keys()):</span><br><span class="line">                <span class="keyword">yield</span> list(visited) + [target]</span><br><span class="line">            stack.pop()</span><br><span class="line">            visited.popitem()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_all_simple_paths_multigraph</span><span class="params">(G, source, targets, cutoff)</span>:</span></span><br><span class="line">    visited = collections.OrderedDict.fromkeys([source])</span><br><span class="line">    stack = [(v <span class="keyword">for</span> u, v <span class="keyword">in</span> G.edges(source))]  <span class="comment"># G.edges(u) returns all edges from u</span></span><br><span class="line">    <span class="comment"># so when there exsit multi-edges between u and v, the v can also appear repeatedly</span></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        children = stack[<span class="number">-1</span>]</span><br><span class="line">        child = next(children, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> child <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            stack.pop()</span><br><span class="line">            visited.popitem()</span><br><span class="line">        <span class="keyword">elif</span> len(visited) &lt; cutoff:</span><br><span class="line">            <span class="keyword">if</span> child <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> child <span class="keyword">in</span> targets:</span><br><span class="line">                <span class="keyword">yield</span> list(visited) + [child]</span><br><span class="line">            visited[child] = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> targets - set(visited.keys()):</span><br><span class="line">                stack.append((v <span class="keyword">for</span> u, v <span class="keyword">in</span> G.edges(child)))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                visited.popitem()</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># len(visited) == cutoff:</span></span><br><span class="line">            <span class="keyword">for</span> target <span class="keyword">in</span> targets - set(visited.keys()):</span><br><span class="line">                count = ([child] + list(children)).count(target)</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">                    <span class="keyword">yield</span> list(visited) + [target]</span><br><span class="line">            stack.pop()</span><br><span class="line">            visited.popitem()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithms </tag>
            
            <tag> networkx </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python repr 函数</title>
      <link href="/programming/python-repr-method/"/>
      <url>/programming/python-repr-method/</url>
      
        <content type="html"><![CDATA[<h1 id="repr">repr</h1><blockquote><p><a href="https://devdocs.io/python~3.6/library/functions#repr" target="_blank" rel="noopener"><code>repr(object)</code></a></p><p>Return a string containing a printable representation of an object. For many types, this function makes an attempt to return a string that would yield an object with the same value when passed to eval(), otherwise the representation is a string enclosed in angle brackets that contains the name of the type of the object together with additional information often including the name and address of the object.</p></blockquote><p>repr的返回结果大致有两种类型：</p><ul><li>返回一个字符串，这个字符串所代表的代码与原对象相同，即 <code>eval(repr(object) == object</code>。</li><li>返回一组尖括号，括号内包含了对象的名称和地址。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Student = namedtuple(<span class="string">'Student'</span>, <span class="string">'id name gender'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>alice = Student(<span class="number">1</span>, <span class="string">'Alice'</span>, <span class="string">'female'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>alice</span><br><span class="line">Student(id=<span class="number">1</span>, name=<span class="string">'Alice'</span>, gender=<span class="string">'female'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval(repr(alice)) == alice</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, id, name, gender)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.id, self.name, self.gender = id, name, gender</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john = Person(<span class="number">2</span>, <span class="string">'John'</span>, <span class="string">'male'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john</span><br><span class="line">&lt;__main__.Person object at <span class="number">0x10bf970b8</span>&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="自定义返回值">自定义返回值</h1><p>自定义返回值只需实现 <code>__repr__</code> 方法。可以看到默认的输出是第二种，想实现类似第一种可以像下面这样做。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="string">"%s(%s)"</span> % (self.__class__.__name__, <span class="string">', '</span>.join(<span class="string">'%s=%r'</span> % (k, v) <span class="keyword">for</span> k, v <span class="keyword">in</span> self.__dict__.items()))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Person.__repr__ = func</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john</span><br><span class="line">Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval(repr(john)) == john</span><br><span class="line"><span class="literal">False</span>                  <span class="comment"># 不相等是因为没有定义__eq__</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval(repr(john))   <span class="comment"># 但内容是相同的</span></span><br><span class="line">Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>)</span><br></pre></td></tr></table></figure><p>优点：对简单类通用。</p><p>缺点：可能会输出不希望被看到的私有属性。如果内部变量有循环引用的话会陷入无限递归。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>marry = Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john = Person(<span class="number">2</span>, <span class="string">'John'</span>, <span class="string">'male'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>marry._sepouse = john  <span class="comment"># 不想被看到的信息</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>marry</span><br><span class="line">Person(id=<span class="number">3</span>, name=<span class="string">'Marry'</span>, gender=<span class="string">'female'</span>, _sepouse=Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john._sepouse = marry  <span class="comment"># 互相引用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john  <span class="comment"># 无限递归</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> func</span><br><span class="line">  ...  <span class="comment"># 省略</span></span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;genexpr&gt;</span><br><span class="line">RecursionError: maximum recursion depth exceeded</span><br></pre></td></tr></table></figure><h1 id="隐藏私有属性">隐藏私有属性</h1><p>常用做法：指定传入的字典即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, id, name, gender)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.id, self.name, self.gender = id, name, gender</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">"%s(%s)"</span> % (self.__class__.__name__, <span class="string">', '</span>.join(<span class="string">'%s=%r'</span> % (k, v) <span class="keyword">for</span> k, v <span class="keyword">in</span> self.get_params().items()))</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">get_params</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> dict(id=self.id, name=self.name, gender=self.gender)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>)</span><br><span class="line">Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john = Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>marry = Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john._sepouse = marry</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>marry._sepouse = john</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john</span><br><span class="line">Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>marry</span><br><span class="line">Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>)</span><br></pre></td></tr></table></figure><h1 id="避免无限递归">避免无限递归</h1><p>reprlib 提供了一个装饰器，能检测递归调用，并用指定的字符代替调用。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/reprlib#reprlib.recursive_repr" target="_blank" rel="noopener"><code>@reprlib.recursive_repr(fillvalue=&quot;...&quot;)</code></a></p><p>Decorator for <code>__repr__()</code> methods to detect recursive calls within the same thread. If a recursive call is made, the fillvalue is returned, otherwise, the usual <code>__repr__()</code> call is made.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, id, name, gender)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.id, self.name, self.gender = id, name, gender</span><br><span class="line"><span class="meta">... </span>    @reprlib.recursive_repr()  <span class="comment"># 因为装饰器有参数，所以必须加上()</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">'%s(%s)'</span> % (type(self).__name__, <span class="string">', '</span>.join(<span class="string">'%s=%r'</span> % (k, v) <span class="keyword">for</span> k, v <span class="keyword">in</span> self.__dict__.items()))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>marry = Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john = Person(<span class="number">2</span>, <span class="string">'John'</span>, <span class="string">'male'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>marry</span><br><span class="line">Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>)  <span class="comment"># 无递归调用时</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>marry._sepouse = john</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john._sepouse = marry  <span class="comment"># 有递归调用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>marry</span><br><span class="line">Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>, _sepouse=Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>, _sepouse=...))</span><br></pre></td></tr></table></figure><h1 id="规避过长的描述">规避过长的描述</h1><p><code>repr()</code> 函数的目的是方便程序员检查、调试程序。如果对象的属性中包含过长的列表、字符串等属性，朴素的 <code>repr()</code> 函数会打印全部内容。其结果会在控制台或日志文件中占据大量篇幅，与初衷相悖。此时推荐的做法是输出其简略的字符串表示形式。万幸，我们无需重复造轮子，也不一定造地好。<code>reprlib.repr()</code> 函数能帮我们达到预期的结果。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/reprlib#reprlib.repr" target="_blank" rel="noopener"><code>reprlib.repr(obj)</code></a></p><p>This is the repr() method of aRepr. It returns a string similar to that returned by the built-in function of the same name, but with limits on most sizes.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array(range(<span class="number">10000</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a  <span class="comment"># numpy就做了类似处理</span></span><br><span class="line">array([   <span class="number">0</span>,    <span class="number">1</span>,    <span class="number">2</span>, ..., <span class="number">9997</span>, <span class="number">9998</span>, <span class="number">9999</span>])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> reprlib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = list(range(<span class="number">10000</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reprlib.repr(b)</span><br><span class="line"><span class="string">'[0, 1, 2, 3, 4, 5, ...]'</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> reprlib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Text</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, content)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.content = content</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">'Text(%s)'</span> % reprlib.repr(self.content)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = Text(<span class="string">'The beginning to learn a programming language is to print "Hello World!"'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">Text(<span class="string">'The beginnin...Hello World!"'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> repr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从定位参数到仅限关键字参数</title>
      <link href="/notes/fluent-python/from-positional-to-keyword-only-parameters/"/>
      <url>/notes/fluent-python/from-positional-to-keyword-only-parameters/</url>
      
        <content type="html"><![CDATA[<h1 id="从定位参数到仅限关键字参数">从定位参数到仅限关键字参数</h1><p>Python最好的特性之一是提供了极为灵活的参数处理机制，而且Python3进一步提供了仅限关键字参数（keyword-only argument）。与之密切相关的是，调用函数时使用<code>*</code>和<code>**</code>“展开”可迭代对象，映射到单个参数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tag</span><span class="params">(name, *content, cls=None, **attrs)</span>:</span></span><br><span class="line">    <span class="string">"""生成一个或多个HTML标签"""</span></span><br><span class="line">    <span class="keyword">if</span> cls <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        attrs[<span class="string">'class'</span>] = cls</span><br><span class="line">    <span class="keyword">if</span> attrs:</span><br><span class="line">        attr_str = <span class="string">''</span>.join(<span class="string">' %s="%s"'</span> % (attr, value)</span><br><span class="line">            <span class="keyword">for</span> attr, value <span class="keyword">in</span> sorted(attrs.items()))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        attr_str = <span class="string">''</span></span><br><span class="line">    <span class="keyword">if</span> content:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'\n'</span>.join(<span class="string">'&lt;%s%s&gt;%s&lt;/%s&gt;'</span> %</span><br><span class="line">            (name, attr_str, c, name) <span class="keyword">for</span> c <span class="keyword">in</span> content)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;%s%s /&gt;'</span> % (name, attr_str)</span><br></pre></td></tr></table></figure><a id="more"></a><p>tag函数的调用方式很多</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag(<span class="string">'br'</span>)  <span class="comment"># A</span></span><br><span class="line"><span class="string">'&lt;br /&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag(<span class="string">'p'</span>, <span class="string">'hello'</span>, <span class="string">'sidebar'</span>)  <span class="comment"># B</span></span><br><span class="line"><span class="string">'&lt;p&gt;hello&lt;/p&gt;\n&lt;p&gt;sidebar&lt;/p&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag(<span class="string">'p'</span>, <span class="string">'hello'</span>, cls=<span class="string">'sidebar'</span>)  <span class="comment"># C</span></span><br><span class="line"><span class="string">'&lt;p class="sidebar"&gt;hello&lt;/p&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_tag = &#123;<span class="string">'name'</span>: <span class="string">'img'</span>, <span class="string">'title'</span>: <span class="string">'Sunset Boulevard'</span>, <span class="string">'src'</span>: <span class="string">'sunset.jpg'</span>, <span class="string">'cls'</span>: <span class="string">'framed'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag(**my_tag)  <span class="comment"># D</span></span><br><span class="line"><span class="string">'&lt;img class="framed" src="sunset.jpg" title="Sunset Boulevard" /&gt;'</span></span><br></pre></td></tr></table></figure><p>A. 传入单个定位参数。</p><p>B. 传入多个定位参数，根据函数定义，第1个参数被传入name，剩余的未命名定位参数被传入content。</p><p>C. cls参数只能通过关键字参数指定，它一定不会捕获未命名的定位参数。（因为cls参数在有<code>*</code>参数的后面（不能放在<code>**</code>参数的后面），若不指定关键字，则编译器无法判断它是该传入content还是该传入cls）</p><p>D. 在my_tag前面加上<code>**</code>，字典中的所有元素作为单个参数传入，同名键会绑定到对应的具名参数上，余下的被<code>**attrs</code>捕获。</p><p>如果不想支持数量不定的定位参数（即<code>*content</code>），但想支持仅限关键字参数，在签名中放一个<code>*</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, *, b)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> a, b</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment"># 强制以关键字传入</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: f() takes <span class="number">1</span> positional argument but <span class="number">2</span> were given</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">1</span>, b=<span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h1 id="获取关于参数的信息">获取关于参数的信息</h1><p>查看<code>__defaultS__</code>、<code>__code__.co_varnames</code>、<code>__code__.co_argcount</code>的值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, b=None, *c, d=None, **e)</span>:</span> f, g = <span class="number">0</span>, <span class="number">1</span>; <span class="keyword">return</span> f + g</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__defaults__  <span class="comment"># 形式参数的默认值</span></span><br><span class="line">(<span class="literal">None</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__kwdefaults__  <span class="comment"># 仅限关键字形式参数的默认值</span></span><br><span class="line">&#123;<span class="string">'d'</span>: <span class="literal">None</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__code__.co_varnames  <span class="comment"># 参数名称+函数定义体中创建的局部变量</span></span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'d'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__code__.co_argcount  <span class="comment"># 参数数量（看来不包括带*参数以及在其后面的参数）</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>上述组织方式不友好，我们有更好的模块inspect模块。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> inspect <span class="keyword">import</span> signature</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sig = signature(f)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sig</span><br><span class="line">&lt;Signature (a, b=<span class="literal">None</span>, *c, d=<span class="literal">None</span>, **e)&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name, param <span class="keyword">in</span> sig.parameters.items():</span><br><span class="line"><span class="meta">... </span>    print(param.kind, <span class="string">':'</span>, name, <span class="string">'='</span>, param.default)</span><br><span class="line">...</span><br><span class="line">POSITIONAL_OR_KEYWORD : a = &lt;<span class="class"><span class="keyword">class</span> '<span class="title">inspect</span>.<span class="title">_empty</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">POSITIONAL_OR_KEYWORD</span> :</span> b = <span class="literal">None</span></span><br><span class="line">VAR_POSITIONAL : c = &lt;<span class="class"><span class="keyword">class</span> '<span class="title">inspect</span>.<span class="title">_empty</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">KEYWORD_ONLY</span> :</span> d = <span class="literal">None</span></span><br><span class="line">VAR_KEYWORD : e = &lt;<span class="class"><span class="keyword">class</span> '<span class="title">inspect</span>.<span class="title">_empty</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>signature返回一个Signature对象，它有一个parameters属性，这是一个有序映射，把参数名和Parameter对象对应起来。Parameter也有自己的属性。例如name、default、kind、annotation（下一节函数注解中使用此属性获取附加的元数据）。特殊的<code>inspect._empty</code>表示参数没有默认值。kind属性是<code>_ParameterKind</code>类中的5个值之一。</p><ul><li><p>POSITIONAL_OR_KEYWORD：可以通过定位参数和关键字参数传入的形参（多数Python函数的参数属于此类）。</p></li><li><p>VAR_POSITIONAL：定位参数元组。</p></li><li><p>VAR_KEYWORD：关键字参数字典。</p></li><li><p>KEYWORD_ONLY：仅限关键字参数（Python3新增）。</p></li><li><p>POSITIONAL_ONLY：仅限定位参数；目前，Python声明函数的句法不支持，但是有些使用C语言实现且不接受关键字参数的函数（如divmod）支持。</p></li></ul><p>Signature对象有个bind方法，它可以把任意个参数绑定到签名中的形参上，所用的规则与实参到形参的匹配方式一样。框架可以使用这个方法在真正调用函数前验证参数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> inspect <span class="keyword">import</span> signature</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sig = signature(tag)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_tag = &#123;<span class="string">'name'</span>: <span class="string">'img'</span>, <span class="string">'title'</span>: <span class="string">'Sunset Boulevard'</span>, <span class="string">'src'</span>: <span class="string">'sunset.jpg'</span>, <span class="string">'cls'</span>: <span class="string">'framed'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bound_args = sig.bind(**my_tag)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bound_args</span><br><span class="line">&lt;BoundArguments (name=<span class="string">'img'</span>, cls=<span class="string">'framed'</span>, attrs=&#123;<span class="string">'title'</span>: <span class="string">'Sunset Boulevard'</span>, <span class="string">'src'</span>: <span class="string">'sunset.jpg'</span>&#125;)&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> bound_args.arguments.items():</span><br><span class="line"><span class="meta">... </span>    print(k, <span class="string">'='</span>, v)</span><br><span class="line">...</span><br><span class="line">name = img</span><br><span class="line">cls = framed</span><br><span class="line">attrs = &#123;<span class="string">'title'</span>: <span class="string">'Sunset Boulevard'</span>, <span class="string">'src'</span>: <span class="string">'sunset.jpg'</span>&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> my_tag[<span class="string">'name'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bound_args = sig.bind(**my_tag)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"/Users/cws/opt/anaconda3/envs/python36/lib/python3.6/inspect.py"</span>, line <span class="number">2997</span>, <span class="keyword">in</span> bind</span><br><span class="line">    <span class="keyword">return</span> args[<span class="number">0</span>]._bind(args[<span class="number">1</span>:], kwargs)</span><br><span class="line">  File <span class="string">"/Users/cws/opt/anaconda3/envs/python36/lib/python3.6/inspect.py"</span>, line <span class="number">2912</span>, <span class="keyword">in</span> _bind</span><br><span class="line">    <span class="keyword">raise</span> TypeError(msg) <span class="keyword">from</span> <span class="literal">None</span></span><br><span class="line">TypeError: missing a required argument: <span class="string">'name'</span></span><br></pre></td></tr></table></figure><h1 id="函数注解">函数注解</h1><p>Python3提供了一种句法，用于为函数声明中的参数和返回值附加元数据。函数声明中的各个参数可以在<code>:</code>之后增加注解表达式。</p><p>Python对注解所做的唯一的事情是，把它们存储在函数的<code>__annotations__</code>属性里。仅此而已，Python不做检查、不做强制、不做验证，什么操作都不做。换句话说，注解对Python解释器没有任何意义。注解只是元数据，可以供IDE、框架和装饰器等工具使用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, b, c, d)</span>:</span> <span class="keyword">pass</span>  <span class="comment"># 常规</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, b: str, c: <span class="string">'int &gt; 0'</span>, d: float=<span class="number">0.0</span>)</span> -&gt; str:</span> <span class="keyword">pass</span>  <span class="comment"># 加注解</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__annotations__</span><br><span class="line">&#123;'b': &lt;class 'str'&gt;, 'c': 'int &gt; 0', 'd': &lt;class 'float'&gt;, 'return': &lt;class 'str'&gt;&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> inspect <span class="keyword">import</span> signature</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sig = signature(f)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sig.return_annotation</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">for</span> <span class="title">param</span> <span class="title">in</span> <span class="title">sig</span>.<span class="title">parameters</span>.<span class="title">values</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    note = repr(param.annotation).ljust(<span class="number">26</span>)</span><br><span class="line"><span class="meta">... </span>    print(note, <span class="string">':'</span>, param.name, <span class="string">'='</span>, param.default)</span><br><span class="line">...</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">inspect</span>.<span class="title">_empty</span>'&gt;   :</span> a = &lt;<span class="class"><span class="keyword">class</span> '<span class="title">inspect</span>.<span class="title">_empty</span>'&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">str</span>'&gt;              :</span> b = &lt;<span class="class"><span class="keyword">class</span> '<span class="title">inspect</span>.<span class="title">_empty</span>'&gt;</span></span><br><span class="line"><span class="class">'<span class="title">int</span> &gt; 0'                  :</span> c = &lt;<span class="class"><span class="keyword">class</span> '<span class="title">inspect</span>.<span class="title">_empty</span>'&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">float</span>'&gt;            :</span> d = <span class="number">0.0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> parameters </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一等函数</title>
      <link href="/notes/fluent-python/first-class-functions/"/>
      <url>/notes/fluent-python/first-class-functions/</url>
      
        <content type="html"><![CDATA[<h1 id="把函数试作对象">把函数试作对象</h1><p>在 Python 中，整数、字符串、字典和函数都是一等对象。“一等对象”为满足下述条件的过程实体：</p><ul><li>在运行时创建</li><li>能赋值给变量或数据结构中的元素</li><li>能作为参数传给函数</li><li>能作为函数的返回结果</li></ul><p>人们经常将“把函数视作一等对象”简称为“一等函数”。这样说并不完美，似乎表明这是函数中的特殊群体。在 Python 中，所有函数都是一等对象。</p><a id="more"></a><h1 id="高阶函数">高阶函数</h1><p>接受函数为参数，或者把函数作为结果返回的函数都是高阶函数（higher-order function）。使用高阶函数是函数式编程的特点之一。常见的高阶函数有 <code>max</code>, <code>min</code>, <code>sorted</code>, <code>map</code>, <code>filter</code>, <code>reduce</code>。</p><p><code>max</code>, <code>min</code>, <code>sorted</code> 中的 key 参数接受函数，任何单参数函数都能作为 key 参数的值。例如，想根据单词长度排序时，只需把 len 函数传入。若想创建押韵词典（水果中的各类浆果 *berry 都排在一起），可以把各个单词反过来拼写，然后排序。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits = [<span class="string">'strawberry'</span>, <span class="string">'fig'</span>, <span class="string">'apple'</span>, <span class="string">'cherry'</span>, <span class="string">'raspberry'</span>, <span class="string">'banana'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(fruits, key=len)</span><br><span class="line">[<span class="string">'fig'</span>, <span class="string">'apple'</span>, <span class="string">'cherry'</span>, <span class="string">'banana'</span>, <span class="string">'raspberry'</span>, <span class="string">'strawberry'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(fruits, key=<span class="keyword">lambda</span> i: i[::<span class="number">-1</span>])</span><br><span class="line">[<span class="string">'banana'</span>, <span class="string">'apple'</span>, <span class="string">'fig'</span>, <span class="string">'raspberry'</span>, <span class="string">'strawberry'</span>, <span class="string">'cherry'</span>]</span><br></pre></td></tr></table></figure><p><code>map</code>, <code>filter</code>, <code>reduce</code> 在多数使用场景下都有更好的替代品。</p><h2 id="mapfilter和reduce的替代品">map、filter和reduce的替代品</h2><p>在 Python3 中，<code>map</code> 和 <code>filter</code> 返回生成器（一种迭代器），因此它们的直接替代品是生成器表达式（在 Python2 中，这两个函数返回列表，因此最接近的替代品是列表推导）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">"""Returns n!"""</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> n * fact(n - <span class="number">1</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(fact, range(<span class="number">6</span>))</span><br><span class="line">&lt;map object at <span class="number">0x10c597f98</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(fact(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">6</span>))</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x10c58b780</span>&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(fact, range(<span class="number">6</span>)))</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[fact(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">6</span>)]</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(fact, filter(<span class="keyword">lambda</span> n: n % <span class="number">2</span>, range(<span class="number">6</span>))))</span><br><span class="line">[<span class="number">1</span>, <span class="number">6</span>, <span class="number">120</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[fact(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">6</span>) <span class="keyword">if</span> n % <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">6</span>, <span class="number">120</span>]</span><br></pre></td></tr></table></figure><p><code>reduce</code> 这个函数最常用于求和，可使用 <code>sum</code> 函数替代，在可读性和性能方面，这是一项重大改善。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> add</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(add, range(<span class="number">100</span>))</span><br><span class="line"><span class="number">4950</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum(range(<span class="number">100</span>))</span><br><span class="line"><span class="number">4950</span></span><br></pre></td></tr></table></figure><h2 id="归约函数">归约函数</h2><p><code>sum</code> 和 <code>reduce</code> 的通用思想是把某个操作连续应用到序列的元素上，累计之前的结果，把一系列值归约成一个值。<code>all</code> 和 <code>any</code> 也是内置的归约函数。</p><blockquote><p><code>all(iterable)</code></p><p>Return True if all elements of the iterable are true (or if the iterable is empty).</p><p><code>any(iterable)</code></p><p>Return True if any element of the iterable is true. If the iterable is empty, return False.</p></blockquote><h1 id="匿名函数">匿名函数</h1><p>lambda 关键字在 Python 表达式内创建匿名函数。然而，Python 简单的句法限制了 lambda 函数的定义体只能使用纯表达式。换句话说，lambda 函数的定义体中不能赋值，也不能使用 while 和 try 等 Python 语句。</p><p>如果使用 lambda 表达式导致一段代码难以理解，Fredrik Lundh 建议像下面这样重构。</p><p>（1）编写注释，说明 lambda 表达式的作用。</p><p>（2）研究一会注释，并找出一个名称来概括注释。</p><p>（3）把 lambda 表达式转换成def语句，使用那个名称来定义函数。</p><p>（4）删除注释。</p><p>与def语句一样，lambda 表达式会创建函数对象。这是 Python 中几种可调用对象的一种。</p><h1 id="可调用对象">可调用对象</h1><p>除了用户定义的函数，调用运算符，即 <code>()</code>，还可以应用到其他对象上。如果想判断对象能否调用，可以使用内置的 <code>callable</code> 函数。Python 数据模型文档列出了 7 种可调用对象。</p><ul><li>用户定义的函数：使用 def 语句或 lambda 表达式创建。</li><li>内置函数：使用 C 语言（CPython）实现的函数，如 len 或 <code>time.strftime</code>。</li><li>内置方法：使用 C 语言实现的方法，如 <code>dict.get</code>。</li><li>方法：在类的定义体中定义的函数。</li><li>类：调用类时会运行类的 <code>__new__</code> 方法创建一个实例，然后运行 <code>__init__</code> 方法，初始化实例，最后把实例返回给调用方。因为 Python 没有 new 运算符，所以调用类相当于调用函数。</li><li>类的实例：如果类定义了 <code>__call__</code> 方法，那么它的实例可以作为函数调用。</li><li>生成器函数：使用 yield 关键字的函数或方法。调用生成器函数返回的是生成器对象。生成器函数在很多方面与其他可调用对象不同。</li></ul><p>Python 中有各种各样可调用的类型，因此判断对象能否调用，最安全的方法是使用内置的 callable 函数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>abs, str, <span class="number">1</span></span><br><span class="line">(&lt;built-in function abs&gt;, &lt;class 'str'&gt;, 1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[callable(obj) <span class="keyword">for</span> obj <span class="keyword">in</span> (abs, str, <span class="number">1</span>)]</span><br><span class="line">[<span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">False</span>]</span><br></pre></td></tr></table></figure><h1 id="函数内省">函数内省</h1><p>函数对象有很多属性。使用 dir 函数可以探知 fact 具有以下属性。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(fact)</span><br><span class="line">[<span class="string">'__annotations__'</span>, <span class="string">'__call__'</span>, <span class="string">'__class__'</span>, <span class="string">'__closure__'</span>, <span class="string">'__code__'</span>, <span class="string">'__defaults__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__get__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__globals__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__kwdefaults__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__module__'</span>, <span class="string">'__name__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__qualname__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>]</span><br></pre></td></tr></table></figure><p>其中大多数属性是 Python 对象共有的。</p><p>与用户定义的常规类一样，函数使用 <code>__dict__</code> 属性存储赋予它的用户属性。一般来说，为函数随意赋予属性不是很常见的做法。</p><p>下面重点说明函数专有而用户定义的一般对象没有的属性。计算两个属性集合的差集便能得到函数专有属性列表。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = C()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span> <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(set(dir(func)) - set(dir(obj)))</span><br><span class="line">[<span class="string">'__annotations__'</span>, <span class="string">'__call__'</span>, <span class="string">'__closure__'</span>, <span class="string">'__code__'</span>, <span class="string">'__defaults__'</span>, <span class="string">'__get__'</span>, <span class="string">'__globals__'</span>, <span class="string">'__kwdefaults__'</span>, <span class="string">'__name__'</span>, <span class="string">'__qualname__'</span>]</span><br></pre></td></tr></table></figure><table><thead><tr class="header"><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>__annotations__</code></td><td>dict</td><td>参数和返回值的注解</td></tr><tr class="even"><td><code>__call__</code></td><td>method-wrapper</td><td>实现()运算符：即可调用对象协议</td></tr><tr class="odd"><td><code>__closure__</code></td><td>tuple</td><td>函数闭包，即自由变量的绑定（通常是None）</td></tr><tr class="even"><td><code>__code__</code></td><td>code</td><td>编译成字节码的函数元数据和函数定义体</td></tr><tr class="odd"><td><code>__defaults__</code></td><td>tuple</td><td>形式参数的默认值</td></tr><tr class="even"><td><code>__get__</code></td><td>method-wrapper</td><td>实现只读描述符协议</td></tr><tr class="odd"><td><code>__globals__</code></td><td>dict</td><td>函数所在模块中的全局变量</td></tr><tr class="even"><td><code>__kwdefaults__</code></td><td>dict</td><td>仅限关键字形式参数的默认值</td></tr><tr class="odd"><td><code>__name__</code></td><td>str</td><td>函数名称</td></tr><tr class="even"><td><code>__qualname__</code></td><td>str</td><td>函数的限定名称，如Random.choice（<a href="https://www.python.org/dev/peps/pep-3155/" target="_blank" rel="noopener">参阅PEP 3155</a>）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> first-class functions </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>支持函数式编程的包</title>
      <link href="/notes/fluent-python/packages-for-functional-programming/"/>
      <url>/notes/fluent-python/packages-for-functional-programming/</url>
      
        <content type="html"><![CDATA[<h1 id="operator模块">operator模块</h1><p>Python的目标不是变成函数式编程语言，但是得益于operator和functools等包的支持，函数式编程风格也可以信手拈来。下面是operator模块中定义的部分函数（省略了以_开头的名称，因为它们基本上是实现细节）：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> operator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[name <span class="keyword">for</span> name <span class="keyword">in</span> dir(operator) <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'_'</span>)]</span><br><span class="line">[<span class="string">'abs'</span>, <span class="string">'add'</span>, <span class="string">'and_'</span>, <span class="string">'attrgetter'</span>, <span class="string">'concat'</span>, <span class="string">'contains'</span>, <span class="string">'countOf'</span>, <span class="string">'delitem'</span>, <span class="string">'eq'</span>, <span class="string">'floordiv'</span>, <span class="string">'ge'</span>, <span class="string">'getitem'</span>, <span class="string">'gt'</span>, <span class="string">'iadd'</span>, <span class="string">'iand'</span>, <span class="string">'iconcat'</span>, <span class="string">'ifloordiv'</span>, <span class="string">'ilshift'</span>, <span class="string">'imatmul'</span>, <span class="string">'imod'</span>, <span class="string">'imul'</span>, <span class="string">'index'</span>, <span class="string">'indexOf'</span>, <span class="string">'inv'</span>, <span class="string">'invert'</span>, <span class="string">'ior'</span>, <span class="string">'ipow'</span>, <span class="string">'irshift'</span>, <span class="string">'is_'</span>, <span class="string">'is_not'</span>, <span class="string">'isub'</span>, <span class="string">'itemgetter'</span>, <span class="string">'itruediv'</span>, <span class="string">'ixor'</span>, <span class="string">'le'</span>, <span class="string">'length_hint'</span>, <span class="string">'lshift'</span>, <span class="string">'lt'</span>, <span class="string">'matmul'</span>, <span class="string">'methodcaller'</span>, <span class="string">'mod'</span>, <span class="string">'mul'</span>, <span class="string">'ne'</span>, <span class="string">'neg'</span>, <span class="string">'not_'</span>, <span class="string">'or_'</span>, <span class="string">'pos'</span>, <span class="string">'pow'</span>, <span class="string">'rshift'</span>, <span class="string">'setitem'</span>, <span class="string">'sub'</span>, <span class="string">'truediv'</span>, <span class="string">'truth'</span>, <span class="string">'xor'</span>]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="算术运算符函数">算术运算符函数</h2><p>在函数式编程中，经常需要把算术运算符当作函数使用。例如，不使用递归进行阶乘</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> a, b: a*b, range(<span class="number">1</span>, n+<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>operator模块为多个算术运算符提供了对应的函数，从而避免编写<code>lambda a, b: a*b</code>这种平凡的匿名函数。使用算术运算符函数，可以把上例改写为</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> mul</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">_fact</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> reduce(mul, range(<span class="number">1</span>, n+<span class="number">1</span>))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>all(fact(i) == _fact(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">100</span>))</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="getter函数">getter函数</h2><p>operator模块中还有一类函数，能替代从序列中取出元素或读取对象属性的lambda表达式：因此，itemgetter和attrgetter其实会自行构建函数（点击链接查看其等价函数）。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/operator#operator.itemgetter" target="_blank" rel="noopener"><code>operator.itemgetter(item) operator.itemgetter(*items)</code></a></p><p>Return a callable object that fetches <em>item</em> from its operand using the operand’s <code>__getitem__()</code> method. If multiple items are specified, returns a tuple of lookup values. For example:</p><ul><li>After <code>f = itemgetter(2)</code>, the call <code>f(r)</code> returns <code>r[2]</code>.</li><li>After <code>g = itemgetter(2, 5, 3)</code>, the call <code>g(r)</code> returns <code>(r[2], r[5], r[3])</code>.</li></ul><hr><p><a href="https://devdocs.io/python~3.6/library/operator#operator.attrgetter" target="_blank" rel="noopener"><code>operator.attrgetter(attr) operator.attrgetter(*attrs)</code></a></p><p>Return a callable object that fetches <em>attr</em> from its operand. If more than one attribute is requested, returns a tuple of attributes. The attribute names can also contain dots. For example:</p><ul><li>After <code>f = attrgetter('name')</code>, the call <code>f(b)</code> returns <code>b.name</code>.</li><li>After <code>f = attrgetter('name', 'date')</code>, the call <code>f(b)</code> returns <code>(b.name, b.date)</code>.</li><li>After <code>f = attrgetter('name.first', 'name.last')</code>, the call <code>f(b)</code> returns <code>(b.name.first, b.name.last)</code>.</li></ul></blockquote><h2 id="methodcall函数">methodcall函数</h2><p>它的作用与attrgetter和itemgetter类似，它会自行创建函数。methodcaller创建的函数会在对象上调用参数指定的方法。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/operator#operator.methodcaller" target="_blank" rel="noopener"><code>operator.methodcaller(name[, args...])</code></a></p><p>Return a callable object that calls the method <em>name</em> on its operand. If additional arguments and/or keyword arguments are given, they will be given to the method as well. For example:</p><ul><li>After <code>f = methodcaller('name')</code>, the call <code>f(b)</code> returns <code>b.name()</code>.</li><li>After <code>f = methodcaller('name', 'foo', bar=1)</code>, the call <code>f(b)</code> returns <code>b.name('foo', bar=1)</code>.</li></ul></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> methodcaller</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'The time has come'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>upcase = methodcaller(<span class="string">'upper'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>upcase(s)  <span class="comment"># 相当于s.upper()</span></span><br><span class="line"><span class="string">'THE TIME HAS COME'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hiphenate = methodcaller(<span class="string">'replace'</span>, <span class="string">' '</span>, <span class="string">'-'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hiphenate(s)  <span class="comment"># 相当于s.replace(' ', '-')</span></span><br><span class="line"><span class="string">'The-time-has-come'</span></span><br></pre></td></tr></table></figure><h1 id="使用functools.partial冻结参数">使用functools.partial冻结参数</h1><blockquote><p><a href="https://devdocs.io/python~3.6/library/functools#functools.partial" target="_blank" rel="noopener"><code>functools.partial(func, *args, **keywords)</code></a></p></blockquote><p>partial这个高阶函数用于部分应用一个函数。部分应用是指，基于一个函数创建一个新的调用对象，把原函数的某些参数固定。使用这个函数可以把接受一个或多个参数的函数改编成需要回调的API，这样参数更少。</p><p>示例：使用partial把一个两参数函数改编成需要单参数的可调用对象。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> mul</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>triple = partial(mul, <span class="number">3</span>)  <span class="comment"># 相当于 lambda e: mul(3, e)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>triple</span><br><span class="line">functools.partial(&lt;built-<span class="keyword">in</span> function mul&gt;, <span class="number">3</span>)  <span class="comment"># 返回一个partial对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>triple(<span class="number">7</span>)  <span class="comment"># triple接受单参数</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(triple, range(<span class="number">1</span>, <span class="number">10</span>)))</span><br><span class="line">[<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">21</span>, <span class="number">24</span>, <span class="number">27</span>]</span><br></pre></td></tr></table></figure><p>functools.partialmethod函数（Python3.4新增）的作用与partial一样，不过是用于处理方法（在类中定义的函数）的。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/functools#functools.partialmethod" target="_blank" rel="noopener"><code>class functools.partialmethod(func, *args, **keywords)</code></a></p></blockquote><p>Example:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Cell</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self._alive = <span class="literal">False</span></span><br><span class="line"><span class="meta">... </span>    @property</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">alive</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> self._alive</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">set_state</span><span class="params">(self, state)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self._alive = bool(state)</span><br><span class="line"><span class="meta">... </span>    set_alive = partialmethod(set_state, <span class="literal">True</span>)</span><br><span class="line"><span class="meta">... </span>    set_dead = partialmethod(set_state, <span class="literal">False</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Cell()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.alive</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.set_alive()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.alive</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> functional programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dict：处理找不到的键</title>
      <link href="/notes/fluent-python/handling-missing-keys-in-a-dict/"/>
      <url>/notes/fluent-python/handling-missing-keys-in-a-dict/</url>
      
        <content type="html"><![CDATA[<h1 id="get">get</h1><blockquote><p><code>get(key[, default])</code></p></blockquote><p>当key存在时，返回其对应的值，否则返回default，defaut的默认值为None，这比处理KeyError要方便不少。相当于<code>return m[key] if key in a else default</code>。</p><p>但是要更新某个键对应的值时，不管使用<code>__getitem__</code>（即类似m[key]的形式）还是get都会不自然，而且效率低。</p><h1 id="setdefault">setdefault</h1><blockquote><p><code>setdefault(key[, default])</code></p></blockquote><p>当key不存在时，会先更新key的值为default，然后返回default。当key存在时，返回key的值。相当于：</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setdefault</span><span class="params">(self, key, default=None)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> self[key]  <span class="comment"># key已存在时</span></span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">        self[key] = default  <span class="comment"># key不存在时</span></span><br><span class="line">        <span class="keyword">return</span> default</span><br></pre></td></tr></table></figure><p>get(key, default)与setdefault(key, default)在key不存在时都能返回default，不同的是setdefault在返回前更新了key的值，这在某些时候（比如值是一个对象，且对其进行修改时）非常有用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name_list = m.get(<span class="string">'names'</span>, [])  <span class="comment"># 第1次查询</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name_list.append(<span class="string">'Alice'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="string">'names'</span>] = name_list  <span class="comment"># 第2次查询</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m</span><br><span class="line">&#123;<span class="string">'names'</span>: [<span class="string">'Alice'</span>]&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.setdefault(<span class="string">'names'</span>, []).append(<span class="string">'John'</span>)  <span class="comment"># 1步到位</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m</span><br><span class="line">&#123;<span class="string">'names'</span>: [<span class="string">'Alice'</span>, <span class="string">'John'</span>]&#125;</span><br></pre></td></tr></table></figure><h1 id="defaultdict">defaultdict</h1><blockquote><p><code>class collections.defaultdict([default_factory[, ...]])</code></p></blockquote><p>在用户创建defaultdict对象的时候，就需要给它配置一个为找不到的键创造默认值的方法。具体而言，在实例化一个defaultdict的时候，需要给构造方法提供一个可调用对象，这个可调用对象会在<code>__getitem__</code>碰到找不到的键的时候被调用，让<code>__getitem__</code>返回某种默认值。</p><p>defaultdict里的<code>default_factory</code>只会在<code>__getitem__</code>里被调用，在其他的方法里完全不会发挥作用。比如，dd是个defaultdict，k是个找不到的键，dd[k]这个表达式会调用<code>default_factory</code>创造某个默认值，而dd.get(k)则会返回None。</p><p>所有这一切背后的功臣其实是特殊方法<code>__missing__</code>。它会在defaultdict遇到找不到的键的时候调用<code>default_factory</code>，而实际上这个特性是所有映射类型都可以选择去支持的。</p><p>使用例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = defaultdict(list)  <span class="comment"># default_factory=list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="string">'names'</span>].append(<span class="string">'Alice'</span>)  <span class="comment"># default_factor会被调用，为查询不到的键创建一个值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">defaultdict(&lt;class 'list'&gt;, &#123;'names': ['Alice']&#125;)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.get(<span class="number">0</span>)  <span class="comment"># default_factor会被调用不会被调用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.get(<span class="string">'names'</span>)</span><br><span class="line">[<span class="string">'Alice'</span>]</span><br></pre></td></tr></table></figure><h1 id="特殊方法">特殊方法</h1><p><strong>所有的映射类型在处理找不到的键的时候，都会牵扯到<code>__missing__</code>方法。</strong>这也是这个方法称作“missing”的原因。虽然基类dict并没有定义这个方法，但是dict是知道有这么个东西存在的。也就是说，如果有一个类继承了dict，然后这个继承类提供了<code>__missing__</code>方法，那么在<code>__getitem__</code>碰到找不到的键的时候，Python 就会自动调用它，而不是抛出一个KeyError异常。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">StrKeyDict</span><span class="params">(dict)</span>:</span>  <span class="comment"># 继承自dict</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> isinstance(key, str):  <span class="comment"># 如果key本身是字符串，就抛出异常</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">raise</span> KeyError(key)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> self[str(key)]  <span class="comment"># 否则，转换成字符串在进行查找</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key, default=None)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> self[key]  <span class="comment"># 将get方法的查找工作委托给__getitem__，这样在宣布</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">except</span> KeyError:      <span class="comment"># 查找失败之前，还能通过__missing__再给某个键一次机会</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> default</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self, key)</span>:</span>  <span class="comment"># 继承的__contains__方法在找不到键时不会调用__missing__</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> key <span class="keyword">in</span> self.keys() <span class="keyword">or</span> str(key) <span class="keyword">in</span> self.keys()  <span class="comment"># 因此这里需要重写此方法</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = StrKeyDict(&#123;i <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> str(i): i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m</span><br><span class="line">&#123;<span class="number">0</span>: <span class="number">0</span>, <span class="string">'1'</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">4</span>, <span class="string">'3'</span>: <span class="number">9</span>, <span class="number">4</span>: <span class="number">16</span>, <span class="string">'5'</span>: <span class="number">25</span>, <span class="number">6</span>: <span class="number">36</span>, <span class="string">'7'</span>: <span class="number">49</span>, <span class="number">8</span>: <span class="number">64</span>, <span class="string">'9'</span>: <span class="number">81</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="number">0</span>]</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.get(<span class="number">0</span>)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="number">1</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.get(<span class="number">1</span>)  <span class="comment"># 与defaultdict不同，能触发__missing__</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> <span class="keyword">in</span> m</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> <span class="keyword">in</span> m</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><ul><li><p><code>__missing__</code>方法中isinstance是必须的，否则当str(key)是一个不存在的键时，会陷入无限递归。</p></li><li><p><code>__contains__</code>方法中没有用key in my_dict来检查键是否存在，因为那也会导致<code>__contains__</code>被递归调用（or关键字后面的第二次查找会调用<code>__contains__</code>）。为了避免这一情况，这里采用了更显式的方法，直接在self.keys()里查询。</p></li><li><p>像<code>k in my_dict.keys()</code>这种操作在Python 3中是很快的，而且即便映射类型对象很庞大也没关系。这是因为dict.keys()的返回值是一个”视图“。视图就像一个集合，而且跟字典类似的是，在视图里查找一个元素的速度很快。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dict </tag>
            
            <tag> Fluent Python </tag>
            
            <tag> defaultdict </tag>
            
            <tag> special methods </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用bisect来管理已排序的序列</title>
      <link href="/notes/fluent-python/managing-ordered-sequences-with-bisect/"/>
      <url>/notes/fluent-python/managing-ordered-sequences-with-bisect/</url>
      
        <content type="html"><![CDATA[<h1 id="bisect">bisect</h1><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><thead><tr class="header"><th>Method</th><th>Doc</th></tr></thead><tbody><tr class="odd"><td><code>bisect.bisect_left(a, x, lo=0, hi=len(a))</code></td><td>Return the leftmost index where to insert item x in list a, assuming a is sorted.</td></tr><tr class="even"><td><code>bisect.bisect_right(a, x, lo=0, hi=len(a))</code></td><td>Return the rightmost index where to insert item x in list a, assuming a is sorted.</td></tr><tr class="odd"><td><code>bisect.bisect(a, x, lo=0, hi=len(a))</code></td><td>Equal to bisect_right.</td></tr><tr class="even"><td><code>bisect.insort_left(a, x, lo=0, hi=len(a))</code></td><td>Insert item x in a and keep it sorted assuming a is sorted. If equal keys are found, add to the left.</td></tr><tr class="odd"><td><code>bisect.insort_right(a, x, lo=0, hi=len(a))</code></td><td>Insert item x in a and keep it sorted assuming a is sorted. If equal keys are found, add to the right.</td></tr><tr class="even"><td><code>bisect.insort(a, x, lo=0, hi=len(a))</code></td><td>Equal to insort_right.</td></tr></tbody></table><a id="more"></a><h1 id="sortedcollection">SortedCollection</h1><p>Python的高产贡献者Raymond Hettinger写了一个排序集合模块<a href="http://code.activestate.com/recipes/577197-sortedcollection/" target="_blank" rel="noopener">SortedCollection</a>，模块里集成了bisect功能，但是比独立的bisect更易用。</p><table><colgroup><col style="width: 33%"><col style="width: 66%"></colgroup><thead><tr class="header"><th>Method</th><th>Doc</th></tr></thead><tbody><tr class="odd"><td><code>def clear(self)</code></td><td></td></tr><tr class="even"><td><code>def copy(self)</code></td><td></td></tr><tr class="odd"><td><code>def index(self, item)</code></td><td>Find the position of an item. Raise ValueError if not found.</td></tr><tr class="even"><td><code>def count(self, item)</code></td><td>Return number of occurrences of item.</td></tr><tr class="odd"><td><code>def insert(self, item)</code></td><td>Insert a new item. If equal keys are found, add to the left.</td></tr><tr class="even"><td><code>def insert_right(self, item)</code></td><td>Insert a new item. If equal keys are found, add to the right.</td></tr><tr class="odd"><td><code>def remove(self, item)</code></td><td>Remove first occurence of item. Raise ValueError if not found.</td></tr><tr class="even"><td><code>def find(self, k)</code></td><td>Return first item with a key == k. Raise ValueError if not found.</td></tr><tr class="odd"><td><code>def find_le(self, k)</code></td><td>Return last item with a key &lt;= k. Raise ValueError if not found.</td></tr><tr class="even"><td><code>def find_lt(self, k)</code></td><td>Return last item with a key &lt; k. Raise ValueError if not found.</td></tr><tr class="odd"><td><code>def find_ge(self, k)</code></td><td>Return first item with a key &gt;= k. Raise ValueError if not found.</td></tr><tr class="even"><td><code>def find_gt(self, k)</code></td><td>Return first item with a key &gt; k. Raise ValueError if not found.</td></tr></tbody></table><h1 id="bisect源码">bisect源码</h1><figure class="highlight python"><figcaption><span>bisect.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="string">"""Bisection algorithms."""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insort_right</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="string">"""Insert item x in list a, and keep it sorted assuming a is sorted.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If x is already in a, insert it to the right of the rightmost x.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Optional args lo (default 0) and hi (default len(a)) bound the</span></span><br><span class="line"><span class="string">    slice of a to be searched.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; a[mid]: hi = mid</span><br><span class="line">        <span class="keyword">else</span>: lo = mid+<span class="number">1</span></span><br><span class="line">    a.insert(lo, x)</span><br><span class="line"></span><br><span class="line">insort = insort_right   <span class="comment"># backward compatibility</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bisect_right</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="string">"""Return the index where to insert item x in list a, assuming a is sorted.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The return value i is such that all e in a[:i] have e &lt;= x, and all e in</span></span><br><span class="line"><span class="string">    a[i:] have e &gt; x.  So if x already appears in the list, a.insert(x) will</span></span><br><span class="line"><span class="string">    insert just after the rightmost x already there.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Optional args lo (default 0) and hi (default len(a)) bound the</span></span><br><span class="line"><span class="string">    slice of a to be searched.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; a[mid]: hi = mid</span><br><span class="line">        <span class="keyword">else</span>: lo = mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> lo</span><br><span class="line"></span><br><span class="line">bisect = bisect_right   <span class="comment"># backward compatibility</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insort_left</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="string">"""Insert item x in list a, and keep it sorted assuming a is sorted.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If x is already in a, insert it to the left of the leftmost x.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Optional args lo (default 0) and hi (default len(a)) bound the</span></span><br><span class="line"><span class="string">    slice of a to be searched.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> a[mid] &lt; x: lo = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: hi = mid</span><br><span class="line">    a.insert(lo, x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bisect_left</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="string">"""Return the index where to insert item x in list a, assuming a is sorted.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The return value i is such that all e in a[:i] have e &lt; x, and all e in</span></span><br><span class="line"><span class="string">    a[i:] have e &gt;= x.  So if x already appears in the list, a.insert(x) will</span></span><br><span class="line"><span class="string">    insert just before the leftmost x already there.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Optional args lo (default 0) and hi (default len(a)) bound the</span></span><br><span class="line"><span class="string">    slice of a to be searched.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> a[mid] &lt; x: lo = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: hi = mid</span><br><span class="line">    <span class="keyword">return</span> lo</span><br><span class="line"></span><br><span class="line"><span class="comment"># Overwrite above definitions with a fast C implementation</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> _bisect <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h1 id="sortedcollection源码">SortedCollection源码</h1><figure class="highlight python"><figcaption><span>recipe-577197-1.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_left, bisect_right</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortedCollection</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''Sequence sorted by a key function.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    SortedCollection() is much easier to work with than using bisect() directly.</span></span><br><span class="line"><span class="string">    It supports key functions like those use in sorted(), min(), and max().</span></span><br><span class="line"><span class="string">    The result of the key function call is saved so that keys can be searched</span></span><br><span class="line"><span class="string">    efficiently.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Instead of returning an insertion-point which can be hard to interpret, the</span></span><br><span class="line"><span class="string">    five find-methods return a specific item in the sequence. They can scan for</span></span><br><span class="line"><span class="string">    exact matches, the last item less-than-or-equal to a key, or the first item</span></span><br><span class="line"><span class="string">    greater-than-or-equal to a key.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Once found, an item's ordinal position can be located with the index() method.</span></span><br><span class="line"><span class="string">    New items can be added with the insert() and insert_right() methods.</span></span><br><span class="line"><span class="string">    Old items can be deleted with the remove() method.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The usual sequence methods are provided to support indexing, slicing,</span></span><br><span class="line"><span class="string">    length lookup, clearing, copying, forward and reverse iteration, contains</span></span><br><span class="line"><span class="string">    checking, item counts, item removal, and a nice looking repr.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Finding and indexing are O(log n) operations while iteration and insertion</span></span><br><span class="line"><span class="string">    are O(n).  The initial sort is O(n log n).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The key function is stored in the 'key' attibute for easy introspection or</span></span><br><span class="line"><span class="string">    so that you can assign a new key function (triggering an automatic re-sort).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    In short, the class was designed to handle all of the common use cases for</span></span><br><span class="line"><span class="string">    bisect but with a simpler API and support for key functions.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; from pprint import pprint</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; from operator import itemgetter</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s = SortedCollection(key=itemgetter(2))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; for record in [</span></span><br><span class="line"><span class="string">    ...         ('roger', 'young', 30),</span></span><br><span class="line"><span class="string">    ...         ('angela', 'jones', 28),</span></span><br><span class="line"><span class="string">    ...         ('bill', 'smith', 22),</span></span><br><span class="line"><span class="string">    ...         ('david', 'thomas', 32)]:</span></span><br><span class="line"><span class="string">    ...     s.insert(record)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; pprint(list(s))         # show records sorted by age</span></span><br><span class="line"><span class="string">    [('bill', 'smith', 22),</span></span><br><span class="line"><span class="string">     ('angela', 'jones', 28),</span></span><br><span class="line"><span class="string">     ('roger', 'young', 30),</span></span><br><span class="line"><span class="string">     ('david', 'thomas', 32)]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s.find_le(29)           # find oldest person aged 29 or younger</span></span><br><span class="line"><span class="string">    ('angela', 'jones', 28)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s.find_lt(28)           # find oldest person under 28</span></span><br><span class="line"><span class="string">    ('bill', 'smith', 22)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s.find_gt(28)           # find youngest person over 28</span></span><br><span class="line"><span class="string">    ('roger', 'young', 30)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; r = s.find_ge(32)       # find youngest person aged 32 or older</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s.index(r)              # get the index of their record</span></span><br><span class="line"><span class="string">    3</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s[3]                    # fetch the record at that index</span></span><br><span class="line"><span class="string">    ('david', 'thomas', 32)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s.key = itemgetter(0)   # now sort by first name</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; pprint(list(s))</span></span><br><span class="line"><span class="string">    [('angela', 'jones', 28),</span></span><br><span class="line"><span class="string">     ('bill', 'smith', 22),</span></span><br><span class="line"><span class="string">     ('david', 'thomas', 32),</span></span><br><span class="line"><span class="string">     ('roger', 'young', 30)]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, iterable=<span class="params">()</span>, key=None)</span>:</span></span><br><span class="line">        self._given_key = key</span><br><span class="line">        key = (<span class="keyword">lambda</span> x: x) <span class="keyword">if</span> key <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> key</span><br><span class="line">        decorated = sorted((key(item), item) <span class="keyword">for</span> item <span class="keyword">in</span> iterable)</span><br><span class="line">        self._keys = [k <span class="keyword">for</span> k, item <span class="keyword">in</span> decorated]</span><br><span class="line">        self._items = [item <span class="keyword">for</span> k, item <span class="keyword">in</span> decorated]</span><br><span class="line">        self._key = key</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_getkey</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._key</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_setkey</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">is</span> <span class="keyword">not</span> self._key:</span><br><span class="line">            self.__init__(self._items, key=key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_delkey</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._setkey(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    key = property(_getkey, _setkey, _delkey, <span class="string">'key function'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__init__([], self._key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copy</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__class__(self, self._key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._items)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._items[i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self._items)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reversed__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> reversed(self._items)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'%s(%r, key=%s)'</span> % (</span><br><span class="line">            self.__class__.__name__,</span><br><span class="line">            self._items,</span><br><span class="line">            getattr(self._given_key, <span class="string">'__name__'</span>, repr(self._given_key))</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reduce__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__class__, (self._items, self._given_key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        k = self._key(item)</span><br><span class="line">        i = bisect_left(self._keys, k)</span><br><span class="line">        j = bisect_right(self._keys, k)</span><br><span class="line">        <span class="keyword">return</span> item <span class="keyword">in</span> self._items[i:j]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'Find the position of an item.  Raise ValueError if not found.'</span></span><br><span class="line">        k = self._key(item)</span><br><span class="line">        i = bisect_left(self._keys, k)</span><br><span class="line">        j = bisect_right(self._keys, k)</span><br><span class="line">        <span class="keyword">return</span> self._items[i:j].index(item) + i</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'Return number of occurrences of item'</span></span><br><span class="line">        k = self._key(item)</span><br><span class="line">        i = bisect_left(self._keys, k)</span><br><span class="line">        j = bisect_right(self._keys, k)</span><br><span class="line">        <span class="keyword">return</span> self._items[i:j].count(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'Insert a new item.  If equal keys are found, add to the left'</span></span><br><span class="line">        k = self._key(item)</span><br><span class="line">        i = bisect_left(self._keys, k)</span><br><span class="line">        self._keys.insert(i, k)</span><br><span class="line">        self._items.insert(i, item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_right</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'Insert a new item.  If equal keys are found, add to the right'</span></span><br><span class="line">        k = self._key(item)</span><br><span class="line">        i = bisect_right(self._keys, k)</span><br><span class="line">        self._keys.insert(i, k)</span><br><span class="line">        self._items.insert(i, item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'Remove first occurence of item.  Raise ValueError if not found'</span></span><br><span class="line">        i = self.index(item)</span><br><span class="line">        <span class="keyword">del</span> self._keys[i]</span><br><span class="line">        <span class="keyword">del</span> self._items[i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        <span class="string">'Return first item with a key == k.  Raise ValueError if not found.'</span></span><br><span class="line">        i = bisect_left(self._keys, k)</span><br><span class="line">        <span class="keyword">if</span> i != len(self) <span class="keyword">and</span> self._keys[i] == k:</span><br><span class="line">            <span class="keyword">return</span> self._items[i]</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'No item found with key equal to: %r'</span> % (k,))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_le</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        <span class="string">'Return last item with a key &lt;= k.  Raise ValueError if not found.'</span></span><br><span class="line">        i = bisect_right(self._keys, k)</span><br><span class="line">        <span class="keyword">if</span> i:</span><br><span class="line">            <span class="keyword">return</span> self._items[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'No item found with key at or below: %r'</span> % (k,))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_lt</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        <span class="string">'Return last item with a key &lt; k.  Raise ValueError if not found.'</span></span><br><span class="line">        i = bisect_left(self._keys, k)</span><br><span class="line">        <span class="keyword">if</span> i:</span><br><span class="line">            <span class="keyword">return</span> self._items[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'No item found with key below: %r'</span> % (k,))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_ge</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        <span class="string">'Return first item with a key &gt;= equal to k.  Raise ValueError if not found'</span></span><br><span class="line">        i = bisect_left(self._keys, k)</span><br><span class="line">        <span class="keyword">if</span> i != len(self):</span><br><span class="line">            <span class="keyword">return</span> self._items[i]</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'No item found with key at or above: %r'</span> % (k,))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_gt</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        <span class="string">'Return first item with a key &gt; k.  Raise ValueError if not found'</span></span><br><span class="line">        i = bisect_right(self._keys, k)</span><br><span class="line">        <span class="keyword">if</span> i != len(self):</span><br><span class="line">            <span class="keyword">return</span> self._items[i]</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'No item found with key above: %r'</span> % (k,))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------  Simple demo and tests  -------------------------</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ve2no</span><span class="params">(f, *args)</span>:</span></span><br><span class="line">        <span class="string">'Convert ValueError result to -1'</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> f(*args)</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">slow_index</span><span class="params">(seq, k)</span>:</span></span><br><span class="line">        <span class="string">'Location of match or -1 if not found'</span></span><br><span class="line">        <span class="keyword">for</span> i, item <span class="keyword">in</span> enumerate(seq):</span><br><span class="line">            <span class="keyword">if</span> item == k:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">slow_find</span><span class="params">(seq, k)</span>:</span></span><br><span class="line">        <span class="string">'First item with a key equal to k. -1 if not found'</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> seq:</span><br><span class="line">            <span class="keyword">if</span> item == k:</span><br><span class="line">                <span class="keyword">return</span> item</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">slow_find_le</span><span class="params">(seq, k)</span>:</span></span><br><span class="line">        <span class="string">'Last item with a key less-than or equal to k.'</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> reversed(seq):</span><br><span class="line">            <span class="keyword">if</span> item &lt;= k:</span><br><span class="line">                <span class="keyword">return</span> item</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">slow_find_lt</span><span class="params">(seq, k)</span>:</span></span><br><span class="line">        <span class="string">'Last item with a key less-than k.'</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> reversed(seq):</span><br><span class="line">            <span class="keyword">if</span> item &lt; k:</span><br><span class="line">                <span class="keyword">return</span> item</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">slow_find_ge</span><span class="params">(seq, k)</span>:</span></span><br><span class="line">        <span class="string">'First item with a key-value greater-than or equal to k.'</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> seq:</span><br><span class="line">            <span class="keyword">if</span> item &gt;= k:</span><br><span class="line">                <span class="keyword">return</span> item</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">slow_find_gt</span><span class="params">(seq, k)</span>:</span></span><br><span class="line">        <span class="string">'First item with a key-value greater-than or equal to k.'</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> seq:</span><br><span class="line">            <span class="keyword">if</span> item &gt; k:</span><br><span class="line">                <span class="keyword">return</span> item</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line">    pool = [<span class="number">1.5</span>, <span class="number">2</span>, <span class="number">2.0</span>, <span class="number">3</span>, <span class="number">3.0</span>, <span class="number">3.5</span>, <span class="number">4</span>, <span class="number">4.0</span>, <span class="number">4.5</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">500</span>):</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">            s = [choice(pool) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">            sc = SortedCollection(s)</span><br><span class="line">            s.sort()</span><br><span class="line">            <span class="keyword">for</span> probe <span class="keyword">in</span> pool:</span><br><span class="line">                <span class="keyword">assert</span> repr(ve2no(sc.index, probe)) == repr(slow_index(s, probe))</span><br><span class="line">                <span class="keyword">assert</span> repr(ve2no(sc.find, probe)) == repr(slow_find(s, probe))</span><br><span class="line">                <span class="keyword">assert</span> repr(ve2no(sc.find_le, probe)) == repr(slow_find_le(s, probe))</span><br><span class="line">                <span class="keyword">assert</span> repr(ve2no(sc.find_lt, probe)) == repr(slow_find_lt(s, probe))</span><br><span class="line">                <span class="keyword">assert</span> repr(ve2no(sc.find_ge, probe)) == repr(slow_find_ge(s, probe))</span><br><span class="line">                <span class="keyword">assert</span> repr(ve2no(sc.find_gt, probe)) == repr(slow_find_gt(s, probe))</span><br><span class="line">            <span class="keyword">for</span> i, item <span class="keyword">in</span> enumerate(s):</span><br><span class="line">                <span class="keyword">assert</span> repr(item) == repr(sc[i])        <span class="comment"># test __getitem__</span></span><br><span class="line">                <span class="keyword">assert</span> item <span class="keyword">in</span> sc                       <span class="comment"># test __contains__ and __iter__</span></span><br><span class="line">                <span class="keyword">assert</span> s.count(item) == sc.count(item)  <span class="comment"># test count()</span></span><br><span class="line">            <span class="keyword">assert</span> len(sc) == n                         <span class="comment"># test __len__</span></span><br><span class="line">            <span class="keyword">assert</span> list(map(repr, reversed(sc))) == list(map(repr, reversed(s)))    <span class="comment"># test __reversed__</span></span><br><span class="line">            <span class="keyword">assert</span> list(sc.copy()) == list(sc)          <span class="comment"># test copy()</span></span><br><span class="line">            sc.clear()                                  <span class="comment"># test clear()</span></span><br><span class="line">            <span class="keyword">assert</span> len(sc) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    sd = SortedCollection(<span class="string">'The quick Brown Fox jumped'</span>.split(), key=str.lower)</span><br><span class="line">    <span class="keyword">assert</span> sd._keys == [<span class="string">'brown'</span>, <span class="string">'fox'</span>, <span class="string">'jumped'</span>, <span class="string">'quick'</span>, <span class="string">'the'</span>]</span><br><span class="line">    <span class="keyword">assert</span> sd._items == [<span class="string">'Brown'</span>, <span class="string">'Fox'</span>, <span class="string">'jumped'</span>, <span class="string">'quick'</span>, <span class="string">'The'</span>]</span><br><span class="line">    <span class="keyword">assert</span> sd._key == str.lower</span><br><span class="line">    <span class="keyword">assert</span> repr(sd) == <span class="string">"SortedCollection(['Brown', 'Fox', 'jumped', 'quick', 'The'], key=lower)"</span></span><br><span class="line">    sd.key = str.upper</span><br><span class="line">    <span class="keyword">assert</span> sd._key == str.upper</span><br><span class="line">    <span class="keyword">assert</span> len(sd) == <span class="number">5</span></span><br><span class="line">    <span class="keyword">assert</span> list(reversed(sd)) == [<span class="string">'The'</span>, <span class="string">'quick'</span>, <span class="string">'jumped'</span>, <span class="string">'Fox'</span>, <span class="string">'Brown'</span>]</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> sd:</span><br><span class="line">        <span class="keyword">assert</span> item <span class="keyword">in</span> sd</span><br><span class="line">    <span class="keyword">for</span> i, item <span class="keyword">in</span> enumerate(sd):</span><br><span class="line">        <span class="keyword">assert</span> item == sd[i]</span><br><span class="line">    sd.insert(<span class="string">'jUmPeD'</span>)</span><br><span class="line">    sd.insert_right(<span class="string">'QuIcK'</span>)</span><br><span class="line">    <span class="keyword">assert</span> sd._keys ==[<span class="string">'BROWN'</span>, <span class="string">'FOX'</span>, <span class="string">'JUMPED'</span>, <span class="string">'JUMPED'</span>, <span class="string">'QUICK'</span>, <span class="string">'QUICK'</span>, <span class="string">'THE'</span>]</span><br><span class="line">    <span class="keyword">assert</span> sd._items == [<span class="string">'Brown'</span>, <span class="string">'Fox'</span>, <span class="string">'jUmPeD'</span>, <span class="string">'jumped'</span>, <span class="string">'quick'</span>, <span class="string">'QuIcK'</span>, <span class="string">'The'</span>]</span><br><span class="line">    <span class="keyword">assert</span> sd.find_le(<span class="string">'JUMPED'</span>) == <span class="string">'jumped'</span>, sd.find_le(<span class="string">'JUMPED'</span>)</span><br><span class="line">    <span class="keyword">assert</span> sd.find_ge(<span class="string">'JUMPED'</span>) == <span class="string">'jUmPeD'</span></span><br><span class="line">    <span class="keyword">assert</span> sd.find_le(<span class="string">'GOAT'</span>) == <span class="string">'Fox'</span></span><br><span class="line">    <span class="keyword">assert</span> sd.find_ge(<span class="string">'GOAT'</span>) == <span class="string">'jUmPeD'</span></span><br><span class="line">    <span class="keyword">assert</span> sd.find(<span class="string">'FOX'</span>) == <span class="string">'Fox'</span></span><br><span class="line">    <span class="keyword">assert</span> sd[<span class="number">3</span>] == <span class="string">'jumped'</span></span><br><span class="line">    <span class="keyword">assert</span> sd[<span class="number">3</span>:<span class="number">5</span>] ==[<span class="string">'jumped'</span>, <span class="string">'quick'</span>]</span><br><span class="line">    <span class="keyword">assert</span> sd[<span class="number">-2</span>] == <span class="string">'QuIcK'</span></span><br><span class="line">    <span class="keyword">assert</span> sd[<span class="number">-4</span>:<span class="number">-2</span>] == [<span class="string">'jumped'</span>, <span class="string">'quick'</span>]</span><br><span class="line">    <span class="keyword">for</span> i, item <span class="keyword">in</span> enumerate(sd):</span><br><span class="line">        <span class="keyword">assert</span> sd.index(item) == i</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sd.index(<span class="string">'xyzpdq'</span>)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="number">0</span>, <span class="string">'Oops, failed to notify of missing value'</span></span><br><span class="line">    sd.remove(<span class="string">'jumped'</span>)</span><br><span class="line">    <span class="keyword">assert</span> list(sd) == [<span class="string">'Brown'</span>, <span class="string">'Fox'</span>, <span class="string">'jUmPeD'</span>, <span class="string">'quick'</span>, <span class="string">'QuIcK'</span>, <span class="string">'The'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> doctest</span><br><span class="line">    <span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line">    print(doctest.testmod())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> bisect </tag>
            
            <tag> binary serch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>list.sort方法和内置函数sorted</title>
      <link href="/notes/fluent-python/list-sort-and-the-sorted-built-in-function/"/>
      <url>/notes/fluent-python/list-sort-and-the-sorted-built-in-function/</url>
      
        <content type="html"><![CDATA[<h1 id="python的一个惯例">Python的一个惯例</h1><p>如果一个函数或者方法对对象进行的是就地改动，那它就应该返回None，好让调用者知道传入的参数发生了变动，而且并未产生新的对象。例如，list.sort和random.shuffle函数。</p><h1 id="list.sort和sorted">list.sort和sorted</h1><blockquote><p><code>sort(*, key=None, reverse=False)</code></p></blockquote><blockquote><p><code>sorted(iterable, *, key=None, reverse=False)</code></p></blockquote><p>这两个函数都有两个可选的关键字参数。</p><ul><li><p>reverse：如果被设定为True，被排序的序列里的元素会以降序输出。默认值是False。</p></li><li><p>key：指定一个函数，这个函数会被用在序列里的每一个元素上，所产生的结果将是排序算法依赖的对比关键字。默认值是None，直接比较元素。</p></li></ul><p>sorted函数会新建一个列表作为返回值。这个方法可以接受任何形式的可迭代对象作为参数，甚至包括不可变序列或生成器。而不管接受的是怎样的参数，它最后都会返回一个列表。</p><a id="more"></a><h1 id="例">例</h1><p>参数使用例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits = [<span class="string">'grape'</span>, <span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'Grape'</span>, <span class="string">'Apple'</span>, <span class="string">'Banana'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits.sort()  <span class="comment"># 默认</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits  <span class="comment"># 参数本身改变了</span></span><br><span class="line">[<span class="string">'Apple'</span>, <span class="string">'Banana'</span>, <span class="string">'Grape'</span>, <span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'grape'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits.sort(reverse=<span class="literal">True</span>)  <span class="comment"># 降序</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits</span><br><span class="line">[<span class="string">'grape'</span>, <span class="string">'banana'</span>, <span class="string">'apple'</span>, <span class="string">'Grape'</span>, <span class="string">'Banana'</span>, <span class="string">'Apple'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits.sort(key=len)  <span class="comment"># 按照字符串长度排序</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits</span><br><span class="line">[<span class="string">'grape'</span>, <span class="string">'apple'</span>, <span class="string">'Grape'</span>, <span class="string">'Apple'</span>, <span class="string">'banana'</span>, <span class="string">'Banana'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits.sort(key=str.lower)  <span class="comment"># 按照小写字母的大小排序</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits</span><br><span class="line">[<span class="string">'apple'</span>, <span class="string">'Apple'</span>, <span class="string">'banana'</span>, <span class="string">'Banana'</span>, <span class="string">'grape'</span>, <span class="string">'Grape'</span>]</span><br></pre></td></tr></table></figure><p>sorted函数使用例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits = [<span class="string">'grape'</span>, <span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'Grape'</span>, <span class="string">'Apple'</span>, <span class="string">'Banana'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = sorted(fruits)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits  <span class="comment"># 参数不变</span></span><br><span class="line">[<span class="string">'grape'</span>, <span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'Grape'</span>, <span class="string">'Apple'</span>, <span class="string">'Banana'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r  <span class="comment"># 返回一个新列表</span></span><br><span class="line">[<span class="string">'Apple'</span>, <span class="string">'Banana'</span>, <span class="string">'Grape'</span>, <span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'grape'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = sorted(fruits)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r1 = sorted(tuple(fruits))  <span class="comment"># 参数是不可变序列（元组）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r2 = sorted(set(fruits))  <span class="comment"># 参数是集合</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r == r1 == r2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = [(<span class="string">'amily'</span>, <span class="number">12</span>), (<span class="string">'william'</span>, <span class="number">17</span>), (<span class="string">'joseph'</span>, <span class="number">16</span>), (<span class="string">'olivia'</span>, <span class="number">13</span>), (<span class="string">'amily'</span>, <span class="number">11</span>), (<span class="string">'olivia'</span>, <span class="number">17</span>)]  <span class="comment"># (name, age)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = sorted(m)  <span class="comment"># 默认参数：按name升序排列，name完全一样，按age升序排列</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r</span><br><span class="line">[(<span class="string">'amily'</span>, <span class="number">11</span>), (<span class="string">'amily'</span>, <span class="number">12</span>), (<span class="string">'joseph'</span>, <span class="number">16</span>), (<span class="string">'olivia'</span>, <span class="number">13</span>), (<span class="string">'olivia'</span>, <span class="number">17</span>), (<span class="string">'william'</span>, <span class="number">17</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = sorted(m, key=<span class="keyword">lambda</span> i: i[<span class="number">1</span>])  <span class="comment"># 按年龄</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r</span><br><span class="line">[(<span class="string">'amily'</span>, <span class="number">11</span>), (<span class="string">'amily'</span>, <span class="number">12</span>), (<span class="string">'olivia'</span>, <span class="number">13</span>), (<span class="string">'joseph'</span>, <span class="number">16</span>), (<span class="string">'william'</span>, <span class="number">17</span>), (<span class="string">'olivia'</span>, <span class="number">17</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = sorted(m, key=<span class="keyword">lambda</span> i: (i[<span class="number">1</span>], i[<span class="number">0</span>]))  <span class="comment"># 先按年龄排序，年龄相同时按名字排序</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r</span><br><span class="line">[(<span class="string">'amily'</span>, <span class="number">11</span>), (<span class="string">'amily'</span>, <span class="number">12</span>), (<span class="string">'olivia'</span>, <span class="number">13</span>), (<span class="string">'joseph'</span>, <span class="number">16</span>), (<span class="string">'olivia'</span>, <span class="number">17</span>), (<span class="string">'william'</span>, <span class="number">17</span>)]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> sorted </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>切片</title>
      <link href="/notes/fluent-python/slicing/"/>
      <url>/notes/fluent-python/slicing/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么切片和区间会忽略最后一个元素">为什么切片和区间会忽略最后一个元素</h1><p>在切片和区间操作里不包含区间范围的最后一个元素是Python的风格，这个习惯符合Python、C和其他语言里以0作为起始下标的传统。这样做带来的好处如下。</p><ul><li>当只有最后一个位置信息时，可以快速看出切片和区间里有几个元素：range(3)和my_list[:3]都返回3个元素。</li><li>当起止位置信息都可见时，可以快速计算出切片和区间的长度，用后一个数减去第一个下标(stop - start)即可。</li><li>可以利用任意一个下标来把序列分割成不重叠的两部分，只要写成my_list[:x]和my_list[x:]就可以了。</li></ul><h1 id="切片示例">切片示例</h1><p>在Python里，像列表（list）、元组（tuple）和字符串（str）这类序列类型都支持切片操作。</p><p>常用用法：<code>my_list[start:stop]</code></p><p>理解：取出下标从start到stop - 1之间的所有元素，组成新列表。</p><p>相当于：<code>[my_list[i] for i in range(start, stop)]</code></p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>li = list(range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[<span class="number">0</span>:len(li)]  <span class="comment"># 拷贝整个列表</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[:]  <span class="comment"># 常用写法，更简单易读</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[<span class="number">1</span>:]  <span class="comment"># 从第1个元素切到最后一个元素</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[:<span class="number">5</span>]  <span class="comment"># 从第0个元素切到第4个元素</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[<span class="number">1</span>:<span class="number">5</span>] <span class="comment"># 从第0个元素切到第4个元素</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>更高级的：<code>my_list[start:stop:step]</code></p><p>理解：将my_list[start:stop]按序分组，每组step个元素，取出每组的第1个元素组成新列表。</p><p>相当于：<code>[my_list[i] for i in range(start, stop, step)]</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[::<span class="number">1</span>]  <span class="comment"># 等价于 li[:]</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[::<span class="number">3</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[::<span class="number">-1</span>] <span class="comment"># step可以为负值，负值意味着反向取值</span></span><br><span class="line">[<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[<span class="number">5</span>:<span class="number">1</span>:<span class="number">-2</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><h1 id="切片对象">切片对象</h1><blockquote><p><code>class slice(stop)</code></p></blockquote><blockquote><p><code>class slice(start, stop[, step])</code></p></blockquote><p><code>a:b:c</code>这种用法只能作为索引或者下标用在[]中来返回一个切片对象：slice(a, b, c)。在对seq[start:stop:step]进行求值的时候，Python会调用<code>seq.__getitem__(slice(start, stop, step))</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>first_five = slice(<span class="number">5</span>)  <span class="comment"># 1个参数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[first_five]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>last_five = slice(len(li) - <span class="number">5</span>, len(li))  <span class="comment"># 2个参数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[last_five]</span><br><span class="line">[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>odd = slice(<span class="number">1</span>, len(li), <span class="number">2</span>)  <span class="comment"># 全部3个参数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[odd]</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><h1 id="给切片赋值">给切片赋值</h1><p>如果把切片放在赋值语句的左边，或把它作为del操作的对象，我们就可以对序列进行嫁接、切除或就地修改操作。</p><p>如果赋值的对象是一个切片，那么赋值语句的右侧必须是个可迭代对象。即便只有单独一个值，也要把它转换成可迭代的序列。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[<span class="number">2</span>:<span class="number">3</span>] = <span class="number">-2</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: can only assign an iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[<span class="number">2</span>:<span class="number">3</span>] = [<span class="number">-2</span>]  <span class="comment"># 必须可迭代</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[<span class="number">0</span>:<span class="number">6</span>] = [<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>, <span class="number">-4</span>, <span class="number">-5</span>]  <span class="comment"># 切除前6个元素，嫁接5个新元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li</span><br><span class="line">[<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>, <span class="number">-4</span>, <span class="number">-5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li = list(range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[<span class="number">2</span>::<span class="number">2</span>] = [<span class="number">-2</span>, <span class="number">-4</span>, <span class="number">-6</span>, <span class="number">-8</span>]  <span class="comment"># 偶数改为负值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">3</span>, <span class="number">-4</span>, <span class="number">5</span>, <span class="number">-6</span>, <span class="number">7</span>, <span class="number">-8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> li[<span class="number">1</span>::<span class="number">2</span>]  <span class="comment"># 删除奇数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li</span><br><span class="line">[<span class="number">0</span>, <span class="number">-2</span>, <span class="number">-4</span>, <span class="number">-6</span>, <span class="number">-8</span>]</span><br></pre></td></tr></table></figure><h1 id="多维切片和省略">多维切片和省略</h1><p>[]运算符里还可以使用逗号分开的多个索引或者是切片，外部库NumPy里就用到了这个特性，二维的numpy.ndarray就可以用a[i, j]这种形式来获取，抑或是a[m:n, k:l]的方式来得到二维切片。要正确处理这种[]运算符的话，对象的特殊方法<code>__getitem__</code>和<code>__setitem__</code>需要以元组的形式来接收a[i, j]中的索引。也就是说，如果要得到a[i, j]的值，Python会调用<code>a.__getitem__((i, j))</code>。</p><p>Python内置的序列类型都是一维的，因此它们只支持单一的索引，成对出现的索引是没有用的。</p><p>省略（ellipsis）的正确书写方法是三个英文句号（<code>...</code>）。省略在Python解释器眼里是一个符号，而实际上它是Ellipsis对象的别名，而Ellipsis对象又是ellipsis类的单一实例（是的，你没看错，ellipsis是类名，全小写，而它的内置实例写作Ellipsis。这其实跟bool是小写，但是它的两个实例写作True和False异曲同工）。它可以当作切片规范的一部分，也可以用在函数的参数清单中，比如<code>f(a, ..., z)</code>，或<code>a[i:...]</code>。在NumPy中，<code>...</code>用作多维数组切片的快捷方式。如果x是四维数组，那么<code>x[i,...]</code>就是<code>x[i, :, :, :]</code>的缩写。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">12</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(a)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">numpy</span>.<span class="title">ndarray</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">a</span>.<span class="title">shape</span>  # 查看维度</span></span><br><span class="line"><span class="class"><span class="params">(<span class="number">12</span>,)</span>  # 一维的含有12个元素的数组</span></span><br><span class="line">&gt;&gt;&gt; a.shape = 3, 4  # 将其转换为一个二维的数组</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.shape</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)  <span class="comment"># 二维，各维度分别含有3、4个元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>, <span class="number">1</span>]  <span class="comment"># 等价于a[0][1]</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>:, <span class="number">2</span>:]</span><br><span class="line">array([[ <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.shape = <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>  <span class="comment"># 转换为三维数组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>],</span><br><span class="line">        [ <span class="number">2</span>,  <span class="number">3</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">        [ <span class="number">6</span>,  <span class="number">7</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">11</span>]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>:, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">array([<span class="number">5</span>, <span class="number">9</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>, <span class="built_in">Ellipsis</span>]  <span class="comment"># 完整的取出第1个维度的1号元素</span></span><br><span class="line">array([[<span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">6</span>, <span class="number">7</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>...</span><br><span class="line"><span class="built_in">Ellipsis</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>, ...]  <span class="comment"># 完整的取出第1个维度的1号元素</span></span><br><span class="line">array([[<span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">6</span>, <span class="number">7</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>, :, :]</span><br><span class="line">array([[<span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">6</span>, <span class="number">7</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[..., <span class="number">1</span>]  <span class="comment"># 取出最后1个维度的1号元素</span></span><br><span class="line">array([[ <span class="number">1</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">5</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">9</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[..., <span class="number">1</span>, ...]  <span class="comment"># 不能包含多个ellipsis</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">IndexError: an index can only have a single ellipsis (<span class="string">'...'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> slicing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python map filter 函数</title>
      <link href="/programming/python-map-filter-methods/"/>
      <url>/programming/python-map-filter-methods/</url>
      
        <content type="html"><![CDATA[<h1 id="map">map</h1><blockquote><p><a href="https://devdocs.io/python~3.6/library/functions#map" target="_blank" rel="noopener"><code>map(function, iterable, ...)</code></a></p></blockquote><p>将 iterable 中的元素依次传入 function，返回 function 的返回值。相当于</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span><span class="params">(function, *iterable)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> zip(*iterable):</span><br><span class="line">        <span class="keyword">yield</span> function(*e)</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 类型转换</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(int, <span class="string">'0123456789'</span>))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对应位置两数相加。当列表长度不一致时，按照最小的那个长度算。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(<span class="keyword">lambda</span> x, y: x + y, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># map 的良好替代：列表推导</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[int(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">'0123456789'</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x + y <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(range(<span class="number">1</span>, <span class="number">6</span>), range(<span class="number">1</span>, <span class="number">5</span>))]</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure><h1 id="filter">filter</h1><blockquote><p><a href="https://devdocs.io/python~3.6/library/functions#filter" target="_blank" rel="noopener"><code>filter(function, iterable)</code></a></p></blockquote><p>将 iterable 中的元素依次传入 function，返回 function 的返回值为真时的元素。</p><p>当 <code>function != None</code> 时，相当于 <code>(item for item in iterable if function(item))</code>；</p><p>当 <code>function == None</code> 时，相当于 <code>(item for item in iterable if item)</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 返回10以下的偶数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, range(<span class="number">11</span>)))</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表推导也是filter的良好替代</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><h1 id="组合使用">组合使用</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 选出小于10的偶数，并转成字符串类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(str, filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span> ==<span class="number">0</span>, range(<span class="number">10</span>))))</span><br><span class="line">[<span class="string">'0'</span>, <span class="string">'2'</span>, <span class="string">'4'</span>, <span class="string">'6'</span>, <span class="string">'8'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[str(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">[<span class="string">'0'</span>, <span class="string">'2'</span>, <span class="string">'4'</span>, <span class="string">'6'</span>, <span class="string">'8'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反过来，将代表数值小于10的字符串转成int，再选出其中的偶数。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, map(int, <span class="string">'0123456789'</span>)))</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[int(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">'0123456789'</span> <span class="keyword">if</span> int(i) % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用特殊方法</title>
      <link href="/notes/fluent-python/how-special-methods-are-used/"/>
      <url>/notes/fluent-python/how-special-methods-are-used/</url>
      
        <content type="html"><![CDATA[<p>不管在哪种框架下写程序，都会花费大量时间去实现那些会被框架本身调用的方法，Python也不例外。Python解释器碰到特殊的句法时，会使用特殊方法去激活一些基本的对象操作，这些特殊方法的名字以两个下划线开头，以两个下划线结尾(例如<code>__getitem__</code>)。比如obj[key]的背后就是<code>__getitem__</code>方法，为了能求得my_collection[key]的值，解释器实际上会调用<code>my_collection.__getitem__(key)</code>。</p><p>这些特殊方法名能让你自己的对象实现和支持以下的语言架构，并与之交互：</p><ul><li>迭代</li><li>集合类</li><li>属性访问</li><li>运算符重载</li><li>函数和方法的调用</li><li>对象的创建和销毁</li><li>字符串表示形式和格式化</li><li>管理上下文（即with块）</li></ul><a id="more"></a><h1 id="一摞python风格的纸牌">一摞Python风格的纸牌</h1><figure class="highlight python"><figcaption><span>french_deck.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">Card = collections.namedtuple(<span class="string">'Card'</span>, [<span class="string">'rank'</span>, <span class="string">'suit'</span>])</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrenchDeck</span>:</span></span><br><span class="line">    ranks = [str(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">11</span>)] + list(<span class="string">'JQKA'</span>)</span><br><span class="line">    suits = <span class="string">'spades diamonds clubs hearts'</span>.split()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'__init__'</span>)</span><br><span class="line">        self._cards = [Card(rank, suit) <span class="keyword">for</span> suit <span class="keyword">in</span> self.suits</span><br><span class="line">                       <span class="keyword">for</span> rank <span class="keyword">in</span> self.ranks]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'__len__'</span>)</span><br><span class="line">        <span class="keyword">return</span> len(self._cards)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        print(<span class="string">'__getitem__'</span>)</span><br><span class="line">        <span class="keyword">return</span> self._cards[item]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        print(<span class="string">'__setitem__'</span>)</span><br><span class="line">        self._cards[key] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'__iter__'</span>)</span><br><span class="line"></span><br><span class="line">suit_values = dict(spades=<span class="number">3</span>, hearts=<span class="number">2</span>, diamonds=<span class="number">1</span>, clubs=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spades_high</span><span class="params">(card)</span>:</span></span><br><span class="line">    <span class="comment"># 按照常规，用点数来判定扑克牌的大小，2 最小、A 最大；</span></span><br><span class="line">    <span class="comment"># 同时还要加上对花色的判定，黑桃最大、红桃次之、方块再次、梅花最小。</span></span><br><span class="line">    rank_value = FrenchDeck.ranks.index(card.rank)</span><br><span class="line">    <span class="keyword">return</span> rank_value * len(suit_values) + suit_values[card.suit]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> french_deck <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> random <span class="keyword">import</span> choice, randrange</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck = FrenchDeck()  <span class="comment"># 初始化</span></span><br><span class="line">__init__</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(deck)  <span class="comment"># len</span></span><br><span class="line">__len__</span><br><span class="line"><span class="number">52</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[<span class="number">0</span>]  <span class="comment"># 下标访问</span></span><br><span class="line">__getitem__</span><br><span class="line">Card(rank=<span class="string">'2'</span>, suit=<span class="string">'spades'</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>choice(deck)  <span class="comment"># 随机抽取</span></span><br><span class="line">__len__</span><br><span class="line">__getitem__</span><br><span class="line">Card(rank=<span class="string">'K'</span>, suit=<span class="string">'diamonds'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[randrange(<span class="number">0</span>, len(deck))]  <span class="comment"># 随机抽取等价替代</span></span><br><span class="line">__len__</span><br><span class="line">__getitem__</span><br><span class="line">Card(rank=<span class="string">'8'</span>, suit=<span class="string">'clubs'</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> card <span class="keyword">in</span> deck:  <span class="comment"># 迭代，无需调用__len__方法</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line">__getitem__</span><br><span class="line"><span class="comment"># 中间全都是__getitem__ #</span></span><br><span class="line">__getitem__</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[<span class="number">-2</span>:]  <span class="comment"># 切片，注意只调用一次__getitem__方法</span></span><br><span class="line">__getitem__</span><br><span class="line">[Card(rank=<span class="string">'K'</span>, suit=<span class="string">'hearts'</span>), Card(rank=<span class="string">'A'</span>, suit=<span class="string">'hearts'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[<span class="number">12</span>::<span class="number">13</span>]  <span class="comment"># 从第12张牌开始，每隔13张取一张牌</span></span><br><span class="line">__getitem__</span><br><span class="line">[Card(rank=<span class="string">'A'</span>, suit=<span class="string">'spades'</span>), Card(rank=<span class="string">'A'</span>, suit=<span class="string">'diamonds'</span>), Card(rank=<span class="string">'A'</span>, suit=<span class="string">'clubs'</span>), Card(rank=<span class="string">'A'</span>, suit=<span class="string">'hearts'</span>)]</span><br></pre></td></tr></table></figure><p>迭代通常是隐式的，譬如说一个集合类型没有实现<code>__contains__</code>方法，那么in运算符就会按顺序做一次迭代搜索。于是，in运算符可以用在我们的FrenchDeck类上，因为它是可迭代的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[<span class="number">2</span>]</span><br><span class="line">__getitem__</span><br><span class="line">Card(rank=<span class="string">'4'</span>, suit=<span class="string">'spades'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Card(<span class="string">'4'</span>, <span class="string">'spades'</span>) <span class="keyword">in</span> deck  <span class="comment"># in，没有实现__contains__方式时，按顺序查找</span></span><br><span class="line">__getitem__</span><br><span class="line">__getitem__</span><br><span class="line">__getitem__</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> card <span class="keyword">in</span> sorted(deck, key=spades_high):  <span class="comment"># sorted</span></span><br><span class="line"><span class="meta">... </span>    print(card)</span><br><span class="line">...</span><br><span class="line">__len__</span><br><span class="line">__getitem__</span><br><span class="line"><span class="comment"># 省略 #</span></span><br><span class="line">__getitem__</span><br><span class="line">Card(rank=<span class="string">'2'</span>, suit=<span class="string">'clubs'</span>)</span><br><span class="line">Card(rank=<span class="string">'2'</span>, suit=<span class="string">'diamonds'</span>)</span><br><span class="line"><span class="comment"># 省略 #</span></span><br><span class="line">Card(rank=<span class="string">'A'</span>, suit=<span class="string">'hearts'</span>)</span><br><span class="line">Card(rank=<span class="string">'A'</span>, suit=<span class="string">'spades'</span>)</span><br></pre></td></tr></table></figure><p>虽然FrenchDeck隐式地继承了object类，但功能却不是继承而来的。我们通过数据模型和一些合成来实现这些功能。通过实现<code>__len__</code>和<code>__getitem__</code>这两个特殊方法，FrenchDeck就跟一个Python自有的序列数据类型一样，可以体现出Python的核心语言特性（例如迭代和切片）。同时这个类还可以用于标准库中诸如random.choice、reversed和sorted这些函数。另外，对合成的运用使得<code>__len__</code>和<code>__getitem__</code>的具体实现可以代理给self._cards这个Python列表（即list对象）。</p><table><thead><tr class="header"><th>操作</th><th>底层支持</th></tr></thead><tbody><tr class="odd"><td>初始化</td><td><code>__init__</code></td></tr><tr class="even"><td>获取长度</td><td><code>__len__</code></td></tr><tr class="odd"><td>下标访问</td><td><code>__getitem__</code></td></tr><tr class="even"><td>随机抽取</td><td><code>__len__</code>, <code>__getitem__</code></td></tr><tr class="odd"><td>查询</td><td><code>__getitem__</code>（没有实现<code>__contains__</code>方法时，in运算符会做一次顺序搜索）</td></tr><tr class="even"><td>迭代</td><td><code>__getitem__</code>（调用次数与迭代次数有关，神奇的是不需要调用<code>__len__</code>）</td></tr><tr class="odd"><td>切片</td><td><code>__getitem__</code>（只调用一次，同样不需要调用<code>__len__</code>）</td></tr><tr class="even"><td>排序</td><td><code>__len__</code>（一次）, <code>__getitem__</code>（调用次数与迭代次数有关）</td></tr></tbody></table><h1 id="如何使用特殊方法">如何使用特殊方法</h1><p>首先明确一点，特殊方法的存在是为了被Python解释器调用的，你自己并不需要调用它们。也就是说没有<code>my_object.__len__()</code>这种写法，而应该使用len(my_object)。在执行len(my_object)的时候，如果my_object是一个自定义类的对象，那么Python会自己去调用其中由你实现的<code>__len__</code>方法。</p><p>然而如果是Python内置的类型，比如列表(list)、字符串(str)、字节序列(bytearray)等，那么CPython会抄个近路，<code>__len__</code>实际上会直接返回PyVarObject里的ob_size属性。PyVarObject是表示内存中长度可变的内置对象的C语言结构体。直接读取这个值比调用一个方法要快很多。</p><p>很多时候，特殊方法的调用是隐式的，比如for i in x这个语句，背后其实用的是iter(x)，而这个函数的背后则是<code>x.__iter__()</code>方法。当然<strong>前提</strong>是这个方法在x中被实现了。</p><p>通常你的代码无需直接使用特殊方法。除非有大量的元编程存在，直接调用特殊方法的频率应该远远低于你去实现它们的次数。唯一的例外可能是<code>__init__</code>方法，你的代码里可能经常会用到它，目的是在你自己的子类的<code>__init__</code>方法中调用超类的构造器。</p><p>通过内置的函数（例如len、iter、str，等等）来使用特殊方法是最好的选择。这些内置函数不仅会调用特殊方法，通常还提供额外的好处，而且对于内置的类来说，它们的速度更快。</p><p>不要自己想当然地随意添加特殊方法，比如<code>__foo__</code>之类的，因为虽然现在这个名字没有被Python内部使用，以后就不一定了。</p><h2 id="模拟数值类型">模拟数值类型</h2><p><img src="/uploads/image/fluent-python/example-of-2d-vector-addition.png" title="一个二维向量加法的例子"></p><p>一个二维向量加法的例子，Vector(2, 4) + Vector(2, 1) = Vector(4, 5)</p><p>向量加法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v2 = Vector(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + v2</span><br><span class="line">Vector(<span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>向量的模：abs是一个内置函数，如果输入是整数或者浮点数，它返回的是输入值的绝对值；如果输入是复数(complex number)，那么返回这个复数的模。为了保持一致性，我们的API在碰到abs函数的时候，也应该返回该向量的模。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v = Vector(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>abs(v)</span><br><span class="line"><span class="number">5.0</span></span><br></pre></td></tr></table></figure><p>标量乘法（即向量与数的乘法，得到的结果向量的方向与原向量一致，模变大）：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v * <span class="number">3</span></span><br><span class="line">Vector(<span class="number">9</span>, <span class="number">12</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>abs(v * <span class="number">3</span>)</span><br><span class="line"><span class="number">15.0</span></span><br></pre></td></tr></table></figure><h2 id="实现">实现</h2><figure class="highlight python"><figcaption><span>vector.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> hypot</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x=<span class="number">0</span>, y=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Vector(%r, %r)'</span> % (self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> hypot(self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(self.x <span class="keyword">or</span> self.y)  <span class="comment"># 更高效</span></span><br><span class="line">        <span class="comment"># return bool(abs(self))</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        x = self.x + other.x</span><br><span class="line">        y = self.y + other.y</span><br><span class="line">        <span class="keyword">return</span> Vector(x, y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, scalar)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Vector(self.x * scalar, self.y * scalar)</span><br></pre></td></tr></table></figure><h2 id="自定义的布尔值">自定义的布尔值</h2><p>尽管Python里有bool类型，但实际上任何对象都可以用于需要布尔值的上下文中（比如if或while语句，或者and、or和not运算符）。为了判定一个值x为真还是为假，Python会调用bool(x)，这个函数只能返回True或者False。</p><p>默认情况下，我们自己定义的类的实例总被认为是真的，除非这个类对<code>__bool__</code>或者<code>__len__</code>函数有自己的实现。bool(x)的背后是调用<code>x.__bool__()</code>的结果；如果不存在<code>__bool__</code>方法，那么bool(x)会尝试调用<code>x.__len__()</code>。若返回0，则bool会返回False；否则返回True。</p><table><thead><tr class="header"><th>操作</th><th>底层支持</th></tr></thead><tbody><tr class="odd"><td>取绝对值或取模</td><td><code>__abs__</code></td></tr><tr class="even"><td>布尔运算</td><td><code>__bool__</code>（优先调用），<code>__len__</code>（不存在<code>__bool__</code>时调用）</td></tr><tr class="odd"><td>加法</td><td><code>__add__</code></td></tr><tr class="even"><td>乘法</td><td><code>__mul__</code></td></tr></tbody></table><h1 id="特殊方法一览">特殊方法一览</h1><p>Python语言参考手册中的<a href="https://docs.python.org/3/reference/datamodel.html" target="_blank" rel="noopener">“Data Model”</a>一章列出了83个特殊方法的名字，其中47个用于实现算术运算、位运算和比较操作。</p><h2 id="跟运算无关的特殊方法">跟运算无关的特殊方法</h2><table><thead><tr class="header"><th>类别</th><th>方法名</th></tr></thead><tbody><tr class="odd"><td>字符串 / 字节序列表示形式</td><td><code>__repr__</code>、<code>__str__</code>、<code>__format__</code>、<code>__bytes__</code></td></tr><tr class="even"><td>数值转换</td><td><code>__abs__</code>、<code>__bool__</code>、<code>__complex__</code>、<code>__int__</code>、<code>__float__</code>、<code>__hash__</code>、<code>__index__</code></td></tr><tr class="odd"><td>集合模拟</td><td><code>__len__</code>、<code>__getitem__</code>、<code>__setitem__</code>、<code>__delitem__</code>、<code>__contains__</code></td></tr><tr class="even"><td>迭代枚举</td><td><code>__iter__</code>、<code>__reversed__</code>、<code>__next__</code></td></tr><tr class="odd"><td>可调用模拟</td><td><code>__call__</code></td></tr><tr class="even"><td>上下文管理</td><td><code>__enter__</code>、<code>__exit__</code></td></tr><tr class="odd"><td>实例创建和销毁</td><td><code>__new__</code>、<code>__init__</code>、<code>__del__</code></td></tr><tr class="even"><td>属性管理</td><td><code>__getattr__</code>、<code>__getattribute__</code>、<code>__setattr__</code>、<code>__delattr__</code>、<code>__dir__</code></td></tr><tr class="odd"><td>属性描述符</td><td><code>__get__</code>、<code>__set__</code>、<code>__delete__</code></td></tr><tr class="even"><td>跟类相关的服务</td><td><code>__prepare__</code>、<code>__instancecheck__</code>、<code>__subclasscheck__</code></td></tr></tbody></table><h2 id="跟运算符相关的特殊方法">跟运算符相关的特殊方法</h2><table><colgroup><col style="width: 23%"><col style="width: 76%"></colgroup><thead><tr class="header"><th>类别</th><th>方法名和对应的运算符</th></tr></thead><tbody><tr class="odd"><td>一元运算符</td><td><code>__neg__ -</code>、<code>__pos__ +</code>、<code>__abs__ abs()</code></td></tr><tr class="even"><td>比较运算符</td><td><code>__lt__ &lt;</code>、<code>__le__ &lt;=</code>、<code>__eq__ ==</code>、<code>__ne__ !=</code>、<code>__gt__ &gt;</code>、<code>__ge__ &gt;=</code></td></tr><tr class="odd"><td>算术运算符</td><td><code>__add__ +</code>、<code>__sub__ -</code>、<code>__mul__ *</code>、<code>__truediv__ /</code>、<code>__floordiv__ //</code>、<code>__mod__ %</code>、<code>__divmod__ divmod()</code>、<code>__pow__ **</code>或<code>pow()</code>、<code>__round__ round()</code></td></tr><tr class="even"><td>反向算术运算符</td><td><code>__radd__</code>、<code>__rsub__</code>、<code>__rmul__</code>、<code>__rtruediv__</code>、 <code>__rfloordiv__</code>、<code>__rmod__</code>、<code>__rdivmod__</code>、<code>__rpow__</code></td></tr><tr class="odd"><td>增量赋值算术运算符</td><td><code>__iadd__</code>、<code>__isub__</code>、<code>__imul__</code>、<code>__itruediv__</code>、 <code>__ifloordiv__</code>、<code>__imod__</code>、<code>__ipow__</code></td></tr><tr class="even"><td>位运算符</td><td><code>__invert__ ~</code>、<code>__lshift__ &lt;&lt;</code>、<code>__rshift__ &gt;&gt;</code>、<code>__and__ &amp;</code>、<code>__or__ |</code>、<code>__xor__ ^</code></td></tr><tr class="odd"><td>反向位运算符</td><td><code>__rlshift__</code>、<code>__rrshift__</code>、<code>__rand__</code>、<code>__rxor__</code>、<code>__ror__</code></td></tr><tr class="even"><td>增量赋值位运算符</td><td><code>__ilshift__</code>、<code>__irshift__</code>、<code>__iand__</code>、<code>__ixor__</code>、<code>__ior__</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> special methods </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jupyter Notebook ModuleNotFoundError</title>
      <link href="/programming/jupyter-notebook-ModuleNotFoundError/"/>
      <url>/programming/jupyter-notebook-ModuleNotFoundError/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_34650787/article/details/83304080" target="_blank" rel="noopener">点击查看原文</a></p><p>可能原因：安装了多个Python版本，终端和Jupyter Notebook使用的不是同一个Python。</p><p>在Terminal和Jupyter Notebook中分别执行</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.executable</span><br></pre></td></tr></table></figure><p>比较各自的输出路径。若不相同，例如</p><p>Terminal：<code>/Users/cws/opt/anaconda3/bin/python</code></p><p>Notebook：<code>/usr/local/bin/python3.6</code></p><p>则可按照下述操作解决此问题。打开Terminal，</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(base) MacBook-Pro:~ cws$ jupyter kernelspec list</span><br><span class="line">Available kernels:  <span class="comment"># 列出所有内核</span></span><br><span class="line">  python36    /Users/cws/Library/Jupyter/kernels/python36</span><br><span class="line">  python3     /Library/Frameworks/Python.framework/Versions/<span class="number">3.6</span>/share/jupyter/kernels/python3</span><br></pre></td></tr></table></figure><p>根据自己正在使用的内核，例如python3，进入对应目录/Library/.../python3，修改配置文件kernel.json</p><figure class="highlight diff"><figcaption><span>kernel.json</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> "argv": [</span><br><span class="line"><span class="deletion">- "python",</span></span><br><span class="line"><span class="addition">+ "/Users/cws/opt/anaconda3/bin/python",</span></span><br><span class="line">  "-m",</span><br><span class="line">  "ipykernel_launcher",</span><br><span class="line">  "-f",</span><br><span class="line">  "&#123;connection_file&#125;"</span><br><span class="line"> ],</span><br><span class="line"> "display_name": "Python 3",</span><br><span class="line"> "language": "python"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后保存，重启Notebook。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> jupyter notebook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树</title>
      <link href="/notes/introduction-to-algorithms/red-black-trees/"/>
      <url>/notes/introduction-to-algorithms/red-black-trees/</url>
      
        <content type="html"><![CDATA[<h1 id="红黑树">红黑树</h1><p>红黑树（red-black tree）是一棵二叉搜索树，是许多平衡搜索树的一种。它在每个节点上增加了一个存储位来表示结点的颜色，可以是RED或BLACK。通过对任何一条从根到叶子的简单路径上各个结点的颜色进行约束，<strong>红黑树确保没有一条路径会比其他路径长出2倍</strong>，因而是近似于平衡的。</p><h1 id="性质">性质</h1><p>树中每个结点包含5个属性：color、key、left、right和p。</p><p>一棵红黑树是满足下面<strong>红黑性质</strong>的二叉搜索树：</p><ol type="1"><li>每个结点或是红色的，或是黑色的。</li><li>根节点是黑色的。</li><li>每个叶子结点（NIL）是黑色的。</li><li>如果一个结点是红色的，则它的两个子节点都是黑色的。</li><li>对每个结点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色结点。</li></ol><a id="more"></a><p>为了便于处理红黑树中的边界条件，使用一个哨兵来代替NIL。哨兵的color=BLACK，其他属性的p、left、right、key的取值不重要。尽管可以为树中每一个NIL（叶子结点）新增一个不同的哨兵结点，但会浪费空间。取而代之的是，使用一个哨兵T.nil​来代表所有的NIL。如图(b)可以用更少的空间等价地表示图(a)。其中黑色结点用黑色、红色节点用灰色表示。</p><p><strong>黑高</strong>（black-height）：从某个结点x出发（不含该结点）到达一个叶节点的任意一条简单路径上的黑色结点个数（根据性质5可知结点的黑高是唯一的）称为该结点的黑高，记为bh(x)​。定义红黑树的黑高为其根节点的黑高。如图(a)所示的红黑树中，红黑树的黑高为3。图(c)省略了哨兵，多数时候采用这种更简洁的画法。</p><p><img src="/uploads/image/introduction-to-algorithms/red-black-tree.png"></p><blockquote><p>引理13.1</p><p>一棵有n个内部结点的红黑树的高度至多为<span class="math inline">\(2\lg(n+1)\)</span>。</p></blockquote><p><strong>证明</strong>： 先证明以任一结点x为根的子树中至少包含<span class="math inline">\(2^{bh(x)}-1\)</span>个内部结点。使用归纳法证明。</p><ol type="1"><li><p>如果x的高度为0，则x为叶节点（T.nil)，且以x为根节点的子树至少包含<span class="math inline">\(2^{bh(x)}-1=2^0-1=0\)</span>个内部结点。</p></li><li><p>如果x的高度为h(h&gt;0)，假设以x为根节点的子树至少包含<span class="math inline">\(2^{bh(x)}-1\)</span>个内部结点成立。</p></li><li><p>考虑高度h+1且有两个子节点的内部节点<span class="math inline">\(x^\prime\)</span>。子节点的高度为h，黑高为</p><ul><li><span class="math inline">\(bh(x^\prime)\)</span>（当子节点为红色时），</li><li>或<span class="math inline">\(bh(x^\prime)-1\)</span>（当子节点为黑色时）。</li></ul><p>根据归纳假设，以子节点为根节点的子树至少包含<span class="math inline">\(2^{bh(x)-1}-1\)</span>个结点。于是，以<span class="math inline">\(x^\prime\)</span>为根的子树至少包含<span class="math inline">\((2^{bh(x)-1}-1)+(2^{bh(x)-1}-1)+1=2^{bh(x)}-1\)</span>个内部结点。</p></li></ol><p>之后，证明引理：设h为树的高度。根据性质4，从根到叶节点的任何一条简单路径上都至少有一半的结点为黑色。因此，根的黑高至少为h/2，于是有<span class="math inline">\(n\ge2^{h/2}-1\)</span>，将1移到左边，再对两边取对数，得到<span class="math inline">\(h\le2\lg(n+1)\)</span>。</p><h1 id="旋转">旋转</h1><p>搜索树操作TREE-INSERT和TREE-DELETE在含n个关键字的红黑树上，运行花费时间为<span class="math inline">\(O(\lg{n})\)</span>。由于这两个操作对树做了修改，结果可能违反红黑性质。为了维护这些性质，必须要改变树中某些结点的颜色以及指针结构。</p><p>指针结构的修改是通过<strong>旋转</strong>（rotation）来完成的，这是一种能保持二叉搜索树性质的局部操作。<strong>在旋转操作中只有指针改变</strong>，其他所有属性都保持不变。下图给出了两种旋转：左旋和右旋。</p><ul><li>左旋：结点x取代<span class="math inline">\(\beta\)</span>成为y的左孩子结点，<span class="math inline">\(\beta\)</span>取代y成为x的右孩子结点。</li><li>右旋：结点y取代<span class="math inline">\(\beta\)</span>成为x的左孩子结点，<span class="math inline">\(\beta\)</span>取代x成为y的左孩子结点。</li></ul><p><img src="/uploads/image/introduction-to-algorithms/red-black-tree-rotation.png"></p><p>容易观察到，旋转前与旋转后各元素的大小顺序没有改变，都是<span class="math inline">\(\alpha\le{x}\le\beta\le{y}\le\gamma\)</span>。</p><p>在LEFT-ROTATE的伪代码中，假设<span class="math inline">\(x.right\ne{T.nil}\)</span>且根节点的父节点为T.nil。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">LEFT-ROTATE(T, x):</span><br><span class="line">y = x.right              <span class="comment"># y的位置（结合上图理解）</span></span><br><span class="line">x.right = y.left         <span class="comment"># beta取代y成为x的右孩子</span></span><br><span class="line"><span class="keyword">if</span> y.left != T.nil:      <span class="comment"># 此时y.left还是beta结点</span></span><br><span class="line">    y.left.p = x         <span class="comment"># 修改beta的父节点为x</span></span><br><span class="line">y.p = x.p                <span class="comment"># 修改y的父节点</span></span><br><span class="line"><span class="keyword">if</span> x.p == T.nil:         <span class="comment"># 若x原本是根节点，y将变为树的根</span></span><br><span class="line">    T.root = y</span><br><span class="line"><span class="keyword">elif</span> x == x.p.left:      <span class="comment"># 若原本x是左孩子，y取代x后依旧是左孩子</span></span><br><span class="line">    x.p.left = y</span><br><span class="line"><span class="keyword">else</span>:                    <span class="comment"># 若原本x是右孩子，y取代x后依旧是右孩子</span></span><br><span class="line">    x.p.right = y</span><br><span class="line">y.left = x               <span class="comment"># x变为y的左孩子</span></span><br><span class="line">x.p = y                  <span class="comment"># 修改x的父节点为y</span></span><br></pre></td></tr></table></figure><p>RIGHT-ROTATE操作的代码是对称的。它们都在O(1)时间内运行完成。</p><p><img src="/uploads/image/introduction-to-algorithms/red-black-tree-left-rotate.png"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">RIGHT-ROTATE(T, x):</span><br><span class="line">y = x.p</span><br><span class="line">y.left = x.right</span><br><span class="line"><span class="keyword">if</span> x.right != T.nil:</span><br><span class="line">    x.right.p = y</span><br><span class="line">x.p = y.p</span><br><span class="line"><span class="keyword">if</span> y.p == T.nil:</span><br><span class="line">    T.root = x</span><br><span class="line"><span class="keyword">elif</span> y == y.p.left:</span><br><span class="line">    y.p.left = x</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    y.p.right = x</span><br><span class="line">x.right = y</span><br><span class="line">y.p = x</span><br></pre></td></tr></table></figure><h1 id="插入">插入</h1><p>利用二叉搜索树的插入过程，略作修改来将结点z插入树T内，就好像T是一棵普通的二叉搜索树一样，然后将z着为红色。为了保证红黑性质能继续保持，调用一个辅助程序RB-INSERT-FIXUP来对结点重新着色并旋转。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">RB-INSERT(T, z):</span><br><span class="line">y = T.nil             <span class="comment"># 与普通的二叉搜索树不同，此处y指向哨兵</span></span><br><span class="line">x = T.root            <span class="comment"># 寻找z的插入位置</span></span><br><span class="line"><span class="keyword">while</span> x != T.nil:</span><br><span class="line">    y = x</span><br><span class="line">    <span class="keyword">if</span> z.key &lt; x.key:</span><br><span class="line">        x = x.left</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x = x.right</span><br><span class="line">z.p = y               <span class="comment"># 插入结点z</span></span><br><span class="line"><span class="keyword">if</span> y == T.nil:</span><br><span class="line">    T.root = z</span><br><span class="line"><span class="keyword">elif</span> z.key &lt; y.key:</span><br><span class="line">    y.left = z</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    y.right = z</span><br><span class="line">z.left = T.nil        <span class="comment"># 设置新节点的左右孩子为哨兵结点，以保持合理的树结构</span></span><br><span class="line">z.right = T.nil</span><br><span class="line">z.color = RED         <span class="comment"># 新插入节点着红色</span></span><br><span class="line">RB-INSERT-FIXUP(T, z) <span class="comment"># 辅助程序，对结点重新着色并旋转以维护红黑性质</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">RB-INSERT-FIXUP(T, z):</span><br><span class="line"><span class="keyword">while</span> z.p.color == RED:        <span class="comment"># z的父节点也为红色，违反性质4</span></span><br><span class="line">    <span class="keyword">if</span> z.p == z.p.p.left:      <span class="comment"># 如果z的父节点是左孩子结点</span></span><br><span class="line">        y = z.p.p.right        <span class="comment"># z的叔结点(父节点的另一个兄弟结点)</span></span><br><span class="line">        <span class="keyword">if</span> y.color == RED:        <span class="comment"># 情况1：z的叔结点y也是红色的</span></span><br><span class="line">            z.p.color = BLACK          <span class="comment"># z的父节点涂黑</span></span><br><span class="line">            y.color = BLACK            <span class="comment"># z的叔结点也涂黑</span></span><br><span class="line">            z.p.p.color = RED          <span class="comment"># z的祖父结点涂红(将祖父结点涂红可能违反性质4)</span></span><br><span class="line">            z = z.p.p                  <span class="comment"># z指针上升至祖父结点，等候下一次循环修复性质</span></span><br><span class="line">        <span class="keyword">elif</span> z == z.p.right:      <span class="comment"># 情况2：叔结点非红且z是右孩子结点</span></span><br><span class="line">            z = z.p                    <span class="comment"># 注意此时无论情况1是否发生，z的父节点都是红色</span></span><br><span class="line">            LEFT-ROTATE(T, z)          <span class="comment"># 左旋，转为情况3</span></span><br><span class="line">                                  <span class="comment"># 情况3：叔结点非红且z是左孩子结点(注意左旋后z的位置变化)</span></span><br><span class="line">        z.p.color = BLACK         <span class="comment"># 父节点涂黑</span></span><br><span class="line">        z.p.p.color = RED         <span class="comment"># 祖父结点涂红</span></span><br><span class="line">        RIGHT-ROTATE(T, z.p.p)    <span class="comment"># 右旋</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        same <span class="keyword">as</span> then clause <span class="keyword">with</span> <span class="string">"right"</span> <span class="keyword">and</span> <span class="string">"left"</span> exchanged</span><br><span class="line">T.root.color = BLACK              <span class="comment"># 根节点涂黑，修复性质2</span></span><br></pre></td></tr></table></figure><p>在调用RB-INSERT-FIXUP操作时，哪些红黑性质可能会被破坏呢？性质1（非红即黑）和性质3（叶子全黑）继续成立，因为新插入的红节点的两个子节点都是哨兵T.nil。性质5（黑高相等）也会成立，因为结点z代替了黑色的哨兵结点，并且z本身是红结点且有哨兵结点。仅可能被破坏的就是性质2（根节点为黑色）和性质4（红节点不能有红孩子）。如果z是根节点，则破坏了性质2；如果z的父节点是红节点，则破坏了性质4。</p><p>当违反性质4时，z与父节点z.p都时红色，此时可能发生的情况如下：</p><ul><li>情况1：z的叔结点y是红色的。通过重新着色修复性质。</li><li>z的叔结点y是黑色：<ul><li>情况2：z是一个右孩子。通过左旋转化为情况3。（表明这几种情况不是完全独立的）</li><li>情况3：z是一个左孩子。通过重新着色和右旋修复性质。</li></ul></li></ul><p>下图给出一个范例，显示在一棵红黑树上RB-INSERT-FIXUP如何操作。</p><p><img src="/uploads/image/introduction-to-algorithms/red-black-tree-insert-fixup.png"></p><p>由于一棵有n个结点的红黑树的高度为<span class="math inline">\(O(\lg{n})\)</span>，因此RB-INSERT的插入操作要花费<span class="math inline">\(O(\lg{n})\)</span>时间。在RB-INSERT-FIXUP中，仅当情况1发生，然后指针z沿着树上升2层，while循环才会重复执行。所以while循环可能被执行的总次数为<span class="math inline">\(O(\lg{n})\)</span>。因此，RB-INSERT总共花费<span class="math inline">\(O(\lg{n})\)</span>时间。此外，该程序所做的旋转不超过2次，因为只要执行了情况2（先左旋后右旋，旋转两次）或情况3（一次右旋），while循环就结束了。</p><h1 id="删除">删除</h1><p>从一棵红黑树中删除结点的过程是基于二叉搜索树的删除过程而来的。首先，需要特别设计一个子过程：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">RB-TRANSPLANT(T, u, v): <span class="comment"># 用根节点为v的子树替换根节点为u的子树</span></span><br><span class="line"><span class="keyword">if</span> u.p == T.nil:        <span class="comment"># 若u为根结点，只需改变树的根指针即可</span></span><br><span class="line">    T.root = v</span><br><span class="line"><span class="keyword">elif</span> u == u.p.left:     <span class="comment"># 若u是左孩子</span></span><br><span class="line">    u.p.left = v        <span class="comment"># 移植v</span></span><br><span class="line"><span class="keyword">else</span>:                   <span class="comment"># 若u是右孩子</span></span><br><span class="line">    u.p.right = v</span><br><span class="line">v.p = u.p               <span class="comment"># 无条件执行，因为红黑树所有结点(包括哨兵结点)都有父节点属性</span></span><br></pre></td></tr></table></figure><p>过程RB-DELETE与TREE-DELETE类似，两个过程具有相同的基本结构。在RB-DELETE中能够找到TREE-DELETE的每一行语句（其中NIL被替换成了T.nil，TRANSPLANT换成了RB-TRANSPLANT），其执行的条件相同。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">RB-DELETE(T, z):</span><br><span class="line">y = z                             <span class="comment"># y为从树中删除的结点或者移至树内的结点</span></span><br><span class="line">y-original-color = y.color        <span class="comment"># 记录y的原始颜色</span></span><br><span class="line"><span class="keyword">if</span> z.left == T.nil:               <span class="comment"># 情况(a)：左孩子为空</span></span><br><span class="line">    x = z.right                     <span class="comment"># 移植后的结点可能会破坏红黑性质，用x记录其踪迹</span></span><br><span class="line">    RB-TRANSPLANT(T, z, z.right)    <span class="comment"># 用z的右孩子(可能为T.nil)替换z，达到删除z的目的</span></span><br><span class="line"><span class="keyword">elif</span> z.right == T.nil:            <span class="comment"># 情况(b)：右孩子为空</span></span><br><span class="line">    x = z.left                      <span class="comment"># 记录x的踪迹</span></span><br><span class="line">    RB-TRANSPLANT(T, z, z.left)     <span class="comment"># 用z的左孩子替换z</span></span><br><span class="line"><span class="keyword">else</span>:                             <span class="comment"># 情况(c)和(d)：有两个孩子，用z的后继结点y替换z</span></span><br><span class="line">    y = TREE-MINIMUM(z.right)       <span class="comment"># 查找后继结点y</span></span><br><span class="line">    y-original-color = y.color      <span class="comment"># 记录y的初始颜色</span></span><br><span class="line">    x = y.right                     <span class="comment"># 记录x的踪迹</span></span><br><span class="line">    <span class="keyword">if</span> y.p != z                   <span class="comment"># 情况(d)：后继结点y不是z的子节点</span></span><br><span class="line">        RB-TRANSPLANT(T, y, y.right)</span><br><span class="line">        y.right = z.right</span><br><span class="line">        y.right.p = y</span><br><span class="line">    <span class="keyword">else</span>:                         <span class="comment"># 情况(c)：y是z的子节点</span></span><br><span class="line">        x.p = y                     <span class="comment"># 没搞懂你存在的意义</span></span><br><span class="line">    RB-TRANSPLANT(T, z, y)</span><br><span class="line">    y.left = z.left</span><br><span class="line">    y.left.p = y</span><br><span class="line">    y.color = z.color             <span class="comment"># 删除z后，将替换z的结点y涂与z相同的颜色</span></span><br><span class="line"><span class="keyword">if</span> y-original-color == BLACK:  <span class="comment"># 如果原始为黑色，删除或移动y会破坏红黑性质；原始为红色，则不会</span></span><br><span class="line">    RB-DELETE-FIXUP(T, x)      <span class="comment"># 调用子过程修复红黑性质</span></span><br></pre></td></tr></table></figure><p>删除过程分为两部分：</p><ul><li><p>与二叉搜索树的删除操作相同的删除操作。下图描述了在二叉搜索树上删除结点时的4种情况，在红黑树上删除结点时同样考虑这4种情况。</p></li><li><p>修复红黑性质的RB-DELETE-FIXUP操作。为此，在删除结点时用变量y-original-color和x记录了必要的信息。</p></li></ul><p><img src="/uploads/image/introduction-to-algorithms/binary-search-tree-delete.png"></p><p>在RB-DELETE的最后，如果结点y是黑色的，就有可能已经引入了一个或多个红黑性质被破坏的情况，所以调用RB-DELETE-FIXUP来恢复红黑性质。如果结点y是红色，当y被删除或移动时，红黑性质仍然保持，原因如下：</p><ol type="1"><li>树中的黑高没有变化。</li><li>不存在两个相邻的红色结点：<ul><li>情况(a)或情况(b)发生时（y与z相同），y是红色，则其子节点一定是黑色。y被删除后，其子节点替换y的位置。因此，不会出现两个相邻的红色结点。</li><li>情况(c)发生时（y是z的后继结点），y是红色，则y的右孩子x一定是黑色，y替换z后被涂成与z相同的颜色，y和x不会出现两个相邻的红色结点。</li><li>情况(d)的第一步替换中，y是红色，则x是黑色，x替换y之后不会出现两个相邻的红色结点。第二步替换中，y替换z并且被涂成与z相同的颜色。因此y与r不会是两个相邻的红色结点（y与r的颜色就是原来z与r的颜色）。</li></ul></li><li>y是红色，就不可能是根节点，所以根节点仍旧是黑色。</li></ol><p>如果结点y是黑色，则会产生三个问题，可以通过调用RB-DELETE-FIXUP进行修复。</p><ol type="1"><li>在情况(a)和(b)中，y（与z相同）是黑色，若y的一个红色的孩子（l或r）替换了y成为新的根节点，则违反了性质2（根节点为黑色）。</li><li>在情况(c)和(d)中，y是黑色，若y.p与x同时为红色，则删除z后出现y.p与x都是红色的情况，违反了性质4（红色结点的孩子是黑色的）。</li><li>y为黑色，移动y将导致包含y的任何简单路径上的黑结点个数少1。因此，y的任何祖先都不满足性质5（到叶节点的简单路径含有相同数目的黑色结点）。改正这一问题的办法是将现在占有y原来位置的结点x视为还有一重额外的黑色。当将黑色结点y删除或移动时，将其黑色“下推“给结点x。这个额外的黑色是针对结点x的，而不是反映在它的color属性上的。x.color仍然是RED（如果x是红黑色的）或BLACK（如果x是双重黑色的）。x时双重黑色或红黑色时，分别给包含x的简单路径上黑结点数贡献了2或1。</li></ol><p>下面是过程RB-DELETE-FIXUP的伪代码。该过程可以恢复性质1、性质2和性质4。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">RB-DELETE-FIXUP(T, x):</span><br><span class="line"><span class="keyword">while</span> x != T.root <span class="keyword">and</span> x.color == BLACK:<span class="comment"># x为双重黑色，为黑色结点数贡献2</span></span><br><span class="line">    <span class="keyword">if</span> x == x.p.left:</span><br><span class="line">        w = x.p.right                  <span class="comment"># w指向兄弟结点</span></span><br><span class="line">        <span class="keyword">if</span> w.color == RED:             <span class="comment"># 情况1：w是红色的，可以通过以下操作转化为情况2、3或4</span></span><br><span class="line">            w.color = BLACK               <span class="comment"># 而不会违反红黑树的任何性质</span></span><br><span class="line">            x.p.color = RED            <span class="comment"># 改变w和x.p的颜色</span></span><br><span class="line">            LEFT-ROTATE(T, x.p)        <span class="comment"># 然后对x.p做一次左旋</span></span><br><span class="line">            w = x.p.right              <span class="comment"># x的新的兄弟结点w是黑色了</span></span><br><span class="line">        <span class="keyword">if</span> w.left.color == BLACK <span class="keyword">and</span> w.right.color == BLACK: <span class="comment"># 情况2：w和w的两个孩子都是黑色的</span></span><br><span class="line">            w.color = RED              <span class="comment"># 抹去w的黑色，w的所有祖先的黑高降低了1</span></span><br><span class="line">            x = x.p                    <span class="comment"># 作为补偿，在x.p(也是w的父节点)上新增一重额外的黑色</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 情况3和情况4的公共前提：w是黑色的，但两个孩子不全是黑色</span></span><br><span class="line">            <span class="keyword">if</span> w.right.color == BLACK: <span class="comment"># 情况3：w的右孩子是黑色的，暗示着左孩子是红色的</span></span><br><span class="line">                w.left.color = BLACK      <span class="comment"># 通过下列操作转化为情况4而不违反红黑树的任何性质</span></span><br><span class="line">                w.color = RED             <span class="comment"># w与其左孩子交换颜色(w变为红色了)</span></span><br><span class="line">                RIGHT-ROTATE(T, w)        <span class="comment"># 然后对w进行右旋(旋转后的w变成了新w的右孩子)</span></span><br><span class="line">                w = x.p.right             <span class="comment"># x的新的兄弟结点w仍旧是黑色的</span></span><br><span class="line">            w.color = x.p.color        <span class="comment"># 情况4：w的右孩子是红色的，左孩子颜色无所谓</span></span><br><span class="line">            x.p.color = BLACK          <span class="comment"># w涂上父节点的颜色</span></span><br><span class="line">            w.right.color = BLACK      <span class="comment"># 然后将父节点x.p和右孩子w.right涂成黑色</span></span><br><span class="line">            LEFT-ROTATE(T, x.p)        <span class="comment"># 最后对x.p进行一次左旋，即可去掉x的额外的黑色</span></span><br><span class="line">            x = T.root                 <span class="comment"># 将x设置为root，退出while循环</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">         <span class="comment"># same as then clause with "right" and "left" exchanged</span></span><br><span class="line">x.color = BLACK                        <span class="comment"># 若x指向红黑结点或根节点，直接涂成黑色即可修复性质5</span></span><br></pre></td></tr></table></figure><p>while循环的目标是将额外的黑色沿树上移，直到可以将额外的黑色移除：</p><ol type="1"><li>x指向红黑结点，此时将x着为黑色（x.color = BLACK），”移除”额外的黑色。</li><li>x指向根结点，此时”移除“额外的黑色即可。根结点x到所有叶子结点的简单路径的黑色结点数都降低1。</li><li>执行适当的旋转和重新着色，退出循环（while循环内的代码）。</li></ol><p>在while循环中，x总是指向一个具有双重黑色的非根结点。要判断x是左孩子还是右孩子。为左孩子时的代码与为右孩子时的代码是对称的。</p><p><img src="/uploads/image/introduction-to-algorithms/red-black-tree-delete-fixup.png"></p><p>对图的说明：</p><ul><li>加黑的结点color属性为BLACK，深阴影的结点color属性为RED，浅阴影的结点color属性用c和<span class="math inline">\(c^\prime\)</span>表示，它既可为RED也可为BLACK。字母<span class="math inline">\(\alpha,\beta,\dots,\zeta\)</span>代表任意的子树。容易观察到在上述4中操作中，任意结点的黑高都没有发生变化（注意x的黑色层数）。</li><li>x指向的结点带有额外的一重黑色，即x为双重黑色或红黑色。</li></ul><p>对代码内注释的整理：</p><ul><li>x的兄弟结点w是红色的。改变w和x.p的颜色，对x.p做一次左旋。旋转后，x的新兄弟结点new w是黑色的，就将情况1转换为情况2、3或4。</li><li>x的兄弟结点w是黑色的。<ul><li>w的两个子节点都是黑色的。去掉w的黑色，作为补偿对w.p（=x.p）补偿一层黑色。在代码中表现为指针x的移动。</li><li>w的两个孩子不全是黑色的。<ul><li>w的左孩子是红色的，右孩子是黑色的。交换w和左孩子w.left的颜色，对w进行右旋。旋转后，x的新兄弟结点w是一个有红色右孩子的黑色结点，将情况3转换成情况4。</li><li>w的右孩子是红色的，左孩子颜色可红可黑。通过进行某些颜色修改并对x.p做一次左旋，可以去掉x的额外的黑色，从而使它变为单黑色。将x设置为根后，当while循环测试循环条件时，循环终止。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Algorithms </tag>
            
            <tag> data structures </tag>
            
            <tag> red-black tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx启用WebDAV</title>
      <link href="/server/nginx-set-up-a-webdav/"/>
      <url>/server/nginx-set-up-a-webdav/</url>
      
        <content type="html"><![CDATA[<h1 id="环境">环境</h1><p><a href="https://en.wikipedia.org/wiki/WebDAV" target="_blank" rel="noopener">WebDAV</a>: Web Distributed Authoring and Versioning.</p><ul><li><p>系统：ubuntu 18.04.2 LTS</p></li><li><p>nginx：1.14.0</p></li><li><p>客户端：iOS documents 和 Windows winscp</p></li></ul><h1 id="安装nginx">安装nginx</h1><p>nginx默认支持dav，但PROPFIND、OPTIONS操作还不支持。支持这些操作需要额外的模块。</p><ul><li>完全安装。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ubuntu@ip:~$ sudo apt-get update</span><br><span class="line">ubuntu@ip:~$ sudo apt-get install nginx-full</span><br></pre></td></tr></table></figure><ul><li>部分安装。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ubuntu@ip:~$ sudo apt-get update</span><br><span class="line">ubuntu@ip:~$ sudo apt-get install nginx nginx-extras</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="配置">配置</h1><p>使用新域名。在sites-available目录下添加配置文件。</p><figure class="highlight plain"><figcaption><span>/etc/nginx/sites-available/dav</span></figcaption><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 443 ssl;</span><br><span class="line">        listen [::]:443 ssl;</span><br><span class="line"></span><br><span class="line">        server_name your_dav_domain.com;</span><br><span class="line">        root /var/www/nginx/dav;</span><br><span class="line"></span><br><span class="line">        ssl on;</span><br><span class="line">        ssl_certificate /your/path/dav.crt;</span><br><span class="line">        ssl_certificate_key /your/path/dav.key;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                charset         utf-8;</span><br><span class="line">                autoindex       on;</span><br><span class="line"></span><br><span class="line">                client_body_temp_path   /etc/nginx/client_temp;</span><br><span class="line">                client_max_body_size    512m;  # 最大文件，若为0则表示不限制</span><br><span class="line"></span><br><span class="line">                dav_methods PUT DELETE MKCOL COPY MOVE;</span><br><span class="line">                dav_ext_methods PROPFIND OPTIONS;  # 需要额外的模块支持</span><br><span class="line"></span><br><span class="line">                create_full_put_path    on;</span><br><span class="line">                dav_access              group:rw all:r;</span><br><span class="line"></span><br><span class="line">                auth_basic              &quot;Access limited&quot;;</span><br><span class="line">                auth_basic_user_file    /etc/nginx/user.passwd;</span><br><span class="line"></span><br><span class="line">                access_log              /var/log/nginx/access.dav.log;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启用该配置。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git@ip:/etc/nginx/sites-enabled$ <span class="built_in">cd</span> /etc/nginx/sites-available/</span><br><span class="line">git@ip:/etc/nginx/sites-available$ sudo ln -s dav ../sites-enabled/dav</span><br><span class="line">git@ip:/etc/nginx/sites-available$ sudo nginx -t</span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf <span class="built_in">test</span> is successful</span><br><span class="line">git@ip:/etc/nginx/sites-available$ sudo nginx -s reload</span><br></pre></td></tr></table></figure><h1 id="删除文件夹">删除文件夹</h1><p>搭建了webdav服务器后，能访问并可以执行部分操作，如创建文件等。但也有不能执行的操作，出现此问题的原因是客户端和服务器的要求不兼容。比如winscp可以删除文件夹，但不可以修改文件夹名称。documents不可以删除文件夹（但是文件夹里面的文件会被成功删除），也不能重命名文件夹（客户端提示权限不足，提示并不正确，看nginx的错误日志）。</p><table><thead><tr class="header"><th>操作</th><th>winscp</th><th>documents</th><th>err_log</th></tr></thead><tbody><tr class="odd"><td>浏览</td><td>Y</td><td>Y</td><td></td></tr><tr class="even"><td>创建文件</td><td>Y</td><td>Y</td><td></td></tr><tr class="odd"><td>创建文件夹</td><td>Y</td><td>Y</td><td></td></tr><tr class="even"><td>移动文件（包括重命名）</td><td>Y</td><td>Y</td><td></td></tr><tr class="odd"><td>移动文件夹（包括重命名）</td><td>N</td><td>N</td><td>&quot;/folder&quot; is collection</td></tr><tr class="even"><td>删除文件</td><td>Y</td><td>Y</td><td></td></tr><tr class="odd"><td>删除文件夹</td><td>Y</td><td>N</td><td>DELETE &quot;/folder&quot; failed (21: Is a directory)</td></tr></tbody></table><p>根据日志，报错的原因是nginx要求对文件夹的操作请求的末尾带上斜线/，比如删除文件夹必须是DELETE /folder/，但是客户端发出的请求是DELETE /folder，因此报错。</p><p>修复方法是重写请求，在webdav的配置文件中加入下列修改：</p><figure class="highlight diff"><figcaption><span>/etc/nginx/sites-enabled/dav</span></figcaption><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"><span class="addition">+    # 如果请求内容是文件夹，在请求末尾加上/</span></span><br><span class="line"><span class="addition">+    if ( -d $request_filename ) &#123;  </span></span><br><span class="line"><span class="addition">+        rewrite ^(.*[^/])$ $1/ break;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="移动文件夹">移动文件夹</h1><p>加了如上配置后，documents可以删除文件夹了，但是不论winscp还是documents都无法重命名文件夹。错误日志为<code>both URI &quot;/fog/&quot; and &quot;Destination&quot; URI &quot;https://dav.server.demo/fofg&quot; should be either collections or non-collections</code>。即nginx收到了将文件夹重命名为文件的操作请求，于是报出以上错误。在尝试了各种配置无法解决后，我在nginx源文件ngx_http_dav_module.c中找到了这段代码。这段代码要求URI和Destination一致，要么都带/，要么都不带/。</p><figure class="highlight c"><figcaption><span>~/nginx-1.14.0/src/http/modules/ngx_http_dav_module.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((r-&gt;uri.data[r-&gt;uri.len - <span class="number">1</span>] == <span class="string">'/'</span> &amp;&amp; *(last - <span class="number">1</span>) != <span class="string">'/'</span>)</span><br><span class="line">    || (r-&gt;uri.data[r-&gt;uri.len - <span class="number">1</span>] != <span class="string">'/'</span> &amp;&amp; *(last - <span class="number">1</span>) == <span class="string">'/'</span>))</span><br><span class="line">&#123;</span><br><span class="line">    ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                  <span class="string">"both URI \"%V\" and \"Destination\" URI \"%V\" "</span></span><br><span class="line">                  <span class="string">"should be either collections or non-collections"</span>,</span><br><span class="line">                  &amp;r-&gt;uri, &amp;dest-&gt;value);</span><br><span class="line">    <span class="keyword">return</span> NGX_HTTP_CONFLICT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要解决这个问题，我注释掉了这段代码，重新编译nginx。</p><h1 id="编译nginx">编译nginx</h1><p>下载nginx和nginx-dav-ext-module。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ubuntu@ip:~$ wget http://nginx.org/download/nginx-1.14.0.tar.gz</span><br><span class="line">ubuntu@ip:~$ tar xzf nginx-1.14.0.tar.gz</span><br><span class="line">ubuntu@ip:~$ git <span class="built_in">clone</span> https://github.com/arut/nginx-dav-ext-module.git</span><br></pre></td></tr></table></figure><p>在nginx源码中注释掉上述代码。</p><figure class="highlight c"><figcaption><span>~/nginx-1.14.0/src/http/modules/ngx_http_dav_module.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if ((r-&gt;uri.data[r-&gt;uri.len - 1] == '/' &amp;&amp; *(last - 1) != '/')</span></span><br><span class="line"><span class="comment">    || (r-&gt;uri.data[r-&gt;uri.len - 1] != '/' &amp;&amp; *(last - 1) == '/'))</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0,</span></span><br><span class="line"><span class="comment">                  "both URI \"%V\" and \"Destination\" URI \"%V\" "</span></span><br><span class="line"><span class="comment">                  "should be either collections or non-collections",</span></span><br><span class="line"><span class="comment">                  &amp;r-&gt;uri, &amp;dest-&gt;value);</span></span><br><span class="line"><span class="comment">    return NGX_HTTP_CONFLICT;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>设置编译参数，<a href="https://xuexb.github.io/learn-nginx/guide/nginx-configure-descriptions.html" target="_blank" rel="noopener">编译参数介绍</a>。不想深究编译参数，可以使用如下默认的编译参数。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ubuntu@ip:~/nginx-1.14.0$ nginx -V  <span class="comment"># 查看编译参数</span></span><br><span class="line">nginx version: nginx/1.14.0 (Ubuntu)</span><br><span class="line">built with OpenSSL 1.1.1  11 Sep 2018</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --with-cc-opt=<span class="string">'-g -O2 -fdebug-prefix-map=/build/nginx-DUghaW/nginx-1.14.0=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wdate-time -D_FORTIFY_SOURCE=2'</span> --with-ld-opt=<span class="string">'-Wl,-Bsymbolic-functions -Wl,-z,relro -Wl,-z,now -fPIC'</span> --prefix=/usr/share/nginx --conf-path=/etc/nginx/nginx.conf --http-log-path=/var/<span class="built_in">log</span>/nginx/access.log --error-log-path=/var/<span class="built_in">log</span>/nginx/error.log --lock-path=/var/lock/nginx.lock --pid-path=/run/nginx.pid --modules-path=/usr/lib/nginx/modules --http-client-body-temp-path=/var/lib/nginx/body --http-fastcgi-temp-path=/var/lib/nginx/fastcgi --http-proxy-temp-path=/var/lib/nginx/proxy --http-scgi-temp-path=/var/lib/nginx/scgi --http-uwsgi-temp-path=/var/lib/nginx/uwsgi --with-debug --with-pcre-jit --with-http_ssl_module --with-http_stub_status_module --with-http_realip_module --with-http_auth_request_module --with-http_v2_module --with-http_dav_module --with-http_slice_module --with-threads --with-http_addition_module --with-http_geoip_module=dynamic --with-http_gunzip_module --with-http_gzip_static_module --with-http_image_filter_module=dynamic --with-http_sub_module --with-http_xslt_module=dynamic --with-stream=dynamic --with-stream_ssl_module --with-mail=dynamic --with-mail_ssl_module</span><br></pre></td></tr></table></figure><p>保持这些参数不变，添加额外的nginx-dav-ext-module模块。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ubuntu@ip:~/nginx-1.14.0$ ./configure --with-cc-opt=...原来的参数... --add-module=../nginx-dav-ext-module</span><br><span class="line">ubuntu@ip:~/nginx-1.14.0$ make  <span class="comment"># 编译</span></span><br><span class="line">ubuntu@ip:~/nginx-1.14.0$ sudo objs/nginx -t  <span class="comment"># 测试</span></span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf <span class="built_in">test</span> is successful</span><br><span class="line">ubuntu@ip:~/nginx-1.14.0$ sudo cp /usr/sbin/nginx /usr/sbin/nginx.bak  <span class="comment"># 备份</span></span><br><span class="line">ubuntu@ip:~/nginx-1.14.0$ sudo nginx -s stop  <span class="comment"># 停止服务</span></span><br><span class="line">ubuntu@ip:~/nginx-1.14.0$ sudo cp objs/nginx /usr/sbin/nginx  <span class="comment"># 替换</span></span><br><span class="line">ubuntu@ip:~/nginx-1.14.0$ sudo service nginx start  <span class="comment"># 重启</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> webdav </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu挂载和卸除文件系统</title>
      <link href="/server/ubuntu-mount-and-unmount-drive/"/>
      <url>/server/ubuntu-mount-and-unmount-drive/</url>
      
        <content type="html"><![CDATA[<h1 id="挂载">挂载</h1><p>查看文件系统</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git@ip:~$ sudo fdisk -l</span><br><span class="line">...省略...</span><br><span class="line">Disk /dev/xvdb: 20 GiB, 21474836480 bytes, 41943040 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br></pre></td></tr></table></figure><p>目标文件系统为/dev/xvdb。挂载：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git@ip:~$ sudo mkdir /mnt/data</span><br><span class="line">git@ip:~$ sudo mount /dev/xvdb /mnt/data/</span><br><span class="line">git@ip:~$ sudo df -h  <span class="comment"># 显示文件系统</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">...省略...</span><br><span class="line">/dev/xvdb        20G  208M   19G   2% /mnt/data</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="卸除">卸除</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git@ip:~$ sudo umount /dev/xvdb  <span class="comment"># 通过设备名</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git@ip:~$ sudo umount /mnt/data  <span class="comment"># 通过挂载点</span></span><br></pre></td></tr></table></figure><h1 id="自动挂载">自动挂载</h1><p>查看文件系统信息：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git@ip:~$ sudo e2label /dev/xvdb data  <span class="comment"># 修改卷标</span></span><br><span class="line">git@ip:~$ sudo blkid /dev/xvdb</span><br><span class="line">/dev/xvdb: LABEL=<span class="string">"data"</span> UUID=<span class="string">"a0001bdb-4b69-4419-9339-f57ddec2f007"</span> TYPE=<span class="string">"ext4"</span></span><br></pre></td></tr></table></figure><p>修改fstab文件：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git@ip:~$ sudo nano /etc/fstab</span><br></pre></td></tr></table></figure><p>添加一列：</p><figure class="highlight diff"><figcaption><span>/etc/fstab</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="addition">+    LABEL=data              /mnt/data       ext4    defaults                0 2</span></span><br></pre></td></tr></table></figure><p>/etc/fstab文件包含了如下字段，通过空格或Tab分隔：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;file system&gt;    &lt;dir&gt;    &lt;type&gt;    &lt;options&gt;    &lt;dump&gt;    &lt;pass&gt;</span><br></pre></td></tr></table></figure><ul><li><file system> - 要挂载的分区或存储设备。</file></li><li><dir><ul><li>file systems的挂载位置。</li></ul></dir></li><li><type> - 文件系统类型，支持许多种不同的文件系统：ext2, ext3, ext4, reiserfs, xfs, jfs, smbfs, iso9660, vfat, ntfs, swap及auto。设置成auto类型，mount命令会猜测使用的文件系统类型，对CDROM和DVD等移动设备是非常有用的。</type></li><li><options> - 挂载时使用的参数，注意有些参数是特定文件系统才有的。</options></li><li><dump> - dump工具通过它决定何时作备份。dump会检查其内容，并用数字来决定是否对这个文件系统进行备份。允许的数字是0和1。0表示忽略，1则进行备份。大部分的用户是没有安装dump的，对他们而言<dump>应设为0。</dump></dump></li><li><pass> - fsck读取<pass>的数值来决定需要检查的文件系统的检查顺序。允许的数字是0, 1, 和2。根目录应当获得最高的优先权1,其它所有需要被检查的设备设置为2。0表示设备不会被fsck所检查。</pass></pass></li></ul><p><strong>验证配置的正确性</strong>：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git@ip:~$ sudo mount -a  <span class="comment"># 有错误时打印错误信息</span></span><br><span class="line">mount: /mnt/data: can<span class="string">'t find LABEL=date.</span></span><br></pre></td></tr></table></figure><p>最后可以重启系统验证一下。</p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> command </tag>
            
            <tag> mount </tag>
            
            <tag> unmount </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python迭代器与生成器</title>
      <link href="/programming/python-iterator-generator/"/>
      <url>/programming/python-iterator-generator/</url>
      
        <content type="html"><![CDATA[<h1 id="迭代器">迭代器</h1><p>迭代是访问集合元素的一种方式。迭代器从集合的第一个元素开始访问，直到所有元素被访问完。迭代器只能往前访问，不能后退。字符串，列表，集合等集合对象都可用于创建迭代器。</p><p>多数情况下，更倾向于通过以下方式遍历集合：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line"><span class="meta">... </span>    print(i, end=<span class="string">' '</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>    print()</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>等价地，可以创建一个集合a的迭代器：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it = iter(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>        print(next(it), end=<span class="string">' '</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">except</span> StopIteration:   <span class="comment"># 访问结束后再次调用next(it)会抛出此异常</span></span><br><span class="line"><span class="meta">... </span>        print()</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">break</span></span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>例如，有一个链表，我希望像遍历数组一样可以遍历链表。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        self.key, self.next = key, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.y = self  <span class="comment"># 用变量y记录位置</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.y <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 队尾判断</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x = self.y  <span class="comment"># 暂存</span></span><br><span class="line">            <span class="keyword">if</span> self.y <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment"># 更新位置以便下次访问</span></span><br><span class="line">                self.y = self.y.next</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a, b, c = Node(<span class="number">1</span>), Node(<span class="number">2</span>), Node(<span class="number">3</span>)</span><br><span class="line">    a.next, b.next, c.next = b, c, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a:             <span class="comment"># for each</span></span><br><span class="line">        print(i, end=<span class="string">' '</span>)</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line">    it = iter(b)            <span class="comment"># iterator</span></span><br><span class="line">    print(next(it))</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h1 id="生成器">生成器</h1><p>在Python中，使用了yield的函数被称为生成器。生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</p><p>python可以通过列表解析（list comprehension）的方式构建集合：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><p>实际上，<code>(i for i in range(10))</code>就是一个生成器。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">generator</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>在生成器运行过程中，每次遇到yield时函数会暂停并保存当前所有的运行信息，返回yield的值，并在下一次执行next()方法时从当前位置继续运行。</p><p>这在很多情况下特别有用。例如，最近研究如何获得一个图中两点之间的所有简单路径。一个测试示例中大概包含一千万条不同的简单路径，若是一次性将这一千万条作为数组返回，……，大概我的笔记本会原地爆炸吧。</p><p>这时生成器就排上用场了。为了简化说明，使用斐波那契数列作为示例。一个斐波那契数列的迭代版本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">"""返回斐波那契数列的前n个元素组成的列表"""</span></span><br><span class="line">    a, b, c, r = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, []</span><br><span class="line">    <span class="keyword">while</span> c &lt; n:</span><br><span class="line">        r.append(a)</span><br><span class="line">        a, b, c = b, a + b, c + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure><p>假设需要获得前一千万个数，……，(#`O′)。下面使用yield将之变为生成器。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci_it</span><span class="params">(n)</span>:</span> <span class="comment"># 它是一个迭代器</span></span><br><span class="line">    a, b, c = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> c &lt; n:</span><br><span class="line">        <span class="keyword">yield</span> a  <span class="comment"># 每次执行到此处暂停，返回一个结果，下次调用next时将从此处继续执行</span></span><br><span class="line">        a, b, c = b, a + b, c + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> fibonacci_it(<span class="number">10</span>):    <span class="comment"># 使用</span></span><br><span class="line">        print(i, end=<span class="string">' '</span>)</span><br><span class="line">    print()</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 1 1 2 3 5 8 13 21 34</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> iterator </tag>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NetworkX 文档</title>
      <link href="/documentation/networkx-documentation/"/>
      <url>/documentation/networkx-documentation/</url>
      
        <content type="html"><![CDATA[<h1 id="图的种类">图的种类</h1><p>有 4 种 + 1 类 <a href="https://networkx.github.io/documentation/stable/reference/classes/index.html#basic-graph-types" target="_blank" rel="noopener">Basic graph types</a>。</p><ul><li><code>Graph</code>：无向图，允许自环（顶点与自身连接的边）。</li><li><code>DiGraph</code>：有向图，允许自环。</li><li><code>MultiGraph</code>：无向图，允许自环和平行边（两条或多条与同一对顶点相连接的边）。</li><li><code>MultiDiGraph</code>：有向图，允许自环和平行边。</li><li>Ordered Graph：<code>OrderedGraph</code>，<code>OrderedDiGraph</code>，<code>OrderedMultiGraph</code>，<code>OrderedMultiDiGraph</code>。</li></ul><p>Ordered Graph 的存在意义：在返回图中顶点或边的集合时，Ordered Graph 总是以一个固定的顺序返回。</p><p>当<strong>无需此项性质</strong>或<strong>使用Python 3.6+</strong>（Python 3.6+中，集合的顺序是固定的）时，使用前四种基本类即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = nx.Graph()</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="graph-的方法">Graph 的方法</h1><p>其他类的方法大同小异。</p><h2 id="adding-and-removing-nodes-and-edges">Adding and removing nodes and edges</h2><table><colgroup><col style="width: 23%"><col style="width: 76%"></colgroup><thead><tr class="header"><th>Method</th><th>Description</th></tr></thead><tbody><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.__init__.html#networkx.Graph.__init__" target="_blank" rel="noopener"><code>Graph.__init__([incoming_graph_data])</code></a></td><td>Initialize a graph with edges, name, or graph attributes.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.add_node.html#networkx.Graph.add_node" target="_blank" rel="noopener"><code>Graph.add_node(node_for_adding, **attr)</code></a></td><td>Add a single node node_for_adding and update node attributes.</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.add_nodes_from.html#networkx.Graph.add_nodes_from" target="_blank" rel="noopener"><code>Graph.add_nodes_from(nodes_for_adding, **attr)</code></a></td><td>Add multiple nodes.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.remove_node.html#networkx.Graph.remove_node" target="_blank" rel="noopener"><code>Graph.remove_node(n)</code></a></td><td>Remove node n.</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.remove_nodes_from.html#networkx.Graph.remove_nodes_from" target="_blank" rel="noopener"><code>Graph.remove_nodes_from(nodes)</code></a></td><td>Remove multiple nodes.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.add_edge.html#networkx.Graph.add_edge" target="_blank" rel="noopener"><code>Graph.add_edge(u_of_edge, v_of_edge, **attr)</code></a></td><td>Add an edge between u and v.</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.add_edges_from.html#networkx.Graph.add_edges_from" target="_blank" rel="noopener"><code>Graph.add_edges_from(ebunch_to_add, **attr)</code></a></td><td>Add all the edges in ebunch_to_add.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.add_weighted_edges_from.html#networkx.Graph.add_weighted_edges_from" target="_blank" rel="noopener"><code>Graph.add_weighted_edges_from(ebunch_to_add)</code></a></td><td>Add weighted edges in ebunch_to_add with specified weight attr</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.remove_edge.html#networkx.Graph.remove_edge" target="_blank" rel="noopener"><code>Graph.remove_edge(u, v)</code></a></td><td>Remove the edge between u and v.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.remove_edges_from.html#networkx.Graph.remove_edges_from" target="_blank" rel="noopener"><code>Graph.remove_edges_from(ebunch)</code></a></td><td>Remove all edges specified in ebunch.</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.update.html#networkx.Graph.update" target="_blank" rel="noopener"><code>Graph.update([edges, nodes])</code></a></td><td>Update the graph using nodes/edges/graphs as input.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.clear.html#networkx.Graph.clear" target="_blank" rel="noopener"><code>Graph.clear()</code></a></td><td>Remove all nodes and edges from the graph.</td></tr></tbody></table><h2 id="reporting-nodes-edges-and-neighbors">Reporting nodes edges and neighbors</h2><table><colgroup><col style="width: 23%"><col style="width: 76%"></colgroup><thead><tr class="header"><th>Method</th><th>Description</th></tr></thead><tbody><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.nodes.html#networkx.Graph.nodes" target="_blank" rel="noopener"><code>Graph.nodes</code></a></td><td>A NodeView of the Graph as G.nodes or G.nodes().</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.__iter__.html#networkx.Graph.__iter__" target="_blank" rel="noopener"><code>Graph.__iter__()</code></a></td><td>Iterate over the nodes.</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.has_node.html#networkx.Graph.has_node" target="_blank" rel="noopener"><code>Graph.has_node(n)</code></a></td><td>Returns True if the graph contains the node n.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.__contains__.html#networkx.Graph.__contains__" target="_blank" rel="noopener"><code>Graph.__contains__(n)</code></a></td><td>Returns True if n is a node, False otherwise.</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.edges.html#networkx.Graph.edges" target="_blank" rel="noopener"><code>Graph.edges</code></a></td><td>An EdgeView of the Graph as G.edges or G.edges().</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.has_edge.html#networkx.Graph.has_edge" target="_blank" rel="noopener"><code>Graph.has_edge(u, v)</code></a></td><td>Returns True if the edge (u, v) is in the graph.</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.get_edge_data.html#networkx.Graph.get_edge_data" target="_blank" rel="noopener"><code>Graph.get_edge_data(u, v[, default])</code></a></td><td>Returns the attribute dictionary associated with edge (u, v).</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.neighbors.html#networkx.Graph.neighbors" target="_blank" rel="noopener"><code>Graph.neighbors(n)</code></a></td><td>Returns an iterator over all neighbors of node n.</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.adj.html#networkx.Graph.adj" target="_blank" rel="noopener"><code>Graph.adj</code></a></td><td>Graph adjacency object holding the neighbors of each node.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.__getitem__.html#networkx.Graph.__getitem__" target="_blank" rel="noopener"><code>Graph.__getitem__(n)</code></a></td><td>Returns a dict of neighbors of node n.</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.adjacency.html#networkx.Graph.adjacency" target="_blank" rel="noopener"><code>Graph.adjacency()</code></a></td><td>Returns an iterator over (node, adjacency dict) tuples for all nodes.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.nbunch_iter.html#networkx.Graph.nbunch_iter" target="_blank" rel="noopener"><code>Graph.nbunch_iter([nbunch])</code></a></td><td>Returns an iterator over nodes contained in nbunch that are also in the graph.</td></tr></tbody></table><h2 id="counting-nodes-edges-and-neighbors">Counting nodes edges and neighbors</h2><table><colgroup><col style="width: 23%"><col style="width: 76%"></colgroup><thead><tr class="header"><th>Method</th><th>Description</th></tr></thead><tbody><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.order.html#networkx.Graph.order" target="_blank" rel="noopener"><code>Graph.order()</code></a></td><td>Returns the number of nodes in the graph.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.number_of_nodes.html#networkx.Graph.number_of_nodes" target="_blank" rel="noopener"><code>Graph.number_of_nodes()</code></a></td><td>Returns the number of nodes in the graph.</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.__len__.html#networkx.Graph.__len__" target="_blank" rel="noopener"><code>Graph.__len__()</code></a></td><td>Returns the number of nodes in the graph.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.degree.html#networkx.Graph.degree" target="_blank" rel="noopener"><code>Graph.degree</code></a></td><td>A DegreeView for the Graph as G.degree or G.degree().</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.size.html#networkx.Graph.size" target="_blank" rel="noopener"><code>Graph.size([weight])</code></a></td><td>Returns the number of edges or total of all edge weights.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.number_of_edges.html#networkx.Graph.number_of_edges" target="_blank" rel="noopener"><code>Graph.number_of_edges([u, v])</code></a></td><td>Returns the number of edges between two nodes.</td></tr></tbody></table><h2 id="making-copies-and-subgraphs">Making copies and subgraphs</h2><table><colgroup><col style="width: 23%"><col style="width: 76%"></colgroup><thead><tr class="header"><th>Method</th><th>Description</th></tr></thead><tbody><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.copy.html#networkx.Graph.copy" target="_blank" rel="noopener"><code>Graph.copy([as_view])</code></a></td><td>Returns a copy of the graph.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.to_undirected.html#networkx.Graph.to_undirected" target="_blank" rel="noopener"><code>Graph.to_undirected([as_view])</code></a></td><td>Returns an undirected copy of the graph.</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.to_directed.html#networkx.Graph.to_directed" target="_blank" rel="noopener"><code>Graph.to_directed([as_view])</code></a></td><td>Returns a directed representation of the graph.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.subgraph.html#networkx.Graph.subgraph" target="_blank" rel="noopener"><code>Graph.subgraph(nodes)</code></a></td><td>Returns a SubGraph view of the subgraph induced on nodes.</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.edge_subgraph.html#networkx.Graph.edge_subgraph" target="_blank" rel="noopener"><code>Graph.edge_subgraph(edges)</code></a></td><td>Returns the subgraph induced by the specified edges.</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> networkx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广度优先搜索和深度优先搜索</title>
      <link href="/notes/introduction-to-algorithms/breadth-first-search-and-depth-first-search/"/>
      <url>/notes/introduction-to-algorithms/breadth-first-search-and-depth-first-search/</url>
      
        <content type="html"><![CDATA[<h1 id="广度优先搜索">广度优先搜索</h1><p>广度优先搜索是最简单的图搜索算法之一，也是许多重要算法的原型。<strong>Prim的最小生成树算法和Dijkstra的单源最短路径算法都使用了类似广度优先搜索的思想</strong>。</p><p>给定图G=(V,E)和一个可以识别的源结点s，广度优先搜索对图G中的边进行系统性的探索来发现<strong>可以从源结点s到达的所有结点</strong>。该算法能够计算从源结点s到每个可到达的结点的距离（最少的边数），同时生成一棵“广度优先搜索树”。该树以源结点s为根节点，包含所有可以从s到达的结点。对于每个从源结点s可以到达的结点v，在广度优先搜索树里从结点s到结点v的简单路径所对应的就是图G中从结点s到结点v的“最短路径”，即包含最少边数的路径。该算法既可以用于有向图，也可以用于无向图。</p><p>广度优先搜索之所以如此得名是因为该算法始终是将已发现结点和未发现结点之间的边界，沿其广度方向向外扩展。也就是说，<strong>算法需要在发现所有距离源结点s为k的所有结点之后，才会发现距离源结点s为k+1的其他结点</strong>。</p><h2 id="算法">算法</h2><p>为了跟踪算法的进展，广度优先搜索在概念上将每个结点涂上白色、灰色或黑色。所有结点在一开始的时候涂上白色。在算法推进过程中，这些结点可能会变成灰色或黑色（灰色或黑色结点不会变回白色）。在搜索过程中，第一次遇到一个结点就称该结点被“<strong>发现</strong>”，此时该结点的颜色将发生改变。因此，凡是灰色和黑色的结点都是已被发现的结点。</p><a id="more"></a><p>如果边<span class="math inline">\((u,v)\in{E}\)</span>且结点u是黑色，则结点v既可能是灰色也可能是黑色。也就是说，所有与黑色结点邻接的结点都已经被发现。对于灰色结点来说，其邻接结点中可能存在未被发现的白色结点。灰色结点所代表的就是已知和未知两个集合之间的边界。</p><p>在执行广度优先搜索的过程中将构造出一棵广度优先树。一开始，该树仅含有根节点，就是源结点s。在扫描已发现结点u的邻接链表时，每当发现一个白色结点v，就将结点v和边(u,v)同时加入该棵树中。在广度优先树中，称结点u是结点v的<strong>前驱</strong>或者<strong>父结点</strong>。由于每个结点最多被发现一次，它最多只有一个父结点。广度优先树中的祖先和后代关系皆以相对于根节点s的位置来定义：如果结点u是从根节点s到结点v的简单路径上的一个结点，则结点u是结点v的祖先，结点v是结点u的后代。</p><p>在下面给出的 广度优先搜索过程BFS中，假定输入图G=(V,E)是以邻接链表所表示的。该算法为图中每个结点赋予了一些额外的属性：</p><ul><li>u.color：每个结点u的颜色。</li><li>u.pi：u的前驱结点，如果u没有前驱结点，则u.pi=NIL。</li><li>u.d：BFS算法所计算出的从源结点s到结点u之间的距离。</li></ul><p>该算法使用一个先进先出的队列Q来管理灰色结点集。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BFS(G, s):</span><br><span class="line">    <span class="keyword">for</span> each vertex u <span class="keyword">in</span> G.V-&#123;s&#125;:  <span class="comment"># 初始化</span></span><br><span class="line">        u.color = WHITE</span><br><span class="line">        u.d = infinity</span><br><span class="line">        u.pi = NIL</span><br><span class="line">    s.color = GRAY</span><br><span class="line">    s.d = <span class="number">0</span></span><br><span class="line">    s.pi = NIL</span><br><span class="line">    Q = &#123;&#125;</span><br><span class="line">    ENQUEUE(Q, s)</span><br><span class="line">    <span class="keyword">while</span> Q <span class="keyword">is</span> <span class="keyword">not</span> empty:</span><br><span class="line">        u = DEQUEUE(Q)</span><br><span class="line">        <span class="keyword">for</span> each v <span class="keyword">in</span> G.Adj[u]:</span><br><span class="line">            <span class="keyword">if</span> v.color == WHITE:</span><br><span class="line">                v.color = GRAY</span><br><span class="line">                v.d = u.d + <span class="number">1</span></span><br><span class="line">                v.pi = u</span><br><span class="line">                ENQUEUE(Q, v)</span><br><span class="line">        u.color = BLACK</span><br></pre></td></tr></table></figure><p>下图描述的是BFS在一个样本图上的推进过程。</p><p><img src="/uploads/image/introduction-to-algorithms/operation-of-BFS-on-an-undirected-graph.png" title="BFS在一个无向图上的推进过程"></p><h2 id="分析">分析</h2><p>每个结点的入队（当它是白色时）次数最多为一次，因而出队最多一次。入队和出队的时间均为O(1)，因此，对队列进行操作的总时间为O(V)。因为算法只在一个结点出队的时候才对该结点的邻接链表进行扫描，所以每个邻接链表最多只扫描一次。由于所有邻接链表的长度之和是<span class="math inline">\(\Theta(E)\)</span>，用于扫描邻接链表的总时间为O(E)。初始化操作的成本是O(V)，因此<strong>广度优先搜索的总运行时间为</strong>O(V+E)。因此，广度优先搜索的运行时间是图G的邻接链表大小的一个线性函数。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> networkx <span class="keyword">import</span> Graph</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_f</span><span class="params">(graph)</span>:</span></span><br><span class="line">    fmt = <span class="string">'&#123;0:&lt;10s&#125; &#123;1:&lt;10s&#125; &#123;2:&lt;10s&#125;\n'</span></span><br><span class="line">    title = fmt.format(<span class="string">'vertex'</span>, <span class="string">'distance'</span>, <span class="string">'previous'</span>)</span><br><span class="line">    data = <span class="string">''</span>.join(fmt.format(str(k), str(attr[<span class="string">'distance'</span>]), str(attr[<span class="string">'previous'</span>])) <span class="keyword">for</span> k, attr <span class="keyword">in</span> graph.nodes.items())</span><br><span class="line">    print(title + data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">breadth_first_search</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> attr <span class="keyword">in</span> graph.nodes.values():</span><br><span class="line">        attr[<span class="string">'visited'</span>], attr[<span class="string">'distance'</span>], attr[<span class="string">'previous'</span>] = <span class="literal">False</span>, float(<span class="string">'inf'</span>), <span class="literal">None</span></span><br><span class="line">    graph.nodes[s][<span class="string">'visited'</span>], graph.nodes[s][<span class="string">'distance'</span>], q = <span class="literal">True</span>, <span class="number">0</span>, Queue()</span><br><span class="line">    q.put(s)</span><br><span class="line">    <span class="keyword">while</span> q.empty() <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">        u = q.get()</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> graph[u].keys():</span><br><span class="line">            v_attr, u_attr = graph.nodes[v], graph.nodes[u]</span><br><span class="line">            <span class="keyword">if</span> v_attr[<span class="string">'visited'</span>] <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">                v_attr[<span class="string">'visited'</span>], v_attr[<span class="string">'distance'</span>], v_attr[<span class="string">'previous'</span>] = <span class="literal">True</span>, u_attr[<span class="string">'distance'</span>] + <span class="number">1</span>, u</span><br><span class="line">                q.put(v)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    g = Graph()</span><br><span class="line">    g.add_nodes_from(<span class="string">'rstuvwxy'</span>)</span><br><span class="line">    g.add_edges_from(</span><br><span class="line">        [(<span class="string">'r'</span>, <span class="string">'v'</span>), (<span class="string">'r'</span>, <span class="string">'s'</span>), (<span class="string">'s'</span>, <span class="string">'w'</span>), (<span class="string">'w'</span>, <span class="string">'t'</span>), (<span class="string">'w'</span>, <span class="string">'x'</span>), (<span class="string">'t'</span>, <span class="string">'x'</span>), (<span class="string">'t'</span>, <span class="string">'u'</span>), (<span class="string">'u'</span>, <span class="string">'x'</span>), (<span class="string">'u'</span>, <span class="string">'y'</span>),</span><br><span class="line">         (<span class="string">'x'</span>, <span class="string">'y'</span>)])</span><br><span class="line">    breadth_first_search(g, <span class="string">'s'</span>)</span><br><span class="line">    print_f(g)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vertex     distance   previous  </span><br><span class="line">r          1          s</span><br><span class="line">s          0          None</span><br><span class="line">t          2          w</span><br><span class="line">u          3          t</span><br><span class="line">v          2          r</span><br><span class="line">w          1          s</span><br><span class="line">x          2          w</span><br><span class="line">y          3          x</span><br></pre></td></tr></table></figure><h1 id="深度优先搜索">深度优先搜索</h1><p>深度优先搜索总是对最近才发现的结点v的出发边进行搜索，直到该结点的所有出发边都被发现为止。一旦结点v的所有出发边都被发现，搜索则“回溯”到v的前驱结点，来搜索该前驱结点的出发边。该过程一直持续到从源结点可以达到的所有结点都被发现为止。如果还存在尚未发现的结点，则深度优先搜索将从这些未被发现的结点中任选一个作为新的源结点，并重复同样的搜索过程。该算法重复整个过程，直到图中的所有结点都被发现为止。</p><p>与广度优先搜索不同的是，广度优先搜索的前驱子图形成一棵树，而深度优先搜索的前驱子图可能由多棵树组成，因为搜索可能从多个源结点重复进行。深度优先搜索的前驱子图形成一个由多棵<strong>深度优先树</strong>构成的<strong>深度优先森林</strong>。</p><h2 id="算法-1">算法</h2><p>像广度优先搜索算法一样，深度优先搜索算法在搜索过程中也是对结点进行涂色来指明结点的状态。每个结点的初始颜色都是白色，在结点被<strong>发现</strong>后变为灰色，在其邻接链表被扫描完成后变为黑色。该方法可以保证每个结点仅在一棵深度优先树中出现，因此，所有的深度优先树是不相交的（disjoint）。</p><p>深度优先搜索算法还在每个结点盖上一个<strong>时间戳</strong>。每个结点v有两个时间戳：第一个时间戳v.d记录结点v第一次被发现的时间（涂上灰色的时候），第二个时间戳v.f记录的是搜索完成对v的邻接链表扫描的时间（涂上黑色的时候）。这些时间戳提供了图结构的重要信息，通常能够帮助推断深度优先算法的行为。</p><p>因为|V|个结点中每个结点只能有一个发现事件和一个完成事件，所以这些时间戳都是处于1和2|V|之间的整数。很显然，对于每个结点u，我们有：u.d &lt; u.f。结点u在时刻u.d之前为白色，在时刻u.d和u.f之间为灰色，在时刻u.f之后为黑色。</p><p>下面的伪代码给出的是基本的深度优先搜索算法。输入图G既可以是无向图，也可以是有向图。变量time是一个全局变量，用来计算时间戳。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DFS(G):</span><br><span class="line">    <span class="keyword">for</span> each vertex u <span class="keyword">in</span> G.V:  <span class="comment"># 初始化</span></span><br><span class="line">        u.color = WHITE</span><br><span class="line">        u.pi = NIL</span><br><span class="line">    time = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> each vertex u <span class="keyword">in</span> G.V:</span><br><span class="line">        <span class="keyword">if</span> u.color == WHITE:</span><br><span class="line">            DFS-VISIT(G, u)  <span class="comment"># 以u为源结点进行深度优先探索</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DFS-VISIT(G, u):</span><br><span class="line">    time = time + <span class="number">1</span></span><br><span class="line">    u.d = time</span><br><span class="line">    u.color = GRAY            <span class="comment"># 发现</span></span><br><span class="line">    <span class="keyword">for</span> each v <span class="keyword">in</span> G.Adj[u]:   <span class="comment"># 探索u的邻接结点</span></span><br><span class="line">        <span class="keyword">if</span> v.color == WHITE:  <span class="comment"># 若发现新的未探索结点</span></span><br><span class="line">            v.pi = u</span><br><span class="line">            DFS-VISIT(G, v)   <span class="comment"># 优先递归探索新的结点v</span></span><br><span class="line">            <span class="comment"># 探索完v后，循环继续进行，探索u的下一个邻接结点</span></span><br><span class="line">    u.color = BLACK</span><br><span class="line">    time = time + <span class="number">1</span></span><br><span class="line">    u.f = time                <span class="comment"># 探索完成</span></span><br></pre></td></tr></table></figure><p>注意，深度优先算法的结果可能依赖于算法DFS中第6行对结点进行检查的次序和算法DFS-VISIT中的第5行对一个结点的邻接结点进行访问的次序。不过，这些不同的访问次序在实际中并不会导致问题，因为我们通常可以对任意的深度优先搜索结果加以有效利用，并获得等价的结果。</p><p>下图展示算法DFS在有向图上的运行过程。结点中的时间戳表明该结点的发现时间和完成时间。</p><p><img src="/uploads/image/introduction-to-algorithms/progress-of-the-depth-first-search-algorithm-DFS-on-a-directed-graph.png"></p><h2 id="分析-1">分析</h2><p>如果排除调用DFS-VISIT的时间，DFS中两个循环所需的时间均为<span class="math inline">\(\Theta(V)\)</span>。对每个结点<span class="math inline">\(v\in{V}\)</span>来说，DFS-VISIT被调用的次数刚好为1次，这是因为在对一个结点u调用DFS-VISIT时，该结点u必须是白色，而DFS-VISIT所做的第一件事情就是将结点u涂上灰色。在执行DFS-VISIT(G, v)的过程中，5~8行的循环所执行的次数为|Adj[v]|。由于<span class="math inline">\(\sum_{v\in{V}}|Adj[v]|=\Theta(E)\)</span>，执行循环操作的总成本是<span class="math inline">\(\Theta(E)\)</span>。因此，深度优先搜索算法的运行时间为<span class="math inline">\(\Theta(V+E)\)</span>。</p><h2 id="代码-1">代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> networkx <span class="keyword">import</span> Graph, DiGraph</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_f</span><span class="params">(g)</span>:</span></span><br><span class="line">    fmt = <span class="string">'&#123;0:&lt;10s&#125; &#123;1:&lt;10s&#125; &#123;2:&lt;10s&#125;\n'</span></span><br><span class="line">    title = fmt.format(<span class="string">'vertex'</span>, <span class="string">'distance'</span>, <span class="string">'previous'</span>)</span><br><span class="line">    data = <span class="string">''</span>.join(fmt.format(str(k), str(attr[<span class="string">'distance'</span>]), str(attr[<span class="string">'previous'</span>])) <span class="keyword">for</span> k, attr <span class="keyword">in</span> g.nodes.items())</span><br><span class="line">    print(title + data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">depth_first_search</span><span class="params">(g)</span>:</span>  <span class="comment"># 函数入口</span></span><br><span class="line">    <span class="keyword">for</span> attr <span class="keyword">in</span> g.nodes.values():  <span class="comment"># 初始化</span></span><br><span class="line">        attr[<span class="string">'visited'</span>], attr[<span class="string">'previous'</span>] = <span class="literal">False</span>, <span class="literal">None</span></span><br><span class="line">    g.graph[<span class="string">'time'</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> u, attr <span class="keyword">in</span> g.nodes.items():  <span class="comment"># 递归搜索无法访问到非连通的部分，通过此处循环解决</span></span><br><span class="line">        <span class="keyword">if</span> attr[<span class="string">'visited'</span>] <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">            dfs_visit(g, u)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs_visit</span><span class="params">(g, u)</span>:</span>  <span class="comment"># 递归方法主体</span></span><br><span class="line">    g.graph[<span class="string">'time'</span>] += <span class="number">1</span></span><br><span class="line">    g.nodes[u][<span class="string">'distance'</span>], g.nodes[u][<span class="string">'visited'</span>] = g.graph[<span class="string">'time'</span>], <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> g[u].keys():</span><br><span class="line">        <span class="keyword">if</span> g.nodes[v][<span class="string">'visited'</span>] <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">            g.nodes[v][<span class="string">'previous'</span>] = u</span><br><span class="line">            dfs_visit(g, v)  <span class="comment"># 递归</span></span><br><span class="line">    g.nodes[u][<span class="string">'visited'</span>] = <span class="literal">True</span></span><br><span class="line">    g.graph[<span class="string">'time'</span>] += <span class="number">1</span></span><br><span class="line">    g.nodes[u][<span class="string">'distance'</span>] = str(g.nodes[u][<span class="string">'distance'</span>]) + <span class="string">'/'</span> + str(g.graph[<span class="string">'time'</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    h = DiGraph()</span><br><span class="line">    h.add_nodes_from(<span class="string">'uvwxyz'</span>)</span><br><span class="line">    h.add_edges_from([(<span class="string">'u'</span>, <span class="string">'v'</span>), (<span class="string">'u'</span>, <span class="string">'x'</span>), (<span class="string">'x'</span>, <span class="string">'v'</span>), (<span class="string">'v'</span>, <span class="string">'y'</span>), (<span class="string">'y'</span>, <span class="string">'x'</span>), (<span class="string">'w'</span>, <span class="string">'y'</span>), (<span class="string">'w'</span>, <span class="string">'z'</span>), (<span class="string">'z'</span>, <span class="string">'z'</span>)])</span><br><span class="line">    depth_first_search(h)</span><br><span class="line">    print_f(h)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vertex     distance   previous  </span><br><span class="line">u          1/8        None</span><br><span class="line">v          2/7        u</span><br><span class="line">w          9/12       None</span><br><span class="line">x          4/5        y</span><br><span class="line">y          3/6        v</span><br><span class="line">z          10/11      w</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Algorithms </tag>
            
            <tag> algorithms </tag>
            
            <tag> recursion </tag>
            
            <tag> stack </tag>
            
            <tag> queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的表示</title>
      <link href="/notes/introduction-to-algorithms/representations-of-graphs/"/>
      <url>/notes/introduction-to-algorithms/representations-of-graphs/</url>
      
        <content type="html"><![CDATA[<h1 id="图的表示">图的表示</h1><p>对于图G=(V,E)，可以用两种标准表示方法表示。两种表示方法都既可以表示无向图，也可以表示有向图。</p><ul><li><p><strong>邻接链表表示</strong>：将图作为邻接链表的组合。</p><p>在表示<strong>稀疏图</strong>（边的条数|E|远远小于<span class="math inline">\(|V|^2\)</span>的图）时非常紧凑而成为通常的选择。</p></li><li><p><strong>邻接矩阵表示</strong>：将图作为邻接矩阵来看待。</p><p>在<strong>稠密图</strong>（|E|接近<span class="math inline">\(|V|^2\)</span>的图）的情况下，倾向于使用邻接矩阵表示法。另外，如果需要快速判断任意两个结点之间是否有边相连，可能也需要使用邻接矩阵表示法。</p></li></ul><p><img src="/uploads/image/introduction-to-algorithms/two-representations-of-an-undirected-graph.png" title="无向图的表示方法"></p><p><img src="/uploads/image/introduction-to-algorithms/two-representations-of-a-directed-graph.png" title="有向图的表示方法"></p><a id="more"></a><h1 id="邻接链表表示">邻接链表表示</h1><p>如上图(b)所示：对于图G=(V,E)来说，其<strong>邻接链表表示</strong>由一个包含|V|条链表的数组Adj所构成，每个结点有一条链表。对于每个结点<span class="math inline">\(u\in{V}\)</span>，邻接链表Adj[u]包含所有与结点u之间有边相邻的结点v，即Adj[u]包含图G中所有与u邻接的结点（也可以说，该链表里包含指向这些结点的指针）。</p><p>如果G是一个有向图，则对于边(u,v)来说，结点v将出现在链表Adj[u]里，因此，所有邻接链表的长度之和等于|E|。如果G是一个无向图，则对于边(u,v)来说，结点v将出现在链表Adj[u]里，结点u将出现在链表Adj[v]里，因此，所有邻接链表的长度之和为2|E|。但不管是有向图还是无向图，邻接链表表示法的存储空间需求均为<span class="math inline">\(\Theta(V+E)\)</span>。</p><p>对邻接链表稍加修改，即可以用来表示<strong>权重图</strong>，权重图是图中的每条边都带有一个相关的权重的图。可以直接将边<span class="math inline">\((u,v)\in{E}\)</span>的权重值w(u,v)存放在结点u的邻接链表里。从这种意义上说，邻接链表表示法的鲁棒性很高，可以通过对其进行简单修改来支持许多其他的图变种。</p><p>邻接链表的一个潜在缺陷是无法快速判断一条边(u,v)是否是图中的一条边，唯一的办法是在邻接链表Adj[u]里面搜索结点v。邻接矩阵表示则克服了这个缺陷，但付出的代价是更大的存储空间消耗。</p><h1 id="邻接矩阵表示">邻接矩阵表示</h1><p>对于<strong>邻接矩阵表示</strong>来说，通常会将图G中的结点编为<code>1,2,...,|V|</code>，这种编号可以是任意的。在进行此种编号之后，图G的邻接矩阵表示由一个<span class="math inline">\(|V|\times|V|\)</span>的矩阵<span class="math inline">\(A=(a_{ij})\)</span>予以表示，该矩阵满足下述条件： <span class="math display">\[a_{ij}=\begin{cases}1\quad\text{if }(i,j)\in{E}\\0\quad\text{otherwise}\end{cases}\]</span> 图(c)给出的是图(a)的邻接矩阵表示。不管一个图中由多少条边，邻接矩阵的空间需求皆为<span class="math inline">\(\Theta(V^2)\)</span>。</p><p>无向图的邻接矩阵是一个对称矩阵。由于在无向图中，边(u,v)和边(v,u)是同一条边，无向图的邻接矩阵A就是自己的转置，即<span class="math inline">\(A=A^T\)</span>。在某些应用中，可能只需要存放对角线及其以上的这部分邻接矩阵（即半个矩阵），从而将图存储空间需要减少几乎一半。</p><p>与邻接链表表示法一样，邻接矩阵也可以用来表示权重图。例如，如果G=(V,E)为一个权重图，则直接将边<span class="math inline">\((u,v)\in{E}\)</span>的权重w(u,v)存放在邻接矩阵中的第u行第v列记录上。对于不存在的边，则在相应的行列记录上存放值NIL。不过，对于许多问题来说，用0或<span class="math inline">\(\infty\)</span>来表示一条不存在的边可能更为便捷。</p><p>邻接矩阵表示法更为简单，因此在图规模比较小时，可能更倾向于使用邻接矩阵表示法。</p><p>而且，对于无向图来说，邻接矩阵还有一个优势：每个纪录项只需要1位空间。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graph </tag>
            
            <tag> Introduction to Algorithms </tag>
            
            <tag> adjacent list </tag>
            
            <tag> adjacent matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小费用流问题</title>
      <link href="/notes/minimum-cost-flow-problems/"/>
      <url>/notes/minimum-cost-flow-problems/</url>
      
        <content type="html"><![CDATA[<h1 id="最小费用流问题">最小费用流问题</h1><p>最小费用流问题（MCFP）试图在一个流网络中寻找发送指定流量的最便宜的可行方案。一个典型的应用是寻找工厂到仓库之间的最佳配送路径，每段路线都有相应的容量和费用。</p><p><strong>定义</strong></p><p>有向图G=(V,E)定义的流网络中，源结点为<span class="math inline">\(s\in{V}\)</span>，汇点为t，每条边<span class="math inline">\((u,v)\in{E}\)</span>有容量c(u,v)&gt;0，流<span class="math inline">\(f(u,v)\ge0\)</span>和代价a(u,v)（代价可以为负）。沿某条边(u,v)发送流量的代价为f(u,v)*a(u,v)。问题要求从源结点s发送指定大小的流量d到汇点t。最小费用流问题试图最小化所有边的总代价：<span class="math inline">\(\sum_{(u,v)\in{E}}a(u,v)*f(u,v)\)</span></p><p>满足以下约束条件：</p><ul><li>容量限制：对于所有的结点<span class="math inline">\(u,v\in{V}\)</span>，要求<span class="math inline">\(0\le{f(u,v)}\le{c(u,v)}\)</span>。</li><li>流量守恒：对于所有的结点<span class="math inline">\(u\in{V-\lbrace{s,t}\rbrace}\)</span>，要求<span class="math inline">\(\sum_{v\in{V}}f(v,u)=\sum_{v\in{V}}f(u，v)\)</span>。</li><li>流量要求：<span class="math inline">\(\sum_{v\in{V}}f(s,v)=d\quad\text{and}\quad\sum_{v\in{V}}f(v,t)=d\)</span>。</li></ul><h1 id="负权环路消除法">负权环路消除法</h1><p>负权环路是指有向图G=(V,E)中的环路且构成环路的所有边的权重之和为负数值。</p><a id="more"></a><h2 id="残存网络">残存网络</h2><p>假定由一个流网络G=(V,E)，其源结点为s，汇点为t。设f为图G中的一个流，考虑结点对<span class="math inline">\(u,v\in{V}\)</span>，定义残存容量<span class="math inline">\(c_f(u,v)\)</span>如下： <span class="math display">\[c_f(u,v)=\begin{cases}c(u,v)-f(u,v)&amp;\text{if }(u,v)\in{E}\\f(v,u)&amp;\text{if }(v,u)\in{E}\\0&amp;otherwise\end{cases}\]</span> 定义残存网络代价<span class="math inline">\(a_f(u,v)\)</span>如下： <span class="math display">\[a_f(u,v)=\begin{cases}a(u,v)&amp;\text{if }(u,v)\in{E}\\-a(u,v)&amp;\text{if }(v,u)\in{E}\\0&amp;otherwise\end{cases}\]</span> 负权环路消除法的核心思想是在残存网络中寻找从源结点s可达的负权环路，然后沿环路发送流量。直到残存网路中不存在从源结点s可达的负权环路为止。算法的步骤如下：</p><ol type="1"><li>设G=(V,E)为一个流网络，求出值为d的一个流。通过修改最大流的Ford-Fulkerson算法，可以求出值为d的一个流。</li><li>在残存网络中寻找从源结点s可达的负权环路。单源最短路径算法的Bellman-Ford算法可以检测图G=(V,E)中是否含有负权环路，通过修改Bellman-Ford算法可以求出该环路。</li><li>若存在，沿环路发送流量，返回步骤2。若不存在，则当前网络中的流为最佳方案。</li></ol><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> graph.max_flow <span class="keyword">import</span> find_path</span><br><span class="line"><span class="keyword">from</span> graph.bellman_ford <span class="keyword">import</span> initialize_single_source, relax</span><br><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_f</span><span class="params">(graph)</span>:</span></span><br><span class="line">    print(<span class="string">'min cost:'</span>, graph.graph[<span class="string">'min_cost'</span>])</span><br><span class="line">    fmt = <span class="string">'&#123;0:&lt;4s&#125; &#123;1:&lt;4s&#125; &#123;2:&lt;4s&#125; &#123;3:&lt;4s&#125; &#123;4:&lt;8s&#125;\n'</span></span><br><span class="line">    title = fmt.format(<span class="string">'u'</span>, <span class="string">'v'</span>, <span class="string">'flow'</span>, <span class="string">'cost'</span>, <span class="string">'capacity'</span>)</span><br><span class="line">    data = <span class="string">''</span>.join(</span><br><span class="line">        fmt.format(str(u), str(v), str(attr[<span class="string">'flow'</span>]), str(attr[<span class="string">'cost'</span>]), str(attr[<span class="string">'capacity'</span>]))</span><br><span class="line">        <span class="keyword">for</span> u, v, attr <span class="keyword">in</span> graph.edges(data=<span class="literal">True</span>) <span class="keyword">if</span> attr[<span class="string">'flow'</span>] &gt; <span class="number">0</span>)</span><br><span class="line">    print(title + data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flow</span><span class="params">(graph, s, t, f)</span>:</span></span><br><span class="line">    <span class="string">"""求出任意一个值为f的流"""</span></span><br><span class="line">    p = find_path(graph, s, t, set())</span><br><span class="line">    <span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        residual = [graph[u][v][<span class="string">'capacity'</span>] - graph[u][v][<span class="string">'flow'</span>] <span class="keyword">for</span> u, v <span class="keyword">in</span> p]</span><br><span class="line">        augment_flow = min(min(residual), f)</span><br><span class="line">        <span class="keyword">for</span> u, v <span class="keyword">in</span> p:</span><br><span class="line">            graph[u][v][<span class="string">'flow'</span>] += augment_flow</span><br><span class="line">            graph[v][u][<span class="string">'flow'</span>] -= augment_flow</span><br><span class="line">        f -= augment_flow</span><br><span class="line">        <span class="keyword">if</span> f == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        p = find_path(graph, s, t, set())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bellman_ford</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    initialize_single_source(graph, s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(graph.number_of_nodes() - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> u, v, e_attr <span class="keyword">in</span> graph.edges(data=<span class="literal">True</span>):</span><br><span class="line">            <span class="keyword">if</span> e_attr[<span class="string">'capacity'</span>] - e_attr[<span class="string">'flow'</span>] &gt; <span class="number">0</span>:  <span class="comment"># 只有此值大于0的边存在于残存网络中</span></span><br><span class="line">                relax(graph, u, v, e_attr[<span class="string">'cost'</span>])</span><br><span class="line">    <span class="keyword">for</span> u, v, e_attr <span class="keyword">in</span> graph.edges(data=<span class="literal">True</span>):</span><br><span class="line">        residual = e_attr[<span class="string">'capacity'</span>] - e_attr[<span class="string">'flow'</span>]</span><br><span class="line">        <span class="keyword">if</span> residual &gt; <span class="number">0</span> <span class="keyword">and</span> graph.nodes[v][<span class="string">'distance'</span>] &gt; graph.nodes[u][<span class="string">'distance'</span>] + e_attr[<span class="string">'cost'</span>]:</span><br><span class="line">            <span class="comment"># 当存在负权环路时，返回从环路可达的一个结点</span></span><br><span class="line">            <span class="keyword">return</span> u</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_negative_cycle</span><span class="params">(graph, v, cycle)</span>:</span></span><br><span class="line">    <span class="string">"""根据previous属性找出环路"""</span></span><br><span class="line">    <span class="comment"># 先找到环路中任一结点</span></span><br><span class="line">    visit = &#123;v&#125;</span><br><span class="line">    pre = graph.nodes[v][<span class="string">'previous'</span>]  <span class="comment"># 前驱结点</span></span><br><span class="line">    <span class="keyword">while</span> pre <span class="keyword">not</span> <span class="keyword">in</span> visit:</span><br><span class="line">        visit.add(pre)</span><br><span class="line">        pre = graph.nodes[pre][<span class="string">'previous'</span>]</span><br><span class="line">    <span class="comment"># 通过previous找出环路</span></span><br><span class="line">    anchor = pre</span><br><span class="line">    end, start = pre, graph.nodes[pre][<span class="string">'previous'</span>]</span><br><span class="line">    <span class="keyword">while</span> start != anchor:</span><br><span class="line">        cycle.append((start, end))</span><br><span class="line">        end = start</span><br><span class="line">        start = graph.nodes[start][<span class="string">'previous'</span>]</span><br><span class="line">    cycle.append((start, end))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">negative_cycle_canceling</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    key = bellman_ford(graph, s)  <span class="comment"># bellman ford求最短路径的方式寻找环路</span></span><br><span class="line">    <span class="keyword">while</span> key <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        cycle = []</span><br><span class="line">        get_negative_cycle(graph, key, cycle)</span><br><span class="line">        cancel_flow = min(graph[u][v][<span class="string">'capacity'</span>] - graph[u][v][<span class="string">'flow'</span>] <span class="keyword">for</span> u, v <span class="keyword">in</span> cycle)  <span class="comment"># 修改环路上的流量</span></span><br><span class="line">        <span class="keyword">for</span> u, v <span class="keyword">in</span> cycle:</span><br><span class="line">            graph[u][v][<span class="string">'flow'</span>] += cancel_flow</span><br><span class="line">            graph[v][u][<span class="string">'flow'</span>] -= cancel_flow</span><br><span class="line">        key = bellman_ford(graph, s)  <span class="comment"># 重新寻找环路</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min_cost</span><span class="params">(graph, s, t, d)</span>:</span></span><br><span class="line">    <span class="string">"""求解流量值为d的最小费用流"""</span></span><br><span class="line">    flow(graph, s, t, d)  <span class="comment"># 先找到一个可行解，当d大于最大流量时，找到的可行解是最大流量</span></span><br><span class="line">    negative_cycle_canceling(graph, s)  <span class="comment"># 移除负权环路</span></span><br><span class="line">    graph.graph[<span class="string">'min_cost'</span>] = sum(attr[<span class="string">'flow'</span>] * attr[<span class="string">'cost'</span>] <span class="keyword">for</span> attr <span class="keyword">in</span> graph.edges.values() <span class="keyword">if</span> attr[<span class="string">'flow'</span>] &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_graph</span><span class="params">(graph, vertices, edges)</span>:</span></span><br><span class="line">    graph.add_nodes_from(vertices)</span><br><span class="line">    <span class="keyword">for</span> u, v, cap, cost <span class="keyword">in</span> edges:</span><br><span class="line">        graph.add_edges_from([(u, v, &#123;<span class="string">'capacity'</span>: cap, <span class="string">'cost'</span>: cost&#125;), (v, u, &#123;<span class="string">'capacity'</span>: <span class="number">0</span>, <span class="string">'cost'</span>: -cost&#125;)], flow=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    g = nx.DiGraph()</span><br><span class="line">    v = <span class="string">'s1234t'</span></span><br><span class="line">    e = [(<span class="string">'s'</span>, <span class="string">'1'</span>, <span class="number">10</span>, <span class="number">2</span>), (<span class="string">'s'</span>, <span class="string">'3'</span>, <span class="number">35</span>, <span class="number">4</span>), (<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="number">20</span>, <span class="number">6</span>), (<span class="string">'1'</span>, <span class="string">'3'</span>, <span class="number">10</span>, <span class="number">1</span>), (<span class="string">'2'</span>, <span class="string">'t'</span>, <span class="number">35</span>, <span class="number">2</span>),</span><br><span class="line">         (<span class="string">'3'</span>, <span class="string">'2'</span>, <span class="number">5</span>, <span class="number">6</span>), (<span class="string">'3'</span>, <span class="string">'4'</span>, <span class="number">30</span>, <span class="number">2</span>), (<span class="string">'4'</span>, <span class="string">'2'</span>, <span class="number">15</span>, <span class="number">2</span>), (<span class="string">'4'</span>, <span class="string">'t'</span>, <span class="number">10</span>, <span class="number">7</span>)]</span><br><span class="line">    initialize_graph(g, v, e)</span><br><span class="line">    min_cost(g, <span class="string">'s'</span>, <span class="string">'t'</span>, <span class="number">20</span>)</span><br><span class="line">    print_f(g)</span><br><span class="line"></span><br><span class="line">    g.clear()</span><br><span class="line">    e = [(<span class="string">'s'</span>, <span class="string">'1'</span>, <span class="number">16</span>, <span class="number">3</span>), (<span class="string">'s'</span>, <span class="string">'2'</span>, <span class="number">13</span>, <span class="number">4</span>), (<span class="string">'1'</span>, <span class="string">'3'</span>, <span class="number">12</span>, <span class="number">7</span>), (<span class="string">'2'</span>, <span class="string">'1'</span>, <span class="number">4</span>, <span class="number">3</span>), (<span class="string">'2'</span>, <span class="string">'4'</span>, <span class="number">14</span>, <span class="number">6</span>),</span><br><span class="line">         (<span class="string">'3'</span>, <span class="string">'2'</span>, <span class="number">9</span>, <span class="number">5</span>), (<span class="string">'3'</span>, <span class="string">'t'</span>, <span class="number">20</span>, <span class="number">6</span>), (<span class="string">'4'</span>, <span class="string">'3'</span>, <span class="number">7</span>, <span class="number">8</span>), (<span class="string">'4'</span>, <span class="string">'t'</span>, <span class="number">4</span>, <span class="number">9</span>)]</span><br><span class="line">    initialize_graph(g, v, e)</span><br><span class="line">    min_cost(g, <span class="string">'s'</span>, <span class="string">'t'</span>, <span class="number">19</span>)</span><br><span class="line">    print_f(g)</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">min cost: 195</span><br><span class="line">u    v    flow cost capacity</span><br><span class="line">s    1    10   2    10</span><br><span class="line">s    3    10   4    35</span><br><span class="line">1    2    5    6    20</span><br><span class="line">1    3    5    1    10</span><br><span class="line">2    t    20   2    35</span><br><span class="line">3    4    15   2    30</span><br><span class="line">4    2    15   2    15</span><br><span class="line"></span><br><span class="line">min cost: 340</span><br><span class="line">u    v    flow cost capacity</span><br><span class="line">s    1    12   3    16</span><br><span class="line">s    2    7    4    13</span><br><span class="line">1    3    12   7    12</span><br><span class="line">2    4    7    6    14</span><br><span class="line">3    t    15   6    20</span><br><span class="line">4    3    3    8    7</span><br><span class="line">4    t    4    9    4</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithms </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大子数组问题</title>
      <link href="/notes/introduction-to-algorithms/maximum-subarray-problems/"/>
      <url>/notes/introduction-to-algorithms/maximum-subarray-problems/</url>
      
        <content type="html"><![CDATA[<h1 id="最大化收益">最大化收益</h1><p>假设你知道了未来 17 天某公司的股票价格，你的目标是最大化收益。</p><ul><li>你可能认为可以“低价买进，高价卖出”——在最低价格时买进股票，之后在最高价格时卖出，这样可以最大化收益。但遗憾的是，在一段时间内，可能无法做到在最低价格时买进股票，然后在最高价格时卖出。例如，下图中，最低价在后，最高价在前。</li></ul><p><img src="/uploads/image/introduction-to-algorithms/maximum-subarray-problem-price-of-stock.png" title="未来 17 天股票价格"></p><a id="more"></a><ul><li>你还可能认为可以在最低价格时买进，或在最高价格时卖出，即可最大化收益。如果这种策略总是有效的，则确定最大化收益是非常简单的：寻找最高和最低价格，然后从最高价格开始向左寻找之前的最低价格；从最低价格开始向右寻找之后的最高价格；取两对价格中差值最大者。例如上图中，在第 7 天股票价格最低时买入，即可最大化收益。但下图给出了一个简单的反例，显示有时最大收益既不是在最低价格时买进，也不是在最高价格时卖出。</li></ul><p><img src="/uploads/image/introduction-to-algorithms/maximum-subarray-problem-a-counter-example.png" title="一个反例：最大收益既不是在最低价格时买进，也不是在最高价格时卖出"></p><p>暴力求解方法：</p><p>尝试每对可能的买进和卖出日期组合，只要卖出日期在买进日期之后即可。n 天中共有 <span class="math inline">\(\begin{pmatrix}n\\2\end{pmatrix}=\Theta(n^2)\)</span> 种日期组合。处理每对日期所花费的时间至少也是常量，因次这种方法的运行时间为 <span class="math inline">\(\Omega(n^2)\)</span>。</p><h1 id="最大子数组问题">最大子数组问题</h1><p>从一个稍微不同的角度来看待输入数据。我们的目的是寻找一段日期，使得从第一天到最后一天的股票价格净变值最大。因此，我们不再从每日价格的角度来看待输入数据，而是考察每日价格变化，第 <code>i</code> 天的价格变化定义为第i天和第 <code>i-1</code> 天的价格差。第一幅图的最后一行给出了每日价格变化。如果将这一行看作一个数组A，那么问题就转化为寻找A的<strong>和最大的非空连续子数组</strong>。这样的连续子数组为<strong>最大子数组</strong>（maximum subarray）。例如，对第一幅图中的数组，<code>A[1...16]</code> 的最大子数组为 <code>A[8...11]</code>，其和为 43。因此，可以在第 8 天开始前（第 7 天结束后）买入股票，并在第 11 天结束后卖出，获得每股收益 43。</p><p><img src="/uploads/image/introduction-to-algorithms/maximum-subarray.png" title="最大子数组"></p><p>乍一看，这种变换对问题求解并没有什么帮助。对于一段 n 天的日期，仍需要检查 <span class="math inline">\(\begin{pmatrix}n-1\\2\end{pmatrix}=\Theta(n^2)\)</span> 个子数组。计算一个子数组之和所需的时间是线性的，但当计算所有 <span class="math inline">\(\Theta(n^2)\)</span> 个子数组和时，可以重新组织计算方式，利用之前计算出的子数组和来计算当前子数组的和，使得每个子数组和的计算时间为 <span class="math inline">\(O(1)\)</span>，从而暴力求解方法所花费的时间仍为 <span class="math inline">\(\Theta(n^2)\)</span>。</p><p>接下来，寻找最大子数组问题的更高效的求解方法。在此过程中，我们通常说“一个最大子数组”而不是“最大子数组”，因为可能有多个子数组达到最大和。</p><p>只有当数组中包含负数时，最大子数组问题才有意义。如果所有数组元素都是非负的，最大子数组问题没有任何难度，因为整个数组的和肯定是最大的。</p><h1 id="使用分治策略的算法">使用分治策略的算法</h1><p>假定要寻找子数组 <code>A[low...high]</code> 的最大子数组。使用分治技术意味着要将子数组划分成两个规模尽量相等的子数组。也就是说，找到子数组的中央位置，比如 <code>mid</code>，然后考虑求解两个子数组 <code>A[low...mid]</code> 和 <code>A[mid+1...high]</code>。如下图(a)所示，<code>A[low...high]</code> 的任何连续子数组 <code>A[i...j]</code> 所处的位置必然是以下三种情况之一：</p><ul><li>完全位于子数组 <code>A[low...mid]</code> 中，因此 <span class="math inline">\(low\le{i}\le{j}\le{mid}\)</span>。</li><li>完全位于子数组 <code>A[mid+1...high]</code> 中，因此 <span class="math inline">\(mid&lt;i\le{j}\le{high}\)</span>。</li><li>跨越了中点，因此 <span class="math inline">\(low\le{i}\le{mid}&lt;j\le{high}\)</span>。</li></ul><p><img src="/uploads/image/introduction-to-algorithms/maximum-subarray-problem-possible-locations.png" title="最大子数组所处的三种位置"></p><p>我们可以递归地求解 <code>A[low...mid]</code> 和 <code>A[mid+1...high]</code> 的最大子数组，因为这两个子问题仍是最大子数组问题，只是规模更小。因此，剩下的全部工作就是寻找跨越中点的最大子数组，然后在三种情况中选取和最大者。</p><p>求出跨越中点的最大子树组并非原问题规模更小的实例，因为它加入了限制——求出的子数组必须跨越中点。如上图(b)所示，任何跨越中点的子数组都有两个子数组 <code>A[i...mid]</code> 和 <code>A[mid+1...j]</code> 组成。因此，只需找出形如 <code>A[i...mid]</code> 和 <code>A[mid+1...j]</code> 的最大子数组，然后将其合并即可。过程 <code>FIND-MAX-CROSSING-SUBARRAY</code> 接收数组A和下标 <code>low</code>、<code>mid</code> 和 <code>high</code> 为输入，返回一个下标元组划定跨越中点的最大子数组的边界，并返回最大子数组值的和。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high):  <span class="comment"># 设 high-low+1 = n</span></span><br><span class="line">    left-sum = -infinty</span><br><span class="line">    sum = <span class="number">0</span>                   <span class="comment"># 求出左半部的最大子数组</span></span><br><span class="line">    <span class="keyword">for</span> i = mid downto low:   <span class="comment"># 循环 mid-low+1 次</span></span><br><span class="line">        sum = sum + A[i]      <span class="comment"># 循环体花费常数时间</span></span><br><span class="line">        <span class="keyword">if</span> sum &gt; left-sum：</span><br><span class="line">            left-sum = sum</span><br><span class="line">            max-left = i</span><br><span class="line">    right-sum = -infinty</span><br><span class="line">    sum = <span class="number">0</span>                   <span class="comment"># 求出右半部的最大子数组</span></span><br><span class="line">    <span class="keyword">for</span> j = mid + <span class="number">1</span> to high:  <span class="comment"># 循环 high-(mid+1)+1=high-mid 次</span></span><br><span class="line">        sum = sum + A[j]      <span class="comment"># 循环体花费常数时间</span></span><br><span class="line">        <span class="keyword">if</span> sum &gt; right-sum:</span><br><span class="line">            right-sum = sum</span><br><span class="line">            max-right = j</span><br><span class="line">    <span class="keyword">return</span> (max-left, max-right, left-sum + right-sum)</span><br></pre></td></tr></table></figure><p>如果子数组 <code>A[low...high]</code> 包含 n 个元素，则两个 for 循环的总迭代次数为 n 次，每次迭代花费 <span class="math inline">\(\Theta(1)\)</span> 时间，因此调用 <code>FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)</code> 花费 <span class="math inline">\(\Theta(n)\)</span>时间。</p><p>求解最大子数组问题的分治算法的伪代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FIND-MAXIMUM-SUBARRAY(A, low, high):</span><br><span class="line">    <span class="keyword">if</span> high == low:  <span class="comment"># 只有一个元素的情况，花费常量时间</span></span><br><span class="line">        <span class="keyword">return</span> (low, high, A[low])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mid = math.floor((low+high)/<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 分解成子问题</span></span><br><span class="line">        (left-low, left-high, left-sum)    = FIND-MAXIMUM-SUBARRAY(A, low, mid)  <span class="comment"># 递归</span></span><br><span class="line">        (right-low, right-high, right-sum) = FIND-MAXIMUM-SUBARRAY(A, mid+<span class="number">1</span>, high)</span><br><span class="line">        (cross-low, cross-high, cross-sum) = FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)  <span class="comment"># 对第三种情况单独求解</span></span><br><span class="line">        <span class="comment"># 合并：三种结果中最大的子数组为原问题的解</span></span><br><span class="line">        <span class="keyword">if</span> left-sum &gt;= right-sum <span class="keyword">and</span> left-sum &gt;= cross-sum:</span><br><span class="line">            <span class="keyword">return</span> (left-low, left-high, left-sum)</span><br><span class="line">        <span class="keyword">elif</span> right-sum &gt;= left-sum <span class="keyword">and</span> right-sum &gt;= cross-sum:</span><br><span class="line">            <span class="keyword">return</span> (right-low, right-high, right-sum)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (cross-low, cross-high, cross-sum)</span><br></pre></td></tr></table></figure><p>初始调用 <code>FIND-MAXIMUM-SUBARRAY(A, 0, A.lenght-1)</code> 即可求出 <code>A[0...n-1]</code> 的最大子数组。</p><h2 id="分析">分析</h2><p>建立一个递归式来描述递归过程 <code>FIND-MAXIMUM-SUBARRAY</code> 的运行时间。对问题进行简化，假设原问题的规模为 2 的幂，这样所有子问题的规模均为整数。用 <span class="math inline">\(T(n)\)</span> 表示 <code>FIND-MAXIMUM-SUBARRAY</code> 求解 n 个元素的最大子数组的运行时间。</p><p>对于 <code>n=1</code> 的基本情况，花费常量时间，因此 <span class="math inline">\(T(1)=\Theta(1)\)</span>。</p><p>当 <code>n&gt;1</code> 时为递归情况。到达递归调用前花费 <span class="math inline">\(\Theta(1)\)</span> 时间。递归求解的子问题均为 n/2 个元素的子数组（假定原问题规模为 2 的幂，保证了 n/2 为整数），因此每个子问题求解时间为 <span class="math inline">\(T(n/2)\)</span>。调用 <code>FIND-MAX-CROSSING-SUBARRAY</code> 花费 <span class="math inline">\(\Theta(n)\)</span> 时间。合并过程花费 <span class="math inline">\(\Theta(1)\)</span> 时间。因此，对于递归情况，有 <span class="math inline">\(T(n)=\Theta(1)+2T(n/2)+\Theta(n)+\Theta(1)=2T(n/2)+\Theta(n)\)</span>。</p><p>结合两式，得到 <code>FIND-MAXIMUM-SUBARRAY</code> 运行时间 <span class="math inline">\(T(n)\)</span> 的递归式：</p><p><span class="math display">\[T(n)=\begin{cases}\Theta(1)&amp;\text{if }n=1\\2T(n/2)+Theta(n)&amp;\text{if }n&gt;1\end{cases}\]</span></p><p>此递归式与归并排序的递归式一样，其解为 <span class="math inline">\(T(n)=\Theta(n\lg{n})\)</span>。利用分治策略的求解方法渐进复杂性优于暴力求解方法。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_max_crossing_subarray</span><span class="params">(a, low, mid, high)</span>:</span></span><br><span class="line">    left_sum = right_sum = float(<span class="string">'-inf'</span>)</span><br><span class="line">    max_left = max_right = t = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(low, mid + <span class="number">1</span>)):</span><br><span class="line">        t += a[i]</span><br><span class="line">        <span class="keyword">if</span> t &gt; left_sum:</span><br><span class="line">            left_sum, max_left = t, i</span><br><span class="line">    t = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(mid + <span class="number">1</span>, high + <span class="number">1</span>):</span><br><span class="line">        t += a[i]</span><br><span class="line">        <span class="keyword">if</span> t &gt; right_sum:</span><br><span class="line">            right_sum, max_right = t, i</span><br><span class="line">    <span class="keyword">return</span> max_left, max_right, left_sum + right_sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_maximum_subarray_dac</span><span class="params">(a, low, high)</span>:</span></span><br><span class="line">    <span class="string">"""divide and conquer"""</span></span><br><span class="line">    <span class="keyword">if</span> high == low:</span><br><span class="line">        <span class="keyword">return</span> low, high, a[low]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mid = (low + high) // <span class="number">2</span></span><br><span class="line">        left_low, left_high, left_sum = find_maximum_subarray_dac(a, low, mid)</span><br><span class="line">        right_low, right_high, right_sum = find_maximum_subarray_dac(a, low + <span class="number">1</span>, high)</span><br><span class="line">        cross_low, cross_high, cross_sum = find_max_crossing_subarray(a, low, mid, high)</span><br><span class="line">        <span class="keyword">if</span> left_sum &gt;= right_sum <span class="keyword">and</span> left_sum &gt;= cross_sum:</span><br><span class="line">            <span class="keyword">return</span> left_low, left_high, left_sum</span><br><span class="line">        <span class="keyword">elif</span> right_sum &gt;= left_sum <span class="keyword">and</span> right_sum &gt;= cross_sum:</span><br><span class="line">            <span class="keyword">return</span> right_low, right_high, right_sum</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> cross_low, cross_high, cross_sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">13</span>, <span class="number">-3</span>, <span class="number">-25</span>, <span class="number">20</span>, <span class="number">-3</span>, <span class="number">-16</span>, <span class="number">-23</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">-7</span>, <span class="number">12</span>, <span class="number">-5</span>, <span class="number">-22</span>, <span class="number">15</span>, <span class="number">-4</span>, <span class="number">7</span>]</span><br><span class="line">    print(find_maximum_subarray_dac(arr, <span class="number">0</span>, len(arr) - <span class="number">1</span>))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(7, 10, 43)</span><br></pre></td></tr></table></figure><h1 id="使用动态规划的算法">使用动态规划的算法</h1><p>从数组的左边界开始，从左至右处理，记录到目前为止已经处理过的最大子数组。定义数组 <code>dp</code>，其中 <code>dp[j]</code> 代表数组<code>A[0...j]</code>中以 <code>A[j]</code> 结尾的最大子数组，则</p><ul><li><code>j = 0</code> 时，以 <code>A[j]</code> 结尾的最大子数组就是其本身。</li><li><code>j &gt; 0</code> 时，以 <code>A[j]</code> 结尾的最大子数组可能有两种情况：<ul><li>最大子数组是 <code>A[i..j]</code>，此时 <code>dp[j] = dp[j - 1] + A[j]</code></li><li>最大子数组是 <code>A[j]</code>，此时 <code>dp[j] = A[j]</code>。</li></ul></li></ul><p>即</p><p><span class="math display">\[dp[j]=\begin{cases}A[j]&amp;j=0\\max(dp[j-1],0)+A[j]&amp;j=1\dots{n-1}\end{cases}\]</span></p><h2 id="代码-1">代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kadanes</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> a:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    dp = [<span class="number">0</span>] * len(a)</span><br><span class="line">    dp[<span class="number">0</span>] = a[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(a)):</span><br><span class="line">        dp[i] = max(dp[i - <span class="number">1</span>], <span class="number">0</span>) + a[i]</span><br><span class="line">    <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: a = [13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7]</span><br><span class="line">Output: 43</span><br></pre></td></tr></table></figure><h2 id="分析-1">分析</h2><p>对一个输入规模为 <span class="math inline">\(n\)</span> 的数组，迭代次数为 <span class="math inline">\(n\)</span>，每次迭代花费 <span class="math inline">\(\Theta(1)\)</span> 时间。因此，算法的总代价为 <span class="math inline">\(n*\Theta(1)=\Theta(n)\)</span>。</p><p>算法使用了一个长度为 <span class="math inline">\(n\)</span> 的辅助数组，因此空间复杂度为 <span class="math inline">\(\Theta(n)\)</span>。</p><h2 id="降低空间复杂度">降低空间复杂度</h2><p>若只需要整个数组的最大子数组，那么可以用一个变量代替 <code>dp</code> 数组，从而降低动态规划算法的空间复杂度。该变量记录到目前为止已处理过的最大子数组中最大的值。修改后的算法代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kadanes_r1</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> a:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    curr = res = a[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(a)):</span><br><span class="line">        curr = max(curr, <span class="number">0</span>) + a[i]</span><br><span class="line">        res = max(res, curr)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>修改后的算法时间复杂度还是 <span class="math inline">\(\Theta(n)\)</span>，空间复杂度降低为 <span class="math inline">\(O(1)\)</span>。</p><h2 id="记录子数组位置">记录子数组位置</h2><p>展开 <code>max</code>，在 <code>curr</code> 和 <code>res</code> 的值发生改变的同时，更新起始或终止位置。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kadanes_r2</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> a:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    curr = res = a[<span class="number">0</span>]</span><br><span class="line">    start = end = <span class="number">0</span></span><br><span class="line">    temp = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(a)):</span><br><span class="line">        <span class="keyword">if</span> curr &lt; <span class="number">0</span>:</span><br><span class="line">            curr, temp = <span class="number">0</span>, i</span><br><span class="line">        curr += a[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> res &lt; curr:</span><br><span class="line">            res = curr             <span class="comment"># 更新最优解</span></span><br><span class="line">            start, end = temp, i   <span class="comment"># 记录起始下标</span></span><br><span class="line">    <span class="keyword">return</span> start, end, res</span><br></pre></td></tr></table></figure><p>时间复杂度为 <span class="math inline">\(\Theta(n)\)</span>，空间复杂度为 <span class="math inline">\(O(1)\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> Introduction to Algorithms </tag>
            
            <tag> algorithms </tag>
            
            <tag> divide and conquer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序统计量</title>
      <link href="/notes/introduction-to-algorithms/order-statistics/"/>
      <url>/notes/introduction-to-algorithms/order-statistics/</url>
      
        <content type="html"><![CDATA[<h1 id="顺序统计量">顺序统计量</h1><p>在一个由n个元素组成的集合中，第i个顺序统计量（order statistic）是该集合中第i小的元素。</p><p>例如，在一个元素集合中，最小值是第1个顺序统计量（i=1），最大值是第n个顺序统计量（i=n）。</p><p>将从一个由n个互异的元素构成的集合中选择第i个顺序统计量的问题形式化定义为如下的<strong>选择问题</strong>：</p><p><strong>输入</strong>： 一个包含n个（互异的）数的集合A和一个整数<span class="math inline">\(i，1\le{i}\le{n}\)</span>。</p><p><strong>输出</strong>： 元素<span class="math inline">\(x\in{A}\)</span>，且A中恰好有i-1个其他元素小于它。</p><a id="more"></a><h1 id="最大值和最小值">最大值和最小值</h1><h2 id="找到最小值或最大值">找到最小值或最大值</h2><p>在一个有n个元素的集合中，找出其最小值：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minimum</span><span class="params">(a)</span>:</span>  <span class="comment"># 与min()作用相同</span></span><br><span class="line">    <span class="keyword">if</span> len(a) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'minimum() arg is an empty sequence'</span>)</span><br><span class="line">    m = a[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(a)):  <span class="comment"># 循环n-1次，n位数组长度</span></span><br><span class="line">        m = min(m, a[i])  <span class="comment"># 元素之间比较n-1次</span></span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">18</span>, <span class="number">24</span>, <span class="number">17</span>, <span class="number">3</span>, <span class="number">21</span>, <span class="number">7</span>, <span class="number">23</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">39</span>, <span class="number">46</span>, <span class="number">26</span>, <span class="number">30</span>, <span class="number">38</span>, <span class="number">52</span>]</span><br><span class="line">    print(<span class="string">'min ='</span>, minimum(arr))</span><br></pre></td></tr></table></figure><p>需要做n-1次比较，n-1次既是其比较次数上界亦是其下界。找出最大值的方法类似。</p><p>在一个包含n个元素的集合中找出最小值（最大值）的时间是<span class="math inline">\(\Theta(n)\)</span>。</p><p>输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">min = 3</span><br></pre></td></tr></table></figure><h2 id="同时找到最小值和最大值">同时找到最小值和最大值</h2><p>可以分别独立地找出最小值和最大值，这各需要n-1次比较，共需2n-2次比较。即将每个元素与当前最小值比较一次，再与最大元素比较一次。代价是每个元素都需要2次比较。</p><p>事实上，只需要最多<span class="math inline">\(3\lfloor{n/2}\rfloor\)</span>次比较就可以同时找到最小值和最大值。</p><p>记录已知的最大值和最小值，对输入元素成对地进行处理。首先，将一对输入元素相互进行比较，然后把较小的与当前最小值比较，把较大的与当前最大值进行比较。这样，对每连个元素共需3次比较。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min_max</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(a) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'min_max() arg is an empty sequence'</span>)</span><br><span class="line">    mini = maxi = a[<span class="number">0</span>]  <span class="comment"># n为奇数时，临时变量同时指向第一个元素</span></span><br><span class="line">    i = <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> len(a) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        mini, maxi = a[<span class="number">0</span>], a[<span class="number">1</span>]  <span class="comment"># n为偶数时，先比较前两个元素确定当前最小值和最大值</span></span><br><span class="line">        <span class="keyword">if</span> mini &lt; maxi:</span><br><span class="line">            mini, maxi = maxi, mini</span><br><span class="line">        i = <span class="number">3</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(a):</span><br><span class="line">        x, y = a[i - <span class="number">1</span>], a[i]</span><br><span class="line">        <span class="keyword">if</span> a[i - <span class="number">1</span>] &gt; a[i]:</span><br><span class="line">            x, y = y, x  <span class="comment"># 先比较数组中两个元素</span></span><br><span class="line">        mini = min(mini, x)  <span class="comment"># 小的元素与当前最小值比较</span></span><br><span class="line">        maxi = max(maxi, y)  <span class="comment"># 大的元素与当前最大值比较</span></span><br><span class="line">        i += <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> mini, maxi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">18</span>, <span class="number">24</span>, <span class="number">17</span>, <span class="number">3</span>, <span class="number">21</span>, <span class="number">7</span>, <span class="number">23</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">39</span>, <span class="number">46</span>, <span class="number">26</span>, <span class="number">30</span>, <span class="number">38</span>, <span class="number">52</span>]</span><br><span class="line">    print(<span class="string">'(min, max) ='</span>, min_max(arr))</span><br></pre></td></tr></table></figure><p>分析以下总的比较次数：</p><ul><li>如果n是奇数，那么第一个元素不用比较，后n-1个元素每两个进行3次比较，总共进行<span class="math inline">\(3(n-1)/2=3\lfloor{n/2}\rfloor\)</span>次比较。</li><li>如果n是偶数，那么前两个元素比较1次，后n-2个元素每两个进行3次比较，总共进行<span class="math inline">\(1+3(n-2)/2=3n/2-2&lt;3\lfloor{n/2}\rfloor\)</span>。</li></ul><p>因此，不管是哪一种情况，总的比较次数至多是<span class="math inline">\(3\lfloor{n/2}\rfloor\)</span>。</p><p>输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(min, max) = (3, 52)</span><br></pre></td></tr></table></figure><h1 id="期望为线性时间的选择算法">期望为线性时间的选择算法</h1><p>一般选择问题看起来要比找最小值这样的简单问题更难。但令人惊奇的是，这两个问题的渐进运行时间确实相同的：<span class="math inline">\(\Theta(n)\)</span>。下面介绍一种解决选择问题的分治算法。RANDOMIZED-SELECT算法是以快速排序算法为模型的。</p><ul><li><p>与快速排序一样，将输入数组进行递归划分。</p></li><li><p>与快速排序不同的是，快速排序会递归处理划分的两边，而RANDOMIZED-SELECT只处理划分的一边。快速排序的期望运行时间是<span class="math inline">\(n\lg(n)\)</span>，而RANDOMIZED-SELECT的期望运行时间为O(n)。</p></li></ul><p>RANDOMIZED-SELECT返回数组<code>A[p...r]</code>中第i小的元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">RANDOMIZED-SELECT(A, p, r, i):</span><br><span class="line">    <span class="keyword">if</span> p == r:          <span class="comment"># 如果数组中只包括一个元素，那么此时i必然等于1</span></span><br><span class="line">        <span class="keyword">return</span> A[p]    <span class="comment"># 此时只需返回这唯一的一个元素</span></span><br><span class="line">    q = RANDOMIZED-PARTITION(A, p, r)  <span class="comment"># 随机选择主元并划分，返回主元位置。因为主元与其他元素</span></span><br><span class="line">    k = q-p+<span class="number">1</span>  <span class="comment"># 主元是第k小             # 都比较过，所以主元所在位置就是最终在已排序数组中的位置</span></span><br><span class="line">    <span class="keyword">if</span> i == k:          <span class="comment"># 检测A[q]是否是第i小元素</span></span><br><span class="line">        <span class="keyword">return</span> A[q]</span><br><span class="line">    <span class="keyword">elif</span> i &lt; k:         <span class="comment"># i&lt;k说明A[q]过大，要找的元素落在左边</span></span><br><span class="line">        <span class="keyword">return</span> RANDOMIZED-SELECT(A, p, q<span class="number">-1</span>, i)</span><br><span class="line">    <span class="keyword">else</span>:               <span class="comment"># 否则落在右边</span></span><br><span class="line">        <span class="keyword">return</span> RANDOMIZED-SELECT(A, q+<span class="number">1</span>, r, i-k)  <span class="comment"># 左边+主元一共k个元素，在右边要找第i-k小元素</span></span><br></pre></td></tr></table></figure><p>程序判断了p==r即子数组只含有1个元素的情况，那么含有0个元素的情况呢？划分操作有可能产生长度为0的子数组，那么上述递归操作会调用含有0个元素的子数组吗？答案是这种情况不会发生。考虑主元位于边界的情况：</p><ul><li>p=q：左边子数组长度为0，右边不为0。主元是第1小元素，由于i不可能小于1，若所寻目标i=1，程序结束并返回；若i&gt;1，程序将在右边的子数组中递归寻找。</li><li>p=r：与p=q是对称的。i不可能大于n（数组中元素总个数）。此时主元是第n小，若i=n，程序结束并返回；若i&lt;n，则在左边的子数组中递归寻找。</li></ul><p>因此，程序会不递归调用含有0个元素的数组。</p><h2 id="分析">分析</h2><p>RANDOMIZED-SELECT的最坏情况运行时间为<span class="math inline">\(\Theta(n^2)\)</span>，即使是找最小元素也是如此，因为在每次划分时可能极不走运地总是按余下的元素中最大的来进行划分，而划分操作需要<span class="math inline">\(\Theta(n)\)</span>时间。但因为算法是随机化的，所以不存在一个特定的会导致其最坏情况发生的输入数据。下面分析算法的期望运行时间。</p><p>设该算法在一个含有n个元素的输入数组<code>A[p...r]</code>上的运行时间是一个随机变量，记为T(n)。对每一个<span class="math inline">\(k(1\le{k}\le{n})\)</span>，子数组<code>A[p...q]</code>（全部小于或等于主元）有k个元素的概率是1/n。对所有的<code>k=1,2,...,n</code>，定义指示器变量<span class="math inline">\(X_k\)</span>为：<span class="math inline">\(X_k=I\lbrace子数组A[p...q]正好包含k个元素\rbrace\)</span>。假设元素是互异的，有<span class="math inline">\(E[X_k]=1/n\)</span>。</p><p>为了得到所需时间的上界，假定查找的第i个元素总是在划分中包含较大元素的一边。指示器随机变量<span class="math inline">\(X_k\)</span>恰好在给定的k值上取值1，对其他值都为0。当<span class="math inline">\(X_k=1\)</span>时，可能要递归处理的两个子数组大小分别为k-1和n-k。因此可以得到递归式： <span class="math display">\[\begin{aligned}T(n)&amp;\le\sum_{k=1}^nX_k\cdot\Bigl(T\bigl(max(k-1,n-k)\bigr)+O(n)\Bigr)\\&amp;=\sum_{k=1}^nX_k\cdot{T(max(k-1,n-k))}+O(n)\end{aligned}\]</span> 两边取期望值，得到 <span class="math display">\[\begin{aligned}E[T(n)]&amp;\le{E\Big[\sum_{k=1}^nX_k\cdot{T(max(k-1,n-k))}+O(n)\Bigr]}\\&amp;=\sum_{k=1}^nE\Big[X_k\cdot{T(max(k-1,n-k))}\Big]+O(n)\quad\text{(期望的线性性质)}\\&amp;=\sum_{k=1}^nE[X_k]\cdot{E[T(max(k-1,n-k))]}+O(n)\quad\text{(}X_k\text{和}T(max(k-1,n-k))\text{相互独立)}\\&amp;=\sum_{k=1}^n\frac{1}{n}\cdot{E[T(max(k-1,n-k))]}+O(n)\end{aligned}\]</span> 考虑表达式max(k-1,n-k)，有 <span class="math display">\[max(k-1,n-k)=\begin{cases}k-1\quad\text{若}k&gt;\lceil{n/2}\rceil\\n-k\quad\text{若}k\le\lceil{n/2}\rceil\end{cases}\]</span> 观察到表达式max(k-1,n-k)的取值是成对出现的：</p><ul><li>如果n是偶数，则<span class="math inline">\(k=1,2,\dots,n/2\)</span>与<span class="math inline">\(k=n,n-1,\dots,n/2+1\)</span>时的取值相等，取值分别是<span class="math inline">\(n-1,n-2,\dots,n/2\)</span>。</li><li>如果n是奇数，则<span class="math inline">\(k=1,2,\dots,\lfloor{n/2}\rfloor\)</span>与<span class="math inline">\(k=n,n-1,\dots,\lceil{n/2}\rceil+1\)</span>时的取值相等，分别是<span class="math inline">\(n-1,n-2,\dots,\lceil{n/2}\rceil\)</span>。此外<span class="math inline">\(k=\lceil{n/2}\rceil\)</span>时的取值单独出现，值是<span class="math inline">\(\lfloor{2/n}\rfloor\)</span>。</li></ul><p>因此，有 <span class="math display">\[E[T(n)]\le\frac{2}{n}\sum_{k=\lfloor{n/2}\rfloor}^{n-1}E[T(k)]+O(n)\]</span> 下面用替代法来得到E[T(n)]=O(n)。</p><p>假设对某个常数c，有<span class="math inline">\(E[T(n)]\le{cn}\)</span>。假设对小于某个常数的n，有T(n)=O(1)。同时，选择一个常数a，使得对所有n&gt;0，上式中O(n)项所描述的函数有上界an。利用这个归纳假设，可以得到： <span class="math display">\[\begin{aligned}E[T(n)]&amp;\le\frac{2}{n}\sum_{k=\lfloor{n/2}\rfloor}^{n-1}ck+an\\&amp;=\frac{2c}{n}\Big(\sum_{k=1}^{n-1}k-\sum_{k=1}^{\lfloor{n/2}\rfloor-1}k\Big)+an\\&amp;=\frac{2c}{n}\Big(\frac{(n-1)n}{2}-\frac{(\lfloor{n/2}\rfloor-1)\lfloor{n/2}\rfloor}{2}\Big)+an\\&amp;\le\frac{2c}{n}\Big(\frac{(n-1)n}{2}-\frac{(n/2-2)(n/2-1)}{2}\Big)+an\\&amp;=\frac{2c}{n}\Big(\frac{n^2-n}{2}-\frac{n^2-3n/2+2}{2}\Big)+an\\&amp;=\frac{c}{n}(\frac{3n}{4}+\frac{1}{2}-\frac{2}{n})+an\\&amp;\le\frac{3cn}{4}+\frac{c}{2}+an\\&amp;=cn-\color{red}{(\frac{cn}{4}-\frac{c}{2}-an)}\end{aligned}\]</span> 为了完成证明，还需要证明：对足够大的n，最后一个表达式至多是cn。 <span class="math display">\[\begin{aligned}\frac{cn}{4}-\frac{c}{2}-an&amp;\ge0\\n(\frac{c}{4}-a)&amp;\ge\frac{c}{2}\end{aligned}\]</span> 只要选择的常数c能够满足c/4-a&gt;0，就可以将两边同时除以c/4-a，得到 <span class="math display">\[n\ge\frac{c/2}{c/4-a}=\frac{2c}{c-4a}\]</span> 因此，如果假设对所有n&lt;2c/(c-4a)，都有T(n)=O(1)，那么就有E[T(n)]=O(n)。</p><p>结果：假设所有元素是互异的，在期望线性时间内，可以找到任一顺序统计量，特别是中位数（？）。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sort.quick_sort <span class="keyword">import</span> partition</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randomized_select</span><span class="params">(a, p, r, i)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> p == r:  <span class="comment"># 只有一个元素时，i一定等于1，i代表的是在a[p..r]中第i小</span></span><br><span class="line">        <span class="keyword">return</span> a[p]</span><br><span class="line">    q = partition(a, p, r, randint(p, r))  <span class="comment"># 随机选择主元并划分</span></span><br><span class="line">    k = q - p + <span class="number">1</span>  <span class="comment"># 主元是第k小元素</span></span><br><span class="line">    <span class="keyword">if</span> i == k:</span><br><span class="line">        <span class="keyword">return</span> a[q]</span><br><span class="line">    <span class="keyword">elif</span> i &lt; k:  <span class="comment"># 在左边继续寻找</span></span><br><span class="line">        <span class="keyword">return</span> randomized_select(a, p, q - <span class="number">1</span>, i)</span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 在右边继续寻找，注意要寻找的序号要变化</span></span><br><span class="line">        <span class="keyword">return</span> randomized_select(a, q + <span class="number">1</span>, r, i - k)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">18</span>, <span class="number">24</span>, <span class="number">17</span>, <span class="number">3</span>, <span class="number">21</span>, <span class="number">7</span>, <span class="number">23</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">39</span>, <span class="number">46</span>, <span class="number">26</span>, <span class="number">30</span>, <span class="number">38</span>, <span class="number">52</span>]</span><br><span class="line">    print([randomized_select(arr, <span class="number">0</span>, len(arr) - <span class="number">1</span>, i + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr))])</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[3, 7, 17, 18, 21, 23, 24, 26, 30, 35, 38, 39, 41, 46, 52]</span><br></pre></td></tr></table></figure><h1 id="最坏情况为线性时间的选择算法">最坏情况为线性时间的选择算法</h1><p>本节介绍一个最坏情况运行时间为<span class="math inline">\(\Theta(n)\)</span>的选择算法：SELECT算法。像RANDOMIZED-SELECT一样，SELECT算法通过对输入数组的递归划分来找出所需元素，但是，在该算法中<strong>能够保证得到对数组的一个好的划分</strong>。</p><p>SELECT算法的执行步骤如下：</p><ol type="1"><li>如果n=1，则返回唯一元素作为第i小的元素。否则将输入数组的n个元素划分为<span class="math inline">\(\lfloor{n/5}\rfloor\)</span>组，每组5个元素，剩下的一组至多由n%5个元素组成。</li><li>寻找这<span class="math inline">\(\lceil{n/5}\rceil\)</span>组中每一组的中位数：首先对每组元素进行插入排序，然后确定每组有序元素的中位数。</li><li>对第2步中找出的<span class="math inline">\(\lceil{n/5}\rceil\)</span>个中位数，递归调用SELECT以找出其中的中位数x（如果由偶数个中位数，为了方便，约定x是较小的中位数）。</li><li>按中位数的中位数x对输入数组进行划分。让k比划分的低区中的元素数目多1，因此x是第k小的元素，并且有n-k个元素在划分的高区。</li><li>如果i=k，则返回x。如果i&lt;k，则在地区递归调用SELECT来找出第i小的元素。如果i&gt;k，则在高区递归查找第i-k小的元素。</li></ol><h2 id="分析-1">分析</h2><p>首先确定大于划分主元x的元素个数的下界。下图给出了一些形象的说明。在第2步找出的中位数中，至少有一半大于或等于中位数的中位数x。因此，在这<span class="math inline">\(\lceil{n/5}\rceil\)</span>个组中， 除了当n不能被5整除时产生的所含元素少于5的那个组，和包含x的那个组之外，至少有一半的组中有3个元素大于x。不算这两个组，大于x的元素个数至少为 <span class="math display">\[3\Bigl(\big\lceil\frac{1}{2}\lceil\frac{n}{5}\rceil\big\rceil-2\Bigr)\ge\frac{3n}{10}-6\]</span> 类似地，至少有3n/10-6个元素小于x。因此，在最坏情况下，在第5步中，SELECT的递归调用最多作用于7n/10+6个元素。</p><p><img src="/uploads/image/introduction-to-algorithms/select-analysis.png" title="灰色阴影覆盖的元素全都大于x"></p><p>现在，设计一个递归式来推到SELECT算法的最坏情况运行时间T(n)。</p><p>步骤1：分组需要O(n)时间。</p><p>步骤2：对大小为O(1)（大小为5）的集合调用O(n)（<span class="math inline">\(\lceil{n/5}\rceil\)</span>次）插入排序，总时间也为O(n)。</p><p>步骤3：递归所需时间为<span class="math inline">\(T(\lceil{n/5}\rceil)\)</span>。</p><p>步骤4：partition所需时间为O(n)。</p><p>步骤5：递归所需时间至多为T(7n/10+6)。</p><p>将上述时间累加，可得到 <span class="math display">\[T(n)\le{T(\lceil{n/5}\rceil)+T(7n/10+6)+O(n)}\]</span> 下面用替换法证明这个运行时间是线性的。更明确地说，证明对某个适当大的常数c和所有的n&gt;0，有<span class="math inline">\(T(n)\le{cn}\)</span>。挑选一个常数a，使得对所有的n&gt;0，公式中的O(n)项所对应的函数有上界an。假设<span class="math inline">\(T(n)\le{cn}\)</span>成立。将假设带入上述递归式的右边，得到 <span class="math display">\[\begin{aligned}T(n)&amp;\le{c\lceil{n/5}\rceil}+c(7n/10+6)+an\\&amp;\le{cn/5+c}+7cn/10+6c+an\\&amp;=9cn/10+7c+an\\&amp;=cn+\color{red}{(-cn/10+7c+an)}\end{aligned}\]</span> 若<span class="math inline">\(-cn/10+7c+an\le0\)</span>时，则<span class="math inline">\(T(n)\le{cn}\)</span>成立。 <span class="math display">\[\begin{aligned}-cn/10+7c+an&amp;\le0\\cn/10-7c&amp;\ge{an}\\c\frac{n-70}{10}&amp;\ge{an}\end{aligned}\]</span> 观察上式可知，当n&gt;70时，<span class="math inline">\(-cn/10+7c+an\le0\)</span>，此时<span class="math inline">\(c\ge10a\color{red}{(n/(n-70))}\)</span>。 <span class="math display">\[\frac{n}{n-70}=\frac{1}{1-\frac{70}{n}}\]</span> 当n增大时，n/(n-70)减小，因此只要适当地选择c的值，使不等式<span class="math inline">\(-cn/10+7c+an\le0\)</span>成立，就能证明<span class="math inline">\(T(n)\le{cn}\)</span>。例如，n&gt;70时，<span class="math inline">\(n/(n-70)\le71\)</span>，选择常数<span class="math inline">\(c\ge710a\)</span>即可满足<span class="math inline">\(T(n)\le{cn}\)</span>。又例如，当<span class="math inline">\(n\ge140\)</span>时，<span class="math inline">\(n/(n-70)\le2\)</span>，选择常数<span class="math inline">\(c\ge20a\)</span>即可。无论如何选择n的边界x，在n&lt;x时，<span class="math inline">\(T(n)\le{cn}\)</span>成立（只需选择足够大的c即可）。因此，最坏情况下SELECT的运行时间是线性的。</p><h2 id="代码-1">代码</h2><p>不同的是：将选择中位数的中位数过程（步骤1~3）从选择算法中独立出来。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sort.quick_sort <span class="keyword">import</span> partition</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> ceil</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(a, i, j)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> i != j:</span><br><span class="line">        a[i], a[j] = a[j], a[i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span><span class="params">(a, p, r)</span>:</span>  <span class="comment"># 修改过的插入排序，对a[p..r]进行排序</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(p + <span class="number">1</span>, r + <span class="number">1</span>):</span><br><span class="line">        key = a[j]</span><br><span class="line">        i = j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= p <span class="keyword">and</span> a[i] &gt; key:</span><br><span class="line">            a[i + <span class="number">1</span>] = a[i]</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        a[i + <span class="number">1</span>] = key</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">median_of_median</span><span class="params">(a, p, r)</span>:</span></span><br><span class="line">    <span class="string">"""将数组分成每5个元素一组，找其中位数，若有多个，递归中位数组成的数组，继续寻找"""</span></span><br><span class="line">    <span class="keyword">if</span> p == r:</span><br><span class="line">        <span class="keyword">return</span> a[p]</span><br><span class="line">    <span class="comment"># 对每5个元素调用插入排序</span></span><br><span class="line">    left = p</span><br><span class="line">    <span class="keyword">while</span> left &lt;= r:</span><br><span class="line">        right = min(left + <span class="number">4</span>, r)</span><br><span class="line">        insertion_sort(a, left, right)  <span class="comment"># 对每5个数排序，剩下的一组若不足5个，有几个算几个</span></span><br><span class="line">        <span class="comment"># 交换中位数到数组前面，方便递归调用</span></span><br><span class="line">        exchange(a, p + (right - p) // <span class="number">5</span>, (right + left) // <span class="number">2</span>)</span><br><span class="line">        left += <span class="number">5</span></span><br><span class="line">    n = ceil((r - p + <span class="number">1</span>) / <span class="number">5</span>)  <span class="comment"># 所有分组的中位数的个数</span></span><br><span class="line">    <span class="keyword">return</span> median_of_median(a, p, p + n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select</span><span class="params">(a, p, r, i)</span>:</span></span><br><span class="line">    median_of_median(a, p, r)  <span class="comment"># 找出中位数的中位数，过程结束时找到的中位数位置为p</span></span><br><span class="line">    q = partition(a, p, r, p)  <span class="comment"># 以找到的中位数为pivot，划分数组</span></span><br><span class="line">    k = q - p + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i == k:</span><br><span class="line">        <span class="keyword">return</span> a[q]</span><br><span class="line">    <span class="keyword">elif</span> i &lt; k:</span><br><span class="line">        <span class="keyword">return</span> select(a, p, q - <span class="number">1</span>, i)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> select(a, q + <span class="number">1</span>, r, i - k)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">18</span>, <span class="number">24</span>, <span class="number">17</span>, <span class="number">3</span>, <span class="number">21</span>, <span class="number">7</span>, <span class="number">23</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">39</span>, <span class="number">46</span>, <span class="number">26</span>, <span class="number">30</span>, <span class="number">38</span>, <span class="number">52</span>]</span><br><span class="line">    print([select(arr, <span class="number">0</span>, len(arr) - <span class="number">1</span>, i + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr))])</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[3, 7, 17, 18, 21, 23, 24, 26, 30, 35, 38, 39, 41, 46, 52]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Algorithms </tag>
            
            <tag> algorithms </tag>
            
            <tag> divide and conquer </tag>
            
            <tag> quicksort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大流</title>
      <link href="/notes/introduction-to-algorithms/maximum-flow/"/>
      <url>/notes/introduction-to-algorithms/maximum-flow/</url>
      
        <content type="html"><![CDATA[<h1 id="流网络和流">流网络和流</h1><p><strong>流网络</strong>G=(V,E)是一个有向图，图中每条边<span class="math inline">\((u,v)\in{E}\)</span>有一个非负的<strong>容量值</strong><span class="math inline">\(c(u,v)\ge0\)</span>。而且，如果边集合E包含一条边(u,v)，则图中不存在反向边(v,u)。如果<span class="math inline">\((u,v)\notin{E}\)</span>，为方便起见，定义c(u,v)=0，并且在图中不允许自循环。</p><p>在流网络的所有结点中，特别分辨出两个特殊结点：<strong>源结点</strong>s和<strong>汇点</strong>t。为方便起点，假定每个结点都在从源结点到汇点的某条路径上。因此，流网络图是连通的，并且由于除源结点外的每个结点都至少有一条进入的边，有<span class="math inline">\(|E|\ge|V|-1\)</span>。下图描述的是一个流网络的例子。</p><p><img src="/uploads/image/introduction-to-algorithms/flow-network.png" title="一个流网络"></p><a id="more"></a><p>下面给出流的形式化定义。设G=(V,E)为一个流网络，其容量函数为c。设s为网络的源结点，t为汇点。G中的<strong>流</strong>是一个实值函数<span class="math inline">\(f:V\times{V}\rightarrow\mathbb{R}\)</span>，满足下面的两条性质：</p><ul><li>容量限制：对于所有的结点<span class="math inline">\(u,v\in{V}\)</span>，要求<span class="math inline">\(0\le{f(u,v)}\le{c(u,v)}\)</span>。</li><li>流量守恒：对于所有的结点<span class="math inline">\(u\in{V-\lbrace{s,t}\rbrace}\)</span>，要求</li></ul><p><span class="math display">\[\sum_{v\in{V}}f(v,u)=\sum_{v\in{V}}f(u，v)\]</span></p><p>当<span class="math inline">\((u,v)\notin{E}\)</span>时，从结点u到结点v之间没有流，因此f(u,v)=0。</p><p>容量限制性质说明，从一个结点到另一个结点之间的流必须为非负值且不能超过给定的容量限制。</p><p>流量守恒性质说明，流入一个结点（源结点和汇点除外）的总流量必须等于流出该节点的总流量，“流入等于流出”。</p><p>一个流f的<strong>值</strong>|f|（这里，符号| |表示流的值）定义如下： <span class="math display">\[|f|=\sum_{v\in{V}}f(s,v)-\sum_{v\in{V}}f(v,s)\tag{26.1}\]</span> 也就是说，流f的值是从源结点流出的总流量减去流入源结点的总流量。在<strong>最大流问题</strong>中，给定一个流网络G、一个源结点s、一个汇点t，希望找到值最大的一个流。</p><h1 id="反平行边多源点汇点">反平行边、多源点汇点</h1><p>上述流网络假设：如果边<span class="math inline">\((u,v)\in{E}\)</span>，则<span class="math inline">\((v,u)\notin{E}\)</span>。称(u,v)和边(v,u)为<strong>反平行</strong>（antiparallel）。如果一个流问题中包含反平行边，必须将这种网络转换为一个等价的但不包含反平行边的网络。下图描述的就是这样一个等价网络。选择两条反平行边中的一条，在这个例子中是边<span class="math inline">\((v_1,v_2)\)</span>，通过加入一个新结点<span class="math inline">\(v^\prime\)</span>来将其分且为两段，并以边<span class="math inline">\((v_1,v^\prime)\)</span>和<span class="math inline">\((v^\prime,v_2)\)</span>来替换边<span class="math inline">\((v_1,v_2)\)</span>。同时将两条新设立的边的容量设置为与原来的边的容量相同。</p><p><img src="/uploads/image/introduction-to-algorithms/flow-network-with-antiparallel-edges.png" title="带有反平行边的流网络"></p><p>一个最大流问题可能有几个源结点和几个汇点。在具有多个源结点和汇点的网络中，确定最大流的问题可以规约为一个普通的最大流问题。下图(b描述的是如何将(a)所示的网络转换为只有一个源结点和一个汇点的普通流网络。转换方法是加入一个<strong>超级源结点</strong>s，并加入有向边<span class="math inline">\((s,s_i),i=1,2,\dots,m\)</span>，其容量<span class="math inline">\(c(s,s_i)=\infty\)</span>。同时创建一个新的<strong>超级汇点</strong>t，并加入有向边<span class="math inline">\((t_i,t),i=1,2,\dots,n\)</span>，其容量<span class="math inline">\(c(t_i,t)=\infty\)</span>。</p><p><img src="/uploads/image/introduction-to-algorithms/flow-network-with-multiple-source-multiple-sink.png" title="含有多个源结点和汇点的流网络"></p><h1 id="ford-fulkerson方法">Ford-Fulkerson方法</h1><p>Ford-Fulkerson方法是解决最大流问题的一种方法。之所以称其为“方法”而不是“算法”，是因为它包含了几种运行时间各不相同的具体实现。Ford-Fulkerson方法依赖于三种重要思想，它们与许多的流算法和问题有关：残存网络、增广路径和切割。这些思想是最大流最小切割定理的精髓。</p><p>Ford-Fulkerson方法循环增加流的值。</p><ul><li>在开始的时候，对于所有的结点<span class="math inline">\(u,v\in{V}\)</span>，f(u,v)=0，给出的初始流值为0。</li><li>在每一次迭代中，将图G的流值进行增加，方法是在一个关联的“残存网络”<span class="math inline">\(G_f\)</span>中寻找一条“增广路径”。增加的是整个网络中的流量，对于图中特定的一条边来说，其流量在迭代过程中可能增加，也可能减少。对某些边的流进行缩减可能是必要的，以便让算法可以将更多的流从源结点发送到汇点。</li><li>重复对流进行上述迭代过程，直到残存网络中不再存在增广路径未知。最大流最小切割定理将说明在算法终止时，将获得一个最大流。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FORD-FULKERSON-METHOD(G, s, t):</span><br><span class="line">    initialize flow f to <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> there exists an augmenting path p <span class="keyword">in</span> the residual network:</span><br><span class="line">        augment flow f along p</span><br><span class="line">    <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure><p>为了实现和分析Ford-Fulkerson方法，需要引入几个新的概念。</p><h2 id="残存网络">残存网络</h2><p>从直观上看，给定流网络G和流量f，残存网络<span class="math inline">\(G_f\)</span>由那些仍有空间对流量进行调整的边构成。</p><ul><li>流网络的一条边可以允许的额外流量等于该边的容量减去该边上的流量。如果该差值为正，则将该条边置于图<span class="math inline">\(G_f\)</span>中，并将其残存容量设置为<span class="math inline">\(c_f(u,v)=c(u,v)-f(u,v)\)</span>。如果边(u,v)的流量等于其容量，则其<span class="math inline">\(c_f(u,v)=0\)</span>，该条边将不属于<span class="math inline">\(G_f\)</span>。</li><li>残存网络<span class="math inline">\(G_f\)</span>还可能包含图G中不存在的边。算法对流量进行操作的目标是增加总流量，为此，算法可能对某些特定边上的流量进行缩减。为了表示对一个正流量f(u,v)的缩减，将边(v,u)加入到图<span class="math inline">\(G_f\)</span>中，并将其残存容量设置为<span class="math inline">\(c_f(v,u)=f(u,v)\)</span>。也就是说，一条边所能允许的反向流量最多将其正向流量抵消。</li></ul><p>残存网络中的这些反向边允许算法将已经发送出来的流量发送回去。而将流量从同一条边发送回去等同于缩减该条边的流量，这种操作在许多算法中都是必要的。</p><p>更形式化地，假定由一个流网络G=(V,E)，其源结点为s，汇点为t。设f为图G中的一个流，考虑结点对<span class="math inline">\(u,v\in{V}\)</span>，定义残存容量<span class="math inline">\(c_f(u,v)\)</span>如下： <span class="math display">\[c_f(u,v)=\begin{cases}c(u,v)-f(u,v)&amp;\text{if }(u,v)\in{E}\\f(v,u)&amp;\text{if }(v,u)\in{E}\\0&amp;otherwise\end{cases}\tag{26.2}\]</span> 因为假定边<span class="math inline">\((u,v)\in{E}\)</span>意味着<span class="math inline">\((v,u)\notin{E}\)</span>（对流网络的假设），对于每一对边来说，上述公式中只有一种情况成立。下图中，(a)所示的流网络中流f所对应的残存网络如(b)所示。</p><p>给定一个流网络G=(V,E)和一个流f，则由f所诱导的图G的残存网络为<span class="math inline">\(G_f=(V,E_f)\)</span>，其中 <span class="math display">\[E_f=\lbrace(u,v)\in{V\times{V}}:c_f(u,v)&gt;0\rbrace\]</span> 也就是说，残存网络的每条边或<strong>残存边</strong>，必须允许大于0的流量通过。图(a)给出了流网络G和流量f，图(b)描述的是对应的残存网络<span class="math inline">\(G_f\)</span>。<span class="math inline">\(E_f\)</span>中的边要么是E中原有的边，要么是其反向边，因此有 <span class="math display">\[|E_f|\le2|E|\]</span></p><p><img src="/uploads/image/introduction-to-algorithms/maximum-flow-problem.png" title="最大流问题以及残存网络"></p><p>可以在残存网络中定义一个流，它满足流的定义，但是针对的是残存网络<span class="math inline">\(G_f\)</span>中的容量<span class="math inline">\(c_f\)</span>。残存网络中的一个流指出的是一条路线图：如何在原来的流网络中增加流。如果f是G的一个流，<span class="math inline">\(f^\prime\)</span>是对应的残存网络<span class="math inline">\(G_f\)</span>中的一个流，定义<span class="math inline">\(f\uparrow{f^\prime}\)</span>为流<span class="math inline">\(f^\prime\)</span>对流f的<strong>递增</strong>（augmentation），它是一个从<span class="math inline">\(V\times{V}\)</span>到<span class="math inline">\(\mathbb{R}\)</span>的函数，其定义如下： <span class="math display">\[(f\uparrow{f^\prime})(u,v)=\begin{cases}f(u,v)+f^\prime(u,v)-f^\prime(v,u)&amp;if (u,v)\in{E}\\0&amp;otherwise\end{cases}\tag{26.4}\]</span></p><p>该定义背后的直观解释遵循残存网络的定义。因为在残存网络中将流量发送到反向边上等同于在原来的网络中缩减流量，所以将边(u,v)的流量增加了<span class="math inline">\(f^\prime(u,v)\)</span>，但减少了<span class="math inline">\(f^\prime(v,u)\)</span>。在残存网络中将流量推送回去也称为<strong>抵消操作</strong>（cancellation）。例如，如果将5货箱的冰球从城市u发送到城市v，同时将2货箱冰球从城市v发送到城市u，那么可以等价（以最后结果来看）地将3货箱冰球从城市u发送到城市v，而不从城市v发送货箱到城市u。这类抵消操作对于任何最大流算法来说都是非常关键的。</p><blockquote><p>引理26.1</p><p>设G=(V,E)为一个流网络，源结点为s，汇点为t，设f为G中的一个流。设<span class="math inline">\(G_f\)</span>为由流f所诱导的G的残存网络，设<span class="math inline">\(f^\prime\)</span>为<span class="math inline">\(G_f\)</span>中的一个流。那么式(26.4)所定义的函数<span class="math inline">\(f\uparrow{f^\prime}\)</span>是G的一个流，其值<span class="math inline">\(|f\uparrow{f^\prime}|=|f|+|f^\prime|\)</span>。</p></blockquote><p><strong>证明</strong>：首先证明<span class="math inline">\(f\uparrow{f^\prime}\)</span>是G的一个流，即满足流的两条性质：容量限制和流量守恒。</p><p>对于容量限制，注意到，如果边<span class="math inline">\((u,v)\in{E}\)</span>，则<span class="math inline">\(c_f(v,u)=f(u,v)\)</span>。而且<span class="math inline">\(f^\prime(v,u)\le{c_f(v,u)}=f(u,v)\)</span>。因此， <span class="math display">\[\begin{aligned}(f\uparrow{f^\prime})(u,v)&amp;=f(u,v)+f^\prime(u,v)-f^\prime(v,u)&amp;\text{(by equation(26.4))}\\&amp;\ge{f(u,v)+f^\prime(u,v)}-f(u,v)&amp;\text{(because }f^\prime(v,u)\le{f(u,v)}\text{)}\\&amp;=f^\prime(u,v)\\&amp;\ge0\end{aligned}\]</span> 此外， <span class="math display">\[\begin{aligned}(f\uparrow{f^\prime})(u,v)&amp;=f(u,v)+f^\prime(u,v)-f^\prime(v,u)&amp;\text{(by equation(26.4))}\\&amp;\le{f(u,v)+f^\prime(u,v)}&amp;\text{(because flows are nonnegative}\\&amp;\le{f(u,v)+c_f(u,v)}&amp;\text{(capacity constraint)}\\&amp;=f(u,v)+c(u,v)-f(u,v)&amp;\text{(by definition (26.2))}\\&amp;=c(u,v)\end{aligned}\]</span></p><p>对于流量守恒性质，因为f和<span class="math inline">\(f^\prime\)</span>均遵守流量守恒性质，所以有<span class="math inline">\(f(u,v)=f(v,u)\)</span>和<span class="math inline">\(f^\prime(u,v)=f^\prime(v,u)\)</span>。因此，对于所有的结点<span class="math inline">\(u\in{V-\lbrace{s,t}\rbrace}\)</span>，有</p><p><span class="math display">\[\begin{aligned}\sum_{v\in{V}}(f\uparrow{f^\prime})(u,v)&amp;=\sum_{v\in{V}}(f(u,v)+f^\prime(u,v)-f^\prime(v,u))\\&amp;=\sum_{v\in{V}}f(u,v)+\sum_{v\in{V}}f^\prime(u,v)-\sum_{v\in{V}}f^\prime(v,u)\\&amp;=\sum_{v\in{V}}f(v,u)+\sum_{v\in{V}}f^\prime(v,u)-\sum_{v\in{V}}f^\prime(u,v)\\&amp;=\sum_{v\in{V}}(f(v,u)+f^\prime(v,u)-f^\prime(u,v))\\&amp;=\sum_{v\in{V}}(f\uparrow{f^\prime})(v,u)\end{aligned}\]</span></p><p>最后，计算<span class="math inline">\(f\uparrow{f^\prime}\)</span>的值。将顶点集合分<span class="math inline">\(V_1\)</span>和<span class="math inline">\(V_2\)</span>两个集合。定义<span class="math inline">\(V_1=\lbrace{v:(s,v)\in{E}}\rbrace\)</span>为有边从源结点s到达的结点集合，<span class="math inline">\(V_2=\lbrace{v:(v,s)\in{E}}\rbrace\)</span>为有边通往s的结点集合，有<span class="math inline">\(V_1\bigcup{V_2}\subseteq{V}\)</span>。并且因为不允许有反平行边，又有<span class="math inline">\(V_1\bigcap{V_2}=\varnothing\)</span>。现在来计算</p><p><span class="math display">\[\begin{aligned}|f\uparrow{f^\prime}|&amp;=\sum_{v\in{V}}(f\uparrow{f^\prime})(s,v)-\sum_{v\in{V}}(f\uparrow{f^\prime})(v,s)\\&amp;=\sum_{v\in{V_1\cup{V_2}}}(f\uparrow{f^\prime})(s,v)-\sum_{v\in{V_1\cup{V_2}}}(f\uparrow{f^\prime})(v,s)\\\end{aligned}\tag{26.5}\]</span> 回忆之间的内容，对于边<span class="math inline">\((u,v)\notin{E}\)</span>，定义f(u,v)=0，因此有<span class="math inline">\(f(s,v)=0\text{, if }{v\in{V_2}}\)</span>和<span class="math inline">\(f(v,s)=0\text{, if }{v\in{V_1}}\)</span>。现在将<span class="math inline">\(f\uparrow{f^\prime}\)</span>的定义应用到式(26.5)上，然后对和值项进行重新排序与重组可以获得： <span class="math display">\[\begin{aligned}|f\uparrow{f^\prime}|&amp;=\sum_{v\in{V_1}}(f\uparrow{f&#39;})(s,v)-\sum_{v\in{V_2}}(f\uparrow{f&#39;})(v,s)\\&amp;=\sum_{v\in{V_1}}(f(s,v)+f&#39;(s,v)-f&#39;(v,s))-\sum_{v\in{V_2}}(f(v,s)+f&#39;(v,s)-f&#39;(s,v))\\&amp;=\sum_{v\in{V_1}}f(s,v)-\sum_{v\in{V_2}}f(v,s)+\sum_{v\in{V_1}}f&#39;(s,v)+\sum_{v\in{V_2}}f&#39;(s,v)-\sum_{v\in{V_1}}f&#39;(v,s)-\sum_{v\in{V_2}}f&#39;(v,s)\\&amp;=\sum_{v\in{V_1}}f(s,v)-\sum_{v\in{V_2}}f(v,s)+\sum_{v\in{V_1\bigcup{V_2}}}f&#39;(s,v)-\sum_{v\in{V_1\bigcup{V_2}}}f&#39;(v,s)\\&amp;=\sum_{v\in{V}}f(s,v)-\sum_{v\in{V}}f(v,s)+\sum_{v\in{V}}f&#39;(s,v)-\sum_{v\in{V}}f&#39;(v,s)\\&amp;=|f|+|f&#39;|\end{aligned}\]</span></p><h2 id="增广路径">增广路径</h2><p>给定流网络G=(V,E)和流f，增广路径p是残存网络<span class="math inline">\(G_f\)</span>中一条从源结点到汇点t的简单路径。根据残存网络的定义，对于一条增广路径上的边(u,v)，可以增加其流量的幅度最大为<span class="math inline">\(c_f(u,v)\)</span>，而不会违反原始流网络G中对边(u,v)或(v,u)的容量限制。</p><p>上图(b)中阴影覆盖的路径是一条增广路径。如果将图中的残存网络<span class="math inline">\(G_f\)</span>看作一个流网络，那么可以对这条路径上每条边的流量增加4个单位，而不会违反容量限制，因为该条路径上最小的残存容量是<span class="math inline">\(c_f(v_2,v_3)=4\)</span>。称在一条增广路径p上能够为每条边增加的流量的最大值为路径p的<strong>残存容量</strong>，该容量由下面的表达式给出： <span class="math display">\[c_f(p)=min\lbrace{c_f(u,v):(u,v)\text{ 属于路径 }p}\rbrace\]</span></p><p>下面精确阐述残存网络中的流：</p><blockquote><p>引理26.2</p><p>设G=(V,E)为一个流网络，设f为G中的一个流，设p为残存网络<span class="math inline">\(G_f\)</span>中的一条增广路径。定义一个函数<span class="math inline">\(f_p:V\times{V}\rightarrow\mathbb{R}\)</span>如下： <span class="math display">\[f_p(u,v)=\begin{cases}c_f(p)&amp;\text{if }(u,v)\text{ is on }p\\0&amp;otherwise\end{cases}\tag{26.8}\]</span> 则<span class="math inline">\(f_p\)</span>是残存网络<span class="math inline">\(G_f\)</span>中的一个流，其值为<span class="math inline">\(|f_p|=c_f(p)&gt;0\)</span>。</p></blockquote><p>式(26.8)表示，残存网络中在增广路径p上的边的流量等于残存容量<span class="math inline">\(c_f(p)\)</span>，不在增广路径p上的边的流量为0。</p><p>下面的推论证明，如果将流f增加<span class="math inline">\(f_p\)</span>的量，则将获得G的另一个流，该流的值更加接近最大值。</p><blockquote><p>推论26.3</p><p>设G=(V,E)为一个流网络，设f为G中的一个流，设p为残存网络<span class="math inline">\(G_f\)</span>中的一条增广路径。设<span class="math inline">\(f_p\)</span>由式(26.8)所定义，假定将f增加<span class="math inline">\(f_p\)</span>的量，则函数<span class="math inline">\(f\uparrow{f_p}\)</span>是图G中的一个流，其值为<span class="math inline">\(|f\uparrow{f_p}|=|f|+|f_p|&gt;|f|\)</span>。</p></blockquote><p><strong>证明</strong>：根据引理26.1和引理26.2可得到上述结论。</p><h2 id="流网络的切割">流网络的切割</h2><p>Ford-Fulkerson方法的核心就是沿着增广路径重复增加路径上的流量，直到找到最大流为止。如何知道在算法中终止时，确实找到了一个最大流呢？最大流最小割定理告诉我们，一个流是最大流当且仅当其残存网络中不包含任何增广路径。为了证明这个定理，首先来探讨一下流网络中的切割概念。</p><p>流网络G=(V,E)中的一个切割(S,T)将结点集合V划分为S和T=V-S两个集合，使得<span class="math inline">\(s\in{S},t\in{T}\)</span>。若f是一个流，则定义横跨切割(S,T)的<strong>净流量</strong>f(S,T)如下： <span class="math display">\[f(S,T)=\sum_{u\in{S}}\sum_{v\in{T}}f(u,v)-\sum_{u\in{S}}\sum_{v\in{T}}f(v,u)\tag{26.9}\]</span> 切割(S,T)的<strong>容量</strong>是： <span class="math display">\[c(S,T)=\sum_{u\in{S}}\sum_{v\in{T}}c(u,v)\tag{26.10}\]</span> 一个网络的最小切割是整个网络中<strong>容量最小</strong>的切割。</p><p>流的定义和切割容量的定义之间存在着不对称性，这种不对称性是有意而为，并且很重要。</p><ul><li>对于容量，计算从集合S发出进入集合T的边的容量，而忽略反方向边上的容量。</li><li>对于流，考虑的则是从S到T的流量减去从T到S的反方向的流量。</li></ul><p>下图描述的是流网络的一个切割（<span class="math inline">\(\lbrace{s,v_1,v_2}\rbrace,\lbrace{v_3,v_4,t}\rbrace\)</span>）。横跨该切割的净流量是<span class="math inline">\(f(v_1,v_3)+f(v_2,v_4)-f(v_3,v_2)=12+11-4=19\)</span>。该切割的容量是<span class="math inline">\(c(v_1,v_3)+c(v_2,v_4)=12+14=26\)</span>。</p><p><img src="/uploads/image/introduction-to-algorithms/s-t-cut-in-flow-network.png" title="流网络的一个ST切割"></p><blockquote><p>引理26.4</p><p>设f为流网络G的一个流，该流网络的源结点为s，汇点为t，设(S,T)为流网络G的任意切割，则横跨切割(S,T)的净流量为f(S,T)=|f|。</p></blockquote><p>直观上，从源结点s发往汇点t的流量必然经过切割的边界（图中虚线）,并且流满足流量守恒性质，表明所有从源结点s发出的流量最终都会流入汇点t。因此所有横跨边界的净流量等于流的值。</p><p>形式化地：对于任意结点<span class="math inline">\(u\in{V-\lbrace{s,t}\rbrace}\)</span>，重写（将右边的子式移到左边）流量守恒性质如下： <span class="math display">\[\begin{aligned}\sum_{v\in{V}}f(u,v)-\sum_{v\in{V}}f(v,u)=0\qquad{u\in{V-\lbrace{s,t}\rbrace}}\end{aligned}\tag{26.11}\]</span> 针对所有结点<span class="math inline">\(S-\lbrace{s}\rbrace\)</span>求和： <span class="math display">\[\sum_{u\in{S-\{s\}}}(\sum_{v\in{V}}f(u,v)-\sum_{v\in{V}}f(v,u))=0\]</span> 根据式(26.1)对|f|的定义，将上式的左项加进来： <span class="math display">\[\begin{aligned}|f|&amp;=\sum_{v\in{V}}f(s,v)-\sum_{v\in{V}}f(v,s)+\sum_{u\in{S-\{s\}}}(\sum_{v\in{V}}f(u,v)-\sum_{v\in{V}}f(v,u))\\&amp;=\sum_{v\in{V}}f(s,v)-\sum_{v\in{V}}f(v,s)+\sum_{u\in{S-\{s\}}}\sum_{v\in{V}}f(u,v)-\sum_{u\in{S-\{s\}}}\sum_{v\in{V}}f(v,u)\\&amp;=\sum_{v\in{V}}(f(s,v)+\sum_{u\in{S-\{s\}}}f(u,v))-\sum_{v\in{V}}(f(v,s)+\sum_{u\in{S-\{s\}}}f(v,s))\\&amp;=\sum_{v\in{V}}\sum_{u\in{S}}f(u,v)-\sum_{v\in{V}}\sum_{u\in{S}}f(v,u)\end{aligned}\]</span></p><p>因为<span class="math inline">\(V=S\bigcup{T},S\bigcap{T}=\varnothing\)</span>，将上述表达式中针对集合V的求和分解为针对S和T的求和，得到： <span class="math display">\[\begin{aligned}|f|&amp;=\sum_{v\in{S}}\sum_{u\in{S}}f(u,v)+\sum_{v\in{T}}\sum_{u\in{S}}f(u,v)-\sum_{v\in{S}}\sum_{u\in{S}}f(v,u)-\sum_{v\in{T}}\sum_{u\in{S}}f(v,u)\\&amp;=\sum_{v\in{T}}\sum_{u\in{S}}f(u,v)-\sum_{v\in{T}}\sum_{u\in{S}}f(v,u)+\color{red}{\Bigl(\sum_{v\in{S}}\sum_{u\in{S}}f(u,v)-\sum_{v\in{S}}\sum_{u\in{S}}f(v,u)\Bigr)}\end{aligned}\]</span> 上式表达式括号里面的两个求和项实际上是一样的。因此，这些求和项相互抵消，得到： <span class="math display">\[|f|=\sum_{v\in{T}}\sum_{u\in{S}}f(u,v)-\sum_{v\in{T}}\sum_{u\in{S}}f(v,u)=f(S,T)\]</span></p><blockquote><p>推论26.5</p><p>流网络G中任意流f的值不能超过G的任意切割容量。</p></blockquote><p><strong>证明</strong>：设(S,T)为流网络G的任意切割，设f为G中的任意流。根据引理26.4和容量限制性质，有 <span class="math display">\[\begin{aligned}|f|=f(S,T)&amp;=\sum_{u\in{S}}\sum_{v\in{T}}f(u,v)-\sum_{u\in{S}}\sum_{v\in{T}}f(v,u)\\&amp;\le\sum_{u\in{}S}\sum_{v\in{T}}f(u,v)\le\sum_{u\in{}S}\sum_{v\in{T}}c(u,v)=c(S,T)\end{aligned}\]</span></p><h2 id="最大流最小割定理">最大流最小割定理</h2><blockquote><p>定理26.6 （最大流最小割定理）</p><p>设f为流网络G=(V,E)中的一个流，该流网络的源结点为s，汇点为t，则下面的条件是等价的：</p><ol type="1"><li>f是G的一个最大流。</li><li>残存网络<span class="math inline">\(G_f\)</span>不包含任何增广路径。</li><li>|f|=c(S,T)，其中(S,T)是流网络的某个切割。</li></ol></blockquote><p><strong>证明</strong>：</p><ul><li><p><span class="math inline">\((1)\Rightarrow(2)\)</span>：使用反证法。假定f是G的一个最大流，但残存网络<span class="math inline">\(G_f\)</span>同时包含一条增广路径p。那么根据推论26.3，对f增加流量<span class="math inline">\(f_p\)</span>所形成的流是G中的一个值严格大于|f|的流，这与f是最大流的假设矛盾。</p></li><li><p><span class="math inline">\((2)\Rightarrow(3)\)</span>：假设<span class="math inline">\(G_f\)</span>不包含任何增广路径，也就是说，在残存网络<span class="math inline">\(G_f\)</span>中不存在任何从源结点s到汇点t的路径。定义<span class="math inline">\(S=\lbrace{v\in{V}:\text{在 }G_f\text{中存在从 }s\text{到}v\text{的路径}}\rbrace,T=V-S\)</span>。显然，<span class="math inline">\(s\in{S}\)</span>，而因为<span class="math inline">\(G_f\)</span>中不存在从s到t的路径（增广路径），所以<span class="math inline">\(t\notin{S}\)</span>。因此，划分(S,T)是流网络G的一个切割。下面证明|f|=c(S,T)。</p><p>考虑一对结点<span class="math inline">\(u\in{S}\)</span>和<span class="math inline">\(v\in{T}\)</span>。</p><ul><li>如果<span class="math inline">\((u,v)\in{E}\)</span>，则必有f(u,v)=c(u,v)，否则边(u,v)将属于<span class="math inline">\(E_f\)</span>，在残存网络中存在一条路径<span class="math inline">\(s\rightsquigarrow{u}\rightarrow{v}\)</span>到达结点v，即<span class="math inline">\(v\in{S}\)</span>，这与结点<span class="math inline">\(v\in{T}\)</span>矛盾。</li><li>如果<span class="math inline">\((v,u)\in{E}\)</span>，则必有f(v,u)=0，否则边(u,v)将属于<span class="math inline">\(E_f\)</span>，得出<span class="math inline">\(v\in{S}\)</span>，与<span class="math inline">\(v\in{T}\)</span>矛盾。</li><li>如果边(u,v)和(v,u)都不在集合E中，则f(u,v)=f(v,u)=0。</li></ul></li></ul><p>因此有 <span class="math display">\[\begin{aligned}f(S,T)&amp;=\sum_{u\in{S}}\sum_{v\in{T}}f(u,v)-\sum_{u\in{S}}\sum_{v\in{T}}f(v,u)\\&amp;=\sum_{u\in{S}}\sum_{v\in{T}}f(u,v)-\sum_{u\in{S}}\sum_{v\in{T}}0\\&amp;=c(S,T)\end{aligned}\]</span></p><ul><li><span class="math inline">\((3)\Rightarrow(1)\)</span>：根据推论26.5，对于所有切割(S,T)，<span class="math inline">\(|f|\le{c(S,T)}\)</span>。因此，条件|f|=c(S,T)隐含着|f|是一个最大流。</li></ul><h1 id="基本的ford-fulkerson算法">基本的Ford-Fulkerson算法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FORD-FULKERSON(G, s, t):</span><br><span class="line">    <span class="keyword">for</span> each edge (u,v) <span class="keyword">in</span> G.E:  <span class="comment"># 将流f初始化为0</span></span><br><span class="line">        (u,v).f = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> there exists a path p <span class="keyword">from</span> s to t <span class="keyword">in</span> the residual network:  <span class="comment"># 寻找增广路径</span></span><br><span class="line">        c_f(p) = min&#123;c_f(u,v):(u,v) <span class="keyword">is</span> <span class="keyword">in</span> p&#125;   <span class="comment"># 残存容量</span></span><br><span class="line">        <span class="keyword">for</span> each edge (u,v) <span class="keyword">in</span> p:              <span class="comment"># 修改原始流网络中的流</span></span><br><span class="line">            <span class="keyword">if</span> (u,v) <span class="keyword">in</span> E:</span><br><span class="line">                (u,v).f = (u,v).f + c_f(p)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                (v,u).f = (v,u).f - c_f(p)</span><br></pre></td></tr></table></figure><p>FORD-FULKERSON算法仅是对FORD-FULKERSON-METHOD过程的简单扩展。下图描述的是一个样本运行过程的每次迭代的结果。</p><p><img src="/uploads/image/introduction-to-algorithms/ford-fulkerson-example.png" title="Ford-Fulkerson示例"></p><h2 id="分析">分析</h2><p>假定所选择的任意增广路径和所有的容量都是整数（如果容量为有理数，则可以通过乘以某个系数来将其转换为整数；如果容量为无理数，则Ford-Fulkerson方法可能不会终止）。</p><ul><li>初始化：对每条边赋初始值0，成本是O(E)。</li><li>寻找增广路径：如果用来实现流网络G=(V,E)的数据结构是合理的，使用深度优先搜索或广度优先搜索在一个残存网络中找到一条路径的时间应是O(V+E)=O(E)。</li><li>while循环：执行一遍的时间为O(E)。如果<span class="math inline">\(f^\star\)</span>表示网络中的一个最大流，则在FORD-FULKERSON算法中，while循环的次数最多为<span class="math inline">\(|f^\star|\)</span>次，因为流量值在每次迭代中最少增加一个单位。</li></ul><p>从而整个FORD-FULKERSON算法的运行时间为<span class="math inline">\(O(E|f^\star|)\)</span>。</p><p>当容量都是整数值且最优的流量值<span class="math inline">\(|f^\star|\)</span>较小时，FORD-FULKERSON算法的运行时间相当不错。下图描述的是当<span class="math inline">\(|f^\star|\)</span>的取值较大时可能发生的情况。该网络的一个最大流取值为2 000 000，1 000 000单位的流量流经路径<span class="math inline">\(s\rightarrow{u}\rightarrow{t}\)</span>，另外1 000 000单位的流量流经路径<span class="math inline">\(s\rightarrow{v}\rightarrow{t}\)</span>。</p><p>如果FORD-FULKERSON算法找到的第一条增广路径为<span class="math inline">\(s\rightarrow{u}\rightarrow{v}\rightarrow{t}\)</span>，如图(a)所示，则在第一次迭代后，流的值为1。产生的残存网络如图(b)所示，找到的第二条增广路径为<span class="math inline">\(s\rightarrow{v}\rightarrow{u}\rightarrow{t}\)</span>，然后流的值将为2。图(c)描述的是结果残存网络。</p><p>如此继续下去，在每个奇数次迭代中，选择增广路径<span class="math inline">\(s\rightarrow{u}\rightarrow{v}\rightarrow{t}\)</span>，在每个偶数次迭代中，选择增广路径<span class="math inline">\(s\rightarrow{v}\rightarrow{u}\rightarrow{t}\)</span>，这样将一共执行2 000 000次递增操作，每次将流量增加1个单位。</p><p><img src="/uploads/image/introduction-to-algorithms/ford-fulkerson-analysis.png" title="循环次数很大的一个示例问题"></p><h1 id="edmonds-karp算法">Edmonds-Karp算法</h1><p>使用广度优先搜索寻找增广路径可以改善FORD-FULKERSON算法的效率。广度优先搜索得到的增广路径是一条从源结点s到汇点t的<strong>最短</strong>（边数最少）路径。称如此实现的Ford-Fulkerson方法为Edmonds-Karp算法。该算法的运行时间为<span class="math inline">\(O(VE^2)\)</span>，只与流网络的规模有关，与最优的流量值无关。</p><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_f</span><span class="params">(graph)</span>:</span></span><br><span class="line">    print(<span class="string">'max flow:'</span>, graph.graph[<span class="string">'max_flow'</span>])</span><br><span class="line">    fmt = <span class="string">'&#123;0:&lt;4s&#125; &#123;1:&lt;4s&#125; &#123;2:&lt;4s&#125; &#123;3:&lt;8s&#125;\n'</span></span><br><span class="line">    title = fmt.format(<span class="string">'u'</span>, <span class="string">'v'</span>, <span class="string">'flow'</span>, <span class="string">'capacity'</span>)</span><br><span class="line">    data = <span class="string">''</span>.join(</span><br><span class="line">        fmt.format(str(u), str(v), str(attr[<span class="string">'flow'</span>]), str(attr[<span class="string">'capacity'</span>])) <span class="keyword">for</span> u, v, attr <span class="keyword">in</span> graph.edges(data=<span class="literal">True</span>) <span class="keyword">if</span></span><br><span class="line">        attr[<span class="string">'flow'</span>] &gt; <span class="number">0</span>)</span><br><span class="line">    print(title + data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_path_dfs</span><span class="params">(graph, s, t, p)</span>:</span></span><br><span class="line">    <span class="string">"""寻找增广路径，深度优先搜索（递归实现）"""</span></span><br><span class="line">    <span class="keyword">if</span> s == t:</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> graph.get_e(s):</span><br><span class="line">        residuals = e.c - e.f</span><br><span class="line">        <span class="keyword">if</span> residuals &gt; <span class="number">0</span> <span class="keyword">and</span> e <span class="keyword">not</span> <span class="keyword">in</span> p:</span><br><span class="line">            p.add(e)  <span class="comment"># 将当前邻接边加入path，向sink寻路</span></span><br><span class="line">            result = find_path_dfs(graph, e.v, t, p)</span><br><span class="line">            <span class="keyword">if</span> result <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">            p.remove(e)  <span class="comment"># 若没找到通向sink的路，从path中移除当前边，循环下一条邻接边</span></span><br><span class="line">    <span class="comment"># 未找到路径，将返回默认值None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_path_bfs</span><span class="params">(graph, s, t, p)</span>:</span></span><br><span class="line">    <span class="string">"""Ford-Fulkerson Method的一种特殊实现：Edmonds-Karp algorithm</span></span><br><span class="line"><span class="string">    使用广度优先搜索寻找增广路径，寻找一条边数最少的增广路径"""</span></span><br><span class="line">    previous, visit, q = &#123;s: <span class="literal">None</span>&#125;, set(), Queue()</span><br><span class="line">    q.put(s)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">        u = q.get()</span><br><span class="line">        visit.add(u)  <span class="comment"># visit用来记录结点是否曾被访问过</span></span><br><span class="line">        <span class="keyword">if</span> u == t:  <span class="comment"># 输出路径</span></span><br><span class="line">            pre = previous[t]</span><br><span class="line">            <span class="keyword">while</span> pre <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                p.add((pre, u))  <span class="comment"># path的顺序无影响</span></span><br><span class="line">                u = pre</span><br><span class="line">                pre = previous[pre]</span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line">        <span class="keyword">for</span> v, attr <span class="keyword">in</span> graph[u].items():</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> visit:</span><br><span class="line">                residual = attr[<span class="string">'capacity'</span>] - attr[<span class="string">'flow'</span>]  <span class="comment"># 判断残存容量</span></span><br><span class="line">                <span class="keyword">if</span> residual &gt; <span class="number">0</span>:</span><br><span class="line">                    q.put(v)</span><br><span class="line">                    previous[v] = u  <span class="comment"># previous记录前驱结点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_path</span><span class="params">(graph, s, t, path)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> find_path_bfs(graph, s, t, path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_flow</span><span class="params">(graph, s, t)</span>:</span></span><br><span class="line">    <span class="string">"""求最大流"""</span></span><br><span class="line">    p = find_path(graph, s, t, set())</span><br><span class="line">    <span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        augment_flow = min(graph[u][v][<span class="string">'capacity'</span>] - graph[u][v][<span class="string">'flow'</span>] <span class="keyword">for</span> u, v <span class="keyword">in</span> p)</span><br><span class="line">        <span class="keyword">for</span> u, v <span class="keyword">in</span> p:</span><br><span class="line">            graph[u][v][<span class="string">'flow'</span>] += augment_flow</span><br><span class="line">            graph[v][u][<span class="string">'flow'</span>] -= augment_flow</span><br><span class="line">        p = find_path(graph, s, t, set())</span><br><span class="line">    graph.graph[<span class="string">'max_flow'</span>] = sum(attr[<span class="string">'flow'</span>] <span class="keyword">for</span> attr <span class="keyword">in</span> graph[s].values())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_graph</span><span class="params">(graph, vertices, edges)</span>:</span></span><br><span class="line">    graph.add_nodes_from(vertices)</span><br><span class="line">    <span class="keyword">for</span> u, v, c <span class="keyword">in</span> edges:</span><br><span class="line">        graph.add_edges_from([(u, v, &#123;<span class="string">'capacity'</span>: c&#125;), (v, u, &#123;<span class="string">'capacity'</span>: <span class="number">0</span>&#125;)], flow=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    g = nx.DiGraph()</span><br><span class="line">    v = <span class="string">'s1234t'</span></span><br><span class="line">    e = [(<span class="string">'s'</span>, <span class="string">'1'</span>, <span class="number">6</span>), (<span class="string">'s'</span>, <span class="string">'3'</span>, <span class="number">5</span>), (<span class="string">'s'</span>, <span class="string">'4'</span>, <span class="number">1</span>), (<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="number">5</span>), (<span class="string">'1'</span>, <span class="string">'4'</span>, <span class="number">2</span>), (<span class="string">'1'</span>, <span class="string">'t'</span>, <span class="number">3</span>),</span><br><span class="line">         (<span class="string">'2'</span>, <span class="string">'t'</span>, <span class="number">5</span>), (<span class="string">'3'</span>, <span class="string">'1'</span>, <span class="number">2</span>), (<span class="string">'3'</span>, <span class="string">'4'</span>, <span class="number">4</span>), (<span class="string">'4'</span>, <span class="string">'2'</span>, <span class="number">3</span>), (<span class="string">'4'</span>, <span class="string">'t'</span>, <span class="number">3</span>)]</span><br><span class="line">    initialize_graph(g, v, e)</span><br><span class="line">    max_flow(g, <span class="string">'s'</span>, <span class="string">'t'</span>)</span><br><span class="line">    print_f(g)</span><br><span class="line"></span><br><span class="line">    g.clear()</span><br><span class="line">    e = [(<span class="string">'s'</span>, <span class="string">'1'</span>, <span class="number">16</span>), (<span class="string">'s'</span>, <span class="string">'2'</span>, <span class="number">13</span>), (<span class="string">'1'</span>, <span class="string">'3'</span>, <span class="number">12</span>), (<span class="string">'2'</span>, <span class="string">'1'</span>, <span class="number">4</span>), (<span class="string">'2'</span>, <span class="string">'4'</span>, <span class="number">14</span>), (<span class="string">'3'</span>, <span class="string">'2'</span>, <span class="number">9</span>),</span><br><span class="line">         (<span class="string">'3'</span>, <span class="string">'t'</span>, <span class="number">20</span>), (<span class="string">'4'</span>, <span class="string">'3'</span>, <span class="number">7</span>), (<span class="string">'4'</span>, <span class="string">'t'</span>, <span class="number">4</span>)]</span><br><span class="line">    initialize_graph(g, v, e)</span><br><span class="line">    max_flow(g, <span class="string">'s'</span>, <span class="string">'t'</span>)</span><br><span class="line">    print_f(g)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">max flow: 11</span><br><span class="line">u    v    flow capacity</span><br><span class="line">s    1    6    6</span><br><span class="line">s    3    5    5</span><br><span class="line">1    2    2    5</span><br><span class="line">1    4    2    2</span><br><span class="line">1    t    3    3</span><br><span class="line">2    t    5    5</span><br><span class="line">3    1    1    2</span><br><span class="line">3    4    4    4</span><br><span class="line">4    2    3    3</span><br><span class="line">4    t    3    3</span><br><span class="line"></span><br><span class="line">max flow: 23</span><br><span class="line">u    v    flow capacity</span><br><span class="line">s    1    12   16</span><br><span class="line">s    2    11   13</span><br><span class="line">1    3    12   12</span><br><span class="line">2    4    11   14</span><br><span class="line">3    t    19   20</span><br><span class="line">4    3    7    7</span><br><span class="line">4    t    4    4</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Algorithms </tag>
            
            <tag> algorithms </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Python 中使用 CPLEX</title>
      <link href="/operations-research/cplex-in-python/"/>
      <url>/operations-research/cplex-in-python/</url>
      
        <content type="html"><![CDATA[<h1 id="设置api">设置API</h1><p>从搭建运行环境开始。使用的软件如下：</p><ul><li>ILOG CPLEX Optimization studio 12.9.0 64bit。</li><li>Python3.6.8 64bit。</li></ul><p>安装好ILOG CPLEX Optimization studio后，<a href="https://www.ibm.com/support/knowledgecenter/zh/SSSA5P_12.9.0/ilog.odms.cplex.help/CPLEX/GettingStarted/topics/set_up/Python_setup.html" target="_blank" rel="noopener">设置 CPLEX 的 Python API</a>。</p><h2 id="使用脚本-setup.py">使用脚本 setup.py</h2><p>要在系统上安装 CPLEX-Python 模块，请使用位于 yourCplexhome/python/VERSION/PLATFORM 中的脚本 setup.py。 如果要将 CPLEX-Python 模块安装在非缺省位置，请使用选项 --home 识别安装目录。 例如，要将 CPLEX-Python 模块安装在缺省位置，请从命令行使用以下命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><p>要安装在目录 yourPythonPackageshome/cplex 中，请从命令行使用以下命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python setup.py install --home yourPythonPackageshome/cplex</span><br></pre></td></tr></table></figure><p>这两个命令（缺省和指定主目录）均会调用 Python 包 distutils。 有关适用于该软件包的其他选项，请参考 Python distutils 的文档。</p><p>设置完成后，若能在Python解释器中导入cplex库（<code>import cplex</code>）说明配置成功。</p><a id="more"></a><p><strong>附</strong>：</p><ol type="1"><li>CPLEX API和Python位数需一致。</li><li>CPLEX Optimization studio 12.9版本不支持32bit。</li><li>如果都安装64bit版本，Python不要选择v3.7，某些库尚不支持Python3.7 64bit。</li></ol><h1 id="hello-cplex">Hello CPLEX</h1><p>cplex中重要的一个类就是Cplex类，它提供了创建、修改、查询最优化问题的一系列方法。Cplex 的官方文档：<a href="https://www.ibm.com/support/knowledgecenter/zh/SSSA5P_12.9.0/ilog.odms.cplex.help/refpythoncplex/html/cplex.Cplex-class.html" target="_blank" rel="noopener">Class Cplex</a>。使用cplex优化一个LP模型：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Maximize</span><br><span class="line">3x1 + 5x2</span><br><span class="line">Subject to</span><br><span class="line"> x1 + 7x2 &lt;= 140</span><br><span class="line"> x1 + 2x2 &lt;= 50</span><br><span class="line">3x1 + 2x2 &lt;= 130</span><br><span class="line">Bounds</span><br><span class="line">0 &lt;= x1 &lt;= infinity</span><br><span class="line">0 &lt;= x2 &lt;= infinity</span><br><span class="line">End</span><br></pre></td></tr></table></figure><p>将上述内容保存至文件hello.lp，之后可以直接读取该文件。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cplex</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    c = cplex.Cplex()</span><br><span class="line">    c.read(<span class="string">'hello.lp'</span>)</span><br><span class="line">    c.solve()</span><br><span class="line">    print(c.solution.get_objective_value(), c.solution.get_values())</span><br></pre></td></tr></table></figure><p>或者直接构建相同的模型。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cplex</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    c = cplex.Cplex()</span><br><span class="line">    <span class="comment"># 设置优化目标为最大化，默认是minimize</span></span><br><span class="line">    c.objective.set_sense(c.objective.sense.maximize)</span><br><span class="line">    <span class="comment"># obj: 目标函数</span></span><br><span class="line">    <span class="comment"># names: 变量名</span></span><br><span class="line">    <span class="comment"># lb: lower bound</span></span><br><span class="line">    <span class="comment"># ub: upper bound</span></span><br><span class="line">    c.variables.add(</span><br><span class="line">        obj=[<span class="number">3</span>, <span class="number">5</span>], names=[<span class="string">'x1'</span>, <span class="string">'x2'</span>],</span><br><span class="line">        lb=[<span class="number">0.0</span>, <span class="number">0.0</span>], ub=[cplex.infinity] * <span class="number">2</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># lin_expr: 线性表达式，约束条件左边</span></span><br><span class="line">    <span class="comment"># senses: 约束条件的比较符号，G|L|E|R，分别表示大于等于|小于等于|等于|区间约束</span></span><br><span class="line">    <span class="comment"># rhs: right hand side，约束条件右边的值</span></span><br><span class="line">    c.linear_constraints.add(</span><br><span class="line">        lin_expr=[([<span class="string">'x1'</span>, <span class="string">'x2'</span>], [<span class="number">1</span>, <span class="number">7</span>]),</span><br><span class="line">                  ([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>]),</span><br><span class="line">                  ([<span class="string">'x1'</span>, <span class="string">'x2'</span>], [<span class="number">3</span>, <span class="number">2</span>])],</span><br><span class="line">        senses=<span class="string">'L'</span> * <span class="number">3</span>,</span><br><span class="line">        rhs=[<span class="number">140.0</span>, <span class="number">50.0</span>, <span class="number">130.0</span>]</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 求解问题，解决方案保存在c.solution变量</span></span><br><span class="line">    c.solve()</span><br><span class="line">    <span class="comment"># 打印最优值和所有变量的值</span></span><br><span class="line">    print(c.solution.get_objective_value(), c.solution.get_values())</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CPXPARAM_Read_DataCheck                          1</span><br><span class="line">Tried aggregator 1 time.</span><br><span class="line">No LP presolve or aggregator reductions.</span><br><span class="line">Presolve time = 0.00 sec. (0.00 ticks)</span><br><span class="line"></span><br><span class="line">Iteration log . . .</span><br><span class="line">Iteration:     1   Dual infeasibility =             0.000000</span><br><span class="line">Iteration:     2   Dual objective     =           175.789474</span><br><span class="line">145.0 [40.0, 5.0]  # 最优值和此时变量的值，上面是log内容</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 运筹学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linear programming </tag>
            
            <tag> cplex </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单源最短路径</title>
      <link href="/notes/introduction-to-algorithms/single-source-shortest-paths/"/>
      <url>/notes/introduction-to-algorithms/single-source-shortest-paths/</url>
      
        <content type="html"><![CDATA[<h1 id="简介">简介</h1><p>最短路径问题（Shortest path problem, SPP）旨在寻找图中两个结点之间的最短路径。本文介绍单源最短路径问题：给定一个图 <span class="math inline">\(G=(V,E)\)</span>，我们希望找到从给定源节点 <span class="math inline">\(s\)</span> 到每个结点 <span class="math inline">\(v\in{V}\)</span> 的最短路径。广度优先搜索就是权重均为1的单源最短路径问题，根节点（源点）到每个结点的最短距离等于最短路径上的边的条数。单源最短路径问题可以用来解决许多其他问题，其中就包括它的几个变体：</p><ul><li>单目的地最短路径问题：找到从给定结点 <span class="math inline">\(v\)</span> 到给定目的地结点 <span class="math inline">\(t\)</span> 的最短路径。如果将图的每条边的方向翻转过来，就可以将这个问题转换为单源最短路径问题。</li><li>单节点对最短路径问题：找到从给定结点 <span class="math inline">\(u\)</span> 到给定节点 <span class="math inline">\(v\)</span> 的最短距离。如果解决了针对单个结点 <span class="math inline">\(u\)</span> 的单源最短路径问题，那么也就解决了这个问题。而且，在该问题的所有已知算法中，最坏情况下的渐进运行时间都和最好的单源最短路径算法的运行时间一样。</li><li>所有结点对最短距离：对于每对结点 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(v\)</span>，找到从结点 <span class="math inline">\(u\)</span> 到结点 <span class="math inline">\(v\)</span> 的最短路径。可以针对每个结点运行一遍单源最短路径算法，但可以更快地解决这个问题。此类问题适合使用Floyd-Warshall算法。</li></ul><a id="more"></a><h1 id="最短路径的最优子结构">最短路径的最优子结构</h1><blockquote><p>引理24.1 （最短路径的子路径也是最短路径）</p><p>给定带权重的有向图 <span class="math inline">\(G=(V,E)\)</span> 和权重函数 <span class="math inline">\(w:E\rightarrow{R}\)</span>。设 <span class="math inline">\(p=\langle{v_0,v_1,\dots,v_k\rangle}\)</span> 为从结点 <span class="math inline">\(v_0\)</span> 到结点 <span class="math inline">\(v_k\)</span> 的一条最短路径，并且对于任意的 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j，0\le{I}\le{j}\le{k}\)</span>，设 <span class="math inline">\(p_{ij}=\langle{v_i,v_{i+1},\dots,v_j}\rangle\)</span> 为路径 <span class="math inline">\(p\)</span> 中从结点 <span class="math inline">\(v_i\)</span> 到结点 <span class="math inline">\(v_j\)</span> 的子路径。那么 <span class="math inline">\(p_{ij}\)</span> 是从结点 <span class="math inline">\(v_i\)</span> 到结点 <span class="math inline">\(v_j\)</span> 的一条最短路径。</p></blockquote><p><strong>证明</strong>：假设 <span class="math inline">\(p\)</span> 是从 <span class="math inline">\(v_0\)</span> 到 <span class="math inline">\(v_k\)</span> 的一条最短路径。将路径p分解为</p><p><span class="math display">\[v_0\mathop{\rightsquigarrow}^{p_{0i}}v_i\mathop{\rightsquigarrow}^{p_{ij}}v_j\mathop{\rightsquigarrow}^{p_{jk}}v_k\]</span></p><p>则有 <span class="math inline">\(w(p)=w(p_{0i})+w(p_{ij})+w(p_{jk})\)</span>。</p><p>假设存在一条从 <span class="math inline">\(v_i\)</span> 到 <span class="math inline">\(v_j\)</span> 的路径 <span class="math inline">\(p^\prime_{ij}\)</span>，且 <span class="math inline">\(w(p^\prime_{ij})&lt;w(p_{ij})\)</span>。则</p><p><span class="math display">\[v_0\mathop{\rightsquigarrow}^{p_{0i}}v_i\mathop{\rightsquigarrow}^{\color{red}{p^\prime_{ij}}}v_j\mathop{\rightsquigarrow}^{p_{jk}}v_k\]</span></p><p>是一条从结点 <span class="math inline">\(v_0\)</span> 到结点 <span class="math inline">\(v_k\)</span> 的权重为 <span class="math inline">\(w(p^\prime)=w(p_{0i})+w(p^\prime_{ij})+w(p_{jk})\)</span> 的路径，而该权重小于 <span class="math inline">\(w(p)\)</span>。</p><p>这与 <span class="math inline">\(p\)</span> 是从 <span class="math inline">\(v_0\)</span> 到 <span class="math inline">\(v_k\)</span> 的一条最短路径这一假设矛盾。</p><h1 id="环路">环路</h1><p>不失一般性，我们可以假定找到的最短路径中没有环路，即它们都是简单路径。</p><ul><li><p>若一条路径包含权重为正值的环路，那么将环路从路径上删除就可以得到一条源点和终点相同的权重更小的路径。</p></li><li><p>若包含权重为负值的环路，那么只要沿着环路再遍历一遍，就能找到一条权重更小的路径。如果从结点s到结点v的某条路径上存在权重为负值的环路，我们定义结点s到结点v的最短路径<span class="math inline">\(\delta(s,v)=-\infty\)</span>。例如下图中，存在<span class="math inline">\(\langle{e,f,e}\rangle\)</span>这条权重为-3的环路，因此所有经过这条环路可达的结点e,f,g的最短路径权重为<span class="math inline">\(-\infty\)</span>。</p><p><img src="/uploads/image/introduction-to-algorithms/negative-edge-weights-in-a-directed-graph.png" title="包含权重为负值的环路的有向图"></p></li><li><p>若包含权重为0的环路，那么删除该环路后得到的路径权重与原来的相等。只要一条最短路径上还有权重为0的环路，我们就可以重复删除这些环路，直到得到一条不包含环路的简单路径。</p></li></ul><p>由于图<span class="math inline">\(G=(V,E)\)</span>中的任意无环路径最多包含|V|个不同的结点，到任意结点的最短路径最多包含|V|-1条边。</p><h1 id="最短路径的表示">最短路径的表示</h1><p>通常情况下，我们不但希望计算出最短路径权重，还希望计算出最短路径上的结点。</p><p>给定图<span class="math inline">\(G=(V,E)\)</span>，对于每个结点v，维持一个<strong>前驱结点</strong><span class="math inline">\(v.\pi\)</span>。该前驱结点可能是另一个结点或者NIL。将从结点v开始的前驱结点链反转过来，就是从s到v的一条最短路径。</p><p>我们感兴趣的是由<span class="math inline">\(\pi\)</span>值所诱导的<strong>前驱子图</strong><span class="math inline">\(G_\pi=(V_\pi,E_\pi)\)</span>。定义结点集<span class="math inline">\(V_\pi\)</span>为图G中的前驱结点不为NIL的结点的集合，再加上源节点s，即<span class="math inline">\(V_\pi=\{v\in{V}:v.\pi\neq{NIL}\}\cup\{s\}\)</span>。有向边集合<span class="math inline">\(E_\pi\)</span>是由<span class="math inline">\(V_\pi\)</span>中的结点的<span class="math inline">\(\pi\)</span>值所诱导的边的集合，即<span class="math inline">\(E_\pi=\{(v.\pi,v)\in{E}:v\in{V_\pi-\{s\}}\}\)</span>。</p><p>一个正确的单源最短路径算法：在算法终止时，<span class="math inline">\(G_\pi\)</span>是一棵“最短路径树“。最短路径树是一棵有根节点的树，该树包括了从源节点s到每个可以从s到达的结点的一条最短路径。类似于广度优先搜索中的广度优先树，但它所包括的最短路径是以边的权重来定义的，而不是边的条数。</p><p>需要指出的是，最短路径不一定是唯一的，最短路径树也不一定是唯一的。如下图(a)所示的带权重的有向图中，有(b)和(c)两种最短路径，即存在两棵根节点为s的最短路径树。</p><p><img src="/uploads/image/introduction-to-algorithms/two-shortest-paths-trees-with-the-same-root.png" title="根结点相同的两棵不同的最短路径树"></p><h1 id="松弛操作">松弛操作</h1><p>本文的算法需要使用松弛（relaxation）技术。对于每个结点v来说，维持一个属性v.d，用来记录从源节点s到结点v的最短路径权重的上界。称之为s到v的<strong>最短路径估计</strong>。使用下面运行时间为<span class="math inline">\(\Theta(V)\)</span>的算法来对最短路径估计和前驱结点进行初始化。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INITIALIZE-SINGLE-SOURCE(G, s):</span><br><span class="line">    <span class="keyword">for</span> each vertex v <span class="keyword">in</span> G.V:</span><br><span class="line">        v.d = infinity</span><br><span class="line">        v.pi = NIL</span><br><span class="line">    s.d = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>下面的伪代码给出了对边(u,v)在O(1)时间内进行的松弛操作：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">RELAX(u, v, w)：</span><br><span class="line">    <span class="keyword">if</span> v.d &gt; u.d + w(u, v):</span><br><span class="line">        v.d = u.d + w(u, v)</span><br><span class="line">        v.pi = u</span><br></pre></td></tr></table></figure><p>对一条边的松弛过程为：</p><p>首先测试一下是否可以对从s到v的最短距离进行改善。测试方法是，将从结点s到结点u之间的最短路径距离u.d加上结点u与v之间的边权重w(u, v)，并与当前的s到v的最短路径估计v.d进行比较。如果前者更小，则对v.d和v.pi进行更新。如下图：</p><ol type="a"><li><p>v.d=9; u.d=5; w(u,v)=2，9&gt;5+2，因此v的最短路径估计v.d降低，同时v的前驱结点也要更新为u。称这种情况为松弛成功。</p></li><li><p>6&lt;5+2，因此v.d和v.pi属性都不会变化。称这种情况为松弛失败。</p></li></ol><p><img src="/uploads/image/introduction-to-algorithms/single-source-shortest-path-relax.png" title="松弛成功和松弛失败"></p><h1 id="bellman-ford算法">Bellman-Ford算法</h1><p>Bellman-Ford算法解决的是一般情况下的单源最短路径问题。边的权重可以为负值。算法返回一个布尔值，以表明是否存在一个从源节点可以到达的权重为负值的环路。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BELLMAN-FORD(G, w, s):</span><br><span class="line">    INITIALIZE-SINGLE-SOURCE(G, s)</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to |G.V| - <span class="number">1</span>:        <span class="comment"># 算法对每条边进行|V|-1次处理</span></span><br><span class="line">        <span class="keyword">for</span> each edge(u, v) <span class="keyword">in</span> G.E:</span><br><span class="line">            RELAX(u, v, w)</span><br><span class="line">    <span class="keyword">for</span> each edge(u, v) <span class="keyword">in</span> G.E:    <span class="comment"># 检查是否存在权重为负值的环路</span></span><br><span class="line">        <span class="keyword">if</span> v.d &gt; u.d + w(u, v):</span><br><span class="line">            <span class="keyword">return</span> false           <span class="comment"># 若存在，返回false</span></span><br><span class="line">    <span class="keyword">return</span> true</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-algorithms/execution-of-bellman-ford.png" title="Bellman Ford每次迭代后的结果"></p><p>例如在图(a)所示的带权重的有向图中，按(t,x), (t,y), (t,z), (x,t), (y,x), (y,z), (z,x), (z,s), (s,t), (s,y)的顺序对边执行松弛操作的过程。有向图中有6个顶点，因此需要循环5次。单次循环后的结果分为如图(b)~(e)所示。只有v.d值降低的结点成功松弛。</p><p>边的顺序不会对最终结果产生影响，但若斟酌选择，可以减少松弛失败的次数，从而提高代码的执行效率。在后续的优化中将会提到一种选择方案。</p><h2 id="分析">分析</h2><p>INITIALIZE-SINGLE-SOURCE所需时间为<span class="math inline">\(\Theta(V)\)</span>，内层循环对每条边都执行一次RELAX操作，因此运行时间为<span class="math inline">\(\Theta(E)\)</span>，且一共要进行|V|-1次循环，检测是否存在权重为负值的环路所需时间为O(E)，Bellman-Ford算法的总运行时间为<span class="math inline">\(\Theta(V)+(|V|-1)\Theta(E)+O(E)=O(VE)\)</span>。</p><h2 id="优化">优化</h2><ol type="1"><li><p>提前跳出循环。</p><p>实际操作中，Bellman-Ford算法经常会在未达到|V|-1次前就出解，|V|-1其实是最大值。于是可以在循环中设置判定，在某次循环不再进行松弛时，直接退出循环，进行负权环判定。（若存在负权环，则循环次数一定会达到|V|-1次，因此，若是提前跳出循环，则说明图中没有负权环）</p></li><li><p>队列优化。参考最短路径快速算法。</p><p>松弛操作必定只会发生在最短路径前驱结点松弛成功过的结点上：结点v的所有前驱结点<span class="math inline">\(\{u|(u,v)\in{E}\}\)</span>中，若存在松弛成功（更新了最短路径估计d和前驱结点pi）的结点，则对结点v执行松弛操作RELAX(v, n, w)。</p><p>反过来说，我们应该对哪些结点v执行松弛操作：若结点u成功松弛，则应该对u的所有后继结点<span class="math inline">\(\{v|(u,v)\in{E}\}\)</span>执行松弛操作。</p><p>用一个队列记录松弛过的结点，避免了冗余计算。</p></li></ol><h2 id="代码">代码</h2><p>图用邻接链表的方式存储。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_f</span><span class="params">(graph, result=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> result <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        print(<span class="string">'has negative cycle or not?'</span>, <span class="keyword">not</span> result)</span><br><span class="line">    fmt = <span class="string">'&#123;0:&lt;10s&#125; &#123;1:&lt;10s&#125; &#123;2:&lt;10s&#125;\n'</span></span><br><span class="line">    title = fmt.format(<span class="string">'vertex'</span>, <span class="string">'distance'</span>, <span class="string">'previous'</span>)</span><br><span class="line">    data = <span class="string">''</span>.join(fmt.format(str(k), str(attr[<span class="string">'distance'</span>]), str(attr[<span class="string">'previous'</span>])) <span class="keyword">for</span> k, attr <span class="keyword">in</span> graph.nodes.items())</span><br><span class="line">    print(title + data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_single_source</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    <span class="string">"""初始化单源点"""</span></span><br><span class="line">    <span class="keyword">for</span> attr <span class="keyword">in</span> graph.nodes.values():</span><br><span class="line">        attr[<span class="string">'previous'</span>] = <span class="literal">None</span></span><br><span class="line">        attr[<span class="string">'distance'</span>] = float(<span class="string">'inf'</span>)</span><br><span class="line">    graph.nodes[s][<span class="string">'distance'</span>] = <span class="number">0</span>  <span class="comment"># 源点距离初始为0，其他为无穷远</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relax</span><span class="params">(graph, u, v, w)</span>:</span></span><br><span class="line">    <span class="string">"""relax操作，distance的值只在此处发生改变"""</span></span><br><span class="line">    u_attr, v_attr = graph.nodes[u], graph.nodes[v]</span><br><span class="line">    <span class="keyword">if</span> v_attr[<span class="string">'distance'</span>] &gt; u_attr[<span class="string">'distance'</span>] + w:</span><br><span class="line">        v_attr[<span class="string">'distance'</span>] = u_attr[<span class="string">'distance'</span>] + w  <span class="comment"># 更新最短距离</span></span><br><span class="line">        v_attr[<span class="string">'previous'</span>] = u  <span class="comment"># 更新前驱结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detect_negative_cycle</span><span class="params">(graph)</span>:</span></span><br><span class="line">    <span class="string">"""检测图g中是否包含负权环路"""</span></span><br><span class="line">    <span class="keyword">for</span> u, v, w <span class="keyword">in</span> graph.edges.data(<span class="string">'weight'</span>):</span><br><span class="line">        <span class="keyword">if</span> graph.nodes[v][<span class="string">'distance'</span>] &gt; graph.nodes[u][<span class="string">'distance'</span>] + w:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bellman_ford</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    <span class="string">"""Bellman Ford算法，同时判断是否存在权重为负值的环路"""</span></span><br><span class="line">    initialize_single_source(graph, s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(graph.number_of_nodes() - <span class="number">1</span>):  <span class="comment"># 重复|V|-1遍</span></span><br><span class="line">        <span class="keyword">for</span> u, v, w <span class="keyword">in</span> graph.edges.data(<span class="string">'weight'</span>):  <span class="comment"># 对每条边执行一次relax</span></span><br><span class="line">            relax(graph, u, v, w)</span><br><span class="line">    <span class="keyword">return</span> detect_negative_cycle(graph)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bellman_ford_op_1</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    <span class="string">"""优化方案1：提前跳出循环"""</span></span><br><span class="line">    initialize_single_source(graph, s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(graph.number_of_nodes() - <span class="number">1</span>):</span><br><span class="line">        relaxed = <span class="literal">False</span>  <span class="comment"># 一次循环开始前，标志位置为0</span></span><br><span class="line">        <span class="keyword">for</span> u, v, w <span class="keyword">in</span> graph.edges.data(<span class="string">'weight'</span>):</span><br><span class="line">            <span class="keyword">if</span> relax(graph, u, v, w) <span class="keyword">is</span> <span class="literal">True</span>:  <span class="comment"># 若松弛成功，标志位置为1</span></span><br><span class="line">                relaxed = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> relaxed <span class="keyword">is</span> <span class="literal">False</span>:  <span class="comment"># 提前跳出循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 若完整执行了|V|-1次循环，则去判断是否包含负权环</span></span><br><span class="line">        <span class="keyword">return</span> detect_negative_cycle(graph)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bellman_ford_op_2</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    <span class="string">"""队列优化"""</span></span><br><span class="line">    initialize_single_source(graph, s)</span><br><span class="line">    q = Queue()</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> graph.edges:</span><br><span class="line">        graph[u][v][<span class="string">'__times__'</span>] = <span class="number">0</span>  <span class="comment"># 记录松弛次数（不论结果），当超过|V|-1次时，说明图中包含负权环</span></span><br><span class="line">    q.put(s)  <span class="comment"># 初始放入源点</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">        u = q.get()</span><br><span class="line">        <span class="keyword">for</span> v, attr <span class="keyword">in</span> graph[u].items():  <span class="comment"># 遍历邻接边</span></span><br><span class="line">            <span class="keyword">if</span> relax(graph, u, v, attr[<span class="string">'weight'</span>]) <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">                q.put(v)  <span class="comment"># 将松弛成功过的结点放入队列</span></span><br><span class="line">                graph[u][v][<span class="string">'__times__'</span>] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> graph[u][v][<span class="string">'__times__'</span>] &gt; graph.number_of_nodes() - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># Bellman-Ford示例</span></span><br><span class="line">    g = nx.DiGraph()</span><br><span class="line">    g.add_nodes_from(<span class="string">'stxyz'</span>)</span><br><span class="line">    edges = [(<span class="string">'s'</span>, <span class="string">'t'</span>, <span class="number">6</span>), (<span class="string">'s'</span>, <span class="string">'y'</span>, <span class="number">7</span>), (<span class="string">'t'</span>, <span class="string">'x'</span>, <span class="number">5</span>), (<span class="string">'t'</span>, <span class="string">'y'</span>, <span class="number">8</span>), (<span class="string">'t'</span>, <span class="string">'z'</span>, <span class="number">-4</span>), (<span class="string">'x'</span>, <span class="string">'t'</span>, <span class="number">-2</span>), (<span class="string">'y'</span>, <span class="string">'x'</span>, <span class="number">-3</span>),</span><br><span class="line">             (<span class="string">'y'</span>, <span class="string">'z'</span>, <span class="number">9</span>), (<span class="string">'z'</span>, <span class="string">'s'</span>, <span class="number">2</span>), (<span class="string">'z'</span>, <span class="string">'x'</span>, <span class="number">7</span>)]</span><br><span class="line">    g.add_weighted_edges_from(edges)</span><br><span class="line">    r = bellman_ford(g, <span class="string">'s'</span>)</span><br><span class="line">    print_f(g, r)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 一个带有负权环路的示例</span></span><br><span class="line">    g.clear()</span><br><span class="line">    g.add_nodes_from(<span class="string">'s1234t'</span>)</span><br><span class="line">    edges = [(<span class="string">'s'</span>, <span class="string">'1'</span>, <span class="number">1</span>), (<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="number">1</span>), (<span class="string">'2'</span>, <span class="string">'1'</span>, <span class="number">-2</span>), (<span class="string">'1'</span>, <span class="string">'3'</span>, <span class="number">1</span>), (<span class="string">'3'</span>, <span class="string">'4'</span>, <span class="number">-4</span>), (<span class="string">'4'</span>, <span class="string">'1'</span>, <span class="number">1</span>), (<span class="string">'4'</span>, <span class="string">'t'</span>, <span class="number">1</span>)]</span><br><span class="line">    g.add_weighted_edges_from(edges)</span><br><span class="line">    r = bellman_ford_op_2(g, <span class="string">'s'</span>)</span><br><span class="line">    print_f(g, r)</span><br><span class="line"></span><br><span class="line">    g.clear()</span><br><span class="line">    g.add_nodes_from(<span class="string">'s1234t'</span>)</span><br><span class="line">    edges = [(<span class="string">'s'</span>, <span class="string">'1'</span>, <span class="number">3</span>), (<span class="string">'1'</span>, <span class="string">'s'</span>, <span class="number">-3</span>), (<span class="string">'s'</span>, <span class="string">'2'</span>, <span class="number">4</span>), (<span class="string">'2'</span>, <span class="string">'s'</span>, <span class="number">-4</span>), (<span class="string">'2'</span>, <span class="string">'1'</span>, <span class="number">3</span>), (<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="number">-3</span>), (<span class="string">'1'</span>, <span class="string">'3'</span>, <span class="number">7</span>),</span><br><span class="line">             (<span class="string">'3'</span>, <span class="string">'1'</span>, <span class="number">-7</span>), (<span class="string">'3'</span>, <span class="string">'2'</span>, <span class="number">5</span>), (<span class="string">'2'</span>, <span class="string">'4'</span>, <span class="number">6</span>), (<span class="string">'4'</span>, <span class="string">'2'</span>, <span class="number">-6</span>), (<span class="string">'3'</span>, <span class="string">'4'</span>, <span class="number">-8</span>), (<span class="string">'3'</span>, <span class="string">'t'</span>, <span class="number">6</span>),</span><br><span class="line">             (<span class="string">'t'</span>, <span class="string">'3'</span>, <span class="number">-6</span>), (<span class="string">'4'</span>, <span class="string">'t'</span>, <span class="number">9</span>), (<span class="string">'t'</span>, <span class="string">'4'</span>, <span class="number">-9</span>)]</span><br><span class="line">    g.add_weighted_edges_from(edges)</span><br><span class="line">    r = bellman_ford_op_1(g, <span class="string">'s'</span>)</span><br><span class="line">    print_f(g, r)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">has negative cycle or not? False</span><br><span class="line">vertex     distance   previous  </span><br><span class="line">s          0          None</span><br><span class="line">t          2          x</span><br><span class="line">x          4          y</span><br><span class="line">y          7          s</span><br><span class="line">z          -2         t</span><br><span class="line"></span><br><span class="line">has negative cycle or not? True</span><br><span class="line">vertex     distance   previous  </span><br><span class="line">s          0          None</span><br><span class="line">1          -4         4</span><br><span class="line">2          -3         1</span><br><span class="line">3          -2         1</span><br><span class="line">4          -6         3</span><br><span class="line">t          -4         4</span><br><span class="line"></span><br><span class="line">has negative cycle or not? True</span><br><span class="line">vertex     distance   previous  </span><br><span class="line">s          -23        2</span><br><span class="line">1          -17        3</span><br><span class="line">2          -24        4</span><br><span class="line">3          -15        t</span><br><span class="line">4          -18        3</span><br><span class="line">t          -9         4</span><br></pre></td></tr></table></figure><h1 id="dijkstra算法">Dijkstra算法</h1><p>Dijkstra算法是另一个解决单源最短路径问题的算法，该要求所有边的权重都为非负值。</p><p>Dijkstra算法在运行过程中维持的关键信息是一组结点集合S。从源节点s到该集合中每个结点之间的最短距离已经被找到。算法重复从结点集V-S中选择<strong>最短路径估计最小</strong>的结点u，将u加入到集合S，然后对所有从u发出的边进行松弛（对于边<span class="math inline">\((u,v),v\in{S}\)</span>是没有松弛的必要的，即使对之松弛，松弛一定不会成功，因为s到v的最短距离已经求出）。因为算法总是选择集合V-S中最近的结点来加入到集合S中，该算法使用的是贪心策略。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DIJKSTRA(G, w, s):</span><br><span class="line">    INITIALIZE-SINGLE-SOURCE(G, s)</span><br><span class="line">    S = empty set           <span class="comment"># 到源点s的最短距离被找到的结点集，伪代码中体现的作用不大</span></span><br><span class="line">    Q = G.V                 <span class="comment"># 初始时将所有结点放入优先队列</span></span><br><span class="line">    <span class="keyword">while</span> Q <span class="keyword">not</span> empty:</span><br><span class="line">        u = EXTRACT-MIN(Q)  <span class="comment"># 选择最短路径估计最小的结点</span></span><br><span class="line">        S = S + &#123;u&#125;         <span class="comment"># 将u加入集合S</span></span><br><span class="line">        <span class="keyword">for</span> each vertex v <span class="keyword">in</span> G.Adj[u]:     <span class="comment"># 松弛所有从u发出的边</span></span><br><span class="line">            RELAX(u, v, w)  <span class="comment"># 如果松弛成功，还要改变优先队列中结点v的减值</span></span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-algorithms/execution-of-dijkstra.png" title="Dijkstra每次迭代后的结果"></p><p>在一个结点个数为5的带权重的有向图上执行Dijkstra算法的过程如上图。</p><p>(a)~(e) 为每次while循环开始时，灰色结点为最短路径估计最小的结点。白色结点属于集合V-S。</p><p>(b)~(f) 为每次for循环结束后，阴影的边描述了前驱节点。黑色的结点属于集合S。图(f)就是最终结果。</p><h2 id="分析-1">分析</h2><p>首先分析算法的循环次数。算法调用1次INITIALIZE-SINGLE-SOURCE操作和1次初始化优先队列操作Q=G.V。之后的while循环执行次数为|V|次，因为每次循环都从最小优先队列Q中提取一个结点。因此，EXTRACT-MIN也执行了|V|次。内层的for循环对从结点u发出的边执行一次松弛操作，而在while循环过程中，u取到了图中所有的结点且各取到一次。因此for循环实际上对图中所有的边执行了1次松弛操作，即RELAX操作的执行次数为|E|。暗含在其中的降低键值DECREASE-KEY操作也执行了|E|次。</p><p>如何实现算法中的优先队列直接影响到算法的时间复杂度。在此列出3中实现下的时间复杂度分析。</p><table><thead><tr class="header"><th>实现方式</th><th>初始化代价*1</th><th>提取最小值代价*V</th><th>降低键值代价*E</th><th>Dijkstra算法总代价</th></tr></thead><tbody><tr class="odd"><td>数组</td><td><span class="math inline">\(O(V)\)</span></td><td><span class="math inline">\(O(V)\)</span>，搜索整个数组</td><td><span class="math inline">\(O(1)\)</span></td><td><span class="math inline">\(O(V^2+E)=O(V^2)\)</span></td></tr><tr class="even"><td>二叉堆</td><td><span class="math inline">\(O(V)\)</span></td><td><span class="math inline">\(O(\lg{V})\)</span>，调整队</td><td><span class="math inline">\(O(\lg{V})\)</span>，调整堆</td><td><span class="math inline">\(O((V+E)\lg{V})\)</span></td></tr><tr class="odd"><td>斐波那契堆</td><td><span class="math inline">\(O(V)\)</span></td><td><span class="math inline">\(O(\lg{V})\)</span>，摊还代价</td><td><span class="math inline">\(O(1)\)</span>，摊还代价</td><td><span class="math inline">\(O(V\lg{V}+E)\)</span></td></tr></tbody></table><p>若所有结点都可以从源节点到达（|V|&lt;|E|），则<span class="math inline">\(O((V+E)\lg{V})=O(E\lg{V})\)</span>。对于稀疏图，特别地，如果<span class="math inline">\(E=o(V^2/\lg{V})\)</span>，则使用二叉堆实现最小优先队列相对于用数组直接实现的<span class="math inline">\(O(V^2)\)</span>代价有改善。</p><p>Dijkstra算法与广度优先搜索算法及计算最小生成树的Prim算法的相似点：</p><ul><li>与广度优先搜索算法：集合S对应的是广度优先搜索中的黑色结点集合：正如集合S中的结点的最短路径权重已经计算出来一样，在广度优先搜索中，黑色结点的正确广度优先距离也已经计算出来。</li><li>与Prim算法：两个算法都使用最小优先队列来寻找集合之外“最轻”结点，将该节点加入到集合里，并对位于集合外面的结点的权重进行相应调整。</li></ul><h2 id="代码-1">代码</h2><p>使用内建的优先队列时的妥协：</p><p>因为无法改变优先队列中的键值（或者说改变了也没有意义，优先队列不会调整结点在队列中的先后顺序），所以在初始时<span class="math inline">\(Q\neq{G.V}\)</span>，而是只将源点s放入优先队列。之后在松弛过程中，若发现集合S中不存在的结点，再将之放入优先队列。</p><p>但这也随之产生了一个问题：多条不同的边可能指向同一个集合S外的结点u，当这些边成功松弛多次时，结点u被多次加入队列中（因为内建的优先队列没有提供DECREASE-KEY操作，只能通过重复放入的方式更新键值）。这些重复加入的结点u携带不同的键值，显然，因最近一次松弛成功而被加入队列的结点u携带最小的键值。携带较大键值的结点u对算法没有意义，但它们仍然存在于队列中。因此，在循环开始时对取得的结点进行判断：若u结点在visit集合中，说明源结点s到u的最短距离已经求出，跳过这样的结点。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue</span><br><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"><span class="keyword">from</span> graph.bellman_ford <span class="keyword">import</span> initialize_single_source, relax, print_f</span><br><span class="line"><span class="keyword">from</span> data_structure.fib_heap <span class="keyword">import</span> FibHeap, Node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dijkstra_queue</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    <span class="string">"""使用优先队列"""</span></span><br><span class="line">    initialize_single_source(graph, s)</span><br><span class="line">    visit, q = set(), PriorityQueue()  <span class="comment"># visit：集合S</span></span><br><span class="line">    q.put((graph.nodes[s][<span class="string">'distance'</span>], s))  <span class="comment"># 初始时s入队列</span></span><br><span class="line">    <span class="keyword">while</span> q.empty() <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">        u = q.get()[<span class="number">1</span>]  <span class="comment"># 选择最近的节点u</span></span><br><span class="line">        <span class="keyword">if</span> u <span class="keyword">not</span> <span class="keyword">in</span> visit:</span><br><span class="line">            visit.add(u)</span><br><span class="line">            <span class="keyword">for</span> v, e_attr <span class="keyword">in</span> graph[u].items():</span><br><span class="line">                <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> visit:  <span class="comment"># 已经访问过的顶点无需入队列</span></span><br><span class="line">                    relax(graph, u, v, e_attr[<span class="string">'weight'</span>])  <span class="comment"># relax最近顶点u的临界点</span></span><br><span class="line">                    q.put((graph.nodes[v][<span class="string">'distance'</span>], v))  <span class="comment"># 临接顶点入队列，同一顶点可能带有不同的distance值多次入队列</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dijkstra_fibonacci</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    <span class="string">"""使用斐波那契堆优化算法"""</span></span><br><span class="line">    initialize_single_source(graph, s)</span><br><span class="line">    m, visit, heap = &#123;&#125;, set(), FibHeap()  <span class="comment"># m：顶点到堆中结点的映射&#123;v.key:Node&#125;</span></span><br><span class="line">    <span class="keyword">for</span> v, v_attr <span class="keyword">in</span> graph.nodes.items():  <span class="comment"># 所有顶点入堆</span></span><br><span class="line">        n = Node(v_attr[<span class="string">'distance'</span>])</span><br><span class="line">        n.v = v  <span class="comment"># 为fibonacci node添加属性v，记录指向顶点的指针</span></span><br><span class="line">        heap.insert(n)</span><br><span class="line">        m[v] = n</span><br><span class="line">    <span class="keyword">while</span> heap.n &gt; <span class="number">0</span>:  <span class="comment"># 实际上循环|V|-1次，等价于for i in range(len(g.get_v_set()))</span></span><br><span class="line">        u = heap.pop().v  <span class="comment"># 选择最近的节点u</span></span><br><span class="line">        visit.add(u)</span><br><span class="line">        <span class="keyword">for</span> v, e_attr <span class="keyword">in</span> graph[u].items():</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> visit:</span><br><span class="line">                relax(graph, u, v, e_attr[<span class="string">'weight'</span>])</span><br><span class="line">                heap.decrease_key(m[v], graph.nodes[v][<span class="string">'distance'</span>])  <span class="comment"># 修改heap中对应节点的key值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># Dijkstra示例</span></span><br><span class="line">    g = nx.DiGraph()</span><br><span class="line">    g.add_nodes_from(<span class="string">'s12345t'</span>)</span><br><span class="line">    edges = [(<span class="string">'s'</span>, <span class="string">'1'</span>, <span class="number">2</span>), (<span class="string">'s'</span>, <span class="string">'2'</span>, <span class="number">3</span>), (<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="number">4</span>), (<span class="string">'1'</span>, <span class="string">'3'</span>, <span class="number">8</span>), (<span class="string">'1'</span>, <span class="string">'4'</span>, <span class="number">5</span>), (<span class="string">'2'</span>, <span class="string">'4'</span>, <span class="number">3</span>), (<span class="string">'2'</span>, <span class="string">'5'</span>, <span class="number">4</span>),</span><br><span class="line">             (<span class="string">'3'</span>, <span class="string">'4'</span>, <span class="number">2</span>), (<span class="string">'3'</span>, <span class="string">'t'</span>, <span class="number">9</span>), (<span class="string">'4'</span>, <span class="string">'t'</span>, <span class="number">6</span>), (<span class="string">'5'</span>, <span class="string">'t'</span>, <span class="number">10</span>)]</span><br><span class="line">    g.add_weighted_edges_from(edges)</span><br><span class="line">    dijkstra_queue(g, <span class="string">'s'</span>)</span><br><span class="line">    print_f(g)</span><br><span class="line"></span><br><span class="line">    g.clear()</span><br><span class="line">    g.add_nodes_from(<span class="string">'stxyz'</span>)</span><br><span class="line">    edges = [(<span class="string">'s'</span>, <span class="string">'t'</span>, <span class="number">10</span>), (<span class="string">'s'</span>, <span class="string">'y'</span>, <span class="number">5</span>), (<span class="string">'t'</span>, <span class="string">'x'</span>, <span class="number">1</span>), (<span class="string">'t'</span>, <span class="string">'y'</span>, <span class="number">2</span>), (<span class="string">'x'</span>, <span class="string">'z'</span>, <span class="number">4</span>), (<span class="string">'y'</span>, <span class="string">'t'</span>, <span class="number">3</span>), (<span class="string">'y'</span>, <span class="string">'x'</span>, <span class="number">9</span>),</span><br><span class="line">             (<span class="string">'y'</span>, <span class="string">'z'</span>, <span class="number">2</span>), (<span class="string">'z'</span>, <span class="string">'s'</span>, <span class="number">7</span>), (<span class="string">'z'</span>, <span class="string">'x'</span>, <span class="number">6</span>)]</span><br><span class="line">    g.add_weighted_edges_from(edges)</span><br><span class="line">    dijkstra_fibonacci(g, <span class="string">'s'</span>)</span><br><span class="line">    print_f(g)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vertex     distance   previous  </span><br><span class="line">s          0          None</span><br><span class="line">1          2          s</span><br><span class="line">2          3          s</span><br><span class="line">3          10         1</span><br><span class="line">4          6          2</span><br><span class="line">5          7          2</span><br><span class="line">t          12         4</span><br><span class="line"></span><br><span class="line">vertex     distance   previous  </span><br><span class="line">s          0          None</span><br><span class="line">t          8          y</span><br><span class="line">x          9          t</span><br><span class="line">y          5          s</span><br><span class="line">z          7          y</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Algorithms </tag>
            
            <tag> algorithms </tag>
            
            <tag> fibonacci heap </tag>
            
            <tag> greedy method </tag>
            
            <tag> priority queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树</title>
      <link href="/notes/introduction-to-algorithms/binary-search-trees/"/>
      <url>/notes/introduction-to-algorithms/binary-search-trees/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉搜索树">二叉搜索树</h1><p>一棵二叉搜索树是以一棵二叉树来组织的。每个结点除了key之外，还包含属性left、right、p，分别指向结点的左孩子、右孩子和父节点。如果父节点或者子节点不存在，则相应属性值为NIL。根节点是唯一父节点为NIL的结点。</p><h1 id="性质">性质</h1><p>二叉搜索树性质：</p><p>设x是二叉搜索树中的一个结点。如果y是x左子树中的一个结点，那么<span class="math inline">\(y.key\le{x.key}\)</span>。如果y是x右子树中的一个结点，那么<span class="math inline">\(y.key\ge{x.key}\)</span>。</p><p>根据此性质，可以通过中序遍历（inorder tree walk）算法按序输出二叉搜索树中的所有关键字。比较简单的递归实现如下：</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INORDER-TREE-WALK(x):</span><br><span class="line">    <span class="keyword">if</span> x != NIL:</span><br><span class="line">        INORDER-TREE-WALK(x.left)</span><br><span class="line">        <span class="keyword">print</span> x.key</span><br><span class="line">        INORDER-TREE-WALK(x.right)</span><br></pre></td></tr></table></figure><p>包含相同结点的两棵高度不同的二叉搜索树。大部分搜索树操作的运行时间与树的高度成正比。因此(b)比(a)低效。</p><p><img src="/uploads/image/introduction-to-algorithms/binary-search-trees.png" title="二叉搜索树"></p><h1 id="操作">操作</h1><h2 id="查找">查找</h2><p>使用下面的过程在一棵二叉搜索树中查找一个具有给定关键字的结点。输入一个指向树根的指针x和一个关键字k，如果这个结点存在，返回一个指向关键字为k的结点的指针；否则返回NIL。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">TREE-SEARCH(x, k):</span><br><span class="line">    <span class="keyword">if</span> x == NIL <span class="keyword">or</span> k == x.key:  <span class="comment"># 如果关键字与k相等，返回结果</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">if</span> k &lt; x.key:               <span class="comment"># 如果关键字大于k，查找在左子树中继续</span></span><br><span class="line">        <span class="keyword">return</span> TREE-SEARCH(x.left, k)   <span class="comment"># 递归</span></span><br><span class="line">    <span class="keyword">else</span>:                       <span class="comment"># 如果关键字小于k，查找在右子树中继续</span></span><br><span class="line">        <span class="keyword">return</span> TREE-SEARCH(x.right, k)</span><br></pre></td></tr></table></figure><p>可以采用循环来展开递归，用一种迭代方式重写此过程。对于大多数计算机，迭代版本的效率要高得多。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ITERATIVE-TREE-SEARCH(x, k):</span><br><span class="line">    <span class="keyword">while</span> x != NIL <span class="keyword">and</span> k != x.key:  <span class="comment"># 迭代实现：如果关键字与k不相等，重复循环</span></span><br><span class="line">        <span class="keyword">if</span> k &lt; x.key:               <span class="comment"># 如果关键字大于k，查找在左子树中继续</span></span><br><span class="line">            x = x.left</span><br><span class="line">        <span class="keyword">else</span>:                       <span class="comment"># 否则，在右子树中继续</span></span><br><span class="line">            x = x.right</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-algorithms/binary-search-tree-search.png" title="搜索键值等于13的结点"></p><p>例如在如上图所示的二叉查找树中查找键值为13的查找路径是<span class="math inline">\(15\rightarrow6\rightarrow7\rightarrow13\)</span>。具体步骤为：</p><ol type="1"><li>x指向根节点，比较x与13。13&lt;15：x指向x.left，在左子树中继续查找。</li><li>13&gt;6：x指向x.right，在右子树中继续查找。</li><li>13&gt;7：x指向x.right，在右子树中继续查找。</li><li>13=13：返回x。</li></ol><h3 id="最大和最小关键字">最大和最小关键字</h3><p>查找最小关键字元素：从根开始沿着left孩子指针直到遇到一个NIL。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">TREE-MINIMUM(X):</span><br><span class="line">    <span class="keyword">while</span> x.left != NIL:  <span class="comment"># 假设x != NIL，不停查找左子树</span></span><br><span class="line">        x = x.left</span><br><span class="line">    <span class="keyword">return</span> x              <span class="comment"># 当x的左子树为NIL时，x为最小关键字元素</span></span><br></pre></td></tr></table></figure><p>查找最大关键字的TREE-MAXIMUM的伪代码是对称的，如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">TREE-MAXIMUM(x):</span><br><span class="line">    <span class="keyword">while</span> x.right != NIL:</span><br><span class="line">        x = x.right</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h3 id="后继和前驱">后继和前驱</h3><p>给定一棵二叉搜索树中的一个结点，有时候需要按中序遍历的次序查找它的后继。如果所有的关键字互不相同，则一个结点x的<strong>后继</strong>是大于x.key的最小关键字的结点。二叉搜索树的性质允许我们通过没有任何关键字的比较来确定一个结点的后继。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">TREE-SUCCESSOR(x):</span><br><span class="line">    <span class="keyword">if</span> x.right != NIL:  <span class="comment"># 如果x的右子树不为空，根据性质，右子树中的关键字均大于x的关键字</span></span><br><span class="line">        <span class="keyword">return</span> TREE-MINIMUM(x.right)  <span class="comment"># 此时x的后继为右子树中最小的结点</span></span><br><span class="line">    y = x.p  <span class="comment"># 如果右子树为空，那么x的后继是 x的有左孩子的最底层祖先（回想中序遍历次序）</span></span><br><span class="line">    <span class="keyword">while</span> y != NIL <span class="keyword">and</span> x == y.right:</span><br><span class="line">        x = y</span><br><span class="line">        y = y.p</span><br><span class="line">    <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><p>查找<strong>前驱</strong>的TREE-PREDECESSOR的伪代码是对称的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">TREE-PREDECESSOR(x):</span><br><span class="line">    <span class="keyword">if</span> x.left != NIL:</span><br><span class="line">        <span class="keyword">return</span> TREE-MAXIMUM(x.left)</span><br><span class="line">    y = x.p</span><br><span class="line">    <span class="keyword">while</span> y != NIL <span class="keyword">and</span> x == y.left:</span><br><span class="line">        x = y</span><br><span class="line">        y = y.p</span><br><span class="line">    <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><h2 id="插入和删除">插入和删除</h2><p>插入和删除操作会引起由二叉搜索树表示的动态集合的变化（二叉搜索树中的元素集合会变化）。一定要修改指针以保持二叉搜索树性质的成立。</p><h3 id="插入">插入</h3><p>插入操作相对简单些。将结点z插入到树中的相应位置上，这个过程要修改T和z的某些属性。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">TREE-INSERT(T, z):</span><br><span class="line">    y = NIL</span><br><span class="line">    x = T.root            <span class="comment"># 找到z在树中的位置</span></span><br><span class="line">    <span class="keyword">while</span> x != NIL:</span><br><span class="line">        y = x</span><br><span class="line">        <span class="keyword">if</span> z.key &lt; x.key:</span><br><span class="line">            x = x.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x = x.right</span><br><span class="line">    z.p = y               <span class="comment"># 找到z的位置时，y为z在树中的父节点</span></span><br><span class="line">    <span class="keyword">if</span> y == NIL:          <span class="comment"># 如果父节点为NIL，说明在插入前二叉搜索树是空的</span></span><br><span class="line">        T.root = z</span><br><span class="line">    <span class="keyword">elif</span> z.key &lt; y.key:   <span class="comment"># 判断z与父节点y的大小关系，决定z称为左孩子还是右孩子</span></span><br><span class="line">        y.left = z</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        y.right = z</span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-algorithms/binary-search-tree-insert.png" title="插入一个键值等于13的新结点"></p><p>例如在如上图所示的二叉查找树中插入键值为13的结点。步骤为：</p><ol type="1"><li>x指向根节点。比较x的键值与欲插入的键值13的大小关系：12&lt;13：x指向x.right。意味着，结点13应该在根节点的右子树中。</li><li>x.key=18，18&gt;13：x指向x.left。</li><li>x.key=15，15&gt;13：x指向x.left。</li><li>x=NIL，x就是结点13应该插入的位置。修改相应指针完成插入操作。</li></ol><h3 id="删除">删除</h3><p>从一棵二叉搜索树T中删除一个结点z时需要考虑三种基本情况。</p><ul><li>如果z没有孩子结点。</li><li>如果z只有一个孩子。</li><li>如果z既有左孩子又有右孩子。</li></ul><p>在具体的删除操作中，则需要考虑4中情况，它与上面的三种情况有些不同。</p><ul><li><ol type="a"><li>若z的左孩子为空，那么用其右孩子来替换z，这个右孩子可以是NIL。为NIL时对应上面的第一种情况；不为NIL时对应第二种情况。</li></ol></li><li><ol start="2" type="a"><li>若z的右孩子为空，那么用其左孩子来替换z。</li></ol><p>否则，z既有左孩子又有右孩子。需要查找z的后继节点y（这个后继位于z的右子树中并且没有左孩子）。</p></li><li><ol start="3" type="a"><li>若y是z的右孩子，那么用y替换z，并仅留下y的右孩子。</li></ol></li><li><ol start="4" type="a"><li>若y位于z的右子树中但并不是z的右孩子。在这种情况下，先用y的右孩子替换y，然后再用y替换z。</li></ol></li></ul><p><img src="/uploads/image/introduction-to-algorithms/binary-search-tree-delete.png" title="删除结点的4种情况"></p><p>为了在二叉搜索树内移动子树，定义一个子过程TRANSPLANT。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">TRANSPLANT(T, u, v):        <span class="comment"># 用根节点为v的子树替换根节点为u的子树</span></span><br><span class="line">    <span class="keyword">if</span> u.p == NIL:          <span class="comment"># 若u为根节点，则子树的替换实际上就是整棵树的替换</span></span><br><span class="line">        T.root = v          <span class="comment"># 因而，只需修改树的root属性</span></span><br><span class="line">    <span class="keyword">elif</span> u == u.p.left:     <span class="comment"># 若u是左孩子</span></span><br><span class="line">        u.p.left = v        <span class="comment"># 修改父节点左孩子指针</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        u.p.right = v       <span class="comment"># 否则修改右孩子指针</span></span><br><span class="line">    <span class="keyword">if</span> v != NIL:            <span class="comment"># 若v不为空，修改v的父节点指针</span></span><br><span class="line">        v.p = u.p</span><br></pre></td></tr></table></figure><p>注意到，TRANSPLANT并没有处理v.left和v.right的更新，这些更新都由TRANSPLANT的调用者来负责。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">TREE-DELETE(T, z):</span><br><span class="line">    <span class="keyword">if</span> z.left == NIL:                  <span class="comment"># 情况(a)：左孩子为空</span></span><br><span class="line">        TRANSPLANT(T, z, z.right)      <span class="comment"># 用右孩子替换</span></span><br><span class="line">    <span class="keyword">elif</span> z.right == NIL:               <span class="comment"># 情况(b):右孩子为空</span></span><br><span class="line">        TRANSPLANT(T, z, z.left)       <span class="comment"># 用左孩子替换</span></span><br><span class="line">    <span class="keyword">else</span>:                              <span class="comment"># 既有左孩子又有右孩子</span></span><br><span class="line">        y = TREE-MINIMUM(z.right)      <span class="comment"># 查找z的后继y</span></span><br><span class="line">        <span class="keyword">if</span> y.p != z:                   <span class="comment"># 情况(d)：如果y不是z的右孩子</span></span><br><span class="line">            TRANSPLANT(T, y, y.right)  <span class="comment"># 用y的右孩子替换y</span></span><br><span class="line">            y.right = z.right          <span class="comment"># 修改y的右孩子指针</span></span><br><span class="line">            y.right.p = y              <span class="comment"># 将原来z的孩子结点的父节点指针指向y</span></span><br><span class="line">        TRANSPLANT(T, z, y)            <span class="comment"># 情况(c)：y是z的子节点，用y替换z，也是(d)的第二步替换</span></span><br><span class="line">        y.left = z.left                <span class="comment"># 修改y的指针属性</span></span><br><span class="line">        y.left.p = y</span><br></pre></td></tr></table></figure><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> data_structure.binary_tree <span class="keyword">import</span> BinaryTree, Node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span><span class="params">(BinaryTree)</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(x, k)</span>:</span></span><br><span class="line">        <span class="string">"""在根节点为x的子树中迭代查找键值为k的结点"""</span></span><br><span class="line">        <span class="keyword">while</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> k != x.key:</span><br><span class="line">            <span class="keyword">if</span> k &lt; x.key:</span><br><span class="line">                x = x.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x = x.right</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimum</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="string">"""返回以x为根节点的子树中键值最小的结点，x为空时返回None"""</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">while</span> x.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                x = x.left</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximum</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="string">""""返回子树中键值最大的结点"""</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">while</span> x.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                x = x.right</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">successor</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""返回结点x的后继结点"""</span></span><br><span class="line">        <span class="keyword">if</span> x.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self.minimum(x.right)</span><br><span class="line">        y = x.p</span><br><span class="line">        <span class="keyword">while</span> y <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> x == y.right:</span><br><span class="line">            x, y = y, y.p</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predecessor</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""返回前驱"""</span></span><br><span class="line">        <span class="keyword">if</span> x.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self.maximum(x.left)</span><br><span class="line">        y = x.p</span><br><span class="line">        <span class="keyword">while</span> y <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> x == y.left:</span><br><span class="line">            x, y = y, y.p</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, z)</span>:</span></span><br><span class="line">        <span class="string">"""插入结点z"""</span></span><br><span class="line">        y, x = <span class="literal">None</span>, self.root</span><br><span class="line">        <span class="keyword">while</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            y = x</span><br><span class="line">            <span class="keyword">if</span> z.key &lt; x.key:</span><br><span class="line">                x = x.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x = x.right</span><br><span class="line">        z.p = y</span><br><span class="line">        <span class="keyword">if</span> y <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.root = z</span><br><span class="line">        <span class="keyword">elif</span> z.key &lt; y.key:</span><br><span class="line">            y.left = z</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            y.right = z</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transplant</span><span class="params">(self, u, v)</span>:</span></span><br><span class="line">        <span class="string">"""用v替换u"""</span></span><br><span class="line">        <span class="keyword">if</span> u.p <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.root = v</span><br><span class="line">        <span class="keyword">elif</span> u == u.p.left:</span><br><span class="line">            u.p.left = v</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            u.p.right = v</span><br><span class="line">        <span class="keyword">if</span> v <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            v.p = u.p</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, z)</span>:</span></span><br><span class="line">        <span class="string">"""删除结点z"""</span></span><br><span class="line">        <span class="keyword">if</span> z.left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.transplant(z, z.right)</span><br><span class="line">        <span class="keyword">elif</span> z.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.transplant(z, z.left)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            y = self.minimum(z.right)</span><br><span class="line">            <span class="keyword">if</span> y.p != z:</span><br><span class="line">                self.transplant(y, y.right)</span><br><span class="line">                y.right, y.right.p = z.right, y</span><br><span class="line">            self.transplant(z, y)</span><br><span class="line">            y.left, y.left.p = z.left, y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    key = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">18</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">15</span>, <span class="number">19</span>, <span class="number">17</span>, <span class="number">3</span>, <span class="number">21</span>]</span><br><span class="line">    n = &#123;i: Node(i) <span class="keyword">for</span> i <span class="keyword">in</span> key&#125;</span><br><span class="line">    bst = BinarySearchTree()</span><br><span class="line">    [bst.insert(n[i]) <span class="keyword">for</span> i <span class="keyword">in</span> key]</span><br><span class="line">    print(<span class="string">'初始    '</span>, bst)</span><br><span class="line">    print(<span class="string">'查找 8  '</span>, bst.search(bst.root, <span class="number">8</span>))  <span class="comment"># 在整棵树中搜索</span></span><br><span class="line">    print(<span class="string">'查找 9  '</span>, bst.search(bst.root, <span class="number">9</span>))</span><br><span class="line">    print(<span class="string">'12的前驱'</span>, bst.predecessor(n[<span class="number">12</span>]))  <span class="comment"># 前驱</span></span><br><span class="line">    print(<span class="string">'12的后继'</span>, bst.successor(n[<span class="number">12</span>]))  <span class="comment"># 后继</span></span><br><span class="line">    n[<span class="number">8</span>] = Node(<span class="number">8</span>)</span><br><span class="line">    bst.insert(n[<span class="number">8</span>])  <span class="comment"># 插入</span></span><br><span class="line">    print(<span class="string">'插入 8后'</span>, bst)</span><br><span class="line">    bst.delete(n[<span class="number">3</span>])  <span class="comment"># 情况(a)，只有右孩子</span></span><br><span class="line">    print(<span class="string">'删除 3后'</span>, bst)</span><br><span class="line">    bst.delete(n[<span class="number">8</span>])  <span class="comment"># 情况(a)，只有左孩子</span></span><br><span class="line">    print(<span class="string">'删除 8后'</span>, bst)</span><br><span class="line">    bst.delete(n[<span class="number">18</span>])  <span class="comment"># 情况(c)，有右孩子结点19，且右孩子是其后继结点</span></span><br><span class="line">    print(<span class="string">'删除18后'</span>, bst)</span><br><span class="line">    bst.delete(n[<span class="number">12</span>])  <span class="comment"># 情况(d)，后继结点是15</span></span><br><span class="line">    print(<span class="string">'删除12后'</span>, bst)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">初始     &#123;12: [&#123;5: [&#123;2: [None, 3]&#125;, 9]&#125;, &#123;18: [&#123;15: [None, 17]&#125;, &#123;19: [None, 21]&#125;]&#125;]&#125;</span><br><span class="line">查找 8   None</span><br><span class="line">查找 9   9</span><br><span class="line">12的前驱 9</span><br><span class="line">12的后继 15</span><br><span class="line">插入 8后 &#123;12: [&#123;5: [&#123;2: [None, 3]&#125;, &#123;9: [8, None]&#125;]&#125;, &#123;18: [&#123;15: [None, 17]&#125;, &#123;19: [None, 21]&#125;]&#125;]&#125;</span><br><span class="line">删除 3后 &#123;12: [&#123;5: [2, &#123;9: [8, None]&#125;]&#125;, &#123;18: [&#123;15: [None, 17]&#125;, &#123;19: [None, 21]&#125;]&#125;]&#125;</span><br><span class="line">删除 8后 &#123;12: [&#123;5: [2, 9]&#125;, &#123;18: [&#123;15: [None, 17]&#125;, &#123;19: [None, 21]&#125;]&#125;]&#125;</span><br><span class="line">删除18后 &#123;12: [&#123;5: [2, 9]&#125;, &#123;19: [&#123;15: [None, 17]&#125;, 21]&#125;]&#125;</span><br><span class="line">删除12后 &#123;15: [&#123;5: [2, 9]&#125;, &#123;19: [17, 21]&#125;]&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Algorithms </tag>
            
            <tag> data structures </tag>
            
            <tag> binary tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有根树</title>
      <link href="/notes/introduction-to-algorithms/rooted-trees/"/>
      <url>/notes/introduction-to-algorithms/rooted-trees/</url>
      
        <content type="html"><![CDATA[<h1 id="有根树">有根树</h1><p>表示链表的方法可以推广到任意同构的数据结构上。树的结点用对象表示。与链表类似，每个结点都含有一个关键字key。其余的属性包括指向其他结点的指针，它们随树的种类不同会有所变化。</p><p>链表的结点：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Node:</span><br><span class="line">    key       <span class="comment"># 结点自身的键值</span></span><br><span class="line">    previous  <span class="comment"># 前驱节点</span></span><br><span class="line">    next      <span class="comment"># 后继结点</span></span><br></pre></td></tr></table></figure><h1 id="二叉树">二叉树</h1><p>二叉树的结点：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Node:</span><br><span class="line">    key    <span class="comment"># 键值</span></span><br><span class="line">    p      <span class="comment"># 父节点，只有根节点的父节点为NIL</span></span><br><span class="line">    left   <span class="comment"># 左孩子，若没有左孩子，则该属性为NIL</span></span><br><span class="line">    right  <span class="comment"># 右孩子，若没有右孩子，则该属性为NIL</span></span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="/uploads/image/introduction-to-algorithms/binary-tree.png" title="二叉树的表示方法"></p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.p = self.left = self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_left</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.left, n.p = n, self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_right</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.right, n.p = n, self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.values(self.root))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">values</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""递归得到以当前结点为根节点的子树中所有结点的值"""</span></span><br><span class="line">        v, c = [], <span class="number">0</span>  <span class="comment"># c：孩子个数</span></span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            v.append(self.values(node.left))</span><br><span class="line">            c += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            v.append(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            v.append(self.values(node.right))</span><br><span class="line">            c += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            v.append(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> c &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;node.key: v&#125;</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> node.key</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    key = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">    n = [Node(i) <span class="keyword">for</span> i <span class="keyword">in</span> key]</span><br><span class="line">    t = BinaryTree()</span><br><span class="line">    t.root = n[<span class="number">0</span>]</span><br><span class="line">    n[<span class="number">0</span>].set_left(n[<span class="number">1</span>])</span><br><span class="line">    n[<span class="number">0</span>].set_right(n[<span class="number">2</span>])</span><br><span class="line">    n[<span class="number">1</span>].set_right(n[<span class="number">3</span>])</span><br><span class="line">    n[<span class="number">2</span>].set_left(n[<span class="number">4</span>])</span><br><span class="line">    n[<span class="number">2</span>].set_right(n[<span class="number">5</span>])</span><br><span class="line">    n[<span class="number">3</span>].set_left(n[<span class="number">6</span>])</span><br><span class="line">    n[<span class="number">3</span>].set_right(n[<span class="number">7</span>])</span><br><span class="line">    n[<span class="number">4</span>].set_right(n[<span class="number">8</span>])</span><br><span class="line">    n[<span class="number">5</span>].set_left(n[<span class="number">9</span>])</span><br><span class="line">    n[<span class="number">8</span>].set_left(n[<span class="number">10</span>])</span><br><span class="line">    print(t)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">0</span>: [&#123;<span class="number">1</span>: [<span class="literal">None</span>, &#123;<span class="number">3</span>: [<span class="number">6</span>, <span class="number">7</span>]&#125;]&#125;, &#123;<span class="number">2</span>: [&#123;<span class="number">4</span>: [<span class="literal">None</span>, &#123;<span class="number">8</span>: [<span class="number">10</span>, <span class="literal">None</span>]&#125;]&#125;, &#123;<span class="number">5</span>: [<span class="number">9</span>, <span class="literal">None</span>]&#125;]&#125;]&#125;</span><br></pre></td></tr></table></figure><h1 id="分支无限制的有根树">分支无限制的有根树</h1><p>二叉树的表示方法可以推广到每个结点的孩子数至多为常数k的任意类型的树：只需要将left和right属性用<code>child1，child2，...，childk</code>代替。缺点是，若大部分结点只有少量的孩子，则会浪费大量存储空间（大量无意义的孩子指针）。此外，若孩子的结点数无限制时，此方法失效。所幸的是，有一个巧妙地方法可以用来表示孩子数任意的树。</p><p><strong>左孩子右兄弟表示法</strong>（left-child, right-sibling representation）：对任意n个结点的有根树，只需要O(n)的存储空间。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Node:</span><br><span class="line">    key              <span class="comment"># 键值</span></span><br><span class="line">    p                <span class="comment"># 父节点，若为根节点，则为NIL</span></span><br><span class="line">    left-child       <span class="comment"># 最左边的孩子结点，若没有孩子结点，则为NIL</span></span><br><span class="line">    right-sibling    <span class="comment"># 右侧相邻的兄弟结点，若是其父节点的最右孩子，则为NIL</span></span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-algorithms/tree-with-unbounded-branching.png" title="不限分支数的有根树的表示方法"></p><h2 id="代码-1">代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> data_structure.binary_tree <span class="keyword">import</span> Node <span class="keyword">as</span> Ne</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(Ne)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_child</span><span class="params">(self, c)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.set_left(c)  <span class="comment"># 添加第一个孩子</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 追加孩子</span></span><br><span class="line">            x = self.left</span><br><span class="line">            <span class="keyword">while</span> x.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment"># 寻找追加位置</span></span><br><span class="line">                x = x.right</span><br><span class="line">            x.right, c.p = c, self  <span class="comment"># 添加指针</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        self.root = root</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.values(self.root))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">values</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 没有孩子节点</span></span><br><span class="line">            <span class="keyword">return</span> node.key</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c = node.left</span><br><span class="line">            v = [self.values(c)]  <span class="comment"># 所有孩子组成的列表</span></span><br><span class="line">            <span class="keyword">while</span> c.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                v.append(self.values(c.right))</span><br><span class="line">                c = c.right</span><br><span class="line">            <span class="keyword">return</span> &#123;node.key: v&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    key = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line">    n = [Node(i) <span class="keyword">for</span> i <span class="keyword">in</span> key]</span><br><span class="line">    t = Tree(n[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        n[<span class="number">0</span>].add_child(n[i])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>, <span class="number">6</span>):</span><br><span class="line">        n[<span class="number">1</span>].add_child(n[i])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>, <span class="number">10</span>):</span><br><span class="line">        n[<span class="number">2</span>].add_child(n[i])</span><br><span class="line">    n[<span class="number">3</span>].add_child(n[<span class="number">10</span>])</span><br><span class="line">    n[<span class="number">5</span>].add_child(n[<span class="number">11</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">12</span>, <span class="number">14</span>):</span><br><span class="line">        n[<span class="number">8</span>].add_child(n[i])</span><br><span class="line">    print(t)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;0: [&#123;1: [4, &#123;5: [11]&#125;]&#125;, &#123;2: [6, 7, &#123;8: [12, 13]&#125;, 9]&#125;, &#123;3: [10]&#125;]&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Algorithms </tag>
            
            <tag> data structures </tag>
            
            <tag> binary tree </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/notes/introduction-to-algorithms/linked-lists/"/>
      <url>/notes/introduction-to-algorithms/linked-lists/</url>
      
        <content type="html"><![CDATA[<h1 id="链表">链表</h1><p>链表（linked list）中的各元素按线性顺序排列。数据的线性顺序是由数组下标决定的，然而与数组不同的是，链表的顺序是由各个对象里的指针决定的。链表为动态集合提供了一种简单而灵活的表示方法。</p><h1 id="种类">种类</h1><p>链表可以有多种形式。它可以是单链接的或双链接的，可以是已排序的或未排序的，可以是循环的或非循环的。</p><ul><li><p>双向链表（doubly linked list）L的每个元素都是一个对象，每个对象有一个关键字k和两个指针：next和prev。对象中还可以包含其他辅助数据（或称为卫星数据）。设x为链表的一个元素，x.next指向它在链表中的后继元素，x.prev则指向它的前驱元素。如果x.prev=NIL，则元素x没有前驱，因此是链表的第一个元素，即链表的头（head）。如果x.next=NIL，则元素x没有后继，因此是链表的最后一个元素，即链表的尾（tail）。属性L.head指向链表的第一个元素。如果L.head=NIL，则链表为空。</p><p><img src="/uploads/image/introduction-to-algorithms/linked-list.png" title="链表"></p></li><li><p>单链接的（single linked）：省略每个元素中的prev指针。</p></li></ul><a id="more"></a><ul><li>已排序（sorted）的：链表的线性顺序与链表元素中关键字的线性顺序一致。据此，最小的元素就是表头元素，而最大的元素则是表尾元素。</li><li><p>未排序（unsorted）的：链表的各元素可以以任何顺序出现。</p></li><li><p>循环链表（circular list）：表头元素的prev指针指向表尾元素，而表尾元素的next指针则指向表头元素。可以将循环链表想象成一个各元素组成的圆环。</p></li></ul><h1 id="操作">操作</h1><h2 id="搜索">搜索</h2><p>过程LIST-SEARCH采用简单的线性搜索方法，用于查找链表L中第一个关键字为k的元素，并返回指向该元素的指针。如果链表中没有关键字为k的对象，则返回NIL。要搜索一个有n个对象的链表，过程LIST-SEARCH在最坏情况下的运行时间为<span class="math inline">\(\Theta(n)\)</span>，因为可能需要搜索整个链表。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">LIST-SEARCH(L, k):</span><br><span class="line">    x = L.head</span><br><span class="line">    <span class="keyword">while</span> x != NIL <span class="keyword">and</span> x.key != k:</span><br><span class="line">        x = x.next</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h2 id="插入">插入</h2><p>给定一个元素x，过程LIST-INSERT将x”连接入“到链表的前端。在一个含n个元素的链表上执行LIST-INSERT的运行时间是<span class="math inline">\(\Theta(1)\)</span>。例如，在(a)所示的链表中插入键值为25的元素。插入后的链表如(b)所示。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">LIST-INSERT(L, x):</span><br><span class="line">    x.next = L.head      <span class="comment"># 将x的后继元素指向当前head</span></span><br><span class="line">    <span class="keyword">if</span> L.head != NIL:    <span class="comment"># 若当前head不为NIL</span></span><br><span class="line">        L.head.prev = x  <span class="comment"># 修改head的前驱元素为x</span></span><br><span class="line">    L.head = x           <span class="comment"># 更改链表的表头元素</span></span><br><span class="line">    x.prev = NIL         <span class="comment"># 修改x的前驱元素为NIL</span></span><br></pre></td></tr></table></figure><h2 id="删除">删除</h2><p>过程LIST-DELETE将一个元素x从链表L中移除。通过修改一些指针，将x“删除出”该链表。如果要删除具有给定关键字值的元素，则必须先调用LIST-SEARCH找到该元素。LIST-DELETE的运行时间为<span class="math inline">\(\Theta(1)\)</span>。例如，在(b)所示的链表中删除键值为4的元素，删除后的链表如(c)所示。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">LIST-DELETE(L, x):</span><br><span class="line">    <span class="keyword">if</span> x.prev != NIL:          <span class="comment"># 如果x不是表头元素</span></span><br><span class="line">        x.prev.next = x.next   <span class="comment"># 修改x的前驱中的后继指针</span></span><br><span class="line">    <span class="keyword">else</span>:                      <span class="comment"># 如果x是表头元素，则x没有前驱</span></span><br><span class="line">        L.head = x.next        <span class="comment"># 直接修改表头指针</span></span><br><span class="line">    <span class="keyword">if</span> x.next != NIL:          <span class="comment"># 如果x有后继元素</span></span><br><span class="line">        x.next.prev = x.prev   <span class="comment"># 修改后继元素的前驱指针</span></span><br></pre></td></tr></table></figure><h2 id="哨兵">哨兵</h2><p>哨兵（sentinel）是一个哑对象，其作用是简化边界条件的处理。在链表L中设置一个哨兵L.nil，对于链表代码中出现的每一处（表头和表尾）对NIL的引用，都代之以对哨兵L.nil的引用，即表头元素的prev指针和表尾的next指针均指向L.nil。这样的调整将一个常规的双向链表转变为一个<strong>有哨兵的双向循环链表</strong>（circular, doubly linked list with a sentinel），哨兵位于表头和表尾之间。属性L.nil.next指向表头，L.nil.prev指向表尾。一个空链表只由一个哨兵构成，L.nil.next和L.nil.prev同时指向L.nil。</p><p><img src="/uploads/image/introduction-to-algorithms/circular-doubly-linked-list-with-a-sentinel.png" title="有哨兵的双向循环链表"></p><p>应当慎用哨兵。假如有许多个很短的链表，它们的哨兵所占用的额外的存储空间会造成严重的存储浪费。</p><p>引入哨兵后，搜索、插入和删除的代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">LIST-SEARCH<span class="string">'(L, k):</span></span><br><span class="line"><span class="string">    x = L.nil.next   # 初始x指向表头元素</span></span><br><span class="line"><span class="string">    while x != L.nil and x.key != k:</span></span><br><span class="line"><span class="string">        x = x.next</span></span><br><span class="line"><span class="string">    return x</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">LIST-INSERT'</span>(L, X):</span><br><span class="line">    x.next = L.nil.next</span><br><span class="line">    L.nil.next.prev = x</span><br><span class="line">    L.nil.next = x</span><br><span class="line">    x.prev = L.nil</span><br><span class="line"></span><br><span class="line">LIST-DELETE<span class="string">'(L, x):</span></span><br><span class="line"><span class="string">    x.prev.next = x.next</span></span><br><span class="line"><span class="string">    x.next.prev = x.prev</span></span><br></pre></td></tr></table></figure><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.prev = self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>:</span></span><br><span class="line">    <span class="string">"""双向循环链表"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""空链表"""</span></span><br><span class="line">        self.nil, self.size = Element(<span class="literal">None</span>), <span class="number">0</span></span><br><span class="line">        self.nil.prev = self.nil.next = self.nil  <span class="comment"># 哨兵（sentinel）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str([x.key <span class="keyword">for</span> x <span class="keyword">in</span> self])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self.to_list())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_list</span><span class="params">(self)</span>:</span></span><br><span class="line">        x, values = self.head(), []</span><br><span class="line">        <span class="keyword">while</span> x != self.nil:</span><br><span class="line">            values.append(x)</span><br><span class="line">            x = x.next</span><br><span class="line">        <span class="keyword">return</span> values</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""删除元素x"""</span></span><br><span class="line">        x.prev.next, x.next.prev = x.next, x.prev</span><br><span class="line">        self.size -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        <span class="string">"""查找键值为k的元素"""</span></span><br><span class="line">        x = self.head()</span><br><span class="line">        <span class="keyword">while</span> x != self.nil <span class="keyword">and</span> x.key != k:  <span class="comment"># 找不到时x重新指向nil</span></span><br><span class="line">            x = x.next</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""插入元素x，x作为新的表头"""</span></span><br><span class="line">        x.next, self.head().prev = self.head(), x  <span class="comment"># 链接x与第1个元素</span></span><br><span class="line">        self.nil.next, x.prev = x, self.nil  <span class="comment"># 链接哨兵与x</span></span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">head</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回表头元素"""</span></span><br><span class="line">        <span class="keyword">return</span> self.nil.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tail</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回表尾元素"""</span></span><br><span class="line">        <span class="keyword">return</span> self.nil.prev</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(y, z)</span>:</span></span><br><span class="line">    <span class="string">"""合并链表y和z为一个新的链表，y和z会被销毁"""</span></span><br><span class="line">    x = LinkedList()</span><br><span class="line">    x.nil.next, y.head().prev = y.head(), x.nil  <span class="comment"># 链接x.nil与y的头部</span></span><br><span class="line">    x.nil.prev, z.tail().next = z.tail(), x.nil  <span class="comment"># 链接x.nil与z的尾部</span></span><br><span class="line">    y.tail().next, z.head().prev = z.head(), y.tail()  <span class="comment"># 链接y的尾部与z的头部</span></span><br><span class="line">    y = z = <span class="literal">None</span>  <span class="comment"># 销毁y和z</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    l = LinkedList()</span><br><span class="line">    l.insert(Element(<span class="number">1</span>))</span><br><span class="line">    l.insert(Element(<span class="number">2</span>))</span><br><span class="line">    l.insert(Element(<span class="number">3</span>))</span><br><span class="line">    l.insert(Element(<span class="number">4</span>))</span><br><span class="line">    l.insert(Element(<span class="number">5</span>))</span><br><span class="line">    l.insert(Element(<span class="number">6</span>))</span><br><span class="line">    print(l)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[6, 5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Algorithms </tag>
            
            <tag> data structures </tag>
            
            <tag> list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tex Commands</title>
      <link href="/documentation/tex-commands/"/>
      <url>/documentation/tex-commands/</url>
      
        <content type="html"><![CDATA[<h1 id="希腊字母">希腊字母</h1><table><thead><tr class="header"><th>Notation</th><th>Commands</th><th>Notation</th><th>Commands</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\alpha\)</span></td><td><code>\alpha</code></td><td><span class="math inline">\(\beta\)</span></td><td><code>\beta</code></td></tr><tr class="even"><td><span class="math inline">\(\gamma\)</span> <span class="math inline">\(\Gamma\)</span></td><td><code>\gamma \Gamma</code></td><td><span class="math inline">\(\delta\)</span> <span class="math inline">\(\Delta\)</span></td><td><code>\delta \Delta</code></td></tr><tr class="odd"><td><span class="math inline">\(\varepsilon\)</span></td><td><code>\varepsilon</code></td><td><span class="math inline">\(\epsilon\)</span></td><td><code>\epsilon</code></td></tr><tr class="even"><td><span class="math inline">\(\zeta\)</span></td><td><code>\zeta</code></td><td><span class="math inline">\(\eta\)</span></td><td><code>\eta</code></td></tr><tr class="odd"><td><span class="math inline">\(\theta\)</span> <span class="math inline">\(\Theta\)</span></td><td><code>\theta \Theta</code></td><td><span class="math inline">\(\vartheta\)</span></td><td><code>\vartheta</code></td></tr><tr class="even"><td><span class="math inline">\(\iota\)</span></td><td><code>\iota</code></td><td><span class="math inline">\(\kappa\)</span></td><td><code>\kappa</code></td></tr><tr class="odd"><td><span class="math inline">\(\lambda\)</span> <span class="math inline">\(\Lambda\)</span></td><td><code>\lambda \Lambda</code></td><td><span class="math inline">\(\mu\)</span></td><td><code>\mu</code></td></tr><tr class="even"><td><span class="math inline">\(\nu\)</span></td><td><code>\nu</code></td><td><span class="math inline">\(\xi\)</span> <span class="math inline">\(\Xi\)</span></td><td><code>\xi \Xi</code></td></tr><tr class="odd"><td><span class="math inline">\(\omicron\)</span></td><td><code>\omicron</code></td><td><span class="math inline">\(\pi\)</span> <span class="math inline">\(\Pi\)</span></td><td><code>\pi \Pi</code></td></tr><tr class="even"><td><span class="math inline">\(\varpi\)</span></td><td><code>\varpi</code></td><td><span class="math inline">\(\rho\)</span></td><td><code>\rho</code></td></tr><tr class="odd"><td><span class="math inline">\(\varrho\)</span></td><td><code>\varrho</code></td><td><span class="math inline">\(\sigma\)</span> <span class="math inline">\(\Sigma\)</span></td><td><code>\sigma \Sigma</code></td></tr><tr class="even"><td><span class="math inline">\(\varsigma\)</span></td><td><code>\varsigma</code></td><td><span class="math inline">\(\tau\)</span></td><td><code>\tau</code></td></tr><tr class="odd"><td><span class="math inline">\(\upsilon\)</span> <span class="math inline">\(\Upsilon\)</span></td><td><code>\upsilon \Upsilon</code></td><td><span class="math inline">\(\varphi\)</span></td><td><code>\varphi</code></td></tr><tr class="even"><td><span class="math inline">\(\phi\)</span> <span class="math inline">\(\Phi\)</span></td><td><code>\phi \Phi</code></td><td><span class="math inline">\(\chi\)</span></td><td><code>\chi</code></td></tr><tr class="odd"><td><span class="math inline">\(\psi\)</span> <span class="math inline">\(\Psi\)</span></td><td><code>\psi \Psi</code></td><td><span class="math inline">\(\omega\)</span> <span class="math inline">\(\Omega\)</span></td><td><code>\omega \Omega</code></td></tr></tbody></table><a id="more"></a><h1 id="括号">括号</h1><table><thead><tr class="header"><th>Notation</th><th>Commands</th><th>Notation</th><th>Commands</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\lbrace\)</span> <span class="math inline">\(\rbrace\)</span></td><td><code>\lbrace \rbrace</code></td><td><span class="math inline">\(\langle\)</span> <span class="math inline">\(\rangle\)</span></td><td><code>\langle \rangle</code></td></tr></tbody></table><h1 id="运算符号">运算符号</h1><table><thead><tr class="header"><th>Notation</th><th>Commands</th><th>Notation</th><th>Commands</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\times\)</span></td><td><code>$\times$</code></td><td><span class="math inline">\(\div\)</span></td><td><code>$\div$</code></td></tr><tr class="even"><td><span class="math inline">\(\frac{a}{b}\)</span></td><td><code>$\frac{a}{b}$</code></td><td><span class="math inline">\(\pm\)</span></td><td><code>$\pm$</code></td></tr><tr class="odd"><td><span class="math inline">\(\sum\)</span></td><td><code>\sum</code></td><td><span class="math inline">\(\prod\)</span></td><td><code>\prod</code></td></tr><tr class="even"><td><span class="math inline">\(\lceil\)</span> <span class="math inline">\(\rceil\)</span></td><td><code>$\lceil$ $\rceil$</code></td><td><span class="math inline">\(\lfloor\)</span> <span class="math inline">\(\rfloor\)</span></td><td><code>$\lfloor$ $\rfloor$</code></td></tr></tbody></table><h1 id="角标">角标</h1><table><thead><tr class="header"><th>Notation</th><th>Commands</th><th>Notation</th><th>Commands</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\hat a\)</span></td><td><code>\hat a</code></td><td><span class="math inline">\(\dot a\)</span></td><td><code>$\dot a$</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mathjax </tag>
            
            <tag> tex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斐波那契堆</title>
      <link href="/notes/introduction-to-algorithms/fibonacci-heaps/"/>
      <url>/notes/introduction-to-algorithms/fibonacci-heaps/</url>
      
        <content type="html"><![CDATA[<h1 id="斐波那契堆">斐波那契堆</h1><p>斐波那契堆数据结构有两种用途：</p><ul><li>它支持一些列操作，这些操作构成了所谓的“可合并堆”。</li><li>斐波那契堆的一些操作（INSERT/UNION/DECREASE-KEY）可以在常数摊还时间内完成，非常适用于需要频繁使用这些操作的应用。</li></ul><table><thead><tr class="header"><th>操作</th><th>二项堆（最坏情形）</th><th>斐波那契堆（摊还）</th></tr></thead><tbody><tr class="odd"><td>MAKE-HEAP()：创建空堆</td><td><span class="math inline">\(\Theta(1)\)</span></td><td><span class="math inline">\(\Theta(1)\)</span></td></tr><tr class="even"><td>INSERT(H, x)：插入元素x</td><td><span class="math inline">\(\Theta(\lg{n})\)</span></td><td><span class="math inline">\(\Theta(1)\)</span></td></tr><tr class="odd"><td>MINIMUM()：提取最小元素</td><td><span class="math inline">\(\Theta(1)\)</span></td><td><span class="math inline">\(\Theta(1)\)</span></td></tr><tr class="even"><td>EXTRACT-MIN()：删除并返回最小元素</td><td><span class="math inline">\(\Theta(\lg{n})\)</span></td><td><span class="math inline">\(O(\lg{n})\)</span></td></tr><tr class="odd"><td>UNION(H1, H2)：创建一个包含H1和H2中所有元素的新堆</td><td><span class="math inline">\(\Theta(n)\)</span></td><td><span class="math inline">\(\Theta(1)\)</span></td></tr><tr class="even"><td>DECREASE-KEY(H, x, k)：将元素x的关键字赋予新值k</td><td><span class="math inline">\(\Theta(\lg{n})\)</span></td><td><span class="math inline">\(\Theta(1)\)</span></td></tr><tr class="odd"><td>DELETE(H, x)：删除元素x</td><td><span class="math inline">\(\Theta(\lg{n})\)</span></td><td><span class="math inline">\(O(\lg{n})\)</span></td></tr></tbody></table><ul><li>从理论上看，当EXTRACT-MIN和DELETE数目相比于其他操作小得多的时候，斐波那契堆尤为合适。例如，一些图问题算法可能每条边调用一次DECREASE-KEY。对于有很多边的稠密图，每次调用DECREASE-KEY需要<span class="math inline">\(\Theta(1)\)</span>摊还时间，相比起二叉堆最坏情况时间<span class="math inline">\(\Theta(\lg{n})\)</span>，其积累起来是个很大的改进。如最小生成树和寻找单源最短路径的快速算法必不可少地要用到斐波那契堆。</li><li>从实际上看，除了某些需要管理大量数据的应用外，对于大多数应用，斐波那契堆的常数因子和编程复杂性使得它比起普通二项（或k项）堆并不那么适用。因此对斐波那契堆的研究主要出于理论研究。</li></ul><a id="more"></a><h1 id="结构">结构</h1><p>一个斐波那契堆（Fibonacci heap）一系列具有最小堆序（min-heap ordered）的有根树的集合。也就是说，每棵树均遵守最小堆性质（min-heap property）：每个结点的关键字大于或等于它的父结点的关键字。</p><p>斐波那契堆的每个结点x包含：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    int     key      <span class="comment"># 值</span></span><br><span class="line">    int     degree   <span class="comment"># 度，孩子数目</span></span><br><span class="line">    Node    left     <span class="comment"># 左兄弟</span></span><br><span class="line">    Node    right    <span class="comment"># 右兄弟</span></span><br><span class="line">    Node    p        <span class="comment"># 父节点</span></span><br><span class="line">    Node    child    <span class="comment"># 任意一个孩子</span></span><br><span class="line">    bool    marked   <span class="comment"># 是否第一次被删除某个孩子</span></span><br></pre></td></tr></table></figure><p>x的所有孩子被链接成一个环形的双向链表（如下图(b)所示，通常情况下省略了指针，将图画成(a)的样子，因为很容易从(a)中推断出指针指向），称为x的孩子链表（child list）。</p><p>斐波那契堆H包含：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FiboHeap</span>:</span></span><br><span class="line">    Node        min        <span class="comment"># 堆中最小结点（minimum node）</span></span><br><span class="line">    LinkedList  root_list  <span class="comment"># 包含所有根结点的双向环形链表</span></span><br><span class="line">    int         n          <span class="comment"># 堆中所有结点数目</span></span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-algorithms/fibonacci-heap.png" title="斐波那契堆"></p><h1 id="可合并堆">可合并堆</h1><h2 id="创建一个新的斐波那契堆">创建一个新的斐波那契堆</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MAKE-FIB-HEAP():</span><br><span class="line">    H = FiboHeap()</span><br><span class="line">    H.n         = <span class="number">0</span>                 <span class="comment"># 结点数目为0</span></span><br><span class="line">    H.min       = NIL               <span class="comment"># 最小结点为NIL</span></span><br><span class="line">    H.root_list = new LinkedList()  <span class="comment"># 根链表初始为空</span></span><br><span class="line">    <span class="keyword">return</span> H</span><br></pre></td></tr></table></figure><h2 id="插入一个结点">插入一个结点</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FIB-HEAP-INSERT(H, x):</span><br><span class="line">    x.degree    = <span class="number">0</span>                        <span class="comment"># 初始化x的属性</span></span><br><span class="line">    x.p         = NIL</span><br><span class="line">    x.child     = NIL</span><br><span class="line">    x.mark      = <span class="literal">False</span></span><br><span class="line">    H.root_list.insert(x)                  <span class="comment"># 将x插入H的根链表</span></span><br><span class="line">    <span class="keyword">if</span> H.min == NIL <span class="keyword">or</span> x.key &lt; H.min.key:  <span class="comment"># 更新H.min</span></span><br><span class="line">        H.min = x</span><br><span class="line">    H.n = H.n + <span class="number">1</span>                          <span class="comment"># 更新结点数目</span></span><br></pre></td></tr></table></figure><p>在一个斐波那契堆中插入键值为21的结点：</p><p><img src="/uploads/image/introduction-to-algorithms/fib-heap-insert.png" title="插入"></p><p>图中插入位置为H.min的前驱，实际的插入位置没有影响。</p><h2 id="两个斐波那契堆的合并">两个斐波那契堆的合并</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FIB-HEAP-UNION(H1, H2):</span><br><span class="line">    H = MAKE-FIB-HEAP()</span><br><span class="line">    H.root_list = concatenate(H1.root_list, H2.root_list) <span class="comment"># 合并根链表</span></span><br><span class="line">    H.min = H1.min      <span class="comment"># 判断合并后堆的最小结点</span></span><br><span class="line">    <span class="keyword">if</span> H1.min == NIL <span class="keyword">or</span> (H2.min != NIL <span class="keyword">and</span> H2.min.key &lt; H1.min.key):</span><br><span class="line">        H.min = H2.min</span><br><span class="line">    H.n = H1.n + H2.n   <span class="comment"># 更新结点数目</span></span><br><span class="line">    <span class="keyword">return</span> H</span><br></pre></td></tr></table></figure><h2 id="抽取最小结点">抽取最小结点</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FIB-HEAP-EXTRACT-MIN(H):</span><br><span class="line">    z = H.min</span><br><span class="line">    <span class="keyword">if</span> z != NIL:</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> z.child:           <span class="comment"># 将min的所有孩子结点移动到根链表</span></span><br><span class="line">            H.root_list.insert(x)   <span class="comment"># 更新left和right</span></span><br><span class="line">            x.p = NIL               <span class="comment"># 更新父节点，不更新child意味着孩子结点x的孩子结点不变</span></span><br><span class="line">        H.root_list.delete(z)       <span class="comment"># 删除最小结点min</span></span><br><span class="line">        H.min = NIL</span><br><span class="line">        CONSOLIDATE(H)              <span class="comment"># 子过程</span></span><br><span class="line">        H.n = H.n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> z</span><br></pre></td></tr></table></figure><p>其中子过程CONSOLIDATE(H)用来把具有相同度数的根节点合并（consolidating），直到每个度数至多只有一个根。该过程使用一个辅助数组<code>A[0...D(H.n)]</code>来记录根节点对用的度数的轨迹，其中D(H.n)表示一个n个结点的斐波那契堆中任何结点的最大度数上界（<span class="math inline">\(D(n)=O(\lg{n})\)</span>）。如果A[i]=y，那么当前的y是一个具有y.degree=i的根。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CONSOLIDATE(H):</span><br><span class="line">    let A[<span class="number">0.</span>.D(H.n)] be a new array</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to D(H.n):  <span class="comment"># 初始化A</span></span><br><span class="line">        A[i] = NIL</span><br><span class="line">    <span class="keyword">for</span> each node w <span class="keyword">in</span> the root list of H:</span><br><span class="line">        x = w</span><br><span class="line">        d = x.degree</span><br><span class="line">        <span class="keyword">while</span> A[d] != NIL:</span><br><span class="line">            y = A[d]      <span class="comment"># 另一个具有相同度数d的结点y</span></span><br><span class="line">            <span class="keyword">if</span> x.key &gt; y.key:</span><br><span class="line">                exchange x <span class="keyword">with</span> y   <span class="comment"># 始终保证x.key &lt; y.key</span></span><br><span class="line">            FIB-HEAP-LINK(H, y, x)  <span class="comment"># 子过程：将y链接为x的孩子结点</span></span><br><span class="line">            A[d] = NIL              <span class="comment"># 合并后具有度数d的结点不存在了</span></span><br><span class="line">            d = d + <span class="number">1</span>               <span class="comment"># 合并后x的度数，通过while循环再次寻找具有相同度数的结点y</span></span><br><span class="line">        A[d] = x                    <span class="comment"># 不存在相同度数d的y，记录x的度数信息</span></span><br><span class="line">        <span class="keyword">if</span> H.min == NIL <span class="keyword">or</span> x.key &lt; H.min.key:  <span class="comment"># 更新min结点</span></span><br><span class="line">            H.min = x</span><br><span class="line"></span><br><span class="line">FIB-HEAP-LINK(H, y, x):</span><br><span class="line">    H.root_list.delete(y)    <span class="comment"># 从H的根链表中移除y</span></span><br><span class="line">    x.child.insert(y)        <span class="comment"># 将y添加到x的孩子结点中</span></span><br><span class="line">    x.degree = x.degree + <span class="number">1</span>  <span class="comment"># 更新x的度</span></span><br><span class="line">    y.mark = <span class="literal">False</span>           <span class="comment"># 清除y上的标记</span></span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-algorithms/fib-heap-extract-min.png" title="提取最小的元素"></p><ul><li><span class="math inline">\((a)\)</span> 从当前的斐波那契堆中提取最小结点H.min。以后把“键值为x的结点”省略称为“结点x“。</li><li><span class="math inline">\((a)\rightarrow(b)\)</span> 将结点3的所有子节点移动到根链表。H.min指针右移一位。此时不一定指向最小元素，在后续操作中会调整。</li><li><span class="math inline">\((b)\rightarrow(c)\)</span> 创建一个辅助数组A，遍历根链表。当前结点的度数为1，A[1]为空，将A[1]指向当前结点。继续下一位。</li><li><span class="math inline">\((d)\rightarrow(e)\)</span> 过程类似。结果是A[2]指向度数为2的结点24；A[0]指向度数为0的结点23。</li><li><span class="math inline">\((e)\rightarrow(f)\)</span> 结点7的度数为0，但A[0]不为空，将结点7与A[0]指向的结点23合并：键值较大的结点23移动到结点7的子节点链表中。移动后，清除A[0]。</li><li><span class="math inline">\((f)\rightarrow(g)\)</span> 结点7的度数为1，A[1]不为空且指向结点17。于是将结点17移动到结点7的子结点链表中。清除A[1]。</li><li><span class="math inline">\((g)\rightarrow(h)\)</span> 结点7的度数为2，A[2]不为空且指向24。合并结点7与结点24。清除A[2]。此时结点7的度数为3，而A[3]为空，令A[3]指向结点结点7。继续下一个结点。</li><li><span class="math inline">\((i)\rightarrow(j)\)</span> A[0]指向结点21；A[1]指向结点18。</li><li><span class="math inline">\((j)\rightarrow(k)\)</span> 结点52度数为0，A[0]不为空且指向21。合并结点21与结点52。清除A[0]；合并后结点21的度数为1，A[1]指向结点18。合并结点21与结点18。清除A[1]；合并后结点18度数为2，A[2]为空，令A[2]指向结点18。继续下一结点。</li><li><span class="math inline">\((k)\rightarrow(l)\)</span> 结点38的度数为1，A[1]为空。令A[1]指向结点38。继续下一节点。</li><li><span class="math inline">\((m)\)</span> 所有结点遍历完毕。更新H.min。</li></ul><h1 id="减值和删除">减值和删除</h1><h2 id="关键字减值">关键字减值</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FIB-HEAP-DECREASE-KEY(H, x, k):</span><br><span class="line">    <span class="keyword">if</span> k &gt; x.key:</span><br><span class="line">        error <span class="string">"new key is greater than current key"</span></span><br><span class="line">    x.key = k</span><br><span class="line">    y = x.p</span><br><span class="line">    <span class="keyword">if</span> y != NIL <span class="keyword">and</span> x.key &lt; y.key:  <span class="comment"># 如果更新后x的值小于父节点的值，调整堆</span></span><br><span class="line">        CUT(H, x, y)                <span class="comment"># 子过程：切断x与其父节点y之间的链接</span></span><br><span class="line">        CASCADING-CUT(H, y)         <span class="comment"># 子过程：级联切断</span></span><br><span class="line">    <span class="keyword">if</span> x.key &lt; H.min.key:           <span class="comment"># 更新min结点</span></span><br><span class="line">        H.min = x</span><br><span class="line"></span><br><span class="line">CUT(H, x, y):                <span class="comment"># 切断x与其父节点y之间的链接，并将x添加到根链表</span></span><br><span class="line">    y.child.delete(x)        <span class="comment"># remove x from the child list of y</span></span><br><span class="line">    y.degree = y.degree - <span class="number">1</span>  <span class="comment"># decrementint y.degree</span></span><br><span class="line">    H.root_list.insert(x)    <span class="comment"># add x to the root list of H</span></span><br><span class="line">    x.p = NIL</span><br><span class="line">    x.mark = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">CASCADING-CUT(H, y):            <span class="comment"># 级联切断</span></span><br><span class="line">    z = y.p</span><br><span class="line">    <span class="keyword">if</span> z != NIL:</span><br><span class="line">        <span class="keyword">if</span> y.mark == <span class="literal">False</span>:     <span class="comment"># 如果mark为false，那么上次CUT中，是结点y第一次失去孩子</span></span><br><span class="line">            y.mark == <span class="literal">True</span>      <span class="comment"># 第一次失去孩子，mark置为True</span></span><br><span class="line">        <span class="keyword">else</span>:                   <span class="comment"># 如果mark为True，那么上次CUT之前，y已经失去过孩子</span></span><br><span class="line">            CUT(H, y, z)</span><br><span class="line">            CASCADING-CUT(H, Z) <span class="comment"># 向上递归，直到遇到根节点或者一个未被标记的结点（mark=False）</span></span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-algorithms/fib-heap-decrease-key.png" title="减小元素的值"></p><ul><li><span class="math inline">\((a)\)</span> 初始斐波那契堆。将结点46的键值降低为15。</li><li><p><span class="math inline">\((a)\rightarrow(b)\)</span> 修改键值。将修改后的结点15移动到根链表（切断）。其父节点24，之前未被标记。现在失去了一个孩子，标记它。</p></li><li><p><span class="math inline">\((b)\)</span> 在此斐波那契堆上，将结点35的键值降低为5。</p></li><li><span class="math inline">\((b)\rightarrow(c)\)</span> 修改键值，将修改后的结点5移动到根链表（切断）。</li><li><span class="math inline">\((c)\rightarrow(d)\)</span> 结点5的原来的父节点26是被标记的，触发级联切断的条件：切断结点26与其父节点，将结点26移动到根链表，清除其标记。之后对结点26的原来的父节点24递归地调用级联切断过程。</li><li><span class="math inline">\((d)\rightarrow(e)\)</span> 结点24同样是被标记的，切断结点24与其父节点7。最后对结点24的原来的父节点7递归地调用级联切断。</li><li><p>结点7没有父节点，级联切断不处理此类结点。</p></li></ul><h2 id="删除一个结点">删除一个结点</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FIB-HEAP-DELETE(H, x):</span><br><span class="line">    FIB-HEAP-DECREASE-KEY(H, x, -infinty)</span><br><span class="line">    FIB-HEAP-EXTRACT-MIN(H)</span><br></pre></td></tr></table></figure><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> data_structure.linked_list <span class="keyword">import</span> Element, LinkedList, union <span class="keyword">as</span> union_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(Element)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        Element.__init__(self, k)</span><br><span class="line">        self.degree, self.mark = <span class="number">0</span>, <span class="literal">False</span>  <span class="comment"># mark：第1次失去孩子后为True、第2次后为False</span></span><br><span class="line">        self.p = self.child = self.prev = self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.value())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">value</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.child <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> len(self.child) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.key</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;self.key: [c.value() <span class="keyword">for</span> c <span class="keyword">in</span> self.child]&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FibHeap</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.n, self.min = <span class="number">0</span>, <span class="literal">None</span>  <span class="comment"># 堆中结点数目, 堆中最小结点</span></span><br><span class="line">        self.root_list = LinkedList()  <span class="comment"># 根链表</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        s = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self.root_list:</span><br><span class="line">            s.append(str(x))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">', '</span>.join(s)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x.degree, x.mark = <span class="number">0</span>, <span class="literal">False</span></span><br><span class="line">        x.p = x.child = <span class="literal">None</span></span><br><span class="line">        self.root_list.insert(x)  <span class="comment"># 插入根链表</span></span><br><span class="line">        <span class="keyword">if</span> self.min <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> x.key &lt; self.min.key:</span><br><span class="line">            self.min = x</span><br><span class="line">        self.n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        z = self.min</span><br><span class="line">        <span class="keyword">if</span> z <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> z.child <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment"># 将所有子节点插入到根链表</span></span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> z.child:</span><br><span class="line">                    self.root_list.insert(x)</span><br><span class="line">                    x.p = <span class="literal">None</span></span><br><span class="line">            self.min = <span class="literal">None</span></span><br><span class="line">            self.root_list.delete(z)  <span class="comment"># 从根链表中移除</span></span><br><span class="line">            self.consolidate()  <span class="comment"># 合并度数相同的结点</span></span><br><span class="line">            self.n -= <span class="number">1</span>  <span class="comment"># 总结点数目减1</span></span><br><span class="line">            z.child = <span class="literal">None</span>  <span class="comment"># 清除指针，不清除对斐波那契堆也没什么影响</span></span><br><span class="line">        <span class="keyword">return</span> z</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">consolidate</span><span class="params">(self)</span>:</span></span><br><span class="line">        degree = &#123;&#125;  <span class="comment"># degree[i]=y，那么y.degree=i</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self.root_list:  <span class="comment"># 在link()中可能被删除的元素已经访问过，因此可以使用迭代器</span></span><br><span class="line">            d = x.degree</span><br><span class="line">            <span class="keyword">while</span> d <span class="keyword">in</span> degree:</span><br><span class="line">                y = degree.pop(d)  <span class="comment"># another node with the same degree as x</span></span><br><span class="line">                <span class="keyword">if</span> x.key &gt; y.key:</span><br><span class="line">                    x, y = y, x</span><br><span class="line">                self.link(y, x)</span><br><span class="line">                d = d + <span class="number">1</span></span><br><span class="line">            degree[d] = x</span><br><span class="line">            <span class="keyword">if</span> self.min <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> self.min.key &gt; x.key:</span><br><span class="line">                self.min = x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">link</span><span class="params">(self, y, x)</span>:</span></span><br><span class="line">        self.root_list.delete(y)</span><br><span class="line">        y.p = x</span><br><span class="line">        <span class="keyword">if</span> x.child <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            x.child = LinkedList()</span><br><span class="line">        x.child.insert(y)</span><br><span class="line">        x.degree += <span class="number">1</span></span><br><span class="line">        y.mark = <span class="literal">False</span>  <span class="comment"># y成为孩子结点时，mark置为False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decrease_key</span><span class="params">(self, x, k)</span>:</span> <span class="comment"># 没有对结点x是否在堆中进行判断，heap.min可能会指向堆外结点</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; x.key:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'new key is greater than current key'</span>)</span><br><span class="line">        x.key, y = k, x.p</span><br><span class="line">        <span class="keyword">if</span> y <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> x.key &lt; y.key:  <span class="comment"># 当更新后的值小于父节点时调整堆</span></span><br><span class="line">            self.cut(x, y)  <span class="comment"># 切断x与y</span></span><br><span class="line">            self.cascading_cut(y)</span><br><span class="line">        <span class="keyword">if</span> x.key &lt; self.min.key:</span><br><span class="line">            self.min = x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cut</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        y.child.delete(x)  <span class="comment"># 分离x与其父节点y</span></span><br><span class="line">        self.root_list.insert(x)  <span class="comment"># 使x成为根节点</span></span><br><span class="line">        y.degree -= <span class="number">1</span></span><br><span class="line">        x.p, x.mark = <span class="literal">None</span>, <span class="literal">False</span>  <span class="comment"># x成为根结点时，mark置为False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cascading_cut</span><span class="params">(self, y)</span>:</span></span><br><span class="line">        z = y.p</span><br><span class="line">        <span class="keyword">if</span> z <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> y.mark <span class="keyword">is</span> <span class="literal">False</span>:  <span class="comment"># mark=False，是第一次失去孩子</span></span><br><span class="line">                y.mark = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># mark=True,是第二次失去孩子</span></span><br><span class="line">                self.cut(y, z)</span><br><span class="line">                self.cascading_cut(z)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.decrease_key(x, float(<span class="string">'-inf'</span>))</span><br><span class="line">        self.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(h1, h2)</span>:</span></span><br><span class="line">    h = FibHeap()  <span class="comment"># 初始化新堆</span></span><br><span class="line">    h.root_list = union_list(h1.root_list, h2.root_list)  <span class="comment"># 合并根链表，h1和h2的根链表会被销毁</span></span><br><span class="line">    h.min = h1.min  <span class="comment"># 比较最小结点</span></span><br><span class="line">    <span class="keyword">if</span> h1.min <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> (h2.min <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> h2.min.key &lt; h1.min.key):</span><br><span class="line">        h.min = h2.min</span><br><span class="line">    h.n = h1.n + h2.n  <span class="comment"># 结点数目相加</span></span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    h1, h2 = FibHeap(), FibHeap()</span><br><span class="line">    key1, key2 = [<span class="number">23</span>, <span class="number">7</span>, <span class="number">21</span>, <span class="number">3</span>, <span class="number">17</span>, <span class="number">24</span>, <span class="number">18</span>], [<span class="number">52</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">26</span>, <span class="number">46</span>, <span class="number">39</span>, <span class="number">41</span>, <span class="number">35</span>]</span><br><span class="line">    [h1.insert(Node(i)) <span class="keyword">for</span> i <span class="keyword">in</span> key1]</span><br><span class="line">    [h2.insert(Node(i)) <span class="keyword">for</span> i <span class="keyword">in</span> key2]</span><br><span class="line">    print(<span class="string">'h1:'</span>, h1)</span><br><span class="line">    print(<span class="string">'h2:'</span>, h2)</span><br><span class="line">    h = union(h1, h2)  <span class="comment"># union，合并根链表</span></span><br><span class="line">    print(<span class="string">'h:'</span>, h)</span><br><span class="line">    print(<span class="string">'&#123;0:&lt;3s&#125; &#123;1:&lt;6s&#125;'</span>.format(<span class="string">'pop'</span>, <span class="string">'h'</span>))</span><br><span class="line">    <span class="keyword">while</span> h.n &gt; <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">'&#123;0:&lt;3d&#125; &#123;1:&lt;6s&#125;'</span>.format(h.pop().key, str(h)))</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h1: 18, 24, 17, 3, 21, 7, 23</span><br><span class="line">h2: 35, 41, 39, 46, 26, 30, 38, 52</span><br><span class="line">h: 18, 24, 17, 3, 21, 7, 23, 35, 41, 39, 46, 26, 30, 38, 52</span><br><span class="line">pop h</span><br><span class="line">3   &#123;7: [&#123;17: [&#123;18: [24]&#125;, 21]&#125;, &#123;35: [41]&#125;, 23]&#125;, &#123;26: [&#123;39: [46]&#125;, 30]&#125;, &#123;38: [52]&#125;</span><br><span class="line">7   23, &#123;35: [&#123;38: [52]&#125;, 41]&#125;, &#123;17: [&#123;26: [&#123;39: [46]&#125;, 30]&#125;, &#123;18: [24]&#125;, 21]&#125;</span><br><span class="line">17  &#123;18: [&#123;26: [&#123;39: [46]&#125;, 30]&#125;, &#123;21: [23]&#125;, 24]&#125;, &#123;35: [&#123;38: [52]&#125;, 41]&#125;</span><br><span class="line">18  24, &#123;21: [23]&#125;, &#123;26: [&#123;35: [&#123;38: [52]&#125;, 41]&#125;, &#123;39: [46]&#125;, 30]&#125;</span><br><span class="line">21  &#123;23: [24]&#125;, &#123;26: [&#123;35: [&#123;38: [52]&#125;, 41]&#125;, &#123;39: [46]&#125;, 30]&#125;</span><br><span class="line">23  24, &#123;26: [&#123;35: [&#123;38: [52]&#125;, 41]&#125;, &#123;39: [46]&#125;, 30]&#125;</span><br><span class="line">24  &#123;26: [&#123;35: [&#123;38: [52]&#125;, 41]&#125;, &#123;39: [46]&#125;, 30]&#125;</span><br><span class="line">26  30, &#123;39: [46]&#125;, &#123;35: [&#123;38: [52]&#125;, 41]&#125;</span><br><span class="line">30  &#123;39: [46]&#125;, &#123;35: [&#123;38: [52]&#125;, 41]&#125;</span><br><span class="line">35  41, &#123;38: [&#123;39: [46]&#125;, 52]&#125;</span><br><span class="line">38  &#123;39: [&#123;41: [52]&#125;, 46]&#125;</span><br><span class="line">39  46, &#123;41: [52]&#125;</span><br><span class="line">41  &#123;46: [52]&#125;</span><br><span class="line">46  52</span><br><span class="line">52</span><br></pre></td></tr></table></figure><h1 id="应用">应用</h1><ul><li>Dijkstra算法</li><li>Prim算法</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Algorithms </tag>
            
            <tag> data structures </tag>
            
            <tag> heap </tag>
            
            <tag> fibonacci heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斯特灵近似公式</title>
      <link href="/further-mathematics/stirling-s-approximation/"/>
      <url>/further-mathematics/stirling-s-approximation/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zh.wikipedia.org/wiki/%E6%96%AF%E7%89%B9%E9%9D%88%E5%85%AC%E5%BC%8F" target="_blank" rel="noopener">斯特灵公式</a>（Stirling's approximation or Stirling's formula）是一条用来取n阶乘近似值的数学公式。一般来说，当n很大的时候，n阶乘的计算量十分大，所以斯特灵公式十分好用。而且，即使在n很小的时候，斯特灵公式的取值已经十分准确。</p><p><span class="math display">\[n! \approx \sqrt{2\pi{n}}(\frac{n}{e})^n\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> formula </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/notes/introduction-to-algorithms/quicksort/"/>
      <url>/notes/introduction-to-algorithms/quicksort/</url>
      
        <content type="html"><![CDATA[<h1 id="快速排序">快速排序</h1><p>快速排序（Quicksort）是一种高效的比较型排序算法，于1961年由瑞典科学家<a href="https://en.wikipedia.org/wiki/Tony_Hoare" target="_blank" rel="noopener">Tony Hoare</a>发表。与<a href="/algorithm/Merge-sort">归并排序</a>类似，快速排序也是一种分治算法。快速排序是常用的排序算法，一个好的快速排序的实现，甚至可以比归并排序和堆排序快两到三倍。快速排序不是稳定排序，但它是原址排序。排序n个数的<strong>平均</strong>时间代价是<span class="math inline">\(O(n\log{n})\)</span>。最坏情况下，它的时间代价是<span class="math inline">\(O(n^2)\)</span>，这种情况很少出现。快速排序的示例图（来自<a href="https://en.wikipedia.org/wiki/Quicksort" target="_blank" rel="noopener">维基百科：Quicksort</a>）如下：</p><p><img src="/uploads/image/introduction-to-algorithms/sorting-quicksort-anim.gif" title="快速排序动态过程"></p><a id="more"></a><h1 id="实现">实现</h1><p>快速排序同样遵循分治模式，每层递归是有三个步骤：</p><ul><li>分解（Divide）：数组<code>A[p...r]</code>被划分为两个（可能为空）子数组<code>A[p...q-1]</code>和<code>A[q+1...r]</code>，使得<span class="math inline">\(A[i]\le{A[q]}\le{A[j]}, i\in[p,q-1], j\in[q+1,r]\)</span>。其中，计算下标q也是划分过程的一部分。</li><li>解决（Conquer）：通过递归调用快速排序，对子数组<code>A[p...q-1]</code>和<code>A[q+1...r]</code>进行排序。</li><li>合并（Combine）：快速排序不需要合并操作，数组<code>A[p...r]</code>已经有序。</li></ul><p>与归并排序不同，快速排序的比较过程发生在分解阶段，且快速排序是原址排序，所以快速排序不需要合并操作。</p><p>实现快速排序的过程如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">quicksort(A, p, r):</span><br><span class="line">    <span class="keyword">if</span> p &lt; r:</span><br><span class="line">        q = partition(A, p, r)</span><br><span class="line">        quicksort(A, p, q - <span class="number">1</span>)</span><br><span class="line">        quicksort(A, q + <span class="number">1</span>, r)</span><br></pre></td></tr></table></figure><p>快速排序的关键部分是partition过程，它实现了对子数组<code>A[p...r]</code>的原址排序。</p><h2 id="lomuto划分">Lomuto划分</h2><p>Lomuto划分的效率不高，但它易于理解。它通常选择最后一个元素x=A[r]作为<strong>主元</strong>（pivot），并围绕它来划分子数组<code>A[p...r]</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lomuto_partition(A, p, r):</span><br><span class="line">    x = A[r]</span><br><span class="line">    i = p - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j = p to r - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> A[j] &lt;= x</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">            exchange A[i] <span class="keyword">with</span> A[j]</span><br><span class="line">    exchange A[i+<span class="number">1</span>] <span class="keyword">with</span> A[r]</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>        // q的最终位置</span><br></pre></td></tr></table></figure><p>随着划分过程的进行，数组被划分成4个（可能有空的）区域。分别为小于等于x的部分，大于x的部分，未比较部分，和主元x。将这些性质作为循环不变量：</p><blockquote><p>在循环体的每一轮迭代开始时，对任意数组下标k，有：</p><ol type="1"><li>小于x的部分：若<span class="math inline">\(p\le{k}\le{i}\)</span>，则<span class="math inline">\(A[k]\le{x}\)</span>。</li><li>大于x的部分：若<span class="math inline">\(i+1\le{k}\le{j-1}\)</span>，则<span class="math inline">\(A[k]\ge{x}\)</span>。</li><li>等于x的部分：若k=r，则A[k]=x。</li></ol></blockquote><p>上述坐标之外的区域<code>A[j...r-1]</code>对应为比较部分。Lomuto划分的一个示例如下：</p><p>数组的四个部分分别是 (小于主元的元素) (大于等于主元的元素) (未划分元素) (主元)。</p><table><thead><tr class="header"><th><code>array[p...r]</code></th><th>A[i]</th><th>A[j]</th></tr></thead><tbody><tr class="odd"><td>() () (2871356) (4)</td><td>null（i=p-1）</td><td>2</td></tr><tr class="even"><td>x=array[r]=4</td><td></td><td>2&lt;4，i=i+1; exchange 2 with 2; j=j+1</td></tr><tr class="odd"><td>(2) () (871356) (4)</td><td>2</td><td>8</td></tr><tr class="even"><td></td><td></td><td>8&gt;=4，j=j+1</td></tr><tr class="odd"><td>(2) (8) (71356) (4)</td><td>2</td><td>7</td></tr><tr class="even"><td></td><td></td><td>7&gt;=4，j=j+1</td></tr><tr class="odd"><td>(2) (87) (1356) (4)</td><td>2</td><td>1</td></tr><tr class="even"><td></td><td></td><td>1&lt;4，i=i+1; exchange 8 with 1; j=j+1</td></tr><tr class="odd"><td>(21) (78) (356) (4)</td><td>1</td><td>3</td></tr><tr class="even"><td></td><td></td><td>3&lt;4，i=i+1; exchange 7 with 3; j=j+1</td></tr><tr class="odd"><td>(213) (87) (56) (4)</td><td>3</td><td>5</td></tr><tr class="even"><td></td><td></td><td>5&gt;=4，j=j+1</td></tr><tr class="odd"><td>(213) (875) (6) (4)</td><td>3</td><td>6</td></tr><tr class="even"><td></td><td></td><td>6&gt;=4，j=j+1</td></tr><tr class="odd"><td>(213) (8756) () (4)</td><td>3</td><td>4</td></tr><tr class="even"><td></td><td></td><td>j==r，退出循环，exchange 8 with 4</td></tr><tr class="odd"><td>213 4 7568</td><td>3</td><td>return i+1，是主元位置</td></tr></tbody></table><h2 id="hoare划分">Hoare划分</h2><p>Hoare划分比Lomuto划分更加高效。在选择了主元之后，它使用两个下标i和j，i从前往后、j从后往前移动。当找到<span class="math inline">\(A[i]\ge{x}\)</span>、<span class="math inline">\(A[j]\le{x}\)</span>且i&lt;j的两个坐标i和j之后，交换它们的元素。当i和j相遇（<span class="math inline">\(i\ge{j}\)</span>）后，划分过程停止。平均情况下，Hoare划分比Lomuto划分少3次交换次数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hoare_partition(A, p, r):</span><br><span class="line">    x = A[r]                           <span class="comment"># 最后一个元素作为主元</span></span><br><span class="line">    i = p</span><br><span class="line">    j = r - <span class="number">1</span>                          <span class="comment"># 最后一位是主元</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">while</span> i &lt; r <span class="keyword">and</span> A[i] &lt;= x:     <span class="comment"># 找到大于主元的元素或i=r（主元的位置）时停止</span></span><br><span class="line">            i = i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= p <span class="keyword">and</span> A[j] &gt;=x:     <span class="comment"># 找到小于主元的元素或j&lt;p（超出了边界）时停止</span></span><br><span class="line">            j = j<span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; j:                      <span class="comment"># i与j相遇，i是主元应处的位置</span></span><br><span class="line">            <span class="keyword">if</span> i != r:</span><br><span class="line">                swap A[i] <span class="keyword">with</span> A[r]</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        swap A[i] <span class="keyword">with</span> A[j]</span><br></pre></td></tr></table></figure><p>Hoare划分的一个示例如下：</p><p>数组的四个部分分别是 (小于等于主元的元素) (未划分元素) (大于等于主元的元素) (主元)。</p><table><thead><tr class="header"><th></th><th><code>array[p...r]</code></th><th>A[i]</th><th>A[j]</th></tr></thead><tbody><tr class="odd"><td>初始</td><td>() (2871356) () (4)</td><td>2</td><td>6</td></tr><tr class="even"><td>寻找下一对交换元素</td><td>主元x=4</td><td>8</td><td>3，交换</td></tr><tr class="odd"><td>继续寻找</td><td>(23) (71) (856) (4)</td><td>7</td><td>1，交换</td></tr><tr class="even"><td>继续寻找</td><td>(231) () (7856) (4)</td><td>7</td><td>1，相遇，交换A[i]与主元，return i</td></tr><tr class="odd"><td></td><td>231 4 8567</td><td>4</td><td>7</td></tr></tbody></table><h2 id="主元的选择">主元的选择</h2><p>不论Lomuto划分还是Hoare划分，主元的选择方式都会直接影响到划分结果。例如上述Hoare划分过程的示例，若选择主元x=1，正好是数组中最小的元素，划分过程很快就结束，并产生了两个长度相差较大的子数组[1]和[2, 8, 7, 2, 3, 5, 6, 4]。同理若正好选择了最大的元素，也会产生类似的结果。称这种划分为不平衡划分（Unbalanced partitioning）。</p><p>在Lomuto划分中，总是选择最右侧元素作为主元。若输入数组是已排序的，排序算法将总是产生不平衡划分，触发最坏情况。幸运的是，可以通过一些策略来优化，使得对任何输入都比较好。例如随机选择，后文将分析随机选择主元的快速排序的期望运行时间为<span class="math inline">\(O(n\log{n})\)</span>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">random(A, left, right):</span><br><span class="line">    select an integer i <span class="keyword">in</span> [left, right] randomly</span><br><span class="line">    <span class="keyword">if</span> i != right:</span><br><span class="line">        swap A[i] <span class="keyword">with</span> A[right]</span><br><span class="line">    <span class="keyword">return</span> A[right]</span><br></pre></td></tr></table></figure><p>还有一种模式：选择左中右元素的中位数（Median-of-three，mo3）。随机选择模式下，快速排序的比较次数的期望是<span class="math inline">\(1.386n\log{n}\)</span>，mo3模式下，期望可下降至<span class="math inline">\(1.188n\log{n}\)</span>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">median_of_three(A, left, right):</span><br><span class="line">    mid = (left + right) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> A[mid] &lt; A[left]:</span><br><span class="line">        swap A[left] <span class="keyword">with</span> A[mid]    <span class="comment"># A[left] &lt;= A[mid]</span></span><br><span class="line">    <span class="keyword">if</span> A[right] &lt; A[left]:</span><br><span class="line">        swap A[left] <span class="keyword">with</span> A[right]  <span class="comment"># A[left] &lt;= A[right]</span></span><br><span class="line">    <span class="keyword">if</span> A[mid] &lt; A[right]:</span><br><span class="line">        swap A[mid] <span class="keyword">with</span> A[right]   <span class="comment"># A[right] &lt;= A[mid]</span></span><br><span class="line">    pivot = A[right]</span><br></pre></td></tr></table></figure><p>通过上述代码，使得<span class="math inline">\(A[mid]\ge{A[right]}\ge{A[left]}\)</span>，此时再选择最右侧元素，实际上是左中右元素的中位数。当输入数组的排序情况未知时，相比总是直接选择左右侧元素，该方法性能更好。对于更长的数组，可以扩展mo3规则至更强的ninther。</p><p><code>ninther(A)=middle(mo3(first 1/3 of A), mo3(middle 1/3 of A), mo3(final 1/3 of A))</code></p><p><strong>注意</strong>：mid = (left + right) / 2可能会发生越界情况（没搞懂），可以用mid = left + (right - left) / 2来代替。</p><h1 id="分析">分析</h1><h2 id="最坏情况">最坏情况</h2><p>以Lomuto划分为例，当划分操作总是得到一个大小为0、另一个大小为n-1的数组时（还有一个元素是主元），假设T(n)是quicksort在输入规模为n的数据集合上所花费的时间，则有递归式：</p><p><span class="math display">\[T(n)=T(0)+T(n-1)+\Theta(n)\]</span></p><p>递归树深度为n，容易得到<span class="math inline">\(T(n)=O(n^2)\)</span>。</p><p>利用代入法证明：</p><p><span class="math display">\[T(n)=\max_{0\le{q}\le{n-1}}(T(q)+T(n-q-1)+\Theta(n))\]</span></p><p>q和n-q-1分别是两个子数组的规模。设<span class="math inline">\(T(n)\le{cn^2}\)</span>成立，将其带入上式 <span class="math display">\[\begin{aligned}T(n)&amp;\le{\max_{0\le{q}\le{n-1}}(cq^2+c(n-q-1)^2)+\Theta(n)}\\&amp;=c\max_{0\le{q}\le{n-1}}(q^2+(n-q-1)^2)+\Theta(n)\end{aligned}\]</span></p><p><span class="math inline">\(q^2+(n-q-1)^2\le(n-1)^2=n^2-2n+1\)</span>（在端点处取得最大值），将其带入上式，得到</p><p><span class="math display">\[T(n)\le{cn^2-c(2n-1)+\Theta(n)}\le{cn^2}\]</span></p><p><span class="math inline">\(\therefore{T(n)=O(n^2)}\)</span>。</p><h2 id="最佳情况">最佳情况</h2><p>若划分操作总是得到两个规模相等的子数组时，触发最佳情况。</p><p><span class="math display">\[T(n)=2T(\frac{n}{2})+\Theta(n)\]</span></p><p>递归树深度为<span class="math inline">\(\log_2{n}\)</span>，可得<span class="math inline">\(T(n)=O(n\log(n))\)</span>。</p><h2 id="平均情况">平均情况</h2><p>对于规模为n的无重复元素的数组，若主元的选择是独立且随机的，则快速排序的期望运行时间为<span class="math inline">\(O(n\log(n))\)</span>。</p><p>证明：</p><p>考虑输入数组的一个随机序列<span class="math inline">\((x_1,x_2,...,x_n)\)</span>，定义C表示比较次数，<span class="math inline">\(c_{ij}\)</span>为指示器随机变量。有</p><p><span class="math display">\[c_{ij}=\begin{cases}1&amp;x_i与x_j发生比较\\0&amp;x_i与x_j不发生比较&amp;&amp;\end{cases}C=\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}c_{i,j}\]</span></p><p>对C取期望，有</p><p><span class="math display">\[E[C]=\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}E(c_{ij})=\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}Pr(c_{ij})\]</span></p><p>在划分操作中，只有主元会与其他元素发生比较，因此</p><p><span class="math display">\[Pr(c_{ij})=Pr(x_i\text{或}x_j\text{被选为主元)}\]</span></p><p>在一次划分中，<span class="math inline">\(x_i\)</span>与<span class="math inline">\(x_j\)</span>不可能同时被选为主元，且主元的选择是独立的，因此</p><p><span class="math display">\[Pr(c_{ij})=2*Pr(x_i被选为主元)=\frac{2}{j-i+1}\]</span></p><p>令<span class="math inline">\(k=j-i\)</span>，代入<span class="math inline">\(E[C]\)</span>得</p><p><span class="math display">\[\begin{aligned}E[C]&amp;=\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}\frac{2}{j-i+1}\\&amp;=\sum_{i=1}^{n-1}\sum_{k=1}^{n-i}\frac{2}{k+1}\\&amp;&lt;\sum_{i=1}^{n-1}\sum_{k=1}^{n}\frac{2}{k}\\&amp;=\sum_{i=1}^{n-1}O(\log{n})\\&amp;=O(n\log{n})\end{aligned}\]</span></p><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(a, i, j)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> i != j:</span><br><span class="line">        a[i], a[j] = a[j], a[i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">median_of_three</span><span class="params">(a, left, right)</span>:</span></span><br><span class="line">    <span class="string">"""选择左中右三元素的中位数作为pivot"""</span></span><br><span class="line">    mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> a[mid] &lt; a[left]:</span><br><span class="line">        exchange(a, left, mid)  <span class="comment"># now: a[left] &lt;= a[mid]</span></span><br><span class="line">    <span class="keyword">if</span> a[right] &lt; a[left]:</span><br><span class="line">        exchange(a, left, right)  <span class="comment"># now: a[left] &lt;= a[right]</span></span><br><span class="line">    <span class="keyword">if</span> a[mid] &lt; a[right]:</span><br><span class="line">        exchange(a, mid, right)  <span class="comment"># now: a[right] &lt;= a[mid]</span></span><br><span class="line">    <span class="comment"># now: a[left&#125; &lt;= a[right] &lt;= a[mid]</span></span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hoare_partition</span><span class="params">(a, left, right)</span>:</span></span><br><span class="line">    <span class="string">"""Hoare's scheme is more efficient than Lomuto's partition scheme</span></span><br><span class="line"><span class="string">    because it does three times fewer swaps on average."""</span></span><br><span class="line">    pivot, i, j = a[right], left, right - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">while</span> i &lt; right <span class="keyword">and</span> a[i] &lt;= pivot:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= left <span class="keyword">and</span> a[j] &gt;= pivot:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; j:  <span class="comment"># i, j 相遇</span></span><br><span class="line">            exchange(a, i, right)</span><br><span class="line">            <span class="keyword">return</span> i  <span class="comment"># pivot位置</span></span><br><span class="line">        exchange(a, i, j)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lomuto_partition</span><span class="params">(a, left, right)</span>:</span></span><br><span class="line">    pivot, i = a[right], left</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(left, right):</span><br><span class="line">        <span class="keyword">if</span> a[j] &lt; pivot:  <span class="comment"># 小于pivot的元素被划分到左边，大于等于pivot的元素被划分到右边</span></span><br><span class="line">            exchange(a, i, j)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    exchange(a, i, right)</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">q_sort</span><span class="params">(a, left, right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; right:</span><br><span class="line">        p_idx = random.randint(left, right)  <span class="comment"># 随机选择pivot</span></span><br><span class="line">        <span class="comment"># p_idx = median_of_three(a, left, right)  # 选择左中右元素的中位数</span></span><br><span class="line">        q = partition(a, left, right, p_idx)</span><br><span class="line">        q_sort(a, left, q - <span class="number">1</span>)</span><br><span class="line">        q_sort(a, q + <span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(a, left, right, p_idx)</span>:</span>  <span class="comment"># 增加参数，p_idx指示所用主元在数组中的位置</span></span><br><span class="line">    <span class="keyword">if</span> p_idx &lt; left <span class="keyword">or</span> p_idx &gt; right:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">"主元位置越界"</span>)</span><br><span class="line">    exchange(a, p_idx, right)</span><br><span class="line">    <span class="keyword">return</span> hoare_partition(a, left, right)</span><br><span class="line">    <span class="comment"># return lomuto_partition(a, left, right)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="string">"""排序整个列表"""</span></span><br><span class="line">    q_sort(a, <span class="number">0</span>, len(a) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">16</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">11</span>, <span class="number">15</span>]</span><br><span class="line">    quick_sort(arr)</span><br><span class="line">    print(arr)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort </tag>
            
            <tag> Introduction to Algorithms </tag>
            
            <tag> algorithms </tag>
            
            <tag> comparison sort </tag>
            
            <tag> divide and conquer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/notes/introduction-to-algorithms/merge-sort/"/>
      <url>/notes/introduction-to-algorithms/merge-sort/</url>
      
        <content type="html"><![CDATA[<h1 id="归并排序">归并排序</h1><p>归并排序（Merge sort）是一种比较高效的比较型排序算法，由<a href="https://en.wikipedia.org/wiki/John_von_Neumann" target="_blank" rel="noopener">John von Neumann</a>于1945年提出。归并排序算法是运用分治策略（Divide-and-conquer）的典型算法，它有许多中不同的实现，且大多数实现是稳定排序。归并排序的示意图（出自<a href="https://en.wikipedia.org/wiki/Merge_sort#Top-down_implementation_using_lists" target="_blank" rel="noopener">维基百科：Merge sort</a>）如下：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/cc/Merge-sort-example-300px.gif/220px-Merge-sort-example-300px.gif" title="归并排序动态示意图"></p><a id="more"></a><h1 id="实现">实现</h1><p>归并排序在每层递归时有三个步骤（遵循分治模式）：</p><ul><li><p>分解（Divide）：分解待排序的n个元素的序列成各局n/2个元素的两个子序列。</p></li><li><p>解决（Conquer）：使用归并排序递归地排序两个子序列。</p></li><li><p>合并（Combine）：合并两个已排序的子序列以产生已排序的答案。</p></li></ul><h2 id="合并">合并</h2><p>合并过程是归并排序的关键操作。通过调用一个辅助过程merge(A, p, q, r)来完成，其中A是一个数组，p、q和r是数组下标，满足<span class="math inline">\(p\le{q}&lt;r\)</span>。假设子数组<code>A[p...q]</code>和<code>A[q+1...r]</code>都已经排好序。该过程合并这两个子数组形成单一的已排好序的数组来代替当前的数组<code>A[p...r]</code>。</p><p>合并时需要注意要时刻判断两个子数组是否为空，当某个子数组为空时，则无需比较，只需要将另一个子数组中的元素取出即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">merge(A, p, q, r):</span><br><span class="line">    创建新数组B[<span class="number">0.</span>.r-p]</span><br><span class="line">    将A[p..r]复制到B[<span class="number">0.</span>.r-p]</span><br><span class="line">    i = p</span><br><span class="line">    j = q</span><br><span class="line">    <span class="keyword">for</span> k = p to r:</span><br><span class="line">        <span class="keyword">if</span> i &lt; q <span class="keyword">and</span> (j &gt;= r <span class="keyword">or</span> B[i] &lt;= B[j]):  <span class="comment"># 用 i &lt; q 和 j &gt;=r 时刻判断非空</span></span><br><span class="line">            A[k] = B[i]</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            A[k] = B[j]</span><br><span class="line">            j = j + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>为了避免每次检查非空以简化代码，可以通过在子数组末尾放置一个哨兵（sentinel）元素。使用<span class="math inline">\(\infty\)</span>作为哨兵元素的值。当有效数组元素为空时，哨兵元素显露出来，它不可能小于其他非哨兵元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">merge(A, p, q, r):</span><br><span class="line">    <span class="comment"># --------准备工作-------------</span></span><br><span class="line">    创建两个新数组L[<span class="number">0.</span>.p-q+<span class="number">1</span>]和R[<span class="number">0.</span>.r-q]</span><br><span class="line">    将A[p..q]复制到L[<span class="number">0.</span>.p-q]</span><br><span class="line">    将B[q+<span class="number">1.</span>.r]复制到R[<span class="number">0.</span>.r-q<span class="number">-1</span>]</span><br><span class="line">    L[p-q+<span class="number">1</span>] = inf</span><br><span class="line">    R[r-q] = inf</span><br><span class="line">    <span class="comment"># -----------end--------------------</span></span><br><span class="line">    <span class="comment"># ---------比较------------</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k = p to r:</span><br><span class="line">        <span class="keyword">if</span> L[i] &lt; R[j]:</span><br><span class="line">            A[k] = L[i]</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            A[k] = R[j]</span><br><span class="line">            j = j + <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="自顶向下的实现">自顶向下的实现</h2><p>自顶向下的归并排序递归地将序列分解成子序列，直到子序列只有1个元素。当待排序的序列长度为1时，递归“开始回升”，此时无需合并，因为长度为1的每个序列是已排序的。之后合并这些子序列生成已排序的序列。上述示意图描述的就是自顶向下的归并排序算法的排序过程。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">merge_sort_top_down(A, p, r):</span><br><span class="line">    <span class="keyword">if</span> p &lt; r:    <span class="comment"># 当元素个数大于1时</span></span><br><span class="line">        q = (p + q) / <span class="number">2</span></span><br><span class="line">        merge_sort_top_down(A, p, q)</span><br><span class="line">        merge_sort_top_down(A, q + <span class="number">1</span>, r)</span><br><span class="line">        merge(A, p, q, r)</span><br></pre></td></tr></table></figure><h2 id="自底向上的实现">自底向上的实现</h2><p>自底向上的归并排序将原数组视为n个长度为1的子数组，然后依次合并两个相邻子数组，得到长度为2，4，6.…的已排序数组，直到整个数组。自底向上的归并排序的排序过程如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input:  6  5  3  1  8  7  2  4</span><br><span class="line">1st:    56  31  78  24</span><br><span class="line">2nd:    1356  2478</span><br><span class="line">3rd:    12345678</span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">merge_sort_bottom_up(A):</span><br><span class="line">    n = A.length</span><br><span class="line">    <span class="keyword">for</span> (width = <span class="number">1</span>; width &lt; n; width = <span class="number">2</span> * width):</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i = i + <span class="number">2</span> * width):</span><br><span class="line">            merge(A, i, min(i + width, n) - <span class="number">1</span>, min(i + <span class="number">2</span> * width, n) - <span class="number">1</span>)  <span class="comment"># 合并相邻数组</span></span><br></pre></td></tr></table></figure><h1 id="自然归并排序">自然归并排序</h1><p>自然归并排序（Natural merge sort）类似于自底向上的归并排序。自底向上的归并排序的出发点是1（将长度为n的数组视为n个长度为1的子数组，这n个子数组是已排序的）。而输入数组可能包含已排序的子数组，这些子数组可通过一遍遍历找出。自然归并排序将依次合并这些子数组。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Start:          3421758906</span><br><span class="line">Select runs:    34  2  17  589  06</span><br><span class="line">Merge:          234  15789  06</span><br><span class="line">Merge:          12345789  06</span><br><span class="line">Merge:          0123456789</span><br></pre></td></tr></table></figure><h1 id="分析">分析</h1><p>合并过程只需要一次遍历即可完成，运行时间是<span class="math inline">\(\Theta(n)\)</span>，n是合并后数组的长度。归并排序的<strong>平均</strong>和<strong>最坏</strong>情况下的时间复杂度是<span class="math inline">\(O(n\lg{n})\)</span>。</p><p>设T(n)为归并排序对长度为n的数组进行排序的运行时间，则归并排序的时间复杂度可以描述为<span class="math inline">\(T(n)=2T(n/2)+\Theta(n)\)</span>。可解得<span class="math inline">\(T(n)=O(n\lg{n})\)</span>。</p><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort_top_down</span><span class="params">(array, p, r)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> p &lt; r:</span><br><span class="line">        q = (p + r) // <span class="number">2</span></span><br><span class="line">        merge_sort_top_down(array, p, q)  <span class="comment"># 递归调用</span></span><br><span class="line">        merge_sort_top_down(array, q + <span class="number">1</span>, r)  <span class="comment"># 递归调用</span></span><br><span class="line">        merge(array, p, q, r)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort_bottom_up</span><span class="params">(array)</span>:</span></span><br><span class="line">    width, n = <span class="number">1</span>, len(array)</span><br><span class="line">    <span class="keyword">while</span> width &lt; n:</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            merge(array, i, min(i + width, n) - <span class="number">1</span>, min(i + (width &lt;&lt; <span class="number">1</span>), n) - <span class="number">1</span>)</span><br><span class="line">            i += (width &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        width = width &lt;&lt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(array, p, q, r)</span>:</span></span><br><span class="line">    <span class="string">"""合并array[p..q]与array[q+1..r]"""</span></span><br><span class="line">    left, right = array[p:q + <span class="number">1</span>], array[q + <span class="number">1</span>:r + <span class="number">1</span>]</span><br><span class="line">    left.append(float(<span class="string">"inf"</span>))</span><br><span class="line">    right.append(float(<span class="string">"inf"</span>))</span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(p, r + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">            array[k] = left[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            array[k] = right[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line">    merge_sort_top_down(arr, <span class="number">0</span>, len(arr) - <span class="number">1</span>)</span><br><span class="line">    print(arr)</span><br><span class="line">    arr = [<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line">    merge_sort_bottom_up(arr)</span><br><span class="line">    print(arr)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 2, 3, 4, 7, 8, 9, 10, 14, 16]</span><br><span class="line">[1, 2, 3, 4, 7, 8, 9, 10, 14, 16]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort </tag>
            
            <tag> Introduction to Algorithms </tag>
            
            <tag> algorithms </tag>
            
            <tag> comparison sort </tag>
            
            <tag> divide and conquer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 列表推导</title>
      <link href="/programming/python-list-comprehensions/"/>
      <url>/programming/python-list-comprehensions/</url>
      
        <content type="html"><![CDATA[<h1 id="列表推导">列表推导</h1><p>列表推导（List comprehensions）提供了一种更简洁的方式来创建集合。例如创建一个平方和的列表：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>    squares.append(x**<span class="number">2</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="comment"># 在循环结束后，x 仍然存在。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用匿名方法摆脱这种副作用。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = list(map(<span class="keyword">lambda</span> y: y**<span class="number">2</span>, range(<span class="number">10</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用列表推导，代码更加简洁，可读性也更好。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = [z**<span class="number">2</span> <span class="keyword">for</span> z <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br></pre></td></tr></table></figure><h1 id="扩展">扩展</h1><p>一个列表推导语句至少要有一对内含 <code>for</code> 语句的括号（例如 <code>[x for x in range(9)]</code>），<code>for</code> 语句后面可以跟其他 <code>for</code> 或 <code>if</code> 语句。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] <span class="keyword">if</span> x != y]</span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">1</span>, <span class="number">5</span>), (<span class="number">1</span>, <span class="number">6</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">2</span>, <span class="number">6</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 for 和 if 语句按序拆开，上述语句等价于</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>combs = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">if</span> x != y:</span><br><span class="line"><span class="meta">... </span>                    combs.append((x, y))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>combs</span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">1</span>, <span class="number">5</span>), (<span class="number">1</span>, <span class="number">6</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">2</span>, <span class="number">6</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure><h1 id="嵌套">嵌套</h1><p>列表推导自身可以嵌套使用，用来创建一个多维列表。下面是求转置矩阵的例子。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">    [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">    [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],</span><br><span class="line">    [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法1：两个comprehensions嵌套</span></span><br><span class="line">transposed = [[row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2：一个comprehension</span></span><br><span class="line">transposed = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    transposed.append([row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法3：原生</span></span><br><span class="line">transposed = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    transposed_row = []</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> matrix:</span><br><span class="line">        transposed_row.append(row[i])</span><br><span class="line">    transposed.append(transposed_row)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际使用时，更倾向于内建方法。如 zip() 方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(*matrix))</span><br><span class="line">[(<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>), (<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>), (<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>), (<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>)]</span><br></pre></td></tr></table></figure><h1 id="创建集合和字典">创建集合和字典</h1><p>类似的操作同样适用于创建集合和字典。可以称之为集合推导（Set comprehensions）和字典推导（Dictionary comprehensions）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;s <span class="keyword">for</span> s <span class="keyword">in</span> <span class="string">'hello world'</span>&#125;</span><br><span class="line">&#123;<span class="string">'w'</span>, <span class="string">'o'</span>, <span class="string">'r'</span>, <span class="string">'h'</span>, <span class="string">'l'</span>, <span class="string">' '</span>, <span class="string">'d'</span>, <span class="string">'e'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;k:v <span class="keyword">for</span> k, v <span class="keyword">in</span> enumerate([<span class="string">'zero'</span>, <span class="string">'first'</span>, <span class="string">'second'</span>])&#125;</span><br><span class="line">&#123;<span class="number">0</span>: <span class="string">'zero'</span>, <span class="number">1</span>: <span class="string">'first'</span>, <span class="number">2</span>: <span class="string">'second'</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> zip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 循环技巧</title>
      <link href="/programming/python-looping-techniques/"/>
      <url>/programming/python-looping-techniques/</url>
      
        <content type="html"><![CDATA[<h1 id="同时遍历-key-和-value">同时遍历 key 和 value</h1><p>使用 <code>items()</code> 方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic = &#123;<span class="string">'name'</span>: <span class="string">'chen'</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> dic.items():</span><br><span class="line"><span class="meta">... </span>    print(k, v)</span><br><span class="line">...</span><br><span class="line">name chen  </span><br><span class="line">gender male</span><br></pre></td></tr></table></figure><h1 id="同时遍历-index-和-value">同时遍历 index 和 value</h1><p>使用 <code>enumerate()</code> 方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate([<span class="string">'zero'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]):</span><br><span class="line"><span class="meta">... </span>    print(i, v)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> zero</span><br><span class="line"><span class="number">1</span> one</span><br><span class="line"><span class="number">2</span> two</span><br><span class="line"><span class="number">3</span> three</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="同时遍历多个数组">同时遍历多个数组</h1><p>使用 <code>zip()</code> 方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>eng = [<span class="string">'zero'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n, e <span class="keyword">in</span> zip(nums, eng):</span><br><span class="line"><span class="meta">... </span>    print(n, e)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> zero</span><br><span class="line"><span class="number">1</span> one</span><br><span class="line"><span class="number">2</span> two</span><br></pre></td></tr></table></figure><h1 id="反序遍历">反序遍历</h1><p>使用 <code>reversed()</code> 方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(<span class="number">2</span>, <span class="number">11</span>, <span class="number">2</span>)):</span><br><span class="line"><span class="meta">... </span>    print(i, end=<span class="string">' '</span>)</span><br><span class="line">...</span><br><span class="line"><span class="number">10</span> <span class="number">8</span> <span class="number">6</span> <span class="number">4</span> <span class="number">2</span> &gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h1 id="排序和去重">排序和去重</h1><p>使用 <code>sorted()</code> 和 <code>set()</code> 方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>basket = [<span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'apple'</span>, <span class="string">'banana'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> f <span class="keyword">in</span> sorted(set(basket)):</span><br><span class="line"><span class="meta">... </span>    print(f)</span><br><span class="line">...</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br></pre></td></tr></table></figure><h1 id="循环里面的-else">循环里面的 else</h1><p>退出循环时执行 <code>else</code> 块中代码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">if</span> n % x == <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>                    print(n, <span class="string">'equals'</span>, x, <span class="string">'*'</span>, n//x)</span><br><span class="line"><span class="meta">... </span>                    <span class="keyword">break</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>            print(n, <span class="string">'is a prime number'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="number">2</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">3</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">4</span> equals <span class="number">2</span> * <span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">6</span> equals <span class="number">2</span> * <span class="number">3</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">8</span> equals <span class="number">2</span> * <span class="number">4</span></span><br><span class="line"><span class="number">9</span> equals <span class="number">3</span> * <span class="number">3</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性时间排序</title>
      <link href="/notes/introduction-to-algorithms/sorting-in-linear-time/"/>
      <url>/notes/introduction-to-algorithms/sorting-in-linear-time/</url>
      
        <content type="html"><![CDATA[<h1 id="计数排序">计数排序</h1><p>计数排序于 1954 年由 Harold H. Seward 提出，是一种线性时间排序算法。它是稳定排序算法，这个性质很重要，是它可以作为基数排序子过程的前提。但不是原址排序算法，即需要额外的随输入规模增大的辅助空间。计数排序不是比较排序，摆脱了比较排序的下界 <span class="math inline">\(\Omega(n\lg{n})\)</span>，可以在线性时间内完成排序。</p><p>计数排序先“数”出不同元素值的个数，之后通过算数运算求出不同元素值排序后的位置。它的运行时间是 <span class="math inline">\(O(max-min)\)</span>。计数排序比较适用于，输入数组中最大值和最小值的差不特别大于元素个数的情况。但计数排序可以用作别的排序的子过程，例如 <a href="/notes/introduction-to-algorithms/sorting-in-linear-time/" title="线性时间排序">线性时间排序</a>基数排序，基数排序可以很好的处理上述情况。</p><h2 id="实现">实现</h2><p>计数排序假设，输入数组是一组从 0 开始，最大值不超过 k（即小于等于 k）的整型数组。在某些情况下，k 可能已知，比如十进制数的基数排序中 <code>k = 9</code>。在未知的时候，需要通过遍历数组，得出 k 的值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">counting_sort(A, B, k):   <span class="comment"># A：输入；B：输出 ；k：A中的最大值</span></span><br><span class="line">    C = new array[k+<span class="number">1</span>]    <span class="comment"># C：辅助数组</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to A.length - <span class="number">1</span>:</span><br><span class="line">        C[A[i]] = C[A[i]] + <span class="number">1</span>   <span class="comment"># C[i] = n: 有n个元素的等于i</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to k:</span><br><span class="line">        C[i] = C[i] + C[i + <span class="number">1</span>]  <span class="comment"># C[i] = n: 有n个元素的值小于等于i</span></span><br><span class="line">    <span class="keyword">for</span> j = A.length - <span class="number">1</span> to <span class="number">0</span>:</span><br><span class="line">        B[C[A[i]] - <span class="number">1</span>] = A[i]</span><br><span class="line">        C[A[i]] = C[A[i]] - <span class="number">1</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>Q: 为什么不在第一个循环之后借助数组C直接输出排序后的数组？</p><p>A: 保证计数排序算法的稳定性（如果不要求排序结果的稳定性可以这样做）。在下面的基数排序算法中，计数排序通常作为子排序过程出现，而且为了保证基数排序是正确的，子排序过程必须是稳定的。</p><h2 id="分析">分析</h2><p>计数排序的代码只有三个循环，第一个和第三个循环执行 n 次，第二个循环执行 k 次，每个循环的单次运行时间都是 <span class="math inline">\(\Theta(1)\)</span>。所以总运行时间是 <span class="math inline">\(T(n)=2\Theta(n)+\Theta(k)=\Theta(k+n)\)</span>。当 <span class="math inline">\(k=\Theta(n)\)</span> 的时候，即数组中的最大值随数组大小线性变化时，<span class="math inline">\(T(n)=\Theta(n)\)</span>，计数排序可以在线性时间内完成排序。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counting_sort</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    c = [<span class="number">0</span>] * (max(a) + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">        c[a[i]] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(c)):</span><br><span class="line">        c[i] += c[i - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        b[c[a[i]] - <span class="number">1</span>] = a[i]</span><br><span class="line">        c[a[i]] -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="基数排序">基数排序</h1><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字（位数不足的数字高位补零），然后按每个位数分别比较。基数排序最初是应用在卡片排序机上的算法，可以被“机械编程”。</p><h2 id="实现-1">实现</h2><p>基数排序的方式可以采用 LSD（Least significant digital）或 MSD（Most significant digital）。LSD 即从最低位开始比较，MSD 相反，从最高位开始比较。</p><ul><li><p>MSD 的排序过程：按最高有效位进行排序，按最高位分别放入“容器 0-9”，然后按下一个最高位递归的对每个容器中的数进行排序。</p><p>使用 MSD 排序一组数的例子如下，表中省略了没有数的容器（没有被空行隔开的数位于同一个容器内）：</p></li></ul><table><colgroup><col style="width: 20%"><col style="width: 20%"><col style="width: 20%"><col style="width: 20%"><col style="width: 20%"></colgroup><thead><tr class="header"><th>输入数组</th><th>按第一高位排序后</th><th>按第二高位递归排序</th><th>按第三高位递归排序容器</th><th>按序收集</th></tr></thead><tbody><tr class="odd"><td><code>004</code><br><code>178</code><br><code>045</code><br><code>009</code><br><code>135</code><br></td><td><code>004</code><br><code>045</code><br><code>009</code><br><br><code>178</code><br><code>135</code></td><td><code>004</code><br><code>009</code><br><br><code>045</code><br><br><code>135</code><br><br><code>178</code></td><td><code>004</code><br><br><code>009</code><br><br><code>045</code><br><br><code>135</code><br><br><code>178</code></td><td><code>004</code><br><code>009</code><br><code>045</code><br><code>135</code><br><code>178</code></td></tr></tbody></table><ul><li><p>LSD 的排序过程：按最低有效位进行排序，将排序结果放入同一个”容器“，然后按下一个最低位重复排序，再收集，直至最高位排序完成。</p><p>同样的输入，使用 LSD 排序的例子如下：</p></li></ul><table><colgroup><col style="width: 27%"><col style="width: 22%"><col style="width: 27%"><col style="width: 22%"></colgroup><thead><tr class="header"><th>输入数组</th><th>按第一低位排序后</th><th>第二低位</th><th>第三低位</th></tr></thead><tbody><tr class="odd"><td><code>004</code><br><code>178</code><br><code>045</code><br><code>009</code><br><code>135</code><br></td><td><code>004</code><br><code>045</code><br><code>135</code><br><code>178</code><br><code>009</code></td><td><code>004</code><br><code>009</code><br><code>135</code><br><code>045</code><br><code>178</code></td><td><code>004</code><br><code>009</code><br><code>045</code><br><code>135</code><br><code>178</code></td></tr></tbody></table><hr><p>在 MSD 排序中，每次递归都需要额外准备 10 个“容器”用来保存排序结果。如果递归深度比较大，MSD 会占用非常多的空间。</p><p>相比之下，LSD 只需要 10 个“容器”，在下一次循环开始前，“容器”中的数被收集起来，“容器”可以重复使用。</p><p>因此基数排序采用 LSD 进行排序，也因此要求子过程必须是稳定的。即高位的比较结果不能破坏低位的比较结果。</p><p>例如004和009：</p><p>按照第一低位排序后，004 在 009 之前。二者的第二低位都为 0，此时它们的大小就由第一低位决定。因此需要保证在按第二低位排序时，二者的前后顺序不能改变，即排序必须是稳定的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">radix_sort(A, d):</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to d:  <span class="comment"># d 是有效位数</span></span><br><span class="line">        use a stable sort to sort array A on i</span><br></pre></td></tr></table></figure><p>对于十进制数字来说，每一位只会出现 10 种数字（0-9），因此计数排序是一个好的选择。</p><h2 id="分析-1">分析</h2><p>基数排序的时间代价依赖于所使用的稳定的排序算法。如果子过程是计数排序的话，则基数排序的时间复杂度可以描述为 <span class="math inline">\(d\Theta(n+k)=\Theta(d(n+k))\)</span>。当 d 为常数（位数固定）且 <code>k=O(n)</code>（每位数字都在 0 到 k-1 区间内）时，基数排序具有线性时间代价。</p><h2 id="代码-1">代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="string">"""十进制数的基数排序算法"""</span></span><br><span class="line">    c, b = [], [<span class="literal">None</span>] * len(a)  <span class="comment"># b是一个辅助数组</span></span><br><span class="line">    digit, _max = <span class="number">1</span>, max(a)</span><br><span class="line">    <span class="keyword">while</span> _max // digit &gt; <span class="number">0</span>:</span><br><span class="line">        c = [<span class="number">0</span>] * <span class="number">10</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">            c[(a[i] // digit) % <span class="number">10</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(c)):</span><br><span class="line">            c[i] += c[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(len(a))):</span><br><span class="line">            target = (a[i] // digit) % <span class="number">10</span></span><br><span class="line">            b[c[target] - <span class="number">1</span>] = a[i]</span><br><span class="line">            c[target] -= <span class="number">1</span></span><br><span class="line">        a[:] = b[:]</span><br><span class="line">        digit *= <span class="number">10</span></span><br></pre></td></tr></table></figure><h1 id="桶排序">桶排序</h1><p>桶排序（Bucket sort）或箱排序，工作原理是将数组分到有限数量的桶里。每个桶再个别排序。</p><p>计数排序假设输入数据都属于一个小区间内的整数，桶排序也对输入作了某种假设。桶排序假设输入服从均匀分布，平均情况下时间代价为 <code>O(n)</code>。</p><h2 id="实现-2">实现</h2><p>桶排序将 <code>[0,1)</code> 区间划分为 k 个大小相同的子区间，或称为桶。然后，将 n 个输入数分别放到各个桶中。对每个桶中的数进行排序，然后遍历每个桶，按照次序把各个桶中的元素列出来即可。因为输入是均匀、独立地分布在 <code>[0,1)</code> 区间上，所以一般不会出现很多数落在同一个桶中的情况。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bucket_sort(A):</span><br><span class="line">    n = A.length</span><br><span class="line">    B = new array[k]</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to k - <span class="number">1</span>:</span><br><span class="line">        make B[i] an empty list        <span class="comment"># make k buckets</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to n - <span class="number">1</span>:</span><br><span class="line">        insert A[i] into list B[floor(k * A[i])]</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to k - <span class="number">1</span>:</span><br><span class="line">        sort list B[i] <span class="keyword">with</span> insertion sort</span><br><span class="line">    concatenate the lists B[<span class="number">0</span>], B[<span class="number">1</span>],...,B[k<span class="number">-1</span>] together <span class="keyword">in</span> order</span><br></pre></td></tr></table></figure><p>例如 k=10 时，排序一组数的过程如下：</p><table><thead><tr class="header"><th>输入</th><th>所属桶（<code>floor(k * A[i])</code></th><th>桶序号</th><th>桶中元素</th><th>排序后桶中元素</th></tr></thead><tbody><tr class="odd"><td>0.78</td><td>7</td><td>0</td><td></td><td></td></tr><tr class="even"><td>0.17</td><td>1</td><td>1</td><td>0.17、0.12</td><td>0.12、0.17</td></tr><tr class="odd"><td>0.39</td><td>3</td><td>2</td><td>0.26、0.21、0.23</td><td>0.21、0.23、0.26</td></tr><tr class="even"><td>0.26</td><td>2</td><td>3</td><td>0.39</td><td>0.39</td></tr><tr class="odd"><td>0.72</td><td>7</td><td>4</td><td></td><td></td></tr><tr class="even"><td>0.94</td><td>9</td><td>5</td><td></td><td></td></tr><tr class="odd"><td>0.21</td><td>2</td><td>6</td><td>0.68</td><td>0.68</td></tr><tr class="even"><td>0.12</td><td>1</td><td>7</td><td>0.78、0.72</td><td>0.72、0.78</td></tr><tr class="odd"><td>0.23</td><td>2</td><td>8</td><td></td><td></td></tr><tr class="even"><td>0.68</td><td>6</td><td>9</td><td>0.94</td><td>0.94</td></tr></tbody></table><p>遍历桶中元素即可得到排序结果。</p><h2 id="分析-2">分析</h2><p>除去调用插入排序的代码，其他代码可以在 <span class="math inline">\(\Theta(1)\)</span> 时间内完成。已知插入排序的时间复杂度为 <span class="math inline">\(O(n^2)\)</span>，n 为元素个数。桶排序对每个桶都调用了插入排序，桶中有多少元素直接影响到时间代价。设桶 i 中的元素个数为 <span class="math inline">\(n_i\)</span>，则桶排序的时间代价可以描述为：</p><p><span class="math display">\[T(n)=\Theta(n)+\sum_{i=0}^{k-1}{O(n_i^2)}\]</span></p><p>虽然无法准确直到每个桶中元素个数，从而无法计算上述时间代价。但可以计算其期望。通过对上式求期望：</p><p><span class="math display">\[\begin{aligned}E[T(n)]&amp;=E[\Theta(n)+\sum_{i=0}^{k-1}{O(n_i^2)}]\\&amp;=\Theta(n)+\sum_{i=0}^{k-1}{E[O(n_i^2)]}\\&amp;=\Theta(n)+\sum_{i=0}^{k-1}{O(E[n_i^2])}\end{aligned}\]</span></p><p>桶排序假设输入服从均匀分布，因此可以认为元素落到每个桶的概率是相同的，为 1/k。n 个元素分到 k 个桶（设为随机变量 X），X 服从参数为 n 和 1/k 的二项分布，<span class="math inline">\(X\sim{b(n,1/k)}\)</span>。通过二项分布的期望和方差可以快速计算出 <span class="math inline">\(E(n_i^2)\)</span>。</p><p><span class="math display">\[\begin{aligned}E(n_i^2)&amp;=E(X^2)\\&amp;=V(X)+(E(X))^2\\&amp;=n\frac{1}{k}(1-\frac{1}{k})+(n\frac{1}{k})^2\\&amp;=\frac{n^2+nk-n}{k^2}\end{aligned}\]</span></p><p>由此可以得出桶排序的期望时间代价为</p><p><span class="math display">\[\begin{aligned}E[T(n)]&amp;=\Theta(n)+\sum_{i=0}^{k-1}{O(E[n_i^2])}\\&amp;=\Theta(n)+kO(\frac{n^2+nk-n}{k^2})\\&amp;=\Theta(n)+O(\frac{n^2}{k}+n)\end{aligned}\]</span></p><p>如果桶的个数 <span class="math inline">\(k=\Theta(n)\)</span>，则上式等于 <code>O(n)</code>，桶排序可以在线性时间内结束。如果 k=n，则桶排序近似等价于计数排序。</p><p>总结：虽然插入排序的时间复杂度是 <span class="math inline">\(O(n^2)\)</span>，但在 n 比较小的时候同其他比较排序的差距并不明显。桶排序就是将原数组分到不同的桶中，使得各个桶中的元素个数比较小且桶之间满足次序关系，再对桶中元素使用插入排序。</p><h2 id="代码-2">代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> insertion_sort <span class="keyword">import</span> insertion_sort</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucket_sort</span><span class="params">(a)</span>:</span></span><br><span class="line">    b = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a))]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">        b[math.floor(len(a) * a[i])].append(a[i])</span><br><span class="line">    a.clear()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(b)):</span><br><span class="line">        insertion_sort(b[i])</span><br><span class="line">        a.extend(b[i])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort </tag>
            
            <tag> Introduction to Algorithms </tag>
            
            <tag> algorithms </tag>
            
            <tag> non-comparison sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插入排序、选择排序和冒泡排序</title>
      <link href="/notes/introduction-to-algorithms/insertion-sort-selection-sort-and-bubble-sort/"/>
      <url>/notes/introduction-to-algorithms/insertion-sort-selection-sort-and-bubble-sort/</url>
      
        <content type="html"><![CDATA[<h1 id="插入排序">插入排序</h1><p>对于少量元素的排序，插入排序（Insertion sort）是一个有效的算法。插入排序的工作方式像许多人排序一手扑克牌。开始时左手为空，每次从桌子上拿走一张牌并将它插入左手中正确的位置。插入排序将输入数组分成未排序部分和已排序部分两个子数组，初始时已排序部分为空（或者有一个，因为一个数的数组是已排序的），每次迭代从未排序数组中选择一个元素，将其放入已排序数组中的合适位置。</p><p>插入排序示意图（出自<a href="https://en.wikipedia.org/wiki/Insertion_sort" target="_blank" rel="noopener">维基百科：Insertion sort</a>）：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif" title="插入排序动态示意图"></p><h2 id="实现">实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">insertion_sort(A):</span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">1</span> to A.length - <span class="number">1</span>:</span><br><span class="line">        key = A[j]</span><br><span class="line">        <span class="comment"># Insert A[j] into the sorted sequence A[1...j-1]</span></span><br><span class="line">        i = j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> A[i] &gt; key:</span><br><span class="line">            A[i + <span class="number">1</span>] = A[i]</span><br><span class="line">            i = i - <span class="number">1</span></span><br><span class="line">        A[i + <span class="number">1</span>] = key</span><br></pre></td></tr></table></figure><a id="more"></a><p>循环不变式（<a href="https://en.wikipedia.org/wiki/Loop_variant" title="Loop variant" target="_blank" rel="noopener">Loop variant</a>）用来帮助理解算法的正确性。关于循环不变式，必须证明三条性质。</p><ul><li>初始化：循环的第一次迭代前，它为真。</li><li>保持：如果循环的某次迭代前它为真，那么下次迭代前它仍为真。</li><li>终止：在循环终止时，不变式提供一个有用的性质，该性质有助于证明算法是正确的。</li></ul><p>（类似于数学归纳法）</p><p>用下面的循环不变式证明插入排序算法的正确性。</p><blockquote><p>在for循环的每次迭代开始前，子数组<code>A[0...(j-1)]</code>由原来在<code>A[0...(j-1)]</code>中的元素组成，但已按序排列。</p></blockquote><ul><li>初始化：循环的第一次迭代前，j=1，子数组只包含A[0]，它为真。</li><li>保持：for循环里面嵌套了一个while循环，同样可以用另一个循环不变式证明它。但对于简单的循环，同样可以通过非形式化的分析证明其正确性。非形式化地，while循环将 A[j-1], A[j-2]等向右移动一个位置，直到找到A[j]的适当位置。最后将A[j]插入该位置。此时，子数组<code>A[0...(j)]</code>由原来在 <code>A[0...(j)]</code>中的元素组成，但已按序排列。那么下一次迭代增加j，上述循环不变式为真。</li><li>终止：循环终止时j=A.length，则根据循环不变式子数组<code>A[0...(A.length-1)]</code>由原来在<code>A[0...(A.length-1)]</code>中的元素组成，但已按序排列。此时<code>A[0...(A.length-1)]</code>就是整个数组。因此该算法正确。</li></ul><h2 id="分析">分析</h2><p>在for循环内部，除去while循环的语句执行时间均为<span class="math inline">\(\Theta(1)\)</span>（即常数时间内），for循环执行n-1次。while循环的运行时间与数组的已排序程度有关系。若输入数组已按递增序排好，则导致最佳情况。若输入数组已反向排序，即按递减序排好，则导致最坏情况。在while循环处，必须将每个元素 A[j]与整个已排序子数组<code>A[0...(j-1)]</code>中每个元素进行比较。</p><table><thead><tr class="header"><th>j</th><th>最佳时比较元素</th><th>比较次数</th><th>最坏时比较元素</th><th>比较次数</th></tr></thead><tbody><tr class="odd"><td>1</td><td>A[0]</td><td>1</td><td>A[0]</td><td>1</td></tr><tr class="even"><td>2</td><td>A[1]</td><td>1</td><td>A[0, 1]</td><td>2</td></tr><tr class="odd"><td><span class="math inline">\(\vdots\)</span></td><td><span class="math inline">\(\vdots\)</span></td><td><span class="math inline">\(\vdots\)</span></td><td><span class="math inline">\(\vdots\)</span></td><td><span class="math inline">\(\vdots\)</span></td></tr><tr class="even"><td>n-1</td><td>A[n-2]</td><td>1</td><td><code>A[0...(n-2)]</code></td><td>n-1</td></tr></tbody></table><p>最佳情况下，while循环的执行时间为<span class="math inline">\(\sum_{n=1}^{n-1}1=n-1\)</span>。</p><p>最佳运行时间为<span class="math inline">\(T(n)=(n-1)\Theta(1)+n-1=\Theta(n)\)</span>。它是n的线性函数。</p><p>最坏情况下，while循环的执行时间为<span class="math inline">\(\sum_{n=1}^{n-1}n=\frac{n(n-1)}{2}\)</span>。</p><p>所以，插入排序的最坏情况运行时间为<span class="math inline">\(T(n)=(n-1)\Theta(1)+\frac{n(n-1)}{2}\le{n^2}=O(n^2)\)</span>。此时它是n的二次函数。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(a)):</span><br><span class="line">        key = a[j]</span><br><span class="line">        i = j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> a[i] &gt; key:</span><br><span class="line">            a[i + <span class="number">1</span>] = a[i]</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        a[i + <span class="number">1</span>] = key</span><br></pre></td></tr></table></figure><h2 id="最坏最佳与平均情况">最坏、最佳与平均情况</h2><p>最坏情况比最佳情况更加有用，算法导论给出了三点理由。</p><ul><li>一个算法的最坏情况运行时间给出了任何输入的运行时间的一个上界。知道了这个界，就能确保该算法绝不需要更长的时间。</li><li>对某些算法，最坏情况经常出现。例如，当数据库中检索一条特定信息时，若该信息不在数据库中出现，则检索算法的最坏情况会出现。在某些应用中，对缺失信息的检索可能是频繁的。</li><li>“平均情况”往往与最坏情况大致一致。假定随机选择n个数并应用插入排序。平均来说，<code>A[0...(j-1)]</code>中的一般元素小于A[j]，一半元素大于A[j]。所以，平均来说，每次while循环的比较次数大约为j/2。导致平均情况运行时间结果像最坏情况运行时间一样，也是输入规模的一个二次函数。</li></ul><p>在某些特定情况下，会对一个算法的平均情况运行时间感兴趣。平均情况分析的范围有限，因为对于特定的问题，什么构成一种“平均”输入并不明显。</p><h1 id="选择排序">选择排序</h1><p>如果说插入排序是拿一张牌去找在左手中的位置，那么选择排序就是找出最小的牌，放到左手的末位（或者找最大的牌，放到左手的首位）。与插入排序类似，选择排序也将输入数组分成已排序和未排序两个子数组，每次迭代选择未排序数组中最小（或最大，取决于排序规则）的元素，将其与未排序子数组的第一位元素交换，然后扩展已排序数组的边界加一。</p><p>选择排序示意图（出自<a href="https://en.wikipedia.org/wiki/Selection_sort" title="Selection sort" target="_blank" rel="noopener">维基百科：Selection sort</a>）：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif" title="选择排序动态示意图"></p><h2 id="实现-1">实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">selection_sort(A):</span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">0</span> to A.length - <span class="number">2</span>:</span><br><span class="line">        i_min = j</span><br><span class="line">        <span class="keyword">for</span> i = j + <span class="number">1</span> to A.length - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> A[i] &lt; A[i_min]:</span><br><span class="line">                i_min = i</span><br><span class="line">        <span class="keyword">if</span> i_min != j:</span><br><span class="line">            exchange A[i_min] <span class="keyword">with</span> A[j]</span><br></pre></td></tr></table></figure><h2 id="分析-1">分析</h2><p>外层循环执行n-1次，单次运行时间为<span class="math inline">\(\Theta(1)\)</span>。内层循环寻找下一个最小的数执行n-1-j次，单次运行时间也是<span class="math inline">\(\Theta(1)\)</span>。</p><p>总运行时间为：</p><p><span class="math display">\[\begin{aligned}T(n)&amp;=n-1+\sum_{j=0}^{n-2}n-i-j \\&amp;=n-1+\sum_{i=1}^{n-1}n-i \\&amp;=n-1+\frac{n(n-1)}{2} \\&amp;=O(n^2)\end{aligned}\]</span></p><h2 id="代码-1">代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(a) - <span class="number">1</span>):</span><br><span class="line">        i_min = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(j + <span class="number">1</span>, len(a)):</span><br><span class="line">            <span class="keyword">if</span> a[i] &lt; a[i_min]:</span><br><span class="line">                i_min = i</span><br><span class="line">        <span class="keyword">if</span> i_min != j:</span><br><span class="line">            a[i_min], a[j] = a[j], a[i_min]</span><br></pre></td></tr></table></figure><h1 id="冒泡排序">冒泡排序</h1><p>冒泡排序（Bubble sort）通过依次比较两个相邻的元素，如果它们的顺序关系是错误的，就交换它们。正如它的命名一样，比较大的元素先浮到数组顶端。</p><p>冒泡排序示意图（出自<a href="https://en.wikipedia.org/wiki/Bubble_sort" title="冒泡排序" target="_blank" rel="noopener">维基百科：Bubble sort</a>）：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif" title="冒泡排序动态示意图"></p><h2 id="实现-2">实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bubble_sort(A):</span><br><span class="line">    n = A.length</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to n - <span class="number">1</span>:       <span class="comment"># 每次循环将下一个最大元素冒泡到正确位置</span></span><br><span class="line">        swapped = false</span><br><span class="line">        <span class="keyword">for</span> j = <span class="number">1</span> to n - i:   <span class="comment"># 后i位元素大于之前的元素且已经排好序</span></span><br><span class="line">            <span class="keyword">if</span> A[j - <span class="number">1</span>] &gt; A[j]:</span><br><span class="line">                exchange A[j] <span class="keyword">with</span> A[j - <span class="number">1</span>]</span><br><span class="line">                swapped = true</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> swapped:       <span class="comment"># 结束排序</span></span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h3 id="优化">优化</h3><p>与其记录swapped=true or false，不如记录下最后发生交换的位置i，之后没有发生交换意味着i之后的元素全部大于i之前的元素且已经按序排好。那么在下次冒泡前，结束位置可以直接跳到i。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bubble_sort(A):</span><br><span class="line">    target = A.length</span><br><span class="line">    <span class="keyword">while</span> target &gt; <span class="number">1</span>:</span><br><span class="line">        last_swap = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j = <span class="number">1</span> to target - <span class="number">1</span>:   <span class="comment"># target及target之后的元素大于之前的元素且已经排好序</span></span><br><span class="line">            <span class="keyword">if</span> A[j - <span class="number">1</span>] &gt; A[j]:</span><br><span class="line">                exchange A[j] <span class="keyword">with</span> A[j - <span class="number">1</span>]</span><br><span class="line">                last_swap = j</span><br><span class="line">        target = last_swap</span><br></pre></td></tr></table></figure><h2 id="分析-2">分析</h2><p>冒泡排序的平均时间和最坏时间复杂度为<span class="math inline">\(O(n^2)\)</span>。在实际应用中，时间复杂度同样是<span class="math inline">\(O(n^2)\)</span>的插入排序一般比冒泡排序要快，更不用说还有其他更快的排序算法。</p><p>冒泡排序可以用来检测一个数组是否已经排好序，即冒泡排序的最佳情况运行时间O(n)。插入排序同样可以在O(n)时间内检测一个数组是否排好序，且比冒泡排序好。</p><h2 id="代码-2">代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(a)</span>:</span></span><br><span class="line">    target = len(a)</span><br><span class="line">    <span class="keyword">while</span> target &gt; <span class="number">1</span>:</span><br><span class="line">        last_swapped = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, target):</span><br><span class="line">            <span class="keyword">if</span> a[j - <span class="number">1</span>] &gt; a[j]:</span><br><span class="line">                a[j - <span class="number">1</span>], a[j] = a[j], a[j - <span class="number">1</span>]</span><br><span class="line">                last_swapped = j</span><br><span class="line">        target = last_swapped</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort </tag>
            
            <tag> Introduction to Algorithms </tag>
            
            <tag> algorithms </tag>
            
            <tag> comparison sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆和堆排序</title>
      <link href="/notes/introduction-to-algorithms/heaps-and-heapsort/"/>
      <url>/notes/introduction-to-algorithms/heaps-and-heapsort/</url>
      
        <content type="html"><![CDATA[<h1 id="堆">堆</h1><p>堆（Heap）始于<a href="https://en.wikipedia.org/wiki/J._W._J._Williams" target="_blank" rel="noopener">J. W. J. Williams</a>在 1964 年发表的堆排序（heap sort）。</p><p>堆是一种基于树的数据结构，一棵满足以下性质的完全树可称为堆。</p><blockquote><p>给定堆中任意节点 <code>P</code> 和 <code>C</code>，若 <code>P</code> 是 <code>C</code> 的母节点，那么 <code>P</code> 的值小于等于（或大于等于）<code>C</code> 的值。</p><ol type="1"><li>若 <code>P</code> 的值小于等于 <code>C</code> 的值，称为最小堆（min heap）。</li><li>若 <code>P</code> 的值大于等于 <code>C</code> 的值，称为最大堆（max heap）。</li></ol></blockquote><p>在堆中最顶端的节点称为根节点（root node），根节点本身没有母节点（parent node）。</p><p>常见的堆有二叉堆、斐波那契堆等。</p><a id="more"></a><h1 id="操作">操作</h1><p>一个堆应该支持以下常见操作（参考了<a href="https://en.wikipedia.org/wiki/Heap_(data_structure)" title="Heap" target="_blank" rel="noopener">维基百科</a>）。</p><ul><li><code>peek()</code>：返回堆顶元素。</li><li><code>pop()</code>：返回并移除堆顶元素，需要调整堆。</li><li><code>append(x)</code>：添加一个新的元素​，需要调整堆以满足堆的性质。</li><li><code>replace()</code>：相当于一次 <code>pop</code> 之后 <code>append</code>。但比分别执行更效率，因为只需要调整一次堆。</li></ul><hr><ul><li><code>heapify()</code>：创建一个堆。只需要调用一次。</li><li><code>merge(other)</code>：合并 other 中的元素到堆。</li></ul><hr><ul><li><code>size()</code>：返回堆中元素个数。</li><li><code>is_empty()</code>：返回是否是空堆。</li></ul><hr><ul><li><code>increase_key(i, x)</code>：增大元素的值。</li><li><code>decrease_key(i, x)</code>：减小元素的值。</li><li><code>delete(i)</code>：删除指定的一个元素。</li><li><code>sift_up(i)</code>：不断上移元素，直到满足最小堆的性质。</li><li><code>sift_down(i)</code>：不断下移元素，直到满足最大堆的性质。</li></ul><h1 id="实现">实现</h1><p>堆通常用数组（静态或动态）实现，并且不需要保存指针。</p><p>树的根节点是 <code>A[0]</code>，给定一个节点的下标 <code>i</code>，通过计算可以得到它的母节点、左孩子和右孩子节点。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parent(i):</span><br><span class="line">    <span class="keyword">return</span> floor((i<span class="number">-1</span>) / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">left_child(i):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">right_child(i):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">2</span></span><br></pre></td></tr></table></figure><p><img src="/uploads/image/introduction-to-algorithms/heap-and-array.png"></p><h2 id="维护堆的性质">维护堆的性质</h2><p>以最大堆为例，如何维护一个数组使之满足最大堆性质。考虑下面这种情况。</p><ul><li>前提条件：<strong>根节点</strong>为 <code>left_child(i)</code> 和 <code>right_child(i)</code> 的二叉树都是最大堆。</li></ul><p><code>A[i]</code> 有可能小于其孩子节点，这违背了最大堆的性质。<code>sift_down()</code> 方法通过让 <code>A[i]</code> 在最大堆中“逐级下降”，从而使下标为 <code>i</code> 的子树重新遵循最大堆的性质。</p><p><img src="/uploads/image/introduction-to-algorithms/heap-sift-down.png"></p><p>关于逐级下降正确性的思考：满足前提条件的情况下，</p><p>假设根节点 <code>i</code> 有子节点 <code>x, y</code>，其中值最大的是子节点 <code>x</code>。交换 <code>i</code> 与 <code>x</code> 的值，现在 <code>A[i] &gt; A[x]</code>，满足最大堆的性质。但 <code>x</code> 的值相比交换前变小了，所以可能小于其子节点的值。</p><p>现在节点 <code>x</code> 可能小于其子节点的值，其子节点均大于或等于下一层子节点的值。符合前提条件，所以对 <code>x</code> 递归调用 <code>sift_down</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sift_down(A, i):</span><br><span class="line">    l = left_child(i)</span><br><span class="line">    r = right_child(i)</span><br><span class="line">    <span class="keyword">if</span> l &lt; size() <span class="keyword">and</span> A[l] &gt; A[i]:  <span class="comment"># 找最大值</span></span><br><span class="line">        largest = l</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        largest = i</span><br><span class="line">    <span class="keyword">if</span> r &lt; size() <span class="keyword">and</span> A[r] &gt; A[largest]:</span><br><span class="line">        largest = r</span><br><span class="line">    <span class="keyword">if</span> largest != i:              <span class="comment"># 违反最大堆性质</span></span><br><span class="line">        exchange A[i] <span class="keyword">with</span> A[largest]</span><br><span class="line">        sift_down(A, largest)     <span class="comment"># 递归</span></span><br></pre></td></tr></table></figure><p><code>sift_down</code> 的时间复杂度：</p><p>在一棵大小为 <code>n</code> ​的子树上，运行 <code>sift_down</code> 的时间 <code>T(n)</code> 包括：比较三个节点大小关系以及交换值的时间代价 <span class="math inline">\(\Theta(1)\)</span>，加上在一棵子树上运行 <code>sift_down</code> 的时间。子树的大小至多为 <code>2n/3</code>（最底层正好半满的时候，即最后一层左子树节点填满，右子树节点是空的），由此可以得到刻画程序运行时间的递归式：<span class="math inline">\(T(n)\le\Theta(1)+T(2n/3)\)</span>。解得 <span class="math inline">\(T(n)=O(\lg{n})\)</span>。</p><p>也就是说，对于一棵树高为 <code>h</code> 的节点来说，<code>sift_down</code> 的时间复杂度是 <span class="math inline">\(O(h)\)</span>。</p><p>关于一棵子树的大小至多为 <code>2n/3</code> 的由来。</p><p>首先明确关于树的两个性质：</p><ol type="1"><li>如果以某个节点为根节点的树是完全树，那么它的左子树大小大于等于右子树大小。因为完全树的最后一层是从左到右填入的。</li><li>如果一棵满二叉树的最后一层节点数目为 <code>n</code>，那么这个树的大小为 <code>2n-1</code>。因为满二叉树第 <code>i(i&gt;=0)</code> 层节点数量是 <span class="math inline">\(2^i\)</span>。</li></ol><p>根据性质 1，只需要考虑左子树最多为母树的几分之几即可。</p><p>假设一个完全树的大小为 <code>n</code>，它的左子树大小为 <code>i</code>，比值 <code>i/n</code> 根据最底层节点数目而变动。观察最底层节点数目从 0 逐渐增长时该比值的变化情况。</p><ul><li><p>当新增节点属于左子树时，比值由 <code>i/n</code> 变成 <code>(i+1)/(n+1)</code>，比值增大。</p></li><li><p>当新增节点属于右子树时，比值由 <code>i/n</code> 变成 <code>i/(n+1)</code>，比值减小。</p></li></ul><p>因此当左子树恰好填满（最底层恰好半满）时，比值最大。</p><p>设此时最低层节点个数为 <code>x</code>，注意这 <code>x</code> 个节点正好填满左子树最底层，则根据性质 2，<code>i=2x-1</code>，<span class="math inline">\(n=2*i+1-x=3x-1\)</span>。</p><p>所以得到 <span class="math inline">\(i/n=(2x-1)/(3x-1)\le2/3\)</span>。即大小为 <code>n</code> 的树中，子树的大小至多为 <code>2n/3</code>。</p><h2 id="建堆">建堆</h2><p>同样以最大堆为例，可以用<strong>自底向上</strong>的方法调用过程 <code>sift_down</code>，将一个数组转换为最大堆。过程 <code>heapify</code> 对树中非叶子节点都调用一次 <code>sift_down</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">heapify(A):</span><br><span class="line">    <span class="keyword">for</span> i = parent(size()<span class="number">-1</span>) downto <span class="number">0</span>:</span><br><span class="line">        sift_down(A, i)</span><br></pre></td></tr></table></figure><p>可以使用如下的循环不变量验证该过程的正确性。</p><blockquote><p>每一次 <code>for</code> 循环开始前，节点 <code>i, i+1, ..., size()</code> 都是一个最大堆的根节点。</p></blockquote><p>需要证明此循环不变量在循环开始前，迭代时以及结束后都成立。</p><ul><li>初始化：第一次迭代前，<code>i</code> 之后的节点都是叶节点，因此它们都是最大堆的根节点。</li><li>保持：注意到节点 <code>i+1</code>​ 始终比i先调用 <code>sift_down</code> 过程，根据循环不变量，它们都是最大堆的根节点。</li><li>终止：终止时 <code>i=-1​</code>，根据循环不变量节点 <code>0,1,...,size()</code> 都是最大堆的根节点，特别的，0 是堆的顶点。</li></ul><p>之前分析了 <code>sift_down(A, i)</code> 的运行时间与节点 <code>i</code> 所处高度有关，在建堆过程中，不同的节点所处高度可能不同，想准确计算建堆的时间复杂度利用了下面所示的树的特性。</p><ul><li>一棵含有 <code>n</code> 个元素的完全树，在高度 <code>h</code> 处，最多有 <span class="math inline">\(\lceil{n/2^{h+1}}\rceil\)</span> 个元素。根节点所处高度为 0。</li></ul><p>根据这条性质，运行时间可以刻画为</p><p><span class="math display">\[\begin{aligned}T(n)&amp;=\sum_{h=0}^{\lfloor\log_{2}n\rfloor}\lceil{n/2^{h+1}}\rceil*O(h)\\&amp;=O(n\sum_{h=0}^{\lfloor\log_{2}n\rfloor}\frac{h}{2^h})\end{aligned}\\\begin{aligned}\because&amp;\sum_{k=0}^{\infty}kx^k=\frac{x}{(1-x)^2}(|x|\le1)\\\therefore&amp;\sum_{h=0}^{\infty}\frac{h}{2^h}=\frac{1/2}{(1-\frac{1}{2})^2}=2\end{aligned}\]</span></p><p>将其带入可得</p><p><span class="math display">\[\begin{aligned}T(n)&amp;=O(n\sum_{h=0}^{\infty}\frac{h}{2^h})\\&amp;=O(n)\end{aligned}\]</span> 由此可得出结论，<code>heapify</code> 可以在线性时间内将一个数组转换成一个堆。</p><h2 id="其他方法">其他方法</h2><ul><li><code>sift_up</code>：与 <code>sift_down</code> 相反，当节点 <code>i</code> 的值大于其母节点的值，而其他节点均满足堆的性质时，通过此过程将节点i不断上移，直到满足堆的性质。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sift_up(A, i):</span><br><span class="line">    <span class="keyword">while</span> i&gt;<span class="number">1</span> <span class="keyword">and</span> A[parent(i)] &lt; A[i]:</span><br><span class="line">        exchange A[parent(i)] <span class="keyword">with</span> A[i]</span><br><span class="line">        i = parent(i)</span><br></pre></td></tr></table></figure><ul><li><code>increase_key</code>：当堆中某个节点的值变大时，可能大于其母节点，与上述情况相同。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">increase_key(A, i):</span><br><span class="line">    sift_up(A, i)</span><br></pre></td></tr></table></figure><ul><li><code>decrease_key</code>：与<code>sift_down</code>的情况相同。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">decrease_key(A, i):</span><br><span class="line">    sift_down(A, i)</span><br></pre></td></tr></table></figure><ul><li><code>replace</code>：更新后的值大于原来的值，调用 <code>increase_key</code>；小于原来的值，调用 <code>decrease_key</code>。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">replace(A, i, x):</span><br><span class="line">    <span class="keyword">if</span> A[i] &lt; x:</span><br><span class="line">        increase_key(A, i)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> A[i] &gt; x:</span><br><span class="line">        decrease_key(A, i)</span><br></pre></td></tr></table></figure><ul><li><code>append</code>：先添加一个值为无穷小的元素到堆的末尾，然后调用 <code>increase_key</code> 修改值。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">append(A, x):</span><br><span class="line">    A.heap_size = A.heap_size + <span class="number">1</span></span><br><span class="line">    A[A.heap_size - <span class="number">1</span>] = -inf</span><br><span class="line">    increase_key(A, A.heap_size - <span class="number">1</span>, x)</span><br></pre></td></tr></table></figure><hr><ul><li><code>peek</code>：第一个元素就是堆顶元素，直接返回即可。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">peek():</span><br><span class="line">    <span class="keyword">return</span> A[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><ul><li><code>pop</code>：将堆顶元素保存，然后用最后一个元素替换堆顶元素，删除最后一个元素。此时堆顶元素可能违背堆的性质，对其调用 <code>sift_down</code>。或者调用 <code>decrease_key</code> 将堆顶元素的值减小到最后一个元素值，两者调用的过程时一样的。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pop():</span><br><span class="line">    r = A[<span class="number">0</span>]</span><br><span class="line">    A[<span class="number">0</span>] = A[A.lenght - <span class="number">1</span>]</span><br><span class="line">    A.heap_size = A.heap_size - <span class="number">1</span></span><br><span class="line">    sift_down(A, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure><ul><li><code>delete</code>：与 <code>pop</code> 过程相同，<code>pop</code> 就是特殊的 <code>delete</code> 过程。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delete(A, i):</span><br><span class="line">    A[i] = A[A.lenght - <span class="number">1</span>]</span><br><span class="line">    A.heap_size = A.heap_size - <span class="number">1</span></span><br><span class="line">    sift_down(A, i)</span><br></pre></td></tr></table></figure><hr><ul><li><code>merge</code>：逐次调用 <code>append</code> 添加另一个堆中的元素。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">merge(A, o):</span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> o:</span><br><span class="line">        append(A, e)</span><br></pre></td></tr></table></figure><ul><li><code>meld</code>：取出两个堆中的元素，合并成新的列表，调用 <code>heapify</code> 创建堆。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">meld(A, B, C):</span><br><span class="line">    C = A + B</span><br><span class="line">    heapify(C)</span><br></pre></td></tr></table></figure><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parent</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="string">"""计算元素i的母节点位置"""</span></span><br><span class="line">    <span class="keyword">return</span> math.floor((i - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">left_child</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="string">"""计算元素i的左孩子节点位置"""</span></span><br><span class="line">    <span class="keyword">return</span> (i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">right_child</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="string">"""计算元素i的右孩子节点位置"""</span></span><br><span class="line">    <span class="keyword">return</span> (i &lt;&lt; <span class="number">1</span>) + <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(a, i, j)</span>:</span></span><br><span class="line">    <span class="string">"""交换元素i和j的值"""</span></span><br><span class="line">    a[i], a[j] = a[j], a[i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heap</span>:</span></span><br><span class="line">    <span class="string">"""最小堆"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回堆顶元素"""</span></span><br><span class="line">        <span class="keyword">return</span> self.value[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""删除并返回堆顶元素"""</span></span><br><span class="line">        <span class="keyword">if</span> self.size() &gt; <span class="number">1</span>:  <span class="comment"># 堆中元素多于2个时，pop()之后需要调整堆</span></span><br><span class="line">            m = self.value[<span class="number">0</span>]</span><br><span class="line">            self.value[<span class="number">0</span>] = self.value.pop(self.size() - <span class="number">1</span>)  <span class="comment"># 将堆尾元素移动到堆顶</span></span><br><span class="line">            self.sift_down(<span class="number">0</span>)  <span class="comment"># 调整堆</span></span><br><span class="line">            <span class="keyword">return</span> m</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 堆中元素少于2个时，直接调用list的pop()方法</span></span><br><span class="line">            <span class="keyword">return</span> self.value.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""添加元素"""</span></span><br><span class="line">        self.value.append(x)</span><br><span class="line">        self.decrease_key(self.size() - <span class="number">1</span>, x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replace</span><span class="params">(self, i, x)</span>:</span></span><br><span class="line">        <span class="string">"""替换元素的值，替换堆顶元素时指定i=0"""</span></span><br><span class="line">        <span class="keyword">if</span> self.value[i] &lt; x:</span><br><span class="line">            self.increase_key(i, x)</span><br><span class="line">        <span class="keyword">elif</span> self.value[i] &gt; x:</span><br><span class="line">            self.decrease_key(i, x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heapify</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""建堆"""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(parent(self.size() - <span class="number">1</span>), <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            self.sift_down(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="string">"""合并堆"""</span></span><br><span class="line">        self.value.extend(other)</span><br><span class="line">        self.heapify()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回堆的大小"""</span></span><br><span class="line">        <span class="keyword">return</span> len(self.value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""判断是否是空堆"""</span></span><br><span class="line">        <span class="keyword">return</span> self.size() == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increase_key</span><span class="params">(self, i, x)</span>:</span></span><br><span class="line">        <span class="string">"""增加元素的值"""</span></span><br><span class="line">        self.value[i] = x</span><br><span class="line">        self.sift_down(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decrease_key</span><span class="params">(self, i, x)</span>:</span></span><br><span class="line">        <span class="string">"""减小元素的值"""</span></span><br><span class="line">        self.value[i] = x</span><br><span class="line">        self.sift_up(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="string">"""删除元素"""</span></span><br><span class="line">        last = self.value.pop(self.size() - <span class="number">1</span>)  <span class="comment"># pop堆尾元素</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; self.size():  <span class="comment"># 防止删除堆中唯一元素时越界</span></span><br><span class="line">            self.decrease_key(i, last)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sift_up</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="string">"""上滤，将元素放到正确位置"""</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> self.value[parent(i)] &gt; self.value[i]:</span><br><span class="line">            exchange(self.value, parent(i), i)</span><br><span class="line">            i = parent(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sift_down</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="string">"""下滤，将元素放到正确位置"""</span></span><br><span class="line">        l, r = left_child(i), right_child(i)</span><br><span class="line">        <span class="keyword">if</span> l &lt; self.size() <span class="keyword">and</span> self.value[l] &lt; self.value[i]:</span><br><span class="line">            smallest = l</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            smallest = i</span><br><span class="line">        <span class="keyword">if</span> r &lt; self.size() <span class="keyword">and</span> self.value[r] &lt; self.value[smallest]:</span><br><span class="line">            smallest = r</span><br><span class="line">        <span class="keyword">if</span> smallest != i:</span><br><span class="line">            exchange(self.value, i, smallest)</span><br><span class="line">            self.sift_down(smallest)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span><span class="params">(Heap)</span>:</span></span><br><span class="line">    <span class="string">"""最大堆"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.append(x)</span><br><span class="line">        self.increase_key(self.size() - <span class="number">1</span>, x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increase_key</span><span class="params">(self, i, x)</span>:</span></span><br><span class="line">        self.value[i] = x</span><br><span class="line">        self.sift_up(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decrease_key</span><span class="params">(self, i, x)</span>:</span></span><br><span class="line">        self.value[i] = x</span><br><span class="line">        self.sift_down(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sift_down</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        l, r = left_child(i), right_child(i)</span><br><span class="line">        <span class="keyword">if</span> l &lt; self.size() <span class="keyword">and</span> self.value[l] &gt; self.value[i]:</span><br><span class="line">            largest = l</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            largest = i</span><br><span class="line">        <span class="keyword">if</span> r &lt; self.size() <span class="keyword">and</span> self.value[r] &gt; self.value[largest]:</span><br><span class="line">            largest = r</span><br><span class="line">        <span class="keyword">if</span> largest != i:</span><br><span class="line">            exchange(self.value, i, largest)</span><br><span class="line">            self.sift_down(largest)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sift_up</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> self.value[self.value.parent(i)] &lt; self.value[i]:</span><br><span class="line">            exchange(self.value, parent(i), i)</span><br><span class="line">            i = parent(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    min_heap = Heap([<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">7</span>])</span><br><span class="line">    min_heap.heapify()</span><br><span class="line">    print(<span class="string">'min heap'</span>, min_heap.value)</span><br><span class="line"></span><br><span class="line">    max_heap = MaxHeap([<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">7</span>])</span><br><span class="line">    max_heap.heapify()</span><br><span class="line">    print(<span class="string">'max heap'</span>, max_heap.value)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">min heap [1, 2, 3, 4, 7, 9, 10, 14, 8, 16]</span><br><span class="line">max heap [16, 14, 10, 8, 7, 9, 3, 2, 4, 1]</span><br></pre></td></tr></table></figure><h1 id="应用">应用</h1><ul><li>堆排序</li><li>优先队列</li></ul><h1 id="堆排序">堆排序</h1><p>堆排序（Heapsort）是一种比较排序算法。堆排序在 1964 年首次被<a href="https://en.wikipedia.org/wiki/J._W._J._Williams" target="_blank" rel="noopener">J. W. J. Williams</a>提出，同时也是堆这种数据结构首次出现。堆排序是一种原址（In-place）、非稳定（NOT stable）排序算法。</p><p>堆排序可以看作是选择排序的优化版本。堆排序与选择排序类似，将数组分成两个部分，未排序部分和已排序部分。算法每次从未排序部分提取最大值放入已排序部分，当未排序部分为空时，排序结束。</p><p>选择排序通过一次数组遍历（时间复杂度 <span class="math inline">\(\Theta(n)\)</span> 获取最大值。而堆排序通过堆这种数据结构快速获取最大值。获取的时间复杂度是 <span class="math inline">\(\Theta(1)\)</span>，但获取之后要花费 <span class="math inline">\(\Theta(\lg{n})\)</span> 时间调整堆，因此总运行时间为 <span class="math inline">\(\Theta(1)+\Theta(\lg{n})=\Theta(\lg{n})\)</span>。由此可以看出堆排序相比于选择排序改进的点。</p><p>下面是一幅关于堆排序的示意图（出自<a href="https://en.wikipedia.org/wiki/Heapsort" title="Heapsort" target="_blank" rel="noopener">维基百科</a>）。</p><p><img src="/uploads/image/introduction-to-algorithms/sorting-heapsort-anim.gif"></p><h2 id="实现-1">实现</h2><p>有了堆和堆支持的一些基础操作后，可定义堆排序的过程如下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">heapsort(A):</span><br><span class="line">    heapify(A)                         <span class="comment"># Build a max heap with array A</span></span><br><span class="line">    <span class="keyword">for</span> i=A.length<span class="number">-1</span> downto <span class="number">1</span>:</span><br><span class="line">        exchange A[<span class="number">0</span>] <span class="keyword">with</span> A[i]</span><br><span class="line">        A.heap_size = A.heap_size - <span class="number">1</span></span><br><span class="line">        sift_down(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>在关于堆的介绍中，所有在 <code>heap.data</code> 中的数都被认为是堆中的元素，但是堆排序算法为了节省空间被设计成原址算法，<code>heap.data</code> 中需要同时存储堆（未排序部分）和非堆（已排序部分），因此需要做点小修改，保证 <code>size()</code> 函数返回堆的边界，当超出边界时，即使存在对应数据也不被认为是堆中元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">size():</span><br><span class="line">    <span class="keyword">return</span> heap_size</span><br></pre></td></tr></table></figure><p>堆排序的运行时间分为两部分，建堆的时间 <span class="math inline">\(O(n)\)</span> 和 <code>n-1</code> 次调整堆的时间 <span class="math inline">\(O(\lg{n})\)</span>。所以总的运行时间是</p><p><span class="math inline">\(T(n)=O(n)+(n-1)O(\lg{n})=O(n\lg{n})\)</span>。</p><h2 id="代码-1">代码</h2><p>继承并重写了堆的代码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> data_structure.heap <span class="keyword">import</span> MaxHeap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span><span class="params">(MaxHeap)</span>:</span></span><br><span class="line">    <span class="string">"""基于最大堆的堆排序实现，它是原址排序"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, a)</span>:</span></span><br><span class="line">        MaxHeap.__init__(self, a)</span><br><span class="line">        self.heap_size = len(a)  <span class="comment"># 增加heap_size变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""重写方法"""</span></span><br><span class="line">        <span class="keyword">return</span> self.heap_size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""排序过程主体"""</span></span><br><span class="line">        self.heapify()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.size() - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            self.value[<span class="number">0</span>], self.value[i] = self.value[i], self.value[<span class="number">0</span>]</span><br><span class="line">            self.heap_size -= <span class="number">1</span></span><br><span class="line">            self.sift_down(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [16, 14, 8, 10, 4, 7, 9, 3, 2, 1]</span><br><span class="line">Output: [1, 2, 3, 4, 7, 8, 9, 10, 14, 16]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort </tag>
            
            <tag> Introduction to Algorithms </tag>
            
            <tag> data structures </tag>
            
            <tag> binary tree </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
