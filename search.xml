<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>特殊方法一览</title>
      <link href="/notes/fluent-python/overview-of-special-methods/"/>
      <url>/notes/fluent-python/overview-of-special-methods/</url>
      
        <content type="html"><![CDATA[<p>Python 语言参考手册中的<a href="https://docs.python.org/3/reference/datamodel.html" target="_blank" rel="noopener">“Data Model”</a>一章列出了 83 个特殊方法的名字，其中 47 个用于实现算术运算、位运算和比较操作。</p><h1 id="跟运算无关的特殊方法">跟运算无关的特殊方法</h1><table><thead><tr class="header"><th>类别</th><th>方法名</th></tr></thead><tbody><tr class="odd"><td>字符串 / 字节序列表示形式</td><td><code>__repr__</code>、<code>__str__</code>、<code>__format__</code>、<code>__bytes__</code></td></tr><tr class="even"><td>数值转换</td><td><code>__abs__</code>、<code>__bool__</code>、<code>__complex__</code>、<code>__int__</code>、<code>__float__</code>、<code>__hash__</code>、<code>__index__</code></td></tr><tr class="odd"><td>集合模拟</td><td><code>__len__</code>、<code>__getitem__</code>、<code>__setitem__</code>、<code>__delitem__</code>、<code>__contains__</code></td></tr><tr class="even"><td>迭代枚举</td><td><code>__iter__</code>、<code>__reversed__</code>、<code>__next__</code></td></tr><tr class="odd"><td>可调用模拟</td><td><code>__call__</code></td></tr><tr class="even"><td>上下文管理</td><td><code>__enter__</code>、<code>__exit__</code></td></tr><tr class="odd"><td>实例创建和销毁</td><td><code>__new__</code>、<code>__init__</code>、<code>__del__</code></td></tr><tr class="even"><td>属性管理</td><td><code>__getattr__</code>、<code>__getattribute__</code>、<code>__setattr__</code>、<code>__delattr__</code>、<code>__dir__</code></td></tr><tr class="odd"><td>属性描述符</td><td><code>__get__</code>、<code>__set__</code>、<code>__delete__</code></td></tr><tr class="even"><td>跟类相关的服务</td><td><code>__prepare__</code>、<code>__instancecheck__</code>、<code>__subclasscheck__</code></td></tr></tbody></table><a id="more"></a><h1 id="跟运算符相关的特殊方法">跟运算符相关的特殊方法</h1><table><colgroup><col style="width: 23%"><col style="width: 76%"></colgroup><thead><tr class="header"><th>类别</th><th>方法名和对应的运算符</th></tr></thead><tbody><tr class="odd"><td>一元运算符</td><td><code>__neg__ -</code>、<code>__pos__ +</code>、<code>__abs__ abs()</code></td></tr><tr class="even"><td>比较运算符</td><td><code>__lt__ &lt;</code>、<code>__le__ &lt;=</code>、<code>__eq__ ==</code>、<code>__ne__ !=</code>、<code>__gt__ &gt;</code>、<code>__ge__ &gt;=</code></td></tr><tr class="odd"><td>算术运算符</td><td><code>__add__ +</code>、<code>__sub__ -</code>、<code>__mul__ *</code>、<code>__truediv__ /</code>、<code>__floordiv__ //</code>、<code>__mod__ %</code>、<code>__divmod__ divmod()</code>、<code>__pow__ **</code>或<code>pow()</code>、<code>__round__ round()</code></td></tr><tr class="even"><td>反向算术运算符</td><td><code>__radd__</code>、<code>__rsub__</code>、<code>__rmul__</code>、<code>__rtruediv__</code>、 <code>__rfloordiv__</code>、<code>__rmod__</code>、<code>__rdivmod__</code>、<code>__rpow__</code></td></tr><tr class="odd"><td>增量赋值算术运算符</td><td><code>__iadd__</code>、<code>__isub__</code>、<code>__imul__</code>、<code>__itruediv__</code>、 <code>__ifloordiv__</code>、<code>__imod__</code>、<code>__ipow__</code></td></tr><tr class="even"><td>位运算符</td><td><code>__invert__ ~</code>、<code>__lshift__ &lt;&lt;</code>、<code>__rshift__ &gt;&gt;</code>、<code>__and__ &amp;</code>、<code>__or__ |</code>、<code>__xor__ ^</code></td></tr><tr class="odd"><td>反向位运算符</td><td><code>__rlshift__</code>、<code>__rrshift__</code>、<code>__rand__</code>、<code>__rxor__</code>、<code>__ror__</code></td></tr><tr class="even"><td>增量赋值位运算符</td><td><code>__ilshift__</code>、<code>__irshift__</code>、<code>__iand__</code>、<code>__ixor__</code>、<code>__ior__</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> special methods </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用魔术方法</title>
      <link href="/notes/fluent-python/how-special-methods-are-used/"/>
      <url>/notes/fluent-python/how-special-methods-are-used/</url>
      
        <content type="html"><![CDATA[<h1 id="如何使用特殊方法">如何使用特殊方法</h1><p>首先明确一点，特殊方法的存在是为了被 Python 解释器调用的，你自己并不需要调用它们。也就是说没有 <code>my_object.__len__()</code> 这种写法，而应该使用 <code>len(my_object)</code>。在执行 <code>len(my_object)</code> 的时候，如果 <code>my_object</code> 是一个自定义类的对象，那么 Python 会自己去调用其中由你实现的 <code>__len__</code> 方法。</p><p>然而如果是 Python 内置的类型，比如列表(<code>list</code>)、字符串(<code>str</code>)、字节序列 (<code>bytearray</code>)等，那么 CPython 会抄个近路，<code>__len__</code> 实际上会直接返回 <code>PyVarObject</code> 里的 <code>ob_size</code> 属性。<code>PyVarObject</code> 是表示内存中长度可变的内置对象的 C 语言结构体。直接读取这个值比调用一个方法要快很多。</p><p>很多时候，特殊方法的调用是隐式的，比如 <code>for i in x:</code> 这个语句，背后其实用的是 <code>iter(x)</code>，而这个函数的背后则是 <code>x.__iter__()</code> 方法。当然<strong>前提</strong>是这个方法在 <code>x</code> 中被实现了。</p><p>通常你的代码无需直接使用特殊方法。除非有大量的元编程存在，直接调用特殊方法的频率应该远远低于你去实现它们的次数。唯一的例外可能是 <code>__init__</code> 方法，你的代码里可能经常会用到它，目的是在你自己的子类的 <code>__init__</code> 方法中调用超类的构造器。</p><p>通过内置的函数(例如 <code>len</code>、<code>iter</code>、<code>str</code>，等等)来使用特殊方法是最好的选择。这些内置函数不仅会调用特殊方法，通常还提供额外的好处，而且对于内置的类来说，它们的速度更快。</p><p>不要自己想当然地随意添加特殊方法，比如 <code>__foo__</code> 之类的，因为虽然现在这个名字没有被 Python 内部使用，以后就不一定了。</p><a id="more"></a><h1 id="二维向量api">二维向量API</h1><p><img title="一个二维向量加法的例子" data-src="/uploads/posts/example-of-2d-vector-addition.png"></p><p>一个二维向量加法的例子，<code>Vector(2, 4) + Vector(2, 1) = Vector(4, 5)</code></p><p>向量加法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v2 = Vector(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + v2</span><br><span class="line">Vector(<span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>向量的模：<code>abs</code> 是一个内置函数，如果输入是整数或者浮点数，它返回的是输入值的绝对值；如果输入是复数(complex number)，那么返回这个复数的模。为了保持一致性，我们的 API 在碰到 <code>abs</code> 函数的时候，也应该返回该向量的模。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v = Vector(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>abs(v)</span><br><span class="line"><span class="number">5.0</span></span><br></pre></td></tr></table></figure><p>标量乘法（即向量与数的乘法，得到的结果向量的方向与原向量一致，模变大）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v * <span class="number">3</span></span><br><span class="line">Vector(<span class="number">9</span>, <span class="number">12</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>abs(v * <span class="number">3</span>)</span><br><span class="line"><span class="number">15.0</span></span><br></pre></td></tr></table></figure><h1 id="实现">实现</h1><figure class="highlight python"><figcaption><span>vector.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> hypot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x=<span class="number">0</span>, y=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Vector(%r, %r)'</span> % (self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> hypot(self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(self.x <span class="keyword">or</span> self.y)  <span class="comment"># 更高效</span></span><br><span class="line">        <span class="comment"># return bool(abs(self))</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        x = self.x + other.x</span><br><span class="line">        y = self.y + other.y</span><br><span class="line">        <span class="keyword">return</span> Vector(x, y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, scalar)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Vector(self.x * scalar, self.y * scalar)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.x == other.x <span class="keyword">and</span> self.y == other.y</span><br></pre></td></tr></table></figure><h1 id="自定义的布尔值">自定义的布尔值</h1><p>尽管 Python 里有 <code>bool</code> 类型，但实际上任何对象都可以用于需要布尔值的上下文中（比如 <code>if</code> 或 <code>while</code> 语句，或者 <code>and</code>、<code>or</code> 和 <code>not</code> 运算符）。为了判定一个值 <code>x</code> 为真还是为假， Python 会调用 <code>bool(x)</code>，这个函数只能返回 <code>True</code> 或者 <code>False</code>。</p><p>默认情况下，我们自己定义的类的实例总被认为是真的，除非这个类对 <code>__bool__</code> 或者 <code>__len__</code> 函数有自己的实现。<code>bool(x)</code> 的背后是调用 <code>x.__bool__()</code> 的结果；如果不存在 <code>__bool__</code> 方法，那么 <code>bool(x)</code> 会尝试调用 <code>x.__len__()</code>。若返回 0，则 <code>bool</code> 会返回 <code>False</code>；否则返回 <code>True</code>。</p><h1 id="总结">总结</h1><table><thead><tr class="header"><th>操作</th><th>底层支持</th></tr></thead><tbody><tr class="odd"><td>取绝对值或取模<code>abs</code></td><td><code>__abs__</code></td></tr><tr class="even"><td>布尔运算<code>bool</code></td><td><code>__bool__</code>（优先调用），<code>__len__</code>（不存在<code>__bool__</code>时调用）</td></tr><tr class="odd"><td>加法<code>+</code></td><td><code>__add__</code></td></tr><tr class="even"><td>乘法<code>*</code></td><td><code>__mul__</code></td></tr></tbody></table><h1 id="单元测试">单元测试</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> hypot</span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VectorTestCase</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_add</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertEqual(Vector(<span class="number">2</span>, <span class="number">4</span>) + Vector(<span class="number">2</span>, <span class="number">1</span>), Vector(<span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_abs</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertEqual(abs(Vector(<span class="number">3</span>, <span class="number">4</span>)), <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_mul</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertEqual(Vector(<span class="number">3</span>, <span class="number">4</span>) * <span class="number">3</span>, Vector(<span class="number">9</span>, <span class="number">12</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_bool</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertTrue(Vector(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        self.assertFalse(Vector(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> special methods </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一摞Python风格的纸牌</title>
      <link href="/notes/fluent-python/a-pythonic-card-deck/"/>
      <url>/notes/fluent-python/a-pythonic-card-deck/</url>
      
        <content type="html"><![CDATA[<h1 id="魔术方法">魔术方法</h1><p>不管在哪种框架下写程序，都会花费大量时间去实现那些会被框架本身调用的方法， Python 也不例外。Python 解释器碰到特殊的句法时，会使用特殊方法去激活一些基本的对 象操作，这些特殊方法的名字以两个下划线开头，以两个下划线结尾(例如 <code>__getitem__</code>)。比如 <code>obj[key]</code> 的背后就是 <code>__getitem__</code> 方法，为了能求得 <code>my_collection[key]</code> 的值，解释器实际上会调用 <code>my_collection.__getitem__(key)</code>。</p><p>这些特殊方法名能让你自己的对象实现和支持以下的语言架构，并与之交互：</p><ul><li>迭代</li><li>集合类</li><li>属性访问</li><li>运算符重载</li><li>函数和方法的调用</li><li>对象的创建和销毁</li><li>字符串表示形式和格式化</li><li>管理上下文（即<code>with</code>块）</li></ul><a id="more"></a><h1 id="纸牌">纸牌</h1><figure class="highlight python"><figcaption><span>french_deck.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">Card = collections.namedtuple(<span class="string">'Card'</span>, [<span class="string">'rank'</span>, <span class="string">'suit'</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrenchDeck</span>:</span></span><br><span class="line">    ranks = [str(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">11</span>)] + list(<span class="string">'JQKA'</span>)</span><br><span class="line">    suits = <span class="string">'spades diamonds clubs hearts'</span>.split()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'__init__'</span>)</span><br><span class="line">        self._cards = [Card(rank, suit) <span class="keyword">for</span> suit <span class="keyword">in</span> self.suits</span><br><span class="line">                       <span class="keyword">for</span> rank <span class="keyword">in</span> self.ranks]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'__len__'</span>)</span><br><span class="line">        <span class="keyword">return</span> len(self._cards)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        print(<span class="string">'__getitem__'</span>)</span><br><span class="line">        <span class="keyword">return</span> self._cards[item]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        print(<span class="string">'__setitem__'</span>)</span><br><span class="line">        self._cards[key] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'__iter__'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">suit_values = dict(spades=<span class="number">3</span>, hearts=<span class="number">2</span>, diamonds=<span class="number">1</span>, clubs=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spades_high</span><span class="params">(card)</span>:</span></span><br><span class="line">    <span class="comment"># 按照常规，用点数来判定扑克牌的大小，2 最小、A 最大；</span></span><br><span class="line">    <span class="comment"># 同时还要加上对花色的判定，黑桃最大、红桃次之、方块再次、梅花最小。</span></span><br><span class="line">    rank_value = FrenchDeck.ranks.index(card.rank)</span><br><span class="line">    <span class="keyword">return</span> rank_value * len(suit_values) + suit_values[card.suit]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> french_deck <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> random <span class="keyword">import</span> choice, randrange</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck = FrenchDeck()  <span class="comment"># 初始化</span></span><br><span class="line">__init__</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(deck)  <span class="comment"># len</span></span><br><span class="line">__len__</span><br><span class="line"><span class="number">52</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[<span class="number">0</span>]  <span class="comment"># 下标访问</span></span><br><span class="line">__getitem__</span><br><span class="line">Card(rank=<span class="string">'2'</span>, suit=<span class="string">'spades'</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>choice(deck)  <span class="comment"># 随机抽取</span></span><br><span class="line">__len__</span><br><span class="line">__getitem__</span><br><span class="line">Card(rank=<span class="string">'K'</span>, suit=<span class="string">'diamonds'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[randrange(<span class="number">0</span>, len(deck))]</span><br><span class="line">__len__</span><br><span class="line">__getitem__</span><br><span class="line">Card(rank=<span class="string">'8'</span>, suit=<span class="string">'clubs'</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> card <span class="keyword">in</span> deck:  <span class="comment"># 迭代</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line">__getitem__</span><br><span class="line"><span class="meta">... </span>(中间全都是__getitem__)</span><br><span class="line">__getitem__</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[<span class="number">-2</span>:]  <span class="comment"># 切片</span></span><br><span class="line">__getitem__</span><br><span class="line">[Card(rank=<span class="string">'K'</span>, suit=<span class="string">'hearts'</span>), Card(rank=<span class="string">'A'</span>, suit=<span class="string">'hearts'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[<span class="number">12</span>::<span class="number">13</span>]  <span class="comment"># 从第12张牌开始，每隔13张取一张牌</span></span><br><span class="line">__getitem__</span><br><span class="line">[Card(rank=<span class="string">'A'</span>, suit=<span class="string">'spades'</span>), Card(rank=<span class="string">'A'</span>, suit=<span class="string">'diamonds'</span>), Card(rank=<span class="string">'A'</span>, suit=<span class="string">'clubs'</span>), Card(rank=<span class="string">'A'</span>, suit=<span class="string">'hearts'</span>)]</span><br></pre></td></tr></table></figure><p>迭代通常是隐式的，譬如说一个集合类型没有实现 <code>__contains__</code> 方法，那么 <code>in</code> 运算符就会按顺序做一次迭代搜索。于是，<code>in</code> 运算符可以用在我们的 <code>FrenchDeck</code> 类上，因为 它是可迭代的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[<span class="number">2</span>]</span><br><span class="line">__getitem__</span><br><span class="line">Card(rank=<span class="string">'4'</span>, suit=<span class="string">'spades'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Card(<span class="string">'4'</span>, <span class="string">'spades'</span>) <span class="keyword">in</span> deck  <span class="comment"># in</span></span><br><span class="line">__getitem__</span><br><span class="line">__getitem__</span><br><span class="line">__getitem__</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> card <span class="keyword">in</span> sorted(deck, key=spades_high):  <span class="comment"># sorted</span></span><br><span class="line"><span class="meta">... </span>    print(card)</span><br><span class="line">...</span><br><span class="line">__len__</span><br><span class="line">__getitem__</span><br><span class="line">...</span><br><span class="line">__getitem__</span><br><span class="line">Card(rank=<span class="string">'2'</span>, suit=<span class="string">'clubs'</span>)</span><br><span class="line">Card(rank=<span class="string">'2'</span>, suit=<span class="string">'diamonds'</span>)</span><br><span class="line">...</span><br><span class="line">Card(rank=<span class="string">'A'</span>, suit=<span class="string">'hearts'</span>)</span><br><span class="line">Card(rank=<span class="string">'A'</span>, suit=<span class="string">'spades'</span>)</span><br></pre></td></tr></table></figure><p>虽然 <code>FrenchDeck</code> 隐式地继承了 <code>object</code> 类，但功能却不是继承而来的。我们通过数据模型和一些合成来实现这些功能。通过实现 <code>__len__</code> 和 <code>__getitem__</code> 这两个特殊方 法，<code>FrenchDeck</code> 就跟一个 Python 自有的序列数据类型一样，可以体现出 Python 的核心 语言特性（例如迭代和切片）。同时这个类还可以用于标准库中诸如 <code>random.choice</code>、<code>reversed</code> 和 <code>sorted</code> 这些函数。另外，对合成的运用使得 <code>__len__</code> 和 <code>__getitem__</code> 的具体实现可以代理给 <code>self._cards</code> 这个 Python 列表（即 <code>list</code> 对象）。</p><h1 id="总结">总结</h1><table><thead><tr class="header"><th>操作</th><th>底层支持</th></tr></thead><tbody><tr class="odd"><td>初始化</td><td><code>__init__</code></td></tr><tr class="even"><td>获取长度<code>len(obj)</code></td><td><code>__len__</code></td></tr><tr class="odd"><td>下标访问<code>obj[key]</code></td><td><code>__getitem__</code></td></tr><tr class="even"><td>随机抽取<code>choice(obj)</code></td><td><code>__len__</code>, <code>__getitem__</code></td></tr><tr class="odd"><td>查询<code>item in obj</code></td><td><code>__getitem__</code>（没有实现<code>__contains__</code>方法时，<code>in</code>运算符会做一次顺序搜索）</td></tr><tr class="even"><td>迭代</td><td><code>__getitem__</code>（调用次数与迭代次数有关，神奇的是不需要调用<code>__len__</code>）</td></tr><tr class="odd"><td>切片</td><td><code>__getitem__</code>（只调用一次，同样不需要调用<code>__len__</code>）</td></tr><tr class="even"><td>排序<code>sorted(obj)</code></td><td><code>__len__</code>（一次）, <code>__getitem__</code>（调用次数与迭代次数有关）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> special methods </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jupyter Notebook ModuleNotFoundError</title>
      <link href="/programming/jupyter-notebook-ModuleNotFoundError/"/>
      <url>/programming/jupyter-notebook-ModuleNotFoundError/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_34650787/article/details/83304080" target="_blank" rel="noopener">点击查看原文</a></p><p>可能原因：安装了多个Python版本，终端和Jupyter Notebook使用的不是同一个Python。</p><p>在Terminal和Jupyter Notebook中分别执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.executable</span><br></pre></td></tr></table></figure><p>比较各自的输出路径。若不相同，例如</p><p>Terminal：<code>'/Users/cws/opt/anaconda3/bin/python'</code></p><p>Notebook：<code>/usr/local/bin/python3.6</code></p><p>则可按照下述操作解决此问题。</p><a id="more"></a><p>在Terminal中输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(base) MacBook-Pro:~ cws$ jupyter kernelspec list</span><br><span class="line">Available kernels:  <span class="comment"># 列出所有内核</span></span><br><span class="line">  python36    /Users/cws/Library/Jupyter/kernels/python36</span><br><span class="line">  python3     /Library/Frameworks/Python.framework/Versions/<span class="number">3.6</span>/share/jupyter/kernels/python3</span><br></pre></td></tr></table></figure><p>根据自己正在使用的内核，例如python3，进入对应目录<code>/Library/.../python3</code>，修改配置文件kernel.json</p><figure class="highlight diff"><figcaption><span>kernel.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> "argv": [</span><br><span class="line"><span class="deletion">- "python",</span></span><br><span class="line"><span class="addition">+ "/Users/cws/opt/anaconda3/bin/python",</span></span><br><span class="line">  "-m",</span><br><span class="line">  "ipykernel_launcher",</span><br><span class="line">  "-f",</span><br><span class="line">  "&#123;connection_file&#125;"</span><br><span class="line"> ],</span><br><span class="line"> "display_name": "Python 3",</span><br><span class="line"> "language": "python"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后保存，重启Notebook。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> jupyter notebook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树</title>
      <link href="/notes/introduction-to-algorithms/red-black-trees/"/>
      <url>/notes/introduction-to-algorithms/red-black-trees/</url>
      
        <content type="html"><![CDATA[<h1 id="红黑树">红黑树</h1><p>红黑树（red-black tree）是一棵二叉搜索树，是许多平衡搜索树的一种。它在每个节点上增加了一个存储位来表示结点的颜色，可以是<code>RED</code>或<code>BLACK</code>。通过对任何一条从根到叶子的简单路径上各个结点的颜色进行约束，<strong>红黑树确保没有一条路径会比其他路径长出2倍</strong>，因而是近似于平衡的。</p><h1 id="性质">性质</h1><p>树中每个结点包含5个属性：<code>color</code>、<code>key</code>、<code>left</code>、<code>right</code>和<code>p</code>。</p><p>一棵红黑树是满足下面<strong>红黑性质</strong>的二叉搜索树：</p><ol type="1"><li>每个结点或是红色的，或是黑色的。</li><li>根节点是黑色的。</li><li>每个叶子结点（<code>NIL</code>）是黑色的。</li><li>如果一个结点是红色的，则它的两个子节点都是黑色的。</li><li>对每个结点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色结点。</li></ol><p>为了便于处理红黑树中的边界条件，使用一个哨兵来代替<code>NIL</code>。哨兵的<code>color=BLACK</code>，其他属性的<code>p</code>、<code>left</code>、<code>right</code>、<code>key</code>的取值不重要。尽管可以为树中每一个<code>NIL</code>（叶子结点）新增一个不同的哨兵结点，但会浪费空间。取而代之的是，使用一个哨兵<code>T.nil​</code>来代表所有的NIL。如图(b)可以用更少的空间等价地表示图(a)。其中黑色结点用黑色、红色节点用灰色表示。</p><p><strong>黑高</strong>（black-height）：从某个结点<code>x</code>出发（不含该结点）到达一个叶节点的任意一条简单路径上的黑色结点个数（根据性质5可知结点的黑高是唯一的）称为该结点的黑高，记为<code>bh(x)​</code>。定义红黑树的黑高为其根节点的黑高。如图(a)所示的红黑树中，红黑树的黑高为3。图(c)省略了哨兵，多数时候采用这种更简洁的画法。</p><a id="more"></a><p><img data-src="/uploads/posts/red-black-tree.png"></p><blockquote><p>引理13.1</p><p>一棵有<span class="math inline">\(n\)</span>个内部结点的红黑树的高度至多为<span class="math inline">\(2\lg(n+1)\)</span>。</p></blockquote><p><strong>证明</strong>： 先证明以任一结点<span class="math inline">\(x\)</span>为根的子树中至少包含<span class="math inline">\(2^{bh(x)}-1\)</span>个内部结点。使用归纳法证明。</p><ol type="1"><li><p>如果<span class="math inline">\(x\)</span>的高度为0，则<span class="math inline">\(x\)</span>为叶节点（<span class="math inline">\(T.nil\)</span>)，且以<span class="math inline">\(x\)</span>为根节点的子树至少包含<span class="math inline">\(2^{bh(x)}-1=2^0-1=0\)</span>个内部结点。</p></li><li><p>如果<span class="math inline">\(x\)</span>的高度为<span class="math inline">\(h(h&gt;0)\)</span>，假设以<span class="math inline">\(x\)</span>为根节点的子树至少包含<span class="math inline">\(2^{bh(x)}-1\)</span>个内部结点成立。</p></li><li><p>考虑高度<span class="math inline">\(h+1\)</span>且有两个子节点的内部节点<span class="math inline">\(x&#39;\)</span>。子节点的高度为<span class="math inline">\(h\)</span>，黑高为</p><ul><li><span class="math inline">\(bh(x&#39;)\)</span>（当子节点为红色时），</li><li>或<span class="math inline">\(bh(x&#39;)-1\)</span>（当子节点为黑色时）。</li></ul><p>根据归纳假设，以子节点为根节点的子树至少包含<span class="math inline">\(2^{bh(x)-1}-1\)</span>个结点。于是，以<span class="math inline">\(x&#39;\)</span>为根的子树至少包含<span class="math inline">\((2^{bh(x)-1}-1)+(2^{bh(x)-1}-1)+1=2^{bh(x)}-1\)</span>个内部结点。</p></li></ol><p>之后，证明引理：设<span class="math inline">\(h\)</span>为树的高度。根据性质4，从根到叶节点的任何一条简单路径上都至少有一半的结点为黑色。因此，根的黑高至少为<span class="math inline">\(h/2\)</span>，于是有<span class="math inline">\(n\ge2^{h/2}-1\)</span>，将1移到左边，再对两边取对数，得到<span class="math inline">\(h\le2\lg(n+1)\)</span>。</p><h1 id="旋转">旋转</h1><p>搜索树操作<code>TREE-INSERT</code>和<code>TREE-DELETE</code>在含<span class="math inline">\(n\)</span>个关键字的红黑树上，运行花费时间为<span class="math inline">\(O(\lg{n})\)</span>。由于这两个操作对树做了修改，结果可能违反红黑性质。为了维护这些性质，必须要改变树中某些结点的颜色以及指针结构。</p><p>指针结构的修改是通过<strong>旋转</strong>（rotation）来完成的，这是一种能保持二叉搜索树性质的局部操作。<strong>在旋转操作中只有指针改变</strong>，其他所有属性都保持不变。下图给出了两种旋转：左旋和右旋。</p><ul><li>左旋：结点<span class="math inline">\(x\)</span>取代<span class="math inline">\(\beta\)</span>成为<span class="math inline">\(y\)</span>的左孩子结点，<span class="math inline">\(\beta\)</span>取代<span class="math inline">\(y\)</span>成为<span class="math inline">\(x\)</span>的右孩子结点。</li><li>右旋：结点<span class="math inline">\(y\)</span>取代<span class="math inline">\(\beta\)</span>成为<span class="math inline">\(x\)</span>的左孩子结点，<span class="math inline">\(\beta\)</span>取代<span class="math inline">\(x\)</span>成为<span class="math inline">\(y\)</span>的左孩子结点。</li></ul><p><img data-src="/uploads/posts/red-black-tree-rotation.png"></p><p>容易观察到，旋转前与旋转后各元素的大小顺序没有改变，都是<span class="math inline">\(\alpha\le{x}\le\beta\le{y}\le\gamma\)</span>。</p><p>在<code>LEFT-ROTATE</code>的伪代码中，假设<span class="math inline">\(x.right\ne{T.nil}\)</span>且根节点的父节点为<span class="math inline">\(T.nil\)</span>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LEFT-ROTATE(T, x):</span><br><span class="line">y = x.right              <span class="comment"># y的位置（结合上图理解）</span></span><br><span class="line">x.right = y.left         <span class="comment"># beta取代y成为x的右孩子</span></span><br><span class="line"><span class="keyword">if</span> y.left != T.nil:      <span class="comment"># 此时y.left还是beta结点</span></span><br><span class="line">    y.left.p = x         <span class="comment"># 修改beta的父节点为x</span></span><br><span class="line">y.p = x.p                <span class="comment"># 修改y的父节点</span></span><br><span class="line"><span class="keyword">if</span> x.p == T.nil:         <span class="comment"># 若x原本是根节点，y将变为树的根</span></span><br><span class="line">    T.root = y</span><br><span class="line"><span class="keyword">elif</span> x == x.p.left:      <span class="comment"># 若原本x是左孩子，y取代x后依旧是左孩子</span></span><br><span class="line">    x.p.left = y</span><br><span class="line"><span class="keyword">else</span>:                    <span class="comment"># 若原本x是右孩子，y取代x后依旧是右孩子</span></span><br><span class="line">    x.p.right = y</span><br><span class="line">y.left = x               <span class="comment"># x变为y的左孩子</span></span><br><span class="line">x.p = y                  <span class="comment"># 修改x的父节点为y</span></span><br></pre></td></tr></table></figure><p><code>RIGHT-ROTATE</code>操作的代码是对称的。它们都在<span class="math inline">\(O(1)\)</span>时间内运行完成。</p><p><img data-src="/uploads/posts/red-black-tree-left-rotate.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RIGHT-ROTATE(T, x):</span><br><span class="line">y = x.p</span><br><span class="line">y.left = x.right</span><br><span class="line"><span class="keyword">if</span> x.right != T.nil:</span><br><span class="line">    x.right.p = y</span><br><span class="line">x.p = y.p</span><br><span class="line"><span class="keyword">if</span> y.p == T.nil:</span><br><span class="line">    T.root = x</span><br><span class="line"><span class="keyword">elif</span> y == y.p.left:</span><br><span class="line">    y.p.left = x</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    y.p.right = x</span><br><span class="line">x.right = y</span><br><span class="line">y.p = x</span><br></pre></td></tr></table></figure><h1 id="插入">插入</h1><p>利用二叉搜索树的<a href="/data-structure/binary-search-tree/#插入">插入</a>过程，略作修改来将结点<span class="math inline">\(z\)</span>插入树<span class="math inline">\(T\)</span>内，就好像<span class="math inline">\(T\)</span>是一棵普通的二叉搜索树一样，然后将<span class="math inline">\(z\)</span>着为红色。为了保证红黑性质能继续保持，调用一个辅助程序<code>RB-INSERT-FIXUP</code>来对结点重新着色并旋转。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">RB-INSERT(T, z):</span><br><span class="line">y = T.nil             <span class="comment"># 与普通的二叉搜索树不同，此处y指向哨兵</span></span><br><span class="line">x = T.root            <span class="comment"># 寻找z的插入位置</span></span><br><span class="line"><span class="keyword">while</span> x != T.nil:</span><br><span class="line">    y = x</span><br><span class="line">    <span class="keyword">if</span> z.key &lt; x.key:</span><br><span class="line">        x = x.left</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x = x.right</span><br><span class="line">z.p = y               <span class="comment"># 插入结点z</span></span><br><span class="line"><span class="keyword">if</span> y == T.nil:</span><br><span class="line">    T.root = z</span><br><span class="line"><span class="keyword">elif</span> z.key &lt; y.key:</span><br><span class="line">    y.left = z</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    y.right = z</span><br><span class="line">z.left = T.nil        <span class="comment"># 设置新节点的左右孩子为哨兵结点，以保持合理的树结构</span></span><br><span class="line">z.right = T.nil</span><br><span class="line">z.color = RED         <span class="comment"># 新插入节点着红色</span></span><br><span class="line">RB-INSERT-FIXUP(T, z) <span class="comment"># 辅助程序，对结点重新着色并旋转以维护红黑性质</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RB-INSERT-FIXUP(T, z):</span><br><span class="line"><span class="keyword">while</span> z.p.color == RED:        <span class="comment"># z的父节点也为红色，违反性质4</span></span><br><span class="line">    <span class="keyword">if</span> z.p == z.p.p.left:      <span class="comment"># 如果z的父节点是左孩子结点</span></span><br><span class="line">        y = z.p.p.right        <span class="comment"># z的叔结点(父节点的另一个兄弟结点)</span></span><br><span class="line">        <span class="keyword">if</span> y.color == RED:        <span class="comment"># 情况1：z的叔结点y也是红色的</span></span><br><span class="line">            z.p.color = BLACK          <span class="comment"># z的父节点涂黑</span></span><br><span class="line">            y.color = BLACK            <span class="comment"># z的叔结点也涂黑</span></span><br><span class="line">            z.p.p.color = RED          <span class="comment"># z的祖父结点涂红(将祖父结点涂红可能违反性质4)</span></span><br><span class="line">            z = z.p.p                  <span class="comment"># z指针上升至祖父结点，等候下一次循环修复性质</span></span><br><span class="line">        <span class="keyword">elif</span> z == z.p.right:      <span class="comment"># 情况2：叔结点非红且z是右孩子结点</span></span><br><span class="line">            z = z.p                    <span class="comment"># 注意此时无论情况1是否发生，z的父节点都是红色</span></span><br><span class="line">            LEFT-ROTATE(T, z)          <span class="comment"># 左旋，转为情况3</span></span><br><span class="line">                                  <span class="comment"># 情况3：叔结点非红且z是左孩子结点(注意左旋后z的位置变化)</span></span><br><span class="line">        z.p.color = BLACK         <span class="comment"># 父节点涂黑</span></span><br><span class="line">        z.p.p.color = RED         <span class="comment"># 祖父结点涂红</span></span><br><span class="line">        RIGHT-ROTATE(T, z.p.p)    <span class="comment"># 右旋</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        same <span class="keyword">as</span> then clause <span class="keyword">with</span> <span class="string">"right"</span> <span class="keyword">and</span> <span class="string">"left"</span> exchanged</span><br><span class="line">T.root.color = BLACK              <span class="comment"># 根节点涂黑，修复性质2</span></span><br></pre></td></tr></table></figure><p>在调用<code>RB-INSERT-FIXUP</code>操作时，哪些红黑性质可能会被破坏呢？性质1（非红即黑）和性质3（叶子全黑）继续成立，因为新插入的红节点的两个子节点都是哨兵<span class="math inline">\(T.nil\)</span>。性质5（黑高相等）也会成立，因为结点<span class="math inline">\(z\)</span>代替了黑色的哨兵结点，并且<span class="math inline">\(z\)</span>本身是红结点且有哨兵结点。仅可能被破坏的就是性质2（根节点为黑色）和性质4（红节点不能有红孩子）。如果<span class="math inline">\(z\)</span>是根节点，则破坏了性质2；如果<span class="math inline">\(z\)</span>的父节点是红节点，则破坏了性质4。</p><p>当违反性质4时，<span class="math inline">\(z\)</span>与父节点<span class="math inline">\(z.p\)</span>都时红色，此时可能发生的情况如下：</p><ul><li>情况1：<span class="math inline">\(z\)</span>的叔结点<span class="math inline">\(y\)</span>是红色的。通过重新着色修复性质。</li><li><span class="math inline">\(z\)</span>的叔结点<span class="math inline">\(y\)</span>是黑色：<ul><li>情况2：<span class="math inline">\(z\)</span>是一个右孩子。通过左旋转化为情况3。（表明这几种情况不是完全独立的）</li><li>情况3：<span class="math inline">\(z\)</span>是一个左孩子。通过重新着色和右旋修复性质。</li></ul></li></ul><p>下图给出一个范例，显示在一棵红黑树上<code>RB-INSERT-FIXUP</code>如何操作。</p><p><img data-src="/uploads/posts/red-black-tree-insert-fixup.png"></p><p>由于一棵有<span class="math inline">\(n\)</span>个结点的红黑树的高度为<span class="math inline">\(O(\lg{n})\)</span>，因此<code>RB-INSERT</code>的插入操作要花费<span class="math inline">\(O(\lg{n})\)</span>时间。在<code>RB-INSERT-FIXUP</code>中，仅当情况1发生，然后指针<span class="math inline">\(z\)</span>沿着树上升2层，<code>while</code>循环才会重复执行。所以<code>while</code>循环可能被执行的总次数为<span class="math inline">\(O(\lg{n})\)</span>。因此，<code>RB-INSERT</code>总共花费<span class="math inline">\(O(\lg{n})\)</span>时间。此外，该程序所做的旋转不超过2次，因为只要执行了情况2（先左旋后右旋，旋转两次）或情况3（一次右旋），<code>while</code>循环就结束了。</p><h1 id="删除">删除</h1><p>从一棵红黑树中删除结点的过程是基于二叉搜索树的<a href="/data-structure/Binary-search-tree/#删除">删除</a>过程而来的。首先，需要特别设计一个子过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RB-TRANSPLANT(T, u, v): <span class="comment"># 用根节点为v的子树替换根节点为u的子树</span></span><br><span class="line"><span class="keyword">if</span> u.p == T.nil:        <span class="comment"># 若u为根结点，只需改变树的根指针即可</span></span><br><span class="line">    T.root = v</span><br><span class="line"><span class="keyword">elif</span> u == u.p.left:     <span class="comment"># 若u是左孩子</span></span><br><span class="line">    u.p.left = v        <span class="comment"># 移植v</span></span><br><span class="line"><span class="keyword">else</span>:                   <span class="comment"># 若u是右孩子</span></span><br><span class="line">    u.p.right = v</span><br><span class="line">v.p = u.p               <span class="comment"># 无条件执行，因为红黑树所有结点(包括哨兵结点)都有父节点属性</span></span><br></pre></td></tr></table></figure><p>过程<code>RB-DELETE</code>与<code>TREE-DELETE</code>类似，两个过程具有相同的基本结构。在<code>RB-DELETE</code>中能够找到<code>TREE-DELETE</code>的每一行语句（其中<code>NIL</code>被替换成了<code>T.nil</code>，<code>TRANSPLANT</code>换成了<code>RB-TRANSPLANT</code>），其执行的条件相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">RB-DELETE(T, z):</span><br><span class="line">y = z                             <span class="comment"># y为从树中删除的结点或者移至树内的结点</span></span><br><span class="line">y-original-color = y.color        <span class="comment"># 记录y的原始颜色</span></span><br><span class="line"><span class="keyword">if</span> z.left == T.nil:               <span class="comment"># 情况(a)：左孩子为空</span></span><br><span class="line">    x = z.right                     <span class="comment"># 移植后的结点可能会破坏红黑性质，用x记录其踪迹</span></span><br><span class="line">    RB-TRANSPLANT(T, z, z.right)    <span class="comment"># 用z的右孩子(可能为T.nil)替换z，达到删除z的目的</span></span><br><span class="line"><span class="keyword">elif</span> z.right == T.nil:            <span class="comment"># 情况(b)：右孩子为空</span></span><br><span class="line">    x = z.left                      <span class="comment"># 记录x的踪迹</span></span><br><span class="line">    RB-TRANSPLANT(T, z, z.left)     <span class="comment"># 用z的左孩子替换z</span></span><br><span class="line"><span class="keyword">else</span>:                             <span class="comment"># 情况(c)和(d)：有两个孩子，用z的后继结点y替换z</span></span><br><span class="line">    y = TREE-MINIMUM(z.right)       <span class="comment"># 查找后继结点y</span></span><br><span class="line">    y-original-color = y.color      <span class="comment"># 记录y的初始颜色</span></span><br><span class="line">    x = y.right                     <span class="comment"># 记录x的踪迹</span></span><br><span class="line">    <span class="keyword">if</span> y.p != z                   <span class="comment"># 情况(d)：后继结点y不是z的子节点</span></span><br><span class="line">        RB-TRANSPLANT(T, y, y.right)</span><br><span class="line">        y.right = z.right</span><br><span class="line">        y.right.p = y</span><br><span class="line">    <span class="keyword">else</span>:                         <span class="comment"># 情况(c)：y是z的子节点</span></span><br><span class="line">        x.p = y                     <span class="comment"># 没搞懂你存在的意义</span></span><br><span class="line">    RB-TRANSPLANT(T, z, y)</span><br><span class="line">    y.left = z.left</span><br><span class="line">    y.left.p = y</span><br><span class="line">    y.color = z.color             <span class="comment"># 删除z后，将替换z的结点y涂与z相同的颜色</span></span><br><span class="line"><span class="keyword">if</span> y-original-color == BLACK:  <span class="comment"># 如果原始为黑色，删除或移动y会破坏红黑性质；原始为红色，则不会</span></span><br><span class="line">    RB-DELETE-FIXUP(T, x)      <span class="comment"># 调用子过程修复红黑性质</span></span><br></pre></td></tr></table></figure><p>删除过程分为两部分：</p><ul><li><p>与二叉搜索树的删除操作相同的删除操作。下图描述了在二叉搜索树上删除结点时的4种情况，在红黑树上删除结点时同样考虑这4种情况。</p></li><li><p>修复红黑性质的<code>RB-DELETE-FIXUP</code>操作。为此，在删除结点时用变量<code>y-original-color</code>和<code>x</code>记录了必要的信息。</p></li></ul><p><img data-src="/uploads/posts/binary-search-tree-delete.png"></p><p>在<code>RB-DELETE</code>的最后，如果结点<span class="math inline">\(y\)</span>是黑色的，就有可能已经引入了一个或多个红黑性质被破坏的情况，所以调用<code>RB-DELETE-FIXUP</code>来恢复红黑性质。如果结点<span class="math inline">\(y\)</span>是红色，当<span class="math inline">\(y\)</span>被删除或移动时，红黑性质仍然保持，原因如下：</p><ol type="1"><li>树中的黑高没有变化。</li><li>不存在两个相邻的红色结点：<ul><li>情况(a)或情况(b)发生时（<span class="math inline">\(y\)</span>与<span class="math inline">\(z\)</span>相同），<span class="math inline">\(y\)</span>是红色，则其子节点一定是黑色。<span class="math inline">\(y\)</span>被删除后，其子节点替换<span class="math inline">\(y\)</span>的位置。因此，不会出现两个相邻的红色结点。</li><li>情况(c)发生时（<span class="math inline">\(y\)</span>是<span class="math inline">\(z\)</span>的后继结点），<span class="math inline">\(y\)</span>是红色，则<span class="math inline">\(y\)</span>的右孩子<span class="math inline">\(x\)</span>一定是黑色，<span class="math inline">\(y\)</span>替换<span class="math inline">\(z\)</span>后被涂成与<span class="math inline">\(z\)</span>相同的颜色，<span class="math inline">\(y\)</span>和<span class="math inline">\(x\)</span>不会出现两个相邻的红色结点。</li><li>情况(d)的第一步替换中，<span class="math inline">\(y\)</span>是红色，则<span class="math inline">\(x\)</span>是黑色，<span class="math inline">\(x\)</span>替换<span class="math inline">\(y\)</span>之后不会出现两个相邻的红色结点。第二步替换中，<span class="math inline">\(y\)</span>替换<span class="math inline">\(z\)</span>并且被涂成与<span class="math inline">\(z\)</span>相同的颜色。因此<span class="math inline">\(y\)</span>与<span class="math inline">\(r\)</span>不会是两个相邻的红色结点（<span class="math inline">\(y\)</span>与<span class="math inline">\(r\)</span>的颜色就是原来<span class="math inline">\(z\)</span>与<span class="math inline">\(r\)</span>的颜色）。</li></ul></li><li><span class="math inline">\(y\)</span>是红色，就不可能是根节点，所以根节点仍旧是黑色。</li></ol><p>如果结点<span class="math inline">\(y\)</span>是黑色，则会产生三个问题，可以通过调用<code>RB-DELETE-FIXUP</code>进行修复。</p><ol type="1"><li>在情况(a)和(b)中，<span class="math inline">\(y\)</span>（与<span class="math inline">\(z\)</span>相同）是黑色，若<span class="math inline">\(y\)</span>的一个红色的孩子（<span class="math inline">\(l\)</span>或<span class="math inline">\(r\)</span>）替换了<span class="math inline">\(y\)</span>成为新的根节点，则违反了性质2（根节点为黑色）。</li><li>在情况(c)和(d)中，<span class="math inline">\(y\)</span>是黑色，若<span class="math inline">\(y.p\)</span>与<span class="math inline">\(x\)</span>同时为红色，则删除<span class="math inline">\(z\)</span>后出现<span class="math inline">\(y.p\)</span>与<span class="math inline">\(x\)</span>都是红色的情况，违反了性质4（红色结点的孩子是黑色的）。</li><li><span class="math inline">\(y\)</span>为黑色，移动<span class="math inline">\(y\)</span>将导致包含<span class="math inline">\(y\)</span>的任何简单路径上的黑结点个数少1。因此，<span class="math inline">\(y\)</span>的任何祖先都不满足性质5（到叶节点的简单路径含有相同数目的黑色结点）。改正这一问题的办法是将现在占有<span class="math inline">\(y\)</span>原来位置的结点<span class="math inline">\(x\)</span>视为还有一重额外的黑色。当将黑色结点<span class="math inline">\(y\)</span>删除或移动时，将其黑色“下推“给结点<span class="math inline">\(x\)</span>。这个额外的黑色是针对结点<span class="math inline">\(x\)</span>的，而不是反映在它的<code>color</code>属性上的。<code>x.color</code>仍然是RED（如果<span class="math inline">\(x\)</span>是红黑色的）或BLACK（如果<span class="math inline">\(x\)</span>是双重黑色的）。<span class="math inline">\(x\)</span>时双重黑色或红黑色时，分别给包含<span class="math inline">\(x\)</span>的简单路径上黑结点数贡献了2或1。</li></ol><p>下面是过程<code>RB-DELETE-FIXUP</code>的伪代码。该过程可以恢复性质1、性质2和性质4。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">RB-DELETE-FIXUP(T, x):</span><br><span class="line"><span class="keyword">while</span> x != T.root <span class="keyword">and</span> x.color == BLACK:<span class="comment"># x为双重黑色，为黑色结点数贡献2</span></span><br><span class="line">    <span class="keyword">if</span> x == x.p.left:</span><br><span class="line">        w = x.p.right                  <span class="comment"># w指向兄弟结点</span></span><br><span class="line">        <span class="keyword">if</span> w.color == RED:             <span class="comment"># 情况1：w是红色的，可以通过以下操作转化为情况2、3或4</span></span><br><span class="line">            w.color = BLACK               <span class="comment"># 而不会违反红黑树的任何性质</span></span><br><span class="line">            x.p.color = RED            <span class="comment"># 改变w和x.p的颜色</span></span><br><span class="line">            LEFT-ROTATE(T, x.p)        <span class="comment"># 然后对x.p做一次左旋</span></span><br><span class="line">            w = x.p.right              <span class="comment"># x的新的兄弟结点w是黑色了</span></span><br><span class="line">        <span class="keyword">if</span> w.left.color == BLACK <span class="keyword">and</span> w.right.color == BLACK: <span class="comment"># 情况2：w和w的两个孩子都是黑色的</span></span><br><span class="line">            w.color = RED              <span class="comment"># 抹去w的黑色，w的所有祖先的黑高降低了1</span></span><br><span class="line">            x = x.p                    <span class="comment"># 作为补偿，在x.p(也是w的父节点)上新增一重额外的黑色</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 情况3和情况4的公共前提：w是黑色的，但两个孩子不全是黑色</span></span><br><span class="line">            <span class="keyword">if</span> w.right.color == BLACK: <span class="comment"># 情况3：w的右孩子是黑色的，暗示着左孩子是红色的</span></span><br><span class="line">                w.left.color = BLACK      <span class="comment"># 通过下列操作转化为情况4而不违反红黑树的任何性质</span></span><br><span class="line">                w.color = RED             <span class="comment"># w与其左孩子交换颜色(w变为红色了)</span></span><br><span class="line">                RIGHT-ROTATE(T, w)        <span class="comment"># 然后对w进行右旋(旋转后的w变成了新w的右孩子)</span></span><br><span class="line">                w = x.p.right             <span class="comment"># x的新的兄弟结点w仍旧是黑色的</span></span><br><span class="line">            w.color = x.p.color        <span class="comment"># 情况4：w的右孩子是红色的，左孩子颜色无所谓</span></span><br><span class="line">            x.p.color = BLACK          <span class="comment"># w涂上父节点的颜色</span></span><br><span class="line">            w.right.color = BLACK      <span class="comment"># 然后将父节点x.p和右孩子w.right涂成黑色</span></span><br><span class="line">            LEFT-ROTATE(T, x.p)        <span class="comment"># 最后对x.p进行一次左旋，即可去掉x的额外的黑色</span></span><br><span class="line">            x = T.root                 <span class="comment"># 将x设置为root，退出while循环</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">         <span class="comment"># same as then clause with "right" and "left" exchanged</span></span><br><span class="line">x.color = BLACK                        <span class="comment"># 若x指向红黑结点或根节点，直接涂成黑色即可修复性质5</span></span><br></pre></td></tr></table></figure><p><code>while</code>循环的目标是将额外的黑色沿树上移，直到可以将额外的黑色移除：</p><ol type="1"><li><span class="math inline">\(x\)</span>指向红黑结点，此时将<span class="math inline">\(x\)</span>着为黑色（<code>x.color = BLACK</code>），”移除”额外的黑色。</li><li><span class="math inline">\(x\)</span>指向根结点，此时”移除“额外的黑色即可。根结点<span class="math inline">\(x\)</span>到所有叶子结点的简单路径的黑色结点数都降低1。</li><li>执行适当的旋转和重新着色，退出循环（<code>while</code>循环内的代码）。</li></ol><p>在<code>while</code>循环中，<span class="math inline">\(x\)</span>总是指向一个具有双重黑色的非根结点。要判断<span class="math inline">\(x\)</span>是左孩子还是右孩子。为左孩子时的代码与为右孩子时的代码是对称的。</p><p><img data-src="/uploads/posts/red-black-tree-delete-fixup.png"></p><p>对图的说明：</p><ul><li>加黑的结点<span class="math inline">\(color\)</span>属性为BLACK，深阴影的结点<span class="math inline">\(color\)</span>属性为RED，浅阴影的结点<span class="math inline">\(color\)</span>属性用<span class="math inline">\(c\)</span>和<span class="math inline">\(c^\prime\)</span>表示，它既可为RED也可为BLACK。字母<span class="math inline">\(\alpha,\beta,\dots,\zeta\)</span>代表任意的子树。容易观察到在上述4中操作中，任意结点的黑高都没有发生变化（注意<span class="math inline">\(x\)</span>的黑色层数）。</li><li><span class="math inline">\(x\)</span>指向的结点带有额外的一重黑色，即<span class="math inline">\(x\)</span>为双重黑色或红黑色。</li></ul><p>对代码内注释的整理：</p><ul><li><span class="math inline">\(x\)</span>的兄弟结点<span class="math inline">\(w\)</span>是红色的。改变<span class="math inline">\(w\)</span>和<span class="math inline">\(x.p\)</span>的颜色，对<span class="math inline">\(x.p\)</span>做一次左旋。旋转后，<span class="math inline">\(x\)</span>的新兄弟结点new <span class="math inline">\(w\)</span>是黑色的，就将情况1转换为情况2、3或4。</li><li><span class="math inline">\(x\)</span>的兄弟结点<span class="math inline">\(w\)</span>是黑色的。<ul><li><span class="math inline">\(w\)</span>的两个子节点都是黑色的。去掉<span class="math inline">\(w\)</span>的黑色，作为补偿对<span class="math inline">\(w.p\)</span>（<span class="math inline">\(=x.p\)</span>）补偿一层黑色。在代码中表现为指针<span class="math inline">\(x\)</span>的移动。</li><li><span class="math inline">\(w\)</span>的两个孩子不全是黑色的。<ul><li><span class="math inline">\(w\)</span>的左孩子是红色的，右孩子是黑色的。交换<span class="math inline">\(w\)</span>和左孩子<span class="math inline">\(w.left\)</span>的颜色，对<span class="math inline">\(w\)</span>进行右旋。旋转后，<span class="math inline">\(x\)</span>的新兄弟结点<span class="math inline">\(w\)</span>是一个有红色右孩子的黑色结点，将情况3转换成情况4。</li><li><span class="math inline">\(w\)</span>的右孩子是红色的，左孩子颜色可红可黑。通过进行某些颜色修改并对<span class="math inline">\(x.p\)</span>做一次左旋，可以去掉<span class="math inline">\(x\)</span>的额外的黑色，从而使它变为单黑色。将<span class="math inline">\(x\)</span>设置为根后，当<span class="math inline">\(while\)</span>循环测试循环条件时，循环终止。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction To Algorithms </tag>
            
            <tag> data structures </tag>
            
            <tag> red-black tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度优先搜索</title>
      <link href="/notes/introduction-to-algorithms/depth-first-search/"/>
      <url>/notes/introduction-to-algorithms/depth-first-search/</url>
      
        <content type="html"><![CDATA[<h1 id="深度优先搜索">深度优先搜索</h1><p>深度优先搜索总是对最近才发现的结点<code>v</code>的出发边进行搜索，直到该结点的所有出发边都被发现为止。一旦结点<code>v</code>的所有出发边都被发现，搜索则“回溯”到<code>v</code>的前驱结点，来搜索该前驱结点的出发边。该过程一直持续到从源结点可以达到的所有结点都被发现为止。如果还存在尚未发现的结点，则深度优先搜索将从这些未被发现的结点中任选一个作为新的源结点，并重复同样的搜索过程。该算法重复整个过程，直到图中的所有结点都被发现为止。</p><p>与广度优先搜索不同的是，广度优先搜索的前驱子图形成一棵树，而深度优先搜索的前驱子图可能由多棵树组成，因为搜索可能从多个源结点重复进行。深度优先搜索的前驱子图形成一个由多棵<strong>深度优先树</strong>构成的<strong>深度优先森林</strong>。</p><a id="more"></a><h1 id="算法">算法</h1><p>像广度优先搜索算法一样，深度优先搜索算法在搜索过程中也是对结点进行涂色来指明结点的状态。每个结点的初始颜色都是白色，在结点被<strong>发现</strong>后变为灰色，在其邻接链表被扫描完成后变为黑色。该方法可以保证每个结点仅在一棵深度优先树中出现，因此，所有的深度优先树是不相交的（disjoint）。</p><p>深度优先搜索算法还在每个结点盖上一个<strong>时间戳</strong>。每个结点<span class="math inline">\(v\)</span>有两个时间戳：第一个时间戳<code>v.d</code>记录结点<code>v</code>第一次被发现的时间（涂上灰色的时候），第二个时间戳<code>v.f</code>记录的是搜索完成对<code>v</code>的邻接链表扫描的时间（涂上黑色的时候）。这些时间戳提供了图结构的重要信息，通常能够帮助推断深度优先算法的行为。</p><p>因为<code>|V|</code>个结点中每个结点只能有一个发现事件和一个完成事件，所以这些时间戳都是处于<code>1</code>和<code>2|V|</code>之间的整数。很显然，对于每个结点<code>u</code>，我们有：<code>u.d &lt; u.f</code>。结点<code>u</code>在时刻<code>u.d</code>之前为白色，在时刻<code>u.d</code>和<code>u.f</code>之间为灰色，在时刻<code>u.f</code>之后为黑色。</p><p>下面的伪代码给出的是基本的深度优先搜索算法。输入图<code>G</code>既可以是无向图，也可以是有向图。变量<code>time</code>是一个全局变量，用来计算时间戳。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DFS(G):</span><br><span class="line">    <span class="keyword">for</span> each vertex u <span class="keyword">in</span> G.V:  <span class="comment"># 初始化</span></span><br><span class="line">        u.color = WHITE</span><br><span class="line">        u.pi = NIL</span><br><span class="line">    time = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> each vertex u <span class="keyword">in</span> G.V:</span><br><span class="line">        <span class="keyword">if</span> u.color == WHITE:</span><br><span class="line">            DFS-VISIT(G, u)  <span class="comment"># 以u为源结点进行深度优先探索</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DFS-VISIT(G, u):</span><br><span class="line">    time = time + <span class="number">1</span></span><br><span class="line">    u.d = time</span><br><span class="line">    u.color = GRAY            <span class="comment"># 发现</span></span><br><span class="line">    <span class="keyword">for</span> each v <span class="keyword">in</span> G.Adj[u]:   <span class="comment"># 探索u的邻接结点</span></span><br><span class="line">        <span class="keyword">if</span> v.color == WHITE:  <span class="comment"># 若发现新的未探索结点</span></span><br><span class="line">            v.pi = u</span><br><span class="line">            DFS-VISIT(G, v)   <span class="comment"># 优先递归探索新的结点v</span></span><br><span class="line">            <span class="comment"># 探索完v后，循环继续进行，探索u的下一个邻接结点</span></span><br><span class="line">    u.color = BLACK</span><br><span class="line">    time = time + <span class="number">1</span></span><br><span class="line">    u.f = time                <span class="comment"># 探索完成</span></span><br></pre></td></tr></table></figure><p>注意，深度优先算法的结果可能依赖于算法<code>DFS</code>中第6行对结点进行检查的次序和算法<code>DFS-VISIT</code>中的第5行对一个结点的邻接结点进行访问的次序。不过，这些不同的访问次序在实际中并不会导致问题，因为我们通常可以对任意的深度优先搜索结果加以有效利用，并获得等价的结果。</p><p>下图展示算法<code>DFS</code>在有向图上的运行过程。结点中的时间戳表明该结点的发现时间和完成时间。</p><p><img data-src="/uploads/posts/the-progress-of-the-depth-first-search-algorithm-DFS-on-a-directed-graph.png"></p><h1 id="分析">分析</h1><p>如果排除调用<code>DFS-VISIT</code>的时间，<code>DFS</code>中两个循环所需的时间均为<span class="math inline">\(\Theta(V)\)</span>。对每个结点<span class="math inline">\(v\in{V}\)</span>来说，<code>DFS-VISIT</code>被调用的次数刚好为1次，这是因为在对一个结点<code>u</code>调用<code>DFS-VISIT</code>时，该结点<code>u</code>必须是白色，而<code>DFS-VISIT</code>所做的第一件事情就是将结点<code>u</code>涂上灰色。在执行<code>DFS-VISIT(G, v)</code>的过程中，5~8行的循环所执行的次数为<code>|Adj[v]|</code>。由于<span class="math inline">\(\sum_{v\in{V}}|Adj[v]|=\Theta(E)\)</span>，执行循环操作的总成本是<span class="math inline">\(\Theta(E)\)</span>。因此，深度优先搜索算法的运行时间为<span class="math inline">\(\Theta(V+E)\)</span>。</p><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> networkx <span class="keyword">import</span> Graph, DiGraph</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_f</span><span class="params">(g)</span>:</span></span><br><span class="line">    fmt = <span class="string">'&#123;0:&lt;10s&#125; &#123;1:&lt;10s&#125; &#123;2:&lt;10s&#125;\n'</span></span><br><span class="line">    title = fmt.format(<span class="string">'vertex'</span>, <span class="string">'distance'</span>, <span class="string">'previous'</span>)</span><br><span class="line">    data = <span class="string">''</span>.join(fmt.format(str(k), str(attr[<span class="string">'distance'</span>]), str(attr[<span class="string">'previous'</span>])) <span class="keyword">for</span> k, attr <span class="keyword">in</span> g.nodes.items())</span><br><span class="line">    print(title + data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">depth_first_search</span><span class="params">(g)</span>:</span>  <span class="comment"># 函数入口</span></span><br><span class="line">    <span class="keyword">for</span> attr <span class="keyword">in</span> g.nodes.values():  <span class="comment"># 初始化</span></span><br><span class="line">        attr[<span class="string">'visited'</span>], attr[<span class="string">'previous'</span>] = <span class="literal">False</span>, <span class="literal">None</span></span><br><span class="line">    g.graph[<span class="string">'time'</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> u, attr <span class="keyword">in</span> g.nodes.items():  <span class="comment"># 递归搜索无法访问到非连通的部分，通过此处循环解决</span></span><br><span class="line">        <span class="keyword">if</span> attr[<span class="string">'visited'</span>] <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">            dfs_visit(g, u)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs_visit</span><span class="params">(g, u)</span>:</span>  <span class="comment"># 递归方法主体</span></span><br><span class="line">    g.graph[<span class="string">'time'</span>] += <span class="number">1</span></span><br><span class="line">    g.nodes[u][<span class="string">'distance'</span>], g.nodes[u][<span class="string">'visited'</span>] = g.graph[<span class="string">'time'</span>], <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> g[u].keys():</span><br><span class="line">        <span class="keyword">if</span> g.nodes[v][<span class="string">'visited'</span>] <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">            g.nodes[v][<span class="string">'previous'</span>] = u</span><br><span class="line">            dfs_visit(g, v)  <span class="comment"># 递归</span></span><br><span class="line">    g.nodes[u][<span class="string">'visited'</span>] = <span class="literal">True</span></span><br><span class="line">    g.graph[<span class="string">'time'</span>] += <span class="number">1</span></span><br><span class="line">    g.nodes[u][<span class="string">'distance'</span>] = str(g.nodes[u][<span class="string">'distance'</span>]) + <span class="string">'/'</span> + str(g.graph[<span class="string">'time'</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    h = DiGraph()</span><br><span class="line">    h.add_nodes_from(<span class="string">'uvwxyz'</span>)</span><br><span class="line">    h.add_edges_from([(<span class="string">'u'</span>, <span class="string">'v'</span>), (<span class="string">'u'</span>, <span class="string">'x'</span>), (<span class="string">'x'</span>, <span class="string">'v'</span>), (<span class="string">'v'</span>, <span class="string">'y'</span>), (<span class="string">'y'</span>, <span class="string">'x'</span>), (<span class="string">'w'</span>, <span class="string">'y'</span>), (<span class="string">'w'</span>, <span class="string">'z'</span>), (<span class="string">'z'</span>, <span class="string">'z'</span>)])</span><br><span class="line">    depth_first_search(h)</span><br><span class="line">    print_f(h)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vertex     distance   previous  </span><br><span class="line">u          1/8        None</span><br><span class="line">v          2/7        u</span><br><span class="line">w          9/12       None</span><br><span class="line">x          4/5        y</span><br><span class="line">y          3/6        v</span><br><span class="line">z          10/11      w</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithms </tag>
            
            <tag> recursion </tag>
            
            <tag> DFS </tag>
            
            <tag> Introduction To Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python: map/reduce/filter</title>
      <link href="/programming/python-map-reduce-filter/"/>
      <url>/programming/python-map-reduce-filter/</url>
      
        <content type="html"><![CDATA[<h1 id="mapfunction-iterable-...">map(function, iterable, ...)</h1><p>Return an iterator that applies function to every item of iterable, yielding the results. If additional iterable arguments are passed, function must take that many arguments and is applied to the items from all iterables in parallel. With multiple iterables, the iterator stops when the shortest iterable is exhausted. For cases where the function inputs are already arranged into argument tuples, see <a href="https://devdocs.io/python~3.6/library/itertools#itertools.starmap" target="_blank" rel="noopener"><code>itertools.starmap()</code></a>.</p><h1 id="functools.reducefunction-iterable-initializer">functools.reduce(function, iterable[, initializer])</h1><p>Apply function of two arguments cumulatively to the items of sequence, from left to right, so as to reduce the sequence to a single value. For example, <code>reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])</code> calculates <code>((((1+2)+3)+4)+5)</code>. The left argument, x, is the accumulated value and the right argument, y, is the update value from the sequence. If the optional initializer is present, it is placed before the items of the sequence in the calculation, and serves as a default when the sequence is empty. If initializer is not given and sequence contains only one item, the first item is returned.</p><h1 id="filterfunction-iterable">filter(function, iterable)</h1><p>Construct an iterator from those elements of <em>iterable</em> for which <em>function</em> returns true. <em>iterable</em> may be either a sequence, a container which supports iteration, or an iterator. If <em>function</em> is <code>None</code>, the identity function is assumed, that is, all elements of <em>iterable</em> that are false are removed.</p><p>Note that <code>filter(function, iterable)</code> is equivalent to the generator expression <code>(item for item in iterable if function(item))</code> if function is not <code>None</code> and <code>(item for item in iterable if item)</code> if function is <code>None</code>.</p><p>See <a href="https://devdocs.io/python~3.6/library/itertools#itertools.filterfalse" target="_blank" rel="noopener"><code>itertools.filterfalse()</code></a> for the complementary function that returns elements of <em>iterable</em> for which <em>function</em> returns false.</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx启用webdav</title>
      <link href="/server/nginx-set-up-a-webdav/"/>
      <url>/server/nginx-set-up-a-webdav/</url>
      
        <content type="html"><![CDATA[<h1 id="环境">环境</h1><ul><li><p>系统：ubuntu 18.04.2 LTS</p></li><li><p>nginx：1.14.0</p></li><li><p>客户端：iOS documents 和 Windows winscp</p></li></ul><h1 id="安装nginx">安装nginx</h1><p>nginx默认支持dav，但PROPFIND、OPTIONS操作还不支持。支持这些操作需要额外的模块。</p><ul><li>完全安装。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip:~$ sudo apt-get update</span><br><span class="line">ubuntu@ip:~$ sudo apt-get install nginx-full</span><br></pre></td></tr></table></figure><ul><li>部分安装。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip:~$ sudo apt-get update</span><br><span class="line">ubuntu@ip:~$ sudo apt-get install nginx nginx-extras</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="配置">配置</h1><p>使用新域名。在<code>sites-available</code>目录下添加配置文件。</p><figure class="highlight plain"><figcaption><span>/etc/nginx/sites-available/dav</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 443 ssl;</span><br><span class="line">        listen [::]:443 ssl;</span><br><span class="line"></span><br><span class="line">        server_name your_dav_domain.com;</span><br><span class="line">        root /var/www/nginx/dav;</span><br><span class="line"></span><br><span class="line">        ssl on;</span><br><span class="line">        ssl_certificate /your/path/dav.crt;</span><br><span class="line">        ssl_certificate_key /your/path/dav.key;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                charset         utf-8;</span><br><span class="line">                autoindex       on;</span><br><span class="line"></span><br><span class="line">                client_body_temp_path   /etc/nginx/client_temp;</span><br><span class="line">                client_max_body_size    512m;  # 最大文件，若为0则表示不限制</span><br><span class="line"></span><br><span class="line">                dav_methods PUT DELETE MKCOL COPY MOVE;</span><br><span class="line">                dav_ext_methods PROPFIND OPTIONS;  # 需要额外的模块支持</span><br><span class="line"></span><br><span class="line">                create_full_put_path    on;</span><br><span class="line">                dav_access              group:rw all:r;</span><br><span class="line"></span><br><span class="line">                auth_basic              &quot;Access limited&quot;;</span><br><span class="line">                auth_basic_user_file    /etc/nginx/user.passwd;</span><br><span class="line"></span><br><span class="line">                access_log              /var/log/nginx/access.dav.log;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启用该配置。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git@ip:/etc/nginx/sites-enabled$ <span class="built_in">cd</span> /etc/nginx/sites-available/</span><br><span class="line">git@ip:/etc/nginx/sites-available$ sudo ln -s dav ../sites-enabled/dav</span><br><span class="line">git@ip:/etc/nginx/sites-available$ sudo nginx -t</span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf <span class="built_in">test</span> is successful</span><br><span class="line">git@ip:/etc/nginx/sites-available$ sudo nginx -s reload</span><br></pre></td></tr></table></figure><h1 id="删除文件夹">删除文件夹</h1><p>搭建了webdav服务器后，能访问并可以执行部分操作，如创建文件等。但也有不能执行的操作，出现此问题的原因是客户端和服务器的要求不兼容。比如winscp可以删除文件夹，但不可以修改文件夹名称。documents不可以删除文件夹（但是文件夹里面的文件会被成功删除），也不能重命名文件夹（客户端提示权限不足，提示并不正确，看nginx的错误日志）。</p><table><thead><tr class="header"><th>操作</th><th>winscp</th><th>documents</th><th>err_log</th></tr></thead><tbody><tr class="odd"><td>浏览</td><td>Y</td><td>Y</td><td></td></tr><tr class="even"><td>创建文件</td><td>Y</td><td>Y</td><td></td></tr><tr class="odd"><td>创建文件夹</td><td>Y</td><td>Y</td><td></td></tr><tr class="even"><td>移动文件（包括重命名）</td><td>Y</td><td>Y</td><td></td></tr><tr class="odd"><td>移动文件夹（包括重命名）</td><td>N</td><td>N</td><td><code>&quot;/folder&quot; is collection</code></td></tr><tr class="even"><td>删除文件</td><td>Y</td><td>Y</td><td></td></tr><tr class="odd"><td>删除文件夹</td><td>Y</td><td>N</td><td><code>DELETE &quot;/folder&quot; failed (21: Is a directory)</code></td></tr></tbody></table><p>根据日志，报错的原因是nginx要求对文件夹的操作请求的末尾带上斜线<code>/</code>，比如删除文件夹必须是<code>DELETE /folder/</code>，但是客户端发出的请求是<code>DELETE /folder</code>，因此报错。</p><p>修复方法是重写请求，在webdav的配置文件中加入下列修改：</p><figure class="highlight diff"><figcaption><span>/etc/nginx/sites-enabled/dav</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"><span class="addition">+    # 如果请求内容是文件夹，在请求末尾加上/</span></span><br><span class="line"><span class="addition">+    if ( -d $request_filename ) &#123;  </span></span><br><span class="line"><span class="addition">+        rewrite ^(.*[^/])$ $1/ break;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="移动文件夹">移动文件夹</h1><p>加了如上配置后，documents可以删除文件夹了，但是不论winscp还是documents都无法重命名文件夹。错误日志为<code>both URI &quot;/fog/&quot; and &quot;Destination&quot; URI &quot;https://dav.server.demo/fofg&quot; should be either collections or non-collections</code>。即nginx收到了将文件夹重命名为文件的操作请求，于是报出以上错误。在尝试了各种配置无法解决后，我在nginx源文件<code>ngx_http_dav_module.c</code>中找到了这段代码。这段代码要求<code>URI</code>和<code>Destination</code>一致，要么都带<code>/</code>，要么都不带<code>/</code>。</p><figure class="highlight c"><figcaption><span>~/nginx-1.14.0/src/http/modules/ngx_http_dav_module.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((r-&gt;uri.data[r-&gt;uri.len - <span class="number">1</span>] == <span class="string">'/'</span> &amp;&amp; *(last - <span class="number">1</span>) != <span class="string">'/'</span>)</span><br><span class="line">    || (r-&gt;uri.data[r-&gt;uri.len - <span class="number">1</span>] != <span class="string">'/'</span> &amp;&amp; *(last - <span class="number">1</span>) == <span class="string">'/'</span>))</span><br><span class="line">&#123;</span><br><span class="line">    ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                  <span class="string">"both URI \"%V\" and \"Destination\" URI \"%V\" "</span></span><br><span class="line">                  <span class="string">"should be either collections or non-collections"</span>,</span><br><span class="line">                  &amp;r-&gt;uri, &amp;dest-&gt;value);</span><br><span class="line">    <span class="keyword">return</span> NGX_HTTP_CONFLICT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要解决这个问题，我注释掉了这段代码，重新编译nginx。</p><h1 id="编译nginx">编译nginx</h1><p>下载nginx和nginx-dav-ext-module。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip:~$ wget http://nginx.org/download/nginx-1.14.0.tar.gz</span><br><span class="line">ubuntu@ip:~$ tar xzf nginx-1.14.0.tar.gz</span><br><span class="line">ubuntu@ip:~$ git <span class="built_in">clone</span> https://github.com/arut/nginx-dav-ext-module.git</span><br></pre></td></tr></table></figure><p>在nginx源码中注释掉上述代码。</p><figure class="highlight c"><figcaption><span>~/nginx-1.14.0/src/http/modules/ngx_http_dav_module.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if ((r-&gt;uri.data[r-&gt;uri.len - 1] == '/' &amp;&amp; *(last - 1) != '/')</span></span><br><span class="line"><span class="comment">    || (r-&gt;uri.data[r-&gt;uri.len - 1] != '/' &amp;&amp; *(last - 1) == '/'))</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0,</span></span><br><span class="line"><span class="comment">                  "both URI \"%V\" and \"Destination\" URI \"%V\" "</span></span><br><span class="line"><span class="comment">                  "should be either collections or non-collections",</span></span><br><span class="line"><span class="comment">                  &amp;r-&gt;uri, &amp;dest-&gt;value);</span></span><br><span class="line"><span class="comment">    return NGX_HTTP_CONFLICT;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>设置编译参数，<a href="https://xuexb.github.io/learn-nginx/guide/nginx-configure-descriptions.html" target="_blank" rel="noopener">编译参数介绍</a>。不想深究编译参数，可以使用如下默认的编译参数。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip:~/nginx-1.14.0$ nginx -V  <span class="comment"># 查看编译参数</span></span><br><span class="line">nginx version: nginx/1.14.0 (Ubuntu)</span><br><span class="line">built with OpenSSL 1.1.1  11 Sep 2018</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --with-cc-opt=<span class="string">'-g -O2 -fdebug-prefix-map=/build/nginx-DUghaW/nginx-1.14.0=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wdate-time -D_FORTIFY_SOURCE=2'</span> --with-ld-opt=<span class="string">'-Wl,-Bsymbolic-functions -Wl,-z,relro -Wl,-z,now -fPIC'</span> --prefix=/usr/share/nginx --conf-path=/etc/nginx/nginx.conf --http-log-path=/var/<span class="built_in">log</span>/nginx/access.log --error-log-path=/var/<span class="built_in">log</span>/nginx/error.log --lock-path=/var/lock/nginx.lock --pid-path=/run/nginx.pid --modules-path=/usr/lib/nginx/modules --http-client-body-temp-path=/var/lib/nginx/body --http-fastcgi-temp-path=/var/lib/nginx/fastcgi --http-proxy-temp-path=/var/lib/nginx/proxy --http-scgi-temp-path=/var/lib/nginx/scgi --http-uwsgi-temp-path=/var/lib/nginx/uwsgi --with-debug --with-pcre-jit --with-http_ssl_module --with-http_stub_status_module --with-http_realip_module --with-http_auth_request_module --with-http_v2_module --with-http_dav_module --with-http_slice_module --with-threads --with-http_addition_module --with-http_geoip_module=dynamic --with-http_gunzip_module --with-http_gzip_static_module --with-http_image_filter_module=dynamic --with-http_sub_module --with-http_xslt_module=dynamic --with-stream=dynamic --with-stream_ssl_module --with-mail=dynamic --with-mail_ssl_module</span><br></pre></td></tr></table></figure><p>保持这些参数不变，添加额外的<code>nginx-dav-ext-module</code>模块。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip:~/nginx-1.14.0$ ./configure --with-cc-opt=...原来的参数... --add-module=../nginx-dav-ext-module</span><br><span class="line">ubuntu@ip:~/nginx-1.14.0$ make  <span class="comment"># 编译</span></span><br><span class="line">ubuntu@ip:~/nginx-1.14.0$ sudo objs/nginx -t  <span class="comment"># 测试</span></span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf <span class="built_in">test</span> is successful</span><br><span class="line">ubuntu@ip:~/nginx-1.14.0$ sudo cp /usr/sbin/nginx /usr/sbin/nginx.bak  <span class="comment"># 备份</span></span><br><span class="line">ubuntu@ip:~/nginx-1.14.0$ sudo nginx -s stop  <span class="comment"># 停止服务</span></span><br><span class="line">ubuntu@ip:~/nginx-1.14.0$ sudo cp objs/nginx /usr/sbin/nginx  <span class="comment"># 替换</span></span><br><span class="line">ubuntu@ip:~/nginx-1.14.0$ sudo service nginx start  <span class="comment"># 重启</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> webdav </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu挂载和卸除文件系统</title>
      <link href="/server/ubuntu-mount-and-unmount-drive/"/>
      <url>/server/ubuntu-mount-and-unmount-drive/</url>
      
        <content type="html"><![CDATA[<h1 id="挂载">挂载</h1><p>查看文件系统</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git@ip:~$ sudo fdisk -l</span><br><span class="line">...省略...</span><br><span class="line">Disk /dev/xvdb: 20 GiB, 21474836480 bytes, 41943040 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br></pre></td></tr></table></figure><p>目标文件系统为<code>/dev/xvdb</code>。挂载：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git@ip:~$ sudo mkdir /mnt/data</span><br><span class="line">git@ip:~$ sudo mount /dev/xvdb /mnt/data/</span><br><span class="line">git@ip:~$ sudo df -h  <span class="comment"># 显示文件系统</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">...省略...</span><br><span class="line">/dev/xvdb        20G  208M   19G   2% /mnt/data</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="卸除">卸除</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git@ip:~$ sudo umount /dev/xvdb  <span class="comment"># 通过设备名</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git@ip:~$ sudo umount /mnt/data  <span class="comment"># 通过挂载点</span></span><br></pre></td></tr></table></figure><h1 id="自动挂载">自动挂载</h1><p>查看文件系统信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git@ip:~$ sudo e2label /dev/xvdb data  <span class="comment"># 修改卷标</span></span><br><span class="line">git@ip:~$ sudo blkid /dev/xvdb</span><br><span class="line">/dev/xvdb: LABEL=<span class="string">"data"</span> UUID=<span class="string">"a0001bdb-4b69-4419-9339-f57ddec2f007"</span> TYPE=<span class="string">"ext4"</span></span><br></pre></td></tr></table></figure><p>修改<code>fstab</code>文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git@ip:~$ sudo nano /etc/fstab</span><br></pre></td></tr></table></figure><p>添加一列：</p><figure class="highlight diff"><figcaption><span>/etc/fstab</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+    LABEL=data              /mnt/data       ext4    defaults                0 2</span></span><br></pre></td></tr></table></figure><p><code>/etc/fstab</code> 文件包含了如下字段，通过空格或 Tab 分隔：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;file system&gt;    &lt;dir&gt;    &lt;type&gt;    &lt;options&gt;    &lt;dump&gt;    &lt;pass&gt;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;file system&gt;</code> - 要挂载的分区或存储设备。</li><li><code>&lt;dir&gt;</code> - <code>&lt;file systems&gt;</code>的挂载位置。</li><li><code>&lt;type&gt;</code> - 文件系统类型，支持许多种不同的文件系统：<code>ext2</code>, <code>ext3</code>, <code>ext4</code>, <code>reiserfs</code>, <code>xfs</code>, <code>jfs</code>, <code>smbfs</code>, <code>iso9660</code>, <code>vfat</code>, <code>ntfs</code>, <code>swap</code> 及 <code>auto</code>。 设置成<code>auto</code>类型，mount 命令会猜测使用的文件系统类型，对 CDROM 和 DVD 等移动设备是非常有用的。</li><li><code>&lt;options&gt;</code> - 挂载时使用的参数，注意有些 参数是特定文件系统才有的。</li><li><code>&lt;dump&gt;</code> - dump工具通过它决定何时作备份。dump会检查其内容，并用数字来决定是否对这个文件系统进行备份。允许的数字是0和1。0表示忽略，1则进行备份。大部分的用户是没有安装dump的 ，对他们而言<code>&lt;dump&gt;</code> 应设为 0。</li><li><code>&lt;pass&gt;</code> - fsck读取 <code>&lt;pass&gt;</code> 的数值来决定需要检查的文件系统的检查顺序。允许的数字是0, 1, 和2。 根目录应当获得最高的优先权 1, 其它所有需要被检查的设备设置为 2. 0 表示设备不会被fsck所检查。</li></ul><p><strong>验证配置的正确性</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git@ip:~$ sudo mount -a  <span class="comment"># 有错误时打印错误信息</span></span><br><span class="line">mount: /mnt/data: can<span class="string">'t find LABEL=date.</span></span><br></pre></td></tr></table></figure><p>最后可以重启系统验证一下。</p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> command </tag>
            
            <tag> mount </tag>
            
            <tag> unmount </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python迭代器与生成器</title>
      <link href="/programming/python-iterator-and-generator/"/>
      <url>/programming/python-iterator-and-generator/</url>
      
        <content type="html"><![CDATA[<h1 id="迭代器">迭代器</h1><p>迭代是访问集合元素的一种方式。迭代器从集合的第一个元素开始访问，直到所有元素被访问完。迭代器只能往前访问，不能后退。字符串，列表，集合等集合对象都可用于创建迭代器。</p><p>多数情况下，更倾向于通过以下方式遍历集合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line"><span class="meta">... </span>    print(i, end=<span class="string">' '</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>    print()</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>等价地，可以创建一个集合<code>a</code>的迭代器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it = iter(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>            print(next(it), end=<span class="string">' '</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">except</span> StopIteration:   <span class="comment"># 访问结束后再次调用next(it)会抛出此异常</span></span><br><span class="line"><span class="meta">... </span>            print()</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">break</span></span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><hr><p>将一个类作为迭代器使用，需要在类中实现两个方法<code>__iter()__</code>和<code>__next()__</code>。</p><p>例如，有一个链表，我希望像遍历数组一样可以遍历链表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        self.key, self.next = key, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.y = self  <span class="comment"># 用变量y记录位置</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.y <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 队尾判断</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x = self.y  <span class="comment"># 暂存</span></span><br><span class="line">            <span class="keyword">if</span> self.y <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment"># 更新位置以便下次访问</span></span><br><span class="line">                self.y = self.y.next</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a, b, c = Node(<span class="number">1</span>), Node(<span class="number">2</span>), Node(<span class="number">3</span>)</span><br><span class="line">    a.next, b.next, c.next = b, c, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a:             <span class="comment"># for each</span></span><br><span class="line">        print(i, end=<span class="string">' '</span>)</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line">    it = iter(b)            <span class="comment"># iterator</span></span><br><span class="line">    print(next(it))</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h1 id="生成器">生成器</h1><p>在Python中，使用了yield的函数被称为生成器。生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</p><p>python可以通过列表解析（list comprehension）的方式构建集合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><p>实际上，<code>i for i in range(10)</code>就是一个生成器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">generator</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>在生成器运行过程中，每次遇到yield时函数会暂停并保存当前所有的运行信息，返回yield的值，并在下一次执行<code>next()</code>方法时从当前位置继续运行。</p><p>这在很多情况下特别有用。例如，最近研究如何获得一个图中两点之间的所有简单路径。一个测试示例中大概包含一千万条不同的简单路径，若是一次性将这一千万条作为数组返回，……，大概我的笔记本会原地爆炸吧。</p><p>这时生成器就排上用场了。为了简化说明，使用斐波那契数列作为示例。一个斐波那契数列的迭代版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">"""返回斐波那契数列的前n个元素组成的列表"""</span></span><br><span class="line">    a, b, c, r = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, []</span><br><span class="line">    <span class="keyword">while</span> c &lt; n:</span><br><span class="line">        r.append(a)</span><br><span class="line">        a, b, c = b, a + b, c + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure><p>假设需要获得前一千万个数，……，(#`O′)。下面使用yield将之变为生成器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci_it</span><span class="params">(n)</span>:</span> <span class="comment"># 它是一个迭代器</span></span><br><span class="line">    a, b, c = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> c &lt; n:</span><br><span class="line">        <span class="keyword">yield</span> a  <span class="comment"># 每次执行到此处暂停，返回一个结果，下次调用next时将从此处继续执行</span></span><br><span class="line">        a, b, c = b, a + b, c + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> fibonacci_it(<span class="number">10</span>):    <span class="comment"># 使用</span></span><br><span class="line">        print(i, end=<span class="string">' '</span>)</span><br><span class="line">    print()</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 1 2 3 5 8 13 21 34</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> iterator </tag>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NetworkX</title>
      <link href="/documentation/networkx-documentation/"/>
      <url>/documentation/networkx-documentation/</url>
      
        <content type="html"><![CDATA[<h1 id="官网文档">官网文档</h1><p><a href="https://networkx.github.io/documentation/stable/index.html" class="uri" target="_blank" rel="noopener">https://networkx.github.io/documentation/stable/index.html</a></p><h1 id="创建一个图">创建一个图</h1><p>有4种+1类<a href="https://networkx.github.io/documentation/stable/reference/classes/index.html#basic-graph-types" target="_blank" rel="noopener">Basic graph types</a>。</p><ul><li><code>Graph</code>： 无向图，允许自环（顶点与自身连接的边）。</li><li><code>DiGraph</code>： 有向图，允许自环。</li><li><code>MultiGraph</code>： 无向图，允许自环和平行边（两条或多条与同一对顶点相连接的边）。</li><li><code>MultiDiGraph</code>：有向图，允许自环和平行边。</li><li>Ordered Graph：<code>OrderedGraph</code>，<code>OrderedDiGraph</code>，<code>OrderedMultiGraph</code>，<code>OrderedMultiDiGraph</code>。</li></ul><p>Ordered Graph的存在意义：在返回图中顶点或边的集合时，Ordered Graph总是以一个固定的顺序返回。</p><p>当<strong>无需此项性质</strong>或<strong>使用Python 3.6+</strong>（Python 3.6+中，集合的顺序是固定的）时，使用前四种基本类即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = nx.Graph()                   <span class="comment"># 创建一个空的无向图</span></span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="图的属性">图的属性</h1><p>图的属性保存在<code>graph</code>字典变量中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = nx.Graph(source=<span class="string">'s'</span>, sink=<span class="string">'t'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.graph</span><br><span class="line">&#123;<span class="string">'source'</span>: <span class="string">'s'</span>, <span class="string">'sink'</span>: <span class="string">'t'</span>&#125;</span><br></pre></td></tr></table></figure><h1 id="添加结点和边">添加结点和边</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加一个结点</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.add_node(<span class="number">0</span>)                  <span class="comment"># 任何可以哈希的对象都可以作为结点</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.add_node(<span class="string">'0'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.add_node(nx.Graph())         <span class="comment"># 甚至其他图也可以作为结点</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加多个结点，传入集合</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.add_nodes_from([<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.add_nodes_from(range(<span class="number">1</span>, <span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.add_nodes_from(h.nodes)      <span class="comment"># 或者 g.add_nodes_from(h)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有结点</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.nodes</span><br><span class="line">NodeView((<span class="number">0</span>, <span class="string">'0'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加一条边</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.add_edge(<span class="number">0</span>,<span class="number">1</span>)  <span class="comment"># 结点不存在时会自动添加</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加多条边</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.add_edges_from([(<span class="number">0</span>,<span class="number">2</span>),(<span class="number">1</span>,<span class="number">2</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.add_edges_from(g.edges)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有边</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.edges</span><br><span class="line">EdgeView([(<span class="number">0</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">1</span>)])</span><br></pre></td></tr></table></figure><h1 id="访问结点和边">访问结点和边</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在添加结点的同时添加属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.add_node(<span class="number">1</span>, color=<span class="string">'red'</span>, weight=<span class="number">4</span>) <span class="comment"># 第1个变量是结点，后面是任意多个属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.add_nodes_from([<span class="number">1</span>, <span class="number">2</span>], color=<span class="string">'red'</span>, weight=<span class="number">4</span>) <span class="comment"># 所有结点具有相同的属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问结点的属性，返回的是一个dict对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.nodes[<span class="number">2</span>]</span><br><span class="line">&#123;<span class="string">'color'</span>: <span class="string">'red'</span>, <span class="string">'weight'</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.nodes.data() <span class="comment"># 访问所有结点及其属性，或 g.nodes(data=True)</span></span><br><span class="line">NodeDataView(&#123;<span class="number">1</span>: &#123;<span class="string">'color'</span>: <span class="string">'red'</span>, <span class="string">'weight'</span>: <span class="number">4</span>&#125;&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.nodes.data(<span class="string">'color'</span>)  <span class="comment"># 只带color属性</span></span><br><span class="line">NodeDataView(&#123;<span class="number">1</span>: <span class="string">'red'</span>&#125;, data=<span class="string">'color'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加边的同时添加属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.add_edge(<span class="number">1</span>, <span class="number">2</span>, weight=<span class="number">4.7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.add_edges_from([(<span class="number">3</span>, <span class="number">4</span>), (<span class="number">4</span>, <span class="number">5</span>)], color=<span class="string">'red'</span>) <span class="comment"># 所有边具有相同的属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.add_edges_from([(<span class="number">1</span>, <span class="number">2</span>, &#123;<span class="string">'color'</span>: <span class="string">'blue'</span>&#125;), (<span class="number">2</span>, <span class="number">3</span>, &#123;<span class="string">'weight'</span>: <span class="number">8</span>&#125;)]) <span class="comment"># 分开添加属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 权重图经常用到，networkx为此定义了一个特殊的方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.add_weighted_edges_from([(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0.5</span>),(<span class="number">1</span>, <span class="number">3</span>, <span class="number">0.7</span>)]) <span class="comment"># 存储权重的key为weight</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回所有边的属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.edges.data()  <span class="comment"># 或 g.edges(data=True)，与访问结点属性的方法类似</span></span><br><span class="line">EdgeDataView([(<span class="number">1</span>, <span class="number">2</span>, &#123;<span class="string">'weight'</span>: <span class="number">0.5</span>&#125;), (<span class="number">1</span>, <span class="number">3</span>, &#123;<span class="string">'weight'</span>: <span class="number">0.7</span>&#125;)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问边的属性的方式，返回一个dict</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g[<span class="number">1</span>][<span class="number">2</span>]</span><br><span class="line">&#123;<span class="string">'color'</span>: <span class="string">'blue'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.edges[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">&#123;<span class="string">'color'</span>: <span class="string">'blue'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.adj[<span class="number">1</span>][<span class="number">2</span>]</span><br><span class="line">&#123;<span class="string">'color'</span>: <span class="string">'blue'</span>&#125;</span><br></pre></td></tr></table></figure><h1 id="遍历">遍历</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.adj   <span class="comment"># 图g的邻接链表，或 g.adjacency()</span></span><br><span class="line">AdjacencyView(&#123;  <span class="comment"># 稍微格式化了一下，原来的输出为一行</span></span><br><span class="line">    <span class="number">1</span>: &#123;<span class="number">2</span>: &#123;&#125;, <span class="number">3</span>: &#123;&#125;&#125;,  <span class="comment"># 结点1: 结点1的邻接边集合</span></span><br><span class="line">    <span class="number">2</span>: &#123;<span class="number">1</span>: &#123;&#125;&#125;,         <span class="comment"># 结点2: 结点2的邻接边集合</span></span><br><span class="line">    <span class="number">3</span>: &#123;<span class="number">1</span>: &#123;&#125;&#125;          <span class="comment"># 3: &#123;1: &#123;&#125;&#125; 注意后面的集合是边(3,1)的属性</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n, nbrsdict <span class="keyword">in</span> G.adjacency():               <span class="comment"># 以邻接链表的方式遍历边</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> nbr, eattr <span class="keyword">in</span> nbrsdict.items():</span><br><span class="line"><span class="meta">... </span>       <span class="keyword">if</span> <span class="string">'weight'</span> <span class="keyword">in</span> eattr:</span><br><span class="line"><span class="meta">... </span>           <span class="comment"># Do something useful with the edges</span></span><br><span class="line"><span class="meta">... </span>           <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> u, v, weight <span class="keyword">in</span> G.edges.data(<span class="string">'weight'</span>):     <span class="comment"># 通常这种方法更加便利</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> weight <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="comment"># Do something useful with the edges</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h1 id="其他">其他</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> <span class="keyword">in</span> g   <span class="comment"># 结点1是否在图g中</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[n <span class="keyword">for</span> n <span class="keyword">in</span> g <span class="keyword">if</span> n &lt; <span class="number">3</span>] <span class="comment"># 使用列表解析循环图g的结点</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(g)  <span class="comment"># 结点数目，或 g.number_of_nodes()</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.number_of_edges()</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.number_of_selfloops()</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> networkx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广度优先搜索</title>
      <link href="/notes/introduction-to-algorithms/breadth-first-search/"/>
      <url>/notes/introduction-to-algorithms/breadth-first-search/</url>
      
        <content type="html"><![CDATA[<h1 id="广度优先搜索">广度优先搜索</h1><p>广度优先搜索是最简单的图搜索算法之一，也是许多重要算法的原型。<strong>Prim的最小生成树算法和Dijkstra的单源最短路径算法都使用了类似广度优先搜索的思想</strong>。</p><p>给定图<span class="math inline">\(G=(V,E)\)</span>和一个可以识别的源结点<span class="math inline">\(s\)</span>，广度优先搜索对图<span class="math inline">\(G\)</span>中的边进行系统性的探索来发现<strong>可以从源结点<span class="math inline">\(s\)</span>到达的所有结点</strong>。该算法能够计算从源结点<span class="math inline">\(s\)</span>到每个可到达的结点的距离（最少的边数），同时生成一棵“广度优先搜索树”。该树以源结点<span class="math inline">\(s\)</span>为根节点，包含所有可以从<span class="math inline">\(s\)</span>到达的结点。对于每个从源结点<span class="math inline">\(s\)</span>可以到达的结点<span class="math inline">\(v\)</span>，在广度优先搜索树里从结点<span class="math inline">\(s\)</span>到结点<span class="math inline">\(v\)</span>的简单路径所对应的就是图<span class="math inline">\(G\)</span>中从结点<span class="math inline">\(s\)</span>到结点<span class="math inline">\(v\)</span>的“最短路径”，即包含最少边数的路径。该算法既可以用于有向图，也可以用于无向图。</p><p>广度优先搜索之所以如此得名是因为该算法始终是将已发现结点和未发现结点之间的边界，沿其广度方向向外扩展。也就是说，<strong>算法需要在发现所有距离源结点<span class="math inline">\(s\)</span>为<span class="math inline">\(k\)</span>的所有结点之后，才会发现距离源结点<span class="math inline">\(s\)</span>为<span class="math inline">\(k+1\)</span>的其他结点</strong>。</p><a id="more"></a><h1 id="算法">算法</h1><p>为了跟踪算法的进展，广度优先搜索在概念上将每个结点涂上白色、灰色或黑色。所有结点在一开始的时候涂上白色。在算法推进过程中，这些结点可能会变成灰色或黑色（灰色或黑色结点不会变回白色）。在搜索过程中，第一次遇到一个结点就称该结点被“<strong>发现</strong>”，此时该结点的颜色将发生改变。因此，凡是灰色和黑色的结点都是已被发现的结点。</p><p>如果边<span class="math inline">\((u,v)\in{E}\)</span>且结点<span class="math inline">\(u\)</span>是黑色，则结点<span class="math inline">\(v\)</span>既可能是灰色也可能是黑色。也就是说，所有与黑色结点邻接的结点都已经被发现。对于灰色结点来说，其邻接结点中可能存在未被发现的白色结点。灰色结点所代表的就是已知和未知两个集合之间的边界。</p><p>在执行广度优先搜索的过程中将构造出一棵广度优先树。一开始，该树仅含有根节点，就是源结点<span class="math inline">\(s\)</span>。在扫描已发现结点<span class="math inline">\(u\)</span>的邻接链表时，每当发现一个白色结点<span class="math inline">\(v\)</span>，就将结点<span class="math inline">\(v\)</span>和边<span class="math inline">\((u,v)\)</span>同时加入该棵树中。在广度优先树中，称结点<span class="math inline">\(u\)</span>是结点<span class="math inline">\(v\)</span>的<strong>前驱</strong>或者<strong>父结点</strong>。由于每个结点最多被发现一次，它最多只有一个父结点。广度优先树中的祖先和后代关系皆以相对于根节点<span class="math inline">\(s\)</span>的位置来定义：如果结点<span class="math inline">\(u\)</span>是从根节点<span class="math inline">\(s\)</span>到结点<span class="math inline">\(v\)</span>的简单路径上的一个结点，则结点<span class="math inline">\(u\)</span>是结点<span class="math inline">\(v\)</span>的祖先，结点<span class="math inline">\(v\)</span>是结点<span class="math inline">\(u\)</span>的后代。</p><p>在下面给出的 广度优先搜索过程<code>BFS</code>中，假定输入图<span class="math inline">\(G=(V,E)\)</span>是以邻接链表所表示的。该算法为图中每个结点赋予了一些额外的属性：</p><ul><li><span class="math inline">\(u.color\)</span>：每个结点<span class="math inline">\(u\)</span>的颜色。</li><li><span class="math inline">\(u.pi\)</span>：<span class="math inline">\(u\)</span>的前驱结点，如果<span class="math inline">\(u\)</span>没有前驱结点，则<span class="math inline">\(u.pi=NIL\)</span>。</li><li><span class="math inline">\(u.d\)</span>：<code>DFS</code>算法所计算出的从源结点<span class="math inline">\(s\)</span>到结点<span class="math inline">\(u\)</span>之间的距离。</li></ul><p>该算法使用一个先进先出的队列<span class="math inline">\(Q\)</span>来管理灰色结点集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">BFS(G, s):</span><br><span class="line">    <span class="keyword">for</span> each vertex u <span class="keyword">in</span> G.V-&#123;s&#125;:  <span class="comment"># 初始化</span></span><br><span class="line">        u.color = WHITE</span><br><span class="line">        u.d = infinity</span><br><span class="line">        u.pi = NIL</span><br><span class="line">    s.color = GRAY</span><br><span class="line">    s.d = <span class="number">0</span></span><br><span class="line">    s.pi = NIL</span><br><span class="line">    Q = &#123;&#125;</span><br><span class="line">    ENQUEUE(Q, s)</span><br><span class="line">    <span class="keyword">while</span> Q <span class="keyword">is</span> <span class="keyword">not</span> empty:</span><br><span class="line">        u = DEQUEUE(Q)</span><br><span class="line">        <span class="keyword">for</span> each v <span class="keyword">in</span> G.Adj[u]:</span><br><span class="line">            <span class="keyword">if</span> v.color == WHITE:</span><br><span class="line">                v.color = GRAY</span><br><span class="line">                v.d = u.d + <span class="number">1</span></span><br><span class="line">                v.pi = u</span><br><span class="line">                ENQUEUE(Q, v)</span><br><span class="line">        u.color = BLACK</span><br></pre></td></tr></table></figure><p>下图描述的是<code>BFS</code>在一个样本图上的推进过程。</p><p><img title="BFS在一个无向图上的推进过程" data-src="/uploads/posts/the-operation-of-BFS-on-an-undirected-graph.png"></p><h1 id="分析">分析</h1><p>每个结点的入队（当它是白色时）次数最多为一次，因而出队最多一次。入队和出队的时间均为<span class="math inline">\(O(1)\)</span>，因此，对队列进行操作的总时间为<span class="math inline">\(O(V)\)</span>。因为算法只在一个结点出队的时候才对该结点的邻接链表进行扫描，所以每个邻接链表最多只扫描一次。由于所有邻接链表的长度之和是<span class="math inline">\(\Theta(E)\)</span>，用于扫描邻接链表的总时间为<span class="math inline">\(O(E)\)</span>。初始化操作的成本是<span class="math inline">\(O(V)\)</span>，因此<strong>广度优先搜索的总运行时间为</strong><span class="math inline">\(O(V+E)\)</span>。因此，广度优先搜索的运行时间是图<span class="math inline">\(G\)</span>的邻接链表大小的一个线性函数。</p><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> networkx <span class="keyword">import</span> Graph</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_f</span><span class="params">(graph)</span>:</span></span><br><span class="line">    fmt = <span class="string">'&#123;0:&lt;10s&#125; &#123;1:&lt;10s&#125; &#123;2:&lt;10s&#125;\n'</span></span><br><span class="line">    title = fmt.format(<span class="string">'vertex'</span>, <span class="string">'distance'</span>, <span class="string">'previous'</span>)</span><br><span class="line">    data = <span class="string">''</span>.join(fmt.format(str(k), str(attr[<span class="string">'distance'</span>]), str(attr[<span class="string">'previous'</span>])) <span class="keyword">for</span> k, attr <span class="keyword">in</span> graph.nodes.items())</span><br><span class="line">    print(title + data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">breadth_first_search</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> attr <span class="keyword">in</span> graph.nodes.values():</span><br><span class="line">        attr[<span class="string">'visited'</span>], attr[<span class="string">'distance'</span>], attr[<span class="string">'previous'</span>] = <span class="literal">False</span>, float(<span class="string">'inf'</span>), <span class="literal">None</span></span><br><span class="line">    graph.nodes[s][<span class="string">'visited'</span>], graph.nodes[s][<span class="string">'distance'</span>], q = <span class="literal">True</span>, <span class="number">0</span>, Queue()</span><br><span class="line">    q.put(s)</span><br><span class="line">    <span class="keyword">while</span> q.empty() <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">        u = q.get()</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> graph[u].keys():</span><br><span class="line">            v_attr, u_attr = graph.nodes[v], graph.nodes[u]</span><br><span class="line">            <span class="keyword">if</span> v_attr[<span class="string">'visited'</span>] <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">                v_attr[<span class="string">'visited'</span>], v_attr[<span class="string">'distance'</span>], v_attr[<span class="string">'previous'</span>] = <span class="literal">True</span>, u_attr[<span class="string">'distance'</span>] + <span class="number">1</span>, u</span><br><span class="line">                q.put(v)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    g = Graph()</span><br><span class="line">    g.add_nodes_from(<span class="string">'rstuvwxy'</span>)</span><br><span class="line">    g.add_edges_from(</span><br><span class="line">        [(<span class="string">'r'</span>, <span class="string">'v'</span>), (<span class="string">'r'</span>, <span class="string">'s'</span>), (<span class="string">'s'</span>, <span class="string">'w'</span>), (<span class="string">'w'</span>, <span class="string">'t'</span>), (<span class="string">'w'</span>, <span class="string">'x'</span>), (<span class="string">'t'</span>, <span class="string">'x'</span>), (<span class="string">'t'</span>, <span class="string">'u'</span>), (<span class="string">'u'</span>, <span class="string">'x'</span>), (<span class="string">'u'</span>, <span class="string">'y'</span>),</span><br><span class="line">         (<span class="string">'x'</span>, <span class="string">'y'</span>)])</span><br><span class="line">    breadth_first_search(g, <span class="string">'s'</span>)</span><br><span class="line">    print_f(g)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vertex     distance   previous  </span><br><span class="line">r          1          s</span><br><span class="line">s          0          None</span><br><span class="line">t          2          w</span><br><span class="line">u          3          t</span><br><span class="line">v          2          r</span><br><span class="line">w          1          s</span><br><span class="line">x          2          w</span><br><span class="line">y          3          x</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithms </tag>
            
            <tag> Introduction To Algorithms </tag>
            
            <tag> queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的表示</title>
      <link href="/notes/introduction-to-algorithms/representations-of-graphs/"/>
      <url>/notes/introduction-to-algorithms/representations-of-graphs/</url>
      
        <content type="html"><![CDATA[<h1 id="图的表示">图的表示</h1><p>对于图<span class="math inline">\(G=(V,E)\)</span>，可以用两种标准表示方法表示。两种表示方法都既可以表示无向图，也可以表示有向图。</p><ul><li><p><strong>邻接链表表示</strong>：将图作为邻接链表的组合。</p><p>在表示<strong>稀疏图</strong>（边的条数<span class="math inline">\(|E|\)</span>远远小于<span class="math inline">\(|V|^2\)</span>的图）时非常紧凑而成为通常的选择。</p></li><li><p><strong>邻接矩阵表示</strong>：将图作为邻接矩阵来看待。</p><p>在<strong>稠密图</strong>（<span class="math inline">\(|E|\)</span>接近<span class="math inline">\(|V|^2\)</span>的图）的情况下，倾向于使用邻接矩阵表示法。另外，如果需要快速判断任意两个结点之间是否有边相连，可能也需要使用邻接矩阵表示法。</p></li></ul><a id="more"></a><p><img title="无向图的表示方法" data-src="/uploads/posts/two-representations-of-an-undirected-graph.png"></p><p><img title="有向图的表示方法" data-src="/uploads/posts/two-representations-of-a-directed-graph.png"></p><h1 id="邻接链表表示">邻接链表表示</h1><p>如上图(b)所示：对于图<span class="math inline">\(G=(V,E)\)</span>来说，其<strong>邻接链表表示</strong>由一个包含<span class="math inline">\(|V|\)</span>条链表的数组<span class="math inline">\(Adj\)</span>所构成，每个结点有一条链表。对于每个结点<span class="math inline">\(u\in{V}\)</span>，邻接链表<span class="math inline">\(Adj[u]\)</span>包含所有与结点<span class="math inline">\(u\)</span>之间有边相邻的结点<span class="math inline">\(v\)</span>，即<span class="math inline">\(Adj[u]\)</span>包含图<span class="math inline">\(G\)</span>中所有与<span class="math inline">\(u\)</span>邻接的结点（也可以说，该链表里包含指向这些结点的指针）。</p><p>如果<span class="math inline">\(G\)</span>是一个有向图，则对于边<span class="math inline">\((u,v)\)</span>来说，结点<span class="math inline">\(v\)</span>将出现在链表<span class="math inline">\(Adj[u]\)</span>里，因此，所有邻接链表的长度之和等于<span class="math inline">\(|E|\)</span>。如果<span class="math inline">\(G\)</span>是一个无向图，则对于边<span class="math inline">\((u,v)\)</span>来说，结点<span class="math inline">\(v\)</span>将出现在链表<span class="math inline">\(Adj[u]\)</span>里，结点<span class="math inline">\(u\)</span>将出现在链表<span class="math inline">\(Adj[v]\)</span>里，因此，所有邻接链表的长度之和为<span class="math inline">\(2|E|\)</span>。但不管是有向图还是无向图，邻接链表表示法的存储空间需求均为<span class="math inline">\(\Theta(V+E)\)</span>。</p><p>对邻接链表稍加修改，即可以用来表示<strong>权重图</strong>，权重图是图中的每条边都带有一个相关的权重的图。可以直接将边<span class="math inline">\((u,v)\in{E}\)</span>的权重值<span class="math inline">\(w(u,v)\)</span>存放在结点<span class="math inline">\(u\)</span>的邻接链表里。从这种意义上说，邻接链表表示法的鲁棒性很高，可以通过对其进行简单修改来支持许多其他的图变种。</p><p>邻接链表的一个潜在缺陷是无法快速判断一条边<span class="math inline">\((u,v)\)</span>是否是图中的一条边，唯一的办法是在邻接链表<span class="math inline">\(Adj[u]\)</span>里面搜索结点<span class="math inline">\(v\)</span>。邻接矩阵表示则克服了这个缺陷，但付出的代价是更大的存储空间消耗。</p><h1 id="邻接矩阵表示">邻接矩阵表示</h1><p>对于<strong>邻接矩阵表示</strong>来说，通常会将图<span class="math inline">\(G\)</span>中的结点编为<span class="math inline">\(1,2,\dots,|V|\)</span>，这种编号可以是任意的。在进行此种编号之后，图<span class="math inline">\(G\)</span>的邻接矩阵表示由一个<span class="math inline">\(|V|\times|V|\)</span>的矩阵<span class="math inline">\(A=(a_{ij})\)</span>予以表示，该矩阵满足下述条件： <span class="math display">\[a_{ij}=\begin{cases}1\quad\text{if }(i,j)\in{E}\\0\quad\text{otherwise}\end{cases}\]</span> 图(c)给出的是图(a)的邻接矩阵表示。不管一个图中由多少条边，邻接矩阵的空间需求皆为<span class="math inline">\(\Theta(V^2)\)</span>。</p><p>无向图的邻接矩阵是一个对称矩阵。由于在无向图中，边<span class="math inline">\((u,v)\)</span>和边<span class="math inline">\((v,u)\)</span>是同一条边，无向图的邻接矩阵<span class="math inline">\(A\)</span>就是自己的转置，即<span class="math inline">\(A=A^T\)</span>。在某些应用中，可能只需要存放对角线及其以上的这部分邻接矩阵（即半个矩阵），从而将图存储空间需要减少几乎一半。</p><p>与邻接链表表示法一样，邻接矩阵也可以用来表示权重图。例如，如果<span class="math inline">\(G=(V,E)\)</span>为一个权重图，则直接将边<span class="math inline">\((u,v)\in{E}\)</span>的权重<span class="math inline">\(w(u,v)\)</span>存放在邻接矩阵中的第<span class="math inline">\(u\)</span>行第<span class="math inline">\(v\)</span>列记录上。对于不存在的边，则在相应的行列记录上存放值<span class="math inline">\(NIL\)</span>。不过，对于许多问题来说，用0或<span class="math inline">\(\infty\)</span>来表示一条不存在的边可能更为便捷。</p><p>邻接矩阵表示法更为简单，因此在图规模比较小时，可能更倾向于使用邻接矩阵表示法。</p><p>而且，对于无向图来说，邻接矩阵还有一个优势：每个纪录项只需要1位空间。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graph </tag>
            
            <tag> Introduction To Algorithms </tag>
            
            <tag> adjacent list </tag>
            
            <tag> adjacent matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小费用流问题</title>
      <link href="/notes/minimum-cost-flow-problems/"/>
      <url>/notes/minimum-cost-flow-problems/</url>
      
        <content type="html"><![CDATA[<h1 id="最小费用流问题">最小费用流问题</h1><p>最小费用流问题（MCFP）试图在一个流网络中寻找发送指定流量的最便宜的可行方案。一个典型的应用是寻找工厂到仓库之间的最佳配送路径，每段路线都有相应的容量和费用。</p><p><strong>定义</strong></p><p>有向图<span class="math inline">\(G=(V,E)\)</span>定义的流网络中，源结点为<span class="math inline">\(s\in{V}\)</span>，汇点为<span class="math inline">\(t\)</span>，每条边<span class="math inline">\((u,v)\in{E}\)</span>有容量<span class="math inline">\(c(u,v)&gt;0\)</span>，流<span class="math inline">\(f(u,v)\ge0\)</span>和代价<span class="math inline">\(a(u,v)\)</span>（代价可以为负）。沿某条边<span class="math inline">\((u,v)\)</span>发送流量的代价为<span class="math inline">\(f(u,v)*a(u,v)\)</span>。问题要求从源结点<span class="math inline">\(s\)</span>发送指定大小的流量<span class="math inline">\(d\)</span>到汇点<span class="math inline">\(t\)</span>。最小费用流问题试图最小化所有边的总代价：<span class="math inline">\(\sum_{(u,v)\in{E}}a(u,v)*f(u,v)\)</span></p><p>满足以下约束条件：</p><ul><li>容量限制：对于所有的结点<span class="math inline">\(u,v\in{V}\)</span>，要求<span class="math inline">\(0\le{f(u,v)}\le{c(u,v)}\)</span>。</li><li>流量守恒：对于所有的结点<span class="math inline">\(u\in{V-\lbrace{s,t}\rbrace}\)</span>，要求<span class="math inline">\(\sum_{v\in{V}}f(v,u)=\sum_{v\in{V}}f(u，v)\)</span>。</li><li>流量要求：<span class="math inline">\(\sum_{v\in{V}}f(s,v)=d\quad\text{and}\quad\sum_{v\in{V}}f(v,t)=d\)</span>。</li></ul><a id="more"></a><h1 id="负权环路消除法">负权环路消除法</h1><p>负权环路是指有向图<span class="math inline">\(G=(V,E)\)</span>中的环路且构成环路的所有边的权重之和为负数值。</p><h2 id="残存网络">残存网络</h2><p>假定由一个流网络<span class="math inline">\(G=(V,E)\)</span>，其源结点为<span class="math inline">\(s\)</span>，汇点为<span class="math inline">\(t\)</span>。设<span class="math inline">\(f\)</span>为图<span class="math inline">\(G\)</span>中的一个流，考虑结点对<span class="math inline">\(u,v\in{V}\)</span>，定义残存容量<span class="math inline">\(c_f(u,v)\)</span>如下： <span class="math display">\[c_f(u,v)=\begin{cases}c(u,v)-f(u,v)&amp;\text{if }(u,v)\in{E}\\f(v,u)&amp;\text{if }(v,u)\in{E}\\0&amp;otherwise\end{cases}\]</span> 定义残存网络代价<span class="math inline">\(a_f(u,v)\)</span>如下： <span class="math display">\[a_f(u,v)=\begin{cases}a(u,v)&amp;\text{if }(u,v)\in{E}\\-a(u,v)&amp;\text{if }(v,u)\in{E}\\0&amp;otherwise\end{cases}\]</span> 负权环路消除法的核心思想是在残存网络中寻找从源结点<span class="math inline">\(s\)</span>可达的负权环路，然后沿环路发送流量。直到残存网路中不存在从源结点<span class="math inline">\(s\)</span>可达的负权环路为止。算法的步骤如下：</p><ol type="1"><li>设<span class="math inline">\(G=(V,E)\)</span>为一个流网络，求出值为<span class="math inline">\(d\)</span>的一个流。通过修改最大流的Ford-Fulkerson算法，可以求出值为<span class="math inline">\(d\)</span>的一个流。</li><li>在残存网络中寻找从源结点<span class="math inline">\(s\)</span>可达的负权环路。单源最短路径算法的Bellman-Ford算法可以检测图<span class="math inline">\(G=(V,E)\)</span>中是否含有负权环路，通过修改Bellman-Ford算法可以求出该环路。</li><li>若存在，沿环路发送流量，返回步骤2。若不存在，则当前网络中的流为最佳方案。</li></ol><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> graph.max_flow <span class="keyword">import</span> find_path</span><br><span class="line"><span class="keyword">from</span> graph.bellman_ford <span class="keyword">import</span> initialize_single_source, relax</span><br><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_f</span><span class="params">(graph)</span>:</span></span><br><span class="line">    print(<span class="string">'min cost:'</span>, graph.graph[<span class="string">'min_cost'</span>])</span><br><span class="line">    fmt = <span class="string">'&#123;0:&lt;4s&#125; &#123;1:&lt;4s&#125; &#123;2:&lt;4s&#125; &#123;3:&lt;4s&#125; &#123;4:&lt;8s&#125;\n'</span></span><br><span class="line">    title = fmt.format(<span class="string">'u'</span>, <span class="string">'v'</span>, <span class="string">'flow'</span>, <span class="string">'cost'</span>, <span class="string">'capacity'</span>)</span><br><span class="line">    data = <span class="string">''</span>.join(</span><br><span class="line">        fmt.format(str(u), str(v), str(attr[<span class="string">'flow'</span>]), str(attr[<span class="string">'cost'</span>]), str(attr[<span class="string">'capacity'</span>]))</span><br><span class="line">        <span class="keyword">for</span> u, v, attr <span class="keyword">in</span> graph.edges(data=<span class="literal">True</span>) <span class="keyword">if</span> attr[<span class="string">'flow'</span>] &gt; <span class="number">0</span>)</span><br><span class="line">    print(title + data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flow</span><span class="params">(graph, s, t, f)</span>:</span></span><br><span class="line">    <span class="string">"""求出任意一个值为f的流"""</span></span><br><span class="line">    p = find_path(graph, s, t, set())</span><br><span class="line">    <span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        residual = [graph[u][v][<span class="string">'capacity'</span>] - graph[u][v][<span class="string">'flow'</span>] <span class="keyword">for</span> u, v <span class="keyword">in</span> p]</span><br><span class="line">        augment_flow = min(min(residual), f)</span><br><span class="line">        <span class="keyword">for</span> u, v <span class="keyword">in</span> p:</span><br><span class="line">            graph[u][v][<span class="string">'flow'</span>] += augment_flow</span><br><span class="line">            graph[v][u][<span class="string">'flow'</span>] -= augment_flow</span><br><span class="line">        f -= augment_flow</span><br><span class="line">        <span class="keyword">if</span> f == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        p = find_path(graph, s, t, set())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bellman_ford</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    initialize_single_source(graph, s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(graph.number_of_nodes() - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> u, v, e_attr <span class="keyword">in</span> graph.edges(data=<span class="literal">True</span>):</span><br><span class="line">            <span class="keyword">if</span> e_attr[<span class="string">'capacity'</span>] - e_attr[<span class="string">'flow'</span>] &gt; <span class="number">0</span>:  <span class="comment"># 只有此值大于0的边存在于残存网络中</span></span><br><span class="line">                relax(graph, u, v, e_attr[<span class="string">'cost'</span>])</span><br><span class="line">    <span class="keyword">for</span> u, v, e_attr <span class="keyword">in</span> graph.edges(data=<span class="literal">True</span>):</span><br><span class="line">        residual = e_attr[<span class="string">'capacity'</span>] - e_attr[<span class="string">'flow'</span>]</span><br><span class="line">        <span class="keyword">if</span> residual &gt; <span class="number">0</span> <span class="keyword">and</span> graph.nodes[v][<span class="string">'distance'</span>] &gt; graph.nodes[u][<span class="string">'distance'</span>] + e_attr[<span class="string">'cost'</span>]:</span><br><span class="line">            <span class="comment"># 当存在负权环路时，返回从环路可达的一个结点</span></span><br><span class="line">            <span class="keyword">return</span> u</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_negative_cycle</span><span class="params">(graph, v, cycle)</span>:</span></span><br><span class="line">    <span class="string">"""根据previous属性找出环路"""</span></span><br><span class="line">    <span class="comment"># 先找到环路中任一结点</span></span><br><span class="line">    visit = &#123;v&#125;</span><br><span class="line">    pre = graph.nodes[v][<span class="string">'previous'</span>]  <span class="comment"># 前驱结点</span></span><br><span class="line">    <span class="keyword">while</span> pre <span class="keyword">not</span> <span class="keyword">in</span> visit:</span><br><span class="line">        visit.add(pre)</span><br><span class="line">        pre = graph.nodes[pre][<span class="string">'previous'</span>]</span><br><span class="line">    <span class="comment"># 通过previous找出环路</span></span><br><span class="line">    anchor = pre</span><br><span class="line">    end, start = pre, graph.nodes[pre][<span class="string">'previous'</span>]</span><br><span class="line">    <span class="keyword">while</span> start != anchor:</span><br><span class="line">        cycle.append((start, end))</span><br><span class="line">        end = start</span><br><span class="line">        start = graph.nodes[start][<span class="string">'previous'</span>]</span><br><span class="line">    cycle.append((start, end))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">negative_cycle_canceling</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    key = bellman_ford(graph, s)  <span class="comment"># bellman ford求最短路径的方式寻找环路</span></span><br><span class="line">    <span class="keyword">while</span> key <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        cycle = []</span><br><span class="line">        get_negative_cycle(graph, key, cycle)</span><br><span class="line">        cancel_flow = min(graph[u][v][<span class="string">'capacity'</span>] - graph[u][v][<span class="string">'flow'</span>] <span class="keyword">for</span> u, v <span class="keyword">in</span> cycle)  <span class="comment"># 修改环路上的流量</span></span><br><span class="line">        <span class="keyword">for</span> u, v <span class="keyword">in</span> cycle:</span><br><span class="line">            graph[u][v][<span class="string">'flow'</span>] += cancel_flow</span><br><span class="line">            graph[v][u][<span class="string">'flow'</span>] -= cancel_flow</span><br><span class="line">        key = bellman_ford(graph, s)  <span class="comment"># 重新寻找环路</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min_cost</span><span class="params">(graph, s, t, d)</span>:</span></span><br><span class="line">    <span class="string">"""求解流量值为d的最小费用流"""</span></span><br><span class="line">    flow(graph, s, t, d)  <span class="comment"># 先找到一个可行解，当d大于最大流量时，找到的可行解是最大流量</span></span><br><span class="line">    negative_cycle_canceling(graph, s)  <span class="comment"># 移除负权环路</span></span><br><span class="line">    graph.graph[<span class="string">'min_cost'</span>] = sum(attr[<span class="string">'flow'</span>] * attr[<span class="string">'cost'</span>] <span class="keyword">for</span> attr <span class="keyword">in</span> graph.edges.values() <span class="keyword">if</span> attr[<span class="string">'flow'</span>] &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_graph</span><span class="params">(graph, vertices, edges)</span>:</span></span><br><span class="line">    graph.add_nodes_from(vertices)</span><br><span class="line">    <span class="keyword">for</span> u, v, cap, cost <span class="keyword">in</span> edges:</span><br><span class="line">        graph.add_edges_from([(u, v, &#123;<span class="string">'capacity'</span>: cap, <span class="string">'cost'</span>: cost&#125;), (v, u, &#123;<span class="string">'capacity'</span>: <span class="number">0</span>, <span class="string">'cost'</span>: -cost&#125;)], flow=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    g = nx.DiGraph()</span><br><span class="line">    v = <span class="string">'s1234t'</span></span><br><span class="line">    e = [(<span class="string">'s'</span>, <span class="string">'1'</span>, <span class="number">10</span>, <span class="number">2</span>), (<span class="string">'s'</span>, <span class="string">'3'</span>, <span class="number">35</span>, <span class="number">4</span>), (<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="number">20</span>, <span class="number">6</span>), (<span class="string">'1'</span>, <span class="string">'3'</span>, <span class="number">10</span>, <span class="number">1</span>), (<span class="string">'2'</span>, <span class="string">'t'</span>, <span class="number">35</span>, <span class="number">2</span>),</span><br><span class="line">         (<span class="string">'3'</span>, <span class="string">'2'</span>, <span class="number">5</span>, <span class="number">6</span>), (<span class="string">'3'</span>, <span class="string">'4'</span>, <span class="number">30</span>, <span class="number">2</span>), (<span class="string">'4'</span>, <span class="string">'2'</span>, <span class="number">15</span>, <span class="number">2</span>), (<span class="string">'4'</span>, <span class="string">'t'</span>, <span class="number">10</span>, <span class="number">7</span>)]</span><br><span class="line">    initialize_graph(g, v, e)</span><br><span class="line">    min_cost(g, <span class="string">'s'</span>, <span class="string">'t'</span>, <span class="number">20</span>)</span><br><span class="line">    print_f(g)</span><br><span class="line"></span><br><span class="line">    g.clear()</span><br><span class="line">    e = [(<span class="string">'s'</span>, <span class="string">'1'</span>, <span class="number">16</span>, <span class="number">3</span>), (<span class="string">'s'</span>, <span class="string">'2'</span>, <span class="number">13</span>, <span class="number">4</span>), (<span class="string">'1'</span>, <span class="string">'3'</span>, <span class="number">12</span>, <span class="number">7</span>), (<span class="string">'2'</span>, <span class="string">'1'</span>, <span class="number">4</span>, <span class="number">3</span>), (<span class="string">'2'</span>, <span class="string">'4'</span>, <span class="number">14</span>, <span class="number">6</span>),</span><br><span class="line">         (<span class="string">'3'</span>, <span class="string">'2'</span>, <span class="number">9</span>, <span class="number">5</span>), (<span class="string">'3'</span>, <span class="string">'t'</span>, <span class="number">20</span>, <span class="number">6</span>), (<span class="string">'4'</span>, <span class="string">'3'</span>, <span class="number">7</span>, <span class="number">8</span>), (<span class="string">'4'</span>, <span class="string">'t'</span>, <span class="number">4</span>, <span class="number">9</span>)]</span><br><span class="line">    initialize_graph(g, v, e)</span><br><span class="line">    min_cost(g, <span class="string">'s'</span>, <span class="string">'t'</span>, <span class="number">19</span>)</span><br><span class="line">    print_f(g)</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">min cost: 195</span><br><span class="line">u    v    flow cost capacity</span><br><span class="line">s    1    10   2    10</span><br><span class="line">s    3    10   4    35</span><br><span class="line">1    2    5    6    20</span><br><span class="line">1    3    5    1    10</span><br><span class="line">2    t    20   2    35</span><br><span class="line">3    4    15   2    30</span><br><span class="line">4    2    15   2    15</span><br><span class="line"></span><br><span class="line">min cost: 340</span><br><span class="line">u    v    flow cost capacity</span><br><span class="line">s    1    12   3    16</span><br><span class="line">s    2    7    4    13</span><br><span class="line">1    3    12   7    12</span><br><span class="line">2    4    7    6    14</span><br><span class="line">3    t    15   6    20</span><br><span class="line">4    3    3    8    7</span><br><span class="line">4    t    4    9    4</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithms </tag>
            
            <tag> flow network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大子数组问题</title>
      <link href="/notes/introduction-to-algorithms/maximum-subarray-problems/"/>
      <url>/notes/introduction-to-algorithms/maximum-subarray-problems/</url>
      
        <content type="html"><![CDATA[<h1 id="最大化收益">最大化收益</h1><p>假设你知道了未来17天某公司的股票价格，你的目标是最大化收益。</p><ul><li>你可能认为可以“低价买进，高价卖出”——在最低价格时买进股票，之后在最高价格时卖出，这样可以最大化收益。但遗憾的是，在一段时间内，可能无法做到在最低价格时买进股票，然后在最高价格时卖出。例如，下图中，最低价在后，最高价在前。</li></ul><a id="more"></a><p><img title="未来17天股票价格" data-src="/uploads/posts/maximum-subarray-problem-price-of-stock.png"></p><ul><li>你还可能认为可以在最低价格时买进，或在最高价格时卖出，即可最大化收益。如果这种策略总是有效的，则确定最大化收益是非常简单的：寻找最高和最低价格，然后从最高价格开始向左寻找之前的最低价格；从最低价格开始向右寻找之后的最高价格；取两对价格中差值最大者。例如上图中，在第7天股票价格最低时买入，即可最大化收益。但下图给出了一个简单的反例，显示有时最大收益既不是在最低价格时买进，也不是在最高价格时卖出。</li></ul><p><img title="一个反例：最大收益既不是在最低价格时买进，也不是在最高价格时卖出" data-src="/uploads/posts/maximum-flow-problem-a-counter-example.png"></p><p>暴力求解方法：</p><p>尝试每对可能的买进和卖出日期组合，只要卖出日期在买进日期之后即可。<span class="math inline">\(n\)</span>天中共有<span class="math inline">\(\begin{pmatrix}n\\2\end{pmatrix}=\Theta(n^2)\)</span>种日期组合。处理每对日期所花费的时间至少也是常量，因次这种方法的运行时间为<span class="math inline">\(\Omega(n^2)\)</span>。</p><h1 id="最大子数组问题">最大子数组问题</h1><p>从一个稍微不同的角度来看待输入数据。我们的目的是寻找一段日期，使得从第一天到最后一天的股票价格净变值最大。因此，我们不再从每日价格的角度来看待输入数据，而是考察每日价格变化，第<span class="math inline">\(i\)</span>天的价格变化定义为第<span class="math inline">\(i\)</span>天和第<span class="math inline">\(i-1\)</span>天的价格差。第一幅图的最后一行给出了每日价格变化。如果将这一行看作一个数组<span class="math inline">\(A\)</span>，那么问题就转化为寻找<span class="math inline">\(A\)</span>的<strong>和最大的非空连续子数组</strong>。这样的连续子数组为<strong>最大子数组</strong>（maximum subarray）。例如，对第一幅图中的数组，<span class="math inline">\(A[1..16]\)</span>的最大子数组为<span class="math inline">\(A[8..11]\)</span>，其和为43。因此，可以在第8天开始前（第7天结束后）买入股票，并在第11天结束后卖出，获得每股收益43。</p><p><img title="最大子数组" data-src="/uploads/posts/maximum-subarray.png"></p><p>乍一看，这种变换对问题求解并没有什么帮助。对于一段<span class="math inline">\(n\)</span>天的日期，仍需要检查<span class="math inline">\(\begin{pmatrix}n-1\\2\end{pmatrix}=\Theta(n^2)\)</span>个子数组。计算一个子数组之和所需的时间是线性的，但当计算所有<span class="math inline">\(\Theta(n^2)\)</span>个子数组和时，可以重新组织计算方式，利用之前计算出的子数组和来计算当前子数组的和，使得每个子数组和的计算时间为<span class="math inline">\(O(1)\)</span>，从而暴力求解方法所花费的时间仍为<span class="math inline">\(\Theta(n^2)\)</span>。</p><p>接下来，寻找最大子数组问题的更高效的求解方法。在此过程中，我们通常说“一个最大子数组”而不是“最大子数组”，因为可能有多个子数组达到最大和。</p><p>只有当数组中包含负数时，最大子数组问题才有意义。如果所有数组元素都是非负的，最大子数组问题没有任何难度，因为整个数组的和肯定是最大的。</p><h1 id="使用分治策略的算法">使用分治策略的算法</h1><p>假定要寻找子数组<span class="math inline">\(A[low..high]\)</span>的最大子数组。使用分治技术意味着要将子数组划分成两个规模尽量相等的子数组。也就是说，找到子数组的中央位置，比如<span class="math inline">\(mid\)</span>，然后考虑求解两个子数组<span class="math inline">\(A[low..mid]\)</span>和<span class="math inline">\(A[mid+1..high]\)</span>。如下图(a)所示，<span class="math inline">\(A[low..high]\)</span>的任何连续子数组<span class="math inline">\(A[i..j]\)</span>所处的位置必然是以下三种情况之一：</p><ul><li>完全位于子数组<span class="math inline">\(A[low..mid]\)</span>中，因此<span class="math inline">\(low\le{i}\le{j}\le{mid}\)</span>。</li><li>完全位于子数组<span class="math inline">\(A[mid+1..high]\)</span>中，因此<span class="math inline">\(mid&lt;i\le{j}\le{high}\)</span>。</li><li>跨越了中点，因此<span class="math inline">\(low\le{i}\le{mid}&lt;j\le{high}\)</span>。</li></ul><p><img title="最大子数组所处的三种位置" data-src="/uploads/posts/maximum-flow-problem-possible-locations.png"></p><p>我们可以递归地求解<span class="math inline">\(A[low..mid]\)</span>和<span class="math inline">\(A[mid+1..high]\)</span>的最大子数组，因为这两个子问题仍是最大子数组问题，只是规模更小。因此，剩下的全部工作就是寻找跨越中点的最大子数组，然后在三种情况中选取和最大者。</p><p>求出跨越中点的最大子树组并非原问题规模更小的实例，因为它加入了限制——求出的子数组必须跨越中点。如上图(b)所示，任何跨越中点的子数组都有两个子数组<span class="math inline">\(A[i..mid]\)</span>和<span class="math inline">\(A[mid+1..j]\)</span>组成。因此，只需找出形如<span class="math inline">\(A[i..mid]\)</span>和<span class="math inline">\(A[mid+1..j]\)</span>的最大子数组，然后将其合并即可。过程<code>FIND-MAX-CROSSING-SUBARRAY</code>接收数组<span class="math inline">\(A\)</span>和下标<span class="math inline">\(low、mid\)</span>和<span class="math inline">\(high\)</span>为输入，返回一个下标元组划定跨越中点的最大子数组的边界，并返回最大子数组值的和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high):  <span class="comment"># 设 high-low+1 = n</span></span><br><span class="line">    left-sum = -infinty</span><br><span class="line">    sum = <span class="number">0</span>                   <span class="comment"># 求出左半部的最大子数组</span></span><br><span class="line">    <span class="keyword">for</span> i = mid downto low:   <span class="comment"># 循环 mid-low+1 次</span></span><br><span class="line">        sum = sum + A[i]      <span class="comment"># 循环体花费常数时间</span></span><br><span class="line">        <span class="keyword">if</span> sum &gt; left-sum：</span><br><span class="line">            left-sum = sum</span><br><span class="line">            max-left = i</span><br><span class="line">    right-sum = -infinty</span><br><span class="line">    sum = <span class="number">0</span>                   <span class="comment"># 求出右半部的最大子数组</span></span><br><span class="line">    <span class="keyword">for</span> j = mid + <span class="number">1</span> to high:  <span class="comment"># 循环 high-(mid+1)+1=high-mid 次</span></span><br><span class="line">        sum = sum + A[j]      <span class="comment"># 循环体花费常数时间</span></span><br><span class="line">        <span class="keyword">if</span> sum &gt; right-sum:</span><br><span class="line">            right-sum = sum</span><br><span class="line">            max-right = j</span><br><span class="line">    <span class="keyword">return</span> (max-left, max-right, left-sum + right-sum)</span><br></pre></td></tr></table></figure><p>如果子数组<span class="math inline">\(A[low..high]\)</span>包含<span class="math inline">\(n\)</span>个元素，则两个<code>for</code>循环的总迭代次数为<span class="math inline">\(high-mid+mid-low+1=high-low+1=n\)</span>次，每次迭代花费<span class="math inline">\(\Theta(1)\)</span>时间，因此调用<code>FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)</code>花费<span class="math inline">\(\Theta(n)\)</span>时间。</p><p>求解最大子数组问题的分治算法的伪代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FIND-MAXIMUM-SUBARRAY(A, low, high):</span><br><span class="line">    <span class="keyword">if</span> high == low:  <span class="comment"># 只有一个元素的情况，花费常量时间</span></span><br><span class="line">        <span class="keyword">return</span> (low, high, A[low])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mid = math.floor((low+high)/<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 分解成子问题</span></span><br><span class="line">        (left-low, left-high, left-sum)    = FIND-MAXIMUM-SUBARRAY(A, low, mid)  <span class="comment"># 递归</span></span><br><span class="line">        (right-low, right-high, right-sum) = FIND-MAXIMUM-SUBARRAY(A, mid+<span class="number">1</span>, high)</span><br><span class="line">        (cross-low, cross-high, cross-sum) = FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)  <span class="comment"># 对第三种情况单独求解</span></span><br><span class="line">        <span class="comment"># 合并：三种结果中最大的子数组为原问题的解</span></span><br><span class="line">        <span class="keyword">if</span> left-sum &gt;= right-sum <span class="keyword">and</span> left-sum &gt;= cross-sum:</span><br><span class="line">            <span class="keyword">return</span> (left-low, left-high, left-sum)</span><br><span class="line">        <span class="keyword">elif</span> right-sum &gt;= left-sum <span class="keyword">and</span> right-sum &gt;= cross-sum:</span><br><span class="line">            <span class="keyword">return</span> (right-low, right-high, right-sum)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (cross-low, cross-high, cross-sum)</span><br></pre></td></tr></table></figure><p>初始调用 <code>FIND-MAXIMUM-SUBARRAY(A, 0, A.lenght-1)</code>即可求出<span class="math inline">\(A[0..n-1]\)</span>的最大子数组。</p><h2 id="分析">分析</h2><p>建立一个递归式来描述递归过程<code>FIND-MAXIMUM-SUBARRAY</code>的运行时间。对问题进行简化，假设原问题的规模为2的幂，这样所有子问题的规模均为整数。采用<span class="math inline">\(T(n)\)</span>表示<code>FIND-MAXIMUM-SUBARRAY</code>求解<span class="math inline">\(n\)</span>个元素的最大子数组的运行时间。</p><p>对于<span class="math inline">\(n=1\)</span>的基本情况，花费常量时间，因此<span class="math inline">\(T(1)=\Theta(1)\)</span>。</p><p>当<span class="math inline">\(n&gt;1\)</span>时为递归情况。到达递归调用前花费<span class="math inline">\(\Theta(1)\)</span>时间。递归求解的子问题均为<span class="math inline">\(n/2\)</span>个元素的子数组（假定原问题规模为2的幂，保证了<span class="math inline">\(n/2\)</span>为整数），因此每个子问题求解时间为<span class="math inline">\(T(n/2)\)</span>。调用<code>FIND-MAX-CROSSING-SUBARRAY</code>花费<span class="math inline">\(\Theta(n)\)</span>时间。合并过程花费<span class="math inline">\(\Theta(1)\)</span>时间。因此，对于递归情况，有<span class="math inline">\(T(n)=\Theta(1)+2T(n/2)+\Theta(n)+\Theta(1)=2T(n/2)+\Theta(n)\)</span>。</p><p>结合两式，得到<code>FIND-MAXIMUM-SUBARRAY</code>运行时间<span class="math inline">\(T(n)\)</span>的递归式： <span class="math display">\[T(n)=\begin{cases}\Theta(1)&amp;\text{if }n=1\\2T(n/2)+Theta(n)&amp;\text{if }n&gt;1\end{cases}\]</span> 此递归式与归并排序的递归式一样，其解为<span class="math inline">\(T(n)=\Theta(n\lg{n})\)</span>。利用分治策略的求解方法渐进复杂性优于暴力求解方法。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_max_crossing_subarray</span><span class="params">(a, low, mid, high)</span>:</span></span><br><span class="line">    left_sum = right_sum = float(<span class="string">'-inf'</span>)</span><br><span class="line">    max_left = max_right = t = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(low, mid + <span class="number">1</span>)):</span><br><span class="line">        t += a[i]</span><br><span class="line">        <span class="keyword">if</span> t &gt; left_sum:</span><br><span class="line">            left_sum, max_left = t, i</span><br><span class="line">    t = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(mid + <span class="number">1</span>, high + <span class="number">1</span>):</span><br><span class="line">        t += a[i]</span><br><span class="line">        <span class="keyword">if</span> t &gt; right_sum:</span><br><span class="line">            right_sum, max_right = t, i</span><br><span class="line">    <span class="keyword">return</span> max_left, max_right, left_sum + right_sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_maximum_subarray_dac</span><span class="params">(a, low, high)</span>:</span></span><br><span class="line">    <span class="string">"""divide and conquer"""</span></span><br><span class="line">    <span class="keyword">if</span> high == low:</span><br><span class="line">        <span class="keyword">return</span> low, high, a[low]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mid = (low + high) // <span class="number">2</span></span><br><span class="line">        left_low, left_high, left_sum = find_maximum_subarray_dac(a, low, mid)</span><br><span class="line">        right_low, right_high, right_sum = find_maximum_subarray_dac(a, low + <span class="number">1</span>, high)</span><br><span class="line">        cross_low, cross_high, cross_sum = find_max_crossing_subarray(a, low, mid, high)</span><br><span class="line">        <span class="keyword">if</span> left_sum &gt;= right_sum <span class="keyword">and</span> left_sum &gt;= cross_sum:</span><br><span class="line">            <span class="keyword">return</span> left_low, left_high, left_sum</span><br><span class="line">        <span class="keyword">elif</span> right_sum &gt;= left_sum <span class="keyword">and</span> right_sum &gt;= cross_sum:</span><br><span class="line">            <span class="keyword">return</span> right_low, right_high, right_sum</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> cross_low, cross_high, cross_sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">13</span>, <span class="number">-3</span>, <span class="number">-25</span>, <span class="number">20</span>, <span class="number">-3</span>, <span class="number">-16</span>, <span class="number">-23</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">-7</span>, <span class="number">12</span>, <span class="number">-5</span>, <span class="number">-22</span>, <span class="number">15</span>, <span class="number">-4</span>, <span class="number">7</span>]</span><br><span class="line">    print(find_maximum_subarray_dac(arr, <span class="number">0</span>, len(arr) - <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(7, 10, 43)</span><br></pre></td></tr></table></figure><h1 id="使用动态规划的算法">使用动态规划的算法</h1><p>从数组的左边界开始，从左至右处理，记录到目前为止已经处理过的最大子数组。定义数组<span class="math inline">\(dp\)</span>，其中<span class="math inline">\(dp[j]\)</span>代表数组<span class="math inline">\(A[0..j]\)</span>中以<span class="math inline">\(A[j]\)</span>结尾的最大子数组，则 <span class="math display">\[dp[j]=\begin{cases}A[j]&amp;j=0\\max(dp[j-1],0)+A[j]&amp;j=1\dots{n-1}\end{cases}\]</span></p><ul><li><p><span class="math inline">\(j=0\)</span>时，以<span class="math inline">\(A[j]\)</span>结尾的最大子数组就是其本身。</p></li><li><span class="math inline">\(j&gt;0\)</span>时，以<span class="math inline">\(A[j]\)</span>结尾的最大子数组可分为两种情况：<ul><li><p>最大子数组是<span class="math inline">\(A[i..j](0\le{i}&lt;j)\)</span>，此时<span class="math inline">\(dp[j]=dp[j-1]+A[j]\)</span></p></li><li><p>最大子数组是<span class="math inline">\(A[j](i=j)\)</span>，此时<span class="math inline">\(dp[j]=0+A[j]\)</span>。</p><p>比较二者间较大的值，作为以<span class="math inline">\(A[j]\)</span>结尾的最大子数组。</p></li></ul></li></ul><h2 id="代码-1">代码</h2><p>计算<span class="math inline">\(dp\)</span>的过程如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kadanes</span><span class="params">(a)</span>:</span></span><br><span class="line">    dp = [<span class="number">0</span>] * len(a)</span><br><span class="line">    dp[<span class="number">0</span>] = a[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(a)):</span><br><span class="line">        dp[i] = max(dp[i - <span class="number">1</span>], <span class="number">0</span>) + a[i]</span><br><span class="line">    <span class="keyword">return</span> dp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">13</span>, <span class="number">-3</span>, <span class="number">-25</span>, <span class="number">20</span>, <span class="number">-3</span>, <span class="number">-16</span>, <span class="number">-23</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">-7</span>, <span class="number">12</span>, <span class="number">-5</span>, <span class="number">-22</span>, <span class="number">15</span>, <span class="number">-4</span>, <span class="number">7</span>]</span><br><span class="line">    print(max(kadanes(arr)))  <span class="comment"># 最大的值就是整个数组中的最大子数组</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">43</span><br></pre></td></tr></table></figure><h2 id="分析-1">分析</h2><p>对一个输入规模为<span class="math inline">\(n\)</span>的数组，<code>for</code>循环的迭代次数为<span class="math inline">\(n\)</span>，每次迭代花费<span class="math inline">\(\Theta(1)\)</span>时间。因此，算法的总代价为<span class="math inline">\(n*\Theta(1)=\Theta(n)\)</span>。</p><p>算法使用了一个长度为<span class="math inline">\(n\)</span>的辅助数组，因此空间复杂度为<span class="math inline">\(\Theta(n)\)</span>。</p><h2 id="降低空间复杂度">降低空间复杂度</h2><p>若只需要整个数组的最大子数组，那么可以用一个变量代替<span class="math inline">\(dp\)</span>数组，从而降低动态规划算法的空间复杂度。该变量记录到目前为止已处理过的最大子数组中最大的值。修改后的算法代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kadanes_r1</span><span class="params">(a)</span>:</span></span><br><span class="line">    current_max = total_max = float(<span class="string">'-inf'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(a)):</span><br><span class="line">        current_max = max(current_max, <span class="number">0</span>) + a[i]</span><br><span class="line">        total_max = max(total_max, current_max)</span><br><span class="line">    <span class="keyword">return</span> total_max</span><br></pre></td></tr></table></figure><p>修改后的算法时间复杂度还是<span class="math inline">\(\Theta(n)\)</span>，空间复杂度降低为<span class="math inline">\(O(1)\)</span>。</p><h2 id="记录子数组位置">记录子数组位置</h2><p>展开<code>max</code>，在<code>current_max</code>和<code>total_max</code>的值发生改变的同时，更新起始或终止位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kadanes_r2</span><span class="params">(a)</span>:</span></span><br><span class="line">    current_max = total_max = float(<span class="string">'-inf'</span>)</span><br><span class="line">    start = end = temp_start = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(a)):</span><br><span class="line">        current_max += a[i]</span><br><span class="line">        <span class="keyword">if</span> current_max &lt; <span class="number">0</span>:</span><br><span class="line">            current_max, temp_start = <span class="number">0</span>, i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> total_max &lt; current_max:</span><br><span class="line">            total_max = current_max</span><br><span class="line">            start, end = temp_start, i</span><br><span class="line">    <span class="keyword">return</span> start, end, total_max</span><br></pre></td></tr></table></figure><p>时间复杂度为<span class="math inline">\(\Theta(n)\)</span>，空间复杂度为<span class="math inline">\(O(1)\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithms </tag>
            
            <tag> divide-and-conquer </tag>
            
            <tag> dynamic programming </tag>
            
            <tag> Introduction To Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序统计量</title>
      <link href="/notes/introduction-to-algorithms/order-statistics/"/>
      <url>/notes/introduction-to-algorithms/order-statistics/</url>
      
        <content type="html"><![CDATA[<h1 id="顺序统计量">顺序统计量</h1><p>在一个由<span class="math inline">\(n\)</span>个元素组成的集合中，第<span class="math inline">\(i\)</span>个顺序统计量（order statistic）是该集合中第<span class="math inline">\(i\)</span>小的元素。</p><p>例如，在一个元素集合中，最小值是第1个顺序统计量（<span class="math inline">\(i=1\)</span>），最大值是第<span class="math inline">\(n\)</span>个顺序统计量（<span class="math inline">\(i=n\)</span>）。</p><p>将从一个由<span class="math inline">\(n\)</span>个互异的元素构成的集合中选择第<span class="math inline">\(i\)</span>个顺序统计量的问题形式化定义为如下的<strong>选择问题</strong>：</p><p><strong>输入</strong>： 一个包含<span class="math inline">\(n\)</span>个（互异的）数的集合<span class="math inline">\(A\)</span>和一个整数<span class="math inline">\(i，1\le{i}\le{n}\)</span>。</p><p><strong>输出</strong>： 元素<span class="math inline">\(x\in{A}\)</span>，且<span class="math inline">\(A\)</span>中恰好有<span class="math inline">\(i-1\)</span>个其他元素小于它。</p><a id="more"></a><h1 id="最大值和最小值">最大值和最小值</h1><h2 id="找到最小值或最大值">找到最小值或最大值</h2><p>在一个有<span class="math inline">\(n\)</span>个元素的集合中，找出其最小值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minimum</span><span class="params">(a)</span>:</span>  <span class="comment"># 与min()作用相同</span></span><br><span class="line">    <span class="keyword">if</span> len(a) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'minimum() arg is an empty sequence'</span>)</span><br><span class="line">    m = a[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(a)):  <span class="comment"># 循环n-1次，n位数组长度</span></span><br><span class="line">        m = min(m, a[i])  <span class="comment"># 元素之间比较n-1次</span></span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">18</span>, <span class="number">24</span>, <span class="number">17</span>, <span class="number">3</span>, <span class="number">21</span>, <span class="number">7</span>, <span class="number">23</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">39</span>, <span class="number">46</span>, <span class="number">26</span>, <span class="number">30</span>, <span class="number">38</span>, <span class="number">52</span>]</span><br><span class="line">    print(<span class="string">'min ='</span>, minimum(arr))</span><br></pre></td></tr></table></figure><p>需要做<span class="math inline">\(n-1\)</span>次比较，<span class="math inline">\(n-1\)</span>次既是其比较次数上界亦是其下界。找出最大值的方法类似。</p><p>在一个包含<span class="math inline">\(n\)</span>个元素的集合中找出最小值（最大值）的时间是<span class="math inline">\(\Theta(n)\)</span>。</p><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min = 3</span><br></pre></td></tr></table></figure><h2 id="同时找到最小值和最大值">同时找到最小值和最大值</h2><p>可以分别独立地找出最小值和最大值，这各需要<span class="math inline">\(n-1\)</span>次比较，共需<span class="math inline">\(2n-2\)</span>次比较。即将每个元素与当前最小值比较一次，再与最大元素比较一次。代价是每个元素都需要2次比较。</p><p>事实上，只需要最多<span class="math inline">\(3\lfloor{n/2}\rfloor\)</span>次比较就可以同时找到最小值和最大值。</p><p>记录已知的最大值和最小值，对输入元素成对地进行处理。首先，将一对输入元素相互进行比较，然后把较小的与当前最小值比较，把较大的与当前最大值进行比较。这样，对每连个元素共需3次比较。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min_max</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(a) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'min_max() arg is an empty sequence'</span>)</span><br><span class="line">    mini = maxi = a[<span class="number">0</span>]  <span class="comment"># n为奇数时，临时变量同时指向第一个元素</span></span><br><span class="line">    i = <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> len(a) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        mini, maxi = a[<span class="number">0</span>], a[<span class="number">1</span>]  <span class="comment"># n为偶数时，先比较前两个元素确定当前最小值和最大值</span></span><br><span class="line">        <span class="keyword">if</span> mini &lt; maxi:</span><br><span class="line">            mini, maxi = maxi, mini</span><br><span class="line">        i = <span class="number">3</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(a):</span><br><span class="line">        x, y = a[i - <span class="number">1</span>], a[i]</span><br><span class="line">        <span class="keyword">if</span> a[i - <span class="number">1</span>] &gt; a[i]:</span><br><span class="line">            x, y = y, x  <span class="comment"># 先比较数组中两个元素</span></span><br><span class="line">        mini = min(mini, x)  <span class="comment"># 小的元素与当前最小值比较</span></span><br><span class="line">        maxi = max(maxi, y)  <span class="comment"># 大的元素与当前最大值比较</span></span><br><span class="line">        i += <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> mini, maxi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">18</span>, <span class="number">24</span>, <span class="number">17</span>, <span class="number">3</span>, <span class="number">21</span>, <span class="number">7</span>, <span class="number">23</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">39</span>, <span class="number">46</span>, <span class="number">26</span>, <span class="number">30</span>, <span class="number">38</span>, <span class="number">52</span>]</span><br><span class="line">    print(<span class="string">'(min, max) ='</span>, min_max(arr))</span><br></pre></td></tr></table></figure><p>分析以下总的比较次数：</p><ul><li>如果<span class="math inline">\(n\)</span>是奇数，那么第一个元素不用比较，后<span class="math inline">\(n-1\)</span>个元素每两个进行3次比较，总共进行<span class="math inline">\(3(n-1)/2=3\lfloor{n/2}\rfloor\)</span>次比较。</li><li>如果<span class="math inline">\(n\)</span>是偶数，那么前两个元素比较1次，后<span class="math inline">\(n-2\)</span>个元素每两个进行3次比较，总共进行<span class="math inline">\(1+3(n-2)/2=3n/2-2&lt;3\lfloor{n/2}\rfloor\)</span>。</li></ul><p>因此，不管是哪一种情况，总的比较次数至多是<span class="math inline">\(3\lfloor{n/2}\rfloor\)</span>。</p><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(min, max) = (3, 52)</span><br></pre></td></tr></table></figure><h1 id="期望为线性时间的选择算法">期望为线性时间的选择算法</h1><p>一般选择问题看起来要比找最小值这样的简单问题更难。但令人惊奇的是，这两个问题的渐进运行时间确实相同的：<span class="math inline">\(\Theta(n)\)</span>。下面介绍一种解决选择问题的分治算法。<code>RANDOMIZED-SELECT</code>算法是以快速排序算法为模型的。</p><ul><li><p>与快速排序一样，将输入数组进行递归划分。</p></li><li><p>与快速排序不同的是，快速排序会递归处理划分的两边，而<code>RANDOMIZED-SELECT</code>只处理划分的一边。快速排序的期望运行时间是<span class="math inline">\(n\lg(n)\)</span>，而<code>RANDOMIZED-SELECT</code>的期望运行时间为<span class="math inline">\(O(n)\)</span>。</p></li></ul><p><code>RANDOMIZED-SELECT</code>返回数组<span class="math inline">\(A[p..r]\)</span>中第<span class="math inline">\(i\)</span>小的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RANDOMIZED-SELECT(A, p, r, i):</span><br><span class="line">    <span class="keyword">if</span> p == r:          <span class="comment"># 如果数组中只包括一个元素，那么此时i必然等于1</span></span><br><span class="line">        <span class="keyword">return</span> A[p]    <span class="comment"># 此时只需返回这唯一的一个元素</span></span><br><span class="line">    q = RANDOMIZED-PARTITION(A, p, r)  <span class="comment"># 随机选择主元并划分，返回主元位置。因为主元与其他元素</span></span><br><span class="line">    k = q-p+<span class="number">1</span>  <span class="comment"># 主元是第k小             # 都比较过，所以主元所在位置就是最终在已排序数组中的位置</span></span><br><span class="line">    <span class="keyword">if</span> i == k:          <span class="comment"># 检测A[q]是否是第i小元素</span></span><br><span class="line">        <span class="keyword">return</span> A[q]</span><br><span class="line">    <span class="keyword">elif</span> i &lt; k:         <span class="comment"># i&lt;k说明A[q]过大，要找的元素落在左边</span></span><br><span class="line">        <span class="keyword">return</span> RANDOMIZED-SELECT(A, p, q<span class="number">-1</span>, i)</span><br><span class="line">    <span class="keyword">else</span>:               <span class="comment"># 否则落在右边</span></span><br><span class="line">        <span class="keyword">return</span> RANDOMIZED-SELECT(A, q+<span class="number">1</span>, r, i-k)  <span class="comment"># 左边+主元一共k个元素，在右边要找第i-k小元素</span></span><br></pre></td></tr></table></figure><p>程序判断了<code>p==r</code>即子数组只含有1个元素的情况，那么含有0个元素的情况呢？划分操作有可能产生长度为0的子数组，那么上述递归操作会调用含有0个元素的子数组吗？答案是这种情况不会发生。考虑主元位于边界的情况：</p><ul><li><span class="math inline">\(p=q\)</span>：左边子数组长度为0，右边不为0。主元是第1小元素，由于<span class="math inline">\(i\)</span>不可能小于1，若所寻目标<span class="math inline">\(i=1\)</span>，程序结束并返回；若<span class="math inline">\(i&gt;1\)</span>，程序将在右边的子数组中递归寻找。</li><li><span class="math inline">\(p=r\)</span>：与<span class="math inline">\(p=q\)</span>是对称的。<span class="math inline">\(i\)</span>不可能大于n（数组中元素总个数）。此时主元是第n小，若<span class="math inline">\(i=n\)</span>，程序结束并返回；若<span class="math inline">\(i&lt;n\)</span>，则在左边的子数组中递归寻找。</li></ul><p>因此，程序会不递归调用含有0个元素的数组。</p><h2 id="分析">分析</h2><p><code>RANDOMIZED-SELECT</code>的最坏情况运行时间为<span class="math inline">\(\Theta(n^2)\)</span>，即使是找最小元素也是如此，因为在每次划分时可能极不走运地总是按余下的元素中最大的来进行划分，而划分操作需要<span class="math inline">\(\Theta(n)\)</span>时间。但因为算法是随机化的，所以不存在一个特定的会导致其最坏情况发生的输入数据。下面分析算法的期望运行时间。</p><p>设该算法在一个含有<span class="math inline">\(n\)</span>个元素的输入数组<span class="math inline">\(A[p..r]\)</span>上的运行时间是一个随机变量，记为<span class="math inline">\(T(n)\)</span>。对每一个<span class="math inline">\(k(1\le{k}\le{n})\)</span>，子数组<span class="math inline">\(A[p..q]\)</span>（全部小于或等于主元）有<span class="math inline">\(k\)</span>个元素的概率是<span class="math inline">\(1/n\)</span>。对所有的<span class="math inline">\(k=1,2,\dots,n\)</span>，定义指示器变量<span class="math inline">\(X_k\)</span>为：<span class="math inline">\(X_k=I\lbrace子数组A[p..q]正好包含k个元素\rbrace\)</span>。假设元素是互异的，有<span class="math inline">\(E[X_k]=1/n\)</span>。</p><p>为了得到所需时间的上界，假定查找的第<span class="math inline">\(i\)</span>个元素总是在划分中包含较大元素的一边。指示器随机变量<span class="math inline">\(X_k\)</span>恰好在给定的<span class="math inline">\(k\)</span>值上取值1，对其他值都为0。当<span class="math inline">\(X_k=1\)</span>时，可能要递归处理的两个子数组大小分别为<span class="math inline">\(k-1\)</span>和<span class="math inline">\(n-k\)</span>。因此可以得到递归式： <span class="math display">\[\begin{aligned}T(n)&amp;\le\sum_{k=1}^nX_k\cdot\Bigl(T\bigl(max(k-1,n-k)\bigr)+O(n)\Bigr)\\&amp;=\sum_{k=1}^nX_k\cdot{T(max(k-1,n-k))}+O(n)\end{aligned}\]</span> 两边取期望值，得到 <span class="math display">\[\begin{aligned}E[T(n)]&amp;\le{E\Big[\sum_{k=1}^nX_k\cdot{T(max(k-1,n-k))}+O(n)\Bigr]}\\&amp;=\sum_{k=1}^nE\Big[X_k\cdot{T(max(k-1,n-k))}\Big]+O(n)\quad\text{(期望的线性性质)}\\&amp;=\sum_{k=1}^nE[X_k]\cdot{E[T(max(k-1,n-k))]}+O(n)\quad\text{(}X_k\text{和}T(max(k-1,n-k))\text{相互独立)}\\&amp;=\sum_{k=1}^n\frac{1}{n}\cdot{E[T(max(k-1,n-k))]}+O(n)\end{aligned}\]</span> 考虑表达式<span class="math inline">\(max(k-1,n-k)\)</span>，有 <span class="math display">\[max(k-1,n-k)=\begin{cases}k-1\quad\text{若}k&gt;\lceil{n/2}\rceil\\n-k\quad\text{若}k\le\lceil{n/2}\rceil\end{cases}\]</span> 观察到表达式<span class="math inline">\(max(k-1,n-k)\)</span>的取值是成对出现的：</p><ul><li>如果<span class="math inline">\(n\)</span>是偶数，则<span class="math inline">\(k=1,2,\dots,n/2\)</span>与<span class="math inline">\(k=n,n-1,\dots,n/2+1\)</span>时的取值相等，取值分别是<span class="math inline">\(n-1,n-2,\dots,n/2\)</span>。</li><li>如果<span class="math inline">\(n\)</span>是奇数，则<span class="math inline">\(k=1,2,\dots,\lfloor{n/2}\rfloor\)</span>与<span class="math inline">\(k=n,n-1,\dots,\lceil{n/2}\rceil+1\)</span>时的取值相等，分别是<span class="math inline">\(n-1,n-2,\dots,\lceil{n/2}\rceil\)</span>。此外<span class="math inline">\(k=\lceil{n/2}\rceil\)</span>时的取值单独出现，值是<span class="math inline">\(\lfloor{2/n}\rfloor\)</span>。</li></ul><p>因此，有 <span class="math display">\[E[T(n)]\le\frac{2}{n}\sum_{k=\lfloor{n/2}\rfloor}^{n-1}E[T(k)]+O(n)\]</span> 下面用替代法来得到<span class="math inline">\(E[T(n)]=O(n)\)</span>。</p><p>假设对某个常数<span class="math inline">\(c\)</span>，有<span class="math inline">\(E[T(n)]\le{cn}\)</span>。假设对小于某个常数的<span class="math inline">\(n\)</span>，有<span class="math inline">\(T(n)=O(1)\)</span>。同时，选择一个常数<span class="math inline">\(a\)</span>，使得对所有<span class="math inline">\(n&gt;0\)</span>，上式中<span class="math inline">\(O(n)\)</span>项所描述的函数有上界<span class="math inline">\(an\)</span>。利用这个归纳假设，可以得到： <span class="math display">\[\begin{aligned}E[T(n)]&amp;\le\frac{2}{n}\sum_{k=\lfloor{n/2}\rfloor}^{n-1}ck+an\\&amp;=\frac{2c}{n}\Big(\sum_{k=1}^{n-1}k-\sum_{k=1}^{\lfloor{n/2}\rfloor-1}k\Big)+an\\&amp;=\frac{2c}{n}\Big(\frac{(n-1)n}{2}-\frac{(\lfloor{n/2}\rfloor-1)\lfloor{n/2}\rfloor}{2}\Big)+an\\&amp;\le\frac{2c}{n}\Big(\frac{(n-1)n}{2}-\frac{(n/2-2)(n/2-1)}{2}\Big)+an\\&amp;=\frac{2c}{n}\Big(\frac{n^2-n}{2}-\frac{n^2-3n/2+2}{2}\Big)+an\\&amp;=\frac{c}{n}(\frac{3n}{4}+\frac{1}{2}-\frac{2}{n})+an\\&amp;\le\frac{3cn}{4}+\frac{c}{2}+an\\&amp;=cn-\color{red}{(\frac{cn}{4}-\frac{c}{2}-an)}\end{aligned}\]</span> 为了完成证明，还需要证明：对足够大的<span class="math inline">\(n\)</span>，最后一个表达式至多是<span class="math inline">\(cn\)</span>。 <span class="math display">\[\begin{aligned}\frac{cn}{4}-\frac{c}{2}-an&amp;\ge0\\n(\frac{c}{4}-a)&amp;\ge\frac{c}{2}\end{aligned}\]</span> 只要选择的常数<span class="math inline">\(c\)</span>能够满足<span class="math inline">\(c/4-a&gt;0\)</span>，就可以将两边同时除以<span class="math inline">\(c/4-a\)</span>，得到 <span class="math display">\[n\ge\frac{c/2}{c/4-a}=\frac{2c}{c-4a}\]</span> 因此，如果假设对所有<span class="math inline">\(n&lt;2c/(c-4a)\)</span>，都有<span class="math inline">\(T(n)=O(1)\)</span>，那么就有<span class="math inline">\(E[T(n)]=O(n)\)</span>。</p><p>结果：假设所有元素是互异的，在期望线性时间内，可以找到任一顺序统计量，特别是中位数（？）。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sort.quick_sort <span class="keyword">import</span> partition</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randomized_select</span><span class="params">(a, p, r, i)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> p == r:  <span class="comment"># 只有一个元素时，i一定等于1，i代表的是在a[p..r]中第i小</span></span><br><span class="line">        <span class="keyword">return</span> a[p]</span><br><span class="line">    q = partition(a, p, r, randint(p, r))  <span class="comment"># 随机选择主元并划分</span></span><br><span class="line">    k = q - p + <span class="number">1</span>  <span class="comment"># 主元是第k小元素</span></span><br><span class="line">    <span class="keyword">if</span> i == k:</span><br><span class="line">        <span class="keyword">return</span> a[q]</span><br><span class="line">    <span class="keyword">elif</span> i &lt; k:  <span class="comment"># 在左边继续寻找</span></span><br><span class="line">        <span class="keyword">return</span> randomized_select(a, p, q - <span class="number">1</span>, i)</span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 在右边继续寻找，注意要寻找的序号要变化</span></span><br><span class="line">        <span class="keyword">return</span> randomized_select(a, q + <span class="number">1</span>, r, i - k)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">18</span>, <span class="number">24</span>, <span class="number">17</span>, <span class="number">3</span>, <span class="number">21</span>, <span class="number">7</span>, <span class="number">23</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">39</span>, <span class="number">46</span>, <span class="number">26</span>, <span class="number">30</span>, <span class="number">38</span>, <span class="number">52</span>]</span><br><span class="line">    print([randomized_select(arr, <span class="number">0</span>, len(arr) - <span class="number">1</span>, i + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr))])</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3, 7, 17, 18, 21, 23, 24, 26, 30, 35, 38, 39, 41, 46, 52]</span><br></pre></td></tr></table></figure><h1 id="最坏情况为线性时间的选择算法">最坏情况为线性时间的选择算法</h1><p>本节介绍一个最坏情况运行时间为<span class="math inline">\(\Theta(n)\)</span>的选择算法：<code>SELECT</code>算法。像<code>RANDOMIZED-SELECT</code>一样，<code>SELECT</code>算法通过对输入数组的递归划分来找出所需元素，但是，在该算法中<strong>能够保证得到对数组的一个好的划分</strong>。</p><p><code>SELECT</code>算法的执行步骤如下：</p><ol type="1"><li>如果<span class="math inline">\(n=1\)</span>，则返回唯一元素作为第<span class="math inline">\(i\)</span>小的元素。否则将输入数组的<span class="math inline">\(n\)</span>个元素划分为<span class="math inline">\(\lfloor{n/5}\rfloor\)</span>组，每组5个元素，剩下的一组至多由<span class="math inline">\(n\%5\)</span>个元素组成。</li><li>寻找这<span class="math inline">\(\lceil{n/5}\rceil\)</span>组中每一组的中位数：首先对每组元素进行插入排序，然后确定每组有序元素的中位数。</li><li>对第2步中找出的<span class="math inline">\(\lceil{n/5}\rceil\)</span>个中位数，递归调用<code>SELECT</code>以找出其中的中位数<span class="math inline">\(x\)</span>（如果由偶数个中位数，为了方便，约定x是较小的中位数）。</li><li>按中位数的中位数<span class="math inline">\(x\)</span>对输入数组进行划分。让<span class="math inline">\(k\)</span>比划分的低区中的元素数目多1，因此x是第<span class="math inline">\(k\)</span>小的元素，并且有<span class="math inline">\(n-k\)</span>个元素在划分的高区。</li><li>如果<span class="math inline">\(i=k\)</span>，则返回x。如果<span class="math inline">\(i&lt;k\)</span>，则在地区递归调用<code>SELECT</code>来找出第<span class="math inline">\(i\)</span>小的元素。如果<span class="math inline">\(i&gt;k\)</span>，则在高区递归查找第<span class="math inline">\(i-k\)</span>小的元素。</li></ol><h2 id="分析-1">分析</h2><p>首先确定大于划分主元<span class="math inline">\(x\)</span>的元素个数的下界。下图给出了一些形象的说明。在第2步找出的中位数中，至少有一半大于或等于中位数的中位数<span class="math inline">\(x\)</span>。因此，在这<span class="math inline">\(\lceil{n/5}\rceil\)</span>个组中， 除了当<span class="math inline">\(n\)</span>不能被5整除时产生的所含元素少于5的那个组，和包含<span class="math inline">\(x\)</span>的那个组之外，至少有一半的组中有3个元素大于<span class="math inline">\(x\)</span>。不算这两个组，大于<span class="math inline">\(x\)</span>的元素个数至少为 <span class="math display">\[3\Bigl(\big\lceil\frac{1}{2}\lceil\frac{n}{5}\rceil\big\rceil-2\Bigr)\ge\frac{3n}{10}-6\]</span> 类似地，至少有<span class="math inline">\(3n/10-6\)</span>个元素小于<span class="math inline">\(x\)</span>。因此，在最坏情况下，在第5步中，<code>SELECT</code>的递归调用最多作用于<span class="math inline">\(7n/10+6\)</span>个元素。</p><p><img title="灰色阴影覆盖的元素全都大于x" data-src="/uploads/posts/select-analysis.png"></p><p>现在，设计一个递归式来推到<code>SELECT</code>算法的最坏情况运行时间<span class="math inline">\(T(n)\)</span>。</p><p>步骤1：分组需要<span class="math inline">\(O(n)\)</span>时间。</p><p>步骤2：对大小为<span class="math inline">\(O(1)\)</span>（大小为5）的集合调用<span class="math inline">\(O(n)\)</span>（<span class="math inline">\(\lceil{n/5}\rceil\)</span>次）插入排序，总时间也为<span class="math inline">\(O(n)\)</span>。</p><p>步骤3：递归所需时间为<span class="math inline">\(T(\lceil{n/5}\rceil)\)</span>。</p><p>步骤4：<code>partition</code>所需时间为<span class="math inline">\(O(n)\)</span>。</p><p>步骤5：递归所需时间至多为<span class="math inline">\(T(7n/10+6)\)</span>。</p><p>将上述时间累加，可得到 <span class="math display">\[T(n)\le{T(\lceil{n/5}\rceil)+T(7n/10+6)+O(n)}\]</span> 下面用替换法证明这个运行时间是线性的。更明确地说，证明对某个适当大的常数<span class="math inline">\(c\)</span>和所有的<span class="math inline">\(n&gt;0\)</span>，有<span class="math inline">\(T(n)\le{cn}\)</span>。挑选一个常数<span class="math inline">\(a\)</span>，使得对所有的<span class="math inline">\(n&gt;0\)</span>，公式中的<span class="math inline">\(O(n)\)</span>项所对应的函数有上界<span class="math inline">\(an\)</span>。假设<span class="math inline">\(T(n)\le{cn}\)</span>成立。将假设带入上述递归式的右边，得到 <span class="math display">\[\begin{aligned}T(n)&amp;\le{c\lceil{n/5}\rceil}+c(7n/10+6)+an\\&amp;\le{cn/5+c}+7cn/10+6c+an\\&amp;=9cn/10+7c+an\\&amp;=cn+\color{red}{(-cn/10+7c+an)}\end{aligned}\]</span> 若<span class="math inline">\(-cn/10+7c+an\le0\)</span>时，则<span class="math inline">\(T(n)\le{cn}\)</span>成立。 <span class="math display">\[\begin{aligned}-cn/10+7c+an&amp;\le0\\cn/10-7c&amp;\ge{an}\\c\frac{n-70}{10}&amp;\ge{an}\end{aligned}\]</span> 观察上式可知，当<span class="math inline">\(n&gt;70\)</span>时，<span class="math inline">\(-cn/10+7c+an\le0\)</span>，此时<span class="math inline">\(c\ge10a\color{red}{(n/(n-70))}\)</span>。 <span class="math display">\[\frac{n}{n-70}=\frac{1}{1-\frac{70}{n}}\]</span> 当<span class="math inline">\(n\)</span>增大时，<span class="math inline">\(n/(n-70)\)</span>减小，因此只要适当地选择<span class="math inline">\(c\)</span>的值，使不等式<span class="math inline">\(-cn/10+7c+an\le0\)</span>成立，就能证明<span class="math inline">\(T(n)\le{cn}\)</span>。例如，<span class="math inline">\(n&gt;70\)</span>时，<span class="math inline">\(n/(n-70)\le71\)</span>，选择常数<span class="math inline">\(c\ge710a\)</span>即可满足<span class="math inline">\(T(n)\le{cn}\)</span>。又例如，当<span class="math inline">\(n\ge140\)</span>时，<span class="math inline">\(n/(n-70)\le2\)</span>，选择常数<span class="math inline">\(c\ge20a\)</span>即可。无论如何选择<span class="math inline">\(n\)</span>的边界<span class="math inline">\(x\)</span>，在<span class="math inline">\(n&lt;x\)</span>时，<span class="math inline">\(T(n)\le{cn}\)</span>成立（只需选择足够大的<span class="math inline">\(c\)</span>即可）。因此，最坏情况下<code>SELECT</code>的运行时间是线性的。</p><h2 id="代码-1">代码</h2><p>不同的是：将选择中位数的中位数过程（步骤1~3）从选择算法中独立出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sort.quick_sort <span class="keyword">import</span> partition</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> ceil</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(a, i, j)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> i != j:</span><br><span class="line">        a[i], a[j] = a[j], a[i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span><span class="params">(a, p, r)</span>:</span>  <span class="comment"># 修改过的插入排序，对a[p..r]进行排序</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(p + <span class="number">1</span>, r + <span class="number">1</span>):</span><br><span class="line">        key = a[j]</span><br><span class="line">        i = j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= p <span class="keyword">and</span> a[i] &gt; key:</span><br><span class="line">            a[i + <span class="number">1</span>] = a[i]</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        a[i + <span class="number">1</span>] = key</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">median_of_median</span><span class="params">(a, p, r)</span>:</span></span><br><span class="line">    <span class="string">"""将数组分成每5个元素一组，找其中位数，若有多个，递归中位数组成的数组，继续寻找"""</span></span><br><span class="line">    <span class="keyword">if</span> p == r:</span><br><span class="line">        <span class="keyword">return</span> a[p]</span><br><span class="line">    <span class="comment"># 对每5个元素调用插入排序</span></span><br><span class="line">    left = p</span><br><span class="line">    <span class="keyword">while</span> left &lt;= r:</span><br><span class="line">        right = min(left + <span class="number">4</span>, r)</span><br><span class="line">        insertion_sort(a, left, right)  <span class="comment"># 对每5个数排序，剩下的一组若不足5个，有几个算几个</span></span><br><span class="line">        <span class="comment"># 交换中位数到数组前面，方便递归调用</span></span><br><span class="line">        exchange(a, p + (right - p) // <span class="number">5</span>, (right + left) // <span class="number">2</span>)</span><br><span class="line">        left += <span class="number">5</span></span><br><span class="line">    n = ceil((r - p + <span class="number">1</span>) / <span class="number">5</span>)  <span class="comment"># 所有分组的中位数的个数</span></span><br><span class="line">    <span class="keyword">return</span> median_of_median(a, p, p + n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select</span><span class="params">(a, p, r, i)</span>:</span></span><br><span class="line">    median_of_median(a, p, r)  <span class="comment"># 找出中位数的中位数，过程结束时找到的中位数位置为p</span></span><br><span class="line">    q = partition(a, p, r, p)  <span class="comment"># 以找到的中位数为pivot，划分数组</span></span><br><span class="line">    k = q - p + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i == k:</span><br><span class="line">        <span class="keyword">return</span> a[q]</span><br><span class="line">    <span class="keyword">elif</span> i &lt; k:</span><br><span class="line">        <span class="keyword">return</span> select(a, p, q - <span class="number">1</span>, i)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> select(a, q + <span class="number">1</span>, r, i - k)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">18</span>, <span class="number">24</span>, <span class="number">17</span>, <span class="number">3</span>, <span class="number">21</span>, <span class="number">7</span>, <span class="number">23</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">39</span>, <span class="number">46</span>, <span class="number">26</span>, <span class="number">30</span>, <span class="number">38</span>, <span class="number">52</span>]</span><br><span class="line">    print([select(arr, <span class="number">0</span>, len(arr) - <span class="number">1</span>, i + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr))])</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3, 7, 17, 18, 21, 23, 24, 26, 30, 35, 38, 39, 41, 46, 52]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithms </tag>
            
            <tag> divide-and-conquer </tag>
            
            <tag> Introduction To Algorithms </tag>
            
            <tag> quicksort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大流</title>
      <link href="/notes/introduction-to-algorithms/maximum-flow/"/>
      <url>/notes/introduction-to-algorithms/maximum-flow/</url>
      
        <content type="html"><![CDATA[<h1 id="流网络和流">流网络和流</h1><p><strong>流网络</strong><span class="math inline">\(G=(V,E)\)</span>是一个有向图，图中每条边<span class="math inline">\((u,v)\in{E}\)</span>有一个非负的<strong>容量值</strong><span class="math inline">\(c(u,v)\ge0\)</span>。而且，如果边集合<span class="math inline">\(E\)</span>包含一条边<span class="math inline">\((u,v)\)</span>，则图中不存在反向边<span class="math inline">\((v,u)\)</span>。如果<span class="math inline">\((u,v)\notin{E}\)</span>，为方便起见，定义<span class="math inline">\(c(u,v)=0\)</span>，并且在图中不允许自循环。</p><p>在流网络的所有结点中，特别分辨出两个特殊结点：<strong>源结点</strong><span class="math inline">\(s\)</span>和<strong>汇点</strong><span class="math inline">\(t\)</span>。为方便起点，假定每个结点都在从源结点到汇点的某条路径上。因此，流网络图是连通的，并且由于除源结点外的每个结点都至少有一条进入的边，有<span class="math inline">\(|E|\ge|V|-1\)</span>。下图描述的是一个流网络的例子。</p><p><img title="一个流网络" data-src="/uploads/posts/flow-network.png"></p><a id="more"></a><p>下面给出流的形式化定义。设<span class="math inline">\(G=(V,E)\)</span>为一个流网络，其容量函数为<span class="math inline">\(c\)</span>。设<span class="math inline">\(s\)</span>为网络的源结点，<span class="math inline">\(t\)</span>为汇点。<span class="math inline">\(G\)</span>中的<strong>流</strong>是一个实值函数<span class="math inline">\(f:V\times{V}\rightarrow\mathbb{R}\)</span>，满足下面的两条性质：</p><ul><li>容量限制：对于所有的结点<span class="math inline">\(u,v\in{V}\)</span>，要求<span class="math inline">\(0\le{f(u,v)}\le{c(u,v)}\)</span>。</li><li>流量守恒：对于所有的结点<span class="math inline">\(u\in{V-\lbrace{s,t}\rbrace}\)</span>，要求</li></ul><p><span class="math display">\[\sum_{v\in{V}}f(v,u)=\sum_{v\in{V}}f(u，v)\]</span></p><p>当<span class="math inline">\((u,v)\notin{E}\)</span>时，从结点<span class="math inline">\(u\)</span>到结点<span class="math inline">\(v\)</span>之间没有流，因此<span class="math inline">\(f(u,v)=0\)</span>。</p><p>容量限制性质说明，从一个结点到另一个结点之间的流必须为非负值且不能超过给定的容量限制。</p><p>流量守恒性质说明，流入一个结点（源结点和汇点除外）的总流量必须等于流出该节点的总流量，“流入等于流出”。</p><p>一个流<span class="math inline">\(f\)</span>的<strong>值</strong><span class="math inline">\(|f|\)</span>（这里，符号<span class="math inline">\(|\quad|\)</span>表示流的值）定义如下： <span class="math display">\[|f|=\sum_{v\in{V}}f(s,v)-\sum_{v\in{V}}f(v,s)\tag{26.1}\]</span> 也就是说，流<span class="math inline">\(f\)</span>的值是从源结点流出的总流量减去流入源结点的总流量。在<strong>最大流问题</strong>中，给定一个流网络<span class="math inline">\(G\)</span>、一个源结点<span class="math inline">\(s\)</span>、一个汇点<span class="math inline">\(t\)</span>，希望找到值最大的一个流。</p><h1 id="反平行边多源点汇点">反平行边、多源点汇点</h1><p>上述流网络假设：如果边<span class="math inline">\((u,v)\in{E}\)</span>，则<span class="math inline">\((v,u)\notin{E}\)</span>。称<span class="math inline">\((u,v)\)</span>和边<span class="math inline">\((v,u)\)</span>为<strong>反平行</strong>（antiparallel）。如果一个流问题中包含反平行边，必须将这种网络转换为一个等价的但不包含反平行边的网络。下图描述的就是这样一个等价网络。选择两条反平行边中的一条，在这个例子中是边<span class="math inline">\((v_1,v_2)\)</span>，通过加入一个新结点<span class="math inline">\(v^\prime\)</span>来将其分且为两段，并以边<span class="math inline">\((v_1,v^\prime)\)</span>和<span class="math inline">\((v^\prime,v_2)\)</span>来替换边<span class="math inline">\((v_1,v_2)\)</span>。同时将两条新设立的边的容量设置为与原来的边的容量相同。</p><p><img title="带有反平行边的流网络" data-src="/uploads/posts/flow-network-with-antiparallel-edges.png"></p><p>一个最大流问题可能有几个源结点和几个汇点。在具有多个源结点和汇点的网络中，确定最大流的问题可以规约为一个普通的最大流问题。下图(b描述的是如何将(a)所示的网络转换为只有一个源结点和一个汇点的普通流网络。转换方法是加入一个<strong>超级源结点</strong><span class="math inline">\(s\)</span>，并加入有向边<span class="math inline">\((s,s_i),i=1,2,\dots,m\)</span>，其容量<span class="math inline">\(c(s,s_i)=\infty\)</span>。同时创建一个新的<strong>超级汇点</strong><span class="math inline">\(t\)</span>，并加入有向边<span class="math inline">\((t_i,t),i=1,2,\dots,n\)</span>，其容量<span class="math inline">\(c(t_i,t)=\infty\)</span>。</p><p><img title="含有多个源结点和汇点的流网络" data-src="/uploads/posts/flow-network-with-multiple-source-multiple-sink.png"></p><h1 id="ford-fulkerson方法">Ford-Fulkerson方法</h1><p>Ford-Fulkerson方法是解决最大流问题的一种方法。之所以称其为“方法”而不是“算法”，是因为它包含了几种运行时间各不相同的具体实现。Ford-Fulkerson方法依赖于三种重要思想，它们与许多的流算法和问题有关：残存网络、增广路径和切割。这些思想是最大流最小切割定理的精髓。</p><p>Ford-Fulkerson方法循环增加流的值。</p><ul><li>在开始的时候，对于所有的结点<span class="math inline">\(u,v\in{V}\)</span>，<span class="math inline">\(f(u,v)=0\)</span>，给出的初始流值为0。</li><li>在每一次迭代中，将图<span class="math inline">\(G\)</span>的流值进行增加，方法是在一个关联的“残存网络”<span class="math inline">\(G_f\)</span>中寻找一条“增广路径”。增加的是整个网络中的流量，对于图中特定的一条边来说，其流量在迭代过程中可能增加，也可能减少。对某些边的流进行缩减可能是必要的，以便让算法可以将更多的流从源结点发送到汇点。</li><li>重复对流进行上述迭代过程，直到残存网络中不再存在增广路径未知。最大流最小切割定理将说明在算法终止时，将获得一个最大流。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FORD-FULKERSON-METHOD(G, s, t):</span><br><span class="line">    initialize flow f to <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> there exists an augmenting path p <span class="keyword">in</span> the residual network:</span><br><span class="line">        augment flow f along p</span><br><span class="line">    <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure><p>为了实现和分析Ford-Fulkerson方法，需要引入几个新的概念。</p><h2 id="残存网络">残存网络</h2><p>从直观上看，给定流网络<span class="math inline">\(G\)</span>和流量<span class="math inline">\(f\)</span>，残存网络<span class="math inline">\(G_f\)</span>由那些仍有空间对流量进行调整的边构成。</p><ul><li>流网络的一条边可以允许的额外流量等于该边的容量减去该边上的流量。如果该差值为正，则将该条边置于图<span class="math inline">\(G_f\)</span>中，并将其残存容量设置为<span class="math inline">\(c_f(u,v)=c(u,v)-f(u,v)\)</span>。如果边<span class="math inline">\((u,v)\)</span>的流量等于其容量，则其<span class="math inline">\(c_f(u,v)=0\)</span>，该条边将不属于<span class="math inline">\(G_f\)</span>。</li><li>残存网络<span class="math inline">\(G_f\)</span>还可能包含图<span class="math inline">\(G\)</span>中不存在的边。算法对流量进行操作的目标是增加总流量，为此，算法可能对某些特定边上的流量进行缩减。为了表示对一个正流量<span class="math inline">\(f(u,v)\)</span>的缩减，将边<span class="math inline">\((v,u)\)</span>加入到图<span class="math inline">\(G_f\)</span>中，并将其残存容量设置为<span class="math inline">\(c_f(v,u)=f(u,v)\)</span>。也就是说，一条边所能允许的反向流量最多将其正向流量抵消。</li></ul><p>残存网络中的这些反向边允许算法将已经发送出来的流量发送回去。而将流量从同一条边发送回去等同于缩减该条边的流量，这种操作在许多算法中都是必要的。</p><p>更形式化地，假定由一个流网络<span class="math inline">\(G=(V,E)\)</span>，其源结点为<span class="math inline">\(s\)</span>，汇点为<span class="math inline">\(t\)</span>。设<span class="math inline">\(f\)</span>为图<span class="math inline">\(G\)</span>中的一个流，考虑结点对<span class="math inline">\(u,v\in{V}\)</span>，定义残存容量<span class="math inline">\(c_f(u,v)\)</span>如下： <span class="math display">\[c_f(u,v)=\begin{cases}c(u,v)-f(u,v)&amp;\text{if }(u,v)\in{E}\\f(v,u)&amp;\text{if }(v,u)\in{E}\\0&amp;otherwise\end{cases}\tag{26.2}\]</span> 因为假定边<span class="math inline">\((u,v)\in{E}\)</span>意味着<span class="math inline">\((v,u)\notin{E}\)</span>（对流网络的假设），对于每一对边来说，上述公式中只有一种情况成立。下图中，(a)所示的流网络中流<span class="math inline">\(f\)</span>所对应的残存网络如(b)所示。</p><p>给定一个流网络<span class="math inline">\(G=(V,E)\)</span>和一个流<span class="math inline">\(f\)</span>，则由<span class="math inline">\(f\)</span>所诱导的图<span class="math inline">\(G\)</span>的残存网络为<span class="math inline">\(G_f=(V,E_f)\)</span>，其中 <span class="math display">\[E_f=\lbrace(u,v)\in{V\times{V}}:c_f(u,v)&gt;0\rbrace\]</span> 也就是说，残存网络的每条边或<strong>残存边</strong>，必须允许大于0的流量通过。图(a)给出了流网络<span class="math inline">\(G\)</span>和流量<span class="math inline">\(f\)</span>，图(b)描述的是对应的残存网络<span class="math inline">\(G_f\)</span>。<span class="math inline">\(E_f\)</span>中的边要么是<span class="math inline">\(E\)</span>中原有的边，要么是其反向边，因此有 <span class="math display">\[|E_f|\le2|E|\]</span></p><p><img title="最大流问题以及残存网络" data-src="/uploads/posts/maximum-flow-problem.png"></p><p>可以在残存网络中定义一个流，它满足流的定义，但是针对的是残存网络<span class="math inline">\(G_f\)</span>中的容量<span class="math inline">\(c_f\)</span>。残存网络中的一个流指出的是一条路线图：如何在原来的流网络中增加流。如果<span class="math inline">\(f\)</span>是<span class="math inline">\(G\)</span>的一个流，<span class="math inline">\(f^\prime\)</span>是对应的残存网络<span class="math inline">\(G_f\)</span>中的一个流，定义<span class="math inline">\(f\uparrow{f^\prime}\)</span>为流<span class="math inline">\(f^\prime\)</span>对流<span class="math inline">\(f\)</span>的<strong>递增</strong>（augmentation），它是一个从<span class="math inline">\(V\times{V}\)</span>到<span class="math inline">\(\mathbb{R}\)</span>的函数，其定义如下： <span class="math display">\[(f\uparrow{f^\prime})(u,v)=\begin{cases}f(u,v)+f^\prime(u,v)-f^\prime(v,u)&amp;if (u,v)\in{E}\\0&amp;otherwise\end{cases}\tag{26.4}\]</span></p><p>该定义背后的直观解释遵循残存网络的定义。因为在残存网络中将流量发送到反向边上等同于在原来的网络中缩减流量，所以将边<span class="math inline">\((u,v)\)</span>的流量增加了<span class="math inline">\(f^\prime(u,v)\)</span>，但减少了<span class="math inline">\(f^\prime(v,u)\)</span>。在残存网络中将流量推送回去也称为<strong>抵消操作</strong>（cancellation）。例如，如果将5货箱的冰球从城市<span class="math inline">\(u\)</span>发送到城市<span class="math inline">\(v\)</span>，同时将2货箱冰球从城市<span class="math inline">\(v\)</span>发送到城市<span class="math inline">\(u\)</span>，那么可以等价（以最后结果来看）地将3货箱冰球从城市<span class="math inline">\(u\)</span>发送到城市<span class="math inline">\(v\)</span>，而不从城市<span class="math inline">\(v\)</span>发送货箱到城市<span class="math inline">\(u\)</span>。这类抵消操作对于任何最大流算法来说都是非常关键的。</p><blockquote><p>引理26.1</p><p>设<span class="math inline">\(G=(V,E)\)</span>为一个流网络，源结点为<span class="math inline">\(s\)</span>，汇点为<span class="math inline">\(t\)</span>，设<span class="math inline">\(f\)</span>为<span class="math inline">\(G\)</span>中的一个流。设<span class="math inline">\(G_f\)</span>为由流<span class="math inline">\(f\)</span>所诱导的<span class="math inline">\(G\)</span>的残存网络，设<span class="math inline">\(f^\prime\)</span>为<span class="math inline">\(G_f\)</span>中的一个流。那么式(26.4)所定义的函数<span class="math inline">\(f\uparrow{f^\prime}\)</span>是<span class="math inline">\(G\)</span>的一个流，其值<span class="math inline">\(|f\uparrow{f^\prime}|=|f|+|f^\prime|\)</span>。</p></blockquote><p><strong>证明</strong>：首先证明<span class="math inline">\(f\uparrow{f^\prime}\)</span>是<span class="math inline">\(G\)</span>的一个流，即满足流的两条性质：容量限制和流量守恒。</p><p>对于容量限制，注意到，如果边<span class="math inline">\((u,v)\in{E}\)</span>，则<span class="math inline">\(c_f(v,u)=f(u,v)\)</span>。而且<span class="math inline">\(f^\prime(v,u)\le{c_f(v,u)}=f(u,v)\)</span>。因此， <span class="math display">\[\begin{aligned}(f\uparrow{f^\prime})(u,v)&amp;=f(u,v)+f^\prime(u,v)-f^\prime(v,u)&amp;\text{(by equation(26.4))}\\&amp;\ge{f(u,v)+f^\prime(u,v)}-f(u,v)&amp;\text{(because }f^\prime(v,u)\le{f(u,v)}\text{)}\\&amp;=f^\prime(u,v)\\&amp;\ge0\end{aligned}\]</span> 此外， <span class="math display">\[\begin{aligned}(f\uparrow{f^\prime})(u,v)&amp;=f(u,v)+f^\prime(u,v)-f^\prime(v,u)&amp;\text{(by equation(26.4))}\\&amp;\le{f(u,v)+f^\prime(u,v)}&amp;\text{(because flows are nonnegative}\\&amp;\le{f(u,v)+c_f(u,v)}&amp;\text{(capacity constraint)}\\&amp;=f(u,v)+c(u,v)-f(u,v)&amp;\text{(by definition (26.2))}\\&amp;=c(u,v)\end{aligned}\]</span></p><p>对于流量守恒性质，因为<span class="math inline">\(f\)</span>和<span class="math inline">\(f^\prime\)</span>均遵守流量守恒性质，所以有<span class="math inline">\(f(u,v)=f(v,u)\)</span>和<span class="math inline">\(f^\prime(u,v)=f^\prime(v,u)\)</span>。因此，对于所有的结点<span class="math inline">\(u\in{V-\lbrace{s,t}\rbrace}\)</span>，有 <span class="math display">\[\begin{aligned}\sum_{v\in{V}}(f\uparrow{f^\prime})(u,v)&amp;=\sum_{v\in{V}}(f(u,v)+f^\prime(u,v)-f^\prime(v,u))\\&amp;=\sum_{v\in{V}}f(u,v)+\sum_{v\in{V}}f^\prime(u,v)-\sum_{v\in{V}}f^\prime(v,u)\\&amp;=\sum_{v\in{V}}f(v,u)+\sum_{v\in{V}}f^\prime(v,u)-\sum_{v\in{V}}f^\prime(u,v)\\&amp;=\sum_{v\in{V}}(f(v,u)+f^\prime(v,u)-f^\prime(u,v))\\&amp;=\sum_{v\in{V}}(f\uparrow{f^\prime})(v,u)\end{aligned}\]</span></p><p>最后，计算<span class="math inline">\(f\uparrow{f^\prime}\)</span>的值。将顶点集合分<span class="math inline">\(V_1\)</span>和<span class="math inline">\(V_2\)</span>两个集合。定义<span class="math inline">\(V_1=\lbrace{v:(s,v)\in{E}}\rbrace\)</span>为有边从源结点<span class="math inline">\(s\)</span>到达的结点集合，<span class="math inline">\(V_2=\lbrace{v:(v,s)\in{E}}\rbrace\)</span>为有边通往<span class="math inline">\(s\)</span>的结点集合，有<span class="math inline">\(V_1\bigcup{V_2}\subseteq{V}\)</span>。并且因为不允许有反平行边，又有<span class="math inline">\(V_1\bigcap{V_2}=\varnothing\)</span>。现在来计算 <span class="math display">\[\begin{aligned}|f\uparrow{f^\prime}|&amp;=\sum_{v\in{V}}(f\uparrow{f^\prime})(s,v)-\sum_{v\in{V}}(f\uparrow{f^\prime})(v,s)\\&amp;=\sum_{v\in{V_1\cup{V_2}}}(f\uparrow{f^\prime})(s,v)-\sum_{v\in{V_1\cup{V_2}}}(f\uparrow{f^\prime})(v,s)\\\end{aligned}\tag{26.5}\]</span> 回忆之间的内容，对于边<span class="math inline">\((u,v)\notin{E}\)</span>，定义<span class="math inline">\(f(u,v)=0\)</span>，因此有<span class="math inline">\(f(s,v)=0\text{, if }{v\in{V_2}}\)</span>和<span class="math inline">\(f(v,s)=0\text{, if }{v\in{V_1}}\)</span>。现在将<span class="math inline">\(f\uparrow{f^\prime}\)</span>的定义应用到式(26.5)上，然后对和值项进行重新排序与重组可以获得： <span class="math display">\[\begin{aligned}|f\uparrow{f^\prime}|&amp;=\sum_{v\in{V_1}}(f\uparrow{f&#39;})(s,v)-\sum_{v\in{V_2}}(f\uparrow{f&#39;})(v,s)\\&amp;=\sum_{v\in{V_1}}(f(s,v)+f&#39;(s,v)-f&#39;(v,s))-\sum_{v\in{V_2}}(f(v,s)+f&#39;(v,s)-f&#39;(s,v))\\&amp;=\sum_{v\in{V_1}}f(s,v)-\sum_{v\in{V_2}}f(v,s)+\sum_{v\in{V_1}}f&#39;(s,v)+\sum_{v\in{V_2}}f&#39;(s,v)-\sum_{v\in{V_1}}f&#39;(v,s)-\sum_{v\in{V_2}}f&#39;(v,s)\\&amp;=\sum_{v\in{V_1}}f(s,v)-\sum_{v\in{V_2}}f(v,s)+\sum_{v\in{V_1\bigcup{V_2}}}f&#39;(s,v)-\sum_{v\in{V_1\bigcup{V_2}}}f&#39;(v,s)\\&amp;=\sum_{v\in{V}}f(s,v)-\sum_{v\in{V}}f(v,s)+\sum_{v\in{V}}f&#39;(s,v)-\sum_{v\in{V}}f&#39;(v,s)\\&amp;=|f|+|f&#39;|\end{aligned}\]</span></p><h2 id="增广路径">增广路径</h2><p>给定流网络<span class="math inline">\(G=(V,E)\)</span>和流<span class="math inline">\(f\)</span>，增广路径<span class="math inline">\(p\)</span>是残存网络<span class="math inline">\(G_f\)</span>中一条从源结点到汇点<span class="math inline">\(t\)</span>的简单路径。根据残存网络的定义，对于一条增广路径上的边<span class="math inline">\((u,v)\)</span>，可以增加其流量的幅度最大为<span class="math inline">\(c_f(u,v)\)</span>，而不会违反原始流网络<span class="math inline">\(G\)</span>中对边<span class="math inline">\((u,v)\)</span>或<span class="math inline">\((v,u)\)</span>的容量限制。</p><p>上图(b)中阴影覆盖的路径是一条增广路径。如果将图中的残存网络<span class="math inline">\(G_f\)</span>看作一个流网络，那么可以对这条路径上每条边的流量增加4个单位，而不会违反容量限制，因为该条路径上最小的残存容量是<span class="math inline">\(c_f(v_2,v_3)=4\)</span>。称在一条增广路径<span class="math inline">\(p\)</span>上能够为每条边增加的流量的最大值为路径<span class="math inline">\(p\)</span>的<strong>残存容量</strong>，该容量由下面的表达式给出： <span class="math display">\[c_f(p)=min\lbrace{c_f(u,v):(u,v)\text{ 属于路径 }p}\rbrace\]</span></p><p>下面精确阐述残存网络中的流：</p><blockquote><p>引理26.2</p><p>设<span class="math inline">\(G=(V,E)\)</span>为一个流网络，设<span class="math inline">\(f\)</span>为<span class="math inline">\(G\)</span>中的一个流，设<span class="math inline">\(p\)</span>为残存网络<span class="math inline">\(G_f\)</span>中的一条增广路径。定义一个函数<span class="math inline">\(f_p:V\times{V}\rightarrow\mathbb{R}\)</span>如下： <span class="math display">\[f_p(u,v)=\begin{cases}c_f(p)&amp;\text{if }(u,v)\text{ is on }p\\0&amp;otherwise\end{cases}\tag{26.8}\]</span> 则<span class="math inline">\(f_p\)</span>是残存网络<span class="math inline">\(G_f\)</span>中的一个流，其值为<span class="math inline">\(|f_p|=c_f(p)&gt;0\)</span>。</p></blockquote><p>式(26.8)表示，残存网络中在增广路径<span class="math inline">\(p\)</span>上的边的流量等于残存容量<span class="math inline">\(c_f(p)\)</span>，不在增广路径<span class="math inline">\(p\)</span>上的边的流量为0。</p><p>下面的推论证明，如果将流<span class="math inline">\(f\)</span>增加<span class="math inline">\(f_p\)</span>的量，则将获得<span class="math inline">\(G\)</span>的另一个流，该流的值更加接近最大值。</p><blockquote><p>推论26.3</p><p>设<span class="math inline">\(G=(V,E)\)</span>为一个流网络，设<span class="math inline">\(f\)</span>为<span class="math inline">\(G\)</span>中的一个流，设<span class="math inline">\(p\)</span>为残存网络<span class="math inline">\(G_f\)</span>中的一条增广路径。设<span class="math inline">\(f_p\)</span>由式(26.8)所定义，假定将<span class="math inline">\(f\)</span>增加<span class="math inline">\(f_p\)</span>的量，则函数<span class="math inline">\(f\uparrow{f_p}\)</span>是图<span class="math inline">\(G\)</span>中的一个流，其值为<span class="math inline">\(|f\uparrow{f_p}|=|f|+|f_p|&gt;|f|\)</span>。</p></blockquote><p><strong>证明</strong>：根据引理26.1和引理26.2可得到上述结论。</p><h2 id="流网络的切割">流网络的切割</h2><p>Ford-Fulkerson方法的核心就是沿着增广路径重复增加路径上的流量，直到找到最大流为止。如何知道在算法中终止时，确实找到了一个最大流呢？最大流最小割定理告诉我们，一个流是最大流当且仅当其残存网络中不包含任何增广路径。为了证明这个定理，首先来探讨一下流网络中的切割概念。</p><p>流网络<span class="math inline">\(G=(V,E)\)</span>中的一个切割<span class="math inline">\((S,T)\)</span>将结点集合<span class="math inline">\(V\)</span>划分为<span class="math inline">\(S\)</span>和<span class="math inline">\(T=V-S\)</span>两个集合，使得<span class="math inline">\(s\in{S},t\in{T}\)</span>。若<span class="math inline">\(f\)</span>是一个流，则定义横跨切割<span class="math inline">\((S,T)\)</span>的<strong>净流量</strong><span class="math inline">\(f(S,T)\)</span>如下： <span class="math display">\[f(S,T)=\sum_{u\in{S}}\sum_{v\in{T}}f(u,v)-\sum_{u\in{S}}\sum_{v\in{T}}f(v,u)\tag{26.9}\]</span> 切割<span class="math inline">\((S,T)\)</span>的<strong>容量</strong>是： <span class="math display">\[c(S,T)=\sum_{u\in{S}}\sum_{v\in{T}}c(u,v)\tag{26.10}\]</span> 一个网络的最小切割是整个网络中<strong>容量最小</strong>的切割。</p><p>流的定义和切割容量的定义之间存在着不对称性，这种不对称性是有意而为，并且很重要。</p><ul><li>对于容量，计算从集合<span class="math inline">\(S\)</span>发出进入集合<span class="math inline">\(T\)</span>的边的容量，而忽略反方向边上的容量。</li><li>对于流，考虑的则是从<span class="math inline">\(S\)</span>到<span class="math inline">\(T\)</span>的流量减去从<span class="math inline">\(T\)</span>到<span class="math inline">\(S\)</span>的反方向的流量。</li></ul><p>下图描述的是流网络的一个切割（<span class="math inline">\(\lbrace{s,v_1,v_2}\rbrace,\lbrace{v_3,v_4,t}\rbrace\)</span>）。横跨该切割的净流量是<span class="math inline">\(f(v_1,v_3)+f(v_2,v_4)-f(v_3,v_2)=12+11-4=19\)</span>。该切割的容量是<span class="math inline">\(c(v_1,v_3)+c(v_2,v_4)=12+14=26\)</span>。</p><p><img title="流网络的一个ST切割" data-src="/uploads/posts/s-t-cut-in-flow-network.png"></p><blockquote><p>引理26.4</p><p>设<span class="math inline">\(f\)</span>为流网络<span class="math inline">\(G\)</span>的一个流，该流网络的源结点为<span class="math inline">\(s\)</span>，汇点为<span class="math inline">\(t\)</span>，设<span class="math inline">\((S,T)\)</span>为流网络<span class="math inline">\(G\)</span>的任意切割，则横跨切割<span class="math inline">\((S,T)\)</span>的净流量为<span class="math inline">\(f(S,T)=|f|\)</span>。</p></blockquote><p>直观上，从源结点<span class="math inline">\(s\)</span>发往汇点<span class="math inline">\(t\)</span>的流量必然经过切割的边界（图中虚线）,并且流满足流量守恒性质，表明所有从源结点<span class="math inline">\(s\)</span>发出的流量最终都会流入汇点<span class="math inline">\(t\)</span>。因此所有横跨边界的净流量等于流的值。</p><p>形式化地：对于任意结点<span class="math inline">\(u\in{V-\lbrace{s,t}\rbrace}\)</span>，重写（将右边的子式移到左边）流量守恒性质如下： <span class="math display">\[\begin{aligned}\sum_{v\in{V}}f(u,v)-\sum_{v\in{V}}f(v,u)=0\qquad{u\in{V-\lbrace{s,t}\rbrace}}\end{aligned}\tag{26.11}\]</span> 针对所有结点<span class="math inline">\(S-\lbrace{s}\rbrace\)</span>求和： <span class="math display">\[\sum_{u\in{S-\{s\}}}(\sum_{v\in{V}}f(u,v)-\sum_{v\in{V}}f(v,u))=0\]</span> 根据式(26.1)对<span class="math inline">\(|f|\)</span>的定义，将上式的左项加进来： <span class="math display">\[\begin{aligned}|f|&amp;=\sum_{v\in{V}}f(s,v)-\sum_{v\in{V}}f(v,s)+\sum_{u\in{S-\{s\}}}(\sum_{v\in{V}}f(u,v)-\sum_{v\in{V}}f(v,u))\\&amp;=\sum_{v\in{V}}f(s,v)-\sum_{v\in{V}}f(v,s)+\sum_{u\in{S-\{s\}}}\sum_{v\in{V}}f(u,v)-\sum_{u\in{S-\{s\}}}\sum_{v\in{V}}f(v,u)\\&amp;=\sum_{v\in{V}}(f(s,v)+\sum_{u\in{S-\{s\}}}f(u,v))-\sum_{v\in{V}}(f(v,s)+\sum_{u\in{S-\{s\}}}f(v,s))\\&amp;=\sum_{v\in{V}}\sum_{u\in{S}}f(u,v)-\sum_{v\in{V}}\sum_{u\in{S}}f(v,u)\end{aligned}\]</span></p><p>因为<span class="math inline">\(V=S\bigcup{T},S\bigcap{T}=\varnothing\)</span>，将上述表达式中针对集合<span class="math inline">\(V\)</span>的求和分解为针对<span class="math inline">\(S\)</span>和<span class="math inline">\(T\)</span>的求和，得到： <span class="math display">\[\begin{aligned}|f|&amp;=\sum_{v\in{S}}\sum_{u\in{S}}f(u,v)+\sum_{v\in{T}}\sum_{u\in{S}}f(u,v)-\sum_{v\in{S}}\sum_{u\in{S}}f(v,u)-\sum_{v\in{T}}\sum_{u\in{S}}f(v,u)\\&amp;=\sum_{v\in{T}}\sum_{u\in{S}}f(u,v)-\sum_{v\in{T}}\sum_{u\in{S}}f(v,u)+\color{red}{\Bigl(\sum_{v\in{S}}\sum_{u\in{S}}f(u,v)-\sum_{v\in{S}}\sum_{u\in{S}}f(v,u)\Bigr)}\end{aligned}\]</span> 上式表达式括号里面的两个求和项实际上是一样的。因此，这些求和项相互抵消，得到： <span class="math display">\[|f|=\sum_{v\in{T}}\sum_{u\in{S}}f(u,v)-\sum_{v\in{T}}\sum_{u\in{S}}f(v,u)=f(S,T)\]</span></p><blockquote><p>推论26.5</p><p>流网络<span class="math inline">\(G\)</span>中任意流<span class="math inline">\(f\)</span>的值不能超过<span class="math inline">\(G\)</span>的任意切割容量。</p></blockquote><p><strong>证明</strong>：设<span class="math inline">\((S,T)\)</span>为流网络<span class="math inline">\(G\)</span>的任意切割，设<span class="math inline">\(f\)</span>为<span class="math inline">\(G\)</span>中的任意流。根据引理26.4和容量限制性质，有 <span class="math display">\[\begin{aligned}|f|=f(S,T)&amp;=\sum_{u\in{S}}\sum_{v\in{T}}f(u,v)-\sum_{u\in{S}}\sum_{v\in{T}}f(v,u)\\&amp;\le\sum_{u\in{}S}\sum_{v\in{T}}f(u,v)\le\sum_{u\in{}S}\sum_{v\in{T}}c(u,v)=c(S,T)\end{aligned}\]</span></p><h2 id="最大流最小割定理">最大流最小割定理</h2><blockquote><p>定理26.6 （最大流最小割定理）</p><p>设<span class="math inline">\(f\)</span>为流网络<span class="math inline">\(G=(V,E)\)</span>中的一个流，该流网络的源结点为<span class="math inline">\(s\)</span>，汇点为<span class="math inline">\(t\)</span>，则下面的条件是等价的：</p><ol type="1"><li><span class="math inline">\(f\)</span>是<span class="math inline">\(G\)</span>的一个最大流。</li><li>残存网络<span class="math inline">\(G_f\)</span>不包含任何增广路径。</li><li><span class="math inline">\(|f|=c(S,T)\)</span>，其中<span class="math inline">\((S,T)\)</span>是流网络的某个切割。</li></ol></blockquote><p><strong>证明</strong>：</p><ul><li><p>(1)<span class="math inline">\(\Rightarrow\)</span>(2)：使用反证法。假定<span class="math inline">\(f\)</span>是<span class="math inline">\(G\)</span>的一个最大流，但残存网络<span class="math inline">\(G_f\)</span>同时包含一条增广路径<span class="math inline">\(p\)</span>。那么根据推论26.3，对<span class="math inline">\(f\)</span>增加流量<span class="math inline">\(f_p\)</span>所形成的流是<span class="math inline">\(G\)</span>中的一个值严格大于<span class="math inline">\(|f|\)</span>的流，这与<span class="math inline">\(f\)</span>是最大流的假设矛盾。</p></li><li><p>(2)<span class="math inline">\(\Rightarrow\)</span>(3)：假设<span class="math inline">\(G_f\)</span>不包含任何增广路径，也就是说，在残存网络<span class="math inline">\(G_f\)</span>中不存在任何从源结点<span class="math inline">\(s\)</span>到汇点<span class="math inline">\(t\)</span>的路径。定义<span class="math inline">\(S=\lbrace{v\in{V}:\text{在 }G_f\text{中存在从 }s\text{到}v\text{的路径}}\rbrace,T=V-S\)</span>。显然，<span class="math inline">\(s\in{S}\)</span>，而因为<span class="math inline">\(G_f\)</span>中不存在从<span class="math inline">\(s\)</span>到<span class="math inline">\(t\)</span>的路径（增广路径），所以<span class="math inline">\(t\notin{S}\)</span>。因此，划分<span class="math inline">\((S,T)\)</span>是流网络<span class="math inline">\(G\)</span>的一个切割。下面证明<span class="math inline">\(|f|=c(S,T)\)</span>。</p><p>考虑一对结点<span class="math inline">\(u\in{S}\)</span>和<span class="math inline">\(v\in{T}\)</span>。</p><ul><li>如果<span class="math inline">\((u,v)\in{E}\)</span>，则必有<span class="math inline">\(f(u,v)=c(u,v)\)</span>，否则边<span class="math inline">\((u,v)\)</span>将属于<span class="math inline">\(E_f\)</span>，在残存网络中存在一条路径<span class="math inline">\(s\rightsquigarrow{u}\rightarrow{v}\)</span>到达结点<span class="math inline">\(v\)</span>，即<span class="math inline">\(v\in{S}\)</span>，这与结点<span class="math inline">\(v\in{T}\)</span>矛盾。</li><li>如果<span class="math inline">\((v,u)\in{E}\)</span>，则必有<span class="math inline">\(f(v,u)=0\)</span>，否则边<span class="math inline">\((u,v)\)</span>将属于<span class="math inline">\(E_f\)</span>，得出<span class="math inline">\(v\in{S}\)</span>，与<span class="math inline">\(v\in{T}\)</span>矛盾。</li><li>如果边<span class="math inline">\((u,v)\)</span>和<span class="math inline">\((v,u)\)</span>都不在集合<span class="math inline">\(E\)</span>中，则<span class="math inline">\(f(u,v)=f(v,u)=0\)</span>。</li></ul></li></ul><p>因此有 <span class="math display">\[\begin{aligned}f(S,T)&amp;=\sum_{u\in{S}}\sum_{v\in{T}}f(u,v)-\sum_{u\in{S}}\sum_{v\in{T}}f(v,u)\\&amp;=\sum_{u\in{S}}\sum_{v\in{T}}f(u,v)-\sum_{u\in{S}}\sum_{v\in{T}}0\\&amp;=c(S,T)\end{aligned}\]</span></p><ul><li>(3)<span class="math inline">\(\Rightarrow\)</span>(1)：根据推论26.5，对于所有切割<span class="math inline">\((S,T)\)</span>，<span class="math inline">\(|f|\le{c(S,T)}\)</span>。因此，条件<span class="math inline">\(|f|=c(S,T)\)</span>隐含着<span class="math inline">\(|f|\)</span>是一个最大流。</li></ul><h1 id="基本的ford-fulkerson算法">基本的Ford-Fulkerson算法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FORD-FULKERSON(G, s, t):</span><br><span class="line">    <span class="keyword">for</span> each edge (u,v) <span class="keyword">in</span> G.E:  <span class="comment"># 将流f初始化为0</span></span><br><span class="line">        (u,v).f = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> there exists a path p <span class="keyword">from</span> s to t <span class="keyword">in</span> the residual network:  <span class="comment"># 寻找增广路径</span></span><br><span class="line">        c_f(p) = min&#123;c_f(u,v):(u,v) <span class="keyword">is</span> <span class="keyword">in</span> p&#125;   <span class="comment"># 残存容量</span></span><br><span class="line">        <span class="keyword">for</span> each edge (u,v) <span class="keyword">in</span> p:              <span class="comment"># 修改原始流网络中的流</span></span><br><span class="line">            <span class="keyword">if</span> (u,v) <span class="keyword">in</span> E:</span><br><span class="line">                (u,v).f = (u,v).f + c_f(p)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                (v,u).f = (v,u).f - c_f(p)</span><br></pre></td></tr></table></figure><p><code>FORD-FULKERSON</code>算法仅是对<code>FORD-FULKERSON-METHOD</code>过程的简单扩展。下图描述的是一个样本运行过程的每次迭代的结果。</p><p><img title="Ford-Fulkerson示例" data-src="/uploads/posts/ford-fulkerson-example.png"></p><h2 id="分析">分析</h2><p>假定所选择的任意增广路径和所有的容量都是整数（如果容量为有理数，则可以通过乘以某个系数来将其转换为整数；如果容量为无理数，则Ford-Fulkerson方法可能不会终止）。</p><ul><li>初始化：对每条边赋初始值0，成本是<span class="math inline">\(O(E)\)</span>。</li><li>寻找增广路径：如果用来实现流网络<span class="math inline">\(G=(V,E)\)</span>的数据结构是合理的，使用深度优先搜索或广度优先搜索在一个残存网络中找到一条路径的时间应是<span class="math inline">\(O(V+E)=O(E)\)</span>。</li><li><code>while</code>循环：执行一遍的时间为<span class="math inline">\(O(E)\)</span>。如果<span class="math inline">\(f^\star\)</span>表示网络中的一个最大流，则在<code>FORD-FULKERSON</code>算法中，<code>while</code>循环的次数最多为<span class="math inline">\(|f^\star|\)</span>次，因为流量值在每次迭代中最少增加一个单位。</li></ul><p>从而整个<code>FORD-FULKERSON</code>算法的运行时间为<span class="math inline">\(O(E|f^\star|)\)</span>。</p><p>当容量都是整数值且最优的流量值<span class="math inline">\(|f^\star|\)</span>较小时，<code>FORD-FULKERSON</code>算法的运行时间相当不错。下图描述的是当<span class="math inline">\(|f^\star|\)</span>的取值较大时可能发生的情况。该网络的一个最大流取值为2 000 000，1 000 000单位的流量流经路径<span class="math inline">\(s\rightarrow{u}\rightarrow{t}\)</span>，另外1 000 000单位的流量流经路径<span class="math inline">\(s\rightarrow{v}\rightarrow{t}\)</span>。</p><p>如果<code>FORD-FULKERSON</code>算法找到的第一条增广路径为<span class="math inline">\(s\rightarrow{u}\rightarrow{v}\rightarrow{t}\)</span>，如图(a)所示，则在第一次迭代后，流的值为1。产生的残存网络如图(b)所示，找到的第二条增广路径为<span class="math inline">\(s\rightarrow{v}\rightarrow{u}\rightarrow{t}\)</span>，然后流的值将为2。图(c)描述的是结果残存网络。</p><p>如此继续下去，在每个奇数次迭代中，选择增广路径<span class="math inline">\(s\rightarrow{u}\rightarrow{v}\rightarrow{t}\)</span>，在每个偶数次迭代中，选择增广路径<span class="math inline">\(s\rightarrow{v}\rightarrow{u}\rightarrow{t}\)</span>，这样将一共执行2 000 000次递增操作，每次将流量增加1个单位。</p><p><img title="循环次数很大的一个示例问题" data-src="/uploads/posts/ford-fulkerson-analysis.png"></p><h1 id="edmonds-karp算法">Edmonds-Karp算法</h1><p>使用广度优先搜索寻找增广路径可以改善<code>FORD-FULKERSON</code>算法的效率。广度优先搜索得到的增广路径是一条从源结点<span class="math inline">\(s\)</span>到汇点<span class="math inline">\(t\)</span>的<strong>最短</strong>（边数最少）路径。称如此实现的Ford-Fulkerson方法为Edmonds-Karp算法。该算法的运行时间为<span class="math inline">\(O(VE^2)\)</span>，只与流网络的规模有关，与最优的流量值无关。</p><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_f</span><span class="params">(graph)</span>:</span></span><br><span class="line">    print(<span class="string">'max flow:'</span>, graph.graph[<span class="string">'max_flow'</span>])</span><br><span class="line">    fmt = <span class="string">'&#123;0:&lt;4s&#125; &#123;1:&lt;4s&#125; &#123;2:&lt;4s&#125; &#123;3:&lt;8s&#125;\n'</span></span><br><span class="line">    title = fmt.format(<span class="string">'u'</span>, <span class="string">'v'</span>, <span class="string">'flow'</span>, <span class="string">'capacity'</span>)</span><br><span class="line">    data = <span class="string">''</span>.join(</span><br><span class="line">        fmt.format(str(u), str(v), str(attr[<span class="string">'flow'</span>]), str(attr[<span class="string">'capacity'</span>])) <span class="keyword">for</span> u, v, attr <span class="keyword">in</span> graph.edges(data=<span class="literal">True</span>) <span class="keyword">if</span></span><br><span class="line">        attr[<span class="string">'flow'</span>] &gt; <span class="number">0</span>)</span><br><span class="line">    print(title + data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_path_dfs</span><span class="params">(graph, s, t, p)</span>:</span></span><br><span class="line">    <span class="string">"""寻找增广路径，深度优先搜索（递归实现）"""</span></span><br><span class="line">    <span class="keyword">if</span> s == t:</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> graph.get_e(s):</span><br><span class="line">        residuals = e.c - e.f</span><br><span class="line">        <span class="keyword">if</span> residuals &gt; <span class="number">0</span> <span class="keyword">and</span> e <span class="keyword">not</span> <span class="keyword">in</span> p:</span><br><span class="line">            p.add(e)  <span class="comment"># 将当前邻接边加入path，向sink寻路</span></span><br><span class="line">            result = find_path_dfs(graph, e.v, t, p)</span><br><span class="line">            <span class="keyword">if</span> result <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">            p.remove(e)  <span class="comment"># 若没找到通向sink的路，从path中移除当前边，循环下一条邻接边</span></span><br><span class="line">    <span class="comment"># 未找到路径，将返回默认值None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_path_bfs</span><span class="params">(graph, s, t, p)</span>:</span></span><br><span class="line">    <span class="string">"""Ford-Fulkerson Method的一种特殊实现：Edmonds-Karp algorithm</span></span><br><span class="line"><span class="string">    使用广度优先搜索寻找增广路径，寻找一条边数最少的增广路径"""</span></span><br><span class="line">    previous, visit, q = &#123;s: <span class="literal">None</span>&#125;, set(), Queue()</span><br><span class="line">    q.put(s)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">        u = q.get()</span><br><span class="line">        visit.add(u)  <span class="comment"># visit用来记录结点是否曾被访问过</span></span><br><span class="line">        <span class="keyword">if</span> u == t:  <span class="comment"># 输出路径</span></span><br><span class="line">            pre = previous[t]</span><br><span class="line">            <span class="keyword">while</span> pre <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                p.add((pre, u))  <span class="comment"># path的顺序无影响</span></span><br><span class="line">                u = pre</span><br><span class="line">                pre = previous[pre]</span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line">        <span class="keyword">for</span> v, attr <span class="keyword">in</span> graph[u].items():</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> visit:</span><br><span class="line">                residual = attr[<span class="string">'capacity'</span>] - attr[<span class="string">'flow'</span>]  <span class="comment"># 判断残存容量</span></span><br><span class="line">                <span class="keyword">if</span> residual &gt; <span class="number">0</span>:</span><br><span class="line">                    q.put(v)</span><br><span class="line">                    previous[v] = u  <span class="comment"># previous记录前驱结点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_path</span><span class="params">(graph, s, t, path)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> find_path_bfs(graph, s, t, path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_flow</span><span class="params">(graph, s, t)</span>:</span></span><br><span class="line">    <span class="string">"""求最大流"""</span></span><br><span class="line">    p = find_path(graph, s, t, set())</span><br><span class="line">    <span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        augment_flow = min(graph[u][v][<span class="string">'capacity'</span>] - graph[u][v][<span class="string">'flow'</span>] <span class="keyword">for</span> u, v <span class="keyword">in</span> p)</span><br><span class="line">        <span class="keyword">for</span> u, v <span class="keyword">in</span> p:</span><br><span class="line">            graph[u][v][<span class="string">'flow'</span>] += augment_flow</span><br><span class="line">            graph[v][u][<span class="string">'flow'</span>] -= augment_flow</span><br><span class="line">        p = find_path(graph, s, t, set())</span><br><span class="line">    graph.graph[<span class="string">'max_flow'</span>] = sum(attr[<span class="string">'flow'</span>] <span class="keyword">for</span> attr <span class="keyword">in</span> graph[s].values())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_graph</span><span class="params">(graph, vertices, edges)</span>:</span></span><br><span class="line">    graph.add_nodes_from(vertices)</span><br><span class="line">    <span class="keyword">for</span> u, v, c <span class="keyword">in</span> edges:</span><br><span class="line">        graph.add_edges_from([(u, v, &#123;<span class="string">'capacity'</span>: c&#125;), (v, u, &#123;<span class="string">'capacity'</span>: <span class="number">0</span>&#125;)], flow=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    g = nx.DiGraph()</span><br><span class="line">    v = <span class="string">'s1234t'</span></span><br><span class="line">    e = [(<span class="string">'s'</span>, <span class="string">'1'</span>, <span class="number">6</span>), (<span class="string">'s'</span>, <span class="string">'3'</span>, <span class="number">5</span>), (<span class="string">'s'</span>, <span class="string">'4'</span>, <span class="number">1</span>), (<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="number">5</span>), (<span class="string">'1'</span>, <span class="string">'4'</span>, <span class="number">2</span>), (<span class="string">'1'</span>, <span class="string">'t'</span>, <span class="number">3</span>),</span><br><span class="line">         (<span class="string">'2'</span>, <span class="string">'t'</span>, <span class="number">5</span>), (<span class="string">'3'</span>, <span class="string">'1'</span>, <span class="number">2</span>), (<span class="string">'3'</span>, <span class="string">'4'</span>, <span class="number">4</span>), (<span class="string">'4'</span>, <span class="string">'2'</span>, <span class="number">3</span>), (<span class="string">'4'</span>, <span class="string">'t'</span>, <span class="number">3</span>)]</span><br><span class="line">    initialize_graph(g, v, e)</span><br><span class="line">    max_flow(g, <span class="string">'s'</span>, <span class="string">'t'</span>)</span><br><span class="line">    print_f(g)</span><br><span class="line"></span><br><span class="line">    g.clear()</span><br><span class="line">    e = [(<span class="string">'s'</span>, <span class="string">'1'</span>, <span class="number">16</span>), (<span class="string">'s'</span>, <span class="string">'2'</span>, <span class="number">13</span>), (<span class="string">'1'</span>, <span class="string">'3'</span>, <span class="number">12</span>), (<span class="string">'2'</span>, <span class="string">'1'</span>, <span class="number">4</span>), (<span class="string">'2'</span>, <span class="string">'4'</span>, <span class="number">14</span>), (<span class="string">'3'</span>, <span class="string">'2'</span>, <span class="number">9</span>),</span><br><span class="line">         (<span class="string">'3'</span>, <span class="string">'t'</span>, <span class="number">20</span>), (<span class="string">'4'</span>, <span class="string">'3'</span>, <span class="number">7</span>), (<span class="string">'4'</span>, <span class="string">'t'</span>, <span class="number">4</span>)]</span><br><span class="line">    initialize_graph(g, v, e)</span><br><span class="line">    max_flow(g, <span class="string">'s'</span>, <span class="string">'t'</span>)</span><br><span class="line">    print_f(g)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">max flow: 11</span><br><span class="line">u    v    flow capacity</span><br><span class="line">s    1    6    6</span><br><span class="line">s    3    5    5</span><br><span class="line">1    2    2    5</span><br><span class="line">1    4    2    2</span><br><span class="line">1    t    3    3</span><br><span class="line">2    t    5    5</span><br><span class="line">3    1    1    2</span><br><span class="line">3    4    4    4</span><br><span class="line">4    2    3    3</span><br><span class="line">4    t    3    3</span><br><span class="line"></span><br><span class="line">max flow: 23</span><br><span class="line">u    v    flow capacity</span><br><span class="line">s    1    12   16</span><br><span class="line">s    2    11   13</span><br><span class="line">1    3    12   12</span><br><span class="line">2    4    11   14</span><br><span class="line">3    t    19   20</span><br><span class="line">4    3    7    7</span><br><span class="line">4    t    4    4</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithms </tag>
            
            <tag> flow network </tag>
            
            <tag> Introduction To Algorithms </tag>
            
            <tag> maximum flow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Python中使用CPLEX</title>
      <link href="/operations-research/cplex-in-python/"/>
      <url>/operations-research/cplex-in-python/</url>
      
        <content type="html"><![CDATA[<h1 id="设置api">设置API</h1><p>从搭建运行环境开始。使用的软件如下：</p><ul><li>ILOG CPLEX Optimization studio 12.9.0 64bit。</li><li>Python3.6.8 64bit。</li></ul><p>安装好ILOG CPLEX Optimization studio后，<a href="https://www.ibm.com/support/knowledgecenter/zh/SSSA5P_12.9.0/ilog.odms.cplex.help/CPLEX/GettingStarted/topics/set_up/Python_setup.html" target="_blank" rel="noopener">设置 CPLEX 的 Python API</a>。</p><h2 id="使用脚本-setup.py">使用脚本 setup.py</h2><p>要在系统上安装 CPLEX-Python 模块，请使用位于 yourCplexhome/python/VERSION/PLATFORM 中的脚本 setup.py。 如果要将 CPLEX-Python 模块安装在非缺省位置，请使用选项 --home 识别安装目录。 例如，要将 CPLEX-Python 模块安装在缺省位置，请从命令行使用以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><p>要安装在目录 yourPythonPackageshome/cplex 中，请从命令行使用以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py install --home yourPythonPackageshome/cplex</span><br></pre></td></tr></table></figure><p>这两个命令（缺省和指定主目录）均会调用 Python 包 distutils。 有关适用于该软件包的其他选项，请参考 Python distutils 的文档。</p><p>设置完成后，若能在Python解释器中导入cplex库（<code>import cplex</code>）说明配置成功。</p><a id="more"></a><p><strong>附</strong>：</p><ol type="1"><li>CPLEX API和Python位数需一致。</li><li>CPLEX Optimization studio 12.9版本不支持32bit。</li><li>如果都安装64bit版本，Python不要选择v3.7，某些库尚不支持Python3.7 64bit。</li></ol><h1 id="hello-cplex">Hello CPLEX</h1><p>cplex中重要的一个类就是Cplex类，它提供了创建、修改、查询最优化问题的一系列方法。关于Cplex类的官方文档点击这里：<a href="https://www.ibm.com/support/knowledgecenter/zh/SSSA5P_12.9.0/ilog.odms.cplex.help/refpythoncplex/html/cplex.Cplex-class.html" target="_blank" rel="noopener">Class Cplex</a>。使用cplex优化一个LP模型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Maximize</span><br><span class="line">3x1 + 5x2</span><br><span class="line">Subject to</span><br><span class="line"> x1 + 7x2 &lt;= 140</span><br><span class="line"> x1 + 2x2 &lt;= 50</span><br><span class="line">3x1 + 2x2 &lt;= 130</span><br><span class="line">Bounds</span><br><span class="line">0 &lt;= x1 &lt;= infinity</span><br><span class="line">0 &lt;= x2 &lt;= infinity</span><br><span class="line">End</span><br></pre></td></tr></table></figure><p>将上述内容保存至文件<code>hello.lp</code>，之后可以直接读取该文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cplex</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    c = cplex.Cplex()</span><br><span class="line">    c.read(<span class="string">'hello.lp'</span>)</span><br><span class="line">    c.solve()</span><br><span class="line">    print(c.solution.get_objective_value(), c.solution.get_values())</span><br></pre></td></tr></table></figure><p>或者直接构建相同的模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cplex</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    c = cplex.Cplex()</span><br><span class="line">    <span class="comment"># 设置优化目标为最大化</span></span><br><span class="line">    c.objective.set_sense(c.objective.sense.maximize)</span><br><span class="line">    <span class="comment"># obj: 目标函数</span></span><br><span class="line">    <span class="comment"># names: 变量名</span></span><br><span class="line">    <span class="comment"># lb: lower bound</span></span><br><span class="line">    <span class="comment"># ub: upper bound</span></span><br><span class="line">    c.variables.add(</span><br><span class="line">        obj=[<span class="number">3</span>, <span class="number">5</span>], names=[<span class="string">'x1'</span>, <span class="string">'x2'</span>],</span><br><span class="line">        lb=[<span class="number">0.0</span>, <span class="number">0.0</span>], ub=[cplex.infinity] * <span class="number">2</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># lin_expr: 线性表达式，约束条件左边</span></span><br><span class="line">    <span class="comment"># senses: 约束条件的比较符号，G|L|E|R，分别表示大于等于|小于等于|等于|区间约束</span></span><br><span class="line">    <span class="comment"># rhs: right hand side，约束条件右边的值</span></span><br><span class="line">    c.linear_constraints.add(</span><br><span class="line">        lin_expr=[([<span class="string">'x1'</span>, <span class="string">'x2'</span>], [<span class="number">1</span>, <span class="number">7</span>]),</span><br><span class="line">                  ([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>]),</span><br><span class="line">                  ([<span class="string">'x1'</span>, <span class="string">'x2'</span>], [<span class="number">3</span>, <span class="number">2</span>])],</span><br><span class="line">        senses=<span class="string">'L'</span> * <span class="number">3</span>,</span><br><span class="line">        rhs=[<span class="number">140.0</span>, <span class="number">50.0</span>, <span class="number">130.0</span>]</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 求解问题，解决方案保存在c.solution变量</span></span><br><span class="line">    c.solve()</span><br><span class="line">    <span class="comment"># 打印目标值和所有变量的值</span></span><br><span class="line">    print(c.solution.get_objective_value(), c.solution.get_values())</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CPXPARAM_Read_DataCheck                          1</span><br><span class="line">Tried aggregator 1 time.</span><br><span class="line">No LP presolve or aggregator reductions.</span><br><span class="line">Presolve time = 0.00 sec. (0.00 ticks)</span><br><span class="line"></span><br><span class="line">Iteration log . . .</span><br><span class="line">Iteration:     1   Dual infeasibility =             0.000000</span><br><span class="line">Iteration:     2   Dual objective     =           175.789474</span><br><span class="line">145.0 [40.0, 5.0]</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 运筹学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cplex </tag>
            
            <tag> python </tag>
            
            <tag> linear programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单源最短路径</title>
      <link href="/notes/introduction-to-algorithms/single-source-shortest-paths/"/>
      <url>/notes/introduction-to-algorithms/single-source-shortest-paths/</url>
      
        <content type="html"><![CDATA[<h1 id="简介">简介</h1><p>最短路径问题（Shortest path problem, SPP）旨在寻找图中两个结点之间的最短路径。本文介绍单源最短路径问题：给定一个图<span class="math inline">\(G=(V,E)\)</span>，我们希望找到从给定源节点<span class="math inline">\(s\)</span>到每个结点<span class="math inline">\(v\in{V}\)</span>的最短路径。广度优先搜索就是权重均为1的单源最短路径问题，根节点（源点）到每个结点的最短距离等于最短路径上的边的条数。单源最短路径问题可以用来解决许多其他问题，其中就包括它的几个变体：</p><ul><li>单目的地最短路径问题：找到从给定结点<span class="math inline">\(v\)</span>到给定目的地结点<span class="math inline">\(t\)</span>的最短路径。如果将图的每条边的方向翻转过来，就可以将这个问题转换为单源最短路径问题。</li><li>单节点对最短路径问题：找到从给定结点<span class="math inline">\(u\)</span>到给定节点<span class="math inline">\(v\)</span>的最短距离。如果解决了针对单个结点<span class="math inline">\(u\)</span>的单源最短路径问题，那么也就解决了这个问题。而且，在该问题的所有已知算法中，最坏情况下的渐进运行时间都和最好的单源最短路径算法的运行时间一样。</li><li>所有结点对最短距离：对于每对结点<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>，找到从结点<span class="math inline">\(u\)</span>到结点<span class="math inline">\(v\)</span>的最短路径。可以针对每个结点运行一遍单源最短路径算法，但可以更快地解决这个问题。此类问题适合使用Floyd-Warshall算法。</li></ul><a id="more"></a><h1 id="最短路径的最优子结构">最短路径的最优子结构</h1><blockquote><p>引理24.1 （最短路径的子路径也是最短路径）</p><p>给定带权重的有向图<span class="math inline">\(G=(V,E)\)</span>和权重函数<span class="math inline">\(w:E\rightarrow{R}\)</span>。设<span class="math inline">\(p=\langle{v_0,v_1,\dots,v_k\rangle}\)</span>为从结点<span class="math inline">\(v_0\)</span>到结点<span class="math inline">\(v_k\)</span>的一条最短路径，并且对于任意的<span class="math inline">\(i\)</span>和<span class="math inline">\(j，0\le{I}\le{j}\le{k}\)</span>，设<span class="math inline">\(p_{ij}=\langle{v_i,v_{i+1},\dots,v_j}\rangle\)</span>为路径<span class="math inline">\(p\)</span>中从结点<span class="math inline">\(v_i\)</span>到结点<span class="math inline">\(v_j\)</span>的子路径。那么<span class="math inline">\(p_{ij}\)</span>是从结点<span class="math inline">\(v_i\)</span>到结点<span class="math inline">\(v_j\)</span>的一条最短路径。</p></blockquote><p><strong>证明</strong>：假设<span class="math inline">\(p\)</span>是从<span class="math inline">\(v_0\)</span>到<span class="math inline">\(v_k\)</span>的一条最短路径。将路径<span class="math inline">\(p\)</span>分解为 <span class="math display">\[v_0\mathop{\rightsquigarrow}^{p_{0i}}v_i\mathop{\rightsquigarrow}^{p_{ij}}v_j\mathop{\rightsquigarrow}^{p_{jk}}v_k\]</span> 则有<span class="math inline">\(w(p)=w(p_{0i})+w(p_{ij})+w(p_{jk})\)</span>。</p><p>假设存在一条从<span class="math inline">\(v_i\)</span>到<span class="math inline">\(v_j\)</span>的路径<span class="math inline">\(p^\prime_{ij}\)</span>，且<span class="math inline">\(w(p^\prime_{ij})&lt;w(p_{ij})\)</span>。</p><p>则</p><p><span class="math display">\[v_0\mathop{\rightsquigarrow}^{p_{0i}}v_i\mathop{\rightsquigarrow}^{\color{red}{p^\prime_{ij}}}v_j\mathop{\rightsquigarrow}^{p_{jk}}v_k\]</span> 是一条从结点<span class="math inline">\(v_0\)</span>到结点<span class="math inline">\(v_k\)</span>的权重为<span class="math inline">\(w(p^\prime)=w(p_{0i})+w(p^\prime_{ij})+w(p_{jk})\)</span>的路径，而该权重小于<span class="math inline">\(w(p)\)</span>。</p><p>这与<span class="math inline">\(p\)</span>是从<span class="math inline">\(v_0\)</span>到<span class="math inline">\(v_k\)</span>的一条最短路径这一假设矛盾。</p><h1 id="环路">环路</h1><p>不失一般性，我们可以假定找到的最短路径中没有环路，即它们都是简单路径。</p><ul><li><p>若一条路径包含权重为正值的环路，那么将环路从路径上删除就可以得到一条源点和终点相同的权重更小的路径。</p></li><li><p>若包含权重为负值的环路，那么只要沿着环路再遍历一遍，就能找到一条权重更小的路径。如果从结点<span class="math inline">\(s\)</span>到结点<span class="math inline">\(v\)</span>的某条路径上存在权重为负值的环路，我们定义结点<span class="math inline">\(s\)</span>到结点<span class="math inline">\(v\)</span>的最短路径<span class="math inline">\(\delta(s,v)=-\infty\)</span>。例如下图中，存在<span class="math inline">\(\langle{e,f,e}\rangle\)</span>这条权重为-3的环路，因此所有经过这条环路可达的结点<span class="math inline">\(e,f,g\)</span>的最短路径权重为<span class="math inline">\(-\infty\)</span>。</p><p><img title="包含权重为负值的环路的有向图" data-src="/uploads/posts/negative-edge-weights-in-a-directed-graph.png"></p></li><li><p>若包含权重为0的环路，那么删除该环路后得到的路径权重与原来的相等。只要一条最短路径上还有权重为0的环路，我们就可以重复删除这些环路，直到得到一条不包含环路的简单路径。</p></li></ul><p>由于图<span class="math inline">\(G=(V,E)\)</span>中的任意无环路径最多包含<span class="math inline">\(|V|\)</span>个不同的结点，到任意结点的最短路径最多包含<span class="math inline">\(|V|-1\)</span>条边。</p><h1 id="最短路径的表示">最短路径的表示</h1><p>通常情况下，我们不但希望计算出最短路径权重，还希望计算出最短路径上的结点。</p><p>给定图<span class="math inline">\(G=(V,E)\)</span>，对于每个结点<span class="math inline">\(v\)</span>，维持一个<strong>前驱结点</strong><span class="math inline">\(v.\pi\)</span>。该前驱结点可能是另一个结点或者<span class="math inline">\(NIL\)</span>。将从结点<span class="math inline">\(v\)</span>开始的前驱结点链反转过来，就是从<span class="math inline">\(s\)</span>到<span class="math inline">\(v\)</span>的一条最短路径。</p><p>我们感兴趣的是由<span class="math inline">\(\pi\)</span>值所诱导的<strong>前驱子图</strong><span class="math inline">\(G_\pi=(V_\pi,E_\pi)\)</span>。定义结点集<span class="math inline">\(V_\pi\)</span>为图<span class="math inline">\(G\)</span>中的前驱结点不为<span class="math inline">\(NIL\)</span>的结点的集合，再加上源节点<span class="math inline">\(s\)</span>，即<span class="math inline">\(V_\pi=\{v\in{V}:v.\pi\neq{NIL}\}\cup\{s\}\)</span>。有向边集合<span class="math inline">\(E_\pi\)</span>是由<span class="math inline">\(V_\pi\)</span>中的结点的<span class="math inline">\(\pi\)</span>值所诱导的边的集合，即<span class="math inline">\(E_\pi=\{(v.\pi,v)\in{E}:v\in{V_\pi-\{s\}}\}\)</span>。</p><p>一个正确的单源最短路径算法：在算法终止时，<span class="math inline">\(G_\pi\)</span>是一棵“最短路径树“。最短路径树是一棵有根节点的树，该树包括了从源节点<span class="math inline">\(s\)</span>到每个可以从<span class="math inline">\(s\)</span>到达的结点的一条最短路径。类似于广度优先搜索中的广度优先树，但它所包括的最短路径是以边的权重来定义的，而不是边的条数。</p><p>需要指出的是，最短路径不一定是唯一的，最短路径树也不一定是唯一的。如下图(a)所示的带权重的有向图中，有(b)和(c)两种最短路径，即存在两棵根节点为<span class="math inline">\(s\)</span>的最短路径树。</p><p><img title="根结点相同的两棵不同的最短路径树" data-src="/uploads/posts/two-shortest-paths-trees-with-the-same-root.png"></p><h1 id="松弛操作">松弛操作</h1><p>本文的算法需要使用松弛（relaxation）技术。对于每个结点<span class="math inline">\(v\)</span>来说，维持一个属性<span class="math inline">\(v.d\)</span>，用来记录从源节点<span class="math inline">\(s\)</span>到结点<span class="math inline">\(v\)</span>的最短路径权重的上界。称之为<span class="math inline">\(s\)</span>到<span class="math inline">\(v\)</span>的<strong>最短路径估计</strong>。使用下面运行时间为<span class="math inline">\(\Theta(V)\)</span>的算法来对最短路径估计和前驱结点进行初始化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INITIALIZE-SINGLE-SOURCE(G, s):</span><br><span class="line">    <span class="keyword">for</span> each vertex v <span class="keyword">in</span> G.V:</span><br><span class="line">        v.d = infinity</span><br><span class="line">        v.pi = NIL</span><br><span class="line">    s.d = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>下面的伪代码给出了对边<span class="math inline">\((u,v)\)</span>在<span class="math inline">\(O(1)\)</span>时间内进行的松弛操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RELAX(u, v, w)：</span><br><span class="line">    <span class="keyword">if</span> v.d &gt; u.d + w(u, v):</span><br><span class="line">        v.d = u.d + w(u, v)</span><br><span class="line">        v.pi = u</span><br></pre></td></tr></table></figure><p>对一条边的松弛过程为：</p><p>首先测试一下是否可以对从<span class="math inline">\(s\)</span>到<span class="math inline">\(v\)</span>的最短距离进行改善。测试方法是，将从结点<span class="math inline">\(s\)</span>到结点<span class="math inline">\(u\)</span>之间的最短路径距离<span class="math inline">\(u.d\)</span>加上结点<span class="math inline">\(u\)</span>与<span class="math inline">\(v\)</span>之间的边权重<span class="math inline">\(w(u, v)\)</span>，并与当前的<span class="math inline">\(s\)</span>到<span class="math inline">\(v\)</span>的最短路径估计<span class="math inline">\(v.d\)</span>进行比较。如果前者更小，则对<span class="math inline">\(v.d\)</span>和<span class="math inline">\(v.pi\)</span>进行更新。如下图：</p><ol type="a"><li><p><span class="math inline">\(v.d=9; u.d=5; w(u,v)=2，9&gt;5+2\)</span>，因此v的最短路径估计<span class="math inline">\(v.d\)</span>降低，同时<span class="math inline">\(v\)</span>的前驱结点也要更新为<span class="math inline">\(u\)</span>。称这种情况为松弛成功。</p></li><li><p><span class="math inline">\(6&lt;5+2\)</span>，因此<span class="math inline">\(v.d\)</span>和<span class="math inline">\(v.pi\)</span>属性都不会变化。称这种情况为松弛失败。</p></li></ol><p><img title="松弛成功和松弛失败" data-src="/uploads/posts/single-source-shortest-path-relax.png"></p><h1 id="bellman-ford算法">Bellman-Ford算法</h1><p>Bellman-Ford算法解决的是一般情况下的单源最短路径问题。边的权重可以为负值。算法返回一个布尔值，以表明是否存在一个从源节点可以到达的权重为负值的环路。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BELLMAN-FORD(G, w, s):</span><br><span class="line">    INITIALIZE-SINGLE-SOURCE(G, s)</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to |G.V| - <span class="number">1</span>:        <span class="comment"># 算法对每条边进行|V|-1次处理</span></span><br><span class="line">        <span class="keyword">for</span> each edge(u, v) <span class="keyword">in</span> G.E:</span><br><span class="line">            RELAX(u, v, w)</span><br><span class="line">    <span class="keyword">for</span> each edge(u, v) <span class="keyword">in</span> G.E:    <span class="comment"># 检查是否存在权重为负值的环路</span></span><br><span class="line">        <span class="keyword">if</span> v.d &gt; u.d + w(u, v):</span><br><span class="line">            <span class="keyword">return</span> false           <span class="comment"># 若存在，返回false</span></span><br><span class="line">    <span class="keyword">return</span> true</span><br></pre></td></tr></table></figure><p><img title="Bellman Ford每次迭代后的结果" data-src="/uploads/posts/execution-of-bellman-ford.png"></p><p>例如在图(a)所示的带权重的有向图中，按<span class="math inline">\((t,x), (t,y), (t,z), (x,t), (y,x), (y,z), (z,x), (z,s), (s,t), (s,y)\)</span>的顺序对边执行松弛操作的过程。有向图中有6个顶点，因此需要循环5次。单次循环后的结果分为如图(b)~(e)所示。只有<span class="math inline">\(v.d\)</span>值降低的结点成功松弛。</p><p>边的顺序不会对最终结果产生影响，但若斟酌选择，可以减少松弛失败的次数，从而提高代码的执行效率。在后续的优化中将会提到一种选择方案。</p><h2 id="分析">分析</h2><p><code>INITIALIZE-SINGLE-SOURCE</code>所需时间为<span class="math inline">\(\Theta(V)\)</span>，内层循环对每条边都执行一次<code>RELAX</code>操作，因此运行时间为<span class="math inline">\(\Theta(E)\)</span>，且一共要进行<span class="math inline">\(|V|-1\)</span>次循环，检测是否存在权重为负值的环路所需时间为<span class="math inline">\(O(E)\)</span>，Bellman-Ford算法的总运行时间为<span class="math inline">\(\Theta(V)+(|V|-1)\Theta(E)+O(E)=O(VE)\)</span>。</p><h2 id="优化">优化</h2><ol type="1"><li><p>提前跳出循环。</p><p>实际操作中，Bellman-Ford算法经常会在未达到<span class="math inline">\(|V|-1\)</span>次前就出解，<span class="math inline">\(|V|-1\)</span>其实是最大值。于是可以在循环中设置判定，在某次循环不再进行松弛时，直接退出循环，进行负权环判定。（若存在负权环，则循环次数一定会达到<span class="math inline">\(|V|-1\)</span>次，因此，若是提前跳出循环，则说明图中没有负权环）</p></li><li><p>队列优化。参考最短路径快速算法。</p><p>松弛操作必定只会发生在最短路径前驱结点松弛成功过的结点上：结点<span class="math inline">\(v\)</span>的所有前驱结点<span class="math inline">\(\{u|(u,v)\in{E}\}\)</span>中，若存在松弛成功（更新了最短路径估计<span class="math inline">\(d\)</span>和前驱结点<span class="math inline">\(pi\)</span>）的结点，则对结点<span class="math inline">\(v\)</span>执行松弛操作<code>RELAX(v, n, w)</code>。</p><p>反过来说，我们应该对哪些结点<span class="math inline">\(v\)</span>执行松弛操作：若结点<span class="math inline">\(u\)</span>成功松弛，则应该对<span class="math inline">\(u\)</span>的所有后继结点<span class="math inline">\(\{v|(u,v)\in{E}\}\)</span>执行松弛操作。</p><p>用一个队列记录松弛过的结点，避免了冗余计算。</p></li></ol><h2 id="代码">代码</h2><p>图用邻接链表的方式存储。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_f</span><span class="params">(graph, result=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> result <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        print(<span class="string">'has negative cycle or not?'</span>, <span class="keyword">not</span> result)</span><br><span class="line">    fmt = <span class="string">'&#123;0:&lt;10s&#125; &#123;1:&lt;10s&#125; &#123;2:&lt;10s&#125;\n'</span></span><br><span class="line">    title = fmt.format(<span class="string">'vertex'</span>, <span class="string">'distance'</span>, <span class="string">'previous'</span>)</span><br><span class="line">    data = <span class="string">''</span>.join(fmt.format(str(k), str(attr[<span class="string">'distance'</span>]), str(attr[<span class="string">'previous'</span>])) <span class="keyword">for</span> k, attr <span class="keyword">in</span> graph.nodes.items())</span><br><span class="line">    print(title + data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_single_source</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    <span class="string">"""初始化单源点"""</span></span><br><span class="line">    <span class="keyword">for</span> attr <span class="keyword">in</span> graph.nodes.values():</span><br><span class="line">        attr[<span class="string">'previous'</span>] = <span class="literal">None</span></span><br><span class="line">        attr[<span class="string">'distance'</span>] = float(<span class="string">'inf'</span>)</span><br><span class="line">    graph.nodes[s][<span class="string">'distance'</span>] = <span class="number">0</span>  <span class="comment"># 源点距离初始为0，其他为无穷远</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relax</span><span class="params">(graph, u, v, w)</span>:</span></span><br><span class="line">    <span class="string">"""relax操作，distance的值只在此处发生改变"""</span></span><br><span class="line">    u_attr, v_attr = graph.nodes[u], graph.nodes[v]</span><br><span class="line">    <span class="keyword">if</span> v_attr[<span class="string">'distance'</span>] &gt; u_attr[<span class="string">'distance'</span>] + w:</span><br><span class="line">        v_attr[<span class="string">'distance'</span>] = u_attr[<span class="string">'distance'</span>] + w  <span class="comment"># 更新最短距离</span></span><br><span class="line">        v_attr[<span class="string">'previous'</span>] = u  <span class="comment"># 更新前驱结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detect_negative_cycle</span><span class="params">(graph)</span>:</span></span><br><span class="line">    <span class="string">"""检测图g中是否包含负权环路"""</span></span><br><span class="line">    <span class="keyword">for</span> u, v, w <span class="keyword">in</span> graph.edges.data(<span class="string">'weight'</span>):</span><br><span class="line">        <span class="keyword">if</span> graph.nodes[v][<span class="string">'distance'</span>] &gt; graph.nodes[u][<span class="string">'distance'</span>] + w:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bellman_ford</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    <span class="string">"""Bellman Ford算法，同时判断是否存在权重为负值的环路"""</span></span><br><span class="line">    initialize_single_source(graph, s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(graph.number_of_nodes() - <span class="number">1</span>):  <span class="comment"># 重复|V|-1遍</span></span><br><span class="line">        <span class="keyword">for</span> u, v, w <span class="keyword">in</span> graph.edges.data(<span class="string">'weight'</span>):  <span class="comment"># 对每条边执行一次relax</span></span><br><span class="line">            relax(graph, u, v, w)</span><br><span class="line">    <span class="keyword">return</span> detect_negative_cycle(graph)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bellman_ford_op_1</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    <span class="string">"""优化方案1：提前跳出循环"""</span></span><br><span class="line">    initialize_single_source(graph, s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(graph.number_of_nodes() - <span class="number">1</span>):</span><br><span class="line">        relaxed = <span class="literal">False</span>  <span class="comment"># 一次循环开始前，标志位置为0</span></span><br><span class="line">        <span class="keyword">for</span> u, v, w <span class="keyword">in</span> graph.edges.data(<span class="string">'weight'</span>):</span><br><span class="line">            <span class="keyword">if</span> relax(graph, u, v, w) <span class="keyword">is</span> <span class="literal">True</span>:  <span class="comment"># 若松弛成功，标志位置为1</span></span><br><span class="line">                relaxed = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> relaxed <span class="keyword">is</span> <span class="literal">False</span>:  <span class="comment"># 提前跳出循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 若完整执行了|V|-1次循环，则去判断是否包含负权环</span></span><br><span class="line">        <span class="keyword">return</span> detect_negative_cycle(graph)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bellman_ford_op_2</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    <span class="string">"""队列优化"""</span></span><br><span class="line">    initialize_single_source(graph, s)</span><br><span class="line">    q = Queue()</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> graph.edges:</span><br><span class="line">        graph[u][v][<span class="string">'__times__'</span>] = <span class="number">0</span>  <span class="comment"># 记录松弛次数（不论结果），当超过|V|-1次时，说明图中包含负权环</span></span><br><span class="line">    q.put(s)  <span class="comment"># 初始放入源点</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">        u = q.get()</span><br><span class="line">        <span class="keyword">for</span> v, attr <span class="keyword">in</span> graph[u].items():  <span class="comment"># 遍历邻接边</span></span><br><span class="line">            <span class="keyword">if</span> relax(graph, u, v, attr[<span class="string">'weight'</span>]) <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">                q.put(v)  <span class="comment"># 将松弛成功过的结点放入队列</span></span><br><span class="line">                graph[u][v][<span class="string">'__times__'</span>] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> graph[u][v][<span class="string">'__times__'</span>] &gt; graph.number_of_nodes() - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># Bellman-Ford示例</span></span><br><span class="line">    g = nx.DiGraph()</span><br><span class="line">    g.add_nodes_from(<span class="string">'stxyz'</span>)</span><br><span class="line">    edges = [(<span class="string">'s'</span>, <span class="string">'t'</span>, <span class="number">6</span>), (<span class="string">'s'</span>, <span class="string">'y'</span>, <span class="number">7</span>), (<span class="string">'t'</span>, <span class="string">'x'</span>, <span class="number">5</span>), (<span class="string">'t'</span>, <span class="string">'y'</span>, <span class="number">8</span>), (<span class="string">'t'</span>, <span class="string">'z'</span>, <span class="number">-4</span>), (<span class="string">'x'</span>, <span class="string">'t'</span>, <span class="number">-2</span>), (<span class="string">'y'</span>, <span class="string">'x'</span>, <span class="number">-3</span>),</span><br><span class="line">             (<span class="string">'y'</span>, <span class="string">'z'</span>, <span class="number">9</span>), (<span class="string">'z'</span>, <span class="string">'s'</span>, <span class="number">2</span>), (<span class="string">'z'</span>, <span class="string">'x'</span>, <span class="number">7</span>)]</span><br><span class="line">    g.add_weighted_edges_from(edges)</span><br><span class="line">    r = bellman_ford(g, <span class="string">'s'</span>)</span><br><span class="line">    print_f(g, r)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 一个带有负权环路的示例</span></span><br><span class="line">    g.clear()</span><br><span class="line">    g.add_nodes_from(<span class="string">'s1234t'</span>)</span><br><span class="line">    edges = [(<span class="string">'s'</span>, <span class="string">'1'</span>, <span class="number">1</span>), (<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="number">1</span>), (<span class="string">'2'</span>, <span class="string">'1'</span>, <span class="number">-2</span>), (<span class="string">'1'</span>, <span class="string">'3'</span>, <span class="number">1</span>), (<span class="string">'3'</span>, <span class="string">'4'</span>, <span class="number">-4</span>), (<span class="string">'4'</span>, <span class="string">'1'</span>, <span class="number">1</span>), (<span class="string">'4'</span>, <span class="string">'t'</span>, <span class="number">1</span>)]</span><br><span class="line">    g.add_weighted_edges_from(edges)</span><br><span class="line">    r = bellman_ford_op_2(g, <span class="string">'s'</span>)</span><br><span class="line">    print_f(g, r)</span><br><span class="line"></span><br><span class="line">    g.clear()</span><br><span class="line">    g.add_nodes_from(<span class="string">'s1234t'</span>)</span><br><span class="line">    edges = [(<span class="string">'s'</span>, <span class="string">'1'</span>, <span class="number">3</span>), (<span class="string">'1'</span>, <span class="string">'s'</span>, <span class="number">-3</span>), (<span class="string">'s'</span>, <span class="string">'2'</span>, <span class="number">4</span>), (<span class="string">'2'</span>, <span class="string">'s'</span>, <span class="number">-4</span>), (<span class="string">'2'</span>, <span class="string">'1'</span>, <span class="number">3</span>), (<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="number">-3</span>), (<span class="string">'1'</span>, <span class="string">'3'</span>, <span class="number">7</span>),</span><br><span class="line">             (<span class="string">'3'</span>, <span class="string">'1'</span>, <span class="number">-7</span>), (<span class="string">'3'</span>, <span class="string">'2'</span>, <span class="number">5</span>), (<span class="string">'2'</span>, <span class="string">'4'</span>, <span class="number">6</span>), (<span class="string">'4'</span>, <span class="string">'2'</span>, <span class="number">-6</span>), (<span class="string">'3'</span>, <span class="string">'4'</span>, <span class="number">-8</span>), (<span class="string">'3'</span>, <span class="string">'t'</span>, <span class="number">6</span>),</span><br><span class="line">             (<span class="string">'t'</span>, <span class="string">'3'</span>, <span class="number">-6</span>), (<span class="string">'4'</span>, <span class="string">'t'</span>, <span class="number">9</span>), (<span class="string">'t'</span>, <span class="string">'4'</span>, <span class="number">-9</span>)]</span><br><span class="line">    g.add_weighted_edges_from(edges)</span><br><span class="line">    r = bellman_ford_op_1(g, <span class="string">'s'</span>)</span><br><span class="line">    print_f(g, r)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">has negative cycle or not? False</span><br><span class="line">vertex     distance   previous  </span><br><span class="line">s          0          None</span><br><span class="line">t          2          x</span><br><span class="line">x          4          y</span><br><span class="line">y          7          s</span><br><span class="line">z          -2         t</span><br><span class="line"></span><br><span class="line">has negative cycle or not? True</span><br><span class="line">vertex     distance   previous  </span><br><span class="line">s          0          None</span><br><span class="line">1          -4         4</span><br><span class="line">2          -3         1</span><br><span class="line">3          -2         1</span><br><span class="line">4          -6         3</span><br><span class="line">t          -4         4</span><br><span class="line"></span><br><span class="line">has negative cycle or not? True</span><br><span class="line">vertex     distance   previous  </span><br><span class="line">s          -23        2</span><br><span class="line">1          -17        3</span><br><span class="line">2          -24        4</span><br><span class="line">3          -15        t</span><br><span class="line">4          -18        3</span><br><span class="line">t          -9         4</span><br></pre></td></tr></table></figure><h1 id="dijkstra算法">Dijkstra算法</h1><p>Dijkstra算法是另一个解决单源最短路径问题的算法，该要求所有边的权重都为非负值。</p><p>Dijkstra算法在运行过程中维持的关键信息是一组结点集合<span class="math inline">\(S\)</span>。从源节点<span class="math inline">\(s\)</span>到该集合中每个结点之间的最短距离已经被找到。算法重复从结点集<span class="math inline">\(V-S\)</span>中选择<strong>最短路径估计最小</strong>的结点<span class="math inline">\(u\)</span>，将<span class="math inline">\(u\)</span>加入到集合<span class="math inline">\(S\)</span>，然后对所有从<span class="math inline">\(u\)</span>发出的边进行松弛（对于边<span class="math inline">\((u,v),v\in{S}\)</span>是没有松弛的必要的，即使对之松弛，松弛一定不会成功，因为s到v的最短距离已经求出）。因为算法总是选择集合<span class="math inline">\(V-S\)</span>中最近的结点来加入到集合<span class="math inline">\(S\)</span>中，该算法使用的是贪心策略。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DIJKSTRA(G, w, s):</span><br><span class="line">    INITIALIZE-SINGLE-SOURCE(G, s)</span><br><span class="line">    S = empty set           <span class="comment"># 到源点s的最短距离被找到的结点集，伪代码中体现的作用不大</span></span><br><span class="line">    Q = G.V                 <span class="comment"># 初始时将所有结点放入优先队列</span></span><br><span class="line">    <span class="keyword">while</span> Q <span class="keyword">not</span> empty:</span><br><span class="line">        u = EXTRACT-MIN(Q)  <span class="comment"># 选择最短路径估计最小的结点</span></span><br><span class="line">        S = S + &#123;u&#125;         <span class="comment"># 将u加入集合S</span></span><br><span class="line">        <span class="keyword">for</span> each vertex v <span class="keyword">in</span> G.Adj[u]:     <span class="comment"># 松弛所有从u发出的边</span></span><br><span class="line">            RELAX(u, v, w)  <span class="comment"># 如果松弛成功，还要改变优先队列中结点v的减值</span></span><br></pre></td></tr></table></figure><p><img title="Dijkstra每次迭代后的结果" data-src="/uploads/posts/execution-of-dijkstra.png"></p><p>在一个结点个数为5的带权重的有向图上执行Dijkstra算法的过程如上图。</p><p>(a)~(e) 为每次<code>while</code>循环开始时，灰色结点为最短路径估计最小的结点。白色结点属于集合<span class="math inline">\(V-S\)</span>。</p><p>(b)~(f) 为每次<code>for</code>循环结束后，阴影的边描述了前驱节点。黑色的结点属于集合<span class="math inline">\(S\)</span>。图(f)就是最终结果。</p><h2 id="分析-1">分析</h2><p>首先分析算法的循环次数。算法调用1次<code>INITIALIZE-SINGLE-SOURCE</code>操作和1次初始化优先队列操作<code>Q=G.V</code>。之后的<code>while</code>循环执行次数为<span class="math inline">\(|V|\)</span>次，因为每次循环都从最小优先队列<span class="math inline">\(Q\)</span>中提取一个结点。因此，<code>EXTRACT-MIN</code>也执行了<span class="math inline">\(|V|\)</span>次。内层的<code>for</code>循环对从结点<span class="math inline">\(u\)</span>发出的边执行一次松弛操作，而在<code>while</code>循环过程中，<span class="math inline">\(u\)</span>取到了图中所有的结点且各取到一次。因此<code>for</code>循环实际上对图中所有的边执行了1次松弛操作，即<code>RELAX</code>操作的执行次数为<span class="math inline">\(|E|\)</span>。暗含在其中的降低键值<code>DECREASE-KEY</code>操作也执行了<span class="math inline">\(|E|\)</span>次。</p><p>如何实现算法中的优先队列直接影响到算法的时间复杂度。在此列出3中实现下的时间复杂度分析。</p><table><thead><tr class="header"><th>实现方式</th><th>初始化代价*1</th><th>提取最小值代价*V</th><th>降低键值代价*E</th><th>Dijkstra算法总代价</th></tr></thead><tbody><tr class="odd"><td>数组</td><td><span class="math inline">\(O(V)\)</span></td><td><span class="math inline">\(O(V)\)</span>，搜索整个数组</td><td><span class="math inline">\(O(1)\)</span></td><td><span class="math inline">\(O(V^2+E)=O(V^2)\)</span></td></tr><tr class="even"><td>二叉堆</td><td><span class="math inline">\(O(V)\)</span></td><td><span class="math inline">\(O(\lg{V})\)</span>，调整队</td><td><span class="math inline">\(O(\lg{V})\)</span>，调整堆</td><td><span class="math inline">\(O((V+E)\lg{V})\)</span></td></tr><tr class="odd"><td>斐波那契堆</td><td><span class="math inline">\(O(V)\)</span></td><td><span class="math inline">\(O(\lg{V})\)</span>，摊还代价</td><td><span class="math inline">\(O(1)\)</span>，摊还代价</td><td><span class="math inline">\(O(V\lg{V}+E)\)</span></td></tr></tbody></table><p>若所有结点都可以从源节点到达（<span class="math inline">\(|V|&lt;|E|\)</span>），则<span class="math inline">\(O((V+E)\lg{V})=O(E\lg{V})\)</span>。对于稀疏图，特别地，如果<span class="math inline">\(E=o(V^2/\lg{V})\)</span>，则使用二叉堆实现最小优先队列相对于用数组直接实现的<span class="math inline">\(O(V^2)\)</span>代价有改善。</p><p>Dijkstra算法与广度优先搜索算法及计算最小生成树的Prim算法的相似点：</p><ul><li>与广度优先搜索算法：集合<span class="math inline">\(S\)</span>对应的是广度优先搜索中的黑色结点集合：正如集合<span class="math inline">\(S\)</span>中的结点的最短路径权重已经计算出来一样，在广度优先搜索中，黑色结点的正确广度优先距离也已经计算出来。</li><li>与Prim算法：两个算法都使用最小优先队列来寻找集合之外“最轻”结点，将该节点加入到集合里，并对位于集合外面的结点的权重进行相应调整。</li></ul><h2 id="代码-1">代码</h2><p>使用内建的优先队列时的妥协：</p><p>因为无法改变优先队列中的键值（或者说改变了也没有意义，优先队列不会调整结点在队列中的先后顺序），所以在初始时<span class="math inline">\(Q\neq{G.V}\)</span>，而是只将源点<span class="math inline">\(s\)</span>放入优先队列。之后在松弛过程中，若发现集合<span class="math inline">\(S\)</span>中不存在的结点，再将之放入优先队列。</p><p>但这也随之产生了一个问题：多条不同的边可能指向同一个集合<span class="math inline">\(S\)</span>外的结点<span class="math inline">\(u\)</span>，当这些边成功松弛多次时，结点<span class="math inline">\(u\)</span>被多次加入队列中（因为内建的优先队列没有提供<code>DECREASE-KEY</code>操作，只能通过重复放入的方式更新键值）。这些重复加入的结点<span class="math inline">\(u\)</span>携带不同的键值，显然，因最近一次松弛成功而被加入队列的结点<span class="math inline">\(u\)</span>携带最小的键值。携带较大键值的结点<span class="math inline">\(u\)</span>对算法没有意义，但它们仍然存在于队列中。因此，在循环开始时对取得的结点进行判断：若<span class="math inline">\(u\)</span>结点在<code>visit</code>集合中，说明源结点<span class="math inline">\(s\)</span>到<span class="math inline">\(u\)</span>的最短距离已经求出，跳过这样的结点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue</span><br><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"><span class="keyword">from</span> graph.bellman_ford <span class="keyword">import</span> initialize_single_source, relax, print_f</span><br><span class="line"><span class="keyword">from</span> data_structure.fib_heap <span class="keyword">import</span> FibHeap, Node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dijkstra_queue</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    <span class="string">"""使用优先队列"""</span></span><br><span class="line">    initialize_single_source(graph, s)</span><br><span class="line">    visit, q = set(), PriorityQueue()  <span class="comment"># visit：集合S</span></span><br><span class="line">    q.put((graph.nodes[s][<span class="string">'distance'</span>], s))  <span class="comment"># 初始时s入队列</span></span><br><span class="line">    <span class="keyword">while</span> q.empty() <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">        u = q.get()[<span class="number">1</span>]  <span class="comment"># 选择最近的节点u</span></span><br><span class="line">        <span class="keyword">if</span> u <span class="keyword">not</span> <span class="keyword">in</span> visit:</span><br><span class="line">            visit.add(u)</span><br><span class="line">            <span class="keyword">for</span> v, e_attr <span class="keyword">in</span> graph[u].items():</span><br><span class="line">                <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> visit:  <span class="comment"># 已经访问过的顶点无需入队列</span></span><br><span class="line">                    relax(graph, u, v, e_attr[<span class="string">'weight'</span>])  <span class="comment"># relax最近顶点u的临界点</span></span><br><span class="line">                    q.put((graph.nodes[v][<span class="string">'distance'</span>], v))  <span class="comment"># 临接顶点入队列，同一顶点可能带有不同的distance值多次入队列</span></span><br></pre></td></tr></table></figure><p>斐波那契堆的相关知识和代码见<a href="/data-structure/Fibonacci-heap">这里</a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dijkstra_fibonacci</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    <span class="string">"""使用斐波那契堆优化算法"""</span></span><br><span class="line">    initialize_single_source(graph, s)</span><br><span class="line">    m, visit, heap = &#123;&#125;, set(), FibHeap()  <span class="comment"># m：顶点到堆中结点的映射&#123;v.key:Node&#125;</span></span><br><span class="line">    <span class="keyword">for</span> v, v_attr <span class="keyword">in</span> graph.nodes.items():  <span class="comment"># 所有顶点入堆</span></span><br><span class="line">        n = Node(v_attr[<span class="string">'distance'</span>])</span><br><span class="line">        n.v = v  <span class="comment"># 为fibonacci node添加属性v，记录指向顶点的指针</span></span><br><span class="line">        heap.insert(n)</span><br><span class="line">        m[v] = n</span><br><span class="line">    <span class="keyword">while</span> heap.n &gt; <span class="number">0</span>:  <span class="comment"># 实际上循环|V|-1次，等价于for i in range(len(g.get_v_set()))</span></span><br><span class="line">        u = heap.pop().v  <span class="comment"># 选择最近的节点u</span></span><br><span class="line">        visit.add(u)</span><br><span class="line">        <span class="keyword">for</span> v, e_attr <span class="keyword">in</span> graph[u].items():</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> visit:</span><br><span class="line">                relax(graph, u, v, e_attr[<span class="string">'weight'</span>])</span><br><span class="line">                heap.decrease_key(m[v], graph.nodes[v][<span class="string">'distance'</span>])  <span class="comment"># 修改heap中对应节点的key值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># Dijkstra示例</span></span><br><span class="line">    g = nx.DiGraph()</span><br><span class="line">    g.add_nodes_from(<span class="string">'s12345t'</span>)</span><br><span class="line">    edges = [(<span class="string">'s'</span>, <span class="string">'1'</span>, <span class="number">2</span>), (<span class="string">'s'</span>, <span class="string">'2'</span>, <span class="number">3</span>), (<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="number">4</span>), (<span class="string">'1'</span>, <span class="string">'3'</span>, <span class="number">8</span>), (<span class="string">'1'</span>, <span class="string">'4'</span>, <span class="number">5</span>), (<span class="string">'2'</span>, <span class="string">'4'</span>, <span class="number">3</span>), (<span class="string">'2'</span>, <span class="string">'5'</span>, <span class="number">4</span>),</span><br><span class="line">             (<span class="string">'3'</span>, <span class="string">'4'</span>, <span class="number">2</span>), (<span class="string">'3'</span>, <span class="string">'t'</span>, <span class="number">9</span>), (<span class="string">'4'</span>, <span class="string">'t'</span>, <span class="number">6</span>), (<span class="string">'5'</span>, <span class="string">'t'</span>, <span class="number">10</span>)]</span><br><span class="line">    g.add_weighted_edges_from(edges)</span><br><span class="line">    dijkstra_queue(g, <span class="string">'s'</span>)</span><br><span class="line">    print_f(g)</span><br><span class="line"></span><br><span class="line">    g.clear()</span><br><span class="line">    g.add_nodes_from(<span class="string">'stxyz'</span>)</span><br><span class="line">    edges = [(<span class="string">'s'</span>, <span class="string">'t'</span>, <span class="number">10</span>), (<span class="string">'s'</span>, <span class="string">'y'</span>, <span class="number">5</span>), (<span class="string">'t'</span>, <span class="string">'x'</span>, <span class="number">1</span>), (<span class="string">'t'</span>, <span class="string">'y'</span>, <span class="number">2</span>), (<span class="string">'x'</span>, <span class="string">'z'</span>, <span class="number">4</span>), (<span class="string">'y'</span>, <span class="string">'t'</span>, <span class="number">3</span>), (<span class="string">'y'</span>, <span class="string">'x'</span>, <span class="number">9</span>),</span><br><span class="line">             (<span class="string">'y'</span>, <span class="string">'z'</span>, <span class="number">2</span>), (<span class="string">'z'</span>, <span class="string">'s'</span>, <span class="number">7</span>), (<span class="string">'z'</span>, <span class="string">'x'</span>, <span class="number">6</span>)]</span><br><span class="line">    g.add_weighted_edges_from(edges)</span><br><span class="line">    dijkstra_fibonacci(g, <span class="string">'s'</span>)</span><br><span class="line">    print_f(g)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vertex     distance   previous  </span><br><span class="line">s          0          None</span><br><span class="line">1          2          s</span><br><span class="line">2          3          s</span><br><span class="line">3          10         1</span><br><span class="line">4          6          2</span><br><span class="line">5          7          2</span><br><span class="line">t          12         4</span><br><span class="line"></span><br><span class="line">vertex     distance   previous  </span><br><span class="line">s          0          None</span><br><span class="line">t          8          y</span><br><span class="line">x          9          t</span><br><span class="line">y          5          s</span><br><span class="line">z          7          y</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithms </tag>
            
            <tag> Introduction To Algorithms </tag>
            
            <tag> fibonacci heap </tag>
            
            <tag> shortest path </tag>
            
            <tag> greedy method </tag>
            
            <tag> priority queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树</title>
      <link href="/notes/introduction-to-algorithms/binary-search-trees/"/>
      <url>/notes/introduction-to-algorithms/binary-search-trees/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉搜索树">二叉搜索树</h1><p>一棵二叉搜索树是以一棵二叉树来组织的。每个结点除了<code>key</code>之外，还包含属性<code>left、right、p</code>，分别指向结点的左孩子、右孩子和父节点。如果父节点或者子节点不存在，则相应属性值为<code>NIL</code>。根节点是唯一父节点为<code>NIL</code>的结点。</p><h1 id="性质">性质</h1><p>二叉搜索树性质：</p><p>设<code>x</code>是二叉搜索树中的一个结点。如果<span class="math inline">\(y\)</span>是<span class="math inline">\(x\)</span>左子树中的一个结点，那么<span class="math inline">\(y.key\le{x.key}\)</span>。如果<span class="math inline">\(y\)</span>是<span class="math inline">\(x\)</span>右子树中的一个结点，那么<span class="math inline">\(y.key\ge{x.key}\)</span>。</p><p>根据此性质，可以通过中序遍历（inorder tree walk）算法按序输出二叉搜索树中的所有关键字。比较简单的递归实现如下：</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INORDER-TREE-WALK(x):</span><br><span class="line">    <span class="keyword">if</span> x != NIL:</span><br><span class="line">        INORDER-TREE-WALK(x.left)</span><br><span class="line">        <span class="keyword">print</span> x.key</span><br><span class="line">        INORDER-TREE-WALK(x.right)</span><br></pre></td></tr></table></figure><p>包含相同结点的两棵高度不同的二叉搜索树。大部分搜索树操作的运行时间与树的高度成正比。因此(b)比(a)低效。</p><p><img title="二叉搜索树" data-src="/uploads/posts/binary-search-trees.png"></p><h1 id="操作">操作</h1><h2 id="查找">查找</h2><p>使用下面的过程在一棵二叉搜索树中查找一个具有给定关键字的结点。输入一个指向树根的指针<code>x</code>和一个关键字<code>k</code>，如果这个结点存在，返回一个指向关键字为<code>k</code>的结点的指针；否则返回<code>NIL</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TREE-SEARCH(x, k):</span><br><span class="line">    <span class="keyword">if</span> x == NIL <span class="keyword">or</span> k == x.key:  <span class="comment"># 如果关键字与k相等，返回结果</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">if</span> k &lt; x.key:               <span class="comment"># 如果关键字大于k，查找在左子树中继续</span></span><br><span class="line">        <span class="keyword">return</span> TREE-SEARCH(x.left, k)   <span class="comment"># 递归</span></span><br><span class="line">    <span class="keyword">else</span>:                       <span class="comment"># 如果关键字小于k，查找在右子树中继续</span></span><br><span class="line">        <span class="keyword">return</span> TREE-SEARCH(x.right, k)</span><br></pre></td></tr></table></figure><p>可以采用循环来展开递归，用一种迭代方式重写此过程。对于大多数计算机，迭代版本的效率要高得多。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ITERATIVE-TREE-SEARCH(x, k):</span><br><span class="line">    <span class="keyword">while</span> x != NIL <span class="keyword">and</span> k != x.key:  <span class="comment"># 迭代实现：如果关键字与k不相等，重复循环</span></span><br><span class="line">        <span class="keyword">if</span> k &lt; x.key:               <span class="comment"># 如果关键字大于k，查找在左子树中继续</span></span><br><span class="line">            x = x.left</span><br><span class="line">        <span class="keyword">else</span>:                       <span class="comment"># 否则，在右子树中继续</span></span><br><span class="line">            x = x.right</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p><img title="搜索键值等于13的结点" data-src="/uploads/posts/binary-search-tree-search.png"></p><p>例如在如上图所示的二叉查找树中查找键值为13的查找路径是<span class="math inline">\(15\rightarrow6\rightarrow7\rightarrow13\)</span>。具体步骤为：</p><ol type="1"><li><code>x</code>指向根节点，比较<code>x</code>与13：13&lt;15：<code>x</code>指向<code>x.left</code>，在左子树中继续查找。</li><li>13&gt;6：<code>x</code>指向<code>x.right</code>，在右子树中继续查找。</li><li>13&gt;7：<code>x</code>指向<code>x.right</code>，在右子树中继续查找。</li><li>13=13：返回<code>x</code>。</li></ol><h3 id="最大和最小关键字">最大和最小关键字</h3><p>查找最小关键字元素：从根开始沿着<code>left</code>孩子指针直到遇到一个<code>NIL</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TREE-MINIMUM(X):</span><br><span class="line">    <span class="keyword">while</span> x.left != NIL:  <span class="comment"># 假设x != NIL，不停查找左子树</span></span><br><span class="line">        x = x.left</span><br><span class="line">    <span class="keyword">return</span> x              <span class="comment"># 当x的左子树为NIL时，x为最小关键字元素</span></span><br></pre></td></tr></table></figure><p>查找最大关键字的<code>TREE-MAXIMUM</code>的伪代码是对称的，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TREE-MAXIMUM(x):</span><br><span class="line">    <span class="keyword">while</span> x.right != NIL:</span><br><span class="line">        x = x.right</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h3 id="后继和前驱">后继和前驱</h3><p>给定一棵二叉搜索树中的一个结点，有时候需要按中序遍历的次序查找它的后继。如果所有的关键字互不相同，则一个结点<span class="math inline">\(x\)</span>的<strong>后继</strong>是大于<span class="math inline">\(x.key\)</span>的最小关键字的结点。二叉搜索树的性质允许我们通过没有任何关键字的比较来确定一个结点的后继。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TREE-SUCCESSOR(x):</span><br><span class="line">    <span class="keyword">if</span> x.right != NIL:  <span class="comment"># 如果x的右子树不为空，根据性质，右子树中的关键字均大于x的关键字</span></span><br><span class="line">        <span class="keyword">return</span> TREE-MINIMUM(x.right)  <span class="comment"># 此时x的后继为右子树中最小的结点</span></span><br><span class="line">    y = x.p  <span class="comment"># 如果右子树为空，那么x的后继是 x的有左孩子的最底层祖先（回想中序遍历次序）</span></span><br><span class="line">    <span class="keyword">while</span> y != NIL <span class="keyword">and</span> x == y.right:</span><br><span class="line">        x = y</span><br><span class="line">        y = y.p</span><br><span class="line">    <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><p>查找<strong>前驱</strong>的<code>TREE-PREDECESSOR</code>的伪代码是对称的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TREE-PREDECESSOR(x):</span><br><span class="line">    <span class="keyword">if</span> x.left != NIL:</span><br><span class="line">        <span class="keyword">return</span> TREE-MAXIMUM(x.left)</span><br><span class="line">    y = x.p</span><br><span class="line">    <span class="keyword">while</span> y != NIL <span class="keyword">and</span> x == y.left:</span><br><span class="line">        x = y</span><br><span class="line">        y = y.p</span><br><span class="line">    <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><h2 id="插入和删除">插入和删除</h2><p>插入和删除操作会引起由二叉搜索树表示的动态集合的变化（二叉搜索树中的元素集合会变化）。一定要修改指针以保持二叉搜索树性质的成立。</p><h3 id="插入">插入</h3><p>插入操作相对简单些。将结点<code>z</code>插入到树中的相应位置上，这个过程要修改<code>T</code>和<code>z</code>的某些属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TREE-INSERT(T, z):</span><br><span class="line">    y = NIL</span><br><span class="line">    x = T.root            <span class="comment"># 找到z在树中的位置</span></span><br><span class="line">    <span class="keyword">while</span> x != NIL:</span><br><span class="line">        y = x</span><br><span class="line">        <span class="keyword">if</span> z.key &lt; x.key:</span><br><span class="line">            x = x.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x = x.right</span><br><span class="line">    z.p = y               <span class="comment"># 找到z的位置时，y为z在树中的父节点</span></span><br><span class="line">    <span class="keyword">if</span> y == NIL:          <span class="comment"># 如果父节点为NIL，说明在插入前二叉搜索树是空的</span></span><br><span class="line">        T.root = z</span><br><span class="line">    <span class="keyword">elif</span> z.key &lt; y.key:   <span class="comment"># 判断z与父节点y的大小关系，决定z称为左孩子还是右孩子</span></span><br><span class="line">        y.left = z</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        y.right = z</span><br></pre></td></tr></table></figure><p><img title="插入一个键值等于13的新结点" data-src="/uploads/posts/binary-search-tree-insert.png"></p><p>例如在如上图所示的二叉查找树中插入键值为13的结点。步骤为：</p><ol type="1"><li><code>x</code>指向根节点。比较<code>x</code>的键值与欲插入的键值13的大小关系：12&lt;13：<code>x</code>指向<code>x.right</code>。意味着，结点13应该在根节点的右子树中。</li><li><code>x.key=18</code>，18&gt;13：<code>x</code>指向<code>x.left</code>。</li><li><code>x.key=15</code>，15&gt;13：<code>x</code>指向<code>x.left</code>。</li><li><code>x=NIL</code>，<code>x</code>就是结点13应该插入的位置。修改相应指针完成插入操作。</li></ol><h3 id="删除">删除</h3><p>从一棵二叉搜索树<span class="math inline">\(T\)</span>中删除一个结点<span class="math inline">\(z\)</span>时需要考虑三种基本情况。</p><ul><li>如果<code>z</code>没有孩子结点。</li><li>如果<code>z</code>只有一个孩子。</li><li>如果<code>z</code>既有左孩子又有右孩子。</li></ul><p>在具体的删除操作中，则需要考虑4中情况，它与上面的三种情况有些不同。</p><ul><li><ol type="a"><li>若<code>z</code>的左孩子为空，那么用其右孩子来替换<code>z</code>，这个右孩子可以是<code>NIL</code>。为<code>NIL</code>时对应上面的第一种情况；不为<code>NIL</code>时对应第二种情况。</li></ol></li><li><ol start="2" type="a"><li>若<code>z</code>的右孩子为空，那么用其左孩子来替换<code>z</code>。</li></ol><p>否则，<code>z</code>既有左孩子又有右孩子。需要查找<code>z</code>的后继节点<code>y</code>（这个后继位于<code>z</code>的右子树中并且没有左孩子）。</p></li><li><ol start="3" type="a"><li>若<code>y</code>是<code>z</code>的右孩子，那么用<code>y</code>替换<code>z</code>，并仅留下<code>y</code>的右孩子。</li></ol></li><li><ol start="4" type="a"><li>若<code>y</code>位于<code>z</code>的右子树中但并不是<code>z</code>的右孩子。在这种情况下，先用<code>y</code>的右孩子替换<code>y</code>，然后再用<code>y</code>替换<code>z</code>。</li></ol></li></ul><p><img title="删除结点的4种情况" data-src="/uploads/posts/binary-search-tree-delete.png"></p><p>为了在二叉搜索树内移动子树，定义一个子过程<code>TRANSPLANT</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TRANSPLANT(T, u, v):        <span class="comment"># 用根节点为v的子树替换根节点为u的子树</span></span><br><span class="line">    <span class="keyword">if</span> u.p == NIL:          <span class="comment"># 若u为根节点，则子树的替换实际上就是整棵树的替换</span></span><br><span class="line">        T.root = v          <span class="comment"># 因而，只需修改树的root属性</span></span><br><span class="line">    <span class="keyword">elif</span> u == u.p.left:     <span class="comment"># 若u是左孩子</span></span><br><span class="line">        u.p.left = v        <span class="comment"># 修改父节点左孩子指针</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        u.p.right = v       <span class="comment"># 否则修改右孩子指针</span></span><br><span class="line">    <span class="keyword">if</span> v != NIL:            <span class="comment"># 若v不为空，修改v的父节点指针</span></span><br><span class="line">        v.p = u.p</span><br></pre></td></tr></table></figure><p>注意到，<code>TRANSPLANT</code>并没有处理<code>v.left</code>和<code>v.right</code>的更新，这些更新都由<code>TRANSPLANT</code>的调用者来负责。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TREE-DELETE(T, z):</span><br><span class="line">    <span class="keyword">if</span> z.left == NIL:                  <span class="comment"># 情况(a)：左孩子为空</span></span><br><span class="line">        TRANSPLANT(T, z, z.right)      <span class="comment"># 用右孩子替换</span></span><br><span class="line">    <span class="keyword">elif</span> z.right == NIL:               <span class="comment"># 情况(b):右孩子为空</span></span><br><span class="line">        TRANSPLANT(T, z, z.left)       <span class="comment"># 用左孩子替换</span></span><br><span class="line">    <span class="keyword">else</span>:                              <span class="comment"># 既有左孩子又有右孩子</span></span><br><span class="line">        y = TREE-MINIMUM(z.right)      <span class="comment"># 查找z的后继y</span></span><br><span class="line">        <span class="keyword">if</span> y.p != z:                   <span class="comment"># 情况(d)：如果y不是z的右孩子</span></span><br><span class="line">            TRANSPLANT(T, y, y.right)  <span class="comment"># 用y的右孩子替换y</span></span><br><span class="line">            y.right = z.right          <span class="comment"># 修改y的右孩子指针</span></span><br><span class="line">            y.right.p = y              <span class="comment"># 将原来z的孩子结点的父节点指针指向y</span></span><br><span class="line">        TRANSPLANT(T, z, y)            <span class="comment"># 情况(c)：y是z的子节点，用y替换z，也是(d)的第二步替换</span></span><br><span class="line">        y.left = z.left                <span class="comment"># 修改y的指针属性</span></span><br><span class="line">        y.left.p = y</span><br></pre></td></tr></table></figure><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> data_structure.binary_tree <span class="keyword">import</span> BinaryTree, Node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span><span class="params">(BinaryTree)</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(x, k)</span>:</span></span><br><span class="line">        <span class="string">"""在根节点为x的子树中迭代查找键值为k的结点"""</span></span><br><span class="line">        <span class="keyword">while</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> k != x.key:</span><br><span class="line">            <span class="keyword">if</span> k &lt; x.key:</span><br><span class="line">                x = x.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x = x.right</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimum</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="string">"""返回以x为根节点的子树中键值最小的结点，x为空时返回None"""</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">while</span> x.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                x = x.left</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximum</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="string">""""返回子树中键值最大的结点"""</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">while</span> x.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                x = x.right</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">successor</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""返回结点x的后继结点"""</span></span><br><span class="line">        <span class="keyword">if</span> x.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self.minimum(x.right)</span><br><span class="line">        y = x.p</span><br><span class="line">        <span class="keyword">while</span> y <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> x == y.right:</span><br><span class="line">            x, y = y, y.p</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predecessor</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""返回前驱"""</span></span><br><span class="line">        <span class="keyword">if</span> x.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self.maximum(x.left)</span><br><span class="line">        y = x.p</span><br><span class="line">        <span class="keyword">while</span> y <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> x == y.left:</span><br><span class="line">            x, y = y, y.p</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, z)</span>:</span></span><br><span class="line">        <span class="string">"""插入结点z"""</span></span><br><span class="line">        y, x = <span class="literal">None</span>, self.root</span><br><span class="line">        <span class="keyword">while</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            y = x</span><br><span class="line">            <span class="keyword">if</span> z.key &lt; x.key:</span><br><span class="line">                x = x.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x = x.right</span><br><span class="line">        z.p = y</span><br><span class="line">        <span class="keyword">if</span> y <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.root = z</span><br><span class="line">        <span class="keyword">elif</span> z.key &lt; y.key:</span><br><span class="line">            y.left = z</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            y.right = z</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transplant</span><span class="params">(self, u, v)</span>:</span></span><br><span class="line">        <span class="string">"""用v替换u"""</span></span><br><span class="line">        <span class="keyword">if</span> u.p <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.root = v</span><br><span class="line">        <span class="keyword">elif</span> u == u.p.left:</span><br><span class="line">            u.p.left = v</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            u.p.right = v</span><br><span class="line">        <span class="keyword">if</span> v <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            v.p = u.p</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, z)</span>:</span></span><br><span class="line">        <span class="string">"""删除结点z"""</span></span><br><span class="line">        <span class="keyword">if</span> z.left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.transplant(z, z.right)</span><br><span class="line">        <span class="keyword">elif</span> z.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.transplant(z, z.left)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            y = self.minimum(z.right)</span><br><span class="line">            <span class="keyword">if</span> y.p != z:</span><br><span class="line">                self.transplant(y, y.right)</span><br><span class="line">                y.right, y.right.p = z.right, y</span><br><span class="line">            self.transplant(z, y)</span><br><span class="line">            y.left, y.left.p = z.left, y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    key = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">18</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">15</span>, <span class="number">19</span>, <span class="number">17</span>, <span class="number">3</span>, <span class="number">21</span>]</span><br><span class="line">    n = &#123;i: Node(i) <span class="keyword">for</span> i <span class="keyword">in</span> key&#125;</span><br><span class="line">    bst = BinarySearchTree()</span><br><span class="line">    [bst.insert(n[i]) <span class="keyword">for</span> i <span class="keyword">in</span> key]</span><br><span class="line">    print(<span class="string">'初始    '</span>, bst)</span><br><span class="line">    print(<span class="string">'查找 8  '</span>, bst.search(bst.root, <span class="number">8</span>))  <span class="comment"># 在整棵树中搜索</span></span><br><span class="line">    print(<span class="string">'查找 9  '</span>, bst.search(bst.root, <span class="number">9</span>))</span><br><span class="line">    print(<span class="string">'12的前驱'</span>, bst.predecessor(n[<span class="number">12</span>]))  <span class="comment"># 前驱</span></span><br><span class="line">    print(<span class="string">'12的后继'</span>, bst.successor(n[<span class="number">12</span>]))  <span class="comment"># 后继</span></span><br><span class="line">    n[<span class="number">8</span>] = Node(<span class="number">8</span>)</span><br><span class="line">    bst.insert(n[<span class="number">8</span>])  <span class="comment"># 插入</span></span><br><span class="line">    print(<span class="string">'插入 8后'</span>, bst)</span><br><span class="line">    bst.delete(n[<span class="number">3</span>])  <span class="comment"># 情况(a)，只有右孩子</span></span><br><span class="line">    print(<span class="string">'删除 3后'</span>, bst)</span><br><span class="line">    bst.delete(n[<span class="number">8</span>])  <span class="comment"># 情况(a)，只有左孩子</span></span><br><span class="line">    print(<span class="string">'删除 8后'</span>, bst)</span><br><span class="line">    bst.delete(n[<span class="number">18</span>])  <span class="comment"># 情况(c)，有右孩子结点19，且右孩子是其后继结点</span></span><br><span class="line">    print(<span class="string">'删除18后'</span>, bst)</span><br><span class="line">    bst.delete(n[<span class="number">12</span>])  <span class="comment"># 情况(d)，后继结点是15</span></span><br><span class="line">    print(<span class="string">'删除12后'</span>, bst)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">初始     &#123;12: [&#123;5: [&#123;2: [None, 3]&#125;, 9]&#125;, &#123;18: [&#123;15: [None, 17]&#125;, &#123;19: [None, 21]&#125;]&#125;]&#125;</span><br><span class="line">查找 8   None</span><br><span class="line">查找 9   9</span><br><span class="line">12的前驱 9</span><br><span class="line">12的后继 15</span><br><span class="line">插入 8后 &#123;12: [&#123;5: [&#123;2: [None, 3]&#125;, &#123;9: [8, None]&#125;]&#125;, &#123;18: [&#123;15: [None, 17]&#125;, &#123;19: [None, 21]&#125;]&#125;]&#125;</span><br><span class="line">删除 3后 &#123;12: [&#123;5: [2, &#123;9: [8, None]&#125;]&#125;, &#123;18: [&#123;15: [None, 17]&#125;, &#123;19: [None, 21]&#125;]&#125;]&#125;</span><br><span class="line">删除 8后 &#123;12: [&#123;5: [2, 9]&#125;, &#123;18: [&#123;15: [None, 17]&#125;, &#123;19: [None, 21]&#125;]&#125;]&#125;</span><br><span class="line">删除18后 &#123;12: [&#123;5: [2, 9]&#125;, &#123;19: [&#123;15: [None, 17]&#125;, 21]&#125;]&#125;</span><br><span class="line">删除12后 &#123;15: [&#123;5: [2, 9]&#125;, &#123;19: [17, 21]&#125;]&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction To Algorithms </tag>
            
            <tag> data structures </tag>
            
            <tag> binary tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有根树</title>
      <link href="/notes/introduction-to-algorithms/rooted-trees/"/>
      <url>/notes/introduction-to-algorithms/rooted-trees/</url>
      
        <content type="html"><![CDATA[<h1 id="有根树">有根树</h1><p>表示链表的方法可以推广到任意同构的数据结构上。树的结点用对象表示。与链表类似，每个结点都含有一个关键字<code>key</code>。其余的属性包括指向其他结点的指针，它们随树的种类不同会有所变化。</p><p>链表的结点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Node:</span><br><span class="line">    key       <span class="comment"># 结点自身的键值</span></span><br><span class="line">    previous  <span class="comment"># 前驱节点</span></span><br><span class="line">    next      <span class="comment"># 后继结点</span></span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="二叉树">二叉树</h1><p>二叉树的结点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Node:</span><br><span class="line">    key    <span class="comment"># 键值</span></span><br><span class="line">    p      <span class="comment"># 父节点，只有根节点的父节点为NIL</span></span><br><span class="line">    left   <span class="comment"># 左孩子，若没有左孩子，则该属性为NIL</span></span><br><span class="line">    right  <span class="comment"># 右孩子，若没有右孩子，则该属性为NIL</span></span><br></pre></td></tr></table></figure><p><img title="二叉树的表示方法" data-src="/uploads/posts/binary-tree.png"></p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.p = self.left = self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_left</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.left, n.p = n, self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_right</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.right, n.p = n, self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.values(self.root))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">values</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""递归得到以当前结点为根节点的子树中所有结点的值"""</span></span><br><span class="line">        v, c = [], <span class="number">0</span>  <span class="comment"># c：孩子个数</span></span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            v.append(self.values(node.left))</span><br><span class="line">            c += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            v.append(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            v.append(self.values(node.right))</span><br><span class="line">            c += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            v.append(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> c &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;node.key: v&#125;</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> node.key</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    key = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">    n = [Node(i) <span class="keyword">for</span> i <span class="keyword">in</span> key]</span><br><span class="line">    t = BinaryTree()</span><br><span class="line">    t.root = n[<span class="number">0</span>]</span><br><span class="line">    n[<span class="number">0</span>].set_left(n[<span class="number">1</span>])</span><br><span class="line">    n[<span class="number">0</span>].set_right(n[<span class="number">2</span>])</span><br><span class="line">    n[<span class="number">1</span>].set_right(n[<span class="number">3</span>])</span><br><span class="line">    n[<span class="number">2</span>].set_left(n[<span class="number">4</span>])</span><br><span class="line">    n[<span class="number">2</span>].set_right(n[<span class="number">5</span>])</span><br><span class="line">    n[<span class="number">3</span>].set_left(n[<span class="number">6</span>])</span><br><span class="line">    n[<span class="number">3</span>].set_right(n[<span class="number">7</span>])</span><br><span class="line">    n[<span class="number">4</span>].set_right(n[<span class="number">8</span>])</span><br><span class="line">    n[<span class="number">5</span>].set_left(n[<span class="number">9</span>])</span><br><span class="line">    n[<span class="number">8</span>].set_left(n[<span class="number">10</span>])</span><br><span class="line">    print(t)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">0</span>: [&#123;<span class="number">1</span>: [<span class="literal">None</span>, &#123;<span class="number">3</span>: [<span class="number">6</span>, <span class="number">7</span>]&#125;]&#125;, &#123;<span class="number">2</span>: [&#123;<span class="number">4</span>: [<span class="literal">None</span>, &#123;<span class="number">8</span>: [<span class="number">10</span>, <span class="literal">None</span>]&#125;]&#125;, &#123;<span class="number">5</span>: [<span class="number">9</span>, <span class="literal">None</span>]&#125;]&#125;]&#125;</span><br></pre></td></tr></table></figure><h1 id="分支无限制的有根树">分支无限制的有根树</h1><p>二叉树的表示方法可以推广到每个结点的孩子数至多为常数k的任意类型的树：只需要将<code>left</code>和<code>right</code>属性用<code>child1</code>，<code>child2</code>，…，<code>childk</code>代替。缺点是，若大部分结点只有少量的孩子，则会浪费大量存储空间（大量无意义的孩子指针）。此外，若孩子的结点数无限制时，此方法失效。所幸的是，有一个巧妙地方法可以用来表示孩子数任意的树。</p><p><strong>左孩子右兄弟表示法</strong>（left-child, right-sibling representation）：对任意n个结点的有根树，只需要<span class="math inline">\(O(n)\)</span>的存储空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Node:</span><br><span class="line">    key              <span class="comment"># 键值</span></span><br><span class="line">    p                <span class="comment"># 父节点，若为根节点，则为NIL</span></span><br><span class="line">    left-child       <span class="comment"># 最左边的孩子结点，若没有孩子结点，则为NIL</span></span><br><span class="line">    right-sibling    <span class="comment"># 右侧相邻的兄弟结点，若是其父节点的最右孩子，则为NIL</span></span><br></pre></td></tr></table></figure><p><img title="不限分支数的有根树的表示方法" data-src="/uploads/posts/tree-with-unbounded-branching.png"></p><h2 id="代码-1">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> data_structure.binary_tree <span class="keyword">import</span> Node <span class="keyword">as</span> Ne</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(Ne)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_child</span><span class="params">(self, c)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.set_left(c)  <span class="comment"># 添加第一个孩子</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 追加孩子</span></span><br><span class="line">            x = self.left</span><br><span class="line">            <span class="keyword">while</span> x.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment"># 寻找追加位置</span></span><br><span class="line">                x = x.right</span><br><span class="line">            x.right, c.p = c, self  <span class="comment"># 添加指针</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        self.root = root</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.values(self.root))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">values</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 没有孩子节点</span></span><br><span class="line">            <span class="keyword">return</span> node.key</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c = node.left</span><br><span class="line">            v = [self.values(c)]  <span class="comment"># 所有孩子组成的列表</span></span><br><span class="line">            <span class="keyword">while</span> c.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                v.append(self.values(c.right))</span><br><span class="line">                c = c.right</span><br><span class="line">            <span class="keyword">return</span> &#123;node.key: v&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    key = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line">    n = [Node(i) <span class="keyword">for</span> i <span class="keyword">in</span> key]</span><br><span class="line">    t = Tree(n[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        n[<span class="number">0</span>].add_child(n[i])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>, <span class="number">6</span>):</span><br><span class="line">        n[<span class="number">1</span>].add_child(n[i])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>, <span class="number">10</span>):</span><br><span class="line">        n[<span class="number">2</span>].add_child(n[i])</span><br><span class="line">    n[<span class="number">3</span>].add_child(n[<span class="number">10</span>])</span><br><span class="line">    n[<span class="number">5</span>].add_child(n[<span class="number">11</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">12</span>, <span class="number">14</span>):</span><br><span class="line">        n[<span class="number">8</span>].add_child(n[i])</span><br><span class="line">    print(t)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;0: [&#123;1: [4, &#123;5: [11]&#125;]&#125;, &#123;2: [6, 7, &#123;8: [12, 13]&#125;, 9]&#125;, &#123;3: [10]&#125;]&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction To Algorithms </tag>
            
            <tag> data structures </tag>
            
            <tag> binary tree </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/notes/introduction-to-algorithms/linked-lists/"/>
      <url>/notes/introduction-to-algorithms/linked-lists/</url>
      
        <content type="html"><![CDATA[<h1 id="链表">链表</h1><p>链表（linked list）中的各元素按线性顺序排列。数据的线性顺序是由数组下标决定的，然而与数组不同的是，链表的顺序是由各个对象里的指针决定的。链表为动态集合提供了一种简单而灵活的表示方法。</p><h1 id="种类">种类</h1><p>链表可以有多种形式。它可以是单链接的或双链接的，可以是已排序的或未排序的，可以是循环的或非循环的。</p><ul><li><p>双向链表（doubly linked list）<code>L</code>的每个元素都是一个对象，每个对象有一个关键字<code>k</code>和两个指针：<code>next</code>和<code>prev</code>。对象中还可以包含其他辅助数据（或称为卫星数据）。设<code>x</code>为链表的一个元素，<code>x.next</code>指向它在链表中的后继元素，<code>x.prev</code>则指向它的前驱元素。如果<code>x.prev=NIL</code>，则元素<code>x</code>没有前驱，因此是链表的第一个元素，即链表的头（head）。如果<code>x.next=NIL</code>，则元素<code>x</code>没有后继，因此是链表的最后一个元素，即链表的尾（tail）。属性<code>L.head</code>指向链表的第一个元素。如果<code>L.head=NIL</code>，则链表为空。</p><p><img title="链表" data-src="/uploads/posts/linked-list.png"></p></li><li><p>单链接的（single linked）：省略每个元素中的<code>prev</code>指针。</p></li></ul><a id="more"></a><ul><li>已排序（sorted）的：链表的线性顺序与链表元素中关键字的线性顺序一致。据此，最小的元素就是表头元素，而最大的元素则是表尾元素。</li><li><p>未排序（unsorted）的：链表的各元素可以以任何顺序出现。</p></li><li><p>循环链表（circular list）：表头元素的<code>prev</code>指针指向表尾元素，而表尾元素的<code>next</code>指针则指向表头元素。可以将循环链表想象成一个各元素组成的圆环。</p></li></ul><h1 id="操作">操作</h1><h2 id="搜索">搜索</h2><p>过程<code>LIST-SEARCH</code>采用简单的线性搜索方法，用于查找链表<code>L</code>中第一个关键字为<code>k</code>的元素，并返回指向该元素的指针。如果链表中没有关键字为<code>k</code>的对象，则返回NIL。要搜索一个有n个对象的链表，过程<code>LIST-SEARCH</code>在最坏情况下的运行时间为<span class="math inline">\(\Theta(n)\)</span>，因为可能需要搜索整个链表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LIST-SEARCH(L, k):</span><br><span class="line">    x = L.head</span><br><span class="line">    <span class="keyword">while</span> x != NIL <span class="keyword">and</span> x.key != k:</span><br><span class="line">        x = x.next</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h2 id="插入">插入</h2><p>给定一个元素<code>x</code>，过程<code>LIST-INSERT</code>将<code>x</code>”连接入“到链表的前端。在一个含<code>n</code>个元素的链表上执行<code>LIST-INSERT</code>的运行时间是<span class="math inline">\(\Theta(1)\)</span>。例如，在(a)所示的链表中插入键值为25的元素。插入后的链表如(b)所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LIST-INSERT(L, x):</span><br><span class="line">    x.next = L.head      <span class="comment"># 将x的后继元素指向当前head</span></span><br><span class="line">    <span class="keyword">if</span> L.head != NIL:    <span class="comment"># 若当前head不为NIL</span></span><br><span class="line">        L.head.prev = x  <span class="comment"># 修改head的前驱元素为x</span></span><br><span class="line">    L.head = x           <span class="comment"># 更改链表的表头元素</span></span><br><span class="line">    x.prev = NIL         <span class="comment"># 修改x的前驱元素为NIL</span></span><br></pre></td></tr></table></figure><h2 id="删除">删除</h2><p>过程<code>LIST-DELETE</code>将一个元素<code>x</code>从链表<code>L</code>中移除。通过修改一些指针，将<code>x</code>“删除出”该链表。如果要删除具有给定关键字值的元素，则必须先调用<code>LIST-SEARCH</code>找到该元素。<code>LIST-DELETE</code>的运行时间为<span class="math inline">\(\Theta(1)\)</span>。例如，在(b)所示的链表中删除键值为4的元素，删除后的链表如(c)所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LIST-DELETE(L, x):</span><br><span class="line">    <span class="keyword">if</span> x.prev != NIL:          <span class="comment"># 如果x不是表头元素</span></span><br><span class="line">        x.prev.next = x.next   <span class="comment"># 修改x的前驱中的后继指针</span></span><br><span class="line">    <span class="keyword">else</span>:                      <span class="comment"># 如果x是表头元素，则x没有前驱</span></span><br><span class="line">        L.head = x.next        <span class="comment"># 直接修改表头指针</span></span><br><span class="line">    <span class="keyword">if</span> x.next != NIL:          <span class="comment"># 如果x有后继元素</span></span><br><span class="line">        x.next.prev = x.prev   <span class="comment"># 修改后继元素的前驱指针</span></span><br></pre></td></tr></table></figure><h2 id="哨兵">哨兵</h2><p>哨兵（sentinel）是一个哑对象，其作用是简化边界条件的处理。在链表<code>L</code>中设置一个哨兵<code>L.nil</code>，对于链表代码中出现的每一处（表头和表尾）对<code>NIL</code>的引用，都代之以对哨兵<code>L.nil</code>的引用，即表头元素的<code>prev</code>指针和表尾的<code>next</code>指针均指向<code>L.nil</code>。这样的调整将一个常规的双向链表转变为一个<strong>有哨兵的双向循环链表</strong>（circular, doubly linked list with a sentinel），哨兵位于表头和表尾之间。属性<code>L.nil.next</code>指向表头，<code>L.nil.prev</code>指向表尾。一个空链表只由一个哨兵构成，<code>L.nil.next</code>和<code>L.nil.prev</code>同时指向<code>L.nil</code>。</p><p><img title="有哨兵的双向循环链表" data-src="/uploads/posts/circular-doubly-linked-list-with-a-sentinel.png"></p><p>应当慎用哨兵。假如有许多个很短的链表，它们的哨兵所占用的额外的存储空间会造成严重的存储浪费。</p><p>引入哨兵后，搜索、插入和删除的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LIST-SEARCH<span class="string">'(L, k):</span></span><br><span class="line"><span class="string">    x = L.nil.next   # 初始x指向表头元素</span></span><br><span class="line"><span class="string">    while x != L.nil and x.key != k:</span></span><br><span class="line"><span class="string">        x = x.next</span></span><br><span class="line"><span class="string">    return x</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">LIST-INSERT'</span>(L, X):</span><br><span class="line">    x.next = L.nil.next</span><br><span class="line">    L.nil.next.prev = x</span><br><span class="line">    L.nil.next = x</span><br><span class="line">    x.prev = L.nil</span><br><span class="line"></span><br><span class="line">LIST-DELETE<span class="string">'(L, x):</span></span><br><span class="line"><span class="string">    x.prev.next = x.next</span></span><br><span class="line"><span class="string">    x.next.prev = x.prev</span></span><br></pre></td></tr></table></figure><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.prev = self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>:</span></span><br><span class="line">    <span class="string">"""双向循环链表"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""空链表"""</span></span><br><span class="line">        self.nil, self.size = Element(<span class="literal">None</span>), <span class="number">0</span></span><br><span class="line">        self.nil.prev = self.nil.next = self.nil  <span class="comment"># 哨兵（sentinel）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str([x.key <span class="keyword">for</span> x <span class="keyword">in</span> self])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self.to_list())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_list</span><span class="params">(self)</span>:</span></span><br><span class="line">        x, values = self.head(), []</span><br><span class="line">        <span class="keyword">while</span> x != self.nil:</span><br><span class="line">            values.append(x)</span><br><span class="line">            x = x.next</span><br><span class="line">        <span class="keyword">return</span> values</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""删除元素x"""</span></span><br><span class="line">        x.prev.next, x.next.prev = x.next, x.prev</span><br><span class="line">        self.size -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        <span class="string">"""查找键值为k的元素"""</span></span><br><span class="line">        x = self.head()</span><br><span class="line">        <span class="keyword">while</span> x != self.nil <span class="keyword">and</span> x.key != k:  <span class="comment"># 找不到时x重新指向nil</span></span><br><span class="line">            x = x.next</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""插入元素x，x作为新的表头"""</span></span><br><span class="line">        x.next, self.head().prev = self.head(), x  <span class="comment"># 链接x与第1个元素</span></span><br><span class="line">        self.nil.next, x.prev = x, self.nil  <span class="comment"># 链接哨兵与x</span></span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">head</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回表头元素"""</span></span><br><span class="line">        <span class="keyword">return</span> self.nil.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tail</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回表尾元素"""</span></span><br><span class="line">        <span class="keyword">return</span> self.nil.prev</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(y, z)</span>:</span></span><br><span class="line">    <span class="string">"""合并链表y和z为一个新的链表，y和z会被销毁"""</span></span><br><span class="line">    x = LinkedList()</span><br><span class="line">    x.nil.next, y.head().prev = y.head(), x.nil  <span class="comment"># 链接x.nil与y的头部</span></span><br><span class="line">    x.nil.prev, z.tail().next = z.tail(), x.nil  <span class="comment"># 链接x.nil与z的尾部</span></span><br><span class="line">    y.tail().next, z.head().prev = z.head(), y.tail()  <span class="comment"># 链接y的尾部与z的头部</span></span><br><span class="line">    y = z = <span class="literal">None</span>  <span class="comment"># 销毁y和z</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    l = LinkedList()</span><br><span class="line">    l.insert(Element(<span class="number">1</span>))</span><br><span class="line">    l.insert(Element(<span class="number">2</span>))</span><br><span class="line">    l.insert(Element(<span class="number">3</span>))</span><br><span class="line">    l.insert(Element(<span class="number">4</span>))</span><br><span class="line">    l.insert(Element(<span class="number">5</span>))</span><br><span class="line">    l.insert(Element(<span class="number">6</span>))</span><br><span class="line">    print(l)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[6, 5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction To Algorithms </tag>
            
            <tag> data structures </tag>
            
            <tag> list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mathjax快速参考</title>
      <link href="/documentation/mathjax-quick-reference/"/>
      <url>/documentation/mathjax-quick-reference/</url>
      
        <content type="html"><![CDATA[<h1 id="希腊字母">希腊字母</h1><table><thead><tr class="header"><th>Notation</th><th>Commands</th><th>Notation</th><th>Commands</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\alpha\)</span></td><td><code>\alpha</code></td><td><span class="math inline">\(\beta\)</span></td><td><code>\beta</code></td></tr><tr class="even"><td><span class="math inline">\(\gamma\)</span> <span class="math inline">\(\Gamma\)</span></td><td><code>\gamma    \Gamma</code></td><td><span class="math inline">\(\delta\)</span> <span class="math inline">\(\Delta\)</span></td><td><code>\delta    \Delta</code></td></tr><tr class="odd"><td><span class="math inline">\(\varepsilon\)</span></td><td><code>\varepsilon</code></td><td><span class="math inline">\(\epsilon\)</span></td><td><code>\epsilon</code></td></tr><tr class="even"><td><span class="math inline">\(\zeta\)</span></td><td><code>\zeta</code></td><td><span class="math inline">\(\eta\)</span></td><td><code>\eta</code></td></tr><tr class="odd"><td><span class="math inline">\(\theta\)</span> <span class="math inline">\(\Theta\)</span></td><td><code>\theta    \Theta</code></td><td><span class="math inline">\(\vartheta\)</span></td><td><code>\vartheta</code></td></tr><tr class="even"><td><span class="math inline">\(\iota\)</span></td><td><code>\iota</code></td><td><span class="math inline">\(\kappa\)</span></td><td><code>\kappa</code></td></tr><tr class="odd"><td><span class="math inline">\(\lambda\)</span> <span class="math inline">\(\Lambda\)</span></td><td><code>\lambda    \Lambda</code></td><td><span class="math inline">\(\mu\)</span></td><td><code>\mu</code></td></tr><tr class="even"><td><span class="math inline">\(\nu\)</span></td><td><code>\nu</code></td><td><span class="math inline">\(\xi\)</span> <span class="math inline">\(\Xi\)</span></td><td><code>\xi    \Xi</code></td></tr><tr class="odd"><td><span class="math inline">\(\omicron\)</span></td><td><code>\omicron</code></td><td><span class="math inline">\(\pi\)</span> <span class="math inline">\(\Pi\)</span></td><td><code>\pi    \Pi</code></td></tr><tr class="even"><td><span class="math inline">\(\varpi\)</span></td><td><code>\varpi</code></td><td><span class="math inline">\(\rho\)</span></td><td><code>\rho</code></td></tr><tr class="odd"><td><span class="math inline">\(\varrho\)</span></td><td><code>\varrho</code></td><td><span class="math inline">\(\sigma\)</span> <span class="math inline">\(\Sigma\)</span></td><td><code>\sigma    \Sigma</code></td></tr><tr class="even"><td><span class="math inline">\(\varsigma\)</span></td><td><code>\varsigma</code></td><td><span class="math inline">\(\tau\)</span></td><td><code>\tau</code></td></tr><tr class="odd"><td><span class="math inline">\(\upsilon\)</span> <span class="math inline">\(\Upsilon\)</span></td><td><code>\upsilon    \Upsilon</code></td><td><span class="math inline">\(\varphi\)</span></td><td><code>\varphi</code></td></tr><tr class="even"><td><span class="math inline">\(\phi\)</span> <span class="math inline">\(\Phi\)</span></td><td><code>\phi    \Phi</code></td><td><span class="math inline">\(\chi\)</span></td><td><code>\chi</code></td></tr><tr class="odd"><td><span class="math inline">\(\psi\)</span> <span class="math inline">\(\Psi\)</span></td><td><code>\psi    \Psi</code></td><td><span class="math inline">\(\omega\)</span> <span class="math inline">\(\Omega\)</span></td><td><code>\omega    \Omega</code></td></tr></tbody></table><a id="more"></a><h1 id="括号">括号</h1><table><colgroup><col style="width: 27%"><col style="width: 24%"><col style="width: 24%"><col style="width: 24%"></colgroup><thead><tr class="header"><th>Notation</th><th>Commands</th><th>Notation</th><th>Commands</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\lbrace\)</span> <span class="math inline">\(\rbrace\)</span></td><td><code>\lbrace    \rbrace</code></td><td><span class="math inline">\(\mid\)</span></td><td><code>| or \mid</code></td></tr><tr class="even"><td><span class="math inline">\(\Vert\)</span></td><td><code>\Vert</code></td><td><span class="math inline">\(\langle\)</span> <span class="math inline">\(\rangle\)</span></td><td><code>\langle    \rangle</code></td></tr><tr class="odd"><td><span class="math inline">\(\lceil\)</span> <span class="math inline">\(\rceil\)</span> <span class="math inline">\(\lfloor\)</span> <span class="math inline">\(\rfloor\)</span></td><td><code>\lceil \rceil</code> <code>\lfloor \rfloor</code></td><td><span class="math inline">\(\Bigg(\bigg(\big((x)\big)\Big)\Bigg)\)</span></td><td><code>\Bigg(\bigg(\big((x)\big)\Big)\Bigg)</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mathjax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斐波那契堆</title>
      <link href="/notes/introduction-to-algorithms/fibonacci-heaps/"/>
      <url>/notes/introduction-to-algorithms/fibonacci-heaps/</url>
      
        <content type="html"><![CDATA[<h1 id="斐波那契堆">斐波那契堆</h1><p>斐波那契堆数据结构有两种用途：</p><ul><li>它支持一些列操作，这些操作构成了所谓的“可合并堆”。</li><li>斐波那契堆的一些操作（<code>INSERT/UNION/DECREASE-KEY</code>）可以在常数摊还时间内完成，非常适用于需要频繁使用这些操作的应用。</li></ul><a id="more"></a><table><thead><tr class="header"><th>操作</th><th>二项堆（最坏情形）</th><th>斐波那契堆（摊还）</th></tr></thead><tbody><tr class="odd"><td><code>MAKE-HEAP()</code>：创建空堆</td><td><span class="math inline">\(\Theta(1)\)</span></td><td><span class="math inline">\(\Theta(1)\)</span></td></tr><tr class="even"><td><code>INSERT(H, x)</code>：插入元素x</td><td><span class="math inline">\(\Theta(\lg{n})\)</span></td><td><span class="math inline">\(\Theta(1)\)</span></td></tr><tr class="odd"><td><code>MINIMUM()</code>：提取最小元素</td><td><span class="math inline">\(\Theta(1)\)</span></td><td><span class="math inline">\(\Theta(1)\)</span></td></tr><tr class="even"><td><code>EXTRACT-MIN()</code>：删除并返回最小元素</td><td><span class="math inline">\(\Theta(\lg{n})\)</span></td><td><span class="math inline">\(O(\lg{n})\)</span></td></tr><tr class="odd"><td><code>UNION(H1, H2)</code>：创建一个包含H1和H2中所有元素的新堆</td><td><span class="math inline">\(\Theta(n)\)</span></td><td><span class="math inline">\(\Theta(1)\)</span></td></tr><tr class="even"><td><code>DECREASE-KEY(H, x, k)</code>：将元素x的关键字赋予新值k</td><td><span class="math inline">\(\Theta(\lg{n})\)</span></td><td><span class="math inline">\(\Theta(1)\)</span></td></tr><tr class="odd"><td><code>DELETE(H, x)</code>：删除元素x</td><td><span class="math inline">\(\Theta(\lg{n})\)</span></td><td><span class="math inline">\(O(\lg{n})\)</span></td></tr></tbody></table><ul><li>从理论上看，当<code>EXTRACT-MIN</code>和<code>DELETE</code>数目相比于其他操作小得多的时候，斐波那契堆尤为合适。例如，一些图问题算法可能每条边调用一次<code>DECREASE-KEY</code>。对于有很多边的稠密图，每次调用<code>DECREASE-KEY</code>需要<span class="math inline">\(\Theta(1)\)</span>摊还时间，相比起二叉堆最坏情况时间<span class="math inline">\(\Theta(\lg{n})\)</span>，其积累起来是个很大的改进。如最小生成树和寻找单源最短路径的快速算法必不可少地要用到斐波那契堆。</li><li>从实际上看，除了某些需要管理大量数据的应用外，对于大多数应用，斐波那契堆的常数因子和编程复杂性使得它比起普通二项（或k项）堆并不那么适用。因此对斐波那契堆的研究主要出于理论研究。</li></ul><h1 id="结构">结构</h1><p>一个斐波那契堆（Fibonacci heap）一系列具有最小堆序（min-heap ordered）的有根树的集合。也就是说，每棵树均遵守最小堆性质（min-heap property）：每个结点的关键字大于或等于它的父结点的关键字。</p><p>斐波那契堆的每个结点<code>x</code>包含：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    int     key      <span class="comment"># 值</span></span><br><span class="line">    int     degree   <span class="comment"># 度，孩子数目</span></span><br><span class="line">    Node    left     <span class="comment"># 左兄弟</span></span><br><span class="line">    Node    right    <span class="comment"># 右兄弟</span></span><br><span class="line">    Node    p        <span class="comment"># 父节点</span></span><br><span class="line">    Node    child    <span class="comment"># 任意一个孩子</span></span><br><span class="line">    bool    marked   <span class="comment"># 是否第一次被删除某个孩子</span></span><br></pre></td></tr></table></figure><p>x的所有孩子被链接成一个环形的双向链表（如下图(b)所示，通常情况下省略了指针，将图画成(a)的样子，因为很容易从(a)中推断出指针指向），称为x的孩子链表（child list）。</p><p>斐波那契堆<code>H</code>包含：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FiboHeap</span>:</span></span><br><span class="line">    Node        min        <span class="comment"># 堆中最小结点（minimum node）</span></span><br><span class="line">    LinkedList  root_list  <span class="comment"># 包含所有根结点的双向环形链表</span></span><br><span class="line">    int         n          <span class="comment"># 堆中所有结点数目</span></span><br></pre></td></tr></table></figure><p><img title="斐波那契堆" data-src="/uploads/posts/fibonacci-heap.png"></p><h1 id="可合并堆">可合并堆</h1><h2 id="创建一个新的斐波那契堆">创建一个新的斐波那契堆</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MAKE-FIB-HEAP():</span><br><span class="line">    H = FiboHeap()</span><br><span class="line">    H.n         = <span class="number">0</span>                 <span class="comment"># 结点数目为0</span></span><br><span class="line">    H.min       = NIL               <span class="comment"># 最小结点为NIL</span></span><br><span class="line">    H.root_list = new LinkedList()  <span class="comment"># 根链表初始为空</span></span><br><span class="line">    <span class="keyword">return</span> H</span><br></pre></td></tr></table></figure><h2 id="插入一个结点">插入一个结点</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FIB-HEAP-INSERT(H, x):</span><br><span class="line">    x.degree    = <span class="number">0</span>                        <span class="comment"># 初始化x的属性</span></span><br><span class="line">    x.p         = NIL</span><br><span class="line">    x.child     = NIL</span><br><span class="line">    x.mark      = <span class="literal">False</span></span><br><span class="line">    H.root_list.insert(x)                  <span class="comment"># 将x插入H的根链表</span></span><br><span class="line">    <span class="keyword">if</span> H.min == NIL <span class="keyword">or</span> x.key &lt; H.min.key:  <span class="comment"># 更新H.min</span></span><br><span class="line">        H.min = x</span><br><span class="line">    H.n = H.n + <span class="number">1</span>                          <span class="comment"># 更新结点数目</span></span><br></pre></td></tr></table></figure><p>在一个斐波那契堆中插入键值为21的结点：</p><p><img title="插入" data-src="/uploads/posts/fib-heap-insert.png"></p><p>图中插入位置为<code>H.min</code>的前驱，实际的插入位置没有影响。</p><h2 id="两个斐波那契堆的合并">两个斐波那契堆的合并</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FIB-HEAP-UNION(H1, H2):</span><br><span class="line">    H = MAKE-FIB-HEAP()</span><br><span class="line">    H.root_list = concatenate(H1.root_list, H2.root_list) <span class="comment"># 合并根链表</span></span><br><span class="line">    H.min = H1.min      <span class="comment"># 判断合并后堆的最小结点</span></span><br><span class="line">    <span class="keyword">if</span> H1.min == NIL <span class="keyword">or</span> (H2.min != NIL <span class="keyword">and</span> H2.min.key &lt; H1.min.key):</span><br><span class="line">        H.min = H2.min</span><br><span class="line">    H.n = H1.n + H2.n   <span class="comment"># 更新结点数目</span></span><br><span class="line">    <span class="keyword">return</span> H</span><br></pre></td></tr></table></figure><h2 id="抽取最小结点">抽取最小结点</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FIB-HEAP-EXTRACT-MIN(H):</span><br><span class="line">    z = H.min</span><br><span class="line">    <span class="keyword">if</span> z != NIL:</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> z.child:           <span class="comment"># 将min的所有孩子结点移动到根链表</span></span><br><span class="line">            H.root_list.insert(x)   <span class="comment"># 更新left和right</span></span><br><span class="line">            x.p = NIL               <span class="comment"># 更新父节点，不更新child意味着孩子结点x的孩子结点不变</span></span><br><span class="line">        H.root_list.delete(z)       <span class="comment"># 删除最小结点min</span></span><br><span class="line">        H.min = NIL</span><br><span class="line">        CONSOLIDATE(H)              <span class="comment"># 子过程</span></span><br><span class="line">        H.n = H.n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> z</span><br></pre></td></tr></table></figure><p>其中子过程<code>CONSOLIDATE(H)</code>用来把具有相同度数的根节点合并（consolidating），直到每个度数至多只有一个根。该过程使用一个辅助数组<code>A[0..D(H.n)]</code>来记录根节点对用的度数的轨迹，其中<code>D(H.n)</code>表示一个n个结点的斐波那契堆中任何结点的最大度数上界（<span class="math inline">\(D(n)=O(\lg{n})\)</span>）。如果<code>A[i]=y</code>，那么当前的<code>y</code>是一个具有<code>y.degree=i</code>的根。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">CONSOLIDATE(H):</span><br><span class="line">    let A[<span class="number">0.</span>.D(H.n)] be a new array</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to D(H.n):  <span class="comment"># 初始化A</span></span><br><span class="line">        A[i] = NIL</span><br><span class="line">    <span class="keyword">for</span> each node w <span class="keyword">in</span> the root list of H:</span><br><span class="line">        x = w</span><br><span class="line">        d = x.degree</span><br><span class="line">        <span class="keyword">while</span> A[d] != NIL:</span><br><span class="line">            y = A[d]      <span class="comment"># 另一个具有相同度数d的结点y</span></span><br><span class="line">            <span class="keyword">if</span> x.key &gt; y.key:</span><br><span class="line">                exchange x <span class="keyword">with</span> y   <span class="comment"># 始终保证x.key &lt; y.key</span></span><br><span class="line">            FIB-HEAP-LINK(H, y, x)  <span class="comment"># 子过程：将y链接为x的孩子结点</span></span><br><span class="line">            A[d] = NIL              <span class="comment"># 合并后具有度数d的结点不存在了</span></span><br><span class="line">            d = d + <span class="number">1</span>               <span class="comment"># 合并后x的度数，通过while循环再次寻找具有相同度数的结点y</span></span><br><span class="line">        A[d] = x                    <span class="comment"># 不存在相同度数d的y，记录x的度数信息</span></span><br><span class="line">        <span class="keyword">if</span> H.min == NIL <span class="keyword">or</span> x.key &lt; H.min.key:  <span class="comment"># 更新min结点</span></span><br><span class="line">            H.min = x</span><br><span class="line"></span><br><span class="line">FIB-HEAP-LINK(H, y, x):</span><br><span class="line">    H.root_list.delete(y)    <span class="comment"># 从H的根链表中移除y</span></span><br><span class="line">    x.child.insert(y)        <span class="comment"># 将y添加到x的孩子结点中</span></span><br><span class="line">    x.degree = x.degree + <span class="number">1</span>  <span class="comment"># 更新x的度</span></span><br><span class="line">    y.mark = <span class="literal">False</span>           <span class="comment"># 清除y上的标记</span></span><br></pre></td></tr></table></figure><p><img title="提取最小的元素" data-src="/uploads/posts/fib-heap-extract-min.png"></p><ul><li><ol type="a"><li>从当前的斐波那契堆中提取最小结点<code>H.min</code>。以后把“键值为x的结点”省略称为“结点x“。</li></ol></li><li><ol type="a"><li><span class="math inline">\(\rightarrow\)</span> (b) 将结点3的所有子节点移动到根链表。<code>H.min</code>指针右移一位。此时不一定指向最小元素，在后续操作中会调整。</li></ol></li><li><ol start="2" type="a"><li><span class="math inline">\(\rightarrow\)</span> (c) 创建一个辅助数组A，遍历根链表。当前结点的度数为1，<code>A[1]</code>为空，将<code>A[1]</code>指向当前结点。继续下一位。</li></ol></li><li><ol start="4" type="a"><li><ol start="5" type="a"><li>过程类似。结果是<code>A[2]</code>指向度数为2的结点24；<code>A[0]</code>指向度数为0的结点23。</li></ol></li></ol></li><li><ol start="5" type="a"><li><span class="math inline">\(\rightarrow\)</span> (f) 结点7的度数为0，但<code>A[0]</code>不为空，将结点7与<code>A[0]</code>指向的结点23合并：键值较大的结点23移动到结点7的子节点链表中。移动后，清除<code>A[0]</code>。</li></ol></li><li><ol start="6" type="a"><li><span class="math inline">\(\rightarrow\)</span> (g) 结点7的度数为1，<code>A[1]</code>不为空且指向结点17。于是将结点17移动到结点7的子结点链表中。清除<code>A[1]</code>。</li></ol></li><li><ol start="7" type="a"><li><span class="math inline">\(\rightarrow\)</span> (h) 结点7的度数为2，<code>A[2]</code>不为空且指向24。合并结点7与结点24。清除<code>A[2]</code>。此时结点7的度数为3，而<code>A[3]</code>为空，令<code>A[3]</code>指向结点结点7。继续下一个结点。</li></ol></li><li><ol type="i"><li><ol start="10" type="a"><li><code>A[0]</code>指向结点21；<code>A[1]</code>指向结点18。</li></ol></li></ol></li><li><ol start="10" type="a"><li><span class="math inline">\(\rightarrow\)</span> (k) 结点52度数为0，<code>A[0]</code>不为空且指向21。合并结点21与结点52。清除<code>A[0]</code>；合并后结点21的度数为1，<code>A[1]</code>指向结点18。合并结点21与结点18。清除<code>A[1]</code>；合并后结点18度数为2，<code>A[2]</code>为空，令<code>A[2]</code>指向结点18。继续下一结点。</li></ol></li><li><ol start="11" type="a"><li><span class="math inline">\(\rightarrow\)</span> (l) 结点38的度数为1，<code>A[1]</code>为空。令<code>A[1]</code>指向结点38。继续下一节点。</li></ol></li><li><ol start="13" type="a"><li>所有结点遍历完毕。更新<code>H.min</code>。</li></ol></li></ul><h1 id="减值和删除">减值和删除</h1><h2 id="关键字减值">关键字减值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">FIB-HEAP-DECREASE-KEY(H, x, k):</span><br><span class="line">    <span class="keyword">if</span> k &gt; x.key:</span><br><span class="line">        error <span class="string">"new key is greater than current key"</span></span><br><span class="line">    x.key = k</span><br><span class="line">    y = x.p</span><br><span class="line">    <span class="keyword">if</span> y != NIL <span class="keyword">and</span> x.key &lt; y.key:  <span class="comment"># 如果更新后x的值小于父节点的值，调整堆</span></span><br><span class="line">        CUT(H, x, y)                <span class="comment"># 子过程：切断x与其父节点y之间的链接</span></span><br><span class="line">        CASCADING-CUT(H, y)         <span class="comment"># 子过程：级联切断</span></span><br><span class="line">    <span class="keyword">if</span> x.key &lt; H.min.key:           <span class="comment"># 更新min结点</span></span><br><span class="line">        H.min = x</span><br><span class="line"></span><br><span class="line">CUT(H, x, y):                <span class="comment"># 切断x与其父节点y之间的链接，并将x添加到根链表</span></span><br><span class="line">    y.child.delete(x)        <span class="comment"># remove x from the child list of y</span></span><br><span class="line">    y.degree = y.degree - <span class="number">1</span>  <span class="comment"># decrementint y.degree</span></span><br><span class="line">    H.root_list.insert(x)    <span class="comment"># add x to the root list of H</span></span><br><span class="line">    x.p = NIL</span><br><span class="line">    x.mark = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">CASCADING-CUT(H, y):            <span class="comment"># 级联切断</span></span><br><span class="line">    z = y.p</span><br><span class="line">    <span class="keyword">if</span> z != NIL:</span><br><span class="line">        <span class="keyword">if</span> y.mark == <span class="literal">False</span>:     <span class="comment"># 如果mark为false，那么上次CUT中，是结点y第一次失去孩子</span></span><br><span class="line">            y.mark == <span class="literal">True</span>      <span class="comment"># 第一次失去孩子，mark置为True</span></span><br><span class="line">        <span class="keyword">else</span>:                   <span class="comment"># 如果mark为True，那么上次CUT之前，y已经失去过孩子</span></span><br><span class="line">            CUT(H, y, z)</span><br><span class="line">            CASCADING-CUT(H, Z) <span class="comment"># 向上递归，直到遇到根节点或者一个未被标记的结点（mark=False）</span></span><br></pre></td></tr></table></figure><p><img title="减小元素的值" data-src="/uploads/posts/fib-heap-decrease-key.png"></p><ul><li><ol type="a"><li>初始斐波那契堆。将结点46的键值降低为15。</li></ol></li><li><ol type="a"><li><span class="math inline">\(\rightarrow\)</span> (b) 修改键值。将修改后的结点15移动到根链表（切断）。其父节点24，之前未被标记。现在失去了一个孩子，标记它。</li></ol></li><li><ol start="2" type="a"><li>在此斐波那契堆上，将结点35的键值降低为5。</li></ol></li><li><ol start="2" type="a"><li><span class="math inline">\(\rightarrow\)</span> (c) 修改键值，将修改后的结点5移动到根链表（切断）。</li></ol></li><li><ol start="3" type="a"><li><span class="math inline">\(\rightarrow\)</span> (d) 结点5的原来的父节点26是被标记的，触发级联切断的条件：切断结点26与其父节点，将结点26移动到根链表，清除其标记。之后对结点26的原来的父节点24递归地调用级联切断过程。</li></ol></li><li><ol start="4" type="a"><li><span class="math inline">\(\rightarrow\)</span> (e) 结点24同样是被标记的，切断结点24与其父节点7。最后对结点24的原来的父节点7递归地调用级联切断。</li></ol></li><li>结点7没有父节点，级联切断不处理此类结点。</li></ul><h2 id="删除一个结点">删除一个结点</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FIB-HEAP-DELETE(H, x):</span><br><span class="line">    FIB-HEAP-DECREASE-KEY(H, x, -infinty)</span><br><span class="line">    FIB-HEAP-EXTRACT-MIN(H)</span><br></pre></td></tr></table></figure><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> data_structure.linked_list <span class="keyword">import</span> Element, LinkedList, union <span class="keyword">as</span> union_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(Element)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        Element.__init__(self, k)</span><br><span class="line">        self.degree, self.mark = <span class="number">0</span>, <span class="literal">False</span>  <span class="comment"># mark：第1次失去孩子后为True、第2次后为False</span></span><br><span class="line">        self.p = self.child = self.prev = self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.value())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">value</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.child <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> len(self.child) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.key</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;self.key: [c.value() <span class="keyword">for</span> c <span class="keyword">in</span> self.child]&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FibHeap</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.n, self.min = <span class="number">0</span>, <span class="literal">None</span>  <span class="comment"># 堆中结点数目, 堆中最小结点</span></span><br><span class="line">        self.root_list = LinkedList()  <span class="comment"># 根链表</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        s = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self.root_list:</span><br><span class="line">            s.append(str(x))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">', '</span>.join(s)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x.degree, x.mark = <span class="number">0</span>, <span class="literal">False</span></span><br><span class="line">        x.p = x.child = <span class="literal">None</span></span><br><span class="line">        self.root_list.insert(x)  <span class="comment"># 插入根链表</span></span><br><span class="line">        <span class="keyword">if</span> self.min <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> x.key &lt; self.min.key:</span><br><span class="line">            self.min = x</span><br><span class="line">        self.n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        z = self.min</span><br><span class="line">        <span class="keyword">if</span> z <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> z.child <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment"># 将所有子节点插入到根链表</span></span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> z.child:</span><br><span class="line">                    self.root_list.insert(x)</span><br><span class="line">                    x.p = <span class="literal">None</span></span><br><span class="line">            self.min = <span class="literal">None</span></span><br><span class="line">            self.root_list.delete(z)  <span class="comment"># 从根链表中移除</span></span><br><span class="line">            self.consolidate()  <span class="comment"># 合并度数相同的结点</span></span><br><span class="line">            self.n -= <span class="number">1</span>  <span class="comment"># 总结点数目减1</span></span><br><span class="line">            z.child = <span class="literal">None</span>  <span class="comment"># 清除指针，不清除对斐波那契堆也没什么影响</span></span><br><span class="line">        <span class="keyword">return</span> z</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">consolidate</span><span class="params">(self)</span>:</span></span><br><span class="line">        degree = &#123;&#125;  <span class="comment"># degree[i]=y，那么y.degree=i</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self.root_list:  <span class="comment"># 在link()中可能被删除的元素已经访问过，因此可以使用迭代器</span></span><br><span class="line">            d = x.degree</span><br><span class="line">            <span class="keyword">while</span> d <span class="keyword">in</span> degree:</span><br><span class="line">                y = degree.pop(d)  <span class="comment"># another node with the same degree as x</span></span><br><span class="line">                <span class="keyword">if</span> x.key &gt; y.key:</span><br><span class="line">                    x, y = y, x</span><br><span class="line">                self.link(y, x)</span><br><span class="line">                d = d + <span class="number">1</span></span><br><span class="line">            degree[d] = x</span><br><span class="line">            <span class="keyword">if</span> self.min <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> self.min.key &gt; x.key:</span><br><span class="line">                self.min = x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">link</span><span class="params">(self, y, x)</span>:</span></span><br><span class="line">        self.root_list.delete(y)</span><br><span class="line">        y.p = x</span><br><span class="line">        <span class="keyword">if</span> x.child <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            x.child = LinkedList()</span><br><span class="line">        x.child.insert(y)</span><br><span class="line">        x.degree += <span class="number">1</span></span><br><span class="line">        y.mark = <span class="literal">False</span>  <span class="comment"># y成为孩子结点时，mark置为False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decrease_key</span><span class="params">(self, x, k)</span>:</span> <span class="comment"># 没有对结点x是否在堆中进行判断，heap.min可能会指向堆外结点</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; x.key:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'new key is greater than current key'</span>)</span><br><span class="line">        x.key, y = k, x.p</span><br><span class="line">        <span class="keyword">if</span> y <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> x.key &lt; y.key:  <span class="comment"># 当更新后的值小于父节点时调整堆</span></span><br><span class="line">            self.cut(x, y)  <span class="comment"># 切断x与y</span></span><br><span class="line">            self.cascading_cut(y)</span><br><span class="line">        <span class="keyword">if</span> x.key &lt; self.min.key:</span><br><span class="line">            self.min = x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cut</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        y.child.delete(x)  <span class="comment"># 分离x与其父节点y</span></span><br><span class="line">        self.root_list.insert(x)  <span class="comment"># 使x成为根节点</span></span><br><span class="line">        y.degree -= <span class="number">1</span></span><br><span class="line">        x.p, x.mark = <span class="literal">None</span>, <span class="literal">False</span>  <span class="comment"># x成为根结点时，mark置为False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cascading_cut</span><span class="params">(self, y)</span>:</span></span><br><span class="line">        z = y.p</span><br><span class="line">        <span class="keyword">if</span> z <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> y.mark <span class="keyword">is</span> <span class="literal">False</span>:  <span class="comment"># mark=False，是第一次失去孩子</span></span><br><span class="line">                y.mark = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># mark=True,是第二次失去孩子</span></span><br><span class="line">                self.cut(y, z)</span><br><span class="line">                self.cascading_cut(z)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.decrease_key(x, float(<span class="string">'-inf'</span>))</span><br><span class="line">        self.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(h1, h2)</span>:</span></span><br><span class="line">    h = FibHeap()  <span class="comment"># 初始化新堆</span></span><br><span class="line">    h.root_list = union_list(h1.root_list, h2.root_list)  <span class="comment"># 合并根链表，h1和h2的根链表会被销毁</span></span><br><span class="line">    h.min = h1.min  <span class="comment"># 比较最小结点</span></span><br><span class="line">    <span class="keyword">if</span> h1.min <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> (h2.min <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> h2.min.key &lt; h1.min.key):</span><br><span class="line">        h.min = h2.min</span><br><span class="line">    h.n = h1.n + h2.n  <span class="comment"># 结点数目相加</span></span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    h1, h2 = FibHeap(), FibHeap()</span><br><span class="line">    key1, key2 = [<span class="number">23</span>, <span class="number">7</span>, <span class="number">21</span>, <span class="number">3</span>, <span class="number">17</span>, <span class="number">24</span>, <span class="number">18</span>], [<span class="number">52</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">26</span>, <span class="number">46</span>, <span class="number">39</span>, <span class="number">41</span>, <span class="number">35</span>]</span><br><span class="line">    [h1.insert(Node(i)) <span class="keyword">for</span> i <span class="keyword">in</span> key1]</span><br><span class="line">    [h2.insert(Node(i)) <span class="keyword">for</span> i <span class="keyword">in</span> key2]</span><br><span class="line">    print(<span class="string">'h1:'</span>, h1)</span><br><span class="line">    print(<span class="string">'h2:'</span>, h2)</span><br><span class="line">    h = union(h1, h2)  <span class="comment"># union，合并根链表</span></span><br><span class="line">    print(<span class="string">'h:'</span>, h)</span><br><span class="line">    print(<span class="string">'&#123;0:&lt;3s&#125; &#123;1:&lt;6s&#125;'</span>.format(<span class="string">'pop'</span>, <span class="string">'h'</span>))</span><br><span class="line">    <span class="keyword">while</span> h.n &gt; <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">'&#123;0:&lt;3d&#125; &#123;1:&lt;6s&#125;'</span>.format(h.pop().key, str(h)))</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">h1: 18, 24, 17, 3, 21, 7, 23</span><br><span class="line">h2: 35, 41, 39, 46, 26, 30, 38, 52</span><br><span class="line">h: 18, 24, 17, 3, 21, 7, 23, 35, 41, 39, 46, 26, 30, 38, 52</span><br><span class="line">pop h</span><br><span class="line">3   &#123;7: [&#123;17: [&#123;18: [24]&#125;, 21]&#125;, &#123;35: [41]&#125;, 23]&#125;, &#123;26: [&#123;39: [46]&#125;, 30]&#125;, &#123;38: [52]&#125;</span><br><span class="line">7   23, &#123;35: [&#123;38: [52]&#125;, 41]&#125;, &#123;17: [&#123;26: [&#123;39: [46]&#125;, 30]&#125;, &#123;18: [24]&#125;, 21]&#125;</span><br><span class="line">17  &#123;18: [&#123;26: [&#123;39: [46]&#125;, 30]&#125;, &#123;21: [23]&#125;, 24]&#125;, &#123;35: [&#123;38: [52]&#125;, 41]&#125;</span><br><span class="line">18  24, &#123;21: [23]&#125;, &#123;26: [&#123;35: [&#123;38: [52]&#125;, 41]&#125;, &#123;39: [46]&#125;, 30]&#125;</span><br><span class="line">21  &#123;23: [24]&#125;, &#123;26: [&#123;35: [&#123;38: [52]&#125;, 41]&#125;, &#123;39: [46]&#125;, 30]&#125;</span><br><span class="line">23  24, &#123;26: [&#123;35: [&#123;38: [52]&#125;, 41]&#125;, &#123;39: [46]&#125;, 30]&#125;</span><br><span class="line">24  &#123;26: [&#123;35: [&#123;38: [52]&#125;, 41]&#125;, &#123;39: [46]&#125;, 30]&#125;</span><br><span class="line">26  30, &#123;39: [46]&#125;, &#123;35: [&#123;38: [52]&#125;, 41]&#125;</span><br><span class="line">30  &#123;39: [46]&#125;, &#123;35: [&#123;38: [52]&#125;, 41]&#125;</span><br><span class="line">35  41, &#123;38: [&#123;39: [46]&#125;, 52]&#125;</span><br><span class="line">38  &#123;39: [&#123;41: [52]&#125;, 46]&#125;</span><br><span class="line">39  46, &#123;41: [52]&#125;</span><br><span class="line">41  &#123;46: [52]&#125;</span><br><span class="line">46  52</span><br><span class="line">52</span><br></pre></td></tr></table></figure><h1 id="应用">应用</h1><ul><li>Dijkstra算法</li><li>Prim算法</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction To Algorithms </tag>
            
            <tag> data structures </tag>
            
            <tag> heap </tag>
            
            <tag> fibonacci heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斯特灵近似公式</title>
      <link href="/mathematics/stirling-s-approximation/"/>
      <url>/mathematics/stirling-s-approximation/</url>
      
        <content type="html"><![CDATA[<h1 id="斯特灵公式">斯特灵公式</h1><p>斯特灵公式（Stirling's approximation, or Stirling's formula）是一条用来取n阶乘近似值的数学公式。一般来说，当n很大的时候，n阶乘的计算量十分大，所以斯特灵公式十分好用。而且，即使在n很小的时候，斯特灵公式的取值已经十分准确。</p><p><span class="math display">\[n! \approx \sqrt{2\pi{n}}(\frac{n}{e})^n\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> formula </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/notes/introduction-to-algorithms/quicksort/"/>
      <url>/notes/introduction-to-algorithms/quicksort/</url>
      
        <content type="html"><![CDATA[<h1 id="快速排序">快速排序</h1><p>快速排序（Quicksort）是一种高效的比较型排序算法，于1961年由瑞典科学家<a href="https://en.wikipedia.org/wiki/Tony_Hoare" target="_blank" rel="noopener">Tony Hoare</a>发表。与<a href="/algorithm/Merge-sort">归并排序</a>类似，快速排序也是一种分治算法。快速排序是常用的排序算法，一个好的快速排序的实现，甚至可以比归并排序和堆排序快两到三倍。快速排序不是稳定排序，但它是原址排序。排序<span class="math inline">\(n\)</span>个数的<strong>平均</strong>时间代价是<span class="math inline">\(O(n\log{n})\)</span>。最坏情况下，它的时间代价是<span class="math inline">\(O(n^2)\)</span>，这种情况很少出现。快速排序的示例图（来自<a href="https://en.wikipedia.org/wiki/Quicksort" target="_blank" rel="noopener">维基百科：Quicksort</a>）如下：</p><p><img title="快速排序动态过程" data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/6a/Sorting_quicksort_anim.gif/220px-Sorting_quicksort_anim.gif"></p><a id="more"></a><h1 id="实现">实现</h1><p>快速排序同样遵循分治模式，每层递归是有三个步骤：</p><ul><li>分解（Divide）：数组<span class="math inline">\(A[p..r]\)</span>被划分为两个（可能为空）子数组<span class="math inline">\(A[p..q-1]\)</span>和<span class="math inline">\(A[q+1..r]\)</span>，使得<span class="math inline">\(A[i]\le{A[q]}\le{A[j]}, i\in[p,q-1], j\in[q+1,r]\)</span>。其中，计算下标q也是划分过程的一部分。</li><li>解决（Conquer）：通过递归调用快速排序，对子数组<span class="math inline">\(A[p..q-1]\)</span>和<span class="math inline">\(A[q+1..r]\)</span>进行排序。</li><li>合并（Combine）：快速排序不需要合并操作，数组<span class="math inline">\(A[p..r]\)</span>已经有序。</li></ul><p>与归并排序不同，快速排序的比较过程发生在分解阶段，且快速排序是原址排序，所以快速排序不需要合并操作。</p><p>实现快速排序的过程如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">quicksort(A, p, r):</span><br><span class="line">    <span class="keyword">if</span> p &lt; r:</span><br><span class="line">        q = partition(A, p, r)</span><br><span class="line">        quicksort(A, p, q - <span class="number">1</span>)</span><br><span class="line">        quicksort(A, q + <span class="number">1</span>, r)</span><br></pre></td></tr></table></figure><p>快速排序的关键部分是<code>partition</code>过程，它实现了对子数组<span class="math inline">\(A[p..r]\)</span>的原址排序。</p><h2 id="lomuto划分">Lomuto划分</h2><p>Lomuto划分的效率不高，但它易于理解。它通常选择最后一个元素<span class="math inline">\(x=A[r]\)</span>作为<strong>主元</strong>（pivot），并围绕它来划分子数组<span class="math inline">\(A[p..r]\)</span>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lomuto_partition(A, p, r):</span><br><span class="line">    x = A[r]</span><br><span class="line">    i = p - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j = p to r - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> A[j] &lt;= x</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">            exchange A[i] <span class="keyword">with</span> A[j]</span><br><span class="line">    exchange A[i+<span class="number">1</span>] <span class="keyword">with</span> A[r]</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>        // q的最终位置</span><br></pre></td></tr></table></figure><p>随着划分过程的进行，数组被划分成4个（可能有空的）区域。分别为小于等于<span class="math inline">\(x\)</span>的部分，大于<span class="math inline">\(x\)</span>的部分，未比较部分，和主元<span class="math inline">\(x\)</span>。将这些性质作为循环不变量：</p><blockquote><p>在循环体的每一轮迭代开始时，对任意数组下标k，有：</p><ol type="1"><li>小于<span class="math inline">\(x\)</span>的部分：若<span class="math inline">\(p\le{k}\le{i}\)</span>，则<span class="math inline">\(A[k]\le{x}\)</span>。</li><li>大于<span class="math inline">\(x\)</span>的部分：若<span class="math inline">\(i+1\le{k}\le{j-1}\)</span>，则<span class="math inline">\(A[k]\ge{x}\)</span>。</li><li>等于<span class="math inline">\(x\)</span>的部分：若<span class="math inline">\(k=r\)</span>，则<span class="math inline">\(A[k]=x\)</span>。</li></ol></blockquote><p>上述坐标之外的区域<span class="math inline">\(A[j..r-1]\)</span>对应为比较部分。Lomuto划分的一个示例如下：</p><p>数组的四个部分分别是 (小于主元的元素) (大于等于主元的元素) (未划分元素) (主元)。</p><table><thead><tr class="header"><th><span class="math inline">\(array[p..r]\)</span></th><th><span class="math inline">\(A[i]\)</span></th><th><span class="math inline">\(A[j]\)</span></th></tr></thead><tbody><tr class="odd"><td>() () (2871356) (4)</td><td>null（<code>i=p-1</code>）</td><td>2</td></tr><tr class="even"><td><code>x=array[r]=4</code></td><td></td><td>2&lt;4，<code>i=i+1; exchange 2 with 2; j=j+1</code></td></tr><tr class="odd"><td>(2) () (871356) (4)</td><td>2</td><td>8</td></tr><tr class="even"><td></td><td></td><td>8&gt;=4，<code>j=j+1</code></td></tr><tr class="odd"><td>(2) (8) (71356) (4)</td><td>2</td><td>7</td></tr><tr class="even"><td></td><td></td><td>7&gt;=4，<code>j=j+1</code></td></tr><tr class="odd"><td>(2) (87) (1356) (4)</td><td>2</td><td>1</td></tr><tr class="even"><td></td><td></td><td>1&lt;4，<code>i=i+1; exchange 8 with 1; j=j+1</code></td></tr><tr class="odd"><td>(21) (78) (356) (4)</td><td>1</td><td>3</td></tr><tr class="even"><td></td><td></td><td>3&lt;4，<code>i=i+1; exchange 7 with 3; j=j+1</code></td></tr><tr class="odd"><td>(213) (87) (56) (4)</td><td>3</td><td>5</td></tr><tr class="even"><td></td><td></td><td>5&gt;=4，<code>j=j+1</code></td></tr><tr class="odd"><td>(213) (875) (6) (4)</td><td>3</td><td>6</td></tr><tr class="even"><td></td><td></td><td>6&gt;=4，<code>j=j+1</code></td></tr><tr class="odd"><td>(213) (8756) () (4)</td><td>3</td><td>4</td></tr><tr class="even"><td></td><td></td><td><code>j==r</code>，退出循环，<code>exchange 8 with 4</code></td></tr><tr class="odd"><td>213 4 7568</td><td>3</td><td><code>return i+1</code>，是主元位置</td></tr></tbody></table><h2 id="hoare划分">Hoare划分</h2><p>Hoare划分比Lomuto划分更加高效。在选择了主元之后，它使用两个下标<span class="math inline">\(i\)</span>和<span class="math inline">\(j\)</span>，<span class="math inline">\(i\)</span>从前往后、<span class="math inline">\(j\)</span>从后往前移动。当找到<span class="math inline">\(A[i]\ge{x}\)</span>、<span class="math inline">\(A[j]\le{x}\)</span>且<span class="math inline">\(i&lt;j\)</span>的两个坐标<span class="math inline">\(i\)</span>和<span class="math inline">\(j\)</span>之后，交换它们的元素。当<span class="math inline">\(i\)</span>和<span class="math inline">\(j\)</span>相遇（<span class="math inline">\(i\ge{j}\)</span>）后，划分过程停止。平均情况下，Hoare划分比Lomuto划分少3次交换次数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">hoare_partition(A, p, r):</span><br><span class="line">    x = A[r]                           <span class="comment"># 最后一个元素作为主元</span></span><br><span class="line">    i = p</span><br><span class="line">    j = r - <span class="number">1</span>                          <span class="comment"># 最后一位是主元</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">while</span> i &lt; r <span class="keyword">and</span> A[i] &lt;= x:     <span class="comment"># 找到大于主元的元素或i=r（主元的位置）时停止</span></span><br><span class="line">            i = i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= p <span class="keyword">and</span> A[j] &gt;=x:     <span class="comment"># 找到小于主元的元素或j&lt;p（超出了边界）时停止</span></span><br><span class="line">            j = j<span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; j:                      <span class="comment"># i与j相遇，i是主元应处的位置</span></span><br><span class="line">            <span class="keyword">if</span> i != r:</span><br><span class="line">                swap A[i] <span class="keyword">with</span> A[r]</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        swap A[i] <span class="keyword">with</span> A[j]</span><br></pre></td></tr></table></figure><p>Hoare划分的一个示例如下：</p><p>数组的四个部分分别是 (小于等于主元的元素) (未划分元素) (大于等于主元的元素) (主元)。</p><table><thead><tr class="header"><th></th><th><span class="math inline">\(array[p..r]\)</span></th><th><span class="math inline">\(A[i]\)</span></th><th><span class="math inline">\(A[j]\)</span></th></tr></thead><tbody><tr class="odd"><td>初始</td><td>() (2871356) () (4)</td><td>2</td><td>6</td></tr><tr class="even"><td>寻找下一对交换元素</td><td>主元x=4</td><td>8</td><td>3，交换</td></tr><tr class="odd"><td>继续寻找</td><td>(23) (71) (856) (4)</td><td>7</td><td>1，交换</td></tr><tr class="even"><td>继续寻找</td><td>(231) () (7856) (4)</td><td>7</td><td>1，相遇，交换<code>A[i]</code>与主元，<code>return i</code></td></tr><tr class="odd"><td></td><td>231 4 8567</td><td>4</td><td>7</td></tr></tbody></table><h2 id="主元的选择">主元的选择</h2><p>不论Lomuto划分还是Hoare划分，主元的选择方式都会直接影响到划分结果。例如上述Hoare划分过程的示例，若选择主元<span class="math inline">\(x=1\)</span>，正好是数组中最小的元素，划分过程很快就结束，并产生了两个长度相差较大的子数组<code>[1]</code>和<code>[2, 8, 7, 2, 3, 5, 6, 4]</code>。同理若正好选择了最大的元素，也会产生类似的结果。称这种划分为不平衡划分（Unbalanced partitioning）。</p><p>在Lomuto划分中，总是选择最右侧元素作为主元。若输入数组是已排序的，排序算法将总是产生不平衡划分，触发最坏情况。幸运的是，可以通过一些策略来优化，使得对任何输入都比较好。例如随机选择，后文将分析随机选择主元的快速排序的期望运行时间为<span class="math inline">\(O(n\log{n})\)</span>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">random(A, left, right):</span><br><span class="line">    select an integer i <span class="keyword">in</span> [left, right] randomly</span><br><span class="line">    <span class="keyword">if</span> i != right:</span><br><span class="line">        swap A[i] <span class="keyword">with</span> A[right]</span><br><span class="line">    <span class="keyword">return</span> A[right]</span><br></pre></td></tr></table></figure><p>还有一种模式：选择左中右元素的中位数（Median-of-three，mo3）。随机选择模式下，快速排序的比较次数的期望是<span class="math inline">\(1.386n\log{n}\)</span>，mo3模式下，期望可下降至<span class="math inline">\(1.188n\log{n}\)</span>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">median_of_three(A, left, right):</span><br><span class="line">    mid = (left + right) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> A[mid] &lt; A[left]:</span><br><span class="line">        swap A[left] <span class="keyword">with</span> A[mid]    <span class="comment"># A[left] &lt;= A[mid]</span></span><br><span class="line">    <span class="keyword">if</span> A[right] &lt; A[left]:</span><br><span class="line">        swap A[left] <span class="keyword">with</span> A[right]  <span class="comment"># A[left] &lt;= A[right]</span></span><br><span class="line">    <span class="keyword">if</span> A[mid] &lt; A[right]:</span><br><span class="line">        swap A[mid] <span class="keyword">with</span> A[right]   <span class="comment"># A[right] &lt;= A[mid]</span></span><br><span class="line">    pivot = A[right]</span><br></pre></td></tr></table></figure><p>通过上述代码，使得<span class="math inline">\(A[mid]\ge{A[right]}\ge{A[left]}\)</span>，此时再选择最右侧元素，实际上是左中右元素的中位数。当输入数组的排序情况未知时，相比总是直接选择左右侧元素，该方法性能更好。对于更长的数组，可以扩展mo3规则至更强的<code>ninther</code>。</p><p><code>ninther(A)=middle(mo3(first 1/3 of A), mo3(middle 1/3 of A), mo3(final 1/3 of A))</code></p><p><strong>注意</strong>：<code>mid = (left + right) / 2</code>可能会发生越界情况（没搞懂），可以用<code>mid = left + (right - left) / 2</code>来代替。</p><h1 id="分析">分析</h1><h2 id="最坏情况">最坏情况</h2><p>以Lomuto划分为例，当划分操作总是得到一个大小为0、另一个大小为n-1的数组时（还有一个元素是主元），假设<span class="math inline">\(T(n)\)</span>是<code>quicksort</code>在输入规模为<span class="math inline">\(n\)</span>的数据集合上所花费的时间，则有递归式：</p><p><span class="math display">\[T(n)=T(0)+T(n-1)+\Theta(n)\]</span></p><p>递归树深度为n，容易得到<span class="math inline">\(T(n)=O(n^2)\)</span>。</p><p>利用代入法证明：</p><p><span class="math display">\[T(n)=\max_{0\le{q}\le{n-1}}(T(q)+T(n-q-1)+\Theta(n))\]</span></p><p>q和n-q-1分别是两个子数组的规模。设<span class="math inline">\(T(n)\le{cn^2}\)</span>成立，将其带入上式 <span class="math display">\[\begin{aligned}T(n)&amp;\le{\max_{0\le{q}\le{n-1}}(cq^2+c(n-q-1)^2)+\Theta(n)}\\&amp;=c\max_{0\le{q}\le{n-1}}(q^2+(n-q-1)^2)+\Theta(n)\end{aligned}\]</span></p><p><span class="math inline">\(q^2+(n-q-1)^2\le(n-1)^2=n^2-2n+1\)</span>（在端点处取得最大值），将其带入上式，得到</p><p><span class="math display">\[T(n)\le{cn^2-c(2n-1)+\Theta(n)}\le{cn^2}\]</span></p><p><span class="math inline">\(\therefore{T(n)=O(n^2)}\)</span>。</p><h2 id="最佳情况">最佳情况</h2><p>若划分操作总是得到两个规模相等的子数组时，触发最佳情况。</p><p><span class="math display">\[T(n)=2T(\frac{n}{2})+\Theta(n)\]</span></p><p>递归树深度为<span class="math inline">\(\log_2{n}\)</span>，可得<span class="math inline">\(T(n)=O(n\log(n))\)</span>。</p><h2 id="平均情况">平均情况</h2><p>对于规模为n的无重复元素的数组，若主元的选择是独立且随机的，则快速排序的期望运行时间为<span class="math inline">\(O(n\log(n))\)</span>。</p><p>证明：</p><p>考虑输入数组的一个随机序列<span class="math inline">\((x_1,x_2,...,x_n)\)</span>，定义<span class="math inline">\(C\)</span>表示比较次数，<span class="math inline">\(c_{ij}\)</span>为指示器随机变量。有</p><p><span class="math display">\[c_{ij}=\begin{cases}1&amp;x_i与x_j发生比较\\0&amp;x_i与x_j不发生比较&amp;&amp;\end{cases}C=\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}c_{i,j}\]</span></p><p>对<span class="math inline">\(C\)</span>取期望，有</p><p><span class="math display">\[E[C]=\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}E(c_{ij})=\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}Pr(c_{ij})\]</span></p><p>在划分操作中，只有主元会与其他元素发生比较，因此</p><p><span class="math display">\[Pr(c_{ij})=Pr(x_i\text{或}x_j\text{被选为主元)}\]</span></p><p>在一次划分中，<span class="math inline">\(x_i\)</span>与<span class="math inline">\(x_j\)</span>不可能同时被选为主元，且主元的选择是独立的，因此</p><p><span class="math display">\[Pr(c_{ij})=2*Pr(x_i被选为主元)=\frac{2}{j-i+1}\]</span></p><p>令<span class="math inline">\(k=j-i\)</span>，代入<span class="math inline">\(E[C]\)</span>得</p><p><span class="math display">\[\begin{aligned}E[C]&amp;=\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}\frac{2}{j-i+1}\\&amp;=\sum_{i=1}^{n-1}\sum_{k=1}^{n-i}\frac{2}{k+1}\\&amp;&lt;\sum_{i=1}^{n-1}\sum_{k=1}^{n}\frac{2}{k}\\&amp;=\sum_{i=1}^{n-1}O(\log{n})\\&amp;=O(n\log{n})\end{aligned}\]</span></p><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(a, i, j)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> i != j:</span><br><span class="line">        a[i], a[j] = a[j], a[i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">median_of_three</span><span class="params">(a, left, right)</span>:</span></span><br><span class="line">    <span class="string">"""选择左中右三元素的中位数作为pivot"""</span></span><br><span class="line">    mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> a[mid] &lt; a[left]:</span><br><span class="line">        exchange(a, left, mid)  <span class="comment"># now: a[left] &lt;= a[mid]</span></span><br><span class="line">    <span class="keyword">if</span> a[right] &lt; a[left]:</span><br><span class="line">        exchange(a, left, right)  <span class="comment"># now: a[left] &lt;= a[right]</span></span><br><span class="line">    <span class="keyword">if</span> a[mid] &lt; a[right]:</span><br><span class="line">        exchange(a, mid, right)  <span class="comment"># now: a[right] &lt;= a[mid]</span></span><br><span class="line">    <span class="comment"># now: a[left&#125; &lt;= a[right] &lt;= a[mid]</span></span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hoare_partition</span><span class="params">(a, left, right)</span>:</span></span><br><span class="line">    <span class="string">"""Hoare's scheme is more efficient than Lomuto's partition scheme</span></span><br><span class="line"><span class="string">    because it does three times fewer swaps on average."""</span></span><br><span class="line">    pivot, i, j = a[right], left, right - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">while</span> i &lt; right <span class="keyword">and</span> a[i] &lt;= pivot:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= left <span class="keyword">and</span> a[j] &gt;= pivot:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; j:  <span class="comment"># i, j 相遇</span></span><br><span class="line">            exchange(a, i, right)</span><br><span class="line">            <span class="keyword">return</span> i  <span class="comment"># pivot位置</span></span><br><span class="line">        exchange(a, i, j)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lomuto_partition</span><span class="params">(a, left, right)</span>:</span></span><br><span class="line">    pivot, i = a[right], left</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(left, right):</span><br><span class="line">        <span class="keyword">if</span> a[j] &lt; pivot:  <span class="comment"># 小于pivot的元素被划分到左边，大于等于pivot的元素被划分到右边</span></span><br><span class="line">            exchange(a, i, j)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    exchange(a, i, right)</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">q_sort</span><span class="params">(a, left, right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; right:</span><br><span class="line">        p_idx = random.randint(left, right)  <span class="comment"># 随机选择pivot</span></span><br><span class="line">        <span class="comment"># p_idx = median_of_three(a, left, right)  # 选择左中右元素的中位数</span></span><br><span class="line">        q = partition(a, left, right, p_idx)</span><br><span class="line">        q_sort(a, left, q - <span class="number">1</span>)</span><br><span class="line">        q_sort(a, q + <span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(a, left, right, p_idx)</span>:</span>  <span class="comment"># 增加参数，p_idx指示所用主元在数组中的位置</span></span><br><span class="line">    <span class="keyword">if</span> p_idx &lt; left <span class="keyword">or</span> p_idx &gt; right:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">"主元位置越界"</span>)</span><br><span class="line">    exchange(a, p_idx, right)</span><br><span class="line">    <span class="keyword">return</span> hoare_partition(a, left, right)</span><br><span class="line">    <span class="comment"># return lomuto_partition(a, left, right)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="string">"""排序整个列表"""</span></span><br><span class="line">    q_sort(a, <span class="number">0</span>, len(a) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">16</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">11</span>, <span class="number">15</span>]</span><br><span class="line">    quick_sort(arr)</span><br><span class="line">    print(arr)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithms </tag>
            
            <tag> divide-and-conquer </tag>
            
            <tag> sort </tag>
            
            <tag> Introduction To Algorithms </tag>
            
            <tag> comparison sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/notes/introduction-to-algorithms/merge-sort/"/>
      <url>/notes/introduction-to-algorithms/merge-sort/</url>
      
        <content type="html"><![CDATA[<h1 id="归并排序">归并排序</h1><p>归并排序（Merge sort）是一种比较高效的比较型排序算法，由<a href="https://en.wikipedia.org/wiki/John_von_Neumann" target="_blank" rel="noopener">John von Neumann</a>于1945年提出。归并排序算法是运用分治策略（Divide-and-conquer）的典型算法，它有许多中不同的实现，且大多数实现是稳定排序。归并排序的示意图（出自<a href="https://en.wikipedia.org/wiki/Merge_sort#Top-down_implementation_using_lists" target="_blank" rel="noopener">维基百科：Merge sort</a>）如下：</p><p><img title="归并排序动态示意图" data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/cc/Merge-sort-example-300px.gif/220px-Merge-sort-example-300px.gif"></p><a id="more"></a><h1 id="实现">实现</h1><p>归并排序在每层递归时有三个步骤（遵循分治模式）：</p><ul><li><p>分解（Divide）：分解待排序的<span class="math inline">\(n\)</span>个元素的序列成各局<span class="math inline">\(n/2\)</span>个元素的两个子序列。</p></li><li><p>解决（Conquer）：使用归并排序递归地排序两个子序列。</p></li><li><p>合并（Combine）：合并两个已排序的子序列以产生已排序的答案。</p></li></ul><h2 id="合并">合并</h2><p>合并过程是归并排序的关键操作。通过调用一个辅助过程<code>merge(A, p, q, r)</code>来完成，其中<code>A</code>是一个数组，<code>p</code>、<code>q</code>和<code>r</code>是数组下标，满足<span class="math inline">\(p\le{q}&lt;r\)</span>。假设子数组<span class="math inline">\(A[p..q]\)</span>和<span class="math inline">\(A[q+1..r]\)</span>都已经排好序。该过程合并这两个子数组形成单一的已排好序的数组来代替当前的数组<span class="math inline">\(A[p..r]\)</span>。</p><p>合并时需要注意要时刻判断两个子数组是否为空，当某个子数组为空时，则无需比较，只需要将另一个子数组中的元素取出即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">merge(A, p, q, r):</span><br><span class="line">    创建新数组B[<span class="number">0.</span>.r-p]</span><br><span class="line">    将A[p..r]复制到B[<span class="number">0.</span>.r-p]</span><br><span class="line">    i = p</span><br><span class="line">    j = q</span><br><span class="line">    <span class="keyword">for</span> k = p to r:</span><br><span class="line">        <span class="keyword">if</span> i &lt; q <span class="keyword">and</span> (j &gt;= r <span class="keyword">or</span> B[i] &lt;= B[j]):  <span class="comment"># 用 i &lt; q 和 j &gt;=r 时刻判断非空</span></span><br><span class="line">            A[k] = B[i]</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            A[k] = B[j]</span><br><span class="line">            j = j + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>为了避免每次检查非空以简化代码，可以通过在子数组末尾放置一个哨兵（sentinel）元素。使用<span class="math inline">\(\infty\)</span>作为哨兵元素的值。当有效数组元素为空时，哨兵元素显露出来，它不可能小于其他非哨兵元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">merge(A, p, q, r):</span><br><span class="line">    <span class="comment"># --------准备工作-------------</span></span><br><span class="line">    创建两个新数组L[<span class="number">0.</span>.p-q+<span class="number">1</span>]和R[<span class="number">0.</span>.r-q]</span><br><span class="line">    将A[p..q]复制到L[<span class="number">0.</span>.p-q]</span><br><span class="line">    将B[q+<span class="number">1.</span>.r]复制到R[<span class="number">0.</span>.r-q<span class="number">-1</span>]</span><br><span class="line">    L[p-q+<span class="number">1</span>] = inf</span><br><span class="line">    R[r-q] = inf</span><br><span class="line">    <span class="comment"># -----------end--------------------</span></span><br><span class="line">    <span class="comment"># ---------比较------------</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k = p to r:</span><br><span class="line">        <span class="keyword">if</span> L[i] &lt; R[j]:</span><br><span class="line">            A[k] = L[i]</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            A[k] = R[j]</span><br><span class="line">            j = j + <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="自顶向下的实现">自顶向下的实现</h2><p>自顶向下的归并排序递归地将序列分解成子序列，直到子序列只有1个元素。当待排序的序列长度为1时，递归“开始回升”，此时无需合并，因为长度为1的每个序列是已排序的。之后合并这些子序列生成已排序的序列。上述示意图描述的就是自顶向下的归并排序算法的排序过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">merge_sort_top_down(A, p, r):</span><br><span class="line">    <span class="keyword">if</span> p &lt; r:    <span class="comment"># 当元素个数大于1时</span></span><br><span class="line">        q = (p + q) / <span class="number">2</span></span><br><span class="line">        merge_sort_top_down(A, p, q)</span><br><span class="line">        merge_sort_top_down(A, q + <span class="number">1</span>, r)</span><br><span class="line">        merge(A, p, q, r)</span><br></pre></td></tr></table></figure><h2 id="自底向上的实现">自底向上的实现</h2><p>自底向上的归并排序将原数组视为n个长度为1的子数组，然后依次合并两个相邻子数组，得到长度为2，4，6.…的已排序数组，直到整个数组。自底向上的归并排序的排序过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input:  6  5  3  1  8  7  2  4</span><br><span class="line">1st:    56  31  78  24</span><br><span class="line">2nd:    1356  2478</span><br><span class="line">3rd:    12345678</span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">merge_sort_bottom_up(A):</span><br><span class="line">    n = A.length</span><br><span class="line">    <span class="keyword">for</span> (width = <span class="number">1</span>; width &lt; n; width = <span class="number">2</span> * width):</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i = i + <span class="number">2</span> * width):</span><br><span class="line">            merge(A, i, min(i + width, n) - <span class="number">1</span>, min(i + <span class="number">2</span> * width, n) - <span class="number">1</span>)  <span class="comment"># 合并相邻数组</span></span><br></pre></td></tr></table></figure><h1 id="自然归并排序">自然归并排序</h1><p>自然归并排序（Natural merge sort）类似于自底向上的归并排序。自底向上的归并排序的出发点是1（将长度为n的数组视为n个长度为1的子数组，这n个子数组是已排序的）。而输入数组可能包含已排序的子数组，这些子数组可通过一遍遍历找出。自然归并排序将依次合并这些子数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Start:          3421758906</span><br><span class="line">Select runs:    34  2  17  589  06</span><br><span class="line">Merge:          234  15789  06</span><br><span class="line">Merge:          12345789  06</span><br><span class="line">Merge:          0123456789</span><br></pre></td></tr></table></figure><h1 id="分析">分析</h1><p>合并过程只需要一次遍历即可完成，运行时间是<span class="math inline">\(\Theta(n)\)</span>，<span class="math inline">\(n\)</span>是合并后数组的长度。归并排序的<strong>平均</strong>和<strong>最坏</strong>情况下的时间复杂度是<span class="math inline">\(O(n\lg{n})\)</span>。</p><p>设<span class="math inline">\(T(n)\)</span>为归并排序对长度为<span class="math inline">\(n\)</span>的数组进行排序的运行时间，则归并排序的时间复杂度可以描述为<span class="math inline">\(T(n)=2T(n/2)+\Theta(n)\)</span>。可解得<span class="math inline">\(T(n)=O(n\lg{n})\)</span>。</p><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort_top_down</span><span class="params">(array, p, r)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> p &lt; r:</span><br><span class="line">        q = (p + r) // <span class="number">2</span></span><br><span class="line">        merge_sort_top_down(array, p, q)  <span class="comment"># 递归调用</span></span><br><span class="line">        merge_sort_top_down(array, q + <span class="number">1</span>, r)  <span class="comment"># 递归调用</span></span><br><span class="line">        merge(array, p, q, r)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort_bottom_up</span><span class="params">(array)</span>:</span></span><br><span class="line">    width, n = <span class="number">1</span>, len(array)</span><br><span class="line">    <span class="keyword">while</span> width &lt; n:</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            merge(array, i, min(i + width, n) - <span class="number">1</span>, min(i + (width &lt;&lt; <span class="number">1</span>), n) - <span class="number">1</span>)</span><br><span class="line">            i += (width &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        width = width &lt;&lt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(array, p, q, r)</span>:</span></span><br><span class="line">    <span class="string">"""合并array[p..q]与array[q+1..r]"""</span></span><br><span class="line">    left, right = array[p:q + <span class="number">1</span>], array[q + <span class="number">1</span>:r + <span class="number">1</span>]</span><br><span class="line">    left.append(float(<span class="string">"inf"</span>))</span><br><span class="line">    right.append(float(<span class="string">"inf"</span>))</span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(p, r + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">            array[k] = left[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            array[k] = right[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line">    merge_sort_top_down(arr, <span class="number">0</span>, len(arr) - <span class="number">1</span>)</span><br><span class="line">    print(arr)</span><br><span class="line">    arr = [<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line">    merge_sort_bottom_up(arr)</span><br><span class="line">    print(arr)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 7, 8, 9, 10, 14, 16]</span><br><span class="line">[1, 2, 3, 4, 7, 8, 9, 10, 14, 16]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithms </tag>
            
            <tag> divide-and-conquer </tag>
            
            <tag> sort </tag>
            
            <tag> Introduction To Algorithms </tag>
            
            <tag> comparison sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python列表解析/推导</title>
      <link href="/programming/python-list-comprehensions/"/>
      <url>/programming/python-list-comprehensions/</url>
      
        <content type="html"><![CDATA[<h1 id="列表解析">列表解析</h1><p>列表解析（List comprehensions）提供了一种更简洁的方式来创建集合。例如创建一个平方和的列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>    squares.append(x**<span class="number">2</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><p>可以看到在循环结束后，<code>x</code>仍然存在。利用列表解析创建，可以摆脱这种“副作用”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = list(map(<span class="keyword">lambda</span> y: y**<span class="number">2</span>, range(<span class="number">10</span>)))</span><br></pre></td></tr></table></figure><p>等价于，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = [z**<span class="number">2</span> <span class="keyword">for</span> z <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br></pre></td></tr></table></figure><p>最后一种方法更加简洁，可读性也更好。</p><a id="more"></a><h1 id="扩展">扩展</h1><p>一个列表解析语句至少要有一对内含<code>for</code>语句的括号（例如<code>[x for x in range(9)]</code>），<code>for</code>语句后面可以跟其他<code>for</code>或<code>if</code>语句。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] <span class="keyword">if</span> x != y]</span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">1</span>, <span class="number">5</span>), (<span class="number">1</span>, <span class="number">6</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">2</span>, <span class="number">6</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure><p>将<code>for</code>和<code>if</code>语句按序拆开，上述语句等价于</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>combs = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">if</span> x != y:</span><br><span class="line"><span class="meta">... </span>                    combs.append((x, y))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>combs</span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">1</span>, <span class="number">5</span>), (<span class="number">1</span>, <span class="number">6</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">2</span>, <span class="number">6</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure><p>要注意，当表达式是元组（tuple）时，必须要包含在括号内。如上例中的<code>(x, y)</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x, x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    [x, x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line">               ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><h1 id="嵌套">嵌套</h1><p>列表解析自身可以嵌套使用，用来创建一个多维列表。下面是求转置矩阵的例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">    [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">    [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],</span><br><span class="line">    [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>],</span><br><span class="line">]</span><br><span class="line">// 以下<span class="number">3</span>中方法等价，只是写法不同</span><br><span class="line">// 方法<span class="number">1</span>：两个comprehensions嵌套</span><br><span class="line">transposed = [[row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br><span class="line">// 方法<span class="number">2</span>：一个comprehension</span><br><span class="line">transposed = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    transposed.append([row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix])</span><br><span class="line">// 方法<span class="number">3</span>：原生</span><br><span class="line">transposed = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    transposed_row = []</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> matrix:</span><br><span class="line">        transposed_row.append(row[i])</span><br><span class="line">    transposed.append(transposed_row)</span><br><span class="line"></span><br><span class="line">// 结果</span><br><span class="line">[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>], [<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>]]</span><br></pre></td></tr></table></figure><p>实际使用时，更倾向于内建方法。如<code>zip()</code>方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(*matrix))</span><br><span class="line">[(<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>), (<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>), (<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>), (<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>)]</span><br></pre></td></tr></table></figure><h1 id="创建集合和字典">创建集合和字典</h1><p>类似的操作同样适用于创建集合和字典。可以称之为集合解析（Set comprehensions）和字典解析（Dictionary comprehensions）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;s <span class="keyword">for</span> s <span class="keyword">in</span> <span class="string">'hello world'</span>&#125;</span><br><span class="line">&#123;<span class="string">'w'</span>, <span class="string">'o'</span>, <span class="string">'r'</span>, <span class="string">'h'</span>, <span class="string">'l'</span>, <span class="string">' '</span>, <span class="string">'d'</span>, <span class="string">'e'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;k:v <span class="keyword">for</span> k, v <span class="keyword">in</span> enumerate([<span class="string">'zero'</span>, <span class="string">'first'</span>, <span class="string">'second'</span>])&#125;</span><br><span class="line">&#123;<span class="number">0</span>: <span class="string">'zero'</span>, <span class="number">1</span>: <span class="string">'first'</span>, <span class="number">2</span>: <span class="string">'second'</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python循环技巧</title>
      <link href="/programming/python-looping-techniques/"/>
      <url>/programming/python-looping-techniques/</url>
      
        <content type="html"><![CDATA[<h1 id="同时遍历key和value">同时遍历key和value</h1><p>使用<code>items()</code>方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic = &#123;<span class="string">'name'</span>: <span class="string">'chen'</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> dic.items():</span><br><span class="line"><span class="meta">... </span>    print(k, v)</span><br><span class="line">...</span><br><span class="line">name chen  </span><br><span class="line">gender male</span><br></pre></td></tr></table></figure><h1 id="同时遍历index和value">同时遍历index和value</h1><p>使用<code>enumerate()</code>方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate([<span class="string">'zero'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]):</span><br><span class="line"><span class="meta">... </span>    print(i, v)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> zero</span><br><span class="line"><span class="number">1</span> one</span><br><span class="line"><span class="number">2</span> two</span><br><span class="line"><span class="number">3</span> three</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="同时遍历多个数组">同时遍历多个数组</h1><p>使用<code>zip()</code>方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>eng = [<span class="string">'zero'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n, e <span class="keyword">in</span> zip(nums, eng):</span><br><span class="line"><span class="meta">... </span>    print(n, e)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> zero</span><br><span class="line"><span class="number">1</span> one</span><br><span class="line"><span class="number">2</span> two</span><br></pre></td></tr></table></figure><h1 id="反序遍历">反序遍历</h1><p>使用<code>reversed()</code>方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(<span class="number">2</span>, <span class="number">11</span>, <span class="number">2</span>)):</span><br><span class="line"><span class="meta">... </span>    print(i, end=<span class="string">' '</span>)</span><br><span class="line">...</span><br><span class="line"><span class="number">10</span> <span class="number">8</span> <span class="number">6</span> <span class="number">4</span> <span class="number">2</span> &gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h1 id="排序和去重">排序和去重</h1><p>使用<code>sorted()</code>和<code>set()</code>方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>basket = [<span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'apple'</span>, <span class="string">'banana'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> f <span class="keyword">in</span> sorted(set(basket)):</span><br><span class="line"><span class="meta">... </span>    print(f)</span><br><span class="line">...</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br></pre></td></tr></table></figure><h1 id="循环里面的else">循环里面的else</h1><p>退出循环时执行<code>else</code>块中代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">if</span> n % x == <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>                    print(n, <span class="string">'equals'</span>, x, <span class="string">'*'</span>, n//x)</span><br><span class="line"><span class="meta">... </span>                    <span class="keyword">break</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>            print(n, <span class="string">'is a prime number'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="number">2</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">3</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">4</span> equals <span class="number">2</span> * <span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">6</span> equals <span class="number">2</span> * <span class="number">3</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">8</span> equals <span class="number">2</span> * <span class="number">4</span></span><br><span class="line"><span class="number">9</span> equals <span class="number">3</span> * <span class="number">3</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桶排序</title>
      <link href="/notes/introduction-to-algorithms/bucket-sort/"/>
      <url>/notes/introduction-to-algorithms/bucket-sort/</url>
      
        <content type="html"><![CDATA[<h1 id="桶排序">桶排序</h1><p>桶排序（Bucket sort）或箱排序，工作原理是将数组分到有限数量的桶里。每个桶再个别排序。</p><p>计数排序假设输入数据都属于一个小区间内的整数，桶排序也对输入作了某种假设。桶排序假设输入服从均匀分布，平均情况下时间代价为<span class="math inline">\(O(n)\)</span>。</p><a id="more"></a><h1 id="实现">实现</h1><p>桶排序将<span class="math inline">\([0,1)\)</span>区间划分为<span class="math inline">\(k\)</span>个大小相同的子区间，或称为桶。然后，将<span class="math inline">\(n\)</span>个输入数分别放到各个桶中。对每个桶中的数进行排序，然后遍历每个桶，按照次序把各个桶中的元素列出来即可。因为输入是均匀、独立地分布在<span class="math inline">\([0,1)\)</span>区间上，所以一般不会出现很多数落在同一个桶中的情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bucket_sort(A):</span><br><span class="line">    n = A.length</span><br><span class="line">    B = new array[k]</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to k - <span class="number">1</span>:</span><br><span class="line">        make B[i] an empty list        <span class="comment"># make k buckets</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to n - <span class="number">1</span>:</span><br><span class="line">        insert A[i] into list B[floor(k * A[i])]</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to k - <span class="number">1</span>:</span><br><span class="line">        sort list B[i] <span class="keyword">with</span> insertion sort</span><br><span class="line">    concatenate the lists B[<span class="number">0</span>], B[<span class="number">1</span>],...,B[k<span class="number">-1</span>] together <span class="keyword">in</span> order</span><br></pre></td></tr></table></figure><p>例如<span class="math inline">\(k=10\)</span>时，排序一组数的过程如下：</p><table><thead><tr class="header"><th>输入</th><th>所属桶<span class="math inline">\(floor(k * A[i])\)</span></th><th>桶序号</th><th>桶中元素</th><th>排序后桶中元素</th></tr></thead><tbody><tr class="odd"><td>0.78</td><td>7（<span class="math inline">\(floor(10 * 0.78)=7\)</span>）</td><td>0</td><td></td><td></td></tr><tr class="even"><td>0.17</td><td>1</td><td>1</td><td>0.17、0.12</td><td>0.12、0.17</td></tr><tr class="odd"><td>0.39</td><td>3</td><td>2</td><td>0.26、0.21、0.23</td><td>0.21、0.23、0.26</td></tr><tr class="even"><td>0.26</td><td>2</td><td>3</td><td>0.39</td><td>0.39</td></tr><tr class="odd"><td>0.72</td><td>7</td><td>4</td><td></td><td></td></tr><tr class="even"><td>0.94</td><td>9</td><td>5</td><td></td><td></td></tr><tr class="odd"><td>0.21</td><td>2</td><td>6</td><td>0.68</td><td>0.68</td></tr><tr class="even"><td>0.12</td><td>1</td><td>7</td><td>0.78、0.72</td><td>0.72、0.78</td></tr><tr class="odd"><td>0.23</td><td>2</td><td>8</td><td></td><td></td></tr><tr class="even"><td>0.68</td><td>6</td><td>9</td><td>0.94</td><td>0.94</td></tr></tbody></table><p>遍历桶中元素即可得到排序结果。</p><h1 id="分析">分析</h1><p>除去调用插入排序的代码，其他代码可以在<span class="math inline">\(\Theta(1)\)</span>时间内完成。已知插入排序的时间复杂度为<span class="math inline">\(O(n^2)\)</span>，<span class="math inline">\(n\)</span>为元素个数。桶排序对每个桶都调用了插入排序，桶中有多少元素直接影响到时间代价。设桶<span class="math inline">\(i\)</span>中的元素个数为<span class="math inline">\(n_i\)</span>，则桶排序的时间代价可以描述为：</p><p><span class="math display">\[T(n)=\Theta(n)+\sum_{i=0}^{k-1}{O(n_i^2)}\]</span></p><p>虽然无法准确直到每个桶中元素个数，从而无法计算上述时间代价。但可以计算其期望。通过对上式求期望：</p><p><span class="math display">\[\begin{aligned}E[T(n)]&amp;=E[\Theta(n)+\sum_{i=0}^{k-1}{O(n_i^2)}]\\&amp;=\Theta(n)+\sum_{i=0}^{k-1}{E[O(n_i^2)]}\\&amp;=\Theta(n)+\sum_{i=0}^{k-1}{O(E[n_i^2])}\end{aligned}\]</span></p><p>桶排序假设输入服从均匀分布，因此可以认为元素落到每个桶的概率是相同的，为<span class="math inline">\(1/k\)</span>。<span class="math inline">\(n\)</span>个元素分到<span class="math inline">\(k\)</span>个桶（设为随机变量<span class="math inline">\(X\)</span>），<span class="math inline">\(X\)</span>服从参数为<span class="math inline">\(n\)</span>和<span class="math inline">\(1/k\)</span>的二项分布，即<span class="math inline">\(X\sim{b(n,1/k)}\)</span>。通过二项分布的期望和方差可以快速计算出<span class="math inline">\(E(n_i^2)\)</span>。</p><p><span class="math display">\[\begin{aligned}E(n_i^2)&amp;=E(X^2)\\&amp;=V(X)+(E(X))^2\\&amp;=n\frac{1}{k}(1-\frac{1}{k})+(n\frac{1}{k})^2\\&amp;=\frac{n^2+nk-n}{k^2}\end{aligned}\]</span></p><p>由此可以得出桶排序的期望时间代价为</p><p><span class="math display">\[\begin{aligned}E[T(n)]&amp;=\Theta(n)+\sum_{i=0}^{k-1}{O(E[n_i^2])}\\&amp;=\Theta(n)+kO(\frac{n^2+nk-n}{k^2})\\&amp;=\Theta(n)+O(\frac{n^2}{k}+n)\end{aligned}\]</span></p><p>如果桶的个数<span class="math inline">\(k=\Theta(n)\)</span>，则上式等于<span class="math inline">\(O(n)\)</span>，桶排序可以在线性时间内结束。如果<span class="math inline">\(k=n\)</span>，则桶排序近似等价于计数排序。</p><p>总结：虽然插入排序的时间复杂度是<span class="math inline">\(O(n^2)\)</span>，但在<span class="math inline">\(n\)</span>比较小的时候同其他比较排序的差距并不明显。桶排序就是将原数组分到不同的桶中，使得各个桶中的元素个数比较小且桶之间满足次序关系，再对桶中元素使用插入排序。</p><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> insertion_sort <span class="keyword">import</span> insertion_sort</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucket_sort</span><span class="params">(a)</span>:</span></span><br><span class="line">    b = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a))]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">        b[math.floor(len(a) * a[i])].append(a[i])</span><br><span class="line">    a.clear()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(b)):</span><br><span class="line">        insertion_sort(b[i])</span><br><span class="line">        a.extend(b[i])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithms </tag>
            
            <tag> sort </tag>
            
            <tag> Introduction To Algorithms </tag>
            
            <tag> non-comparison sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计数排序和基数排序</title>
      <link href="/notes/introduction-to-algorithms/counting-sort-and-radix-sort/"/>
      <url>/notes/introduction-to-algorithms/counting-sort-and-radix-sort/</url>
      
        <content type="html"><![CDATA[<h1 id="计数排序">计数排序</h1><p>计数排序于1954年由 Harold H. Seward 提出，是一种线性时间排序算法。它是稳定排序算法，这个性质很重要，是它可以作为基数排序子过程的前提。但不是原址排序算法，即需要额外的随输入规模增大的辅助空间。计数排序不是比较排序，摆脱了比较排序的下界<span class="math inline">\(\Omega(n\lg{n})\)</span>，可以在线性时间内完成排序。</p><p>计数排序先“数”出不同元素值的个数，之后通过算数运算求出不同元素值排序后的位置。它的运行时间是<span class="math inline">\(O(max-min)\)</span> 。计数排序比较适用于，输入数组中最大值和最小值的差不特别大于元素个数的情况。但计数排序可以用作别的排序的子过程，例如<a href="/algorithm/Radix-sort">基数排序</a>，基数排序可以很好的处理上述情况。</p><a id="more"></a><h2 id="实现">实现</h2><p>计数排序假设，输入数组是一组从<span class="math inline">\(0\)</span>开始，最大值不超过<span class="math inline">\(k\)</span>（即小于等于<span class="math inline">\(k\)</span>）的整型数组。在某些情况下，<span class="math inline">\(k\)</span>可能已知，比如十进制数的基数排序中<span class="math inline">\(k=9\)</span>。在未知的时候，需要通过遍历数组，得出<span class="math inline">\(k\)</span>的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">counting_sort(A, B, k):   <span class="comment"># A：输入；B：输出 ；k：A中的最大值</span></span><br><span class="line">    C = new array[k+<span class="number">1</span>]    <span class="comment"># C：辅助数组</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to A.length - <span class="number">1</span>:</span><br><span class="line">        C[A[i]] = C[A[i]] + <span class="number">1</span></span><br><span class="line">    <span class="comment"># C[i] now means that A has C[i] elements equal to i</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to k:</span><br><span class="line">        C[i] = C[i] + C[i + <span class="number">1</span>]</span><br><span class="line">    <span class="comment"># C[i] now means that A has C[i] elements equal to or less than i</span></span><br><span class="line">    <span class="keyword">for</span> j = A.length - <span class="number">1</span> to <span class="number">0</span>:</span><br><span class="line">        B[C[A[i]] - <span class="number">1</span>] = A[i]</span><br><span class="line">        C[A[i]] = C[A[i]] - <span class="number">1</span></span><br></pre></td></tr></table></figure><p>通过一个简单的例子来理解这段伪代码。</p><table><thead><tr class="header"><th>序号</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr class="odd"><td>数组A</td><td>2</td><td>5</td><td>3</td><td>0</td><td>2</td><td>3</td><td>0</td><td>3</td></tr><tr class="even"><td>第一个循环后C的值</td><td>2</td><td>0</td><td>2</td><td>3</td><td>0</td><td>1</td><td></td><td></td></tr><tr class="odd"><td>第二个循环后C的值</td><td>2</td><td>2</td><td>4</td><td>7</td><td>7</td><td>8</td><td></td><td></td></tr><tr class="even"><td>j=7，<code>C[A[7]]=C[3]=7</code>，有7个数小于3，则<code>B[6]=A[7]</code></td><td></td><td></td><td></td><td></td><td></td><td></td><td>3</td><td></td></tr><tr class="odd"><td><code>C[3]-=1</code></td><td>2</td><td>2</td><td>4</td><td>6</td><td>7</td><td>8</td><td></td><td></td></tr><tr class="even"><td>j=6，……</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>Q: 为什么不在第一个循环之后借助数组<code>C</code>直接输出排序后的数组？ A: 保证计数排序算法的稳定性（如果不要求排序结果的稳定性可以这样做）。在下面的基数排序算法中，计数排序通常作为子排序过程出现，而且为了保证基数排序是正确的，子排序过程必须是稳定的。</p><h2 id="分析">分析</h2><p>计数排序的代码只有三个循环，第一个和第三个循环执行<span class="math inline">\(n\)</span>次，第二个循环执行<span class="math inline">\(k\)</span>次，每个循环的单次运行时间都是<span class="math inline">\(\Theta(1)\)</span>。所以总运行时间是<span class="math inline">\(T(n)=2\Theta(n)+\Theta(k)=\Theta(k+n)\)</span>。当<span class="math inline">\(k=\Theta(n)\)</span>的时候，即数组中的最大值随数组大小线性变化时，<span class="math inline">\(T(n)=\Theta(n)\)</span>，计数排序可以在线性时间内完成排序。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counting_sort</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    c = [<span class="number">0</span>] * (max(a) + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">        c[a[i]] += <span class="number">1</span>  <span class="comment"># C[i] now contains the number of elements equal to i.</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(c)):</span><br><span class="line">        c[i] += c[i - <span class="number">1</span>]  <span class="comment"># C[i] now contains the number of elements less than or equal to i.</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        b[c[a[i]] - <span class="number">1</span>] = a[i]</span><br><span class="line">        c[a[i]] -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="基数排序">基数排序</h1><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字（位数不足的数字高位补零），然后按每个位数分别比较。基数排序最初是应用在卡片排序机上的算法，可以被“机械编程”。</p><h2 id="实现-1">实现</h2><p>基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital）。LSD即从最低位开始比较，MSD相反，从最高位开始比较。</p><ul><li><p>MSD的排序过程：按最高有效位进行排序，按最高位分别放入“容器0-9”，然后按下一个最高位递归的对每个容器中的数进行排序。</p><p>使用MSD排序一组数的例子如下，表中省略了没有数的容器：</p></li></ul><table><colgroup><col style="width: 18%"><col style="width: 20%"><col style="width: 20%"><col style="width: 20%"><col style="width: 18%"></colgroup><thead><tr class="header"><th>输入数组</th><th>按最高位排序后</th><th>递归排序容器0和1</th><th>递归排序容器0</th><th>按序收集</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\begin{aligned}004\\178\\045\\009\\135\end{aligned}\)</span></td><td><span class="math inline">\(\begin{aligned}&amp;容器0\begin{cases}004\\045\\009\end{cases}\\&amp;容器1\begin{cases}178\\135\end{cases}\end{aligned}\)</span></td><td><span class="math inline">\(\begin{aligned}&amp;容器0\begin{cases}容器0\begin{cases}004\\009\end{cases}\\容器4：045\\\end{cases}\\&amp;容器1\begin{cases}容器3：135\\容器7：178\end{cases}\end{aligned}\)</span></td><td><span class="math inline">\(\begin{aligned}&amp;容器0\begin{cases}容器0\begin{cases}容器4：004\\容器9：009\end{cases}\\容器4：045\end{cases}\\&amp;容器1\begin{cases}容器3：135\\容器7：178\end{cases}\end{aligned}\)</span></td><td><span class="math inline">\(\begin{aligned}004\\009\\045\\135\\178\end{aligned}\)</span></td></tr></tbody></table><ul><li><p>LSD的排序过程：按最低有效位进行排序，将排序结果放入同一个”容器“，然后按下一个最低位重复排序，再收集，直至最高位排序完成。</p><p>同样的输入，使用LSD排序的例子如下（注意稳定性）：</p></li></ul><table><colgroup><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"></colgroup><thead><tr class="header"><th>输入数组</th><th>按最低位排序后</th><th>第二低位</th><th>第三低位</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\begin{aligned}004\\178\\045\\009\\135\end{aligned}\)</span></td><td><span class="math inline">\(\begin{aligned}004\\045\\135\\178\\009\end{aligned}\)</span></td><td><span class="math inline">\(\begin{aligned}004\\009\\135\\045\\178\end{aligned}\)</span></td><td><span class="math inline">\(\begin{aligned}004\\009\\045\\135\\178\end{aligned}\)</span></td></tr></tbody></table><hr><p>在MSD排序中，例如第二列中，为了排序容器0中的数，容器1-9中的数必须先放一边保存起来，每次递归都需要额外准备10个“容器”用来保存排序结果。如果递归深度比较大，MSD会占用非常多的空间。</p><p>相比之下，LSD只需要10个“容器”，在下一次循环开始前，“容器”中的数被收集起来，“容器”可以重复使用。</p><p>因此基数排序采用LSD进行排序，也因此要求子过程必须是稳定的。即高位的比较结果不能破坏低位的比较结果。</p><p>例如004和009：</p><p>在最低位上通过排序确定了004在009之前（4&lt;9）。</p><p>下一个最低有效位都是0，004和009之间的次序应该由较低位（即上一次排序结果）决定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">radix_sort(A, d):</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to d:  <span class="comment"># d 是有效位数</span></span><br><span class="line">        use a stable sort to sort array A on i</span><br></pre></td></tr></table></figure><p>对于十进制数字来说，每一位只会出现10种数字（0-9），因此计数排序是一个好的选择。</p><h2 id="分析-1">分析</h2><p>基数排序的时间代价依赖于所使用的稳定的排序算法。如果子过程是计数排序的话，则基数排序的时间复杂度可以描述为<span class="math inline">\(d\Theta(n+k)=\Theta(d(n+k))\)</span>。当<span class="math inline">\(d\)</span>为常数（位数固定）且<span class="math inline">\(k=O(n)\)</span>（每位数字都在0到<span class="math inline">\(k-1\)</span>区间内）时，基数排序具有线性时间代价。</p><h2 id="代码-1">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="string">"""十进制数的基数排序算法"""</span></span><br><span class="line">    c, b = [], [<span class="literal">None</span>] * len(a)  <span class="comment"># b is an auxiliary list, c share the same meaning with list c in counting sort</span></span><br><span class="line">    digit, _max = <span class="number">1</span>, max(a)</span><br><span class="line">    <span class="keyword">while</span> _max // digit &gt; <span class="number">0</span>:</span><br><span class="line">        c = [<span class="number">0</span>] * <span class="number">10</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">            c[(a[i] // digit) % <span class="number">10</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(c)):</span><br><span class="line">            c[i] += c[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(len(a))):</span><br><span class="line">            target = (a[i] // digit) % <span class="number">10</span></span><br><span class="line">            b[c[target] - <span class="number">1</span>] = a[i]</span><br><span class="line">            c[target] -= <span class="number">1</span></span><br><span class="line">        a[:] = b[:]</span><br><span class="line">        digit *= <span class="number">10</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithms </tag>
            
            <tag> sort </tag>
            
            <tag> Introduction To Algorithms </tag>
            
            <tag> non-comparison sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插入排序、选择排序和冒泡排序</title>
      <link href="/notes/introduction-to-algorithms/insertion-sort-selection-sort-and-bubble-sort/"/>
      <url>/notes/introduction-to-algorithms/insertion-sort-selection-sort-and-bubble-sort/</url>
      
        <content type="html"><![CDATA[<h1 id="插入排序">插入排序</h1><p>对于少量元素的排序，插入排序（Insertion sort）是一个有效的算法。插入排序的工作方式像许多人排序一手扑克牌。开始时左手为空，每次从桌子上拿走一张牌并将它插入左手中正确的位置。插入排序将输入数组分成未排序部分和已排序部分两个子数组，初始时已排序部分为空（或者有一个，因为一个数的数组是已排序的），每次迭代从未排序数组中选择一个元素，将其放入已排序数组中的合适位置。</p><p>插入排序示意图（出自<a href="https://en.wikipedia.org/wiki/Insertion_sort" target="_blank" rel="noopener">维基百科：Insertion sort</a>）：</p><p><img title="插入排序动态示意图" data-src="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif"></p><a id="more"></a><h2 id="实现">实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">insertion_sort(A):</span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">1</span> to A.length - <span class="number">1</span>:</span><br><span class="line">        key = A[j]</span><br><span class="line">        <span class="comment"># Insert A[j] into the sorted sequence A[1...j-1]</span></span><br><span class="line">        i = j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> A[i] &gt; key:</span><br><span class="line">            A[i + <span class="number">1</span>] = A[i]</span><br><span class="line">            i = i - <span class="number">1</span></span><br><span class="line">        A[i + <span class="number">1</span>] = key</span><br></pre></td></tr></table></figure><p>循环不变式（<a href="https://en.wikipedia.org/wiki/Loop_variant" title="Loop variant" target="_blank" rel="noopener">Loop variant</a>）用来帮助理解算法的正确性。关于循环不变式，必须证明三条性质。</p><ul><li>初始化：循环的第一次迭代前，它为真。</li><li>保持：如果循环的某次迭代前它为真，那么下次迭代前它仍为真。</li><li>终止：在循环终止时，不变式提供一个有用的性质，该性质有助于证明算法是正确的。</li></ul><p>（类似于数学归纳法）</p><p>用下面的循环不变式证明插入排序算法的正确性。</p><blockquote><p>在<code>for</code>循环的每次迭代开始前，子数组 <span class="math inline">\(A[0\ldots{j-1}]\)</span>由原来在 <span class="math inline">\(A[0\ldots{j-1}]\)</span>中的元素组成，但已按序排列。</p></blockquote><ul><li>初始化：循环的第一次迭代前，<span class="math inline">\(j=1\)</span>，子数组只包含 <span class="math inline">\(A[0]\)</span>，它为真。</li><li>保持：<code>for</code>循环里面嵌套了一个<code>while</code>循环，同样可以用另一个循环不变式证明它。但对于简单的循环，同样可以通过非形式化的分析证明其正确性。非形式化地，<code>while</code>循环将 <span class="math inline">\(A[j-1], A[j-2]\)</span>等向右移动一个位置，直到找到<span class="math inline">\(A[j]\)</span>的适当位置。最后将<span class="math inline">\(A[j]\)</span>插入该位置。此时，子数组<span class="math inline">\(A[0\ldots{j}]\)</span>由原来在 <span class="math inline">\(A[0\ldots{j}]\)</span>中的元素组成，但已按序排列。那么下一次迭代增加 <span class="math inline">\(j\)</span>，上述循环不变式为真。</li><li>终止：循环终止时<code>j=A.length</code>，则根据循环不变式子数组<span class="math inline">\(A[0\ldots{A.length-1}]\)</span>由原来在 <span class="math inline">\(A[0\ldots{A.length-1}]\)</span>中的元素组成，但已按序排列。此时<span class="math inline">\(A[0\ldots{A.length-1}]\)</span>就是整个数组。因此该算法正确。</li></ul><h2 id="分析">分析</h2><p>在<code>for</code>循环内部，除去<code>while</code>循环的语句执行时间均为<span class="math inline">\(\Theta(1)\)</span>（即常数时间内），<code>for</code>循环执行<span class="math inline">\(n-1\)</span>次。<code>while</code>循环的运行时间与数组的已排序程度有关系。若输入数组已按递增序排好，则导致最佳情况。若输入数组已反向排序，即按递减序排好，则导致最坏情况。在<code>while</code>循环处，必须将每个元素 <span class="math inline">\(A[j]\)</span>与整个已排序子数组<span class="math inline">\(A[0\ldots{j-1}]\)</span>中每个元素进行比较。</p><table><thead><tr class="header"><th><span class="math inline">\(j\)</span></th><th>最佳时比较元素</th><th>比较次数</th><th>最坏时比较元素</th><th>比较次数</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(1\)</span></td><td><span class="math inline">\(A[0]\)</span></td><td><span class="math inline">\(1\)</span></td><td><span class="math inline">\(A[0]\)</span></td><td><span class="math inline">\(1\)</span></td></tr><tr class="even"><td><span class="math inline">\(2\)</span></td><td><span class="math inline">\(A[1]\)</span></td><td><span class="math inline">\(1\)</span></td><td><span class="math inline">\(A[0, 1]\)</span></td><td><span class="math inline">\(2\)</span></td></tr><tr class="odd"><td><span class="math inline">\(\vdots\)</span></td><td><span class="math inline">\(\vdots\)</span></td><td><span class="math inline">\(\vdots\)</span></td><td><span class="math inline">\(\vdots\)</span></td><td><span class="math inline">\(\vdots\)</span></td></tr><tr class="even"><td><span class="math inline">\(n-1\)</span></td><td><span class="math inline">\(A[n-2]\)</span></td><td><span class="math inline">\(1\)</span></td><td><span class="math inline">\(A[0\ldots{n-2}]\)</span></td><td><span class="math inline">\(n-1\)</span></td></tr></tbody></table><p>最佳情况下，<code>while</code>循环的执行时间为<span class="math inline">\(\sum_{n=1}^{n-1}1=n-1\)</span>。</p><p>最佳运行时间为<span class="math inline">\(T(n)=(n-1)\Theta(1)+n-1=\Theta(n)\)</span>。它是n的线性函数。</p><p>最坏情况下，<code>while</code>循环的执行时间为<span class="math inline">\(\sum_{n=1}^{n-1}n=\frac{n(n-1)}{2}\)</span>。</p><p>所以，插入排序的最坏情况运行时间为<span class="math inline">\(T(n)=(n-1)\Theta(1)+\frac{n(n-1)}{2}\le{n^2}=O(n^2)\)</span>。此时它是n的二次函数。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(a)):</span><br><span class="line">        key = a[j]</span><br><span class="line">        i = j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> a[i] &gt; key:</span><br><span class="line">            a[i + <span class="number">1</span>] = a[i]</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        a[i + <span class="number">1</span>] = key</span><br></pre></td></tr></table></figure><h2 id="最坏最佳与平均情况">最坏、最佳与平均情况</h2><p>最坏情况比最佳情况更加有用，算法导论给出了三点理由。</p><ul><li>一个算法的最坏情况运行时间给出了任何输入的运行时间的一个上界。知道了这个界，就能确保该算法绝不需要更长的时间。</li><li>对某些算法，最坏情况经常出现。例如，当数据库中检索一条特定信息时，若该信息不在数据库中出现，则检索算法的最坏情况会出现。在某些应用中，对缺失信息的检索可能是频繁的。</li><li>“平均情况”往往与最坏情况大致一致。假定随机选择n个数并应用插入排序。平均来说，<span class="math inline">\(A[0\ldots{j-1}]\)</span>中的一般元素小于<span class="math inline">\(A[j]\)</span>，一半元素大于<span class="math inline">\(A[j]\)</span>。所以，平均来说，每次<code>while</code>循环的比较次数大约为<span class="math inline">\(j/2\)</span>。导致平均情况运行时间结果像最坏情况运行时间一样，也是输入规模的一个二次函数。</li></ul><p>在某些特定情况下，会对一个算法的平均情况运行时间感兴趣。平均情况分析的范围有限，因为对于特定的问题，什么构成一种“平均”输入并不明显。</p><h1 id="选择排序">选择排序</h1><p>如果说插入排序是拿一张牌去找在左手中的位置，那么选择排序就是找出最小的牌，放到左手的末位（或者找最大的牌，放到左手的首位）。与插入排序类似，选择排序也将输入数组分成已排序和未排序两个子数组，每次迭代选择未排序数组中最小（或最大，取决于排序规则）的元素，将其与未排序子数组的第一位元素交换，然后扩展已排序数组的边界加一。</p><p>选择排序示意图（出自<a href="https://en.wikipedia.org/wiki/Selection_sort" title="Selection sort" target="_blank" rel="noopener">维基百科：Selection sort</a>）：</p><p><img title="选择排序动态示意图" data-src="https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif"></p><h2 id="实现-1">实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">selection_sort(A):</span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">0</span> to A.length - <span class="number">2</span>:</span><br><span class="line">        i_min = j</span><br><span class="line">        <span class="keyword">for</span> i = j + <span class="number">1</span> to A.length - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> A[i] &lt; A[i_min]:</span><br><span class="line">                i_min = i</span><br><span class="line">        <span class="keyword">if</span> i_min != j:</span><br><span class="line">            exchange A[i_min] <span class="keyword">with</span> A[j]</span><br></pre></td></tr></table></figure><h2 id="分析-1">分析</h2><p>外层循环执行<span class="math inline">\(n-1\)</span>次，单次运行时间为<span class="math inline">\(\Theta(1)\)</span>。内层循环寻找下一个最小的数执行<span class="math inline">\(n-1-j\)</span>次，单次运行时间也是<span class="math inline">\(\Theta(1)\)</span>。</p><p>总运行时间为：</p><p><span class="math display">\[\begin{aligned}T(n)&amp;=n-1+\sum_{j=0}^{n-2}n-i-j \\&amp;=n-1+\sum_{i=1}^{n-1}n-i \\&amp;=n-1+\frac{n(n-1)}{2} \\&amp;=O(n^2)\end{aligned}\]</span></p><h2 id="代码-1">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(a) - <span class="number">1</span>):</span><br><span class="line">        i_min = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(j + <span class="number">1</span>, len(a)):</span><br><span class="line">            <span class="keyword">if</span> a[i] &lt; a[i_min]:</span><br><span class="line">                i_min = i</span><br><span class="line">        <span class="keyword">if</span> i_min != j:</span><br><span class="line">            a[i_min], a[j] = a[j], a[i_min]</span><br></pre></td></tr></table></figure><h1 id="冒泡排序">冒泡排序</h1><p>冒泡排序（Bubble sort）通过依次比较两个相邻的元素，如果它们的顺序关系是错误的，就交换它们。正如它的命名一样，比较大的元素先浮到数组顶端。</p><p>冒泡排序示意图（出自<a href="https://en.wikipedia.org/wiki/Bubble_sort" title="冒泡排序" target="_blank" rel="noopener">维基百科：Bubble sort</a>）：</p><p><img title="冒泡排序动态示意图" data-src="https://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif"></p><h2 id="实现-2">实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bubble_sort(A):</span><br><span class="line">    n = A.length</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to n - <span class="number">1</span>:       <span class="comment"># 每次循环将下一个最大元素冒泡到正确位置</span></span><br><span class="line">        swapped = false</span><br><span class="line">        <span class="keyword">for</span> j = <span class="number">1</span> to n - i:   <span class="comment"># 后i位元素大于之前的元素且已经排好序</span></span><br><span class="line">            <span class="keyword">if</span> A[j - <span class="number">1</span>] &gt; A[j]:</span><br><span class="line">                exchange A[j] <span class="keyword">with</span> A[j - <span class="number">1</span>]</span><br><span class="line">                swapped = true</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> swapped:       <span class="comment"># 结束排序</span></span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h3 id="优化">优化</h3><p>与其记录<code>swapped=true or false</code>，不如记录下最后发生交换的位置<code>i</code>，之后没有发生交换意味着<code>i</code>之后的元素全部大于<code>i</code>之前的元素且已经按序排好。那么在下次冒泡前，结束位置可以直接跳到<code>i</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bubble_sort(A):</span><br><span class="line">    target = A.length</span><br><span class="line">    <span class="keyword">while</span> target &gt; <span class="number">1</span>:</span><br><span class="line">        last_swap = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j = <span class="number">1</span> to target - <span class="number">1</span>:   <span class="comment"># target及target之后的元素大于之前的元素且已经排好序</span></span><br><span class="line">            <span class="keyword">if</span> A[j - <span class="number">1</span>] &gt; A[j]:</span><br><span class="line">                exchange A[j] <span class="keyword">with</span> A[j - <span class="number">1</span>]</span><br><span class="line">                last_swap = j</span><br><span class="line">        target = last_swap</span><br></pre></td></tr></table></figure><h2 id="分析-2">分析</h2><p>冒泡排序的平均时间和最坏时间复杂度为<span class="math inline">\(O(n^2)\)</span>。在实际应用中，时间复杂度同样是<span class="math inline">\(O(n^2)\)</span>的插入排序一般比冒泡排序要快，更不用说还有其他更快的排序算法。</p><p>冒泡排序可以用来检测一个数组是否已经排好序，即冒泡排序的最佳情况运行时间<span class="math inline">\(O(n)\)</span>。插入排序同样可以在<span class="math inline">\(O(n)\)</span>时间内检测一个数组是否排好序，且比冒泡排序好。</p><h2 id="代码-2">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(a)</span>:</span></span><br><span class="line">    target = len(a)</span><br><span class="line">    <span class="keyword">while</span> target &gt; <span class="number">1</span>:</span><br><span class="line">        last_swapped = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, target):</span><br><span class="line">            <span class="keyword">if</span> a[j - <span class="number">1</span>] &gt; a[j]:</span><br><span class="line">                a[j - <span class="number">1</span>], a[j] = a[j], a[j - <span class="number">1</span>]</span><br><span class="line">                last_swapped = j</span><br><span class="line">        target = last_swapped</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithms </tag>
            
            <tag> sort </tag>
            
            <tag> Introduction To Algorithms </tag>
            
            <tag> comparison sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="/notes/introduction-to-algorithms/heapsort/"/>
      <url>/notes/introduction-to-algorithms/heapsort/</url>
      
        <content type="html"><![CDATA[<h1 id="堆排序">堆排序</h1><p>堆排序（Heapsort）是一种比较排序算法。堆排序在1964年首次被<a href="https://en.wikipedia.org/wiki/J._W._J._Williams" target="_blank" rel="noopener">J. W. J. Williams</a>提出，同时也是堆这种数据结构首次出现。堆排序是一种原址（In-place）、非稳定（NOT stable）排序算法。</p><p>堆排序可以看作是选择排序的优化版本。堆排序与选择排序类似，将数组分成两个部分，未排序部分和已排序部分。算法每次从未排序部分提取最大值放入已排序部分，当未排序部分为空时，排序结束。</p><a id="more"></a><p>选择排序通过一次数组遍历（时间复杂度<span class="math inline">\(\Theta(n)\)</span>获取最大值。而堆排序通过堆这种数据结构快速获取最大值。获取的时间复杂度是<span class="math inline">\(\Theta(1)\)</span>，但获取之后要花费<span class="math inline">\(\Theta(\lg{n})\)</span>时间调整堆，因此总运行时间为<span class="math inline">\(\Theta(1)+\Theta(\lg{n})=\Theta(\lg{n})\)</span>。由此可以看出堆排序相比于选择排序改进的点。</p><p>下面是一幅关于堆排序的示意图（出自<a href="https://en.wikipedia.org/wiki/Heapsort" title="Heapsort" target="_blank" rel="noopener">维基百科</a>）。</p><p><img title="堆排序动态示意图" data-src="https://upload.wikimedia.org/wikipedia/commons/1/1b/Sorting_heapsort_anim.gif"></p><h1 id="堆">堆</h1><p>参考<a href="/data-structures/heaps" title="堆">堆</a>。</p><h1 id="实现">实现</h1><p>有了堆和堆支持的一些基础操作后，可定义堆排序的过程如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">heapsort(A):</span><br><span class="line">    heapify(A)                         <span class="comment"># Build a max heap with array A</span></span><br><span class="line">    <span class="keyword">for</span> i=A.length<span class="number">-1</span> downto <span class="number">1</span>:</span><br><span class="line">        exchange A[<span class="number">0</span>] <span class="keyword">with</span> A[i]</span><br><span class="line">        A.heap_size = A.heap_size - <span class="number">1</span></span><br><span class="line">        sift_down(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>在关于堆的介绍中，所有在<code>heap.data</code>中的数都被认为是堆中的元素，但是堆排序算法为了节省空间被设计成原址算法，<code>heap.data</code>中需要同时存储堆（未排序部分）和非堆（已排序部分），因此需要做点小修改，保证<code>size()</code>函数返回堆的边界，当超出边界时，即使存在对应数据也不被认为是堆中元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size():</span><br><span class="line">    <span class="keyword">return</span> heap_size</span><br></pre></td></tr></table></figure><p>堆排序的运行时间分为两部分，建堆的时间<span class="math inline">\(O(n)\)</span>和<span class="math inline">\(n-1\)</span>次调整堆的时间 <span class="math inline">\(O(\lg{n})\)</span>。所以总的运行时间是</p><p><span class="math inline">\(T(n)=O(n)+(n-1)O(\lg{n})=O(n\lg{n})\)</span>。</p><h1 id="代码">代码</h1><p>继承并重写了堆的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> data_structure.heap <span class="keyword">import</span> MaxHeap</span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> heapify, heappop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min_heap_sort</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="string">"""heap sort implemented by using heapq. NOT an in-place algorithm"""</span></span><br><span class="line">    heap = a[:]</span><br><span class="line">    heapify(heap)</span><br><span class="line">    <span class="keyword">return</span> [heappop(heap) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(heap))]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span><span class="params">(MaxHeap)</span>:</span></span><br><span class="line">    <span class="string">"""基于最大堆的堆排序实现，它是原址排序"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, a)</span>:</span></span><br><span class="line">        MaxHeap.__init__(self, a)</span><br><span class="line">        self.heap_size = len(a)  <span class="comment"># 增加heap_size变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""重写方法"""</span></span><br><span class="line">        <span class="keyword">return</span> self.heap_size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""排序过程主体"""</span></span><br><span class="line">        self.heapify()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.size() - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            self.value[<span class="number">0</span>], self.value[i] = self.value[i], self.value[<span class="number">0</span>]</span><br><span class="line">            self.heap_size -= <span class="number">1</span></span><br><span class="line">            self.sift_down(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    h = HeapSort([<span class="number">16</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line">    h.heap_sort()</span><br><span class="line">    print(h.value)</span><br><span class="line"></span><br><span class="line">    print(min_heap_sort([<span class="number">16</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]))</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 7, 8, 9, 10, 14, 16]</span><br><span class="line">[1, 2, 3, 4, 7, 8, 9, 10, 14, 16]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithms </tag>
            
            <tag> sort </tag>
            
            <tag> Introduction To Algorithms </tag>
            
            <tag> comparison sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆</title>
      <link href="/notes/introduction-to-algorithms/heaps/"/>
      <url>/notes/introduction-to-algorithms/heaps/</url>
      
        <content type="html"><![CDATA[<h1 id="堆">堆</h1><p>堆（Heap）始于<a href="https://en.wikipedia.org/wiki/J._W._J._Williams" target="_blank" rel="noopener">J. W. J. Williams</a>在1964年发表的堆排序（heap sort）。</p><p>堆是一种基于树的数据结构，一棵满足以下性质的完全树可称为堆。</p><blockquote><p>给定堆中任意节点P和C，若P是C的母节点，那么P的值会小于等于（或大于等于）C的值。</p><ol type="1"><li>若P的值小于等于C的值，称为最小堆（min heap）。</li><li>若P的值大于等于C的值，称为最大堆（max heap）。</li></ol></blockquote><p>在堆中最顶端的节点称为根节点（root node），根节点本身没有母节点（parent node）。</p><p>常见的堆有二叉堆、斐波那契堆等。</p><a id="more"></a><h1 id="操作">操作</h1><p>一个堆应该支持以下常见操作（参考了<a href="https://en.wikipedia.org/wiki/Heap_(data_structure)" title="堆" target="_blank" rel="noopener">维基百科</a>）。</p><ul><li><code>peek()</code>：返回堆顶元素。</li><li><code>pop()</code>：返回并移除堆顶元素，需要调整堆。</li><li><code>append(x)</code>：添加一个新的元素<code>x​</code>，需要调整堆以满足堆的性质。</li><li><code>replace()</code>：相当于一次<code>pop</code>之后<code>append</code>。但比分别执行更效率，因为只需要调整一次堆。</li></ul><hr><ul><li><code>heapify()</code>：创建一个堆。只需要调用一次。</li><li><code>merge(other)</code>：合并<code>other</code>中的元素到堆。</li></ul><hr><ul><li><code>size()</code>：返回堆中元素数。</li><li><code>is_empty()</code>：如果是空堆，返回<code>true</code>，否则返回<code>false</code>。</li></ul><hr><ul><li><code>increase_key(i, x)</code>：增大元素的值。</li><li><code>decrease_key(i, x)</code>：减小元素的值。</li><li><code>delete(i)</code>：删除指定的一个元素。</li><li><code>sift_up(i)</code>：不断上移元素，直到满足最小堆的性质。</li><li><code>sift_down(i)</code>：不断下移元素，直到满足最大堆的性质。</li></ul><h1 id="实现">实现</h1><p>堆通常用数组（静态或动态）实现，并且不需要保存指针。</p><p>树的根节点是<span class="math inline">\(A[0]\)</span>，给定一个节点的下标<span class="math inline">\(i\)</span>，通过计算可以得到它的母节点、左孩子和右孩子节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">parent(i):</span><br><span class="line">    <span class="keyword">return</span> floor((i<span class="number">-1</span>) / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">left_child(i):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">right_child(i):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">2</span></span><br></pre></td></tr></table></figure><p><img title="堆和数组" data-src="/uploads/posts/heap-and-array.png"></p><h2 id="维护堆的性质">维护堆的性质</h2><p>以最大堆为例，如何维护一个数组使之满足最大堆性质。考虑下面这种情况。</p><ul><li>前提条件：假设<strong>根节点</strong>为<code>left_child(i)</code>和<code>right_child(i)</code>的二叉树都是最大堆。</li></ul><p>但<code>A[i]</code>有可能小于其孩子节点，这违背了最大堆的性质。<code>sift_down</code>（下滤）通过让<code>A[i]</code>的值在最大堆中“逐级下降”，从而使下标为<code>i</code>的子树重新遵循最大堆的性质。</p><p><img title="sift down" data-src="/uploads/posts/heap-sift-down.png"></p><p>关于逐级下降正确性的思考：满足前提条件的情况下，</p><p>假设根节点<code>i</code>与<code>i</code>的子节点<code>x, y</code>中，值最大的是子节点<code>x</code>。交换<code>i</code>与<code>x</code>的值，现在<code>A[i]&gt;A[x]</code>，满足最大堆的性质。但<code>x</code>的值相比交换前变小了，所以可能小于其子节点的值。</p><p>新的状况变为节点<code>x</code>可能小于其子节点的值，其子节点均大于或等于下一层子节点的值。符合前提条件，所以对<code>x</code>递归调用<code>sift_down</code>即可。在节点<code>i</code>上执行<code>sift_down</code>的过程如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sift_down(A, i):</span><br><span class="line">    l = left_child(i)</span><br><span class="line">    r = right_child(i)</span><br><span class="line">    <span class="keyword">if</span> l &lt; size() <span class="keyword">and</span> A[l] &gt; A[i]:  <span class="comment"># Find the largest element of i, l and r.</span></span><br><span class="line">        largest = l</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        largest = i</span><br><span class="line">    <span class="keyword">if</span> r &lt; size() <span class="keyword">and</span> A[r] &gt; A[largest]:</span><br><span class="line">        largest = r</span><br><span class="line">    <span class="keyword">if</span> largest != i:              <span class="comment"># If violating the heap properity, then fix them.</span></span><br><span class="line">        exchange A[i] <span class="keyword">with</span> A[largest]</span><br><span class="line">        sift_down(A, largest)     <span class="comment"># A[largest] might violating the heap properity.</span></span><br><span class="line">                                  <span class="comment"># Call sift_down recursively to fix it.</span></span><br></pre></td></tr></table></figure><p><code>sift_down</code>的时间复杂度：</p><p>在一棵大小为<span class="math inline">\(n\)</span>​的子树上，运行<code>sift_down</code>的时间<span class="math inline">\(T(n)\)</span>包括：比较三个节点大小关系以及交换值的时间代价<span class="math inline">\(\Theta(1)\)</span>，加上在一棵子树上运行<code>sift_down</code>的时间。子树的大小至多为<span class="math inline">\(2n/3\)</span>（最底层正好半满的时候，即最后一层左子树节点填满，右子树节点是空的），由此可以得到刻画程序运行时间的递归式：<span class="math inline">\(T(n)\le\Theta(1)+T(2n/3)\)</span>。解得<span class="math inline">\(T(n)=O(\lg{n})\)</span>。</p><p>也就是说，对于一棵树高为<span class="math inline">\(h\)</span>的节点来说，<code>sift_down</code>的时间复杂度是<span class="math inline">\(O(h)\)</span>。</p><p>关于一棵子树的大小至多为<span class="math inline">\(2n/3\)</span>的由来。</p><p>首先明确关于树的两个性质：</p><ol type="1"><li>如果以某个节点为根节点的树是完全树，那么它的左子树大小大于等于右子树大小。因为完全树的最后一层是从左到右填入的。</li><li>如果一棵满二叉树的最后一层节点数目为<span class="math inline">\(n\)</span>，那么这个树的大小为<span class="math inline">\(2n-1\)</span>。因为满二叉树第<span class="math inline">\(i(i&gt;=0)\)</span>层节点数量是<span class="math inline">\(2^i\)</span>。</li></ol><p>根据性质1，只需要考虑左子树最多为母树的几分之几即可。</p><p>假设一个完全树的大小为<span class="math inline">\(n\)</span>，它的左子树大小为<span class="math inline">\(i\)</span>，比值<span class="math inline">\(i/n\)</span>根据最底层节点数目而变动。观察最底层节点数目从0逐渐增长时该比值的变化情况。</p><ul><li><p>当新增节点属于左子树时，比值由<span class="math inline">\(i/n\)</span>变成<span class="math inline">\((i+1)/(n+1)\)</span>，比值增大。</p></li><li><p>当新增节点属于右子树时，比值由<span class="math inline">\(i/n\)</span>变成<span class="math inline">\(i/(n+1)\)</span>，比值减小。</p></li></ul><p>因此当左子树恰好填满（最底层恰好半满）时，比值最大。</p><p>设此时最低层节点个数为<span class="math inline">\(x\)</span>，注意这<span class="math inline">\(x\)</span>个节点正好填满左子树最底层，则根据性质2，<span class="math inline">\(i=2x-1\)</span>，<span class="math inline">\(n=2*i+1-x=3x-1\)</span>。</p><p>所以得到<span class="math inline">\(i/n=(2x-1)/(3x-1)\le2/3\)</span>。即大小为<span class="math inline">\(n\)</span>的树中，子树的大小至多为<span class="math inline">\(2n/3\)</span>。</p><h2 id="建堆">建堆</h2><p>同样以最大堆为例，可以用<strong>自底向上</strong>的方法调用过程<code>sift_down</code>，将一个数组转换为最大堆。过程<code>heapify</code>对树中非叶子节点都调用一次<code>sift_down</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heapify(A):</span><br><span class="line">    <span class="keyword">for</span> i = parent(size()<span class="number">-1</span>) downto <span class="number">0</span>:</span><br><span class="line">        sift_down(A, i)</span><br></pre></td></tr></table></figure><p>可以使用如下的循环不变量验证该过程的正确性。</p><blockquote><p>每一次<code>for</code>循环开始前，节点 <code>i, i+1,...,size()</code>都是一个最大堆的根节点。</p></blockquote><p>需要证明此循环不变量在循环开始前，迭代时以及结束后都成立。</p><ul><li>初始化：第一次迭代前，<code>i</code>之后的节点都是叶节点，因此它们都是最大堆的根节点。</li><li>保持：注意到节点<code>i+1​</code>始终比<code>i</code>先调用<code>sift_down</code>过程，根据循环不变量，它们都是最大堆的根节点。</li><li>终止：终止时<code>i=-1​</code>，根据循环不变量节点<code>0,1,...,size()</code>都是最大堆的根节点，特别的，<code>0</code>是堆的顶点。</li></ul><p>之前分析了<code>sift_down(A, i)</code>的运行时间与节点<code>i</code>所处高度有关，在建堆过程中，不同的节点所处高度可能不同，想准确计算建堆的时间复杂度利用了下面所示的树的特性。</p><ul><li>一棵含有<span class="math inline">\(n\)</span>个元素的完全树，在高度<span class="math inline">\(h\)</span>处，最多有<span class="math inline">\(\lceil{n/2^{h+1}}\rceil\)</span> 个元素。根节点所处高度为0。</li></ul><p>根据这条性质，运行时间可以刻画为 <span class="math display">\[\begin{aligned}T(n)&amp;=\sum_{h=0}^{\lfloor\log_{2}n\rfloor}\lceil{n/2^{h+1}}\rceil*O(h)\\&amp;=O(n\sum_{h=0}^{\lfloor\log_{2}n\rfloor}\frac{h}{2^h})\end{aligned}\\\begin{aligned}\because&amp;\sum_{k=0}^{\infty}kx^k=\frac{x}{(1-x)^2}(|x|\le1)\\\therefore&amp;\sum_{h=0}^{\infty}\frac{h}{2^h}=\frac{1/2}{(1-\frac{1}{2})^2}=2\end{aligned}\]</span></p><p>将其带入可得 <span class="math display">\[\begin{aligned}T(n)&amp;=O(n\sum_{h=0}^{\infty}\frac{h}{2^h})\\&amp;=O(n)\end{aligned}\]</span> 由此可得出结论，<code>heapify</code>可以在线性时间内将一个数组转换成一个堆。</p><h2 id="其他方法">其他方法</h2><ul><li><code>sift_up</code>：与<code>sift_down</code>相反，当节点 <code>i</code> 的值大于其母节点的值，而其他节点均满足堆的性质时，通过此过程将节点 <code>i</code> 不断上移，直到满足堆的性质。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sift_up(A, i):</span><br><span class="line">    <span class="keyword">while</span> i&gt;<span class="number">1</span> <span class="keyword">and</span> A[parent(i)] &lt; A[i]:</span><br><span class="line">        exchange A[parent(i)] <span class="keyword">with</span> A[i]</span><br><span class="line">        i = parent(i)</span><br></pre></td></tr></table></figure><ul><li><code>increase_key</code>：当堆中某个节点的值变大时，可能大于其母节点，与上述情况相同。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">increase_key(A, i):</span><br><span class="line">    sift_up(A, i)</span><br></pre></td></tr></table></figure><ul><li><code>decrease_key</code>：与<code>sift_down</code>的情况相同。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decrease_key(A, i):</span><br><span class="line">    sift_down(A, i)</span><br></pre></td></tr></table></figure><ul><li><code>replace</code>：更新后的值大于原来的值，调用<code>increase_key</code>；小于原来的值，调用<code>decrease_key</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">replace(A, i, x):</span><br><span class="line">    <span class="keyword">if</span> A[i] &lt; x:</span><br><span class="line">        increase_key(A, i)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> A[i] &gt; x:</span><br><span class="line">        decrease_key(A, i)</span><br></pre></td></tr></table></figure><ul><li><code>append</code>：先添加一个值为无穷小的元素到堆的末尾，然后调用<code>increase_key</code>修改值。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">append(A, x):</span><br><span class="line">    A.heap_size = A.heap_size + <span class="number">1</span></span><br><span class="line">    A[A.heap_size - <span class="number">1</span>] = -inf</span><br><span class="line">    increase_key(A, A.heap_size - <span class="number">1</span>, x)</span><br></pre></td></tr></table></figure><hr><ul><li><code>peek</code>：第一个元素就是堆顶元素，直接返回即可。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">peek():</span><br><span class="line">    <span class="keyword">return</span> A[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><ul><li><code>pop</code>：将堆顶元素保存，然后用最后一个元素替换堆顶元素，删除最后一个元素。此时堆顶元素可能违背堆的性质，对其调用<code>sift_down</code>。或者调用<code>decrease_key</code>将堆顶元素的值减小到最后一个元素值，两者调用的过程时一样的。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pop():</span><br><span class="line">    r = A[<span class="number">0</span>]</span><br><span class="line">    A[<span class="number">0</span>] = A[A.lenght - <span class="number">1</span>]</span><br><span class="line">    A.heap_size = A.heap_size - <span class="number">1</span></span><br><span class="line">    sift_down(A, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure><ul><li><code>delete</code>：与<code>pop</code>过程相同，<code>pop</code>就是特殊的<code>delete</code>过程。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">delete(A, i):</span><br><span class="line">    A[i] = A[A.lenght - <span class="number">1</span>]</span><br><span class="line">    A.heap_size = A.heap_size - <span class="number">1</span></span><br><span class="line">    sift_down(A, i)</span><br></pre></td></tr></table></figure><hr><ul><li><code>merge</code>：逐次调用<code>append</code>添加另一个堆中的元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">merge(A, o):</span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> o:</span><br><span class="line">        append(A, e)</span><br></pre></td></tr></table></figure><ul><li><code>meld</code>：取出两个堆中的元素，合并成新的列表，调用<code>heapify</code>创建堆。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meld(A, B, C):</span><br><span class="line">    C = A + B</span><br><span class="line">    heapify(C)</span><br></pre></td></tr></table></figure><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parent</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="string">"""计算元素i的母节点位置"""</span></span><br><span class="line">    <span class="keyword">return</span> math.floor((i - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">left_child</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="string">"""计算元素i的左孩子节点位置"""</span></span><br><span class="line">    <span class="keyword">return</span> (i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">right_child</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="string">"""计算元素i的右孩子节点位置"""</span></span><br><span class="line">    <span class="keyword">return</span> (i &lt;&lt; <span class="number">1</span>) + <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(a, i, j)</span>:</span></span><br><span class="line">    <span class="string">"""交换元素i和j的值"""</span></span><br><span class="line">    a[i], a[j] = a[j], a[i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heap</span>:</span></span><br><span class="line">    <span class="string">"""最小堆"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回堆顶元素"""</span></span><br><span class="line">        <span class="keyword">return</span> self.value[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""删除并返回堆顶元素"""</span></span><br><span class="line">        <span class="keyword">if</span> self.size() &gt; <span class="number">1</span>:  <span class="comment"># 堆中元素多于2个时，pop()之后需要调整堆</span></span><br><span class="line">            m = self.value[<span class="number">0</span>]</span><br><span class="line">            self.value[<span class="number">0</span>] = self.value.pop(self.size() - <span class="number">1</span>)  <span class="comment"># 将堆尾元素移动到堆顶</span></span><br><span class="line">            self.sift_down(<span class="number">0</span>)  <span class="comment"># 调整堆</span></span><br><span class="line">            <span class="keyword">return</span> m</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 堆中元素少于2个时，直接调用list的pop()方法</span></span><br><span class="line">            <span class="keyword">return</span> self.value.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""添加元素"""</span></span><br><span class="line">        self.value.append(x)</span><br><span class="line">        self.decrease_key(self.size() - <span class="number">1</span>, x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replace</span><span class="params">(self, i, x)</span>:</span></span><br><span class="line">        <span class="string">"""替换元素的值，替换堆顶元素时指定i=0"""</span></span><br><span class="line">        <span class="keyword">if</span> self.value[i] &lt; x:</span><br><span class="line">            self.increase_key(i, x)</span><br><span class="line">        <span class="keyword">elif</span> self.value[i] &gt; x:</span><br><span class="line">            self.decrease_key(i, x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heapify</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""建堆"""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(parent(self.size() - <span class="number">1</span>), <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            self.sift_down(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="string">"""合并堆"""</span></span><br><span class="line">        self.value.extend(other)</span><br><span class="line">        self.heapify()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回堆的大小"""</span></span><br><span class="line">        <span class="keyword">return</span> len(self.value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""判断是否是空堆"""</span></span><br><span class="line">        <span class="keyword">return</span> self.size() == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increase_key</span><span class="params">(self, i, x)</span>:</span></span><br><span class="line">        <span class="string">"""增加元素的值"""</span></span><br><span class="line">        self.value[i] = x</span><br><span class="line">        self.sift_down(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decrease_key</span><span class="params">(self, i, x)</span>:</span></span><br><span class="line">        <span class="string">"""减小元素的值"""</span></span><br><span class="line">        self.value[i] = x</span><br><span class="line">        self.sift_up(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="string">"""删除元素"""</span></span><br><span class="line">        last = self.value.pop(self.size() - <span class="number">1</span>)  <span class="comment"># pop堆尾元素</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; self.size():  <span class="comment"># 防止删除堆中唯一元素时越界</span></span><br><span class="line">            self.decrease_key(i, last)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sift_up</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="string">"""上滤，将元素放到正确位置"""</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> self.value[parent(i)] &gt; self.value[i]:</span><br><span class="line">            exchange(self.value, parent(i), i)</span><br><span class="line">            i = parent(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sift_down</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="string">"""下滤，将元素放到正确位置"""</span></span><br><span class="line">        l, r = left_child(i), right_child(i)</span><br><span class="line">        <span class="keyword">if</span> l &lt; self.size() <span class="keyword">and</span> self.value[l] &lt; self.value[i]:</span><br><span class="line">            smallest = l</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            smallest = i</span><br><span class="line">        <span class="keyword">if</span> r &lt; self.size() <span class="keyword">and</span> self.value[r] &lt; self.value[smallest]:</span><br><span class="line">            smallest = r</span><br><span class="line">        <span class="keyword">if</span> smallest != i:</span><br><span class="line">            exchange(self.value, i, smallest)</span><br><span class="line">            self.sift_down(smallest)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span><span class="params">(Heap)</span>:</span></span><br><span class="line">    <span class="string">"""最大堆"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.append(x)</span><br><span class="line">        self.increase_key(self.size() - <span class="number">1</span>, x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increase_key</span><span class="params">(self, i, x)</span>:</span></span><br><span class="line">        self.value[i] = x</span><br><span class="line">        self.sift_up(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decrease_key</span><span class="params">(self, i, x)</span>:</span></span><br><span class="line">        self.value[i] = x</span><br><span class="line">        self.sift_down(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sift_down</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        l, r = left_child(i), right_child(i)</span><br><span class="line">        <span class="keyword">if</span> l &lt; self.size() <span class="keyword">and</span> self.value[l] &gt; self.value[i]:</span><br><span class="line">            largest = l</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            largest = i</span><br><span class="line">        <span class="keyword">if</span> r &lt; self.size() <span class="keyword">and</span> self.value[r] &gt; self.value[largest]:</span><br><span class="line">            largest = r</span><br><span class="line">        <span class="keyword">if</span> largest != i:</span><br><span class="line">            exchange(self.value, i, largest)</span><br><span class="line">            self.sift_down(largest)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sift_up</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> self.value[self.value.parent(i)] &lt; self.value[i]:</span><br><span class="line">            exchange(self.value, parent(i), i)</span><br><span class="line">            i = parent(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    min_heap = Heap([<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">7</span>])</span><br><span class="line">    min_heap.heapify()</span><br><span class="line">    print(<span class="string">'min heap'</span>, min_heap.value)</span><br><span class="line"></span><br><span class="line">    max_heap = MaxHeap([<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">7</span>])</span><br><span class="line">    max_heap.heapify()</span><br><span class="line">    print(<span class="string">'max heap'</span>, max_heap.value)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min heap [1, 2, 3, 4, 7, 9, 10, 14, 8, 16]</span><br><span class="line">max heap [16, 14, 10, 8, 7, 9, 3, 2, 4, 1]</span><br></pre></td></tr></table></figure><h1 id="应用">应用</h1><ul><li><p>堆排序</p></li><li><p>优先队列</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction To Algorithms </tag>
            
            <tag> data structures </tag>
            
            <tag> binary tree </tag>
            
            <tag> heap </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
