<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用动态属性转换数据</title>
      <link href="/notes/fluent-python/data-wrangling-with-dynamic-attributes/"/>
      <url>/notes/fluent-python/data-wrangling-with-dynamic-attributes/</url>
      
        <content type="html"><![CDATA[<p>在Python中，数据的属性和处理数据的方法统称属性（attribute）。其实，方式只是可调用的属性。除了这二者之外，我们还可以创建特性（property），在不改变接口的前提下，使用存取方法（即读值方法和设值方法）修改数据属性。这与统一访问原则相符：不管服务是由存储还是计算实现的，一个模块提供的所有服务都应该通过统一的方式使用。</p><p>除了特性，Python还提供了丰富的API，用于控制属性的访问权限，以及实现动态属性。使用点号访问属性时（如obj.attr），Python解释器会调用特殊的方法（如<code>__getattr__</code>和<code>__setattr__</code>）计算属性。用户自己定义的类可以通过<code>__getattr__</code>方法实现“虚拟属性”，当访问不存在的属性时，即时计算属性的值。</p><p>动态创建属性是一种元编程，框架的作者经常这么做。然而，在Python中，相关的基础技术十分简单，任何人都可以使用，甚至在日常的数据转换任务中也能用到。下面以这种任务开启本章的话题。</p><a id="more"></a><h1 id="使用动态属性转换数据">使用动态属性转换数据</h1><figure class="highlight json"><figcaption><span>osconfeed.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"Schedule"</span>:</span><br><span class="line">  &#123; <span class="attr">"conferences"</span>: [&#123;<span class="attr">"serial"</span>: <span class="number">115</span> &#125;],</span><br><span class="line">    <span class="attr">"events"</span>: [</span><br><span class="line">      &#123; <span class="attr">"serial"</span>: <span class="number">34505</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Why Schools Don ́t Use Open Source to Teach Programming"</span>,</span><br><span class="line">        <span class="attr">"event_type"</span>: <span class="string">"40-minute conference session"</span>,</span><br><span class="line">        <span class="attr">"time_start"</span>: <span class="string">"2014-07-23 11:30:00"</span>,</span><br><span class="line">        <span class="attr">"time_stop"</span>: <span class="string">"2014-07-23 12:10:00"</span>,</span><br><span class="line">        <span class="attr">"venue_serial"</span>: <span class="number">1462</span>,</span><br><span class="line">        <span class="attr">"description"</span>: <span class="string">"Aside from the fact that high school programming..."</span>,</span><br><span class="line">        <span class="attr">"website_url"</span>: <span class="string">"http://oscon.com/oscon2014/public/schedule/detail/34505"</span>,</span><br><span class="line">        <span class="attr">"speakers"</span>: [<span class="number">157509</span>],</span><br><span class="line">        <span class="attr">"categories"</span>: [<span class="string">"Education"</span>] &#125;,</span><br><span class="line">      &#123; <span class="attr">"更多条记录"</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"speakers"</span>: [</span><br><span class="line">      &#123; <span class="attr">"serial"</span>: <span class="number">157509</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Robert Lefkowitz"</span>,</span><br><span class="line">        <span class="attr">"photo"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"url"</span>: <span class="string">"http://sharewave.com/"</span>,</span><br><span class="line">        <span class="attr">"position"</span>: <span class="string">"CTO"</span>,</span><br><span class="line">        <span class="attr">"affiliation"</span>: <span class="string">"Sharewave"</span>,</span><br><span class="line">        <span class="attr">"twitter"</span>: <span class="string">"sharewaveteam"</span>,</span><br><span class="line">        <span class="attr">"bio"</span>: <span class="string">"Robert  ́r0ml ́ Lefkowitz is the CTO at Sharewave, a startup..."</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">"更多条记录"</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"venues"</span>: [</span><br><span class="line">      &#123; <span class="attr">"serial"</span>: <span class="number">1462</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"F151"</span>,</span><br><span class="line">        <span class="attr">"category"</span>: <span class="string">"Conference Venues"</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">"更多条记录"</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>osconfeed.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">URL = <span class="string">'http://www.oreilly.com/pub/sc/osconfeed'</span></span><br><span class="line">JSON = <span class="string">'data/osconfeed.json'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(JSON):  <span class="comment"># 如果文件不存在就去下载</span></span><br><span class="line">        msg = <span class="string">'downloading &#123;&#125; to &#123;&#125;'</span>.format(URL, JSON)</span><br><span class="line">        warnings.warn(msg)  <span class="comment"># 发出警告</span></span><br><span class="line">        <span class="comment"># 在with语句中使用两个上下文管理器</span></span><br><span class="line">        <span class="keyword">with</span> urlopen(URL) <span class="keyword">as</span> remote, open(JSON, <span class="string">'wb'</span>) <span class="keyword">as</span> local:</span><br><span class="line">            local.write(remote.read())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(JSON) <span class="keyword">as</span> fp:</span><br><span class="line">        <span class="keyword">return</span> json.load(fp)  <span class="comment"># 返回Python原生对象</span></span><br></pre></td></tr></table></figure><h1 id="使用动态属性访问json类数据">使用动态属性访问JSON类数据</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> osconfeed <span class="keyword">import</span> load</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>feed = load()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(feed[<span class="string">'Schedule'</span>].keys())  <span class="comment"># feed是一个字典，里面嵌套这字典和列表</span></span><br><span class="line">[<span class="string">'conferences'</span>, <span class="string">'events'</span>, <span class="string">'speakers'</span>, <span class="string">'venues'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key, value <span class="keyword">in</span> sorted(feed[<span class="string">'Schedule'</span>].items()):</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'&#123;:3&#125; &#123;&#125;'</span>.format(len(value), key))</span><br><span class="line">...</span><br><span class="line">  <span class="number">1</span> conferences</span><br><span class="line"><span class="number">494</span> events</span><br><span class="line"><span class="number">357</span> speakers</span><br><span class="line"> <span class="number">53</span> venues</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>feed[<span class="string">'Schedule'</span>][<span class="string">'speakers'</span>][<span class="number">-1</span>][<span class="string">'name'</span>]  <span class="comment"># 最后一位演讲者的名字</span></span><br><span class="line"><span class="string">'Carina C. Zona'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>feed[<span class="string">'Schedule'</span>][<span class="string">'speakers'</span>][<span class="number">-1</span>][<span class="string">'serial'</span>]  <span class="comment"># 最后一位演讲者的编号</span></span><br><span class="line"><span class="number">141590</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>feed[<span class="string">'Schedule'</span>][<span class="string">'events'</span>][<span class="number">40</span>][<span class="string">'name'</span>]  <span class="comment"># 事件名称</span></span><br><span class="line"><span class="string">'There *Will* Be Bugs'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>feed[<span class="string">'Schedule'</span>][<span class="string">'events'</span>][<span class="number">40</span>][<span class="string">'speakers'</span>]  <span class="comment"># 事件的演讲者列表</span></span><br><span class="line">[<span class="number">3471</span>, <span class="number">5199</span>]</span><br></pre></td></tr></table></figure><h2 id="使用动态属性访问json类数据-1">使用动态属性访问JSON类数据</h2><p>feed['Schedule']['events'][40]['name']这种句法很冗长。在JavaScript中，可以使用feed.Schedule.events[40].name获取那个值。在Python中，可以实现一个近似字典的类（网上有大量实现，最常提到的一个实现是<a href="https://pypi.python.org/pypi/attrdict" target="_blank" rel="noopener">AttrDict</a>，还有一个实现能快速创建嵌套的映射——<a href="https://pypi.python.org/pypi/addict" target="_blank" rel="noopener">addict</a>），达到同样的效果。</p><figure class="highlight python"><figcaption><span>explore0.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrozenJSON</span>:</span></span><br><span class="line">    <span class="string">"""一个只读接口，使用属性表示法访问JSON类对象</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, mapping)</span>:</span></span><br><span class="line">        self.__data = dict(mapping)  <span class="comment"># 使用mapping创建一个字典副本</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(self.__data, name):  <span class="comment"># name是__data的属性</span></span><br><span class="line">            <span class="keyword">return</span> getattr(self.__data, name)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 从__data中获取name键对应的元素</span></span><br><span class="line">            <span class="keyword">try</span>:  <span class="comment"># 捕获异常的姿势可能不正确</span></span><br><span class="line">                <span class="keyword">return</span> FrozenJSON.build(self.__data[name])</span><br><span class="line">            <span class="keyword">except</span> KeyError:  <span class="comment"># 可能出现KeyError异常</span></span><br><span class="line">                msg = <span class="string">'&#123;!r&#125; object has no attribute &#123;!r&#125;'</span></span><br><span class="line">                <span class="comment"># 属性访问应该抛出AttributeError</span></span><br><span class="line">                <span class="keyword">raise</span> AttributeError(msg.format(type(self).__name__, name))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(cls, obj)</span>:</span>  <span class="comment"># 备选构造方法</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(obj, abc.Mapping):  <span class="comment"># 是映射</span></span><br><span class="line">            <span class="keyword">return</span> cls(obj)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(obj, abc.MutableSequence):  <span class="comment"># 是列表</span></span><br><span class="line">            <span class="keyword">return</span> [cls.build(item) <span class="keyword">for</span> item <span class="keyword">in</span> obj]</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 其他</span></span><br><span class="line">            <span class="keyword">return</span> obj</span><br></pre></td></tr></table></figure><p>我们要记住重要的一点，<strong>仅当无法使用常规的方式获取属性（即在实例、类或超类中找不到指定的属性），解释器才会调用特殊的<code>__getattr__</code>方法。</strong>这个方法首先查看<code>self.__data</code>字典有没有指定名称的属性（不是键），这样FrozenJSON实例便可以处理字典的所有方法，例如把items方法委托给<code>self.__data.items</code>方法。如果<code>self.__data</code>没有指定名称的属性，那么<code>__getattr__</code>方法以那个名称为键，从<code>self.__data</code>中获取一个元素，传给FrozenJSON.build方法。这样就能深入JSON数据的嵌套结构，使用类方法build把每一层嵌套转换成一个FrozenJSON实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> osconfeed <span class="keyword">import</span> load</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> explore0 <span class="keyword">import</span> FrozenJSON</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>raw_feed = load()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>feed = FrozenJSON(raw_feed)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(feed.Schedule.speakers)</span><br><span class="line"><span class="number">357</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(feed.Schedule.keys())</span><br><span class="line">[<span class="string">'conferences'</span>, <span class="string">'events'</span>, <span class="string">'speakers'</span>, <span class="string">'venues'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>talk = feed.Schedule.events[<span class="number">40</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(talk)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">explore0</span>.<span class="title">FrozenJSON</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">talk</span>.<span class="title">name</span></span></span><br><span class="line"><span class="class">'<span class="title">There</span> *<span class="title">Will</span>* <span class="title">Be</span> <span class="title">Bugs</span>'</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">talk</span>.<span class="title">flavor</span></span></span><br><span class="line"><span class="class"><span class="title">Traceback</span> <span class="params">(most recent call last)</span>:</span></span><br><span class="line">  File <span class="string">"/Users/cws/Desktop/explore0.py"</span>, line <span class="number">15</span>, <span class="keyword">in</span> __getattr__</span><br><span class="line">    <span class="keyword">return</span> FrozenJSON.build(self.__data[name])</span><br><span class="line">KeyError: <span class="string">'flavor'</span>  <span class="comment"># 这个也出来了？</span></span><br><span class="line"></span><br><span class="line">During handling of the above exception, another exception occurred:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"/Users/cws/Desktop/explore0.py"</span>, line <span class="number">19</span>, <span class="keyword">in</span> __getattr__</span><br><span class="line">    <span class="keyword">raise</span> AttributeError(msg.format(type(self).__name__, name))</span><br><span class="line">AttributeError: <span class="string">'FrozenJSON'</span> object has no attribute <span class="string">'flavor'</span></span><br></pre></td></tr></table></figure><p>注意，我们没有缓存或转换原始数据源。在迭代数据源的过程中，嵌套的数据结构不断被转换成FrozenJSON对象。这么做没问题，因为数据集不大，而且这个脚本只用于访问或转换数据。</p><p>从随机源中生成或仿效动态属性名的脚本都必须处理一个问题：原始数据中的键可能不适合作为属性名。</p><h2 id="处理无效属性名">处理无效属性名</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>grad = FrozenJSON(&#123;<span class="string">'name'</span>: <span class="string">'Jim Bo'</span>, <span class="string">'class'</span>: <span class="number">1982</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grad.<span class="keyword">class</span>  <span class="comment"># 无法读取，因为在Python中class是保留字</span></span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    grad.<span class="keyword">class</span></span><br><span class="line">             ^</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(grad, <span class="string">'class'</span>)  <span class="comment"># 可以这么做，但是不够便利</span></span><br><span class="line"><span class="number">1982</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>explore1.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword  <span class="comment"># 检查关键字</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># FrozenJSON类中修改</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, mapping)</span>:</span></span><br><span class="line">        self.__data = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> mapping.items():  <span class="comment"># 检查每个键名</span></span><br><span class="line">            <span class="keyword">if</span> keyword.iskeyword(key):  <span class="comment"># 在关键字的属性后面加_</span></span><br><span class="line">                key += <span class="string">'_'</span></span><br><span class="line">            self.__data[key] = value</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> osconfeed <span class="keyword">import</span> load</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grad = FrozenJSON(&#123;<span class="string">'name'</span>: <span class="string">'Jim Bo'</span>, <span class="string">'class'</span>: <span class="number">1982</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grad.class_  <span class="comment"># 这样访问</span></span><br></pre></td></tr></table></figure><p>如果JSON对象中的键不是有效的Python标识符，也会遇到类似的问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = FrozenJSON(&#123;<span class="string">'2be'</span>:<span class="string">'or not'</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x<span class="number">.2</span>be</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    x<span class="number">.2</span>be</span><br><span class="line">      ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><p>这种有问题的键在Python3中易于检测，因为str类提供的isidentifier方法能根据语言的语法判断s是否为有效的Python标识符。但是，把无效的标识符变成有效的属性名却不容易。对此，有两个简单的解决方法，一个是抛出异常，另一个是把无效的键换成通用名称，例如attr_0、attr_1，等等。</p><p>类方法build把嵌套结构转换成FrozenJSON实例或FrozenJSON实例列表，因为<code>__getattr__</code>方法使用这个方法访问属性时，能为不同的值返回不同类型的对象。除了在类方法中实现这样的逻辑之外，还可以在特殊的<code>__new__</code>方法中实现。</p><h2 id="使用__new__方法以灵活的方式创建对象">使用<code>__new__</code>方法以灵活的方式创建对象</h2><p>我们通常把<code>__init__</code>称为构造方法，这是从其他语言借鉴过来的术语。其实，用于构建实例的是特殊方法<code>__new__</code>：这是个类方法（使用特殊方式处理，因此不必使用@classmethod装饰器），必须返回一个实例。返回的实例会作为第一个参数（即self）传给<code>__init__</code>方法。因为调用<code>__init__</code>方法时要传入实例，而且禁止返回任何值，所以<code>__init__</code>方法其实是“初始化方法”。真正的构造方法是<code>__new__</code>。我们几乎不需要自己编写<code>__new__</code>方法，因为从object类继承的实现已经足够了。</p><p>从<code>__new__</code>方法到<code>__init__</code>方法，是最常见的，但不是唯一的。<code>__new__</code>方法也可以返回其他类的实例，此时，解释器不会调用<code>__init__</code>方法。</p><p>也就是说，Python构建对象的过程可以使用下述伪代码概括：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建对象的伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object_maker</span><span class="params">(the_class, some_arg)</span>:</span></span><br><span class="line">    new_object = the_class.__new__(some_arg)</span><br><span class="line">    <span class="keyword">if</span> isinstance(new_object, the_class):</span><br><span class="line">        the_class.__init__(new_object, some_arg)</span><br><span class="line">    <span class="keyword">return</span> new_object</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下述两个语句的作用基本等效</span></span><br><span class="line">x = Foo(<span class="string">'bar'</span>)</span><br><span class="line">x = object_maker(Foo, <span class="string">'bar'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>explore2.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrozenJSON</span>:</span></span><br><span class="line">    <span class="string">"""一个只读接口，使用属性表示法访问JSON类对象</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, arg)</span>:</span>  <span class="comment"># 第一个参数是类本身</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(arg, abc.Mapping):</span><br><span class="line">            <span class="keyword">return</span> super().__new__(cls)  <span class="comment"># 默认的行为</span></span><br><span class="line">        <span class="keyword">elif</span> isinstance(arg, abc.MutableSequence):</span><br><span class="line">            <span class="keyword">return</span> [cls(item) <span class="keyword">for</span> item <span class="keyword">in</span> arg]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> arg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, mapping)</span>:</span></span><br><span class="line">        self.__data = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> mapping.items():</span><br><span class="line">            <span class="keyword">if</span> iskeyword(key):</span><br><span class="line">                key += <span class="string">'_'</span></span><br><span class="line">            self.__data[key] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(self.__data, name):</span><br><span class="line">            <span class="keyword">return</span> getattr(self.__data, name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> FrozenJSON(self.__data[name])  <span class="comment"># 直接调用构造方法</span></span><br></pre></td></tr></table></figure><p><code>__new__</code>方法的第一个参数是类，因为创建的对象通常是那个类的实例。所以，在<code>FrozenJSON.__new__</code>方法中，<code>super().__new__(cls)</code>表达式会调用<code>object.__new__(FrozenJSON)</code>，而object类构建的实例其实是FrozenJSON实例，即那个实例的<code>__class__</code>属性存储的是FrozenJSON类的引用。不过，真正的构建操作由解释器调用C语言实现的<code>object.__new__</code>方法执行。</p><p>OSCON的JSON数据源有一个明显的缺点：索引为40的事件，即名为'There *Will* Be Bugs'的那个，有两位演讲者，3471和5199，但却不容易找到他们，因为提供的是编号，而 Schedule.speakers列表没有使用编号建立索引。此外，每条事件记录中都有venue_serial字段，存储的值也是编号，但是如果想找到对应的记录，那就要线性搜索Schedule.venues列表。接下来的任务是，调整数据结构，以便自动获取所链接的记录。</p><h2 id="使用shelve模块调整oscon数据源的结构">使用shelve模块调整OSCON数据源的结构</h2><p>标准库中有个<a href="https://devdocs.io/python~3.6/library/shelve" target="_blank" rel="noopener">shelve</a>（架子）模块，shelve模块提供了pickle（泡菜，Python对象序列化格式的名字）存储方式。</p><p><a href="https://devdocs.io/python~3.6/library/shelve#shelve.open" target="_blank" rel="noopener">shelve.open</a>高阶函数返回一个shelve.Shelf实例，这是简单的键值对象数据库，背后由<a href="https://devdocs.io/python~3.6/library/dbm" target="_blank" rel="noopener">dbm</a>模块支持，具有下述特点：</p><ul><li>shelve.Shelf是abc.MutableMapping的子类，因此提供了处理映射类型的重要方法。</li><li>此外，shelve.Shelf类还提供了几个管理I/O的方法，如sync和close；它也是一个上下文管理器。</li><li>只要把新值赋予键，就会保存键和值。</li><li>键必须是字符串。</li><li>值必须是pickle模块能处理的对象。</li></ul><p>shelve模块为识别OSCON的日程数据提供了一种简单有效的方式。我们将从JSON文件中读取所有记录，将其存在一个shelve.Shelf对象中，键由记录类型和编号组成（例如，'event.33950'或'speaker.3471'），而值是我们即将定义的Record类的实例。</p><figure class="highlight python"><figcaption><span>schedule1.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> osconfeed</span><br><span class="line"></span><br><span class="line">DB_NAME = <span class="string">'data/schedule1_db'</span></span><br><span class="line">CONFERENCE = <span class="string">'conference.115'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Record</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        self.__dict__.update(kwargs)  <span class="comment"># 更新实例的__dict__属性</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_db</span><span class="params">(db)</span>:</span></span><br><span class="line">    raw_data = osconfeed.load()  <span class="comment"># 加载数据</span></span><br><span class="line">    warnings.warn(<span class="string">'loading '</span> + DB_NAME)</span><br><span class="line">    <span class="keyword">for</span> collection, rec_list <span class="keyword">in</span> raw_data[<span class="string">'Schedule'</span>].items():</span><br><span class="line">        record_type = collection[:<span class="number">-1</span>]  <span class="comment"># 去掉尾部's'后的集合名，例如event</span></span><br><span class="line">        <span class="keyword">for</span> record <span class="keyword">in</span> rec_list:</span><br><span class="line">            key = <span class="string">'&#123;&#125;.&#123;&#125;'</span>.format(record_type, record[<span class="string">'serial'</span>])</span><br><span class="line">            record[<span class="string">'serial'</span>] = key  <span class="comment"># 把serial的值设置为完整的键：type.serial</span></span><br><span class="line">            db[key] = Record(**record)  <span class="comment"># 在数据库中存储Record实例</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ python -i schedule1.py  <span class="comment"># 启动加载了schedule1模块的控制台</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> shelve</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db = shelve.open(DB_NAME)  <span class="comment"># 打开数据库，或者新建一个</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> CONFERENCE <span class="keyword">not</span> <span class="keyword">in</span> db:  <span class="comment"># 判断数据库是否填充</span></span><br><span class="line"><span class="meta">... </span>    load_db(db)  <span class="comment"># 加载数据库</span></span><br><span class="line">...</span><br><span class="line">schedule1.py:<span class="number">14</span>: UserWarning: loading data/schedule1_db</span><br><span class="line">  warnings.warn(<span class="string">'loading '</span> + DB_NAME)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>speaker = db[<span class="string">'speaker.3471'</span>]  <span class="comment"># 一条speaker记录</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(speaker)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Record</span>'&gt;</span></span><br><span class="line">&gt;&gt;&gt; speaker.name, speaker.twitter  # 在某些应用中，Record类可能要处理不能作为属性名使用的键</span><br><span class="line">(<span class="string">'Anna Ravenscroft'</span>, <span class="string">'annaraven'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db.close()  <span class="comment"># 关闭Shelf对象。如果可以，使用with块确保Shelf对象会关闭</span></span><br></pre></td></tr></table></figure><p>FrozenJSON类要递归转换嵌套的映射和列表；而Record类不需要这么做，因为转换好的数据集中没有嵌套的映射和列表，记录中只有字符串、整数、字符串列表和整数列表。FrozenJSON类要访问内嵌的<code>__data</code>（值是字典）属性，而现在我们不需要这么做了（因为<code>self.__dict__.update(kwargs)</code>已经将传入的键值对保存到实例属性中了）。</p><p>Python标准库中至少有两个与Record类似的类，其实例可以有任意个属性，由传给构造方法的关键字参数构建——<a href="https://devdocs.io/python~3.6/library/multiprocessing#multiprocessing.managers.Namespace" target="_blank" rel="noopener">multiprocessing.managers.Namespace</a>类和<a href="https://devdocs.io/python~3.6/library/argparse#argparse.Namespace" target="_blank" rel="noopener">argparse.Namespace</a>类。之所以自己实现Record，是为了说明一个重要的做法：在<code>__init__</code>方法中更新实例的<code>__dict__</code>属性。</p><h2 id="使用特性获取链接的记录">使用特性获取链接的记录</h2><p>我们可以扩展Record类，让它提供一个有用的服务：自动获取event记录引用的venue和speaker记录，而不是编号。</p><img data-src="http://www.plantuml.com/plantuml/svg/TOzH3i8W44J_UugzW3VmKo_W1KWBeoLAmMKrQR1t5ojfBAdxHTumkpEzDI2u82Cvk0xSw5iR8vsWFHjA3UL93j9xCv5ITh2YL4rnpsmgraEtDaTfnUhypNHhtw94o7_niY6U8RgdDDyhh8x42FmJwlZ482LHVZv0AR0FO1c_rXZGNi6nvbihIx_zQxUKRPRM7pfVUmC0"><p>Record：<code>__init__</code>方法不变；为了辅助测试，增加了<code>__eq__</code>方法。</p><p>DbRecord：Record类的子类，添加了<code>__db</code>类属性，用于设置和获取<code>__db</code>属性的set_db和get_db静态方法，用于从数据库中获取记录的fetch类方法，以及辅助调试和测试的<code>__repr__</code>实例方法。</p><p>Event：DbRecord类的子类，添加了用于获取所链接记录的venue和speakers属性，以及特殊的<code>__repr__</code>方法。</p><figure class="highlight python"><figcaption><span>schedule2.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> osconfeed</span><br><span class="line"></span><br><span class="line">DB_NAME = <span class="string">'data/schedule2_db'</span></span><br><span class="line">CONFERENCE = <span class="string">'conference.115'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Record</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        self.__dict__.update(kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(other, Record):</span><br><span class="line">            <span class="keyword">return</span> self.__dict__ == other.__dict__</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MissingDatabaseError</span><span class="params">(RuntimeError)</span>:</span>  <span class="comment"># 自定义的异常通常是标志类</span></span><br><span class="line">    <span class="string">"""需要数据库但没有指定数据库时抛出"""</span>   <span class="comment"># 没有定义体，写一个文档字符串</span></span><br><span class="line">                                        <span class="comment"># 说明异常的用途，比pass语句要好</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DbRecord</span><span class="params">(Record)</span>:</span>  <span class="comment"># 扩展Record类</span></span><br><span class="line"></span><br><span class="line">    __db = <span class="literal">None</span>  <span class="comment"># 存储一个打开的Shelf数据库引用</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod  # 静态方法，以此强调不管调用多少次</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_db</span><span class="params">(db)</span>:</span>  <span class="comment"># 效果始终一样</span></span><br><span class="line">        DbRecord.__db = db</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_db</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> DbRecord.__db</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod  # 类方法，在子类中易于定制它的行为</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(cls, ident)</span>:</span></span><br><span class="line">        db = cls.get_db()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> db[ident]  <span class="comment"># 从数据库中获取</span></span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="keyword">if</span> db <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 数据库为空时，抛出自定义异常</span></span><br><span class="line">                msg = <span class="string">"database not set; call '&#123;&#125;.set_db(my_db)'"</span></span><br><span class="line">                <span class="keyword">raise</span> MissingDatabseError(msg.format(cls.__name__))</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 否则重新抛出TypeError，因为我们不知道怎么处理</span></span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(self, <span class="string">'serial'</span>):</span><br><span class="line">            cls_name = self.__class__.__name__</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'&lt;&#123;&#125; serial=&#123;!r&#125;&gt;'</span>.format(cls_name, self.serial)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 调用继承的方法</span></span><br><span class="line">            <span class="keyword">return</span> super().__repr__()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span><span class="params">(DbRecord)</span>:</span>  <span class="comment"># 扩展DbRecord类</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">venue</span><span class="params">(self)</span>:</span>  <span class="comment"># venue特性</span></span><br><span class="line">        key = <span class="string">'venue.&#123;&#125;'</span>.format(self.venue_serial)</span><br><span class="line">        <span class="keyword">return</span> self.__class__.fetch(key)  <span class="comment"># 不直接使用self.fetch(key)</span></span><br><span class="line">        <span class="comment"># 对这个OSCON数据源来说，可以使用后者，因为事件记录都没有'fetch'键</span></span><br><span class="line">        <span class="comment"># 哪怕只有一个事件记录有名为'fetch'的键，那么在那个Event实例中</span></span><br><span class="line">        <span class="comment"># self.fetch获取的是fetch字段的值，而不是继承自DbRecord的fetch类方法</span></span><br><span class="line">        <span class="comment"># 这个缺陷不明显，很容易被测试忽略</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speakers</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">'_speaker_objs'</span>):</span><br><span class="line">            <span class="comment"># 从__dict__实例属性中获取</span></span><br><span class="line">            <span class="comment"># self.speakers会出现无限递归，因为特性的公开名称也是speakers</span></span><br><span class="line">            spkr_serials = self.__dict__[<span class="string">'speakers'</span>]</span><br><span class="line">            fetch = self.__class__.fetch  <span class="comment"># 获取类方法的引用</span></span><br><span class="line">            self._speaker_objs = [fetch(<span class="string">'speaker.&#123;&#125;'</span>.format(key))</span><br><span class="line">                                  <span class="keyword">for</span> key <span class="keyword">in</span> spkr_serials]</span><br><span class="line">        <span class="keyword">return</span> self._speaker_objs</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(self, <span class="string">'name'</span>):</span><br><span class="line">            cls_name = self.__class__.__name__</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'&lt;&#123;&#125; &#123;!r&#125;&gt;'</span>.format(cls_name, self.name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> super().__repr__()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_db</span><span class="params">(db)</span>:</span></span><br><span class="line">    raw_data = osconfeed.load()</span><br><span class="line">    warnings.warn(<span class="string">'loading '</span> + DB_NAME)</span><br><span class="line">    <span class="keyword">for</span> collection, rec_list <span class="keyword">in</span> raw_data[<span class="string">'Schedule'</span>].items():</span><br><span class="line">        record_type = collection[:<span class="number">-1</span>]</span><br><span class="line">        cls_name = record_type.capitalize()  <span class="comment"># 首字母大写，例如Event</span></span><br><span class="line">        <span class="comment"># 从模块的全局作用域中获取对应的对象，默认使用DbRecord</span></span><br><span class="line">        <span class="comment"># 只有事件类型的记录有自定义的类——Event。不过，如果定义了</span></span><br><span class="line">        <span class="comment"># Speaker或Venue类，load_db函数构建和保存记录时会自动使用这两个类</span></span><br><span class="line">        cls = globals().get(cls_name, DbRecord)</span><br><span class="line">        <span class="keyword">if</span> inspect.isclass(cls) <span class="keyword">and</span> issubclass(cls, DbRecord):</span><br><span class="line">            factory = cls</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            factory = DbRecord</span><br><span class="line">        <span class="keyword">for</span> record <span class="keyword">in</span> rec_list:</span><br><span class="line">            key = <span class="string">'&#123;&#125;.&#123;&#125;'</span>.format(record_type, record[<span class="string">'serial'</span>])</span><br><span class="line">            record[<span class="string">'serial'</span>] = key</span><br><span class="line">            db[key] = factory(**record)</span><br></pre></td></tr></table></figure><p><strong>从数据中创建实例属性的名称时有可能会引入缺陷，因为类属性（例如方法）可能被遮盖，或者由于意外覆盖现有的实例属性而丢失数据。这个问题可能是Python字典不能像JavaScript对象那样（obj.key）访问的原因。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ python -i schedule2.py</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> shelve</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db = shelve.open(DB_NAME)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>load_db(db)</span><br><span class="line">schedule2.py:<span class="number">85</span>: UserWarning: loading data/schedule2_db</span><br><span class="line">  warnings.warn(<span class="string">'loading '</span> + DB_NAME)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db[<span class="string">'event.33950'</span>]  <span class="comment"># 现在获取的是记录对象，而不是编号</span></span><br><span class="line">&lt;Event <span class="string">'There *Will* Be Bugs'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>DbRecord.set_db(db)  <span class="comment"># 将数据库放入类中，方便操作</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>event = DbRecord.fetch(<span class="string">'event.33950'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>event.venue  <span class="comment"># 返回记录</span></span><br><span class="line">&lt;DbRecord serial=<span class="string">'venue.1449'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>event.venue.name  <span class="comment"># 找出venue.name更容易了</span></span><br><span class="line"><span class="string">'Portland 251'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> spkr <span class="keyword">in</span> event.speakers:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'&#123;0.serial&#125;: &#123;0.name&#125;'</span>.format(spkr))</span><br><span class="line">...</span><br><span class="line">speaker<span class="number">.3471</span>: Anna Ravenscroft</span><br><span class="line">speaker<span class="number">.5199</span>: Alex Martelli</span><br></pre></td></tr></table></figure><p>特性经常用于把公开的属性变成使用读值方法和设值方法管理的属性，且在不影响代码的前提下实施业务规则。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> attribute </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>让pyplot支持汉字</title>
      <link href="/programming/support-chinese-character-in-pyplot/"/>
      <url>/programming/support-chinese-character-in-pyplot/</url>
      
        <content type="html"><![CDATA[<p><a href="https://devdocs.io/matplotlib~3.1/font_manager_api#matplotlib.font_manager.FontProperties" target="_blank" rel="noopener"><code>class matplotlib.font_manager.FontProperties(family=None, style=None, variant=None, weight=None, stretch=None, size=None, fname=None)</code></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib.font_manager <span class="keyword">import</span> FontProperties</span><br><span class="line"></span><br><span class="line">font = FontProperties(fname=<span class="string">'/System/Library/Fonts/PingFang.ttc'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># in most functions, key is fontproperties (see valid kwargs in pyplot)</span></span><br><span class="line">plt.text(<span class="number">0</span>, <span class="number">0</span>, <span class="string">'你好！'</span>, fontproperties=font, ha=<span class="string">'center'</span>)</span><br><span class="line">x = np.linspace(-np.pi, np.pi, <span class="number">201</span>)</span><br><span class="line">plt.plot(x, np.sin(x), label=<span class="string">'sin函数'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'x轴'</span>, fontproperties=font)</span><br><span class="line">plt.ylabel(<span class="string">'y轴'</span>, fontproperties=font)</span><br><span class="line"></span><br><span class="line"><span class="comment"># in legend, key is prop</span></span><br><span class="line">plt.legend(prop=font, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><a id="more"></a><p><img data-src="/uploads/posts/support-chinese-character.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pyplot中合法的kwargs关键字</title>
      <link href="/documentation/valid-kwargs-in-pyplot/"/>
      <url>/documentation/valid-kwargs-in-pyplot/</url>
      
        <content type="html"><![CDATA[<p><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text" target="_blank" rel="noopener"><code>class matplotlib.text.Text(x=0, y=0, text='', color=None, verticalalignment='baseline', horizontalalignment='left', multialignment=None, fontproperties=None, rotation=None, linespacing=None, rotation_mode=None, usetex=None, wrap=False, **kwargs)</code></a></p><table><colgroup><col style="width: 28%"><col style="width: 71%"></colgroup><thead><tr class="header"><th style="text-align: left;">Property</th><th style="text-align: left;">Description</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_agg_filter#matplotlib.artist.Artist.set_agg_filter" target="_blank" rel="noopener"><code>agg_filter</code></a></td><td style="text-align: left;">a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_alpha#matplotlib.artist.Artist.set_alpha" target="_blank" rel="noopener"><code>alpha</code></a></td><td style="text-align: left;">float</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_animated#matplotlib.artist.Artist.set_animated" target="_blank" rel="noopener"><code>animated</code></a></td><td style="text-align: left;">bool</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_backgroundcolor" target="_blank" rel="noopener"><code>backgroundcolor</code></a></td><td style="text-align: left;">color</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_bbox" target="_blank" rel="noopener"><code>bbox</code></a></td><td style="text-align: left;">dict with properties for <a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.patches.fancybboxpatch#matplotlib.patches.FancyBboxPatch" target="_blank" rel="noopener"><code>patches.FancyBboxPatch</code></a></td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_clip_box" target="_blank" rel="noopener"><code>clip_box</code></a></td><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/transformations#matplotlib.transforms.Bbox" target="_blank" rel="noopener"><code>Bbox</code></a></td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_clip_on" target="_blank" rel="noopener"><code>clip_on</code></a></td><td style="text-align: left;">bool</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_clip_path" target="_blank" rel="noopener"><code>clip_path</code></a></td><td style="text-align: left;">[(<a href="https://devdocs.io/matplotlib~3.1/path_api#matplotlib.path.Path" target="_blank" rel="noopener"><code>Path</code></a>, <a href="https://devdocs.io/matplotlib~3.1/transformations#matplotlib.transforms.Transform" target="_blank" rel="noopener"><code>Transform</code></a>)</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_color" target="_blank" rel="noopener"><code>color</code></a> or c</td><td style="text-align: left;">color</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_contains#matplotlib.artist.Artist.set_contains" target="_blank" rel="noopener"><code>contains</code></a></td><td style="text-align: left;">callable</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_figure#matplotlib.artist.Artist.set_figure" target="_blank" rel="noopener"><code>figure</code></a></td><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure" target="_blank" rel="noopener"><code>Figure</code></a></td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_fontfamily" target="_blank" rel="noopener"><code>fontfamily</code></a> or family</td><td style="text-align: left;">{FONTNAME, 'serif', 'sans-serif', 'cursive', 'fantasy', 'monospace'}</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_fontproperties" target="_blank" rel="noopener"><code>fontproperties</code></a> or font_properties</td><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/font_manager_api#matplotlib.font_manager.FontProperties" target="_blank" rel="noopener"><code>font_manager.FontProperties</code></a></td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_fontsize" target="_blank" rel="noopener"><code>fontsize</code></a> or size</td><td style="text-align: left;">{size in points, 'xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'}</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_fontstretch" target="_blank" rel="noopener"><code>fontstretch</code></a> or stretch</td><td style="text-align: left;">{a numeric value in range 0-1000, 'ultra-condensed', 'extra-condensed', 'condensed', 'semi-condensed', 'normal', 'semi-expanded', 'expanded', 'extra-expanded', 'ultra-expanded'}</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_fontstyle" target="_blank" rel="noopener"><code>fontstyle</code></a> or style</td><td style="text-align: left;">{'normal', 'italic', 'oblique'}</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_fontvariant" target="_blank" rel="noopener"><code>fontvariant</code></a> or variant</td><td style="text-align: left;">{'normal', 'small-caps'}</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_fontweight" target="_blank" rel="noopener"><code>fontweight</code></a> or weight</td><td style="text-align: left;">{a numeric value in range 0-1000, 'ultralight', 'light', 'normal', 'regular', 'book', 'medium', 'roman', 'semibold', 'demibold', 'demi', 'bold', 'heavy', 'extra bold', 'black'}</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_gid#matplotlib.artist.Artist.set_gid" target="_blank" rel="noopener"><code>gid</code></a></td><td style="text-align: left;">str</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_horizontalalignment" target="_blank" rel="noopener"><code>horizontalalignment</code></a> or ha</td><td style="text-align: left;">{'center', 'right', 'left'}</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_in_layout#matplotlib.artist.Artist.set_in_layout" target="_blank" rel="noopener"><code>in_layout</code></a></td><td style="text-align: left;">bool</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_label#matplotlib.artist.Artist.set_label" target="_blank" rel="noopener"><code>label</code></a></td><td style="text-align: left;">object</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_linespacing" target="_blank" rel="noopener"><code>linespacing</code></a></td><td style="text-align: left;">float (multiple of font size)</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_multialignment" target="_blank" rel="noopener"><code>multialignment</code></a> or ma</td><td style="text-align: left;">{'left', 'right', 'center'}</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_path_effects#matplotlib.artist.Artist.set_path_effects" target="_blank" rel="noopener"><code>path_effects</code></a></td><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/patheffects_api#matplotlib.patheffects.AbstractPathEffect" target="_blank" rel="noopener"><code>AbstractPathEffect</code></a></td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_picker#matplotlib.artist.Artist.set_picker" target="_blank" rel="noopener"><code>picker</code></a></td><td style="text-align: left;">None or bool or float or callable</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_position" target="_blank" rel="noopener"><code>position</code></a></td><td style="text-align: left;">(float, float)</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_rasterized#matplotlib.artist.Artist.set_rasterized" target="_blank" rel="noopener"><code>rasterized</code></a></td><td style="text-align: left;">bool or None</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_rotation" target="_blank" rel="noopener"><code>rotation</code></a></td><td style="text-align: left;">{angle in degrees, 'vertical', 'horizontal'}</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_rotation_mode" target="_blank" rel="noopener"><code>rotation_mode</code></a></td><td style="text-align: left;">{None, 'default', 'anchor'}</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_sketch_params#matplotlib.artist.Artist.set_sketch_params" target="_blank" rel="noopener"><code>sketch_params</code></a></td><td style="text-align: left;">(scale: float, length: float, randomness: float)</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_snap#matplotlib.artist.Artist.set_snap" target="_blank" rel="noopener"><code>snap</code></a></td><td style="text-align: left;">bool or None</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_text" target="_blank" rel="noopener"><code>text</code></a></td><td style="text-align: left;">object</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_transform#matplotlib.artist.Artist.set_transform" target="_blank" rel="noopener"><code>transform</code></a></td><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/transformations#matplotlib.transforms.Transform" target="_blank" rel="noopener"><code>Transform</code></a></td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_url#matplotlib.artist.Artist.set_url" target="_blank" rel="noopener"><code>url</code></a></td><td style="text-align: left;">str</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_usetex" target="_blank" rel="noopener"><code>usetex</code></a></td><td style="text-align: left;">bool or None</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_verticalalignment" target="_blank" rel="noopener"><code>verticalalignment</code></a> or va</td><td style="text-align: left;">{'center', 'top', 'bottom', 'baseline', 'center_baseline'}</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_visible#matplotlib.artist.Artist.set_visible" target="_blank" rel="noopener"><code>visible</code></a></td><td style="text-align: left;">bool</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_wrap" target="_blank" rel="noopener"><code>wrap</code></a></td><td style="text-align: left;">bool</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_x" target="_blank" rel="noopener"><code>x</code></a></td><td style="text-align: left;">float</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/text_api#matplotlib.text.Text.set_y" target="_blank" rel="noopener"><code>y</code></a></td><td style="text-align: left;">float</td></tr><tr class="even"><td style="text-align: left;"><a href="https://devdocs.io/matplotlib~3.1/_as_gen/matplotlib.artist.artist.set_zorder#matplotlib.artist.Artist.set_zorder" target="_blank" rel="noopener"><code>zorder</code></a></td><td style="text-align: left;">float</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用asyncio包处理并发</title>
      <link href="/notes/fluent-python/concurrency-with-asyncio/"/>
      <url>/notes/fluent-python/concurrency-with-asyncio/</url>
      
        <content type="html"><![CDATA[<blockquote><p>并发（concurrency）是指一次处理多件事，关于结构。并行（parallelism）是指一次做多件事，关于执行。并发用于定制方案，用来解决可能（但未必）并行的问题。</p><p>Rob Pike （Go语言的创造者之一）</p></blockquote><p>真正的并行需要多个核心。现代的笔记本电脑有4个CPU核心，但是通常不经意间就有超过100个进程同时运行。因此，实际上大多数过程都是并发处理的，而不是并行处理。计算机始终运行着100多个进程，确保每个进程都有机会取得进展，不过CPU本身同时做的事情不能超过四件。</p><p>asyncio包使用事件循环驱动的协程实现并发。<em>Guido van Rossum在Python仓库之外开发asyncio包，把这个项目的代号命名为Tulip（郁金香）。Python3.4把Tulip添加到标准库中时，把它重命名为asyncio。</em></p><h1 id="线程与协程对比">线程与协程对比</h1><p>在控制台中显示一个由ASCII字符&quot;|/-&quot;构成的动画旋转指针。一个借由threading模块使用线程实现，一个借由asyncio包使用协程实现。对比两种实现，理解如何不使用线程来实现并发行为。</p><a id="more"></a><h2 id="线程实现">线程实现</h2><p>使用threading模块使用线程实现。</p><figure class="highlight python"><figcaption><span>spinner_thread.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Signal</span>:</span>  <span class="comment"># 定义一个简单的可变对象，用于从外部控制线程</span></span><br><span class="line">    go = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spin</span><span class="params">(msg, signal)</span>:</span>  <span class="comment"># 这个函数会在单独的线程中运行</span></span><br><span class="line">    write, flush = sys.stdout.write, sys.stdout.flush</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> itertools.cycle(<span class="string">'|/-\\'</span>):  <span class="comment"># 无限循环</span></span><br><span class="line">        status = char + <span class="string">' '</span> + msg</span><br><span class="line">        write(status)</span><br><span class="line">        flush()</span><br><span class="line">        write(<span class="string">'\x08'</span> * len(status))  <span class="comment"># 动画的诀窍所在，使用退格符（\x08）把光标移回来</span></span><br><span class="line">        time.sleep(<span class="number">.1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> signal.go:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        write(<span class="string">' '</span> * len(status) + <span class="string">'\x08'</span> * len(status))  <span class="comment"># 使用空格清除状态消息，把光标移回开头</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">slow_function</span><span class="params">()</span>:</span>  <span class="comment"># 假设这是耗时的计算</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)  <span class="comment"># sleep函数会阻塞主线程，不过一定要这么做，以便释放GIL（全局解释器锁）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">supervisor</span><span class="params">()</span>:</span>  <span class="comment"># 这个函数设置从属线程，显示线程对象，运行耗时的计算，最后杀死线程</span></span><br><span class="line">    signal = Signal()</span><br><span class="line">    spinner = threading.Thread(target=spin, args=(<span class="string">'thinking!'</span>, signal))</span><br><span class="line">    print(<span class="string">'spinner object:'</span>, spinner)</span><br><span class="line">    spinner.start()  <span class="comment"># 启动从属线程</span></span><br><span class="line">    result = slow_function()  <span class="comment"># 运行slow_function函数，阻塞主线程。同时，从属线程以动画形式显示旋转指针</span></span><br><span class="line">    signal.go = <span class="literal">False</span>  <span class="comment"># 改变状态，spin函数会终止循环</span></span><br><span class="line">    spinner.join()  <span class="comment"># 等待spinner线程结束</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    result = supervisor()</span><br><span class="line">    print(<span class="string">'Answer:'</span>, result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python spinner_thread.py  # 运行查看动画</span><br><span class="line">spinner object: &lt;Thread(Thread-1, initial)&gt;</span><br><span class="line">Answer: 42!</span><br></pre></td></tr></table></figure><p><strong>Python没有提供终止线程的API，这是有意为之的。若想关闭线程，必须给线程发送消息。</strong>这里，使用的是signal.go属性：在主线程中把它设为False后，spinner线程最终会注意到，然后干净地退出。</p><h2 id="协程实现">协程实现</h2><p>使用@asyncio.coroutine装饰器替代线程，实现相同的行为。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine  # 打算交给asyncio处理的协程建议使用@asyncio.coroutine装饰</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spin</span><span class="params">(msg)</span>:</span>  <span class="comment"># 这里不需要signal参数</span></span><br><span class="line">    write, flush = sys.stdout.write, sys.stdout.flush</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> itertools.cycle(<span class="string">'|/-\\'</span>):</span><br><span class="line">        status = char + <span class="string">' '</span> + msg</span><br><span class="line">        write(status)</span><br><span class="line">        flush()</span><br><span class="line">        write(<span class="string">'\x08'</span> * len(status))</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">.1</span>)  <span class="comment"># 代替time.sleep(.1)，这样的休眠不会阻塞事件循环</span></span><br><span class="line">        <span class="keyword">except</span> asyncio.CancelledError:  <span class="comment"># 若发出了取消请求，会在yield处抛出CancelledError异常</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        write(<span class="string">' '</span> * len(status) + <span class="string">'\x08'</span> * len(status))</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">slow_function</span><span class="params">()</span>:</span>  <span class="comment"># 协程，在用休眠假装进行I/O操作时，使用yield from继续执行事件循环</span></span><br><span class="line">    <span class="comment"># 假装等待I/O一段时间</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">3</span>)  <span class="comment"># 把控制权交给主循环，在休眠结束后恢复这个协程</span></span><br><span class="line">                                 <span class="comment"># 若使用time.sleep(3)，则控制权回不到主循环，</span></span><br><span class="line">                                 <span class="comment"># spinner无法得到运行时间，也就看不到旋转动画和提示消息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">supervisor</span><span class="params">()</span>:</span>  <span class="comment"># 协程，使用yield from驱动slow_function函数</span></span><br><span class="line">    spinner = asyncio.<span class="keyword">async</span>(spin(<span class="string">'thinking!'</span>))  <span class="comment"># async函数排定协程的运行时间，使用一个Task对象包装协程</span></span><br><span class="line">    print(<span class="string">'spinner object:'</span>, spinner)</span><br><span class="line">    result = <span class="keyword">yield</span> <span class="keyword">from</span> slow_function()  <span class="comment"># 驱动slow_function函数。结束后，获取返回值。同时，事件循环继续运行</span></span><br><span class="line">                                         <span class="comment"># 因为slow_function函数最后使用yield from表达式把控制权交回给了主循环</span></span><br><span class="line">                                         <span class="comment"># 若使用result = slow_function()，则同样看不到动画和提示消息</span></span><br><span class="line">    spinner.cancel()  <span class="comment"># Task对象可以取消，取消后会在协程当前暂停的yield处抛出CancelledError异常</span></span><br><span class="line">                      <span class="comment"># 协程可以捕获这个异常，也可以延迟取消，甚至拒绝取消</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    loop = asyncio.get_event_loop()  <span class="comment"># 获取事件循环的引用</span></span><br><span class="line">    result = loop.run_until_complete(supervisor())  <span class="comment"># 驱动supervisor协程， 让它运行完毕</span></span><br><span class="line">    loop.close()</span><br><span class="line">    print(<span class="string">'Answer:'</span>, result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python spinner_asyncio.py  # 运行查看动画</span><br><span class="line">spinner object: &lt;Task pending coro=&lt;spin() running at spinner_asyncio.py:5&gt;&gt;</span><br><span class="line">Answer: 42!</span><br></pre></td></tr></table></figure><p><strong>除非想阻塞主线程，从而冻结事件循环或整个应用，否则不要在asyncio协程中使用time.sleep函数。如果协程需要在一段时间内什么也不做，应该使用yield from asyncio.sleep(DELAY)。</strong></p><p>使用@asyncio.coroutine装饰器不是强制要求，但是强烈建议这么做，因为这样能在一众普通的函数中把协程凸显出来，也有助于调试：如果还没从中产出值，协程就被垃圾回收了（意味着有操作未完成，因此有可能是个缺陷），那就可以发出警告。这个装饰器不会预激协程。</p><p>supervisor函数是这两个示例的核心。下面详细对比二者。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 线程版</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">supervisor</span><span class="params">()</span>:</span></span><br><span class="line">    signal = Signal()</span><br><span class="line">    spinner = threading.Thread(target=spin, args=(<span class="string">'thinking!'</span>, signal))</span><br><span class="line">    print(<span class="string">'spinner object:'</span>, spinner)</span><br><span class="line">    spinner.start()</span><br><span class="line">    result = slow_function()</span><br><span class="line">    signal.go = <span class="literal">False</span></span><br><span class="line">    spinner.join()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 异步版</span></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">supervisor</span><span class="params">()</span>:</span></span><br><span class="line">    spinner = asyncio.<span class="keyword">async</span>(spin(<span class="string">'thinking!'</span>))</span><br><span class="line">    print(<span class="string">'spinner object:'</span>, spinner)</span><br><span class="line">    result = <span class="keyword">yield</span> <span class="keyword">from</span> slow_function()</span><br><span class="line">    spinner.cancel()</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>这两种实现之间的主要区别概述如下：</p><ul><li>asyncio.Task对象差不多与threadig.Thread对象等效。Task对象像是实现协作式多任务的库（如gevent）中的绿色线程（green thread）。</li><li>Task对象用于驱动协程，Thread对象用于调用可调用的对象。</li><li>Task对象不由自己动手实例化，而是通过把协程传给asyncio.async函数或loop.create_task方法获取。</li><li>获取的Task对象已经排定了运行时间（例如，由asyncio.async函数排定）；Thread实例必须调用start方法，明确告知让它运行。</li><li>在线程版supervisor函数中，slow_function函数是普通的函数，直接由线程调用。在异步版supervisor函数中，slow_function函数是协程，由yield from驱动。</li><li>没有API能从外部终止线程，因为线程随时可能被中断，导致系统处于无效状态。如果想终止任务，可以使用Task.cancel实例方法，在协程内部抛出CancelledError异常。协程可以在暂停的yield处捕获这个异常，处理终止请求。</li><li>supervisor协程必须在main函数中由loop.run_until_complete方法执行。</li></ul><p>如果使用线程做过重要的编程，你就直到写出程序有多么困难，因为调度程序任何时候都能中断线程。必须记住保留锁，去保护程序中的重要部分，防止多步操作在执行的过程中中断，防止数据处于无效状态。</p><p>而协程默认会做好全方位保护，以防止中断。我们必须显示产出才能让程序的余下部分运行。对协程来说，无需保留锁，在多个线程之间同步操作，协程自身就会同步，因为在任意时刻只有一个协程运行。想交出控制权时，可以使用yield或yield from把控制权交还调度程序。这就是能够安全地取消协程的原因：按照定义，协程只能在暂停的yield处取消，因此可以处理CancelledError异常，执行清理操作。</p><p>下面说明asyncio.Future类与concurrent.futures.Future类之间的区别。</p><h2 id="asyncio.future故意不阻塞">asyncio.Future：故意不阻塞</h2><p><strong>asyncio.Future类与concurrent.futures.Future类的接口基本一致，不过实现方式不同，不可以互换。</strong></p><p>期物只是调度执行某物的结果。在asyncio包中，BaseEventLoop.create_task方法接收一个协程，排定它的运行时间，然后返回一个asyncio.Task实例——也是asyncio.Future类的实例，因为Task是Future的子类，用于包装协程。这与调用Executor.submit方法创建concurrent.futures.Future实例是一个道理。</p><p>与concurrent.futures.Future类似，asyncio.Future类也提供了done、add_done_callback和result等方法。前两个方法的用法类似，不过result方法差别很大。</p><p>asyncio.Future.result方法没有参数，因此不能指定超时时间。此外，如果调用result方法时期物还没运行完毕，那么result方法不会阻塞去等待结果，而是抛出asyncio.InvalidStatueError异常。</p><p>然而，获取asyncio.Future对象的结果通常使用yield from，从中产出结果。</p><p>使用yield from处理期物，等待期物运行完毕这一步无需我们关心，而且不会阻塞事件循环，因为在asyncio包中，yield from的作用是把控制权还给事件循环。</p><p>注意，使用yield from处理期物，与使用add_done_callback方法处理协程的作用一样：延迟的操作结束后，事件循环不会出发回调对象，而是设置期物的返回值；而yield from表达式则在暂停的协程中生成返回值，恢复执行协程。</p><p><strong>总之，因为asyncio.Future类的目的是与yield from一起使用，所以通常不需要使用以下方法。</strong></p><ul><li><p>无需调用my_future.add_done_callback，因为可以直接把想在期物运行结束后执行的操作放在协程中yield from my_future表达式的后面。这是协程的一大优势：协程是可以暂停和恢复的函数。</p></li><li><p>无需调用my_future.result，因为yield from从期物中产出的值就是结果（例如，result = yield from my_future）。</p></li></ul><p>当然，有时也需要使用done、add_done_callback和result方法。但一般情况下，asyncio.Future对象由yield from驱动，而不是靠调用这些方法驱动。</p><p>下面分析yield from和asyncio包的API如何拉近期物、任务和协程的关系。</p><h2 id="从期物任务和协程中产出">从期物、任务和协程中产出</h2><p>在asyncio包中，期物和协程的关系紧密，因为可以使用yield from从asyncio.Future对象中产出结果。这意味着，如果foo是协程函数（调用后返回协程对象），抑或是返回Future或Task实例的普通函数，那么可以这样写：res = yield from foo()。这是asyncio包的API中很多地方可以互换协程与期物的原因之一。</p><h1 id="从回调到期物到协程">从回调到期物到协程</h1><p>使用协程做面向事件编程，需要下一番功夫才能掌握，因此最好知道，与经典的回调式编程相比，协程有哪些改进。</p><p>“回调地狱”：如果一个操作需要依赖之前操作的结果，那就得嵌套回调。如果要连续做3次异步调用，那就需要嵌套3层回调。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript中的回调地狱：嵌套匿名函数，也称为灾难金字塔</span></span><br><span class="line">api_call1(request1, <span class="function"><span class="keyword">function</span> (<span class="params">response1</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第一步</span></span><br><span class="line">    <span class="keyword">var</span> request2 = step1(response1);  <span class="comment">// 处理回调收到的响应</span></span><br><span class="line">    aip_call2(requset2, <span class="function"><span class="keyword">function</span> (<span class="params">response2</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 第二步</span></span><br><span class="line">        ver request3 = step2(response2);</span><br><span class="line">        api_call3(request3, <span class="function"><span class="keyword">function</span> (<span class="params">response3</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 第三步</span></span><br><span class="line">            step(response3)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python中的回调地狱：链式回调</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stage1</span><span class="params">(response1)</span>:</span></span><br><span class="line">    request2 = step1(response1)</span><br><span class="line">    api_call2(request2, stage2)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stage2</span><span class="params">(response2)</span>:</span></span><br><span class="line">    request3 = step2(response2)</span><br><span class="line">    api_call3(request3, stage3)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stage3</span><span class="params">(response3)</span>:</span></span><br><span class="line">    step3(response3)</span><br><span class="line"></span><br><span class="line">api_call(request1, stage1)</span><br></pre></td></tr></table></figure><p>虽然代码的排布方式差异很大，但是作用却完全相同。JavaScript示例也能改写成链式风格，但是Python代码不能改写成嵌套风格，因为lambda表达式句法上有限制。</p><p>上述组织代码的方式导致代码难以阅读，也更难编写：每个函数做一部分工作，设置下一个回调，然后返回，让事件循环继续运行。这样，所有本地的上下文都会丢失。执行下一个回调时（例如stage2），就无法获取request2的值。如果需要那个值，那就必须依靠闭包，或者把它存储在外部数据结构中，以便在处理过程的不同阶段使用。</p><p>在这个问题上，协程能发挥很大的作用。在协程汇总，如果要连续执行3个异步操作，只需使用yield 3次，让事件循环继续运行。准备好结果后，调用send方法，激活协程。对事件循环来说，这种做法与调用回调类似。但是对使用协程式异步API的用户来说，情况就大为不同了：3次操作都在同一个函数定义体中，像是顺序代码，能在处理过程中使用局部变量保留整个任务的上下文。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">three_stages</span><span class="params">(request1)</span>:</span></span><br><span class="line">    response1 = <span class="keyword">yield</span> <span class="keyword">from</span> api_call1(request1)</span><br><span class="line">    <span class="comment"># 第一步</span></span><br><span class="line">    request2 = step1(response1)</span><br><span class="line">    response2 = <span class="keyword">yield</span> <span class="keyword">from</span> api_call2(request2)</span><br><span class="line">    <span class="comment"># 第二步</span></span><br><span class="line">    request3 = step2(response2)</span><br><span class="line">    response3 = <span class="keyword">yield</span> <span class="keyword">from</span> api_call3(request3)</span><br><span class="line">    <span class="comment"># 第三步</span></span><br><span class="line">    step3(response3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># three_stages(request1)  # 不能直接调用</span></span><br><span class="line">loop.create_task(three_stages(request1))  <span class="comment"># 必须显示调度执行</span></span><br></pre></td></tr></table></figure><p>与前一个示例相比，使用协程容易理解多了：操作的3个步骤依次写在同一个函数中。这样，后续处理便于使用前一步的结果；而且提供了上下文，能通过异常来报告错误。</p><p>假设在上一个示例中处理api_call2(request2, stage2)调用（stage1函数最后一行）时抛出了I/O异常，这个异常无法在stage1函数中捕获，因为api_call2是异步调用，在还未执行任何I/O操作时就会立即返回。在基于回调的API中，这个问题的解决方法是为每个异步调用注册两个回调，一个用于处理操作成功时的结果，另一个用于处理错误。一旦涉及错误处理，回调地狱的危害程度就会迅速增大。</p><p>与此相比，使用协程时三步操作的所有异步调用都在同一个函数中（three_stages），如果异步调用api_call1、api_call2和api_call3会抛出异常，那么可以把相应的yield from表达式放在try/except块中处理异常。这么做比陷入回调地狱好多了，但是我不会把这种方式称为协程天堂，毕竟我们还要付出代价。我们不能使用常规的函数，必须使用协程，而且要习惯yield from——这是第一个障碍。只要函数中有yield from，函数就会变成协程，而协程不能直接调用。我们必须使用事件循环显示排定协程的执行时间，或者在其他排定了执行时间的协程中使用yield from表达式把它激活。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> concurrency </tag>
            
            <tag> asyncio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习引言</title>
      <link href="/notes/introduction-to-machine-learning-with-python/introduction-to-machine-learning/"/>
      <url>/notes/introduction-to-machine-learning-with-python/introduction-to-machine-learning/</url>
      
        <content type="html"><![CDATA[<p>机器学习（machine learning）是从数据中提取知识。它是统计学、人工智能和计算机科学交叉的研究领域，也被称为预测分析（predictive analytics）或统计学习（statistical learning）。</p><h1 id="为何选择机器学习">为何选择机器学习</h1><p>在“智能”应用的早期，许多系统使用人为制订的“if”和“else”决策规则来处理数据，或根据用户输入的内容进行调整。想象有一个垃圾邮件过滤器，其任务是酌情将收到的某些邮件移动到垃圾邮件文件夹。你可以创建一个关键词黑名单，所有包含这些关键词的邮件都会被标记为垃圾邮件。这是用专家设计的规则体系来设计“智能”应用的一个示例。人为制订的决策规则对某些应用来说是可行的，特别是人们对其模型处理过程非常熟悉的应用。但是，人为制订决策规则主要有两个缺点。</p><ul><li>做决策所需要的逻辑只适用于单一领域和单项任务。任务哪怕稍有变化，都可能需要重写整个系统。</li><li>想要制订规则，需要对人类专家的决策过程有很深刻的理解。</li></ul><p>这种人为制订规则的方法并不适用的一个例子就是图像中的人脸检测。如今，每台智能手机都能够检测到图像中的人脸。但直到2001年，人脸检测问题才得到解决。其主要问题在于，计算机“感知”像素（像素组成了计算机中的图像）的方式与人类感知面部的方式有非常大的不同。正是由于这种表征差异，人类想要制订出一套好的规则来描述数字图像中的人脸构成，基本上是不可能的。</p><p>但有了机器学习算法，仅向程序输入海量人脸图像，就足以让算法确定识别人脸需要哪些特征。</p><a id="more"></a><h1 id="机器学习能够解决的问题">机器学习能够解决的问题</h1><p>从输入/输出对中进行学习的机器学习算法叫作监督学习算法（supervised learning algorithm），因为每个用于算法学习的样例都对应一个预期输出，好像有一个“老师”在监督着算法。虽然创建一个包含输入和输出的数据集往往费时又费力，但监督学习算法很好理解，其性能也易于测量。如果你的应用可以表示成一个监督学习问题，并且你能够创建包含预期输出的数据集，那么机器学习很可能可以解决你的问题。</p><p>监督机器学习任务的示例如下。</p><ul><li>识别信封上手写的邮政编码</li><li>基于医学影像判断肿瘤是否为良性</li><li>检测信用卡交易中的诈骗行</li></ul><p>另一类算法是无监督学习算法（unsupervised learning algorithm）。在无监督学习中，只有输入数据是已知的，没有为算法提供输出数据。虽然这种算法有许多成功的应用，但理解和评估这些算法往往更加困难。</p><p>无监督学习的示例如下。</p><ul><li>确定一系列博客文章的主题</li><li>将客户分成具有相似偏好的群组</li><li>检测网站的异常访问模式</li></ul><p>无论是监督学习任务还是无监督学习任务，将输入数据表征为计算机可以理解的形式都是十分重要的。通常来说，将数据想象成表格是很有用的。你想要处理的每一个数据点（每一封电子邮件、每一名客户、每一次交易）对应表格中的一行，描述该数据点的每一项属性（比如客户年龄、交易金额或交易地点）对应表格中的一列。</p><p>在机器学习中，这里的每个实体或每一行被称为一个样本（sample）或数据点，而每一列（用来描述这些实体的属性）则被称为特征（feature）。</p><h1 id="第一个应用鸢尾花分类">第一个应用：鸢尾花分类</h1><p>假设有一名植物学爱好者对她发现的鸢尾花的品种很感兴趣。她收集了每朵鸢尾花的一些测量数据：花瓣的长度和宽度以及花萼的长度和宽度，所有测量结果的单位都是厘米。</p><p>她还有一些鸢尾花的测量数据，这些花之前已经被植物学专家鉴定为属于setosa、versicolor或virginica三个品种之一。对于这些测量数据，她可以确定每朵鸢尾花所属的品种。我们假设这位植物学爱好者在野外只会遇到这三种鸢尾花。</p><p>我们的目标是构建一个机器学习模型，可以从这些已知品种的鸢尾花测量数据中进行学习，从而能够预测新鸢尾花的品种。</p><p>因为我们有已知品种的鸢尾花的测量数据，所以这是一个监督学习问题。在这个问题中，我们要在多个选项中预测其中一个（鸢尾花的品种）。这是一个分类（classification）问题的示例。可能的输出（鸢尾花的不同品种）叫作类别（class）。数据集中的每朵鸢尾花都属于三个类别之一，所以这是一个三分类问题。</p><p>单个数据点（一朵鸢尾花）的预期输出是这朵花的品种。对于一个数据点来说，它的品种叫作标签（label）。</p><h2 id="初识数据">初识数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iris_dataset = load_iris()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iris_dataset.keys()</span><br><span class="line">dict_keys([<span class="string">'data'</span>, <span class="string">'target'</span>, <span class="string">'target_names'</span>, <span class="string">'DESCR'</span>, <span class="string">'feature_names'</span>, <span class="string">'filename'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iris_dataset.target_names  <span class="comment"># 两种访问访问，属性或键</span></span><br><span class="line">array([<span class="string">'setosa'</span>, <span class="string">'versicolor'</span>, <span class="string">'virginica'</span>], dtype=<span class="string">'&lt;U10'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iris_dataset[<span class="string">'feature_names'</span>]</span><br><span class="line">[<span class="string">'sepal length (cm)'</span>, <span class="string">'sepal width (cm)'</span>, <span class="string">'petal length (cm)'</span>, <span class="string">'petal width (cm)'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iris_dataset.data.shape</span><br><span class="line">(<span class="number">150</span>, <span class="number">4</span>)  <span class="comment"># 鸢尾花有150行数据，每行数据有4个特征</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iris_dataset.target.shape</span><br><span class="line">(<span class="number">150</span>,)  <span class="comment"># 150行数据所属的类</span></span><br></pre></td></tr></table></figure><h2 id="衡量模型是否成功训练数据与测试数据">衡量模型是否成功：训练数据与测试数据</h2><p>我们不能将用于构建模型的数据（训练数据）用于评估模型。因为模型会一直记住整个训练集，所以对于训练集中的任何数据点总会预测正确的标签。这种“记忆”无法告诉我们模型的泛化（generalize）能力如何。</p><p>我们要用新数据来评估模型的性能。通常的做法是将收集好的带标签数据分成两部分。一部分数据用于构建机器学习模型，叫做训练数据（training data）或训练集（training set）。其余的数据用来评估模型性能，叫做测试数据（test data）、测试集（test set）或留出集（hold-out set）。</p><p>scikit-learn中的train_test_split函数可以打乱数据集并进行划分。这个函数默认将75%的行数据及对应标签作为训练集，剩下25%的数据及其标签作为测试集。训练集与测试集的分配比例可以是随意的，但使用25%的数据作为测试集是很好的经验法则。</p><blockquote><p><a href="https://devdocs.io/scikit_learn/modules/generated/sklearn.model_selection.train_test_split#sklearn.model_selection.train_test_split" target="_blank" rel="noopener">sklearn.model_selection.train_test_split(*arrays, **options)</a></p><p>Split arrays or matrices into random train and test subsets.</p></blockquote><p>scikit-learn中的数据通常用大写的X表示，而标签用小写的y表示。这是受到了数学标准公式f(x)=y的启发，其中x是函数的输入，y是输出。我们用大写的X是因为数据是一个二维数组（矩阵），用小写的y是因为目标是一个一维数组（向量），这也是数学中的约定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line"><span class="meta">... </span>    iris_dataset.data, iris_dataset.target, random_state=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>在对数据进行拆分之前，train_test_split函数利用伪随机数生成器将数据集打乱。如果只是将最后25%的数据作为测试集，那么所有数据点的标签都是2，因为数据点是按标签排序的。测试集中只有三个类别之一，这无法告诉我们模型的泛化能力如何，所以将数据打乱，确保测试集中包含所有类别的数据。</p><p>为了确保多次运行同一函数能够得到相同的输出，利用random_state参数指定了随机数生成器种子。这样函数输出就是固定不变的，所以这行代码的输出始终相同。</p><p>train_test_split函数的输出为X_train、X_test、y_train和y_test，它们都是NumPy数组。X_train包含75%的行数据，X_test包含剩下的 25%:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_train.shape, y_train.shape</span><br><span class="line">((<span class="number">112</span>, <span class="number">4</span>), (<span class="number">112</span>,))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_test.shape, y_test.shape</span><br><span class="line">((<span class="number">38</span>, <span class="number">4</span>), (<span class="number">38</span>,))</span><br></pre></td></tr></table></figure><h2 id="要事第一观察数据">要事第一：观察数据</h2><p>在构建机器学习模型之前，通常最好检查一下数据，看看如果不用机器学习能不能轻松完成任务，或者需要的信息有没有包含在数据中。</p><p>此外，检查数据也是发现异常值和特殊值的好方法。举个例子，可能有些鸢尾花的测量单位是英寸而不是厘米。在现实世界中，经常会遇到不一致的数据和意料之外的测量数据。</p><p>检查数据的最佳方法之一就是将其可视化。一种可视化方法是绘制散点图（scatter plot）。数据散点图将一个特征作为x轴，另一个特征作为y轴，将每一个数据点绘制为图上的一个点。不幸的是，计算机屏幕只有两个维度，所以我们一次只能绘制两个特征（也可能是3个）。用这种方法难以对多于3个特征的数据集作图。解决这个问题的一种方法是绘制散点图矩阵（pair plot），从而可以两两查看所有的特征。如果特征数不多的话，这种方法是合理的。但是你应该记住，散点图矩阵无法同时显示所有特征之间的关系，所以这种可视化方法可能无法展示数据的某些有趣内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> mglearn</span><br><span class="line"><span class="comment"># 利用X_train中的数据创建DataFrame</span></span><br><span class="line"><span class="comment"># 利用iris_dataset.feature_names中的字符串对数据列进行标记</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iris_dataframe = pd.DataFrame(X_train, columns=iris_dataset.feature_names)</span><br><span class="line"><span class="comment"># 利用DataFrame创建散点图矩阵，按y_train着色</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grr = pd.scatter_matrix(iris_dataframe, c=y_train, figsize=(<span class="number">15</span>, <span class="number">15</span>), marker=<span class="string">'o'</span>,</span><br><span class="line"><span class="meta">... </span>    hist_kwds=&#123;<span class="string">'bins'</span>: <span class="number">20</span>&#125;, s=<span class="number">60</span>, alpha=<span class="number">.8</span>, cmap=mglearn.cm3)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.show()</span><br></pre></td></tr></table></figure><p><img data-src="/uploads/posts/introduction-to-machine-learning-with-python/iris-dataframe.png"></p><p>从图中可以看出，利用花瓣和花萼的测量数据基本可以将三个类别区分开。这说明机器学习模型很可能可以学会区分它们。</p><h2 id="构建第一个模型k近邻算法">构建第一个模型：k近邻算法</h2><p>构建此模型只需要保存训练集即可。要对一个新的数据点作出预测，算法会在训练集中寻找与这个新数据点距离最近的数据点，然后将找到的数据点的标签赋予这个新数据点。</p><p>k的含义是，我们可以考虑训练集中与新数据点最近的任意k个邻居，而不是只考虑最近的那一个。然后，我们可以用这些邻居中数量最多的类别做出预测。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>knn = KNeighborsClassifier(n_neighbors=<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>knn.fit(X_train, y_train)  <span class="comment"># 基于训练集构建模型，fit方法返回knn对象本身并做原处修改</span></span><br><span class="line">KNeighborsClassifier(algorithm=<span class="string">'auto'</span>, leaf_size=<span class="number">30</span>, metric=<span class="string">'minkowski'</span>,</span><br><span class="line">                     metric_params=<span class="literal">None</span>, n_jobs=<span class="literal">None</span>, n_neighbors=<span class="number">1</span>, p=<span class="number">2</span>,</span><br><span class="line">                     weights=<span class="string">'uniform'</span>)</span><br></pre></td></tr></table></figure><h2 id="做出预测">做出预测</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_new = np.array([[<span class="number">5</span>, <span class="number">2.9</span>, <span class="number">1</span>, <span class="number">.2</span>]])  <span class="comment"># 将测量的数据放入二维数组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_new.shape</span><br><span class="line">(<span class="number">1</span>, <span class="number">4</span>)  <span class="comment"># 我们有1行数据，每行数据有4个特征</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>prediction = knn.predict(X_new)  <span class="comment"># predict的参数必须是二维数组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>prediction</span><br><span class="line">array([<span class="number">0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iris_dataset.target_names[<span class="number">0</span>]</span><br><span class="line"><span class="string">'setosa'</span>  <span class="comment"># 这朵花属于setosa品种</span></span><br></pre></td></tr></table></figure><h2 id="评估模型">评估模型</h2><p>这里需要用到之前创建的测试集。这些数据没有用于构建模型，但我们直到测试集中每朵鸢尾花的实际品种。</p><p>因此，我们可以对测试数据中的每朵鸢尾花进行预测，并将预测结果与标签进行对比。我们可以通过计算精确度（accuracy）来衡量模型的优劣，精度就是品种预测正确的花所占的比例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>y_pred = knn.predict(X_test)  <span class="comment"># 先预测</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y_pred</span><br><span class="line">array([<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>,</span><br><span class="line">       <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.mean(y_pred == y_test)  <span class="comment"># 再通过np.mean函数计算精度</span></span><br><span class="line"><span class="number">0.9736842105263158</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>knn.score(X_test, y_test)  <span class="comment"># 或者通过score方法计算精度</span></span><br><span class="line"><span class="number">0.9736842105263158</span></span><br></pre></td></tr></table></figure><p>对于这个模型来说，测试集的精度约为0.97，也就是说，对于测试集中的鸢尾花，我们的预测有97%是正确的。这让我们有信心将模型应用于新数据，并相信模型在约97%的情况下都是正确的。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction to Machine Learning with Python </tag>
            
            <tag> kmeans </tag>
            
            <tag> classification </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用futures处理并发</title>
      <link href="/notes/fluent-python/concurrency-with-futures/"/>
      <url>/notes/fluent-python/concurrency-with-futures/</url>
      
        <content type="html"><![CDATA[<p>本章讨论Python3.2引入的concurrent.futures模块。“期物”（future）是译者自创的词。期物指一种对象，表示异步执行的操作。</p><h1 id="示例网络下载的三种风格">示例：网络下载的三种风格</h1><p>为了高效处理网络I/O，需要使用并发，因为网络有很高的延迟，所以为了不浪费CPU周期去等待，最好在收到网络相应之前做些其他的事。本章有3个示例程序，从网上下载20个国家的国旗图像。第一个示例程序是依序下载的：下载完一个图像，并将其保存在硬盘中之后，才请求下一个图像。另外两个脚本是并发下载（分别使用concurrent.futres模块和asyncio包）的：几乎同时请求所有图像，每下载完一个文件就保存一个文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ python flags.py</span><br><span class="line">BD BR CD CN DE EG ET FR ID IN IR JP MX NG PH PK RU TR US VN</span><br><span class="line">20 flags downloaded in 3.41s</span><br><span class="line">$ python flags_threadpool.py</span><br><span class="line">IN ID CN EG TR NG JP FR DE PK VN RU ET MX PH US IR CD BR BD</span><br><span class="line">20 flags downloaded in 0.20s</span><br><span class="line">$ python flags_asyncio.py</span><br><span class="line">JP CN PK PH EG FR TR BD IN ET RU BR DE ID US NG MX IR CD VN</span><br><span class="line">20 flags downloaded in 0.26s</span><br></pre></td></tr></table></figure><p>两个并发下载的脚本之间性能差异不大，不过都比依序下载的脚本快5倍多（原书是5倍多，我的结果相差更大）。这只是一个特别小的任务，如果把下载的文件数量增加到几百个，并发下载的脚本能比依序下载的脚本快20倍或更多。将这三个脚本一起演示是为了表明一个观点：<strong>在I/O密集型应用中，如果代码写的正确，那么不管使用哪种并发策略（使用线程或asyncio包），吞吐量都比依序执行的代码高得多。</strong></p><a id="more"></a><h2 id="依序下载的脚本">依序下载的脚本</h2><figure class="highlight python"><figcaption><span>flags.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests  <span class="comment"># 导入requests库，这个库不在标准库中</span></span><br><span class="line"></span><br><span class="line">POP20_CC = (<span class="string">'CN IN US ID BR PK NG BD RU JP '</span></span><br><span class="line">            <span class="string">'MX PH VN ET EG DE IR TR CD FR'</span>).split()</span><br><span class="line"></span><br><span class="line">BASE_URL = <span class="string">'http://flupy.org/data/flags'</span></span><br><span class="line"></span><br><span class="line">DEST_DIR = <span class="string">'downloads/'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_flag</span><span class="params">(img, filename)</span>:</span></span><br><span class="line">    path = os.path.join(DEST_DIR, filename)</span><br><span class="line">    <span class="keyword">with</span> open(path, <span class="string">'wb'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(img)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flag</span><span class="params">(cc)</span>:</span></span><br><span class="line">    url = <span class="string">'&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif'</span>.format(BASE_URL, cc=cc.lower())</span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    <span class="keyword">return</span> resp.content</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(text)</span>:</span></span><br><span class="line">    print(text, end=<span class="string">' '</span>)</span><br><span class="line">    sys.stdout.flush()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> cc <span class="keyword">in</span> sorted(cc_list):  <span class="comment"># 按序下载</span></span><br><span class="line">        image = get_flag(cc)</span><br><span class="line">        show(cc)</span><br><span class="line">        save_flag(image, cc.lower() + <span class="string">'.gif'</span>)</span><br><span class="line">    <span class="keyword">return</span> len(cc_list)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(download_many)</span>:</span></span><br><span class="line">    t0 = time.time()</span><br><span class="line">    count = download_many(POP20_CC)</span><br><span class="line">    elapsed = time.time() - t0</span><br><span class="line">    msg = <span class="string">'\n&#123;&#125; flags downloaded in &#123;:.2f&#125;s'</span></span><br><span class="line">    print(msg.format(count, elapsed))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main(download_many)</span><br></pre></td></tr></table></figure><h2 id="使用concurrent.futures模块下载">使用concurrent.futures模块下载</h2><p>concurrent.futures模块的主要特色是ThreadPoolExecutor和ProcessPoolExecutor类，这两个类实现的接口能分别在不同的线程或进程中执行可调用的对象。这两个类在内部维护这一个工作线程或进程池，以及要执行的任务队列。不过，这个接口抽象的层级很高，像下载国旗这种简单的案例，无需关心任何细节。</p><figure class="highlight python"><figcaption><span>flags_threadpool.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flags <span class="keyword">import</span> save_flag, get_flag, show, main  <span class="comment"># 重用函数</span></span><br><span class="line"></span><br><span class="line">MAX_WOKERS = <span class="number">20</span>  <span class="comment"># 设置最大线程数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_one</span><span class="params">(cc)</span>:</span>  <span class="comment"># 下载一个国旗，这是在各个线程中执行的函数</span></span><br><span class="line">    image = get_flag(cc)</span><br><span class="line">    show(cc)</span><br><span class="line">    save_flag(image, cc.lower() + <span class="string">'.gif'</span>)</span><br><span class="line">    <span class="keyword">return</span> cc</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list)</span>:</span></span><br><span class="line">    wokers = min(MAX_WOKERS, len(cc_list))  <span class="comment"># 避免创建多余的线程</span></span><br><span class="line">    <span class="comment"># executor.__exit__方法会调用executor.shutdown(wait=True)方法</span></span><br><span class="line">    <span class="comment"># 它会在所有线程都执行完毕前阻塞线程</span></span><br><span class="line">    <span class="keyword">with</span> futures.ThreadPoolExecutor(wokers) <span class="keyword">as</span> executor:</span><br><span class="line">        res = executor.map(download_one, sorted(cc_list))  <span class="comment"># 返回一个生成器</span></span><br><span class="line">    <span class="keyword">return</span> len(list(res))  <span class="comment"># 获取各个函数返回的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main(download_many)</span><br></pre></td></tr></table></figure><h3 id="期物在哪里">期物在哪里</h3><p>期物是concurrent.futures模块和asyncio包的重要组件，可是，作为这两个库的用户，我们有时却见不到期物。</p><p>从Python3.4起，标准库中有两个名为Future的类：concurrent.futures.Future和asyncio.Future。这两个类的作用相同：两个Future类的实例都表示可能已经完成或者尚未完成的延迟计算。这与Twisted引擎中的Deferred类、Tornado框架中的Future类，以及多个JavaScript库中的Promise对象类似。</p><p>期物封装待完成的操作，可以放入队列，完成的状态可以查询，得到结果（或抛出异常）后可以获取结果（或异常）。</p><p>我们要记住一件事：<strong>通常情况下自己不应该创建期物，而只能由并发框架（concurrent.futures或asyncio）实例化。</strong>原因很简单：期物表示终将发生的事情，而确定某件事会发生的唯一方式是执行的时间已经排定。因此，只有排定把某件事交给concurrent.futures.Executor子类处理时，才会创建concurrent.futures.Future实例。例如，Executor.submit方法的参数是一个可调用的对象，调用这个方法后会为传入的可调用对象排期，并返回一个期物。</p><p>客户端代码不应该改变期物的状态，并发框架在期物表示的延迟计算结束后会改变期物的状态，而我们无法控制计算何时结束。</p><p>这两种期物都有done方法，这个方法不阻塞，返回值是布尔值，指明期物链接的可调用对象是否已经执行。客户端代码通常不会询问期物是否运行结束，而是会等待通知。因此，两个Future类都有add_done_callback方法：这个方法只有一个参数，类型是可调用的对象，期物运行结束后会调用指定的可调用对象。</p><p>此外，还有result方法。在期物运行结束后调用的话，这个方法在两个Future类中的作用相同：返回可调用对象的结果，或者重新抛出执行可调用的对象时抛出的异常。可是，如果期物没有运行结束，result方法在两个Future类中的行为相差很大。对concurrency.futures.Future实例来说，调用f.result()方法会阻塞调用方所在的线程，直到有结果可以返回。此时，result方法可以接收可选的timeout参数，如果在指定的时间内没有运行完毕，会抛出TimeoutError异常。asyncio.Future.result方法不支持设定超过时间，在那个库中获取期物的结果最好使用yield from结构。不过，对concurrency.futures.Future实例不能这么做。</p><p>这两个库中有几个函数会返回期物，其他函数则使用期物，以易于用户理解的方式实现自身。Executor.map方法属于后者：返回值是一个迭代器，迭代器的<code>__next__</code>方法调用各个期物的result方法，因此我们得到的是各个期物的结果，而非期物本身。</p><p>为了从实用的角度理解期物，我们可以实用concurrent.futures.as_completed函数重写示例。这个函数的参数是一个期物列表，返回值是一个迭代器，在期物运行结束后产出期物。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list)</span>:</span></span><br><span class="line">    cc_list = cc_list[:<span class="number">5</span>]  <span class="comment"># 使用5个做演示</span></span><br><span class="line">    <span class="keyword">with</span> futures.ThreadPoolExecutor(max_workers=<span class="number">3</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        to_do = []</span><br><span class="line">        <span class="keyword">for</span> cc <span class="keyword">in</span> sorted(cc_list):</span><br><span class="line">            future = executor.submit(download_one, cc)  <span class="comment"># 排定可调用对象的执行时间，返回一个期物</span></span><br><span class="line">            to_do.append(future)</span><br><span class="line">            msg = <span class="string">'Scheduled for &#123;&#125;: &#123;&#125;'</span></span><br><span class="line">            print(msg.format(cc, future))</span><br><span class="line">        results = []</span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> futures.as_completed(to_do):  <span class="comment"># 在期物运行结束后产出期物</span></span><br><span class="line">            res = future.result()  <span class="comment"># 这次不会阻塞，因为future由as_completed函数产出</span></span><br><span class="line">            msg = <span class="string">'&#123;&#125; result: &#123;!r&#125;'</span></span><br><span class="line">            print(msg.format(future, res))</span><br><span class="line">            results.append(res)</span><br><span class="line">        <span class="keyword">return</span> len(results)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ python flags_threadpool.py</span><br><span class="line">Scheduled for BR: &lt;Future at 0x1031a25f8 state=running&gt;</span><br><span class="line">Scheduled for CN: &lt;Future at 0x1031ae0f0 state=running&gt;</span><br><span class="line">Scheduled for ID: &lt;Future at 0x1031ae6a0 state=running&gt;  # 最大3个</span><br><span class="line">Scheduled for IN: &lt;Future at 0x1031bb080 state=pending&gt;</span><br><span class="line">Scheduled for US: &lt;Future at 0x1031bb160 state=pending&gt;</span><br><span class="line">CN &lt;Future at 0x1031ae0f0 state=finished returned str&gt; result: &apos;CN&apos;</span><br><span class="line">ID BR &lt;Future at 0x1031ae6a0 state=finished returned str&gt; result: &apos;ID&apos;</span><br><span class="line">&lt;Future at 0x1031a25f8 state=finished returned str&gt; result: &apos;BR&apos;</span><br><span class="line">IN &lt;Future at 0x1031bb080 state=finished returned str&gt; result: &apos;IN&apos;</span><br><span class="line">US &lt;Future at 0x1031bb160 state=finished returned str&gt; result: &apos;US&apos;</span><br><span class="line"></span><br><span class="line">5 flags downloaded in 0.32s</span><br></pre></td></tr></table></figure><p>多次运行脚本看到的结果有所不同。如果把max_workers参数的值增大到5，结果的顺序变化更多。把max_workers参数的值设为1，代码依序运行，结果的顺序始终与调用submit方法的顺序一致。</p><h2 id="使用asyncio模块下载">使用asyncio模块下载</h2><figure class="highlight python"><figcaption><span>flags_asyncio.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这段脚本与原文的脚本代码不同，使用了Python3.5引入的async和await关键字</span></span><br><span class="line"><span class="comment"># 原脚本中的一些写法可能不再是推荐写法了，愿脚本的代码也不进行分析了</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> aiohttp  <span class="comment"># 它不在标准库中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flags <span class="keyword">import</span> BASE_URL, save_flag, show, main</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_flag</span><span class="params">(client, cc)</span>:</span></span><br><span class="line">    url = <span class="string">'&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif'</span>.format(BASE_URL, cc=cc.lower())</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> client.get(url) <span class="keyword">as</span> resp:</span><br><span class="line">        <span class="keyword">assert</span> resp.status == <span class="number">200</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> resp.read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">download_one</span><span class="params">(cc)</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> client:</span><br><span class="line">        image = <span class="keyword">await</span> get_flag(client, cc)</span><br><span class="line">        show(cc)</span><br><span class="line">        save_flag(image, cc.lower() + <span class="string">'.gif'</span>)</span><br><span class="line">        <span class="keyword">return</span> cc</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list)</span>:</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    to_do = [download_one(cc) <span class="keyword">for</span> cc <span class="keyword">in</span> sorted(cc_list)]</span><br><span class="line">    <span class="comment"># 虽然函数名是wait，但它不是阻塞性函数。wait是一个协程，等传给它所有协程运行完毕后结束</span></span><br><span class="line">    wait_coro = asyncio.wait(to_do)</span><br><span class="line">    <span class="comment"># 执行事件循环，直到wait_coro运行结束；事件循环运行的过程中，这个脚本会在这里阻塞</span></span><br><span class="line">    res, _ = loop.run_until_complete(wait_coro)</span><br><span class="line">    loop.close()  <span class="comment"># 关闭事件循环</span></span><br><span class="line">    <span class="keyword">return</span> len(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main(download_many)</span><br></pre></td></tr></table></figure><p>严格来说，我们目前测试的并发脚本都不能并行下载。使用concurrent.futures库实现的那两个示例受GIL（Global Interpreter Lock，全局解释器锁）的限制，而使用asyncio库实现的脚本在单个线程中运行。</p><ul><li>既然Python线程受GIL的限制，任何时候都只允许运行一个线程，那么flags_threadpool.py脚本的下载速度怎么会比flags.py脚本快5倍？这是因为GIL几乎对<strong>I/O密集型</strong>处理无害。原因见下一节阻塞型I/O和GIL。</li><li>flags_asyncio.py脚本和flags.py脚本都在单个线程中运行，前者怎么会比后者快5倍？原因见下下一节避免阻塞型调用。</li></ul><h1 id="阻塞型io和gil">阻塞型I/O和GIL</h1><p>CPython解释器本身就不是线程安全的，因此有全局解释器锁（GIL），一次只允许使用一个线程执行Python字节码（这是CPython解释器的局限，与Python语言本身无关）。因此，一个Python进程通常不能同时使用多个CPU核心。</p><p>编写Python代码时无法控制GIL；不过，执行耗时的任务时，可以使用一个内置的函数或一个使用C语言编写的扩展释放GIL。其实，有个使用C语言编写的Python库能管理GIL，自行启动操作系统线程，利用全部可用的CPU核心。这样做会极大地增加库代码的复杂度，因此大多数库的作者都不这么做。</p><p>然而，<strong>标准库中的所有执行阻塞型I/O操作的函数，在等待操作系统返回结果时都会释放GIL。这意味着在Python语言这个层次上可以使用多线程，而I/O密集型Python程序能从中受益：一个Python线程等待网络响应时，阻塞型I/O函数会释放GIL，再运行一个线程。</strong></p><p>下面简单说明如何在<strong>CPU密集型</strong>作业中使用concurrent.futures模块轻松绕开GIL。</p><h1 id="避免阻塞型调用">避免阻塞型调用</h1><p>用asyncio包时，我们编写的异步代码中包含由asyncio本身驱动的协程（即委派生成器），而生成器最终把职责委托给asyncio包或第三方库（如aiohttp）中的协程。这种处理方式相当于架起了管道，让asyncio事件循环（通过我们编写的协程）驱动执行低层异步I/O操作的库函数。</p><p>有两种方法能避免阻塞型调用中止整个应用程序的进程：</p><ul><li>在单独的线程中运行各个阻塞型操作</li><li>把每个阻塞型操作转换成非阻塞的异步调用使用</li></ul><p>多个线程是可以的，但是各个操作系统线程（Python使用的是这种线程）消耗的内存达兆字节（具体的量取决于操作系统种类）。如果要处理几千个连接，而每个连接都使用一个线程的话，我们负担不起。</p><p>为了降低内存的消耗，通常使用回调来实现异步调用。使用回调时，我们不等待响应，而是注册一个函数，在发生某件事时调用。这样，所有调用都是非阻塞的。因为回调简单，而且消耗低，所以Ryan Dahl（Node.js的发明者）用户这种方式。</p><p>当然，只有异步应用程序底层的事件循环能依靠各种基础设置的中断、线程、轮询和后台进程等，确保多个并发请求能取得进展并最终完成，这样才能使用回调。事件循环获得响应后，会回过头来调用我们指定的回调。不过，如果做法正确，事件循环和应用代码共用的主线程绝不会阻塞。</p><p>把生成器当作协程使用是异步编程的另一种方式。对事件循环来说，调用回调与在暂停的协程上调用send方法效果差不多。各个暂停的协程是要消耗内存，但是比线程消耗的内存数量级小。而且，协程能避免可怕的“回调地狱”。</p><p>flags.py脚本依序下载，而每次下载都要用几十亿个CPU周期等待即过。其实，CPU同时做了很多事，只是没有运行你的程序。与此相比，在flags_asyncio.py脚本中，在download_many函数中调用loop.run_until_complete方法时，事件循环驱动各个download_one协程，各个download_one协程中又驱动各个get_flag协程，运行到client.get(url)。这些调用都不会阻塞，因此在零点几秒内所有请求全部开始。</p><p>asyncio的基础设施获得第一个响应后，事件循环把响应发给等待结果的get_flag协程。得到响应后，get_flag向前执行，调用resp.read方法，然后把控制权还给主循环。（我不确定这段描述是否符合<code>return await resp.read()</code>的运行过程；作为参考，原脚本的代码是<code>return yield from resp.read()</code>）</p><p>因为异步操作是交叉执行的，所以并发下载多张图像所需的总时间比依序下载少得多。</p><h1 id="使用concurrent.futures模块启动进程">使用concurrent.futures模块启动进程</h1><p>concurrent.futures模块的文档副标题是“Launching parallel tasks”（执行并行任务）。这个模块实现的是真正的并行计算，因为它使用ProcessPoolExecutor类把工作分配给多个Python进程处理。因此，如果需要做CPU密集型处理，使用这个模块能绕开GIL，利用所有可用CPU核心。</p><p><a href="https://devdocs.io/python~3.6/library/concurrent.futures#concurrent.futures.ProcessPoolExecutor" target="_blank" rel="noopener">ProcessPoolExecutor</a>和<a href="https://devdocs.io/python~3.6/library/concurrent.futures#concurrent.futures.ThreadPoolExecutor" target="_blank" rel="noopener">ThreadPoolExecutor</a>类都实现了通用的Executor接口，因此使用concurrent.futures模块能特别轻松地把基于线程的方案转成基于进程的方案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list)</span>:</span></span><br><span class="line">    workers = min(MAX_WORKERS, len(cc_list))</span><br><span class="line">    <span class="keyword">with</span> futures.ThreadPoolExecutor(workers) <span class="keyword">as</span> executor:  <span class="comment"># 基于线程</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> futures.ProcessPoolExecutor() <span class="keyword">as</span> executor:  <span class="comment"># 基于进程</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p><code>ThreadPoolExecutor.__init__</code>方法需要<code>max_workers</code>参数，指定线程池中线程的数量。在ProcessPoolExecutor类中，那个参数是可选的，而且大多数情况下不实用——默认值是<code>os.cpu_count()</code>函数返回的CPU数量。这样处理说得通，因为对于CPU密集型的处理来说，不可能要求使用超过CPU数量的workers。而对I/O密集型处理来说，可以在一个ThreadPoolExecutor实例中使用10个、100个或1000个线程；最佳线程数取决于做的是什么事，以及可用内存有多少，因此要仔细测试才能找到最佳的线程数。</p><h1 id="实验executor.map方法">实验Executor.map方法</h1><p>若想并发运行多个可调用的对象，最简单的方式是使用示例中见过的Executor.map方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep, strftime</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(*args)</span>:</span>  <span class="comment"># 打印传入的参数并在前加一个时间戳</span></span><br><span class="line">    print(strftime(<span class="string">'[%H:%M:%S]'</span>), end=<span class="string">' '</span>)</span><br><span class="line">    print(*args)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loiter</span><span class="params">(n)</span>:</span></span><br><span class="line">    msg = <span class="string">'&#123;&#125;loiter(&#123;&#125;): doing nothing for &#123;&#125;s...'</span></span><br><span class="line">    display(msg.format(<span class="string">'\t'</span>*n, n, n))</span><br><span class="line">    sleep(n)</span><br><span class="line">    msg = <span class="string">'&#123;&#125;loiter(&#123;&#125;): done.'</span></span><br><span class="line">    display(msg.format(<span class="string">'\t'</span>*n, n))</span><br><span class="line">    <span class="keyword">return</span> n * <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    display(<span class="string">'Script starting.'</span>)</span><br><span class="line">    executor = futures.ThreadPoolExecutor(max_workers=<span class="number">3</span>)</span><br><span class="line">    results = executor.map(loiter, range(<span class="number">5</span>))</span><br><span class="line">    display(<span class="string">'results:'</span>, results)  <span class="comment"># 返回的是生成器，目前不会阻塞</span></span><br><span class="line">    display(<span class="string">'Waiting for individual results:'</span>)</span><br><span class="line">    <span class="keyword">for</span> i, result <span class="keyword">in</span> enumerate(results):</span><br><span class="line">        display(<span class="string">'result &#123;&#125;: &#123;&#125;'</span>.format(i, result))</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ python demo_executor_map.py</span><br><span class="line">[21:31:07] Script starting.</span><br><span class="line">[21:31:07] loiter(0): doing nothing for 0s...</span><br><span class="line">[21:31:07] loiter(0): done.</span><br><span class="line">[21:31:07]     loiter(1): doing nothing for 1s...</span><br><span class="line">[21:31:07]         loiter(2): doing nothing for 2s...</span><br><span class="line">[21:31:07] results: &lt;generator object Executor.map.&lt;locals&gt;.result_iterator at 0x10cd970f8&gt;</span><br><span class="line">[21:31:07] Waiting for individual results:</span><br><span class="line">[21:31:07] result 0: 0  # loiter(0)运行结束了，第一个worker就可以启动第四个线程，运行loiter(3)</span><br><span class="line">[21:31:07]             loiter(3): doing nothing for 3s...</span><br><span class="line">[21:31:08]     loiter(1): done.</span><br><span class="line">[21:31:08]                 loiter(4): doing nothing for 4s...</span><br><span class="line">[21:31:08] result 1: 10</span><br><span class="line">[21:31:09]         loiter(2): done.</span><br><span class="line">[21:31:09] result 2: 20</span><br><span class="line">[21:31:10]             loiter(3): done.</span><br><span class="line">[21:31:10] result 3: 30</span><br><span class="line">[21:31:12]                 loiter(4): done.</span><br><span class="line">[21:31:12] result 4: 40</span><br></pre></td></tr></table></figure><p>第一个线程执行loiter(0)，因此会休眠0秒，甚至会在第二个线程开始之前就结束，不过具体情况因人而异：对线程来说，你永远不知道某一时刻事件的具体排序；有可能在另一台设备中会看到loiter(1)在loiter(0)结束之前开始，这是因为sleep函数总会释放GIL。因此，即便休眠0秒，Python也可能会切换到另一个线程。</p><p><strong>Executor.map函数易于使用，不过有个特性可能有用，也可能没用，具体情况取决于需求：这个函数返回结果的顺序与调用开始的顺序一致。如果第一个调用生成结果用时10秒，而其他调用只用1秒，代码会阻塞10秒，获取map方法返回的生成器产出的第一个结果。在此之后，获取后续结果时不会阻塞，因为后续的调用已经结束。如果必须等到获取所有结果后再处理，这种行为没问题；不过，通常更可取的方式是，不管提交的顺序，只要有结果就获取。为此，要把Executor.submit方法和futures.as_completed函数结合起来使用（之前的示例中演示过如何组合使用）。</strong></p><p>executor.submit和futures.as_completed这个组合比executor.map更灵活，因为submit方法能处理不同的可调用对象和参数，而executor.map只能处理参数不同的同一个可调用对象。此外，传给futures.as_completed函数的期物集合可以来自Executor实例，例如一些由ThreadPoolExecutor实例创建，另一些由ProcessPoolExecutor实例创建。</p><h1 id="显示下载进度并处理错误节选">显示下载进度并处理错误（节选）</h1><h2 id="依序下载">依序下载</h2><p>在download_one函数中处理HTTP 404错误，其他异常则向上冒泡，交给download_many函数处理。</p><figure class="highlight python"><figcaption><span>flags2_sequential.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flag</span><span class="params">(base_url, cc)</span>:</span></span><br><span class="line">    url = <span class="string">'&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif'</span>.format(base_url, cc=cc.lower())</span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    <span class="keyword">if</span> resp.status_code != <span class="number">200</span>:</span><br><span class="line">        resp.raise_for_status()  <span class="comment"># 状态码不是200时，抛出异常</span></span><br><span class="line">    <span class="keyword">return</span> resp.content</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_one</span><span class="params">(cc, base_url, verbose=False)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        image = get_flag(base_url, cc)</span><br><span class="line">    <span class="keyword">except</span> requests.exceptions.HTTPError <span class="keyword">as</span> exc:  <span class="comment"># 捕获异常</span></span><br><span class="line">        res = exc.response</span><br><span class="line">        <span class="keyword">if</span> res.status_code == <span class="number">404</span>:  <span class="comment"># 单独处理404异常</span></span><br><span class="line">            status = HTTPStatus.not_found  <span class="comment"># HTTPStatus是自定义的Enum对象</span></span><br><span class="line">            msg = <span class="string">'not found'</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 抛出其他异常</span></span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 没有异常时</span></span><br><span class="line">        save_flag(image, cc.lower() + <span class="string">'.gif'</span>)</span><br><span class="line">        status = HTTPStatus.ok</span><br><span class="line">        msg = <span class="string">'OK'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> verbose:  <span class="comment"># 是否显示消息</span></span><br><span class="line">        print(cc, msg)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result(status, cc)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list, base_url, verbose, max_req)</span>:</span></span><br><span class="line">    counter = collections.Counter()  <span class="comment"># 计数</span></span><br><span class="line">    cc_iter = sorted(cc_list)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> verbose:  <span class="comment"># 是否显示进度条</span></span><br><span class="line">        <span class="comment"># 把cc_iter传给tqdm函数，返回一个迭代器，产出cc_iter中的元素，还会显示进度条动画</span></span><br><span class="line">        cc_iter = tqdm.tqdm(cc_iter)</span><br><span class="line">    <span class="keyword">for</span> cc <span class="keyword">in</span> cc_iter:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            res = download_one(cc, base_url, verbose)</span><br><span class="line">        <span class="keyword">except</span> requests.exceptions.HTTPError <span class="keyword">as</span> exc:  <span class="comment"># 与HTTP有关且download_one中没处理的异常</span></span><br><span class="line">            error_msg = <span class="string">'HTTP error &#123;res.status_code&#125; - &#123;res.reasion&#125;'</span></span><br><span class="line">            error_msg = errormsg.format(res=exc.response)</span><br><span class="line">        <span class="keyword">except</span> requests.exceptions.ConnectionError <span class="keyword">as</span> exc:  <span class="comment"># 与网络有关的异常</span></span><br><span class="line">            error_msg = <span class="string">'Connection error'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            error_msg = <span class="string">''</span></span><br><span class="line">            status = res.status</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> error_msg:</span><br><span class="line">            status = HTTPStatus.error</span><br><span class="line">        counter[status] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> verbose <span class="keyword">and</span> error_msg:</span><br><span class="line">            print(<span class="string">'*** Error for &#123;&#125;: &#123;&#125;'</span>.format(cc, error_msg))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> counter</span><br></pre></td></tr></table></figure><h2 id="使用futures.as_completed函数">使用futures.as_completed函数</h2><p>为了集成TQDM进度条，并处理各次请求中的错误，flags2_threadpool.py脚本用到futures.ThreadPoolExecutor类和futures.as_completed函数。</p><figure class="highlight python"><figcaption><span>flags2_threadpool.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list, base_url, verbose, concur_req)</span>:</span></span><br><span class="line">    counter = collections.Counter()</span><br><span class="line">    <span class="keyword">with</span> futures.ThreadPoolExecutor(max_workers=concur_req) <span class="keyword">as</span> executor:</span><br><span class="line">        to_do_map = &#123;&#125;  <span class="comment"># 把各个Future实例（表示一次下载）映射到相应的国家代码</span></span><br><span class="line">        <span class="keyword">for</span> cc <span class="keyword">in</span> sorted(cc_list):</span><br><span class="line">            future = executor.submit(download_one, cc, base_url, verbose)  <span class="comment"># 排定执行时间</span></span><br><span class="line">            to_do_map[future] = cc</span><br><span class="line">        done_iter = futures.as_completed(to_do_map)  <span class="comment"># 返回一个迭代器，在期物运行结束后产出期物</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> verbose:</span><br><span class="line">            <span class="comment"># done_iter没有__len__方法，必须通过total参数告诉tqdm函数预期的元素数量</span></span><br><span class="line">            done_iter = tqdm.tqdm(done_iter, total=len(cc_list))</span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> done_iter:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                res = future.result()  <span class="comment"># 不会阻塞，因为as_completed函数只返回已经运行结束的期物</span></span><br><span class="line">            <span class="keyword">except</span> requests.exceptions.HTTPError <span class="keyword">as</span> exc:</span><br><span class="line">                error_msg = <span class="string">'HTTP &#123;res.status_code&#125; - &#123;res.reason&#125;'</span></span><br><span class="line">                error_msg = error_msg.format(res=exc.response)</span><br><span class="line">            <span class="keyword">except</span> requests.exceptions.ConnectionError <span class="keyword">as</span> exc:</span><br><span class="line">                error_msg = <span class="string">'Connection error'</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                error_msg = <span class="string">''</span></span><br><span class="line">                status = res.status</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> error_msg:</span><br><span class="line">                status = HTTPStatus.error</span><br><span class="line">            counter[status] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> verbose <span class="keyword">and</span> error_msg:</span><br><span class="line">                cc = to_do_map[future]</span><br><span class="line">                print(<span class="string">'*** Error for &#123;&#125;: &#123;&#125;'</span>.format(cc, error_msg))</span><br><span class="line">    <span class="keyword">return</span> counter</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> concurrency </tag>
            
            <tag> futures </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用协程做离散事件仿真</title>
      <link href="/notes/fluent-python/coroutines-for-discrete-event-simulation/"/>
      <url>/notes/fluent-python/coroutines-for-discrete-event-simulation/</url>
      
        <content type="html"><![CDATA[<p>在计算机科学领域，仿真是协程的经典应用。</p><p>协程是asyncio包的基础构建。通过仿真系统能说明如何使用协程代替线程实现并发的活动。</p><h1 id="离散事件仿真简介">离散事件仿真简介</h1><p>离散事件仿真（Discrete Event Simulation，DES）是一种把系统建模成一系列事件的仿真类型。在离散事件仿真中，仿真“钟”向前推进的量不是固定的，而是直接推进到下一个事件模型的模拟时间。加入我们抽象模拟出租车的运营过程，其中一个事件是乘客上车，下一个事件则是乘客下车。不管乘客坐了5分钟还是50分钟，一旦乘客下车，仿真钟就会更新，指向此次运营的结束时间。使用离散事件仿真可以在不到一秒钟的事件模拟一年的出租车运营过程。这与连续仿真不同，连续仿真的仿真钟以固定的量（通常很小）不断向前推进。</p><p>显然，回合制游戏就是离散事件仿真的例子：游戏的状态只在玩家操作时变化，而且一旦玩家决定下一步怎么走了，仿真钟就会冻结。而实时游戏则是连续仿真，仿真钟一直在运行，游戏的状态在一秒钟之内更新很多次，因此反应慢的玩家特别吃亏。</p><p>这两种仿真类型都能使用多线程或在单个线程中使用面向事件的编程技术实现。可以说，为了实现连续仿真，在多个线程中处理实时并行的操作更自然。而协程恰好为实现离散事件仿真提供了合理的抽象。SimPy是一个实现离散时间仿真的Python包，通过一个协程表示离散事件仿真系统中的各个进程。</p><p>本节说明如何只使用标准库提供的功能实现一个特别简单的离散事件仿真系统。</p><a id="more"></a><h1 id="出租车队运营仿真">出租车队运营仿真</h1><figure class="highlight python"><figcaption><span>taxi_sim.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">DEFAULT_NUMBER_OF_TAXIS = <span class="number">3</span>  <span class="comment"># 默认出租车数量</span></span><br><span class="line">DEFAULT_END_TIME = <span class="number">180</span>       <span class="comment"># 默认仿真钟结束时间</span></span><br><span class="line">SEARCH_DURATION = <span class="number">5</span>          <span class="comment"># 默认（空车）徘徊时间</span></span><br><span class="line">TRIP_DURATION = <span class="number">20</span>           <span class="comment"># 默认载客行驶时间</span></span><br><span class="line">DEPARTURE_INTERVAL = <span class="number">5</span>       <span class="comment"># 默认出库间隔时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 属性分别为 发生时间, 协程的key, 事件的名称</span></span><br><span class="line">Event = collections.namedtuple(<span class="string">'Event'</span>, <span class="string">'time proc action'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">taxi_process</span><span class="params">(ident, trips, start_time=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">"""每次状态变化时向仿真程序产出一个事件"""</span></span><br><span class="line">    time = <span class="keyword">yield</span> Event(start_time, ident, <span class="string">'leave garage'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(trips):</span><br><span class="line">        time = <span class="keyword">yield</span> Event(time, ident, <span class="string">'pick up passenger'</span>)</span><br><span class="line">        time = <span class="keyword">yield</span> Event(time, ident, <span class="string">'drop off passenger'</span>)</span><br><span class="line">    <span class="keyword">yield</span> Event(time, ident, <span class="string">'going home'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simulator</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, procs_map)</span>:</span>  <span class="comment"># 初始化时传入所有出租车的协程</span></span><br><span class="line">        self.events = queue.PriorityQueue()</span><br><span class="line">        self.procs = dict(procs_map)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, end_time)</span>:</span></span><br><span class="line">        <span class="string">"""调度并显示事件，直到时间结束"""</span></span><br><span class="line">        <span class="comment"># 调度各辆出租车的第一个事件</span></span><br><span class="line">        <span class="keyword">for</span> _, proc <span class="keyword">in</span> sorted(self.procs.items()):</span><br><span class="line">            first_event = next(proc)  <span class="comment"># 预激</span></span><br><span class="line">            self.events.put(first_event)  <span class="comment"># 将第一个事件放入events</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 此次仿真的主循环</span></span><br><span class="line">        sim_time = <span class="number">0</span>  <span class="comment"># 仿真钟</span></span><br><span class="line">        <span class="keyword">while</span> sim_time &lt; end_time:</span><br><span class="line">            <span class="keyword">if</span> self.events.empty():  <span class="comment"># 所有事件都已完成，即各出租车完成出库，完成指定数目的行程，入库</span></span><br><span class="line">                print(<span class="string">'*** end of events ***'</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            current_event = self.events.get()  <span class="comment"># 获得最早发生的事件</span></span><br><span class="line">            sim_time, proc_id, previous_action = current_event  <span class="comment"># 拆包</span></span><br><span class="line">            print(<span class="string">'taxi:'</span>, proc_id, proc_id * <span class="string">'    '</span>, current_event)  <span class="comment"># 打印事件内容</span></span><br><span class="line">            active_proc = self.procs[proc_id]  <span class="comment"># 根据事件的协程的key得到产出该事件的协程（出租车）</span></span><br><span class="line">            next_time = sim_time + compute_duration(previous_action)  <span class="comment"># 计算下一个事件的事件</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                next_event = active_proc.send(next_time)  <span class="comment"># 发送到协程，并得到协程可能产出的事件</span></span><br><span class="line">            <span class="keyword">except</span> StopIteration:  <span class="comment"># 如果协程结束</span></span><br><span class="line">                <span class="keyword">del</span> self.procs[proc_id]  <span class="comment"># 删除该协程</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.events.put(next_event)  <span class="comment"># 否则将产出的事件加入到优先队列中</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 如果因为超时而停止，则输出还有多少事件</span></span><br><span class="line">            msg = <span class="string">'*** end of simulation time: &#123;&#125; events pending ***'</span></span><br><span class="line">            print(msg.format(self.events.qsize()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_duration</span><span class="params">(previous_action)</span>:</span></span><br><span class="line">    <span class="string">"""使用指数分布计算操作的耗时"""</span></span><br><span class="line">    <span class="keyword">if</span> previous_action <span class="keyword">in</span> [<span class="string">'leave garage'</span>, <span class="string">'drop off passenger'</span>]:</span><br><span class="line">        <span class="comment"># 新状态是四处徘徊</span></span><br><span class="line">        interval = SEARCH_DURATION</span><br><span class="line">    <span class="keyword">elif</span> previous_action == <span class="string">'pick up passenger'</span>:</span><br><span class="line">        <span class="comment"># 新状态是行程开始</span></span><br><span class="line">        interval = TRIP_DURATION</span><br><span class="line">    <span class="keyword">elif</span> previous_action == <span class="string">'going home'</span>:</span><br><span class="line">        interval = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'Unknown previous_action: %s'</span> % previous_action)</span><br><span class="line">    <span class="keyword">return</span> int(random.expovariate(<span class="number">1</span>/interval)) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(end_time=DEFAULT_END_TIME, num_taxis=DEFAULT_NUMBER_OF_TAXIS, seed=None)</span>:</span></span><br><span class="line">    <span class="string">"""初始化随机生成器，构建过程，运行仿真程序"""</span></span><br><span class="line">    <span class="keyword">if</span> seed <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        random.seed(seed)  <span class="comment"># 获得可复现的结果</span></span><br><span class="line">    taxis = &#123;i: taxi_process(i, (i+<span class="number">1</span>)*<span class="number">2</span>, i*DEPARTURE_INTERVAL)</span><br><span class="line">             <span class="keyword">for</span> i <span class="keyword">in</span> range(num_taxis)&#125;  <span class="comment"># 协程的字典，每辆出租车对应一个协程</span></span><br><span class="line">    sim = Simulator(taxis)  <span class="comment"># 初始化</span></span><br><span class="line">    sim.run(end_time)  <span class="comment"># 运行仿真</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">'Taxi fleet simulator.'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-e'</span>, <span class="string">'--end-time'</span>, type=int, default=DEFAULT_END_TIME,</span><br><span class="line">                        help=<span class="string">'simulation end time; default = %s'</span></span><br><span class="line">                        % DEFAULT_END_TIME)</span><br><span class="line">    parser.add_argument(<span class="string">'-t'</span>, <span class="string">'--taxis'</span>, type=int, default=DEFAULT_NUMBER_OF_TAXIS,</span><br><span class="line">                        help=<span class="string">'number of taxis running; default = %s'</span></span><br><span class="line">                        % DEFAULT_NUMBER_OF_TAXIS)</span><br><span class="line">    parser.add_argument(<span class="string">'-s'</span>, <span class="string">'--seed'</span>, type=int, default=<span class="literal">None</span>,</span><br><span class="line">                        help=<span class="string">'random generator seed (for testing)'</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    main(args.end_time, args.taxis, args.seed)</span><br></pre></td></tr></table></figure><p><img data-src="/uploads/posts/fluent-python/sample-run-with-three-taxis.png"></p><p>运行taxi_sim.py创建3辆车的输出示例。-s 3参数设置随机数生成器的种子，这样在调试和演示时可以重复运行程序，输出相同的结果。不同颜色的箭头是后来加上的，表示不同出租车的行程。有了箭头，能直观地看出如何使用协程管理并发的活动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ python taxi_sim.py -s 3 -e 60</span><br><span class="line">taxi: 0  Event(time=0, proc=0, action=&apos;leave garage&apos;)</span><br><span class="line">taxi: 0  Event(time=2, proc=0, action=&apos;pick up passenger&apos;)</span><br><span class="line">taxi: 1      Event(time=5, proc=1, action=&apos;leave garage&apos;)</span><br><span class="line">taxi: 1      Event(time=8, proc=1, action=&apos;pick up passenger&apos;)</span><br><span class="line">taxi: 2          Event(time=10, proc=2, action=&apos;leave garage&apos;)</span><br><span class="line">taxi: 2          Event(time=15, proc=2, action=&apos;pick up passenger&apos;)</span><br><span class="line">taxi: 2          Event(time=17, proc=2, action=&apos;drop off passenger&apos;)</span><br><span class="line">taxi: 0  Event(time=18, proc=0, action=&apos;drop off passenger&apos;)</span><br><span class="line">taxi: 2          Event(time=18, proc=2, action=&apos;pick up passenger&apos;)</span><br><span class="line">taxi: 2          Event(time=25, proc=2, action=&apos;drop off passenger&apos;)</span><br><span class="line">taxi: 1      Event(time=27, proc=1, action=&apos;drop off passenger&apos;)</span><br><span class="line">taxi: 2          Event(time=27, proc=2, action=&apos;pick up passenger&apos;)</span><br><span class="line">taxi: 0  Event(time=28, proc=0, action=&apos;pick up passenger&apos;)</span><br><span class="line">taxi: 2          Event(time=40, proc=2, action=&apos;drop off passenger&apos;)</span><br><span class="line">taxi: 2          Event(time=44, proc=2, action=&apos;pick up passenger&apos;)</span><br><span class="line">taxi: 1      Event(time=55, proc=1, action=&apos;pick up passenger&apos;)</span><br><span class="line">taxi: 1      Event(time=59, proc=1, action=&apos;drop off passenger&apos;)</span><br><span class="line">taxi: 0  Event(time=65, proc=0, action=&apos;drop off passenger&apos;)</span><br><span class="line">*** end of simulation time: 3 events pending ***</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> coroutines </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协程</title>
      <link href="/notes/fluent-python/coroutines/"/>
      <url>/notes/fluent-python/coroutines/</url>
      
        <content type="html"><![CDATA[<p>字典为动词“to yield”给出了两个释义：产出和让步。对于Python生成器中的yield来说，这两个含义都成立。yield item这行代码会产出一个值，提供给next(...)的调用方；此外，还会作出让步，暂停执行生成器，让调用方继续工作，直到需要使用另一个值时再调用next()。调用方会从生成器中拉取值。</p><h1 id="用作协程的生成器的基本行为">用作协程的生成器的基本行为</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可能是协程最简单的使用演示</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">simple_coroutine</span><span class="params">()</span>:</span>  <span class="comment"># 定义体中有yield关键字</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'-&gt; coroutine started'</span>)</span><br><span class="line"><span class="meta">... </span>    x = <span class="keyword">yield</span>  <span class="comment"># yield在表达式中使用</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'-&gt; coroutine received:'</span>, x)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro = simple_coroutine()  <span class="comment"># 与创建生成器一样，调用函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro  <span class="comment"># 得到生成器对象</span></span><br><span class="line">&lt;generator object simple_coroutine at <span class="number">0x101df2888</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(my_coro)  <span class="comment"># 首先要调用next()函数，因为生成器还没有启动</span></span><br><span class="line">-&gt; coroutine started  # 生成器启动，在yield处暂停</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro.send(<span class="number">42</span>)  <span class="comment"># 发送数据</span></span><br><span class="line">-&gt; coroutine received: 42  # 协程恢复，继续运行，打印出内容</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration  <span class="comment"># 生成器运行到末尾，抛出StopIteration异常</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>协程可以身处四个状态中的一个。当前状态可以使用inspect.getgeneratorstate(...)函数确定，该函数会返回下述字符串中的一个。</p><p>'GEN_CREATED'：等待开始执行。</p><p>'GEN_RUNNING'：解释器正在执行。只有在多线程应用中才能看到这个状态。此外，生成器对象在自己身上调用getgeneratorstate函数也行，不过这样做没什么用。</p><p>'GEN_SUSPENDED'：在yield表达式出暂停。</p><p>'GEN_CLOSED'：执行结束。</p><p>因为send方法的参数会成为暂停的yield表达式的值，所以，仅当协程处于暂停状态时才能调用send方法，例如my_coro.send(42)。不过，如果协程还没激活（即，状态是'GEN_CREATED'），情况就不同了。因此，始终要调用next(my_coro)激活协程；也可以调用my_coro.send(None)，效果一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro = simple_coroutine()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro.send(<span class="number">42</span>)  <span class="comment"># 协程未激活</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: can <span class="keyword">not</span> send non-<span class="literal">None</span> value to a just-started generator  <span class="comment"># 错误消息明确</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(my_coro), my_coro.send(<span class="number">42</span>)  <span class="comment"># 先激活</span></span><br><span class="line">-&gt; coroutine started</span><br><span class="line">-&gt; coroutine received: 42</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">simple_coro2</span><span class="params">(a)</span>:</span>  <span class="comment"># 举个产出多个值的例子</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'-&gt; Started: a ='</span>, a)</span><br><span class="line"><span class="meta">... </span>    b = <span class="keyword">yield</span> a  <span class="comment"># 产出a后暂停执行</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'-&gt; Received: b ='</span>, b)</span><br><span class="line"><span class="meta">... </span>    c = <span class="keyword">yield</span> a + b</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'-&gt; Received: c ='</span>, c)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro2 = simple_coro2(<span class="number">14</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> inspect <span class="keyword">import</span> getgeneratorstate</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getgeneratorstate(my_coro2)</span><br><span class="line"><span class="string">'GEN_CREATED'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(my_coro2)  <span class="comment"># 激活协程</span></span><br><span class="line">-&gt; Started: a = 14  # 输出的内容</span><br><span class="line"><span class="number">14</span>  <span class="comment"># 产出的内容</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getgeneratorstate(my_coro2)  <span class="comment"># 在第一个yield表达式处暂停，等待调用者为b赋值</span></span><br><span class="line"><span class="string">'GEN_SUSPENDED'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro2.send(<span class="number">28</span>)  <span class="comment"># 为b赋值</span></span><br><span class="line">-&gt; Received: b = 28</span><br><span class="line"><span class="number">42</span>  <span class="comment"># 产出a+b，然后在第二个yield表达式处暂停，等待为c赋值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro2.send(<span class="number">99</span>)</span><br><span class="line">-&gt; Received: c = 99</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getgeneratorstate(my_coro2)  <span class="comment"># 协程结束</span></span><br><span class="line"><span class="string">'GEN_CLOSED'</span></span><br></pre></td></tr></table></figure><h1 id="示例使用协程计算移动平均值">示例：使用协程计算移动平均值</h1><p>在讨论闭包时，我们分别用类和高阶函数实现了该功能。下面展示如何使用协程实现相同的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    total = <span class="number">0.0</span></span><br><span class="line"><span class="meta">... </span>    count = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    average = <span class="literal">None</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># 无限循环，仅当调用方在协程上调用.close()方法，或者协程被垃圾回收程序回收时，这个协程才会终止</span></span><br><span class="line"><span class="meta">... </span>        term = <span class="keyword">yield</span> average  <span class="comment"># 首次会产出None</span></span><br><span class="line"><span class="meta">... </span>        total += term  <span class="comment"># 使用协程的好处是，total和count声明为局部变量即可</span></span><br><span class="line"><span class="meta">... </span>        count += <span class="number">1</span>     <span class="comment"># 无需使用实例属性或闭包在多次调用之间保持上下文</span></span><br><span class="line"><span class="meta">... </span>        average = total/count</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg = averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="literal">None</span>)  <span class="comment"># 使用.send(None)方式激活协程</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">10</span>)</span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">30</span>)</span><br><span class="line"><span class="number">20.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">5</span>)</span><br><span class="line"><span class="number">15.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getgeneratorstate(coro_avg)</span><br><span class="line"><span class="string">'GEN_CLOSED'</span></span><br></pre></td></tr></table></figure><h1 id="预激协程的装饰器">预激协程的装饰器</h1><p>如果不预激，那么协程没什么用。为了简化协程的用法，有时会使用一个预激装饰器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">coroutine</span><span class="params">(func)</span>:</span>  <span class="comment"># 定义的预激装饰器</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">"""装饰器：向前直行到第一个yield表达式，预激func"""</span></span><br><span class="line"><span class="meta">... </span>    @wraps(func)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">primer</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>        gen = func(*args, **kwargs)  <span class="comment"># 调用被装饰的函数</span></span><br><span class="line"><span class="meta">... </span>        next(gen)  <span class="comment"># 激活生成器</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> gen  <span class="comment"># 返回生成器</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> primer  <span class="comment"># 返回包装好的方法</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>averager = coroutine(averager)  <span class="comment"># 装饰averager函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg = averager()  <span class="comment"># 创建一个生成器对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getgeneratorstate(coro_avg)  <span class="comment"># 已经准备好，可以接受值了</span></span><br><span class="line"><span class="string">'GEN_SUSPENDED'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">10</span>)</span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">30</span>)</span><br><span class="line"><span class="number">20.0</span></span><br></pre></td></tr></table></figure><p>很多框架都提供了处理协程的特殊装饰器，不过不是所有的装饰器都用于预激协程，有些会提供其他服务，例如勾入事件循环。</p><p>使用yield from句法调用协程时，会自动预激，因此与示例中的@coroutine装饰器不兼容。Python3.4标准库里的asyncio.coroutine装饰器不会预激协程，因此能兼容yield from句法。</p><h1 id="终止协程和异常处理">终止协程和异常处理</h1><p>协程中未处理的异常会向上冒泡，传给next函数或send方法的调用方（即触发协程的对象）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg = averager()  <span class="comment"># 预激的协程</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">40</span>)</span><br><span class="line"><span class="number">40.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">50</span>)</span><br><span class="line"><span class="number">45.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="string">'spam'</span>)  <span class="comment"># 发送的不是数字，协程会因此终止</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">7</span>, <span class="keyword">in</span> averager</span><br><span class="line">TypeError: unsupported operand type(s) <span class="keyword">for</span> +=: <span class="string">'float'</span> <span class="keyword">and</span> <span class="string">'str'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">60</span>)  <span class="comment"># 无法重新激活</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><p>上例暗示了终止协程的一种方式：<strong>发送某个哨符值，让协程退出。</strong>内置的None和Ellipsis等常量经常用作哨符值。Ellipsis的优点是，数据流中不太常用这个值。我还见过有人把StopIteration类（类本身，而不是实例，也不抛出）作为哨符值：my_coro.send(StopIteration)。</p><p>从Python2.5开始，客户代码可以在生成器对象上调用两个方法，显式地把异常发给协程。这两个方法是throw和close。</p><p><code>generator.throw(exc_type[, exc_value[, traceback]])</code></p><p>致使生成器在暂停的yield表达式处抛出指定的异常。如果生成器处理了抛出的异常，代码会向前执行到下一个yield表达式，而产出的值会成为调用generator.throw方法得到的返回值。如果生成器没有处理抛出的异常，异常会向上冒泡，传到调用方的上下文中。</p><p><code>generator.close()</code></p><p>致使生成器在暂停的yield表达式处抛出GeneratorExit异常。如果生成器没有处理这个异常，或者抛出了StopIteration异常（通常是指运行到结尾），调用方不会报错。如果收到GeneratorExit异常，生成器一定不能产出值，否则解释器会抛出RuntimeError异常。生成器抛出的其他异常会向上冒泡，传给调用方。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">DemoException</span><span class="params">(Exception)</span>:</span> <span class="keyword">pass</span>  <span class="comment"># 为演示定义的异常</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">demo_exc_handling</span><span class="params">()</span>:</span>  <span class="comment"># 学习在协程中处理异常</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'-&gt; coroutine started'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>            x = <span class="keyword">yield</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">except</span> DemoException:  <span class="comment"># 特别处理DemoException异常</span></span><br><span class="line"><span class="meta">... </span>            print(<span class="string">'*** DemoException handled. Continuing...'</span>)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">else</span>:  <span class="comment"># 如果没有异常，那么显示接收到的值</span></span><br><span class="line"><span class="meta">... </span>            print(<span class="string">'-&gt; coroutine received: &#123;!r&#125;'</span>.format(x))</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> RuntimeError(<span class="string">'This line should never run.'</span>)  <span class="comment"># 这行代码不会执行，因为只有未处理的异常</span></span><br><span class="line"><span class="meta">... </span>                                        <span class="comment"># 才会中止无限循环，而一旦出现未处理的异常，协程会立即终止</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>exc_coro = demo_exc_handling()  <span class="comment"># 创建</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(exc_coro)  <span class="comment"># 激活</span></span><br><span class="line">-&gt; coroutine started</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>exc_coro.send(<span class="number">11</span>)</span><br><span class="line">-&gt; coroutine received: 11</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>exc_coro.throw(DemoException)</span><br><span class="line">*** DemoException handled. Continuing...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> inspect <span class="keyword">import</span> getgeneratorstate</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getgeneratorstate(exc_coro)  <span class="comment"># DemoException异常不会导致协程中止</span></span><br><span class="line"><span class="string">'GEN_SUSPENDED'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>exc_coro.throw(ZeroDivisionError)  <span class="comment"># 未处理的异常会导致协程中止</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">5</span>, <span class="keyword">in</span> demo_exc_handling</span><br><span class="line">ZeroDivisionError</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getgeneratorstate(exc_coro)</span><br><span class="line"><span class="string">'GEN_CLOSED'</span></span><br></pre></td></tr></table></figure><p>如果不管协程如何结束都想做些清理工作，要把协程定义体中相关代码放入try/finally块中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo_finally</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'-&gt; coroutine started'</span>)</span><br><span class="line">    <span class="keyword">try</span>:  <span class="comment"># 定义体放入try/finally块中</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                x = <span class="keyword">yield</span></span><br><span class="line">            <span class="keyword">except</span> DemoException:</span><br><span class="line">                print(<span class="string">'*** DemoException handled. Continuing...'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">'-&gt; coroutine received: &#123;!r&#125;'</span>.format(x))</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        print(<span class="string">'-&gt; coroutine ending'</span>)</span><br></pre></td></tr></table></figure><h1 id="让协程返回值">让协程返回值</h1><p>为了说明如何返回值，每次激活协程时不会产出移动平均值。这么做是为了强调某些协程不会产出值，而是在最后返回一个值（通常是某种累计值）。</p><figure class="highlight python"><figcaption><span>coroaverager2.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Result = namedtuple(<span class="string">'Result'</span>, <span class="string">'count average'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">()</span>:</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">if</span> term <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 为了返回值，协程必须正常终止，因此加了个判断条件</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br><span class="line">      <span class="keyword">return</span> Result(count, average)  <span class="comment"># 在Python3.3之前，如果生成器返回值，解释器会报句法错误</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> coroaverager2 <span class="keyword">import</span> averager</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg = averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(coro_avg)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">6.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    coro_avg.send(<span class="literal">None</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> StopIteration <span class="keyword">as</span> exc:</span><br><span class="line"><span class="meta">... </span>    result = exc.value  <span class="comment"># 异常对象的value属性保存着返回的值</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result</span><br><span class="line">Result(count=<span class="number">3</span>, average=<span class="number">15.5</span>)</span><br></pre></td></tr></table></figure><p><strong>return表达式的值会偷偷传给调用方，赋值给StopIteration异常的一个属性。</strong>这样做有点不合常理，但是能保留生成器对象的常规行为——耗尽时抛出StopIteration异常。</p><p>获取协程的返回值虽然要饶个圈子，但这是PEP 380定义的方式，当我们意识到这一点后就说得通了：yield from结构会在内部自动捕获StopIteration异常。这种处理方式与for循环处理StopIteration异常的方式一样：循环机制使用用于易于理解的方式处理异常。对yield from结构来说，解释器不仅会捕获StopIteration异常，还会把value属性的值变成yield from表达式的值。</p><h1 id="使用yield-from">使用yield from</h1><p>yield from是全新的语言结构，它的作用比yield多很多。在生成器gen中使用yield from subgen()时，subgen会获得控制权，把产出的值传给gen的调用方，即调用方可以直接控制subgen。与此同时，gen会阻塞，等待subgen终止。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">'AB'</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">yield</span> c</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">3</span>):</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">yield</span> i</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(gen())</span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span>  <span class="comment"># 可以改写为</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="keyword">from</span> <span class="string">'AB'</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="keyword">from</span> range(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(gen())</span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">chain</span><span class="params">(*iterables)</span>:</span>  <span class="comment"># python版本的chain函数，原函数用C语言编写并且做了优化</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> it <span class="keyword">in</span> iterables:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">yield</span> <span class="keyword">from</span> it</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = tuple(range(<span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(chain(s, t))</span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>yield from x表达式对x对象所做的第一个件事是，调用iter(x)，从中获取迭代器。因此，x可以是任何可迭代的对象。</p><p>可是，如果yield from结构唯一的作用是替代产出值的潜逃for循环，这个结构很有可能不会添加到Python语言中。yield from结构的本质作用无法通过简单的可迭代对象说明，而要发散思维，使用嵌套的生成器。因此，引入yield from结构的“PEP 380才起了”Syntax for Delegatinig to a Subgenerator“（”把职责委托给子生成器的句法“）这个标题。</p><p><strong>yield from的主要功能是打开双向通道，把最外层的调用方与最内层的子生成器连接起来，这样二者可以直接发送和产出值，还可以直接传入异常，而不用在位于中间的协程中添加大量处理异常的样板代码。</strong>有个这个结构，协程可以通过以前不可能的方式委托职责。</p><p>若想使用yield from结构，就要大幅改动代码。为了说明需要改动的部分，PEP 380使用了一些专门的术语。</p><p>委派生成器：包含<code>yield from &lt;iterable&gt;</code>表达式的生成器函数。</p><p>子生成器：从yield from表达式中<code>&lt;iterable&gt;</code>部分获取的生成器。这就是PEP 380的标题中所说的子生成器（subgenerator）。</p><p>调用方：调用委派生成器的客户端代码。</p><p><img data-src="/uploads/posts/fluent-python/yield_from_at_work.png"></p><p>委派生成器在yield from表达式处暂停时，调用方可以直接把数据发给子生成器，子生成器再把产出的值发给调用方。子生成器返回之后，解释器会抛出StopIteration异常，并把返回值附加到异常对象上，此时委派生成器会恢复。</p><figure class="highlight python"><figcaption><span>coroaverager3.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Result = namedtuple(<span class="string">'Result'</span>, <span class="string">'count average'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">()</span>:</span>  <span class="comment"># 代码不变，这里作为子生成器使用</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">if</span> term <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 至关重要的终止条件。如果不这么做，使用yield from</span></span><br><span class="line">            <span class="keyword">break</span>         <span class="comment"># 调用这个协程的生成器会永远阻塞</span></span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br><span class="line">    <span class="keyword">return</span> Result(count, average)  <span class="comment"># 返回的Result会成为调用方中yield from表达式的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 委派生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grouper</span><span class="params">(results, key)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># grouper发送的每个值都会经由yield from处理，通过管道传给averager实例</span></span><br><span class="line">        <span class="comment"># grouper会在yield from表达式处暂停，等待averager实例处理客户端发来的值</span></span><br><span class="line">        <span class="comment"># averager实例运行完毕后，返回的值绑定到results[key]上</span></span><br><span class="line">        results[key] = <span class="keyword">yield</span> <span class="keyword">from</span> averager()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端代码，即调用方。这是驱动一切的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(data)</span>:</span></span><br><span class="line">    results = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key, values <span class="keyword">in</span> data.items():</span><br><span class="line">        group = grouper(results, key)  <span class="comment"># 创建group协程</span></span><br><span class="line">        next(group)  <span class="comment"># 预激</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> values:  <span class="comment"># 把各个value传给grouper。传入的值最终到达averager函数中term = yield那一行</span></span><br><span class="line">            group.send(value)  <span class="comment"># grouper永远不知道传入的值是什么</span></span><br><span class="line">        <span class="comment"># 把None传入grouper，导致当前的averager实例终止，也让grouper继续运行</span></span><br><span class="line">        <span class="comment"># 如果没有这一行，那么averager子生成器永远不会终止，委派生成器group永远不会再次激活</span></span><br><span class="line">        <span class="comment"># 因此永远不会为results[key]赋值</span></span><br><span class="line">        group.send(<span class="literal">None</span>)  </span><br><span class="line">    report(results)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出报告</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">report</span><span class="params">(results)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> key, result <span class="keyword">in</span> sorted(results.items()):</span><br><span class="line">        group, unit = key.split(<span class="string">';'</span>)</span><br><span class="line">        print(<span class="string">'&#123;:2&#125; &#123;:5&#125; averaging &#123;:.2f&#125;&#123;&#125;'</span>.format(</span><br><span class="line">            result.count, group, result.average, unit))</span><br><span class="line"></span><br><span class="line">data = &#123;  <span class="comment"># 男女学生的体重和身高</span></span><br><span class="line">    <span class="string">'girls;kg'</span>:</span><br><span class="line">        [<span class="number">40.9</span>, <span class="number">38.5</span>, <span class="number">44.3</span>, <span class="number">42.2</span>, <span class="number">45.2</span>, <span class="number">41.7</span>, <span class="number">44.5</span>, <span class="number">39.0</span>, <span class="number">40.6</span>, <span class="number">44.5</span>],</span><br><span class="line">    <span class="string">'girls;m'</span>:</span><br><span class="line">        [<span class="number">1.6</span>, <span class="number">1.51</span>, <span class="number">1.4</span>, <span class="number">1.3</span>, <span class="number">1.41</span>, <span class="number">1.39</span>, <span class="number">1.33</span>, <span class="number">1.46</span>, <span class="number">1.45</span>, <span class="number">1.43</span>],</span><br><span class="line">    <span class="string">'boys;kg'</span>:</span><br><span class="line">        [<span class="number">39.0</span>, <span class="number">40.8</span>, <span class="number">43.2</span>, <span class="number">40.8</span>, <span class="number">43.1</span>, <span class="number">38.6</span>, <span class="number">41.4</span>, <span class="number">40.6</span>, <span class="number">36.3</span>],</span><br><span class="line">    <span class="string">'boys;m'</span>:</span><br><span class="line">        [<span class="number">1.38</span>, <span class="number">1.5</span>, <span class="number">1.32</span>, <span class="number">1.25</span>, <span class="number">1.37</span>, <span class="number">1.48</span>, <span class="number">1.25</span>, <span class="number">1.49</span>, <span class="number">1.46</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main(data)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python coroaverager3.py</span><br><span class="line"> 9 boys  averaging 40.42kg</span><br><span class="line"> 9 boys  averaging 1.39m</span><br><span class="line">10 girls averaging 42.14kg</span><br><span class="line">10 girls averaging 1.43m</span><br></pre></td></tr></table></figure><p>grouper函数中循环的目的：在averager()返回结果，并将结果绑定到results[key]上之后，生成器能够继续运行至下一个yield处，而不是抛出StopIteration异常。如果不使用循环，下面的方法同样可以完成任务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grouper</span><span class="params">(results, key)</span>:</span></span><br><span class="line">    results[key] = <span class="keyword">yield</span> <span class="keyword">from</span> averager()</span><br><span class="line">    _ = <span class="keyword">yield</span>  <span class="comment"># group.send(None)之后，group会暂停在此处，然后调用方会重新</span></span><br><span class="line">               <span class="comment"># 创建grouper并绑定到group变量上，旧的grouper会被垃圾回收程序回收</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grouper</span><span class="params">(results, key)</span>:</span></span><br><span class="line">    results[key] = <span class="keyword">yield</span> <span class="keyword">from</span> averager()  <span class="comment"># 不做处理</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(data)</span>:</span></span><br><span class="line">    results = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key, values <span class="keyword">in</span> data.items():</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            group.send(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:  <span class="comment"># 在调用方捕获异常</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    report(results)</span><br></pre></td></tr></table></figure><p>示例展示了yield from结构最简单的用法，只有一个委派生成器和一个子生成器。因为委派生成器相当于管道，所以可以把任意数量个委派生成器连接在一起：一个委派生成器使用yield from调用一个子生成器，而那个子生成器本身也是委派生成器，使用yield from调用另一个子生成器，以此类推。最终，这个链条要以一个只使用yield表达式的简单生成器结束；不过，也能以任何可迭代的对象结束（yield from iterable）。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> coroutines </tag>
            
            <tag> yield </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上下文管理器和else块</title>
      <link href="/notes/fluent-python/context-managers-and-else-blocks/"/>
      <url>/notes/fluent-python/context-managers-and-else-blocks/</url>
      
        <content type="html"><![CDATA[<h1 id="if语句之外的else块">if语句之外的else块</h1><p>else子句不仅能在if语句中使用，还能在for、while和try语句中使用。for/else、while/else和try/else的语义关系紧密，不过与if/else差别很大。</p><p>for：仅当for循环运行完毕时（即for循环没有被break语句终止）才运行else块。</p><p>while：仅当while循环因为条件为假值而退出时（即while循环没有被break语句终止）才运行else块。</p><p>try：仅当try块中没有异常抛出时才运行else块。else子句抛出的异常不会由前面的except子句处理。</p><p>在所有情况下，如果异常或者return、break或continue语句导致控制权跳到了复合语句的主块之外，else子句也会被跳过。</p><p>在这些语句中使用else子句通常能让代码更易于阅读，而且能省去一些麻烦，不用设值控制标志或者添加额外的if语句。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在循环中使用else子句</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> my_list:</span><br><span class="line">    <span class="keyword">if</span> item.flavor == <span class="string">'banana'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">'No banana flavor found!'</span>)</span><br><span class="line"><span class="comment"># 这样呢，我就是不喜欢用for/else</span></span><br><span class="line">have_banana_flavor = any(item.flavor == <span class="string">'banana'</span> <span class="keyword">for</span> item <span class="keyword">in</span> my_list)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> have_banana_flavor:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">'No banana flavor found!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在try/except块中使用else子句</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    dangerous_call()</span><br><span class="line">    after_call()  <span class="comment"># after_call()不应该放在try块中，为了清晰和准确，try块中</span></span><br><span class="line"><span class="keyword">except</span> OSError:   <span class="comment"># 应该只包含抛出预期异常的语句</span></span><br><span class="line">    log(<span class="string">'OSError...'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因此，像下面这样写更好</span></span><br><span class="line"><span class="keyword">try</span>:  <span class="comment"># try块防守的是可能出现的错误</span></span><br><span class="line">    dangerous_call()</span><br><span class="line"><span class="keyword">except</span> OSError:</span><br><span class="line">    log(<span class="string">'OSError...'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    after_call()</span><br></pre></td></tr></table></figure><p>在Python中，try/except不仅用于处理错误，还常用于控制流程。为此，Python官方词汇表还定义了一个缩略词（口号）。</p><p><strong>EAFP</strong>：取得原谅比获得许可容易（easier to ask for forgiveness than permission）。这是一种常见的Python编程风格，先假定存在有效的键或属性，如果假定不成立，那么捕获异常。这种风格简单明快，特点是代码中有很多try和except语句。与其他很多语言一样，这种风格的对立面是LBYL风格。</p><p><strong>LBYL</strong>：三思而后行（look before you leap）。这种编程风格在调用函数或查找属性或键之前显式测试前提条件。与EAFP风格相反，这种风格的特点是代码中有很多if语句。在多线程环境中，LBYL风格可能会在“检查”和“行事”的空当引入条件竞争。例如，对if key in mapping: return mapping[key]这段代码来说，如果在测试之后，但是在查找之前，另一个线程从映射中删除了那个键，那么这段代码就会失败。这个问题可以用锁或者EAFP风格解决。如果选择EAFP风格，那就要更深入地了解else子句，并在try/except语句中合理使用。</p><h1 id="上下文管理器和with块">上下文管理器和with块</h1><p>上下文管理器对象存在的目的是管理with语句，就像迭代器的存在是为了管理for语句一样。</p><p>with语句的目的是简化try/finally模式。这种模式用于保证一段代码运行完毕后执行某项操作，即便那段代码由于异常、return语句或sys.exit()调用而中止，也会执行指定的操作。finally子句中的代码通常用于释放重要的资源，或者还原临时变更的状态。</p><p>上下文管理器协议包含<code>__enter__</code>和<code>__exit__</code>两个方法。with语句开始运行时，会在上下文管理器对象上调用<code>__enter__</code>方法。with语句运行结束后，会在上下文管理器对象上调用<code>__exit__</code>方法，以此扮演finally子句的角色。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最常见的例子是确保关闭文件对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'class.wsd'</span>) <span class="keyword">as</span> fp:  <span class="comment"># fp绑定到打开的文件上，因为文件的__enter__方法返回self</span></span><br><span class="line"><span class="meta">... </span>    src = fp.read(<span class="number">60</span>)  <span class="comment"># 读取一些数据</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(src)</span><br><span class="line"><span class="number">60</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp  <span class="comment"># fp仍然可用，与函数和模块不同，with块没有定义新的作用域</span></span><br><span class="line">&lt;_io.TextIOWrapper name=<span class="string">'class.wsd'</span> mode=<span class="string">'r'</span> encoding=<span class="string">'UTF-8'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp.closed, fp.encoding  <span class="comment"># 可以读取fp对象的属性</span></span><br><span class="line">(<span class="literal">True</span>, <span class="string">'UTF-8'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp.read(<span class="number">60</span>)  <span class="comment"># 但不能在fp上执行I/O操作，因为在with块的末尾，调用TextIOWrapper.__exit__方法把文件关闭了</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: I/O operation on closed file.</span><br></pre></td></tr></table></figure><p><strong>执行with后面的表达式得到的结果是上下文管理器对象，不过把值绑定到目标变量上（as子句）是在上下文管理器对象上调用<code>__enter__</code>方法的结果。</strong>碰巧，示例中的open()函数返回TextIOWrapper类的实例，而该实例的<code>__enter__</code>方法返回self。不过<code>__enter__</code>方法除了返回上下文管理器之外，还可能返回其他对象。</p><p>不管控制流程以哪种方式退出with块，都会在上下文管理器对象上调用<code>__exit__</code>方法，而不是在<code>__enter__</code>方法返回的对象上调用。</p><p>with语句的as子句是可选的。对open函数来说，必须加上as子句，以便获取文件的引用。不过，有些上下文管理器会返回None，因为没什么有用的对象能提供给用户。</p><figure class="highlight python"><figcaption><span>mirror.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LookingGlass</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">import</span> sys</span><br><span class="line">        self.original_write = sys.stdout.write</span><br><span class="line">        sys.stdout.write = self.reverse_write  <span class="comment"># 通过猴子补丁替换成自己的反向输出方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'ABCDE'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_write</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.original_write(text[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_value, traceback)</span>:</span>  <span class="comment"># 如果一切正常，传入的参数是None, None, None</span></span><br><span class="line">        <span class="keyword">import</span> sys</span><br><span class="line">        sys.stdout.write = self.original_write  <span class="comment"># 退出时再换回来</span></span><br><span class="line">        <span class="keyword">if</span> exc_type <span class="keyword">is</span> ZeroDivisionError:  <span class="comment"># 如果有ZeroDivisionError类型异常</span></span><br><span class="line">            print(<span class="string">'Please DO NOT divide by zero!'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span>  <span class="comment"># 返回True，告诉解释器，异常已经处理了</span></span><br><span class="line">        <span class="comment"># 如果__exit__方法返回None，或者True之外的值，with块中的任何异常都会向上冒泡</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> mirror <span class="keyword">import</span> LookingGlass</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> LookingGlass() <span class="keyword">as</span> what:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Hello World!'</span>)</span><br><span class="line"><span class="meta">... </span>    print(what)</span><br><span class="line">...</span><br><span class="line">!dlroW olleH  <span class="comment"># 在with块中输出的内容都是反向的</span></span><br><span class="line">EDCBA</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>what  <span class="comment"># __enter__返回的结果存在what变量中</span></span><br><span class="line"><span class="string">'ABCDE'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(what)  <span class="comment"># 输出不再反向了</span></span><br><span class="line">ABCDE</span><br></pre></td></tr></table></figure><p><strong>在实际使用中，如果应用程序接管了标准输出，可能会把sys.stdout换成类似文件的其他对象，然后再切换成原来的版本。</strong><a href="https://devdocs.io/python~3.6/library/contextlib#contextlib.redirect_stdout" target="_blank" rel="noopener">contextlib.redirect_stdout</a>上下文管理器就是这么做的：只需传入类似文件的对象，用于替代sys.stdout。</p><p>解释器调用<code>__enter__</code>方法时，除了隐式的self之外，不会传入任何参数。传给<code>__exit__</code>方法的三个参数如下：</p><p>exc_type：异常类（例如ZeroDivisionError）。</p><p>exc_value：异常实例。有时会有参数传给异常构造方法，例如错误消息，这些参数可以使用exc_value.args获取。</p><p>traceback：trackback对象。</p><p>在try/finally语句的finally块中调用sys.exc_info()得到的就是<code>__exit__</code>接收的这三个参数。鉴于with语句是为了取代大多数try/finally语句，而且通常需要调用sys.exc_info()来判断做什么清理操作，这种行为是合理的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上下文管理器的具体工作方式</span></span><br><span class="line"><span class="comment"># 在这个示例中，我们在with块之外使用LookingGlass类</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>manager = LookingGlass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>manager</span><br><span class="line">&lt;mirror.LookingGlass object at <span class="number">0x104f5f390</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>monster = manager.__enter__()  <span class="comment"># 从此进入镜中世界</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>monster</span><br><span class="line"><span class="string">'EDCBA'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>monster == <span class="string">'ABCDE'</span></span><br><span class="line">eurT</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>manager</span><br><span class="line">&gt;<span class="number">093</span>f5f401x0 ta tcejbo ssalGgnikooL.rorrim&lt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>manager.__exit__(<span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>)  <span class="comment"># 退出</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>monster</span><br><span class="line"><span class="string">'ABCDE'</span></span><br></pre></td></tr></table></figure><h1 id="contextlib模块中的实用工具">contextlib模块中的实用工具</h1><p>除了前面提到的redirect_stdout函数，contextlib模块中还有一些类和其他函数，使用范围更广。</p><p>closing：如果对象提供了close()方法，但没有实现<code>__enter__/__exit__</code>协议，那么可以使用这个函数构建上下文管理器。</p><p>suppress：构建临时忽略指定异常的上下文管理器。</p><p><span class="citation" data-cites="contextmanager">@contextmanager</span>：这个装饰器把简单的生成器函数变成上下文管理器，这样就不用创建类去实现管理器协议了。</p><p>ContextDecorator：这是个基类，用于定义基于类的上下文管理器。这种上下文管理器也能用于装饰器函数，在受管理的上下文中运行整个函数。</p><p>ExitStack：这个上下文管理器能进入多个上下文管理器。with块结束时，ExitStack按照后进先出的顺序调用栈中各个上下文管理器的<code>__exit__</code>方法。如果事先不知道with块要进入多少个上下文管理器，可以使用这个类。例如，同时打开任意一个文件列表中的所有文件。</p><p>在这些实用工具中，使用最广泛的是@contextmanager装饰器。这个装饰器也有迷惑人的一面，因为它与迭代无关，却要使用yield语句。</p><h1 id="使用contextmanager">使用@contextmanager</h1><p><span class="citation" data-cites="contextmanager装饰器能减少创建上下文管理器的样板代码量">@contextmanager装饰器能减少创建上下文管理器的样板代码量</span>，因为不用编写一个完整的类，定义<code>__enter__</code>和<code>__exit__</code>方法，而只需实现有一个yield语句的生成器，生成想让<code>__enter__</code>方法返回的值。</p><p>在使用@contextmanager装饰的生成器中，yield语句的作用是把函数的定义体分成两部分：yield语句前面的所有代码在with块开始时（即解释器调用<code>__enter__</code>方法时）执行，yield语句后面的代码在with块结束时（即调用<code>__exit__</code>方法时）执行。</p><figure class="highlight python"><figcaption><span>mirror_gen.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextlib.contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">looking_glass</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    original_write = sys.stdout.write</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_write</span><span class="params">(text)</span>:</span></span><br><span class="line">        original_write(text[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    sys.stdout.write = reverse_write</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'ABCDE'</span></span><br><span class="line">    sys.stdout.write = original_write</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> mirror_gen <span class="keyword">import</span> looking_glass</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> looking_glass() <span class="keyword">as</span> what:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Hello World!'</span>)</span><br><span class="line"><span class="meta">... </span>    print(what)</span><br><span class="line">...</span><br><span class="line">!dlroW olleH</span><br><span class="line">EDCBA</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>what</span><br><span class="line"><span class="string">'ABCDE'</span></span><br></pre></td></tr></table></figure><p>其实，contextlib.contextmanager装饰器会把函数包含成实现<code>__enter__</code>和<code>__exit__</code>方法的类。这个类的<code>__enter__</code>方法有如下作用：</p><ol type="1"><li>调用生成器函数，保存生成器对象（这里把它称为gen）。</li><li>调用next(gen)，执行到yield关键字所在的位置。</li><li>返回next(gen)产出的值，以便把产出的值绑定到with/as语句中的目标变量上。</li></ol><p>with块终止时，<code>__exit__</code>方法会做以下几件事：</p><ol type="1"><li>检查有没有把异常传给exc_type；如果有，调用gen.throw(exception)，在生成器函数定义体中包含yield关键字的那一行抛出异常。</li><li>否则，调用next(gen)，继续执行生成器函数定义体中yield语句之后的代码。</li></ol><p>上述示例中有一个严重的错误：如果在with块中抛出了异常，Python解释器会将其捕获，然后再looking_glass函数的yield表达式里再次抛出。但是，那里没有处理错误的代码，因此looking_glass函数会终止，永远无法恢复成原来的sys.stdout.write方法，导致系统处于无效状态。</p><p>下面的实例中添加了一些代码，特别用于处理ZeroDivisionError异常；这样，在功能上它就与基于类的实现等效了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextlib.contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">looking_glass</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    original_write = sys.stdout.write</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_write</span><span class="params">(text)</span>:</span></span><br><span class="line">        original_write(text[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    sys.stdout.write = reverse_write</span><br><span class="line">    msg = <span class="string">''</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">'ABCDE'</span></span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        msg = <span class="string">'Please DO NOT divide by zero!'</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        sys.stdout.write = original_write  <span class="comment"># 撤销猴子补丁</span></span><br><span class="line">        <span class="keyword">if</span> msg:  <span class="comment"># 有错误消息就输出</span></span><br><span class="line">            print(msg)</span><br></pre></td></tr></table></figure><p>前面说过，为了告诉解释器异常已经处理了，<code>__exit__</code>方法会返回True，此时解释器会压制异常。如果<code>__exit__</code>方法没有显式返回一个值，那么解释器得到的是None，然后向上冒泡异常。<strong>使用@contextmanager装饰器时，默认的行为是相反的：装饰器提供的<code>__exit__</code>方法假定发给生成器的所有异常都得到处理了，因此应该压制异常。</strong>如果不想让@contextmanager压制异常，必须在被装饰的函数中显式重新抛出异常。</p><p><strong>使用@contextmanager装饰器时，要把yield语句放在try/finally语句中（或者放在with语句中），这是无法避免的，因为我们永远不知道上下文管理器的用户会在with块中做什么。</strong></p><p>除了标准库中举的例子之外，Martijn Pieters实现的原地文件重写上下文管理器<a href="http://www.zopatista.com/python/2013/11/26/inplace-file-rewriting/" target="_blank" rel="noopener"><code>inplace</code></a>是@contextmanager不错的使用实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用inplace上下文管理器，它为同一个文件提供了两个句柄，以便同时读写同一个文件</span></span><br><span class="line"><span class="keyword">with</span> inplace(csvfilename, <span class="string">'r'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> (infh, outfh):</span><br><span class="line">    reader = csv.reader(infh)</span><br><span class="line">    writer = csv.writer(outfh)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        row += [<span class="string">'new'</span>, <span class="string">'columns'</span>]</span><br><span class="line">        writer.writerow(row)</span><br></pre></td></tr></table></figure><p><strong>在@contextmanager装饰器装饰的生成器中，yield与迭代没有任何关系。</strong>在本节所举的示例中，生成器函数的作用更像是协程：执行到某一点时暂停，让客户代码运行，直到客服让协程继续做事。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> contextlib </tag>
            
            <tag> with </tag>
            
            <tag> for/else </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标准库中的生成器函数</title>
      <link href="/notes/fluent-python/generator-functions-in-standard-library/"/>
      <url>/notes/fluent-python/generator-functions-in-standard-library/</url>
      
        <content type="html"><![CDATA[<p>本节专注于通用的函数：参数为任意的可迭代对象，返回值是生成器，用于生成选中的、计算出的和重新排列的元素。</p><h1 id="用于过滤">用于过滤</h1><p>从输入的可迭代对象中产出元素的子集，而且不修改元素本身。</p><table><colgroup><col style="width: 10%"><col style="width: 20%"><col style="width: 70%"></colgroup><thead><tr class="header"><th>模块</th><th>函数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>itertools</code></td><td><code>compress(it, selector_it)</code></td><td>并行处理两个可迭代对象；如果selector_it中的元素是真值，产出it中对应的元素</td></tr><tr class="even"><td><code>itertools</code></td><td><a href="https://devdocs.io/python~3.6/library/itertools#itertools.dropwhile" target="_blank" rel="noopener"><code>dropwhile(predicate, it)</code></a></td><td>扔掉满足条件的元素，predicate首次返回Flase时，停止检查，产出后续元素（不再检查）</td></tr><tr class="odd"><td>内置</td><td><code>filter(predicate, it)</code></td><td>把it中的各个元素传给predicate，如果predicate(item)返回真值，那么产出对应的元素；如果predicate是None，那么只产出真值元素</td></tr><tr class="even"><td><code>itertools</code></td><td><code>filterfalse(predicate, it)</code></td><td>与filter函数的作用类似，不过predicate的逻辑是相反的：predicate返回假值时产出对应的元素</td></tr><tr class="odd"><td><code>itertools</code></td><td><code>islice(it, stop)</code>或<code>islice(it, start, stop, step=1</code></td><td>产出it的切片，作用类似于s[:stop]或s[start:stop:step]，不过it可以是任何可迭代的对象，而且这个函数实现的是惰性操作</td></tr><tr class="even"><td><code>itertools</code></td><td><a href="https://devdocs.io/python~3.6/library/itertools#itertools.takewhile" target="_blank" rel="noopener"><code>takewhile(predicate, it)</code></a></td><td>产出满足条件的元素，predicate首次返回False时立即停止，不产出后续元素</td></tr></tbody></table><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">vowel</span><span class="params">(c)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> c.lower() <span class="keyword">in</span> <span class="string">'aeiou'</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(filter(vowel, <span class="string">'Aardvark'</span>))</span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> itertools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.filterfalse(vowel, <span class="string">'Aardvark'</span>))</span><br><span class="line">[<span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'v'</span>, <span class="string">'r'</span>, <span class="string">'k'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.dropwhile(vowel, <span class="string">'Aardvark'</span>))</span><br><span class="line">[<span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'v'</span>, <span class="string">'a'</span>, <span class="string">'r'</span>, <span class="string">'k'</span>]  <span class="comment"># 'r'是首个不满足条件的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.takewhile(vowel, <span class="string">'Aardvark'</span>))</span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'a'</span>]  <span class="comment"># 'A', 'a'都满足条件，'r'是首个不满足条件的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.compress(<span class="string">'Aardvark'</span>, (<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>)))</span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.islice(<span class="string">'Aardvark'</span>, <span class="number">4</span>))</span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'a'</span>, <span class="string">'r'</span>, <span class="string">'d'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.islice(<span class="string">'Aardvark'</span>, <span class="number">4</span>, <span class="number">7</span>))</span><br><span class="line">[<span class="string">'v'</span>, <span class="string">'a'</span>, <span class="string">'r'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.islice(<span class="string">'Aardvark'</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>))</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>]</span><br></pre></td></tr></table></figure><h1 id="用于映射">用于映射</h1><table><colgroup><col style="width: 10%"><col style="width: 20%"><col style="width: 70%"></colgroup><thead><tr class="header"><th>模块</th><th>函数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>itertools</code></td><td><code>accumulate(it, [func]</code></td><td>产出累计的总和；如果提供了func，那么把前两个元素传给它，然后把计算结果和下一个元素传给它，以此类推，最后产出结果</td></tr><tr class="even"><td>内置</td><td><code>enumerate(iterable, start=0)</code></td><td>产出由两个元素构成的元素，结构是(index, item)，其中index从start开始计数，item则从iterable中获取</td></tr><tr class="odd"><td>内置</td><td><code>map(func, it1, [it2, ..., itN])</code></td><td>把it中的各个元素传给func，产出结果；如果传入N个可迭代的对象，那么func必须能接受N个参数，而且要并行处理各个可迭代的对象</td></tr><tr class="even"><td><code>itertools</code></td><td><code>starmap(func, it)</code></td><td>把it中的各个元素传给func，产出结果；输入的可迭代对象应该产出可迭代的元素iit，然后以func(*iit)这种形式调用func</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sample = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.accumulate(sample))  <span class="comment"># 累加</span></span><br><span class="line">[<span class="number">5</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">32</span>, <span class="number">35</span>, <span class="number">35</span>, <span class="number">44</span>, <span class="number">45</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.accumulate(sample, min))  <span class="comment"># 计算最小值</span></span><br><span class="line">[<span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.accumulate(sample, max))  <span class="comment"># 计算最大值</span></span><br><span class="line">[<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> operator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.accumulate(sample, operator.mul))  <span class="comment"># 累乘</span></span><br><span class="line">[<span class="number">5</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">320</span>, <span class="number">2240</span>, <span class="number">13440</span>, <span class="number">40320</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.accumulate(range(<span class="number">1</span>, <span class="number">11</span>), operator.mul))  <span class="comment"># 从1!到10!</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>, <span class="number">720</span>, <span class="number">5040</span>, <span class="number">40320</span>, <span class="number">362880</span>, <span class="number">3628800</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(enumerate(<span class="string">'albatroz'</span>, <span class="number">1</span>))</span><br><span class="line">[(<span class="number">1</span>, <span class="string">'a'</span>), (<span class="number">2</span>, <span class="string">'l'</span>), (<span class="number">3</span>, <span class="string">'b'</span>), (<span class="number">4</span>, <span class="string">'a'</span>), (<span class="number">5</span>, <span class="string">'t'</span>), (<span class="number">6</span>, <span class="string">'r'</span>), (<span class="number">7</span>, <span class="string">'o'</span>), (<span class="number">8</span>, <span class="string">'z'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(operator.mul, range(<span class="number">11</span>), range(<span class="number">11</span>)))  <span class="comment"># 0到10的平方</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(operator.mul, range(<span class="number">11</span>), [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>]))  <span class="comment"># 短的iterator结束时停止</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">4</span>, <span class="number">16</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(<span class="keyword">lambda</span> a, b: (a, b), range(<span class="number">11</span>), [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>]))  <span class="comment"># 等同于zip</span></span><br><span class="line">[(<span class="number">0</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">8</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.starmap(operator.mul, enumerate(<span class="string">'albatroz'</span>, <span class="number">1</span>)))  <span class="comment"># 根据所在位置重复相应次数</span></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'ll'</span>, <span class="string">'bbb'</span>, <span class="string">'aaaa'</span>, <span class="string">'ttttt'</span>, <span class="string">'rrrrrr'</span>, <span class="string">'ooooooo'</span>, <span class="string">'zzzzzzzz'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.starmap(<span class="keyword">lambda</span> a, b: b/a,</span><br><span class="line"><span class="meta">... </span>    enumerate(itertools.accumulate(sample), <span class="number">1</span>)))  <span class="comment"># 计算均值</span></span><br><span class="line">[<span class="number">5.0</span>, <span class="number">4.5</span>, <span class="number">3.6666666666666665</span>, <span class="number">4.75</span>, <span class="number">5.2</span>, <span class="number">5.333333333333333</span>, <span class="number">5.0</span>, <span class="number">4.375</span>, <span class="number">4.888888888888889</span>, <span class="number">4.5</span>]</span><br></pre></td></tr></table></figure><h1 id="用于合并">用于合并</h1><table><colgroup><col style="width: 10%"><col style="width: 20%"><col style="width: 70%"></colgroup><thead><tr class="header"><th>模块</th><th>函数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>itertools</code></td><td><code>chain(it1, ..., itN)</code></td><td>先产出it1中的所有元素，然后产出it2中的所有元素，以此类推，无缝连接在一起</td></tr><tr class="even"><td><code>itertools</code></td><td><code>chain.from_iterable(it)</code></td><td>产出it生成的各个可迭代对象中的元素，一个接一个，无缝连接在一起；it应该产出可迭代元素，例如可迭代的对象列表</td></tr><tr class="odd"><td><code>itertools</code></td><td><code>product(it1, ..., itN, repeat=1)</code></td><td>计算笛卡尔积：从输入的各个可迭代元素中获取元素，合并成由N个元素组成的元组，与嵌套的for循环效果一样；repeat指明重复处理多少次输入的可迭代对象</td></tr><tr class="even"><td>内置</td><td><code>zip(it1, ..., itN)</code></td><td>并行从输入的各个可迭代对象中获取元素，产出由N个元素组成的元组，只要有一个可迭代的对象到头了，就默默地停止</td></tr><tr class="odd"><td><code>itertools</code></td><td><code>zip_longest(it1, ..., itN, fillvalue=None)</code></td><td>并行从输入的各个可迭代对象中获取元素，产出由N个元素组成的元组，等到最长的可迭代对象到头后才停止，空缺的值使用fillvalue填充</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.chain(<span class="string">'ABC'</span>, range(<span class="number">2</span>)))</span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.chain(enumerate(<span class="string">'ABC'</span>)))  <span class="comment"># 如果只传入一个可迭代的对象，那么chain函数没什么用</span></span><br><span class="line">[(<span class="number">0</span>, <span class="string">'A'</span>), (<span class="number">1</span>, <span class="string">'B'</span>), (<span class="number">2</span>, <span class="string">'C'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.chain.from_iterable(enumerate(<span class="string">'ABC'</span>)))  <span class="comment"># 各元素本身必须是可迭代对象</span></span><br><span class="line">[<span class="number">0</span>, <span class="string">'A'</span>, <span class="number">1</span>, <span class="string">'B'</span>, <span class="number">2</span>, <span class="string">'C'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(<span class="string">'ABC'</span>, range(<span class="number">5</span>)))</span><br><span class="line">[(<span class="string">'A'</span>, <span class="number">0</span>), (<span class="string">'B'</span>, <span class="number">1</span>), (<span class="string">'C'</span>, <span class="number">2</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(<span class="string">'ABC'</span>, range(<span class="number">5</span>), [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]))  <span class="comment"># 最短的iterator到头时停止</span></span><br><span class="line">[(<span class="string">'A'</span>, <span class="number">0</span>, <span class="number">10</span>), (<span class="string">'B'</span>, <span class="number">1</span>, <span class="number">20</span>), (<span class="string">'C'</span>, <span class="number">2</span>, <span class="number">30</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.zip_longest(<span class="string">'ABC'</span>, range(<span class="number">5</span>)))  <span class="comment"># 最长的iterator到头时停止，默认用None填充空缺的值</span></span><br><span class="line">[(<span class="string">'A'</span>, <span class="number">0</span>), (<span class="string">'B'</span>, <span class="number">1</span>), (<span class="string">'C'</span>, <span class="number">2</span>), (<span class="literal">None</span>, <span class="number">3</span>), (<span class="literal">None</span>, <span class="number">4</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.zip_longest(<span class="string">'ABC'</span>, range(<span class="number">5</span>), fillvalue=<span class="string">'?'</span>))  <span class="comment"># 使用指定字符填充</span></span><br><span class="line">[(<span class="string">'A'</span>, <span class="number">0</span>), (<span class="string">'B'</span>, <span class="number">1</span>), (<span class="string">'C'</span>, <span class="number">2</span>), (<span class="string">'?'</span>, <span class="number">3</span>), (<span class="string">'?'</span>, <span class="number">4</span>)]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.product(<span class="string">'ABC'</span>, range(<span class="number">2</span>)))  <span class="comment"># 生成3*2个元组</span></span><br><span class="line">[(<span class="string">'A'</span>, <span class="number">0</span>), (<span class="string">'A'</span>, <span class="number">1</span>), (<span class="string">'B'</span>, <span class="number">0</span>), (<span class="string">'B'</span>, <span class="number">1</span>), (<span class="string">'C'</span>, <span class="number">0</span>), (<span class="string">'C'</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>suits = <span class="string">'spades hearts diamonds clubs'</span>.split()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.product(<span class="string">'AK'</span>, suits))</span><br><span class="line">[(<span class="string">'A'</span>, <span class="string">'spades'</span>), (<span class="string">'A'</span>, <span class="string">'hearts'</span>), (<span class="string">'A'</span>, <span class="string">'diamonds'</span>), (<span class="string">'A'</span>, <span class="string">'clubs'</span>), (<span class="string">'K'</span>, <span class="string">'spades'</span>), (<span class="string">'K'</span>, <span class="string">'hearts'</span>), (<span class="string">'K'</span>, <span class="string">'diamonds'</span>), (<span class="string">'K'</span>, <span class="string">'clubs'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.product(<span class="string">'ABC'</span>))  <span class="comment"># 如果传入一个可迭代的对象，产出的是一系列只有一个元素的元组，不是特别有用</span></span><br><span class="line">[(<span class="string">'A'</span>,), (<span class="string">'B'</span>,), (<span class="string">'C'</span>,)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.product(<span class="string">'ABC'</span>, repeat=<span class="number">2</span>))  <span class="comment"># 重复2次</span></span><br><span class="line">[(<span class="string">'A'</span>, <span class="string">'A'</span>), (<span class="string">'A'</span>, <span class="string">'B'</span>), (<span class="string">'A'</span>, <span class="string">'C'</span>), (<span class="string">'B'</span>, <span class="string">'A'</span>), (<span class="string">'B'</span>, <span class="string">'B'</span>), (<span class="string">'B'</span>, <span class="string">'C'</span>), (<span class="string">'C'</span>, <span class="string">'A'</span>), (<span class="string">'C'</span>, <span class="string">'B'</span>), (<span class="string">'C'</span>, <span class="string">'C'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.product(range(<span class="number">2</span>), repeat=<span class="number">3</span>))</span><br><span class="line">[(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rows = itertools.product(<span class="string">'AB'</span>, range(<span class="number">2</span>), repeat=<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> row <span class="keyword">in</span> rows: print(row)</span><br><span class="line">...</span><br><span class="line">(<span class="string">'A'</span>, <span class="number">0</span>, <span class="string">'A'</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="string">'A'</span>, <span class="number">0</span>, <span class="string">'A'</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="string">'A'</span>, <span class="number">0</span>, <span class="string">'B'</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="string">'A'</span>, <span class="number">0</span>, <span class="string">'B'</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="string">'A'</span>, <span class="number">1</span>, <span class="string">'A'</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="string">'A'</span>, <span class="number">1</span>, <span class="string">'A'</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="string">'A'</span>, <span class="number">1</span>, <span class="string">'B'</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="string">'A'</span>, <span class="number">1</span>, <span class="string">'B'</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="string">'B'</span>, <span class="number">0</span>, <span class="string">'A'</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="string">'B'</span>, <span class="number">0</span>, <span class="string">'A'</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="string">'B'</span>, <span class="number">0</span>, <span class="string">'B'</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="string">'B'</span>, <span class="number">0</span>, <span class="string">'B'</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="string">'B'</span>, <span class="number">1</span>, <span class="string">'A'</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="string">'B'</span>, <span class="number">1</span>, <span class="string">'A'</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="string">'B'</span>, <span class="number">1</span>, <span class="string">'B'</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="string">'B'</span>, <span class="number">1</span>, <span class="string">'B'</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h1 id="用于扩展元素">用于扩展元素</h1><table><colgroup><col style="width: 10%"><col style="width: 20%"><col style="width: 70%"></colgroup><thead><tr class="header"><th>模块</th><th>函数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>itertools</code></td><td><code>combinations(it, out_len)</code></td><td>把it产出的out_len个元素组合在一起，然后产出</td></tr><tr class="even"><td><code>itertools</code></td><td><code>combinations_with_replacement(it, out_len)</code></td><td>把it产出的out_len个元素组合在一起，然后产出，包含相同元素的组合</td></tr><tr class="odd"><td><code>itertools</code></td><td><code>count(start=0, step=1)</code></td><td>从start开始不断产出数字，按step指定的步幅增加</td></tr><tr class="even"><td><code>itertools</code></td><td><code>cycle(it)</code></td><td>从it中产出各个元素，存储各个元素的副本，然后按顺序重复不断地产出各个元素</td></tr><tr class="odd"><td><code>itertools</code></td><td><code>permutations(it, out_len=None)</code></td><td>把out_len个it产出的元素排列在一起，然后产出这些排列；out_len的默认值等于len(list(it))</td></tr><tr class="even"><td><code>itertools</code></td><td><code>repeat(item, [times])</code></td><td>重复不断地产出指定的元素，除非提供times，指定次数</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct = itertools.count()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(ct), next(ct), next(ct)  <span class="comment"># 不能使用ct构建列表，因为ct是无穷的</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)                                              <span class="comment"># 如果使用islice或takewhile函数，</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.islice(itertools.count(<span class="number">1</span>, <span class="number">.3</span>), <span class="number">3</span>))  <span class="comment"># 可以从count生成器中构建列表</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">1.3</span>, <span class="number">1.6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cy = itertools.cycle(<span class="string">'ABC'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.islice(cy, <span class="number">7</span>))  <span class="comment"># cy同样是无穷的</span></span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'A'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rp = itertools.repeat(<span class="number">7</span>)  <span class="comment"># 无限产出7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(rp), next(rp)</span><br><span class="line">(<span class="number">7</span>, <span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.repeat(<span class="number">8</span>, <span class="number">4</span>))  <span class="comment"># 限制次数</span></span><br><span class="line">[<span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(operator.mul, range(<span class="number">11</span>), itertools.repeat(<span class="number">5</span>)))  <span class="comment"># 乘数固定为5</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">50</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.combinations(<span class="string">'ABC'</span>, <span class="number">2</span>))  <span class="comment"># 不同元素的组合，次序不重要</span></span><br><span class="line">[(<span class="string">'A'</span>, <span class="string">'B'</span>), (<span class="string">'A'</span>, <span class="string">'C'</span>), (<span class="string">'B'</span>, <span class="string">'C'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.combinations_with_replacement(<span class="string">'ABC'</span>, <span class="number">2</span>))  <span class="comment"># 可包含相同元素的组合</span></span><br><span class="line">[(<span class="string">'A'</span>, <span class="string">'A'</span>), (<span class="string">'A'</span>, <span class="string">'B'</span>), (<span class="string">'A'</span>, <span class="string">'C'</span>), (<span class="string">'B'</span>, <span class="string">'B'</span>), (<span class="string">'B'</span>, <span class="string">'C'</span>), (<span class="string">'C'</span>, <span class="string">'C'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.permutations(<span class="string">'ABC'</span>, <span class="number">2</span>))  <span class="comment"># 排列，次序重要</span></span><br><span class="line">[(<span class="string">'A'</span>, <span class="string">'B'</span>), (<span class="string">'A'</span>, <span class="string">'C'</span>), (<span class="string">'B'</span>, <span class="string">'A'</span>), (<span class="string">'B'</span>, <span class="string">'C'</span>), (<span class="string">'C'</span>, <span class="string">'A'</span>), (<span class="string">'C'</span>, <span class="string">'B'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.product(<span class="string">'ABC'</span>, repeat=<span class="number">2</span>))  <span class="comment"># 'ABC'和'ABC'（repeat=2的效果）的笛卡尔积</span></span><br><span class="line">[(<span class="string">'A'</span>, <span class="string">'A'</span>), (<span class="string">'A'</span>, <span class="string">'B'</span>), (<span class="string">'A'</span>, <span class="string">'C'</span>), (<span class="string">'B'</span>, <span class="string">'A'</span>), (<span class="string">'B'</span>, <span class="string">'B'</span>), (<span class="string">'B'</span>, <span class="string">'C'</span>), (<span class="string">'C'</span>, <span class="string">'A'</span>), (<span class="string">'C'</span>, <span class="string">'B'</span>), (<span class="string">'C'</span>, <span class="string">'C'</span>)]</span><br></pre></td></tr></table></figure><h1 id="用于重新排列元素">用于重新排列元素</h1><table><colgroup><col style="width: 10%"><col style="width: 20%"><col style="width: 70%"></colgroup><thead><tr class="header"><th>模块</th><th>函数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>itertools</code></td><td><code>groupby(it, key=None)</code></td><td>产出由两个元素组成的元素，形式为(key, group)，其中key是分组标准，group是生成器，用于产出分组里的元素</td></tr><tr class="even"><td>内置</td><td><code>reversed(seq)</code></td><td>从后向前，倒序产出seq中的元素；seq必须是序列，或者是实现了<code>__reversed__</code>特殊方法的对象</td></tr><tr class="odd"><td><code>itertools</code></td><td><code>tee(it, n=2)</code></td><td>产出一个由n个生成器组成的元组，每个生成器用于单独产出输入的可迭代对象中的元素</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.groupby(<span class="string">'LLLLAAGGG'</span>))</span><br><span class="line">[(<span class="string">'L'</span>, &lt;itertools._grouper object at <span class="number">0x103db4710</span>&gt;), (<span class="string">'A'</span>, &lt;itertools._grouper object at <span class="number">0x103db4390</span>&gt;), (<span class="string">'G'</span>, &lt;itertools._grouper object at <span class="number">0x103db4748</span>&gt;)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> char, group <span class="keyword">in</span> itertools.groupby(<span class="string">'LLLLAAGGG'</span>):</span><br><span class="line"><span class="meta">... </span>    print(char, <span class="string">'-&gt;'</span>, list(group))</span><br><span class="line">...</span><br><span class="line">L -&gt; ['L', 'L', 'L', 'L']</span><br><span class="line">A -&gt; ['A', 'A']</span><br><span class="line">G -&gt; ['G', 'G', 'G']</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>animals = [<span class="string">'duck'</span>, <span class="string">'eagle'</span>, <span class="string">'rat'</span>, <span class="string">'giraffe'</span>, <span class="string">'bear'</span>,</span><br><span class="line"><span class="meta">... </span>            <span class="string">'bat'</span>, <span class="string">'dolphin'</span>, <span class="string">'shark'</span>, <span class="string">'lion'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>animals.sort(key=len)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>animals</span><br><span class="line">[<span class="string">'rat'</span>, <span class="string">'bat'</span>, <span class="string">'duck'</span>, <span class="string">'bear'</span>, <span class="string">'lion'</span>, <span class="string">'eagle'</span>, <span class="string">'shark'</span>, <span class="string">'giraffe'</span>, <span class="string">'dolphin'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> length, group <span class="keyword">in</span> itertools.groupby(animals, len):</span><br><span class="line"><span class="meta">... </span>    print(length, <span class="string">'-&gt;'</span>, list(group))</span><br><span class="line">...</span><br><span class="line">3 -&gt; ['rat', 'bat']</span><br><span class="line">4 -&gt; ['duck', 'bear', 'lion']</span><br><span class="line">5 -&gt; ['eagle', 'shark']</span><br><span class="line">7 -&gt; ['giraffe', 'dolphin']</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> length, group <span class="keyword">in</span> itertools.groupby(reversed(animals), len):</span><br><span class="line"><span class="meta">... </span>    print(length, <span class="string">'-&gt;'</span>, list(group))</span><br><span class="line">...</span><br><span class="line">7 -&gt; ['dolphin', 'giraffe']</span><br><span class="line">5 -&gt; ['shark', 'eagle']</span><br><span class="line">4 -&gt; ['lion', 'bear', 'duck']</span><br><span class="line">3 -&gt; ['bat', 'rat']</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.tee(<span class="string">'ABC'</span>))</span><br><span class="line">[&lt;itertools._tee object at <span class="number">0x103db68c8</span>&gt;, &lt;itertools._tee object at <span class="number">0x103db6788</span>&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g1, g2 = itertools.tee(<span class="string">'ABC'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g1), next(g2)</span><br><span class="line">(<span class="string">'A'</span>, <span class="string">'A'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g2)</span><br><span class="line"><span class="string">'B'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(g1)</span><br><span class="line">[<span class="string">'B'</span>, <span class="string">'C'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(g2)</span><br><span class="line">[<span class="string">'C'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(*itertools.tee(<span class="string">'ABC'</span>)))</span><br><span class="line">[(<span class="string">'A'</span>, <span class="string">'A'</span>), (<span class="string">'B'</span>, <span class="string">'B'</span>), (<span class="string">'C'</span>, <span class="string">'C'</span>)]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> generators </tag>
            
            <tag> itertools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可迭代对象、迭代器和生成器</title>
      <link href="/notes/fluent-python/iterables-iterators-and-generators/"/>
      <url>/notes/fluent-python/iterables-iterators-and-generators/</url>
      
        <content type="html"><![CDATA[<h1 id="sentence类第1版单词序列">Sentence类第1版：单词序列</h1><figure class="highlight python"><figcaption><span>sentence.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">        self.words = RE_WORD.findall(text)  <span class="comment"># 返回全部菲重叠匹配</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.words[index]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.words)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Sentence(%s)'</span> % reprlib.repr(self.text)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sentence <span class="keyword">import</span> Sentence</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Sentence(<span class="string">'"The time has come," the Walrus said,'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">Sentence(<span class="string">'"The time ha... Walrus said,'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(s)  <span class="comment"># Sentence实例是可迭代的，因此可以用于构建列表和其他可迭代的类型</span></span><br><span class="line">[<span class="string">'The'</span>, <span class="string">'time'</span>, <span class="string">'has'</span>, <span class="string">'come'</span>, <span class="string">'the'</span>, <span class="string">'Walrus'</span>, <span class="string">'said'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(s, abc.Iterable)  <span class="comment"># 虽然可以迭代，但无法通过isinstance检测</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(Sentence, abc.Iterable)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>解释器需要迭代对象x时，会自动调用iter(x)。内置的iter函数有以下作用。</p><ol type="1"><li>检查对象是否实现了<code>__iter__</code>方法，如果实现了就调用它，获取一个迭代器。</li><li>如果没有实现<code>__iter__</code>方法，但是实现了<code>__getitem__</code>方法，Python会创建一个迭代器，尝试按顺序获取元素。</li><li>如果尝试失败，Python抛出TypeError异常，通常会提示“C object is not iterable”，其中C是目标对象所属的类。</li></ol><p>任何Python序列都可迭代的原因是，它们都实现了<code>__getitem__</code>方法。其实，标准的序列也都实现了<code>__iter__</code>方法，因此你也应该这么做。之所以对<code>__getitem__</code>方法做特殊处理，是为了向后兼容，而未来可能不会再这么做。</p><p>因为abc.Iterable类实现了<code>__subclasshook__</code>方法，该方法将定义了<code>__iter__</code>方法的类认作自己的虚拟子类。因此，虽然Sentence类可以迭代，但是无法通过issubclass(Sentence, abc.Iterable)测试。</p><p><strong>从Python3.4开始，检查对象x能否迭代，最准确的方法是：调用iter(x)函数，如果不可迭代，再处理TypeError异常。</strong>这比使用isinstance(x, abc.Iterable)更准确，因为iter(x)函数会考虑到遗留的<code>__getitem__</code>方法，而abc.Iterable类则不考虑。</p><h2 id="可迭代的对象与迭代器的对比">可迭代的对象与迭代器的对比</h2><p>可迭代的对象：使用iter内置函数可以获取迭代器的对象。如果对象实现了能返回迭代器的<code>__iter__</code>方法，那么对象就是可迭代的。序列都可以迭代；实现了<code>__getitem__</code>方法，而且其参数是从零开始的索引，这种对象也可以迭代。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> char <span class="keyword">in</span> s:  <span class="comment"># 使用for循环迭代，背后有迭代器，但是看不到</span></span><br><span class="line"><span class="meta">... </span>    print(char)</span><br><span class="line">...</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it = iter(s)  <span class="comment"># 使用迭代器迭代</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>        print(next(it))</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">except</span> StopIteration:  <span class="comment"># 迭代器到头</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">del</span> it  <span class="comment"># 释放引用</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">break</span></span><br><span class="line">...</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br></pre></td></tr></table></figure><img data-src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYIamgBYbAJ2vHy2n9BKfCoabLgEPI089gc4IjGdLkQab6VagjGdny9b1HV3nNBPgsalmYlDhoKYjAWDh02h0ObfTVagfGb9cUKQAGdmPt25ZvqzRjJ_PEVZwh1IQgLmVJ-6pQpcURfq9KxPhoOltI5_kdF9qzxycEXYSxLi6SzNJTl2VxkhbIyr8KGBPWimge2cn8IcgQ0jnmZUBKd3HDAx0421IbbfGMvIc0H1KKb1KWLa4CVpPdpOjTgn5Mm0FIfaPN5s45N5XFJyyE4MnM2i_cjJpTlGi0"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterator</span><span class="params">(Iterable)</span>:</span>  <span class="comment"># abc.Iterator类源码</span></span><br><span class="line"></span><br><span class="line">    __slots__ = ()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'Return the next item from the iterator. When exhausted, raise StopIteration'</span></span><br><span class="line">        <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__subclasshook__</span><span class="params">(cls, C)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">is</span> Iterator:</span><br><span class="line">            <span class="keyword">if</span> (any(<span class="string">"__next__"</span> <span class="keyword">in</span> B.__dict__ <span class="keyword">for</span> B <span class="keyword">in</span> C.__mro__) <span class="keyword">and</span></span><br><span class="line">                any(<span class="string">"__iter__"</span> <span class="keyword">in</span> B.__dict__ <span class="keyword">for</span> B <span class="keyword">in</span> C.__mro__)):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Sentence(<span class="string">'A B'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it = iter(s)  <span class="comment"># 获取迭代器</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)  <span class="comment"># 获取下一个单词</span></span><br><span class="line"><span class="string">'A'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)</span><br><span class="line"><span class="string">'B'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)  <span class="comment"># 迭代到头</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(it)  <span class="comment"># 迭代器空了</span></span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(iter(s))  <span class="comment"># 重新构建迭代器</span></span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'B'</span>]</span><br></pre></td></tr></table></figure><h1 id="sentence类第2版典型的迭代器">Sentence类第2版：典型的迭代器</h1><figure class="highlight python"><figcaption><span>sentence_iter.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span>  <span class="comment"># 使用迭代器模式实现Sentence类</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">        self.words = RW_WORD.findall(text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Sentence(%s)'</span> % reprlib.repr(self.text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span>  <span class="comment"># 实例化并返回一个迭代器</span></span><br><span class="line">        <span class="keyword">return</span> SentenceIterator(self.words)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SentenceIterator</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        self.words = words  <span class="comment"># 引用单词列表</span></span><br><span class="line">        self.index = <span class="number">0</span>  <span class="comment"># 下一个要获取的单词</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            word = self.words[index]  <span class="comment"># 获取索引位上的单词</span></span><br><span class="line">        <span class="keyword">except</span> IndexError:  <span class="comment"># 如果索引位上没有单词</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration()  <span class="comment"># 抛出StopIteration异常</span></span><br><span class="line">        self.index += <span class="number">1</span>  <span class="comment"># 递增索引</span></span><br><span class="line">        <span class="keyword">return</span> word  <span class="comment"># 返回单词</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span>  <span class="comment"># 迭代器应该一直可以迭代</span></span><br><span class="line">        <span class="keyword">return</span> self  <span class="comment"># 因此__iter__方法应该返回自身</span></span><br></pre></td></tr></table></figure><p>对这个示例来说，其实没必要在SentenceIterator类中实现<code>__iter__</code>方法，不过这么做是对的，因为迭代器应该实现<code>__next__</code>和<code>__iter__</code>两个方法，而且这么做能让迭代器通过<code>issubclass(SentenceIterator, abc.Iterator)</code>测试。如果让SentenceIterator类继承abc.Iterator类，那么它会继承<code>abc.Iterator.__iter__</code>这个具体方法。</p><h2 id="把sentence编程迭代器坏主意">把Sentence编程迭代器：坏主意</h2><p>构建可迭代的对象和迭代器时经常会出现错误，原因是混淆了二者。可迭代的对象有个<code>__iter__</code>方法，每次都实例化一个新的迭代器；而迭代器要实现<code>__next__</code>方法，返回单个元素，此外还要实现<code>__iter__</code>方法，返回迭代器本身。</p><p>除了<code>__iter__</code>方法之外，你可能还想在Sentence类中实现<code>__next__</code>方法，让Sentence实例既是可迭代的对象，也是自身的迭代器。可是，这种想法非常糟糕。</p><p>迭代器模式可用来：（出自《设计模式：可复用面向对象软件的基础》）</p><ul><li>访问一个聚合对象的内容而无需暴露它的内部表示</li><li>支持对聚合对象的多种遍历</li><li>为遍历不同的聚合结构提供一个同一的接口（既支持多态迭代）</li></ul><p>为了“支持多种遍历”，必须能从同一个可迭代的实例中获取多个独立的迭代器，而且各个迭代器要能维护自身的内部状态，因此这一模式正确的实现方式是，每次调用iter(my_iterable)都构建一个独立的迭代器。</p><h1 id="sentence类第3版生成器函数">Sentence类第3版：生成器函数</h1><p>用生成器函数代替SentenceIterator类。</p><figure class="highlight python"><figcaption><span>sentence_gen.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">        self.words = RE_WORD.findall(text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Sentence(%s)'</span> % reprlib.repr(self.text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> self.words:</span><br><span class="line">            <span class="keyword">yield</span> word  <span class="comment"># 产出当前的word</span></span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><code>__iter__</code>方法的return语句不是必要的；这个函数可以直接“落空”，自动返回。不管有没有return语句，生成器函数都不会抛出StopIteration异常，而是在生成完全部值之后直接退出。</p><h2 id="生成器函数的工作原理">生成器函数的工作原理</h2><p>只要Python函数的定义体中有yield关键字，该函数就是生成器函数。调用生成器函数时，会返回一个生成器对象。也就是说，生成器函数是生成器工厂。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span>  <span class="comment"># 只要包含关键字yield，该函数就是生成器函数</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'start'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">1</span>  <span class="comment"># 生成器函数的定义体中通常都有循环</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'continue'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">2</span>  <span class="comment"># 不过这不是必要条件</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'end'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen  <span class="comment"># 函数对象</span></span><br><span class="line">&lt;function gen at <span class="number">0x10094ec80</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen()  <span class="comment"># 调用时返回一个生成器对象</span></span><br><span class="line">&lt;generator object gen at <span class="number">0x10094dba0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> gen():</span><br><span class="line"><span class="meta">... </span>    print(i)</span><br><span class="line">...</span><br><span class="line">start</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">end</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = gen()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)  <span class="comment"># 第一次调用，会打印'start'，然后停在第一个yield语句</span></span><br><span class="line">start</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)  <span class="comment"># 第二次调用，打印'continue'，停在第二个yield语句</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)  <span class="comment"># 第三次调用，打印'end'，到达定义体末尾，抛出异常</span></span><br><span class="line">end</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><h1 id="sentence类第4版惰性实现">Sentence类第4版：惰性实现</h1><p>惰性求值（lazy evaluation）和及早求值（eager evaluation）是编程语言理论方面的技术用语。</p><p>目前实现的几版Sentence类都不够惰性，因为<code>__init__</code>方法急迫地构建好了文本中的单词列表，然后将其绑定到self.words属性上。这样就得处理整个文本，列表使用的内存量可能与文本本身一样多（获取更多，这取决于文本中有多少非单词字符）。如果只需迭代前几个单词，大多数工作都是白费力气。</p><p>只要使用Python3，思索着做某件事有没有懒惰的方式，答案通常都是肯定的。re.finditer函数是re.findall函数的惰性版本，返回一个生成器，按需生成re.MatchObject实例。如果有很多匹配，re.finditer函数能节省大量内存。</p><figure class="highlight python"><figcaption><span>sentence_gen2.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Sentence(%s)'</span> % reprlib.repr(self.text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> match <span class="keyword">in</span> RE_WORD.finditer(self.text):</span><br><span class="line">            <span class="keyword">yield</span> match.group()  <span class="comment"># 提取具体文本</span></span><br></pre></td></tr></table></figure><h1 id="sentence类第5版生成器表达式">Sentence类第5版：生成器表达式</h1><p>生成器表达式可以理解为列表推导的惰性版本：不会迫切地构建列表，而是返回一个生成器，按需惰性生成元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'yield 1'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'yield 2'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res1 = [x * <span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> gen()]  <span class="comment"># 列表推导</span></span><br><span class="line"><span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">yield</span> <span class="number">2</span>  <span class="comment"># gen函数全部运行</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res1</span><br><span class="line">[<span class="number">3</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res2 = (x * <span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> gen())  <span class="comment"># 生成器，gen函数没有运行，故没有任何输出</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res2</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x10094daf0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> res2:  <span class="comment"># 循环迭代res2时，gen函数才会真正执行</span></span><br><span class="line"><span class="meta">... </span>    print(i)</span><br><span class="line">...</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="keyword">yield</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>sentence_genexp.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Sentence(%s)'</span> % reprlib.repr(self.text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (match.group() <span class="keyword">for</span> match <span class="keyword">in</span> RE_WORD.finditer(self.text))</span><br></pre></td></tr></table></figure><p><code>__iter__</code>不是生成器函数了（没有yield），而是使用生成器表达式构建生成器，然后将其返回。不过，最终的效果一样：调用<code>__iter__</code>方法会得到一个生成器对象。生成器表达式是语法糖：完全可以替换成生成器函数，不过有时使用生成器表达式更便利。</p><h1 id="何时使用生成器表达式">何时使用生成器表达式</h1><p>生成器表达式是创建生成器的简洁句法，这样无需先定义函数再调用。不过生成器函数灵活得多，可以使用多个语句实现复杂的逻辑，也可以作为协程使用。</p><p>遇到简单的情况时，可以使用生成器表达式，因为这样扫一眼就知道代码的作用；如果生成器表达式要分成多行写，倾向于定义生成器函数，以便提高可读性。此外，生成器函数有名称，因此可以重用。</p><h1 id="另一个示例等差数列生成器">另一个示例：等差数列生成器</h1><p>典型的迭代器模式作用很简单——遍历数据结构。不过，即便不是从集合中获取元素，而是获取序列中即时生成的下一个值时，也用得到这种基于方法的标准接口。例如，内置的range函数用于生成有穷整数等差数列（Arithmetic Progression，AP），itertools.count函数用于生成无穷等差数列。</p><figure class="highlight python"><figcaption><span>arithmetic_progression.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArithmeticProgression</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, begin, step, end=None)</span>:</span></span><br><span class="line">        self.begin = begin</span><br><span class="line">        self.step = step</span><br><span class="line">        self.end = end  <span class="comment"># None -&gt; 无穷数列</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        result = type(self.begin + self.step)(self.begin)  <span class="comment"># 强制转换类型</span></span><br><span class="line">        forever = self.end <span class="keyword">is</span> <span class="literal">None</span>  <span class="comment"># 提高可读性</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> forever <span class="keyword">or</span> result &lt; self.end:</span><br><span class="line">            <span class="keyword">yield</span> result</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">            result = self.begin + self.step * index  <span class="comment"># 没有累加，为了降低处理浮点数时累积效应致错的风险</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> arithmetic_progression <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ap = ArithmeticProgression(<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>)  <span class="comment"># 整型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(ap)</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ap = ArithmeticProgression(<span class="number">1</span>, <span class="number">.5</span>, <span class="number">3</span>)  <span class="comment"># 浮点型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(ap)</span><br><span class="line">[<span class="number">1.0</span>, <span class="number">1.5</span>, <span class="number">2.0</span>, <span class="number">2.5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ap = ArithmeticProgression(<span class="number">0</span>, <span class="number">1</span>/<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(ap)</span><br><span class="line">[<span class="number">0.0</span>, <span class="number">0.3333333333333333</span>, <span class="number">0.6666666666666666</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ap = ArithmeticProgression(<span class="number">0</span>, Fraction(<span class="number">1</span>, <span class="number">3</span>), <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(ap)</span><br><span class="line">[Fraction(<span class="number">0</span>, <span class="number">1</span>), Fraction(<span class="number">1</span>, <span class="number">3</span>), Fraction(<span class="number">2</span>, <span class="number">3</span>)]  <span class="comment"># 第一个数被转换成了Fraction类型</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ap = ArithmeticProgression(<span class="number">0</span>, Decimal(<span class="string">'.1'</span>), <span class="number">.3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(ap)</span><br><span class="line">[Decimal(<span class="string">'0'</span>), Decimal(<span class="string">'0.1'</span>), Decimal(<span class="string">'0.2'</span>)]</span><br></pre></td></tr></table></figure><p>这个简单的示例，说明了如何使用生成器函数实现特殊的<code>__iter__</code>方法。然而，如果一个类只是为了构建生成器而去实现<code>__iter__</code>方法，那还不如使用生成器函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aritprog_gen</span><span class="params">(begin, step, end=None)</span>:</span></span><br><span class="line">    result = type(self.begin + self.step)(self.begin)</span><br><span class="line">    forever = self.end <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> forever <span class="keyword">or</span> result &lt; self.end:</span><br><span class="line">        <span class="keyword">yield</span> result</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">        result = self.begin + self.step * index</span><br></pre></td></tr></table></figure><h2 id="使用itertools模块生成等差数列">使用itertools模块生成等差数列</h2><p>Python3.4中的<a href="https://devdocs.io/python~3.6/library/itertools" target="_blank" rel="noopener">itertools</a>模块提供了19个生成器函数，结合起来使用能实现很多有趣的用法。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/itertools#itertools.count" target="_blank" rel="noopener"><code>itertools.count(start=0, step=1)</code></a></p><p>Make an iterator that returns evenly spaced values starting with number start. Often used as an argument to map() to generate consecutive data points. Also, used with zip() to add sequence numbers. Roughly equivalent to:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(start=<span class="number">0</span>, step=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="comment"># count(10) --&gt; 10 11 12 13 14 ...</span></span><br><span class="line">    <span class="comment"># count(2.5, 0.5) -&gt; 2.5 3.0 3.5 ...</span></span><br><span class="line">    n = start</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        n += step</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>When counting with floating point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: <code>(start + step * i for i in count())</code>.</p></blockquote><p>itertools.count函数返回的生成器能生成等差数列。然而，itertools.count函数从不停止。因此，如果调用list(count())，Python会创建一个特别大的列表，超出可用内存，在调用失败之前，电脑会疯狂地运转。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/itertools#itertools.takewhile" target="_blank" rel="noopener"><code>itertools.takewhile(predicate, iterable)</code></a></p><p>Make an iterator that returns elements from the iterable as long as the predicate is true. Roughly equivalent to:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">takewhile</span><span class="params">(predicate, iterable)</span>:</span></span><br><span class="line">    <span class="comment"># takewhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 1 4</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">if</span> predicate(x):</span><br><span class="line">            <span class="keyword">yield</span> x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure></blockquote><p>itertools.takewhile函数则不同，它会生成一个使用另一个生成器的生成器，在指定的条件计算结果为false时停止。因此，可以把这两个函数结合在一起使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> itertools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen = itertools.takewhile(<span class="keyword">lambda</span> n: n &lt; <span class="number">3</span>, itertools.count(<span class="number">1</span>, <span class="number">.5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(gen)</span><br><span class="line">[<span class="number">1</span>, <span class="number">1.5</span>, <span class="number">2.0</span>, <span class="number">2.5</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aritprog_gen</span><span class="params">(begin, step, end=None)</span>:</span>  <span class="comment"># 利用已有的生成器实现</span></span><br><span class="line">    first = type(begin + step)(begin)</span><br><span class="line">    ap_gen = itertools.count(first, step)</span><br><span class="line">    <span class="keyword">if</span> end <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        ap_gen = itertools.takewhile(<span class="keyword">lambda</span> n: n &lt; end, ap_gen)</span><br><span class="line">    <span class="keyword">return</span> ap_gen</span><br></pre></td></tr></table></figure><h1 id="python3.3中新出现的句法yield-from">Python3.3中新出现的句法：yield from</h1><p>如果生成器函数需要产出另一个生成器生成的值，传统的解决方法是使用嵌套的for循环。例如，chain生成器的等价实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chain</span><span class="params">(*iterables)</span>:</span></span><br><span class="line">    <span class="comment"># chain('ABC', 'DEF') --&gt; A B C D E F</span></span><br><span class="line">    <span class="keyword">for</span> it <span class="keyword">in</span> iterables:</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> it:  <span class="comment"># 使用循环</span></span><br><span class="line">            <span class="keyword">yield</span> element</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chain</span><span class="params">(*iterables)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> it <span class="keyword">in</span> iterables:</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> it  <span class="comment"># 使用yield from</span></span><br></pre></td></tr></table></figure><p>在这个示例中使用yield from是对的，而且代码读起来更顺畅，不过感觉更像是语法糖。除了代替循环之外，yield from还会创建通道，把内层生成器直接与外层生成器的客户端联系起来。把生成器当成协程使用时，这个通道特别重要，不仅能为客户端代码生成值，还能使用客户端提供的值。</p><h1 id="深入分析iter函数">深入分析iter函数</h1><p>在Python中迭代对象x时会调用iter(x)。可是，iter函数还有一个鲜为人知的用法：传入两个参数，使用常规的函数或任何可调用的对象创建迭代器。这样使用时，第一个参数必须是可调用的对象，用于不断调用（没有参数），产出各个值。第二个值是哨符，这是个标记值，当可调用的对象返回这个值时，触发迭代器抛出StopIteration异常，而不产出哨符。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/functions#iter" target="_blank" rel="noopener"><code>iter(object[, sentinel])</code></a></p><p>Return an iterator object. The first argument is interpreted very differently depending on the presence of the second argument. Without a second argument, object must be a collection object which supports the iteration protocol (the <code>__iter__()</code> method), or it must support the sequence protocol (the <code>__getitem__()</code> method with integer arguments starting at 0). If it does not support either of those protocols, TypeError is raised. If the second argument, sentinel, is given, then object must be a callable object. The iterator created in this case will call object with no arguments for each call to its <code>__next__()</code> method; if the value returned is equal to sentinel, StopIteration will be raised, otherwise the value will be returned.</p><p>One useful application of the second form of iter() is to read lines of a file until a certain line is reached. The following example reads a file until the readline() method returns an empty string:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'mydata.txt'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> iter(fp.readline, <span class="string">''</span>):  <span class="comment"># 逐行读取文件，直到遇到空行或者到达文件末尾</span></span><br><span class="line">        process_line(line)</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">d6</span><span class="params">()</span>:</span>  <span class="comment"># 掷骰子</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> randint(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d6_iter = iter(d6, <span class="number">1</span>)  <span class="comment"># 掷到1为止，但不会产出1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d6_iter  <span class="comment"># 返回的是一个callable_iterator对象</span></span><br><span class="line">&lt;callable_iterator object at <span class="number">0x101472e10</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> roll <span class="keyword">in</span> d6_iter:</span><br><span class="line"><span class="meta">... </span>    print(roll)</span><br><span class="line">...</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(d6_iter)  <span class="comment"># 与常规迭代器一样，一旦耗尽就没用了，想重新开始，必须再次创建</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> generators </tag>
            
            <tag> iterables </tag>
            
            <tag> iterators </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符重载</title>
      <link href="/notes/fluent-python/operator-overloading/"/>
      <url>/notes/fluent-python/operator-overloading/</url>
      
        <content type="html"><![CDATA[<h1 id="运算符重载基础">运算符重载基础</h1><p>在某些圈子中，运算符重载的名声并不好。这个语言特性可能（已经）被滥用，让程序员困惑，导致缺陷和意料之外的性能瓶颈。但是，如果使用得到，API会变得好用，代码变得易于阅读。Python施加了一些限制，做好了灵活性、可用性和安全性方面的平衡：</p><ul><li>不能重载内置类型的运算符</li><li>不能新建运算符，只能重载现有的</li><li>某些运算符不能重载——is、and、or和not（不过位运算符&amp;、｜和～可以）</li></ul><p>在Vector类中重载运算符，并修复==运算符可能出现的错误。</p><figure class="highlight python"><figcaption><span>vector.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    typecode = <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, components)</span>:</span></span><br><span class="line">        self._components = array(self.typecode, components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span>  <span class="comment"># 支持 == 中缀运算符，但是有错误</span></span><br><span class="line">        <span class="keyword">return</span> tuple(self) == tuple(other)  <span class="comment"># Vector([3, 4]) == (3, 4)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> math.sqrt(sum(x * x <span class="keyword">for</span> x <span class="keyword">in</span> self))</span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="一元运算符">一元运算符</h1><p><code>- (__neg__)</code>：一元取负算术运算符。如果x是-2，那么-x == 2。</p><p><code>+ (__pos__)</code>：一元取正算术运算符。通常，x == -x，但是也有例外。</p><p><code>~ (__invert__)</code>：对整数按位取反，定义为~x == -(x+1)。如果x是2，那么~x == -3。</p><p>Python语言参考手册还把内置的<code>abs(...)</code>函数列为一元运算符。它对应的特殊方法是<code>__abs__</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在Vector类中定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span>  <span class="comment"># 返回标量</span></span><br><span class="line">    <span class="keyword">return</span> math.sqrt(sum(x * x <span class="keyword">for</span> x <span class="keyword">in</span> self))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__neg__</span><span class="params">(self)</span>:</span>  <span class="comment"># 返回同属一类的实例</span></span><br><span class="line">    <span class="keyword">return</span> Vector(-x <span class="keyword">for</span> x <span class="keyword">in</span> self)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__pos__</span><span class="params">(self)</span>:</span>  <span class="comment"># 返回self的副本</span></span><br><span class="line">    <span class="keyword">return</span> Vector(self)</span><br></pre></td></tr></table></figure><p>我们不打算实现<code>__invert__</code>方法，因此如果用户在Vector实例上尝试计算~v，Python会抛出TypeError，而且输出明确的错误消息，&quot;bad operand type for unary ~: 'Vector'&quot;。</p><h2 id="x-和-x-何时不相等">x 和 +x 何时不相等</h2><p>第一例与decimal.Decimal类有关。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> decimal</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ctx = decimal.getcontext()  <span class="comment"># 当前上下文</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ctx.prec = <span class="number">40</span>  <span class="comment"># 精度设为40</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one_third = decimal.Decimal(<span class="string">'1'</span>) / decimal.Decimal(<span class="string">'3'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one_third</span><br><span class="line">Decimal(<span class="string">'0.3333333333333333333333333333333333333333'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one_third == +one_third</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ctx.prec = <span class="number">28</span>  <span class="comment"># 改变精度</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one_third == +one_third</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>+one_third  <span class="comment"># +one_third的精度与one_third的精度不一样</span></span><br><span class="line">Decimal(<span class="string">'0.3333333333333333333333333333'</span>)</span><br></pre></td></tr></table></figure><p>第二例与collections.Counter类有关。</p><p>Counter类实现了几个算术运算符，例如中缀运算符+，作用是把两个Counter实例的计数器加在一起。然而，从实用角度出发，Counter相加时，负值和零值计数会从结果中剔除。而一元运算符+等同于加上一个空Counter，因此它产生一个新的Counter且保留大于零的计数器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct = Counter(<span class="string">'abracadabra'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct[<span class="string">'r'</span>] = <span class="number">-3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct[<span class="string">'d'</span>] = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct</span><br><span class="line">Counter(&#123;<span class="string">'a'</span>: <span class="number">5</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">1</span>, <span class="string">'d'</span>: <span class="number">0</span>, <span class="string">'r'</span>: <span class="number">-3</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>+ct</span><br><span class="line">Counter(&#123;<span class="string">'a'</span>: <span class="number">5</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct == +ct</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="重载向量加法运算符">重载向量加法运算符</h1><p>序列应该支持<code>+</code>运算符（用于拼接），以及<code>*</code>运算符（用于重复复制）。然而，对Vector类型来说，使用向量数学运算实现<code>+</code>和<code>*</code>运算符更有意义。</p><p>如果尝试把两个不同长度Vector实例加在一起会怎样？此时可以抛出错误，但是根据实际运行情况（例如信息检索），最好使用零填充较短的那个向量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> vector <span class="keyword">import</span> Vector</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v2 = Vector([<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + v2</span><br><span class="line">Vector([<span class="number">9.0</span>, <span class="number">11.0</span>, <span class="number">13.0</span>])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v3 = Vector([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + v3</span><br><span class="line">Vector([<span class="number">4.0</span>, <span class="number">6.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>])</span><br></pre></td></tr></table></figure><p>确定基本要求后，<code>__add__</code>方法的实现如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在Vector类中定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    pairs = itertools.zip_longest(self, other, fillvalue=<span class="number">0.0</span>)</span><br><span class="line">    <span class="keyword">return</span> Vector(a + b <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs)</span><br></pre></td></tr></table></figure><p><strong>实现一元运算符和中缀运算符的特殊方法一定不能修改操作数。使用这些运算符的表达式期待结果是新对象。只有增量赋值表达式可能会修改第一个操作数（self）。</strong></p><p>上述的<code>__add__</code>方法也支持Vector之外的对象。这是因为<code>__add__</code>使用了zip_longest，它能处理任何可迭代对象，而且构造新Vector实例的生成器表达式仅仅是把zip_longest生成的值对相加，因此可以使用任何生成数字元素的可迭代对象。然而，如果对调操作数，混合类型的加法就会失败。</p><p>为了支持涉及不同类型的运算，Python为中缀运算符特殊方法提供了特殊的分派机制。对表达式 a + b 来说，解释器会执行以下几步操作。</p><ol type="1"><li><p>如果a有<code>__add__</code>方法，而且返回值不是NotImplemented，调用<code>a.__add__(b)</code>，然后返回结果。</p></li><li><p>如果a没有<code>__add__</code>方法，或者调用<code>__add__</code>方法返回NotImplemented，检查b有没有<code>__radd__</code>方法（<code>__add__</code>的“反向”reversed版本），如果有，而且没有返回NotImplemented，调用<code>b.__radd__(a)</code>，然后返回结果。</p></li><li><p>如果b没有<code>__radd__</code>方法，或者调用<code>__radd__</code>方法返回NotImplemented，抛出TypeError，并在错误消息中指明操作类型不支持。</p></li></ol><img data-src="http://www.plantuml.com/plantuml/svg/bP2zJiCm58NtFCLLfoBK3XaPkZ6mCB57Dhb09F8ZnnswC24XaA11G8jeLRPE20O6H47gqzZfnYlWsB4980Q695V7dyyzEGTHY81nnWSGOhxBeen7QUBbd7245e5re2qWEKH9rkTEbjFJeo0WOHW4SlGgdsz4CVvulpVa7h7Swk9534UaQzasNIllZiktApcRQdOVEQ6MDhgyVTfE-LQS7MAC2SUmOPsaF587pdvvBIQpXXr3tcSkF3KfsLynwVUOjElWDlcTan9Fls43nF1S59UhPL4-Zik7-R_p-_Q6F9k8ayNE8CDDnbAc6QmcJzSDdPvkKprcfDNoOcu5tPwIr4hFp4gq7TLVwBYR5URKNbsMSwIre_x32jMIqdIW6ZFdNrjyQ-X3Wsmiydzk-WG0"><p><strong>别把NotImplemented和NotImplementedError搞混了。前者是特殊的单例值，如果中缀运算符特殊方法不能处理给定的操作数，那么要把它返回（return）给解释器。而NotImplementedError是一种异常，抽象类中占位方法把它抛出（raise），提醒子类必须覆盖。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在Vector类中定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    pairs = itertools.zip_longest(self, other, fillvalue=<span class="number">0.0</span>)</span><br><span class="line">    <span class="keyword">return</span> Vector(a + b <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__radd__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self + other  <span class="comment"># 直接委托__add__，处理数字和向量时，+可以交换，但是拼接序列时不行。</span></span><br></pre></td></tr></table></figure><p><strong>一般来说，如果中缀运算符的正向方法只处理与self属于同一类型的操作数，那就无需实现对应的反向方法，因为按照定义，反向方法是为了处理类型不同的操作数。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> vector <span class="keyword">import</span> Vector</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + (<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">Vector([<span class="number">5.0</span>, <span class="number">5.0</span>, <span class="number">5.0</span>])  <span class="comment"># __add__方法可以处理任何具有数值元素的可迭代对象</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + <span class="number">1</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"/Users/cws/Desktop/vector.py"</span>, line <span class="number">49</span>, <span class="keyword">in</span> __add__</span><br><span class="line">    pairs = itertools.zip_longest(self, other, fillvalue=<span class="number">0.0</span>)</span><br><span class="line">TypeError: zip_longest argument <span class="comment">#2 must support iteration  # 错误消息明确</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + <span class="string">'abc'</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"/Users/cws/Desktop/vector.py"</span>, line <span class="number">50</span>, <span class="keyword">in</span> __add__</span><br><span class="line">    <span class="keyword">return</span> Vector(a + b <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs)</span><br><span class="line">  File <span class="string">"/Users/cws/Desktop/vector.py"</span>, line <span class="number">11</span>, <span class="keyword">in</span> __init__</span><br><span class="line">    self._components = array(self.typecode, components)</span><br><span class="line">  File <span class="string">"/Users/cws/Desktop/vector.py"</span>, line <span class="number">50</span>, <span class="keyword">in</span> &lt;genexpr&gt;</span><br><span class="line">    <span class="keyword">return</span> Vector(a + b <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs)</span><br><span class="line">TypeError: unsupported operand type(s) <span class="keyword">for</span> +: <span class="string">'float'</span> <span class="keyword">and</span> <span class="string">'str'</span>  <span class="comment"># 问题严重</span></span><br></pre></td></tr></table></figure><p>v1 + 'abc'是无法计算的：如果由于类型不兼容而导致运算符特殊方法无法返回有效的结果，那么应该返回NotImplemented。如果抛出异常，就终止了运算符分派机制。对TypeError来说，通常最好将其捕获，然后返回NotImplemented。这样，解释器会尝试调用反向运算符方法，如果操作数是不同的类型，对调之后，反向运算符方法可能会正确计算。</p><p>为了遵守鸭子类型精神，我们不能测试other操作数的类型，或者它的元素的类型。我们要捕获异常，然后返回NotImplemented。如果解释器还未反转操作数，那么它将尝试去做。如果反方向方法返回NotImplemented，那么Python会抛出TypeError，并返回一个标准的错误消息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在Vector类中定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span>  <span class="comment"># 最终版本</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pairs = itertools.zip_longest(self, other, fillvalue=<span class="number">0.0</span>)</span><br><span class="line">        <span class="keyword">return</span> Vector(a + b <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs)</span><br><span class="line">    <span class="keyword">except</span> TypeError:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br></pre></td></tr></table></figure><h1 id="重载标量乘法运算符">重载标量乘法运算符<code>*</code></h1><p>标量积（scalar product）：<code>Vector([1, 2, 3]) * x</code>，x是数字，结果是一个新Vector实例，各个分量都会乘以x。这也叫元素级乘法（elementwise multiplication）。</p><p>向量点积（dot product）：矩阵乘法。NumPy等库目前的做法是，不重载这两种意义的<code>*</code>，只用<code>*</code>计算标量积。例如，在NumPy中，点积使用<code>numpy.dot()</code>函数计算。</p><p><em>从Python3.5起，<code>@</code>记号可以用作中缀点积运算符。</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在Vector类中定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, scalar)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Vector(n * scalar <span class="keyword">for</span> n <span class="keyword">in</span> self)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__rmul__</span><span class="params">(self, scalar)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self * scalar</span><br></pre></td></tr></table></figure><p>这两个方法确实可用，但是提供不兼容的操作数时会出问题。scalar参数的值要是数字，与浮点数相乘得到的积是另一个浮点数。因此，不能使用复数，但可以是int、bool（int的子类），甚至fractions.Fraction实例等标量。</p><p>我们可以采用鸭子类型技术，在<code>__mul__</code>方法中捕获TypeError。但是，这个问题有个更易于理解的方式，而且也更合理：白鹅类型。我们将使用isinstance()检查scalar的类型，但是不硬编码具体的类型，而是检查numbers.Real抽象基类。这个抽象基类涵盖了我们所需的全部类型，而且还支持以后声明为numbers.Real抽象基类的真实子类或虚拟子类的数值类型。（decimal.Decimal没有把自己注册为numbers.Real的虚拟子类。因此，Vector类不会处理decimal.Decimal数字）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numbers</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在类中定义</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, scalar)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(scalar, numbers.Real):  <span class="comment"># 显示检查抽象类型</span></span><br><span class="line">            <span class="keyword">return</span> Vector(n * scalar <span class="keyword">for</span> n <span class="keyword">in</span> self)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NotImplemented</span>  <span class="comment"># 返回NotImplemented，让Python尝试在scalar操作数上调用__rmul__方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__rmul__</span><span class="params">(self, scalar)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self * scalar</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__matmul__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> sum(a * b <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(self, other))</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__rmatmul__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self @ other  <span class="comment"># 委托</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> vector <span class="keyword">import</span> Vector</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 * <span class="number">11</span></span><br><span class="line">Vector([<span class="number">11.0</span>, <span class="number">22.0</span>, <span class="number">33.0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">11</span> * v1</span><br><span class="line">Vector([<span class="number">11.0</span>, <span class="number">22.0</span>, <span class="number">33.0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 * <span class="literal">True</span></span><br><span class="line">Vector([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 * Fraction(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">Vector([<span class="number">0.3333333333333333</span>, <span class="number">0.6666666666666666</span>, <span class="number">1.0</span>])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>va = Vector([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vz = Vector([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>va @ vz</span><br><span class="line"><span class="number">38.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>] @ vz  <span class="comment"># 反向调用成功</span></span><br><span class="line"><span class="number">380.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>va @ <span class="number">3</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unsupported operand type(s) <span class="keyword">for</span> @: <span class="string">'Vector'</span> <span class="keyword">and</span> <span class="string">'int'</span></span><br></pre></td></tr></table></figure><h1 id="中缀运算符方法的名称">中缀运算符方法的名称</h1><table><thead><tr class="header"><th>运算符</th><th>正向方法</th><th>反向方法</th><th>就地（in-place）方法</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>+</code></td><td><code>__add__</code></td><td><code>__radd__</code></td><td><code>__iadd__</code></td><td>加法或拼接</td></tr><tr class="even"><td><code>-</code></td><td><code>__sub__</code></td><td><code>__rsub__</code></td><td><code>__isub__</code></td><td>减法</td></tr><tr class="odd"><td><code>*</code></td><td><code>__mul__</code></td><td><code>__rmul__</code></td><td><code>__imul__</code></td><td>乘法或重复复制</td></tr><tr class="even"><td><code>/</code></td><td><code>__truediv__</code></td><td><code>__rtruediv__</code></td><td><code>__itruediv__</code></td><td>除法</td></tr><tr class="odd"><td><code>//</code></td><td><code>__floordiv__</code></td><td><code>__rfloordiv__</code></td><td><code>__ifloordiv__</code></td><td>整除</td></tr><tr class="even"><td><code>%</code></td><td><code>__mod__</code></td><td><code>__rmod__</code></td><td><code>__imod__</code></td><td>取模</td></tr><tr class="odd"><td><code>divmod()</code></td><td><code>__divmod__</code></td><td><code>__rdivmod__</code></td><td><code>__idivmod__</code></td><td>返回由整除的商和模数组成的元组</td></tr><tr class="even"><td><code>**, pow()</code></td><td><code>__pow__</code></td><td><code>__rpow__</code></td><td><code>__ipow__</code></td><td>取幂</td></tr><tr class="odd"><td><code>@</code></td><td><code>__matmul__</code></td><td><code>__rmatmul__</code></td><td><code>__imatmul__</code></td><td>矩阵乘法</td></tr><tr class="even"><td><code>&amp;</code></td><td><code>__and__</code></td><td><code>__rand__</code></td><td><code>__iand__</code></td><td>位与</td></tr><tr class="odd"><td><code>|</code></td><td><code>__or__</code></td><td><code>__ror__</code></td><td><code>__ior__</code></td><td>位或</td></tr><tr class="even"><td><code>^</code></td><td><code>__xor__</code></td><td><code>__rxor__</code></td><td><code>__ixor__</code></td><td>位异或</td></tr><tr class="odd"><td><code>&lt;&lt;</code></td><td><code>__lshift__</code></td><td><code>__rlshift__</code></td><td><code>__ilshift__</code></td><td>按位左移</td></tr><tr class="even"><td><code>&gt;&gt;</code></td><td><code>__rshift__</code></td><td><code>__rrshift__</code></td><td><code>__irshift</code></td><td>按位右移</td></tr></tbody></table><h1 id="众多比较运算符">众多比较运算符</h1><p>Python解释器对众多比较运算符的处理与前文类似，不过在两个方面有重大区别。</p><ul><li>正向和反向调用使用的是同一系列方法。</li><li>对<code>==</code>和<code>!=</code>来说，如果反向调用失败，Python会比较对象的ID，而不抛出TypeError。</li></ul><table><thead><tr class="header"><th>分组</th><th>中缀运算符</th><th>正向方法调用</th><th>反向方法调用</th><th>后备机制</th></tr></thead><tbody><tr class="odd"><td>相等性</td><td><code>a == b</code></td><td><code>a.__eq__(b)</code></td><td><code>b.__eq__(a)</code></td><td>返回<code>id(a) == id(b)</code></td></tr><tr class="even"><td></td><td><code>a != b</code></td><td><code>a.__ne__(b)</code></td><td><code>b.__ne__(a)</code></td><td>返回<code>not (a == b)</code></td></tr><tr class="odd"><td>排序</td><td><code>a &gt; b</code></td><td><code>a.__gt__(b)</code></td><td><code>b.__lt__(a)</code></td><td>抛出<code>TypeError</code></td></tr><tr class="even"><td></td><td><code>a &lt; b</code></td><td><code>a.__lt__(b)</code></td><td><code>b.__gt__(a)</code></td><td>抛出<code>TypeError</code></td></tr><tr class="odd"><td></td><td><code>a &gt;= b</code></td><td><code>a.__ge__(b)</code></td><td><code>b.__le__(a)</code></td><td>抛出<code>TypeError</code></td></tr><tr class="even"><td></td><td><code>a &lt;= b</code></td><td><code>a.__le__(b)</code></td><td><code>b.__ge__(a)</code></td><td>抛出<code>TypeError</code></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在Vector类中定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (len(self) == len(other) <span class="keyword">and</span>    <span class="comment"># 等价于 tuple(self) == tuple(other)</span></span><br><span class="line">            all(a == b <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(self, other)))  <span class="comment"># 但是明显此法更高效</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> vector <span class="keyword">import</span> Vector</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>va = Vector([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vb = Vector(range(<span class="number">1</span>, <span class="number">4</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>va == vb</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>va == (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>va == (1, 2, 3)的结果不是很理想，对操作数过度宽容可能导致令人惊讶的结果，而程序员讨厌惊喜。从Python自身来找线索，我们发现[1,2] == (1,2)的结果是False，因此，我们要保守一点，做些类型检查。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在Vector类中定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(other, Vector):</span><br><span class="line">        <span class="keyword">return</span> (len(self) == len(other) <span class="keyword">and</span></span><br><span class="line">                all(a ==b <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(self, other)))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span>  <span class="comment"># 让Python编辑器处理</span></span><br></pre></td></tr></table></figure><p>我们不用实现<code>__ne__</code>方法，因为从object继承的<code>__ne__</code>方法的后备行为满足了我们的需求。从object中继承的<code>__ne__</code>方法，运作方式与下述代码类似，不过原版是用C语言实现的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__ne__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    eq_result = self == other</span><br><span class="line">    <span class="keyword">if</span> eq_result <span class="keyword">is</span> <span class="built_in">NotImplemented</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> eq_result</span><br></pre></td></tr></table></figure><h1 id="增量赋值运算符">增量赋值运算符</h1><p>Vector类已经支持增量赋值运算符<code>+=</code>和<code>*=</code>了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> vector <span class="keyword">import</span> Vector</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1_alias = v1</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(v1)</span><br><span class="line"><span class="number">4358324120</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 += Vector([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(v1)  <span class="comment"># v1重新绑定了实例</span></span><br><span class="line"><span class="number">4359075992</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1</span><br><span class="line">Vector([<span class="number">5.0</span>, <span class="number">7.0</span>, <span class="number">9.0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1_alias  <span class="comment"># 原来的实例没有变</span></span><br><span class="line">Vector([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 *= <span class="number">2</span>  <span class="comment"># 增量乘法运算</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1</span><br><span class="line">Vector([<span class="number">10.0</span>, <span class="number">14.0</span>, <span class="number">18.0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(v1)</span><br><span class="line"><span class="number">4359074872</span></span><br></pre></td></tr></table></figure><p>如果一个类没有实现就地运算符，增量赋值运算只是语法糖：a += b的作用与a = a + b完全一样。对不可变类型来说，这是预期的行为，而且，如果定义了<code>__add__</code>方法的话，不用编写额外的代码，+=就能使用。</p><p>然而，如果实现了就地运算符方法，例如<code>__iadd__</code>方法，计算a += b的结果时会调用它。这种运算符的名称表明，它们会就地修改左操作数，而不会创建新的对象作为结果。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> overloading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承的优缺点</title>
      <link href="/notes/fluent-python/inheritance-for-good-or-for-worse/"/>
      <url>/notes/fluent-python/inheritance-for-good-or-for-worse/</url>
      
        <content type="html"><![CDATA[<h1 id="子类化内置类型很麻烦">子类化内置类型很麻烦</h1><p>在Python2.2之前，内置类型（如list或dict）不能子类化。在Python2.2之后，内置类型可以子类化了，但是有个重要的注意事项：<strong>内置类型（使用C语言编写）不会调用用户定义的类覆盖的特殊方法。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">DoppelDict</span><span class="params">(dict)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line"><span class="meta">... </span>            super().__setitem__(key, [value] * <span class="number">2</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd = DoppelDict(one=<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd</span><br><span class="line">&#123;<span class="string">'one'</span>: <span class="number">1</span>&#125;  <span class="comment"># __init__方法没有调用覆盖的__setitem__方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd[<span class="string">'two'</span>] = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd</span><br><span class="line">&#123;<span class="string">'two'</span>: [<span class="number">2</span>, <span class="number">2</span>], <span class="string">'one'</span>: <span class="number">1</span>&#125;  <span class="comment"># []运算符调用了</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd.update(three=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd</span><br><span class="line">&#123;<span class="string">'three'</span>: <span class="number">3</span>, <span class="string">'two'</span>: [<span class="number">2</span>, <span class="number">2</span>], <span class="string">'one'</span>: <span class="number">1</span>&#125;  <span class="comment"># upate方法没调用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd.get(<span class="string">'three'</span>)  <span class="comment"># get方法没调用</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>原生类型的这种行为违背了面向对象编程的一个基本原则：<strong>始终应该从示例（self）所属的类开始搜索方法，即使在超类中调用也是如此。</strong>在这种糟糕的局面中，<code>__missing__</code>方法却能按预期方式工作，不过这只是特例。</p><a id="more"></a><p>不只是实例内部的调用有这个问题，内置类型的方法调用的其他类的方法，如果被覆盖了，也不会被调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">AnswerDict</span><span class="params">(dict)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span> <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ad = AnswerDict(a=<span class="string">'foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ad[<span class="string">'a'</span>]  <span class="comment"># 实例内部</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.update(ad)  <span class="comment"># 内置dict类型读取AnswerDict实例的值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'a'</span>]  <span class="comment"># 没有调用覆盖的__getitem__方法</span></span><br><span class="line"><span class="string">'foo'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="string">'foo'</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>不要子类化内置类型，用户自己定义的类应该继承collections模块中的类，例如UserDict、UserList和UserString，这些类做了特殊设计，因此易于扩展。</strong></p><h1 id="多重继承和方法解析顺序">多重继承和方法解析顺序</h1><p>任何实现多重继承的语言都要处理潜在的命名冲突，这种冲突由不相关的祖先类实现同名方法引起。这种冲突称为“菱形问题”。</p><figure class="highlight python"><figcaption><span>diamond.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'A ping:'</span>, self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pong</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'B pong:'</span>, self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pong</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'C pong:'</span>, self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B, C)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().ping()</span><br><span class="line">        print(<span class="string">'D ping:'</span>, self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pingpong</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.ping()</span><br><span class="line">        super().ping()</span><br><span class="line">        self.pong()</span><br><span class="line">        super().pong()</span><br><span class="line">        C.pong(self)</span><br></pre></td></tr></table></figure><img data-src="http://www.plantuml.com/plantuml/svg/oyXCILL8pYnApabDuSe0SL9p2qeg5N9JSvDIYxYISnABYnKS5Qgv582W83ClNKEJgnOgx0GJpaSHTiOkx89g28m9L-MeO5EZgwlW16BewIaummJ03BreeDjIKlDYzO0Ad20IBY06K2M8rhC3gdD6KUS2ueFL0G00"><p>说明“菱形问题”的UML类图。虚线箭头是该示例的方法解析顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> diamond <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = D()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.pong()  <span class="comment"># 直接调用，按MRO搜索，运行的是B类中的版本</span></span><br><span class="line">B pong: &lt;diamond.D object at <span class="number">0x10d5d4e80</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.pong(d)  <span class="comment"># 调用指定超类中的方法，此时要把实例作为显式参数传入</span></span><br><span class="line">C pong: &lt;diamond.D object at <span class="number">0x10d5d4e80</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>D.__mro__  <span class="comment"># D类的__mro__属性</span></span><br><span class="line">(&lt;class 'diamond.D'&gt;, &lt;class 'diamond.B'&gt;, &lt;class 'diamond.C'&gt;, &lt;class 'diamond.A'&gt;, &lt;class 'object'&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.pingpong()</span><br><span class="line">A ping: &lt;diamond.D object at <span class="number">0x10d5d4e80</span>&gt;</span><br><span class="line">D ping: &lt;diamond.D object at <span class="number">0x10d5d4e80</span>&gt;  <span class="comment"># 前两行是self.ping()的结果</span></span><br><span class="line">A ping: &lt;diamond.D object at <span class="number">0x10d5d4e80</span>&gt;  <span class="comment"># super().ping()</span></span><br><span class="line">B pong: &lt;diamond.D object at <span class="number">0x10d5d4e80</span>&gt;  <span class="comment"># self.pong()</span></span><br><span class="line">B pong: &lt;diamond.D object at <span class="number">0x10d5d4e80</span>&gt;  <span class="comment"># super().pong()</span></span><br><span class="line">C pong: &lt;diamond.D object at <span class="number">0x10d5d4e80</span>&gt;  <span class="comment"># C.pong(d)</span></span><br></pre></td></tr></table></figure><p>Python能区分d.pong()调用的是哪个方法，是因为Python会按照特定的顺序遍历继承图。这个顺序叫方法解析顺序（Method Resolution Order，MRO）。类都有一个名为<code>__mro__</code>的属性，它的值是一个元组，按照方法解析顺序列出各个超类，从当前类一直向上，直到object类。方法解析顺序不仅考虑继承图，还考虑子类声明中列出超类的顺序。如果把D类声明为<code>class D(C, B):</code>，那么D类的<code>__mro__</code>属性就会不一样，先搜索C类，再搜索B类。</p><p>若想把方法委托给超类，推荐的方式是使用内置的super()函数，最安全，也不易过时。调用框架或不受自己控制的类层次结构中的方法时，尤其适合使用super()。使用super()调用方法时，会遵守方法解析顺序。然而，有时可能需要绕过方法解析顺序，直接调用某个超类的方法。例如C.pong(d)。注意，直接在类上调用实例方法时，必须显式地传入self参数，因为这样访问的是未绑定方法（unbound method）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">print_mro</span><span class="params">(cls)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">', '</span>.join(c.__name__ <span class="keyword">for</span> c <span class="keyword">in</span> cls.__mro__))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_mro(bool)</span><br><span class="line">bool, int, object</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numbers</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_mro(numbers.Integral)</span><br><span class="line">Integral, Rational, Real, Complex, Number, object</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> io</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_mro(io.BytesIO)</span><br><span class="line">BytesIO, _BufferedIOBase, _IOBase, object  <span class="comment"># 以Base结尾的是抽象基类</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_mro(io.TextIOWrapper)</span><br><span class="line">TextIOWrapper, _TextIOBase, _IOBase, object</span><br></pre></td></tr></table></figure><p>多重继承能发挥积极作用。《设计模式:可复用面向对象软件的基础》一书中的适配器模式用的就是多重继承，因此使用多重继承肯定没有错（那本书中的其他22个设计模式都使用单继承，因此多重继承显然不是灵丹妙药)。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> inheritance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标准库中的抽象基类</title>
      <link href="/notes/fluent-python/abc-s-in-standard-library/"/>
      <url>/notes/fluent-python/abc-s-in-standard-library/</url>
      
        <content type="html"><![CDATA[<h1 id="collections.abc模块中的抽象基类">collections.abc模块中的抽象基类</h1><p>Python3.4在collections.abc模块中定义了16个抽象基类（Python3.6定义了25个），简要的UML类图如下。</p><img data-src="http://www.plantuml.com/plantuml/svg/TP513e8m44NtdA8Nu0Rkt6YCAnFs0qoaILiGXXYCXpS2RMTQtRxv_tVcjzCjAhG3BSgYhN4ie9veX8RKcN24sc0anzuHQCT5D_t2bYd06EavmTH9ikPIpqFmCQDhcEOAmw3TdKiecrOQdmpEz7tdHzOso2A3WSHkTfAv5rmIKe6PSME-8tLubsMyJEAmaiH-eLHCHUWvyIVS1sHoAjPlIToCUQUGqG_5UgHFs2T9pxjI34C-KcAYo6BN0OMksVEfE1lzDyMF-W00"><a id="more"></a><ul><li><p>Iterable、Container和Sized</p><p>各个集合应该继承这三个抽象基类，或者至少实现兼容的协议。</p></li><li><p>Sequence、Mapping和Set</p><p>这三个是主要的不可变集合类型，而且各自都有可变的子类。</p></li><li><p>MappingView</p><p>在Python3中，映射方法.items()、.keys()、.values()返回的对象分别是ItemsView、KeysView和ValuesView的实例。前两个类还从Set类继承了丰富的接口。</p></li><li><p>Callable和Hashable</p><p>这两个抽象基类与集合没有太大的关系，只不过因为collections.abc是标准库中定义抽象基类的第一个模块，而它们又太重要了，因此才把它们放到collections.abc模块中。这两个抽象基类的主要作用是为内置函数isinstance提供支持，以一种安全的方式判断对象能不能调用或散列。若想检查是否能调用，可以使用内置的callable()函数；但是没有类似的hashable()函数，因此测试对象是否可散列，最好使用isinstance(my_obj, Hashable)。</p></li><li><p>Iterator</p><p>注意它是Iterable的子类。</p></li></ul><p>继collections.abc之后，标准库中最有用的抽象基类包是numbers。</p><h1 id="抽象基类的数字塔">抽象基类的数字塔</h1><img data-src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYIamgBYbAJ2vHy2j5vJldvnRaf5OW189I4tEGU8abcVbvo2AUUIMfwKL04OX92ZOrkhfmKw0qH11i4eY0Sc56mHWGOPXv0000"><p>如果想检查一个数是不是整数，可以使用instance(x, numbers.Integral)，这样代码就能接受int、bool（int的子类），或者外部库使用numbers抽象基类注册的其他类型。</p><p>与之类似，如果一个值可能是浮点数类型，可以使用instance(x, numbers.Real)检查。这样代码就能接受bool、int、float、fractions.Fraction，或者外部库提供的非复数类型。</p><p>decimal.Decimal没有注册为numbers.Real的虚拟子类。原因是，如果你的程序需要Decimal的精度，要防止与其他低精度数字类型混淆，尤其是浮点数。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口：抽象基类</title>
      <link href="/notes/fluent-python/interfaces-abc-s/"/>
      <url>/notes/fluent-python/interfaces-abc-s/</url>
      
        <content type="html"><![CDATA[<p>抽象基类与描述符和元类一样，适用于构建框架的工具。因此，只有少数Python开发者编写的抽象基类不会对用户施加不必要的限制，让他们做无用功。不建议自己编写抽象基类，因为很容易过度设计。只要正确使用现有的抽象基类，就能获得99.9%的好处，而不用冒着设计不当导致的巨大风险。</p><p>引入抽象基类之前，Python就已经非常成功了，即便现在也很少有代码使用抽象基类。</p><h1 id="抽象基类">抽象基类</h1><p>Python的抽象基类有一个重要的实用优势：可以使用register类方法在终端用户的代码中把某个类”声明“为一个抽象基类的“虚拟”子类。为此，被注册的类必须满足抽象基类对方法名称和签名的要求，最重要的是要满足底层语义契约；但是，开发那个类时不用了解抽象基类，更不用继承抽象类。这大大地打破了严格的耦合，与面向对象编程人员掌握的知识有很大的出入，因此使用继承时要小心。</p><p>有时，为了让抽象基类识别子类，甚至不用注册。其实，抽象基类的本质就是几个特殊方法。例如：</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Struggle</span>:</span>  <span class="comment"># 无继承</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span> <span class="keyword">return</span> <span class="number">23</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(Struggle(), abc.Sized)  <span class="comment"># 无注册abc.Sized.register(Struggle)</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(Struggle, abc.Sized)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>可以看出，无需注册，abc.Sized也能把Struggle识别为自己的子类，只要实现了特殊方法<code>__len__</code>即可。要使用正确的句法和语义，前者要求没有参数，后者要求返回一个非负整数，指明对象的长度。如果不使用规定的句法和语义实现特殊方法，会导致非常严重的问题。</p><p>如果实现的类体现了numbers、collections.abc或其他框架中抽象基类的概念，要么继承相应的抽象基类（必要时），要么把类注册到相应的抽象基类中。开始开发程序时，不要使用提供注册功能的库或框架，要自己动手注册；如果必要检查参数的类型（这是最常见的），例如检查是不是序列，那就这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isinstance(the_arg, collections.abc.Sequece)</span><br></pre></td></tr></table></figure><p>继承抽象基类很简单，只需要实现所需的方法，这样也能明确表明开发者的意图。这一意图还能通过注册虚拟子类来实现。此外，使用isinstance和issubclass测试抽象基类更为人接受。过去，这两个函数用来测试鸭子类型，但用于抽象基类会更灵活。毕竟，如果某个组件没有继承抽象基类，事后还可以注册，让显式类型检查通过。</p><p>然而，即便是抽象基类，也不能滥用isinstance检查，用的多了可能导致代码异味，即表明面向对象设计得不好。<strong>在一连串if/elif/elif中使用isinstance检查，然后根据对象的类型执行不同的操作，通常是不好的做法；此时应该使用多态，即采用一定的方式定义类，让解释器把调用分派给正确的方法，而不使用if/elif/elif块硬编码分派逻辑。</strong></p><p><strong>具体使用时，上述建议有一个常见的例外：有些Python API接受一个字符串或字符串序列；因为字符串是序列类型，所以为了把它和其他不可变序列区分开，最简单的方式是使用isinstance(x, str)检查。</strong></p><blockquote><p>尽管抽象基类使得类型检查变得更容易了，但不应该在程序中过度使用它。Python的核心在于它是一门动态语言，它带来了极大的灵活性。如果处处都强制实行类型约束，那么会使代码变得更加复杂，而本不应该如此。我们应该拥抱Python的灵活性。</p><p>——David Beazley和Brian Jones 《Python Cookbook(第3版)中文版》</p></blockquote><p>另一方面，如果必须强制执行API契约，通常可以使用isinstance检查抽象基类。“老兄，如果你想调用我，必须实现这个”，正如本书技术审校Lennart Regebro所说的。这对采用插入式架构的系统来说特别有用。在框架之外，鸭子类型通常比类型检查更简单，也更灵活。</p><p>例如，本书有几个示例要使用序列，把它当成列表处理。我没有检查参数的类型是不是list，而是直接接受参数，立即使用它构建一个列表（list(x)）。这样，我就可以接受任何可迭代对象；如果参数不是可迭代对象，调用立即失败，并且提供非常清晰的错误消息。当然，如果序列太长（复制开销很大）或者需要就地修改序列而导致无法复制参数，就不能采用这种方式；此时，使用isinstance(x, abc.MutableSequence)更好。如果可以接受任何可迭代对象，也可以调用iter(x)函数获得一个迭代器。</p><p>模仿collections.namedtuple处理<code>field_names</code>参数的方式也是一例：<code>field_names</code>的值可以是单个字符串，以空格或逗号分隔标识符，也可以是一个标识符序列。此时可能想使用isinstance，但我会使用鸭子类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:  <span class="comment"># 假设是单个字符串</span></span><br><span class="line">    field_names = field_names.replace(<span class="string">','</span>, <span class="string">' '</span>).split()  <span class="comment"># 试图替换并拆分</span></span><br><span class="line"><span class="keyword">except</span> AttributeError:  <span class="comment"># 抱歉，field_names看起来不像是字符串...</span></span><br><span class="line">    <span class="keyword">pass</span>                <span class="comment"># 没有.replace方法，或者返回值不能使用.split方法拆分</span></span><br><span class="line"><span class="comment"># 假设已经是由名称组成的可迭代对象了</span></span><br><span class="line">field_names = tuple(field_names)  <span class="comment"># 确保是可迭代对象，也为了保存一份副本，使用所得值创建一个元组</span></span><br></pre></td></tr></table></figure><h1 id="定义抽象基类的子类">定义抽象基类的子类</h1><img data-src="http://www.plantuml.com/plantuml/svg/ZLBB4e8m3Bpp5Vq1_i2R9m-U_02ca1tf37rOWgCY_svLK5iLpN6pEybkKYk2W7Py51gwXCzasRAN5OkbDIoLWHTz9aBr6bnR6aG_KGPH5DMTrHP5DZorAuQNPODPgGgaMBPH9z2ife599DXrCDNyf2qu3DD1UUNaeM9oP2FfZ5icgCSUlWMb7MK8XnYgR6VuTULrnzTi_jgyZJR_p24qFpZ163n_CI-TWw4O6-t580xyHdJMfKfjztWBKHBTxlPygiKvpn_NonuF4yFtXqYmARS0frbU0000"><p>Sequence和MutableSequence抽象基类的方法不全是抽象的。以斜体显示的名称是抽象类和抽象方法。</p><figure class="highlight python"><figcaption><span>frenchdeck2.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">Card = collections.namedtuple(<span class="string">'Card'</span>, [<span class="string">'rank'</span>, <span class="string">'suit'</span>])</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrenchDeck2</span><span class="params">(collections.MutableSequence)</span>:</span>  <span class="comment"># 继承抽象基类</span></span><br><span class="line">    ranks = [str(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">11</span>)] + list(<span class="string">'JQKA'</span>)</span><br><span class="line">    suits = <span class="string">'spades diamonds clubs hearts'</span>.split()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._cards = [Card(rank, suit) <span class="keyword">for</span> suit <span class="keyword">in</span> self.suits</span><br><span class="line">                                        <span class="keyword">for</span> rank <span class="keyword">in</span> self.ranks]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._cards)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, position)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._cards[position]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, position, value)</span>:</span>  <span class="comment"># 支持洗牌必须实现__setitem__方法</span></span><br><span class="line">        self._cards[position] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span><span class="params">(self, position)</span>:</span>  <span class="comment"># 必须实现的基类抽象方法</span></span><br><span class="line">        <span class="keyword">del</span> self._cards[position]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, position, value)</span>:</span>  <span class="comment"># 必须实现的基类抽象方法</span></span><br><span class="line">        self._cards.insert(position, value)</span><br></pre></td></tr></table></figure><p>导入时（加载并编译frenchdeck2.py模块时），Python不会检查抽象方法的实现，在运行时实例化FrenchDeck2类时才会真正检查。因此，如果没有正确实现某个抽象方法，Python会抛出TypeError异常，并把错误消息设为&quot;Cant' instantiate abstract class FrenchDeck2 with abstract method <code>__delitem__</code>, insert&quot;。正是这个原因，即便FrenchDeck2类不需要<code>__delitem__</code>和insert提供的行为，也要实现，因为MutableSequence抽象基类需要它们。</p><p>我们还可以覆盖从抽象基类继承的方法，以更高效的方式重新实现。例如，<code>__contains__</code>方法会全面扫描序列，可是，如果你定义的序列按顺序保存元素，那就可以重新定义<code>__contains__</code>方法，使用bisect函数做二分查找，从而提升搜索速度。</p><h1 id="定义并使用一个抽象基类">定义并使用一个抽象基类</h1><p>为了证明有必要定义抽象基类，我们要在框架中找到使用它的场景。想象一下这个场景：你要在网站或移动应用中显示随机广告，但是在整个广告清单轮转一遍之前，不重复显示广告。假设我们构建一个广告管理框架，名为ADAM。它的职责之一是，支持用户提供随机挑选的无重复类。为了让ADAM的用户明确理解“随机挑选的无重复”组件是什么意思，我们将定义一个抽象基类。</p><p>受到“栈”和“队列”（以物体的排列方式说明抽象接口）启发，我将使用现实世界中的物品命名这个抽象基类：宾果机和彩票机是随机从有限的集合中挑选物品的机器，选出的物品没有重复，直到选完为止。我们把这个抽象基类命名为Tombola，这是宾果机和打乱数字的滚动容器的意大利名。</p><p>Tombola抽象基类有四个方法，其中两个是抽象方法。</p><ul><li><code>.load(...)</code>：把元素放入容器。</li><li><code>.pick()</code>：从容器中随机拿出一个元素，返回选中的元素。</li></ul><p>另外两个是具体方法：</p><ul><li><code>.loaded()</code>：如果容器中至少有一个元素，返回True。</li><li><code>.inspect()</code>返回一个有序元组，由容器中的现有元素构成，不会修改容器的内容（内部的顺序不保留）。</li></ul><img data-src="http://www.plantuml.com/plantuml/svg/dL2n3e8m4DtvYXjrW0ymX05NHlUcBHTiB9IqXuOW_sv56ekBqPkkxrxVlNjdLIDWszC8BRO2RSA58yibmScqmcWEKmA-fe3Fe0slT_jFj5VoigAfhwLvCZ5mLUTwbEHVSo8rTmvArJNco1jSTp2cEaMChH-YFP4uOv9hlP22JcM8q8wbDZUqlsXzyVUAe5AE8C-lojB0DRX1BDEYcFvH3gdczpHz1x25D_T4eooB71sy9ukDRz5YNHGF"><figure class="highlight python"><figcaption><span>tombola.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tombola</span><span class="params">(abc.ABC)</span>:</span>  <span class="comment"># 自定义的抽象基类要继承abc.ABC</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod        # 抽象方法使用abstractmethod装饰器标记</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">(self, iterable)</span>:</span>  <span class="comment"># 而且定义体中通常只有文档字符串</span></span><br><span class="line">        <span class="string">"""从可迭代对象中添加元素"""</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""随机删除元素，然后将其返回。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        如果实例为空，这个方法应该抛出LookupError。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loaded</span><span class="params">(self)</span>:</span>  <span class="comment"># 具体方法</span></span><br><span class="line">        <span class="string">"""如果至少有一个元素，返回True，否则返回False。"""</span></span><br><span class="line">        <span class="keyword">return</span> bool(self.inspect())  <span class="comment"># 具体方法只能依赖抽象基类定义的接口</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inspect</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回一个有序元组，由当前元素构成。"""</span></span><br><span class="line">        items = []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># 我们不知道具体子类如何存储元素，不过为了得到inpect的结果</span></span><br><span class="line">            <span class="keyword">try</span>:     <span class="comment"># 我们可以不断调用.pick()方法，把Tombola清空</span></span><br><span class="line">                items.append(self.pick())</span><br><span class="line">            <span class="keyword">except</span> LookupError:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        self.load(items)  <span class="comment"># 然后再使用.load(...)把所有元素放回去</span></span><br><span class="line">        <span class="keyword">return</span> tuple(sorted(items))</span><br></pre></td></tr></table></figure><p><strong>其实，抽象方法可以有实现代码。即便实现了，子类也必须覆盖抽象方法，但是在子类中可以使用super()函数调用抽象方法，为它添加功能，而不是从头开始实现。</strong></p><p>示例中的inspect()方法实现的方式有些笨拙，不过却表明，有了pick()和load(...)方法，若想查看Tombola中的内容，可以先把所有元素挑出，然后再放回去。这个示例的目的是强调抽象基类可以提供具体方法，只要依赖接口中的其他方法就行。Tombola的具体子类知晓内部数据结构，可以覆盖inspect()方法，使用更聪明的方式实现，但这不是强制要求。</p><p>loaded()方法没有那么笨拙，但是耗时：调用inspect()方法构建有序元组的目的仅仅是在其上调用bool()函数。这样做是可以的，但是具体子类可以做的更好。</p><p>self.pick()抛出LookupError这一事实也是接口的一部分，但是在Python中没办法声明，只能在文档中说明。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BaseException</span><br><span class="line"> +-- Exception</span><br><span class="line">      +-- LookupError</span><br><span class="line">      |    +-- IndexError</span><br><span class="line">      |    +-- KeyError</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> tombola <span class="keyword">import</span> Tombola</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Fake</span><span class="params">(Tombola)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="number">13</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fake  <span class="comment"># 创建子类，不会报错</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Fake</span>'&gt;</span></span><br><span class="line">&gt;&gt;&gt; f = Fake()  # 尝试实例化Fake时抛出了TypeError</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: Can<span class="string">'t instantiate abstract class Fake with abstract methods load  # Python认为Fake是抽象类，因为它没有实现load方法</span></span><br></pre></td></tr></table></figure><h2 id="抽象基类句法详解">抽象基类句法详解</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tombola</span><span class="params">(abc.ABC)</span>:</span>  <span class="comment"># Python3.4之后</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tombola</span><span class="params">(metaclass=abc.ABCMeta)</span>:</span>  <span class="comment"># Python3.4之前</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tombola</span><span class="params">(object)</span>:</span></span><br><span class="line">    __metaclass__ = abc.ABCMeta  <span class="comment"># Python2</span></span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>声明抽象类方法的推荐方式是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyABC</span><span class="params">(abc.ABC)</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">an_abstract_classmethod</span><span class="params">(cls, ...)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>在函数上堆叠装饰器的顺序通常很重要，<a href="https://devdocs.io/python~3.6/library/abc#abc.abstractmethod" target="_blank" rel="noopener">@abstractmethod的文档</a>就特别指出：</p><blockquote><p>When abstractmethod() is applied in combination with other method descriptors, it should be applied as the innermost decorator.</p></blockquote><h2 id="定义tombola抽象基类的子类">定义Tombola抽象基类的子类</h2><figure class="highlight python"><figcaption><span>bingo.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> tombola <span class="keyword">import</span> Tombola</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BingoCage</span><span class="params">(Tombola)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, items)</span>:</span></span><br><span class="line">        self._randomizer = random.SystemRandom()</span><br><span class="line">        self._items = []</span><br><span class="line">        self.load(items)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">(self, items)</span>:</span></span><br><span class="line">        self._items.extend(item)</span><br><span class="line">        self._randomizer.shuffle(self._items)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self._items.pop()</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">raise</span> LookupError(<span class="string">'pick from empty BingoCage'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.pick()</span><br></pre></td></tr></table></figure><p>BingoCage从Tombola中继承了耗时的loaded方法和笨拙的inspect方法。</p><figure class="highlight python"><figcaption><span>lotto.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> tombola <span class="keyword">import</span> Tombola</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LotteryBlower</span><span class="params">(Tombola)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, iterable)</span>:</span></span><br><span class="line">        self._balls = list(iterable)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">(self, iterable)</span>:</span></span><br><span class="line">        self._balls.extend(iterable)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            position = random.randrange(len(self._balls))</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">raise</span> LookupError(<span class="string">'pick from empty LotteryBlower'</span>)</span><br><span class="line">        <span class="keyword">return</span> self._balls.pop(position)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loaded</span><span class="params">(self)</span>:</span>  <span class="comment"># 覆盖基类方法</span></span><br><span class="line">        <span class="keyword">return</span> bool(self._balls)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inspect</span><span class="params">(self)</span>:</span>  <span class="comment"># 覆盖基类方法</span></span><br><span class="line">        <span class="keyword">return</span> tuple(sorted(self._balls))</span><br></pre></td></tr></table></figure><h2 id="tombola的虚拟子类">Tombola的虚拟子类</h2><p>白鹅类型的一个基本特性：即便不继承，也有办法把一个类注册为抽象基类的虚拟子类。这样做时，我们保证注册的类忠实地实现了抽象基类定义的接口，而Python会相信我们，从而不做检查（即便在实例化时也不会检查）。如果我们说谎了，那么常规的运行时异常会把我们捕获。</p><p>注册虚拟子类的方式是在抽象基类上调用register方法。这么做之后，注册的类会变成抽象基类的虚拟子类，而且issubclass和isinstance等函数都能识别，但是注册的类不会从抽象基类中继承任何方法或属性。</p><p>register方法通常作为普通的函数调用，不过也可以作为装饰器使用。</p><img data-src="http://www.plantuml.com/plantuml/svg/ROz93i8m34NtEOKlG0w0Aau0AzXN6RxQY0mbCHAexTqfWmG4lBAVRFdztbaGmi1N2WWQMIXTE2l3j3kpqXvxdCw81i9uLGfvLvX6GKkD0TmdErFRkkYuRMlg4Mk82oFQUb6dvEjDAQMOtpQ757JowcNncBP_L0PdZj_49sL_2IhcOXbWUFbOnQPcajbrFSjdz3KrJKQtjCYmcuruq6PQhTvIuYLxlvKVhlNj3G00"><figure class="highlight python"><figcaption><span>tombolist.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randrange</span><br><span class="line"><span class="keyword">from</span> tombola <span class="keyword">import</span> Tombola</span><br><span class="line"></span><br><span class="line"><span class="meta">@Tombola.register  # 把TomboList注册为Tombola的虚拟子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TomboList</span><span class="params">(list)</span>:</span>  <span class="comment"># TomboList扩展list</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self:  <span class="comment"># 从list继承__bool__方法，列表不为空时返回True</span></span><br><span class="line">            position = randrange(len(self))</span><br><span class="line">            <span class="keyword">return</span> self.pop(position)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> LookupError(<span class="string">'pop from empty TomboList'</span>)</span><br><span class="line"></span><br><span class="line">    load = list.extend  <span class="comment"># TomboList.load与list.extend一样</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># loaded = list.__bool__ 是错误的，因为list没有实现__bool__方法</span></span><br><span class="line">    <span class="comment"># 而内置的bool函数在没有实现__bool__方法时还可以使用__len__方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loaded</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(self)  <span class="comment"># 委托bool函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inspect</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> tuple(sorted(self))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是Python3.3之前的版本，不能把register当作类装饰器使用，必须使用标准的调用句法</span></span><br><span class="line"><span class="comment"># Tombola.register(TomboList)</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> tombola <span class="keyword">import</span> Tombola</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> tombolist <span class="keyword">import</span> TomboList</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(TomboList, Tombola)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = TomboList(range(<span class="number">100</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(t, Tombola)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>然而，类的继承关系在一个特殊的类属性中指定——<code>__mro__</code>，即方法解析顺序（Method Resolution Order）。这个属性的作用很简单，按顺序列出类及其超类，Python会按照这个顺序搜索方法。查看TomboList类的<code>__mro__</code>属性，你会发现它只列出了“真实的”超类，即list和object。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>TomboList.__mro__</span><br><span class="line">(&lt;class 'tombolist.TomboList'&gt;, &lt;class 'list'&gt;, &lt;class 'object'&gt;)</span><br></pre></td></tr></table></figure><p><code>TomboList.__mro__</code>中没有Tombola，因此TomboList没有从Tombola中继承任何方法。</p><h1 id="鹅的行为有可能像鸭子">鹅的行为有可能像鸭子</h1><p>即便不注册，抽象基类也能把一个类识别为虚拟子类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Struggle</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span> <span class="keyword">return</span> <span class="number">23</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(Struggle(), abc.Sized)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(Struggle, abc.Sized)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>这是因为abc.Sized实现了一个特殊的类方法，名为<code>__subclasshook__</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sized</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line"></span><br><span class="line">    __slots__ = ()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__subclasshook__</span><span class="params">(cls, C)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">is</span> Sized:</span><br><span class="line">            <span class="keyword">if</span> any(<span class="string">"__len__"</span> <span class="keyword">in</span> B.__dict__ <span class="keyword">for</span> B <span class="keyword">in</span> C.__mro__):  <span class="comment"># 对C及其超类中所列的类来说，如果有名为__len__的属性</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span>  <span class="comment"># 返回True，表明C是Sized的虚拟子类</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span>  <span class="comment"># 否则返回NotImplemented</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://devdocs.io/python~3.6/library/abc#abc.ABCMeta.__subclasshook__" target="_blank" rel="noopener"><code>__subclasshook__(subclass)</code></a></p><p><strong>(Must be defined as a class method.)</strong></p><p>Check whether subclass is considered a subclass of this ABC.This means that you can customize the behavior of issubclass further without the need to call register() on every class you want to consider a subclass of the ABC. (This class method is called from the <strong>subclasscheck</strong>() method of the ABC.)</p><p>This method should return True, False or NotImplemented.If it returns True, the subclass is considered a subclass of this ABC.If it returns False, the subclass is not considered a subclass of this ABC, even if it would normally be one.If it returns NotImplemented, the subclass check is continued with the usual mechanism.</p></blockquote><p><code>__subclasshook__</code>在白鹅类型中添加了一些鸭子类型的踪迹。</p><p>在自己定义的抽象基类中要不要实现<code>__subclasshook__</code>方法呢？可能不需要。我在Python源码中只见到Sized这一个抽象基类实现了<code>__subclasshook__</code>方法，而Sized只声明了一个特殊方法，因此只用检查这么一个特殊方法。鉴于<code>__len__</code>方法的“特殊性”，我们基本可以确定它能做到该做的事。但是对其他特殊方法和基本的抽象基类来说，很难这么肯定。</p><p>例如，虽然映射实现了<code>__len__</code>、<code>__getitem__</code>和<code>__iter__</code>，但是不应该把它们视作Sequence的子类型，因为不能使用整数偏移值获取元素，也不能保证元素的顺序。当然，OrderedDict除外，它保留了插入元素的顺序，但是不支持通过偏移获取元素。</p><p>自己实现的<code>__subclasshook__</code>方法还可以检查方法签名和其他特性，但我觉得不值得这么做。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口：协议</title>
      <link href="/notes/fluent-python/interfaces-protocols/"/>
      <url>/notes/fluent-python/interfaces-protocols/</url>
      
        <content type="html"><![CDATA[<h1 id="python文化中的接口和协议">Python文化中的接口和协议</h1><p>接口在动态类型语言中是怎么运作的呢？首先，基本的事实是，Python语言没有interface关键字，而且除了抽象基类，每个类都有接口：类实现或继承的公开属性（方法或数据属性），包括特殊方法，如<code>__getitem__</code>或<code>__add__</code>。</p><p>按照定义，受保护的属性和私有属性不在接口中：即便“受保护的”属性也只是采用命名约定实现的（单个前导下划线）；私有属性可以轻松地访问，原因也是如此。不要违背这些约定有意访问私有属性。</p><p>另一方面，不要觉得把公开数据属性放入对象的接口中不妥，因为如果需要，总能实现读值方法和设值方法，把数据属性变成特性，使用obj.attr句法的客户代码不会收到影响。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span>:</span></span><br><span class="line">    typecode = <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = float(x)  <span class="comment"># x和y是公开数据属性</span></span><br><span class="line">        self.y = float(y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (i <span class="keyword">for</span> i <span class="keyword">in</span> (self.x, self.y))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 其他方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重构：把x和y变成只读特性，但是Vector2d的基本接口没变：</span></span><br><span class="line"><span class="comment"># 用户仍能读取my_vector.x和my_vector.y</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span>:</span></span><br><span class="line">    typecode = <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.__x = float(x)</span><br><span class="line">        self.__y = float(y)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__x</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">y</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__y</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 不受影响</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (i <span class="keyword">for</span> i <span class="keyword">in</span> (self.x, self.y))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 其他方法</span></span><br></pre></td></tr></table></figure><p>关于接口，这里有个实用的补充定义：对象公开方法的子集，让对象在系统中扮演特定的角色。Python文档中的“文件类对象”或“可迭代对象”就是这个意思，这种说法指的不是特定的类。</p><p>协议是接口，但不是正式的（只由文档和约定定义），因此协议不能像正式接口那样施加限制。一个类可能只实现部分接口，这是允许的。</p><h1 id="python喜欢序列">Python喜欢序列</h1><img data-src="http://www.plantuml.com/plantuml/svg/VP113i8W44Ntd68kq1kuS-NQ0n0AFvQaK8MfKIjt5rDj0mjc-UU_p9y_M0E2k_AJ75oF85GVEIZDT9myA-iHQ16KPt7WOJA9bhybaPHwTKKfHThP4oEeVaGJjTbKOcVxWcao8to5u3R3w_Qb2pWVSvdyUheyfRbuezhyKbPgm1qXmjGRwmqUfQIdsNEElFTvU7VT5bniNPNosaMXVG00"><p>箭头由子类指向超类，以斜体显示的是抽象方法。</p><p>现在，看看示例中的Foo类。它没有继承abc.Sequence，而且只实现了序列协议的一个方法<code>__getitem__</code>（没有实现<code>__len__</code>方法）。这样足够访问元素、迭代和使用in运算符了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, pos)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> range(<span class="number">0</span>, <span class="number">30</span>, <span class="number">10</span>)[pos]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">1</span>]</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> f: print(i)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">20</span> <span class="keyword">in</span> f</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">15</span> <span class="keyword">in</span> f</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>Python数据模型的哲学是尽量支持基本协议。对序列来说，即便是最简单的实现，Python也会力求做到最好。鉴于序列协议的重要性，如果没有<code>__iter__</code>和<code>__contains__</code>方法，Python会调用<code>__getitem__</code>方法，设法让迭代和in运算符可用。Python中的迭代是鸭子类型的一种极端形式：为了迭代对象，解释器会尝试调用两个不同的方法。</p><h1 id="使用猴子补丁在运行时实现协议">使用猴子补丁在运行时实现协议</h1><p>示例中的FrenchDeck类有个重大缺陷：无法洗牌。如果FrenchDeck实例的行为像序列，那么它就不需要shuffle方法，因为已经有random.shuffle函数可用。如果遵守既定协议，很有可能增加利用现有的标准库和第三方代码的可能性，这得益于鸭子类型。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/random#random.shuffle" target="_blank" rel="noopener"><code>random.shuffle(x[, random])</code></a></p><p>Shuffle the sequence x in place.</p></blockquote><figure class="highlight python"><figcaption><span>frenchdeck.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">Card = collections.namedtuple(<span class="string">'Card'</span>, [<span class="string">'rank'</span>, <span class="string">'suit'</span>])</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrenchDeck</span>:</span>  <span class="comment"># 实现序列协议的FrenchDeck类</span></span><br><span class="line">    ranks = [str(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">11</span>)] + list(<span class="string">'JQKA'</span>)</span><br><span class="line">    suits = <span class="string">'spades diamonds clubs hearts'</span>.split()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._cards = [Card(rank, suit) <span class="keyword">for</span> suit <span class="keyword">in</span> self.suits</span><br><span class="line">                       <span class="keyword">for</span> rank <span class="keyword">in</span> self.ranks]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._cards)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._cards[item]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> frenchdeck <span class="keyword">import</span> FrenchDeck</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> random <span class="keyword">import</span> shuffle</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck = FrenchDeck()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shuffle(deck)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"/Users/cws/opt/anaconda3/envs/python36/lib/python3.6/random.py"</span>, line <span class="number">277</span>, <span class="keyword">in</span> shuffle</span><br><span class="line">    x[i], x[j] = x[j], x[i]</span><br><span class="line">TypeError: <span class="string">'FrenchDeck'</span> object does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure><p>然而，如果尝试打乱FrenchDeck实例，会出现异常。错误消息相当明确，对象不支持为元素赋值。FrenchDeck只实现了不可变序列协议，可变的序列还必须提供<code>__setitem__</code>方法。Python是动态语言，因此我们可以在运行时修正这个问题，甚至还可以在交互式控制台中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">set_card</span><span class="params">(deck, position, card)</span>:</span></span><br><span class="line"><span class="meta">... </span>    deck._cards[position] = card</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>FrenchDeck.__setitem__ = set_card</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shuffle(deck)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[:<span class="number">5</span>]</span><br><span class="line">[Card(rank=<span class="string">'5'</span>, suit=<span class="string">'spades'</span>), Card(rank=<span class="string">'5'</span>, suit=<span class="string">'clubs'</span>), Card(rank=<span class="string">'Q'</span>, suit=<span class="string">'clubs'</span>), Card(rank=<span class="string">'10'</span>, suit=<span class="string">'clubs'</span>), Card(rank=<span class="string">'5'</span>, suit=<span class="string">'hearts'</span>)]</span><br></pre></td></tr></table></figure><p>特殊方法<code>__setitem__</code>的签名在语言参考中使用的是self、key和value，而这里使用的是deck、position和card。这么做是为了告诉你，每个Python方法说到底都是普通函数，把第一个参数命名为self只是一种约定。在控制台会话中使用那几个参数没问题，不过在Python源码文件中最好按照文档那样使用self、key和value。</p><p>这里的关键是，<code>set_card</code>函数要知道deck对象有一个名为<code>_cards</code>的属性，而且<code>_cards</code>的只必须是可变序列。然后，我们把<code>set_card</code>函数赋值给特殊方法<code>__setitem__</code>，从而把它依附到FrenchDeck类上。这种技术叫猴子补丁：在运行时修改类或模块，而不改动源码。猴子补丁很强大，但是打补丁的代码与要打补丁的程序耦合十分紧密，而且往往要处理隐藏和没有文档的部分。</p><p>除了举例说明猴子补丁之外，示例还强调了协议是动态的：random.shuffle函数不关心参数的类型，只要那个对象实现了部分可变序列协议即可。即便对象一开始没有所需的方法也没关系，后来再提供也行。目前，本章讨论的主题是“鸭子类型”：对象的类型无关紧要，只要实现了特定的协议即可。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> protocols </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/notes/the-art-of-design-patterns/creational-patterns-singleton/"/>
      <url>/notes/the-art-of-design-patterns/creational-patterns-singleton/</url>
      
        <content type="html"><![CDATA[<h1 id="定义">定义</h1><p>单例模式（Singleton Pattern）：确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。</p><p>单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。</p><h1 id="意图">意图</h1><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><a id="more"></a><h1 id="动机">动机</h1><p>对一些类来说，只有一个实例是很重要的。一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID（序号）生成器。</p><p>怎样才能保证一个类只有一个实例并且这个实例易于被访问呢？一个全局变量使得一个对象可以被访问，但它不能防止你实例化多个对象。</p><p>一个更好的办法是，让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求），并且它可以提供一个访问该实例的方法。这就是Singleton模式。</p><h1 id="适用性">适用性</h1><ul><li>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。</li><li>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无须更改代码就能使用一个扩展的实例时。</li></ul><h1 id="结构">结构</h1><img data-src="http://www.plantuml.com/plantuml/svg/RO-nRi9044Jx-uefJP0jQ454Iec4Ge6e8egBRx5NCMlhRX62Y7-FSo5d5sot-qOpipKx0fqwlUB8rBXWmXTBPxqzeMni26-gdZ_FIkkobHtV23CJ0NOiLKFQ2huD-id14jHAILWCCA8fAjBrWsQJ9ppyxzkEl5Lk9PiyN9EqlzpDaFgIvw-Z4eiKRwHLWWsGURJW8x9KRRN2-twp-JEFD148NSPfowZnf6SlIROq90w_2KRcA3nNjHQZTuP2nKVDpf4SYhx83m00"><h1 id="时序图">时序图</h1><img data-src="http://www.plantuml.com/plantuml/svg/IqmkoIzIy4tCpEC24GgwTWh1cNdfEQab-NaALWhfgIMUUSKbYNd9gHgQG3vSZWkX2asBZKroKMfYIQgT7LOJYs5i_uBKeiIIpFmy3Kq0"><h1 id="优点">优点</h1><ul><li>对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。</li><li>节约系统资源。由于在系统内只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。</li><li>允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制类似的方法来获得指定数目的对象实例。</li></ul><h1 id="缺点">缺点</h1><ul><li>由于单例模式没有抽象层，因此单例类的扩展有很大困难。</li><li>单例类的职责过重，在一定程度上违反了单一职责原则。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品本身的功能耦合在一起。</li><li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；很多面向对象语言（如Java，C#）的运行环境都提供了自动垃圾回收技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。</li></ul><h1 id="应用">应用</h1><p>一个具有自动编号主键的表可以有多个用户同时使用，但是数据库中只能有一个地方分配下一个主键编号，否则可能会出现主键重复，因此该主键编号生成器必须具备唯一性，可以通过单例模式来实现。</p><h1 id="java代码">Java代码</h1><p>UML类图中的创建方式是不安全的。当创建过程稍长，就可能有多个线程同时进入if块内，重复创建单例类，导致对象状态丢失。下面看看解决方案。</p><p>运用一项叫做Initialization on Demand Holder（IoDH）的技术，既能实现延迟加载（Lazy Load），又可以保证线程安全，不影响系统性能。缺点是与编程语言本身的特性相关，很多面向对象语言不支持IoDH。做法是在单例类中增加一个静态内部类，在该内部类中创建单例对象，再将该单例对象通过getInstance()方法返回给外部使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于静态单例对象不是Singleton的成员变量，因此类加载时不会实例化Singleton，第一次调用getInstance()时将加载内部类Holder，在该内部类中定义了一个static类型的变量instance，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全，确保该成员变量只能初始化一次。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> design patterns </tag>
            
            <tag> The Art of Design Patterns </tag>
            
            <tag> creational </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列的修改、散列和切片</title>
      <link href="/notes/fluent-python/sequence-hacking-hashing-and-slicing/"/>
      <url>/notes/fluent-python/sequence-hacking-hashing-and-slicing/</url>
      
        <content type="html"><![CDATA[<h1 id="表示多维向量的vector类">表示多维向量的Vector类</h1><p>本章定义的Vector类是为了教学而使用的例子。如果在实际使用中需要做向量运算，应该使用NumPy和SciPy。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    typecode = <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, components)</span>:</span></span><br><span class="line">        <span class="comment"># 使用组合模式实现，向量的分量存储在浮点数数组中</span></span><br><span class="line">        self._components = array(self.typecode, components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 使用reprlib.repr()函数获取self._components的有限长度表示形式</span></span><br><span class="line">        <span class="comment"># 如 array('d', [0.0, 1.0, 2.0, 3.0, 4.0, ...])</span></span><br><span class="line">        components = reprlib.repr(self._components)</span><br><span class="line">        <span class="comment"># 去掉 [] 外面的字符</span></span><br><span class="line">        <span class="comment"># 我希望Vector实例的表示形式是 Vector([3.0, 4.0, 5.0])这样</span></span><br><span class="line">        <span class="comment"># 而不是 Vector(array('d', [3.0, 4.0, 5.0]))</span></span><br><span class="line">        <span class="comment"># 因为Vector实例中的数组是实现细节</span></span><br><span class="line">        <span class="comment"># 这两种所构建的Vector对象是一样的，所以我选择使用更简单的句法</span></span><br><span class="line">        components = components[components.find(<span class="string">'['</span>):<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Vector(&#123;&#125;)'</span>.format(components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(tuple(self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bytes__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (bytes([ord(self.typecode)]) +</span><br><span class="line">                bytes(self._components))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> tuple(self) == tuple(other)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 不能使用hypot方法了，先计算所有分量的平方和，在使用sqrt方法</span></span><br><span class="line">        <span class="keyword">return</span> math.sqrt(sum(x * x <span class="keyword">for</span> x <span class="keyword">in</span> self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(abs(self))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">frombytes</span><span class="params">(cls, octets)</span>:</span></span><br><span class="line">        typecode = chr(octets[<span class="number">0</span>])</span><br><span class="line">        memv = memoryview(octets[<span class="number">1</span>:]).cast(typecode)</span><br><span class="line">        <span class="keyword">return</span> cls(memv)</span><br></pre></td></tr></table></figure><p>如果Vector实例的分量超过6个，repr()生成的字符串就会使用...省略一部分。包含大量元素的集合类型一定要这么做，因为字符串表示形式是用于调试的（因此不想让大型对象在控制台或日志中输出几千行内容）。使用reprlib模块可以生成长度有限的表示形式。</p><a id="more"></a><p>编写<code>__repr__</code>方法时，本可以使用这个表达式生成简化的components显示形式：<code>reprlib.repr(list(self._components))</code>。然而，这么做有点浪费，因为要把<code>self._components</code>中的每个元素复制到一个列表中，然后使用列表的表示形式。我没有这么做，而是直接把<code>self._components</code>传给reprlib.repr函数，然后去掉[]外面的字符。</p><h1 id="协议和鸭子类型">协议和鸭子类型</h1><p>在Python中创建功能完善的序列类型无需使用继承，只需实现符合序列<strong>协议</strong>的方法。</p><p>在面向对象编程中，协议是非正式的接口，只在文档中定义，在代码中不定义。例如，Python的序列协议只需要<code>__len__</code>和<code>__getitem__</code>两个方法。任何类，只要使用标准的签名和语义实现了这两个方法，就能用在任何期待序列的地方。即便它是object的子类也无妨，我们说它是序列，因为它的行为像序列，这才是重点。</p><p>协议是非正式的，没有强制力，因此如果你知道类的具体使用场景，通常只需要实现一个协议的部分。例如，为了支持迭代，只需实现<code>__getitem__</code>方法，没必要提供<code>__len__</code>方法。</p><h1 id="可切片的序列">可切片的序列</h1><p>如果能委托给对象中的序列属性（如<code>self._componetns</code>数组），支持序列协议特别简单。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    <span class="comment"># 省略</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._components[index]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(v1)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1[<span class="number">0</span>], v1[<span class="number">-1</span>]</span><br><span class="line">(<span class="number">3.0</span>, <span class="number">5.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v7 = Vector(range(<span class="number">7</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v7[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">array(<span class="string">'d'</span>, [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>])</span><br></pre></td></tr></table></figure><p>可以看到，现在连切片都支持了，不过尚不完美。如果Vector实例的切片也是Vector实例，而不是数组，那就更好了。想想内置的序列类型，切片得到的都是各自类型的新实例，而不是其他类型。为了把Vector实例的切片也变成Vector实例，我们不能简单地委托给数组切片。我们要分析给<code>__getitem__</code>方法的参数，做适当的处理。</p><h2 id="切片原理">切片原理</h2><p>一例胜千言。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MySeq</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> index  <span class="comment"># 直接返回index</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = MySeq()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>]  <span class="comment"># 单个索引</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>:<span class="number">4</span>]  <span class="comment"># 1:4表示法变成了一个slice对象</span></span><br><span class="line">slice(<span class="number">1</span>, <span class="number">4</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>]</span><br><span class="line">slice(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>, <span class="number">9</span>]  <span class="comment"># 如果[]中有逗号，那么__getitem__收到的是元组</span></span><br><span class="line">(slice(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>), <span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>, <span class="number">7</span>:<span class="number">9</span>]  <span class="comment"># 元组中可以有多个切片对象</span></span><br><span class="line">(slice(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>), slice(<span class="number">7</span>, <span class="number">9</span>, <span class="literal">None</span>))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>slice  <span class="comment"># slice是内置的类型</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">slice</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">dir</span><span class="params">(slice)</span></span></span><br><span class="line">['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'indices', 'start', 'step', 'stop']</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(slice.indices)  <span class="comment"># slice.indices方法有很大的作用，但鲜为人知</span></span><br><span class="line">Help on method_descriptor:</span><br><span class="line"></span><br><span class="line">indices(...)</span><br><span class="line">    S.indices(len) -&gt; (start, stop, stride)</span><br><span class="line"></span><br><span class="line">    Assuming a sequence of length len, calculate the start <span class="keyword">and</span> stop</span><br><span class="line">    indices, <span class="keyword">and</span> the stride length of the extended slice described by</span><br><span class="line">    S. Out of bounds indices are clipped <span class="keyword">in</span> a manner consistent <span class="keyword">with</span> the</span><br><span class="line">    handling of normal slices.</span><br><span class="line">    <span class="comment"># 中文翻译 #</span></span><br><span class="line">    给定长度为len的序列，计算S表示的扩展切片的起始（start）和结尾（stop）索引，以及步幅（stride）。超出边界的索引会被截掉，这与常规切片的处理方式一样。</span><br></pre></td></tr></table></figure><p>indices方法开放了内置序列实现的棘手逻辑，用于优雅地处理缺失索引和负数索引，以及长度超过目标序列的切片。这个方法会“整顿”元组，把start、stop和stride都变成非负数，而且都落在指定长度序列的边界内。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设有个长度为5的序列，例如'ABCDE'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>slice(<span class="literal">None</span>, <span class="number">10</span>, <span class="number">2</span>).indices(<span class="number">5</span>)</span><br><span class="line">(<span class="number">0</span>, <span class="number">5</span>, <span class="number">2</span>)  <span class="comment"># 'ABCDE'[:10:2]等同于'ABCDE'[0, 5, 2]</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>slice(<span class="number">-3</span>, <span class="literal">None</span>, <span class="literal">None</span>).indices(<span class="number">5</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>)  <span class="comment"># 'ABCDE'[-3:]等同于'ABCDE'[2:5:1]</span></span><br></pre></td></tr></table></figure><p>在Vector类中无需使用slice.indices()方法，因为收到切片参数时，会委托_components数组处理。但是，如果没有底层序列类型作为依靠，那么使用这个方法能节省大量时间。</p><h2 id="能处理切片的__getitem__方法">能处理切片的<code>__getitem__</code>方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numbers  <span class="comment"># 开头导入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类中定义</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        cls = type(self)</span><br><span class="line">        <span class="keyword">if</span> isinstance(index, slice):  <span class="comment"># 切片</span></span><br><span class="line">            <span class="keyword">return</span> cls(self._components[index])</span><br><span class="line">        <span class="keyword">elif</span> isinstance(index, numbers.Integral):  <span class="comment"># 单个索引</span></span><br><span class="line">            <span class="keyword">return</span> self._components[index]</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 否则抛出异常</span></span><br><span class="line">            msg = <span class="string">'&#123;cls.__name__&#125; indices must be integers'</span></span><br><span class="line">            <span class="keyword">raise</span> TypeError(msg.format(cls=cls))  <span class="comment"># 为了创建符合Python风格的对象，我们要模仿Python内置的对象</span></span><br></pre></td></tr></table></figure><p>大量使用isinstance可能表明面向对象设计得不好，不过在<code>__getitem__</code>方法中使用它处理切片是合理的。numbers.Integral是一个抽象基类（Abstract Base Class，ABC），在isinstance中使用抽象基类做测试能让API更灵活且更容易更新。</p><h1 id="动态存取属性">动态存取属性</h1><p>Vector类没办法通过名称访问向量的分量（如v.x）。现在我们处理的向量可能有大量分量。不过，若能通过单个字母访问前几个分量的话会比较方便。</p><p>比如，用x、y、z和t代替v[0], v[1], v[2]和v[3]。我们可以在Vector中编写四个特性，但这样太麻烦。特殊方法<code>__getattr__</code>提供了更好的方式。属性查找失败后，解释器会调用<code>__getattr__</code>方法。简单来说，对my_obj.x表达式，Python会检查my_obj实例有没有名为x的属性；如果没有，到类（<code>my_obj.__class__</code>）中查找；如果还没有，顺着继承树继续查找（属性查找机制比这复杂的多）。如果依旧找不到，调用my_obj所属类中定义的<code>__getattr__</code>方法，传入self和属性名称的字符形式（如'x'）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 类中定义</span></span><br><span class="line">shortcut_names = <span class="string">'xyzt'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        cls = type(self)</span><br><span class="line">        <span class="keyword">if</span> len(name) == <span class="number">1</span>:</span><br><span class="line">            pos = cls.shortcut_names.find(name)</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= pos &lt; len(self._components):</span><br><span class="line">                <span class="keyword">return</span> self._components[pos]</span><br><span class="line">        msg = <span class="string">'&#123;.__name__!r&#125; object has no attribute &#123;!r&#125;'</span></span><br><span class="line">        <span class="keyword">raise</span> AttributeError(msg.format(cls, name))</span><br></pre></td></tr></table></figure><p><code>__getattr__</code>方法的实现不难，但是这样实现还不够。看看示例中古怪的交互行为。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v = Vector(range(<span class="number">5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v</span><br><span class="line">Vector([<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v.x</span><br><span class="line"><span class="number">0.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v.x = <span class="number">10</span>  <span class="comment"># 实例v中会新增一个属性x</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v.x  <span class="comment"># 属性x存在于实例中，因此直接返回它，不会调用__getattr__方法</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v  <span class="comment"># 向量的分量不会变</span></span><br><span class="line">Vector([<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>])</span><br></pre></td></tr></table></figure><p>为了避免这种现象，要改写Vector类中设置属性的逻辑。在Vector类中，如果为名称是单个小写字母的属性赋值，抛出AttributeError。为此，要实现<code>__setattr__</code>方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 类中定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line">        cls = type(slef)</span><br><span class="line">        <span class="keyword">if</span> len(name) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> name <span class="keyword">in</span> cls.shortcut_names:</span><br><span class="line">                error = <span class="string">'readonly attribute &#123;attr_name!r&#125;'</span></span><br><span class="line">            <span class="keyword">elif</span> name.islower():  <span class="comment"># 禁止为单个小写字母属性赋值</span></span><br><span class="line">                error = <span class="string">"can't set attributes 'a' to 'z' in &#123;cls_name!r&#125;"</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                error = <span class="string">''</span></span><br><span class="line">            <span class="keyword">if</span> error:</span><br><span class="line">                msg = error.format(cls_name=cls.__name__, attr_name=name)</span><br><span class="line">                <span class="keyword">raise</span> AttributeError(msg)</span><br><span class="line">        super().__setattr__(name, value)  <span class="comment"># 默认情况，在超类上调用__setattr__方法，提供标准行为</span></span><br></pre></td></tr></table></figure><p>不建议只为了避免创建实例属性而使用<code>__slots__</code>属性。<code>__slots__</code>属性只应该用于节省内存，而且仅当内存严重不足时才应该这么做。</p><p>虽然这个示例不支持为Vector分量赋值，但是有一个问题需要特别注意：多数时候，如果实现了<code>__getattr__</code>方法，那么也要定义<code>__setattr__</code>方法，以防对象的行为不一致。</p><h1 id="散列和快速等值测试">散列和快速等值测试</h1><p>我们要再次实现<code>__hash__</code>方法。加上现有的<code>__eq__</code>方法，这会把Vector实例变成可散列的对象。Vector2d中的<code>__hash__</code>方法简单地计算hash(self.x) ^ hash(self.y)。这一次，我们要使用异或运算符依次计算各个分量的散列值，像这样：v[0] ^ v[1] ^ v[2]...。这正是functools.reduce函数的作用。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/functools#functools.reduce" target="_blank" rel="noopener"><code>functools.reduce(function, iterable[, initializer])</code></a></p><p>Apply function of two arguments cumulatively to the items of sequence, from left to right, so as to reduce the sequence to a single value. For example, <code>reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])</code> calculates <code>((((1+2)+3)+4)+5)</code>.</p></blockquote><p>functools.reduce()的原理。它的关键思想是，把一系列值归约成单个值。reduce()函数的第一个参数是接受两个参数的函数，第二个参数是一个可迭代的对象。假如有个接受两个参数的fn函数和一个lst列表。调用reduce(fn, lst)时，fn会应用到第一对元素上，即fn(lst[0], lst[1])，生成第一个结果r1。然后，fn会应用到r1和下一个元素上，即fn(r1, lst[2])，生成第二个结果r2...直到最后一个元素，返回最后得到的结果rN。</p><p>使用reduce函数时最好提供第三个参数，这样能避免这个异常：TypeError: reduce() of empty sequence with no initial value。如果序列为空，initializer是返回的结果；否则，在归约中使用它作为第一个参数，因此应该使用恒等值。比如，对<code>+</code>、<code>|</code>和<code>^</code>来说，initializer应该是0；而对<code>*</code>和<code>&amp;</code>来说，应该是1。</p><p>回到散列问题上，计算聚合异或有3种方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算整数0～5的累计异或</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">6</span>):  <span class="comment"># 使用循环</span></span><br><span class="line"><span class="meta">... </span>    n ^= i</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> functools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>functools.reduce(<span class="keyword">lambda</span> a, b: a^b, range(<span class="number">6</span>))  <span class="comment"># 使用匿名函数和reduce函数</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> operator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>functools.reduce(operator.xor, range(<span class="number">6</span>))  <span class="comment"># 使用运算符函数和reduce函数</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>编写<code>Vector.__hash__</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类中定义</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span>  <span class="comment"># 为了提高比较效率</span></span><br><span class="line">        <span class="comment"># tuple(self) == tuple(other) 要完整复制两个操作数</span></span><br><span class="line">        <span class="comment"># 构建两个元组，效率十分低下</span></span><br><span class="line">        <span class="keyword">if</span> len(self) != len(other):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 长度比较非常有必要，因为一旦有一个输入耗尽</span></span><br><span class="line">        <span class="comment"># zip函数会立即停止生成值，而不发出警告</span></span><br><span class="line">        <span class="comment"># 若无长度比较，可能会发生 Vector([1]) == Vector([1, 2]) is True</span></span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(self, other):</span><br><span class="line">            <span class="keyword">if</span> a != b:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">        hashes = (hash(x) <span class="keyword">for</span> x <span class="keyword">in</span> self._components)  <span class="comment"># 创建一个生成器表达式，惰性计算各个分量的散列值</span></span><br><span class="line">        <span class="keyword">return</span> functools.reduce(operator.xor, hashes, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img data-src="/uploads/posts/fluent-python/map-reduce.png"></p><p>示例中实现的<code>__hash__</code>方法是一种映射归约计算。把函数应用到各个元素上，生成一个新序列（映射，map），然后计算聚合值（规约，reduce）。映射过程计算各个分量的散列值，归约过程则使用xor运算符聚合所有散列值。把生成器表达式替换成map方法，映射过程更明显：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">    hashes = map(hash, self._components)  <span class="comment"># 与Python3生成器表达式原理一样</span></span><br><span class="line">    <span class="keyword">return</span> functools.reduce(operator.xor, hashes)</span><br></pre></td></tr></table></figure><p>示例中的<code>__eq__</code>方法的效率很好（不过Vector([1, 2] == (1, 2)的问题仍然存在），不过用于计算聚合值的整个for循环可以替换成一行all函数调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> len(self) == len(other) <span class="keyword">and</span> all(a == b <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(self, other))</span><br></pre></td></tr></table></figure><p><em>zip函数的名字取自拉链系结物（zipper fastener），因为这个物品用于把两个拉链边的链牙咬合在一起，这形象地说明了zip(left, right)的作用。zip函数与文件压缩没有关系。</em></p><p>zip函数在当一个可迭代对象耗尽后，它不发出警告就停止。itertools.zip_longest函数的行为有所不同：使用可选的fillvalue填充缺失的值，因此可以继续产出，直到最长的可迭代对象耗尽。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/itertools#itertools.zip_longest" target="_blank" rel="noopener"><code>itertools.zip_longest(*iterables, fillvalue=None)</code></a></p><p>Make an iterator that aggregates elements from each of the iterables. If the iterables are of uneven length, missing values are filled-in with fillvalue. Iteration continues until the longest iterable is exhausted.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>zip(range(<span class="number">3</span>), <span class="string">'ABCDE'</span>)</span><br><span class="line">&lt;zip object at <span class="number">0x10cc9c088</span>&gt;  <span class="comment"># zip返回一个生成器</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(range(<span class="number">3</span>), <span class="string">'ABCDE'</span>))</span><br><span class="line">[(<span class="number">0</span>, <span class="string">'A'</span>), (<span class="number">1</span>, <span class="string">'B'</span>), (<span class="number">2</span>, <span class="string">'C'</span>)]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(range(<span class="number">2</span>), <span class="string">'ABC'</span>, <span class="string">'DEFG'</span>))</span><br><span class="line">[(<span class="number">0</span>, <span class="string">'A'</span>, <span class="string">'D'</span>), (<span class="number">1</span>, <span class="string">'B'</span>, <span class="string">'E'</span>)]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> itertools <span class="keyword">import</span> zip_longest</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip_longest(range(<span class="number">2</span>), <span class="string">'ABC'</span>, <span class="string">'DEFG'</span>, fillvalue=<span class="number">-1</span>))</span><br><span class="line">[(<span class="number">0</span>, <span class="string">'A'</span>, <span class="string">'D'</span>), (<span class="number">1</span>, <span class="string">'B'</span>, <span class="string">'E'</span>), (<span class="number">-1</span>, <span class="string">'C'</span>, <span class="string">'F'</span>), (<span class="number">-1</span>, <span class="number">-1</span>, <span class="string">'G'</span>)]</span><br></pre></td></tr></table></figure><h1 id="格式化">格式化</h1><p>Vector类的<code>__format__</code>方法与Vector2d类的相似，但是不使用极坐标，而使用球面坐标（也叫超球面坐标，hyperspherical coordinate），因为Vector类支持n个维度，而超过四维后，球体变成了“超球体”。因此，我们会把自定义格式后缀‘p’变成‘h’。</p><p>在小幅度改动<code>__format__</code>方法之前，我们要定义两个辅助方法：一个是angle(n)，用于计算某个角坐标；另一个是angles()，返回由所有角坐标构成的可迭代对象。我们不会讲解其中涉及的数学原理，如果你好奇的话，可以查看维基百科中的“<a href="https://en.wikipedia.org/wiki/N-sphere" target="_blank" rel="noopener">n为球体</a>”词条，那里有几个公式，我就是使用它们把Vector实例分量数组内的笛卡尔坐标转换成球面坐标的。</p><p>最终版的doctest和全部代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">A multidimensional ``Vector`` class, take 5</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">A ``Vector`` is built from an iterable of numbers::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; Vector([3.1, 4.2])</span></span><br><span class="line"><span class="string">    Vector([3.1, 4.2])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; Vector((3, 4, 5))</span></span><br><span class="line"><span class="string">    Vector([3.0, 4.0, 5.0])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; Vector(range(10))</span></span><br><span class="line"><span class="string">    Vector([0.0, 1.0, 2.0, 3.0, 4.0, ...])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests with two dimensions (same results as ``vector2d_v1.py``)::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 = Vector([3, 4])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; x, y = v1</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; x, y</span></span><br><span class="line"><span class="string">    (3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1</span></span><br><span class="line"><span class="string">    Vector([3.0, 4.0])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone = eval(repr(v1))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 == v1_clone</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print(v1)</span></span><br><span class="line"><span class="string">    (3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; octets = bytes(v1)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; octets</span></span><br><span class="line"><span class="string">    b'd\\x00\\x00\\x00\\x00\\x00\\x00\\x08@\\x00\\x00\\x00\\x00\\x00\\x00\\x10@'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(v1)</span></span><br><span class="line"><span class="string">    5.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; bool(v1), bool(Vector([0, 0]))</span></span><br><span class="line"><span class="string">    (True, False)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Test of ``.frombytes()`` class method:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone = Vector.frombytes(bytes(v1))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone</span></span><br><span class="line"><span class="string">    Vector([3.0, 4.0])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 == v1_clone</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests with three dimensions::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 = Vector([3, 4, 5])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; x, y, z = v1</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; x, y, z</span></span><br><span class="line"><span class="string">    (3.0, 4.0, 5.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1</span></span><br><span class="line"><span class="string">    Vector([3.0, 4.0, 5.0])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone = eval(repr(v1))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 == v1_clone</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print(v1)</span></span><br><span class="line"><span class="string">    (3.0, 4.0, 5.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(v1) # doctest:+ELLIPSIS</span></span><br><span class="line"><span class="string">    7.071067811...</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; bool(v1), bool(Vector([0, 0, 0]))</span></span><br><span class="line"><span class="string">    (True, False)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests with many dimensions::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v7 = Vector(range(7))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v7</span></span><br><span class="line"><span class="string">    Vector([0.0, 1.0, 2.0, 3.0, 4.0, ...])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(v7) # doctest:+ELLIPSIS</span></span><br><span class="line"><span class="string">    9.53939201...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Test of ``.__bytes__`` and ``.frombytes()`` methods::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 = Vector([3, 4, 5])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone = Vector.frombytes(bytes(v1))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone</span></span><br><span class="line"><span class="string">    Vector([3.0, 4.0, 5.0])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 == v1_clone</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of sequence behavior::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 = Vector([3, 4, 5])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; len(v1)</span></span><br><span class="line"><span class="string">    3</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1[0], v1[len(v1)-1], v1[-1]</span></span><br><span class="line"><span class="string">    (3.0, 5.0, 5.0)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Test of slicing::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v7 = Vector(range(7))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v7[-1]</span></span><br><span class="line"><span class="string">    6.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v7[1:4]</span></span><br><span class="line"><span class="string">    Vector([1.0, 2.0, 3.0])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v7[-1:]</span></span><br><span class="line"><span class="string">    Vector([6.0])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v7[1,2]</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">      ...</span></span><br><span class="line"><span class="string">    TypeError: Vector indices must be integers</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of dynamic attribute access::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v7 = Vector(range(10))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v7.x</span></span><br><span class="line"><span class="string">    0.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v7.y, v7.z, v7.t</span></span><br><span class="line"><span class="string">    (1.0, 2.0, 3.0)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Dynamic attribute lookup failures::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v7.k</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">      ...</span></span><br><span class="line"><span class="string">    AttributeError: 'Vector' object has no attribute 'k'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v3 = Vector(range(3))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v3.t</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">      ...</span></span><br><span class="line"><span class="string">    AttributeError: 'Vector' object has no attribute 't'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v3.spam</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">      ...</span></span><br><span class="line"><span class="string">    AttributeError: 'Vector' object has no attribute 'spam'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of hashing::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 = Vector([3, 4])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v2 = Vector([3.1, 4.2])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v3 = Vector([3, 4, 5])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v6 = Vector(range(6))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; hash(v1), hash(v3), hash(v6)</span></span><br><span class="line"><span class="string">    (7, 2, 1)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Most hash values of non-integers vary from a 32-bit to 64-bit CPython build::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; import sys</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; hash(v2) == (384307168202284039 if sys.maxsize &gt; 2**32 else 357915986)</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of ``format()`` with Cartesian coordinates in 2D::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 = Vector([3, 4])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(v1)</span></span><br><span class="line"><span class="string">    '(3.0, 4.0)'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(v1, '.2f')</span></span><br><span class="line"><span class="string">    '(3.00, 4.00)'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(v1, '.3e')</span></span><br><span class="line"><span class="string">    '(3.000e+00, 4.000e+00)'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of ``format()`` with Cartesian coordinates in 3D and 7D::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v3 = Vector([3, 4, 5])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(v3)</span></span><br><span class="line"><span class="string">    '(3.0, 4.0, 5.0)'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector(range(7)))</span></span><br><span class="line"><span class="string">    '(0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0)'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of ``format()`` with spherical coordinates in 2D, 3D and 4D::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector([1, 1]), 'h') # doctest:+ELLIPSIS</span></span><br><span class="line"><span class="string">    '&lt;1.414213..., 0.785398...&gt;'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector([1, 1]), '.3eh')</span></span><br><span class="line"><span class="string">    '&lt;1.414e+00, 7.854e-01&gt;'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector([1, 1]), '0.5fh')</span></span><br><span class="line"><span class="string">    '&lt;1.41421, 0.78540&gt;'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector([1, 1, 1]), 'h') # doctest:+ELLIPSIS</span></span><br><span class="line"><span class="string">    '&lt;1.73205..., 0.95531..., 0.78539...&gt;'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector([2, 2, 2]), '.3eh')</span></span><br><span class="line"><span class="string">    '&lt;3.464e+00, 9.553e-01, 7.854e-01&gt;'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector([0, 0, 0]), '0.5fh')</span></span><br><span class="line"><span class="string">    '&lt;0.00000, 0.00000, 0.00000&gt;'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector([-1, -1, -1, -1]), 'h') # doctest:+ELLIPSIS</span></span><br><span class="line"><span class="string">    '&lt;2.0, 2.09439..., 2.18627..., 3.92699...&gt;'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector([2, 2, 2, 2]), '.3eh')</span></span><br><span class="line"><span class="string">    '&lt;4.000e+00, 1.047e+00, 9.553e-01, 7.854e-01&gt;'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector([0, 1, 0, 0]), '0.5fh')</span></span><br><span class="line"><span class="string">    '&lt;1.00000, 1.57080, 0.00000, 0.00000&gt;'</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> numbers</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    typecode = <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, components)</span>:</span></span><br><span class="line">        self._components = array(self.typecode, components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        components = reprlib.repr(self._components)</span><br><span class="line">        components = components[components.find(<span class="string">'['</span>):<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Vector(&#123;&#125;)'</span>.format(components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(tuple(self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bytes__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (bytes([ord(self.typecode)]) +</span><br><span class="line">                bytes(self._components))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (len(self) == len(other) <span class="keyword">and</span></span><br><span class="line">                all(a == b <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(self, other)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">        hashes = (hash(x) <span class="keyword">for</span> x <span class="keyword">in</span> self)</span><br><span class="line">        <span class="keyword">return</span> functools.reduce(operator.xor, hashes, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> math.sqrt(sum(x * x <span class="keyword">for</span> x <span class="keyword">in</span> self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(abs(self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        cls = type(self)</span><br><span class="line">        <span class="keyword">if</span> isinstance(index, slice):</span><br><span class="line">            <span class="keyword">return</span> cls(self._components[index])</span><br><span class="line">        <span class="keyword">elif</span> isinstance(index, numbers.Integral):</span><br><span class="line">            <span class="keyword">return</span> self._components[index]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msg = <span class="string">'&#123;.__name__&#125; indices must be integers'</span></span><br><span class="line">            <span class="keyword">raise</span> TypeError(msg.format(cls))</span><br><span class="line"></span><br><span class="line">    shortcut_names = <span class="string">'xyzt'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        cls = type(self)</span><br><span class="line">        <span class="keyword">if</span> len(name) == <span class="number">1</span>:</span><br><span class="line">            pos = cls.shortcut_names.find(name)</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= pos &lt; len(self._components):</span><br><span class="line">                <span class="keyword">return</span> self._components[pos]</span><br><span class="line">        msg = <span class="string">'&#123;.__name__!r&#125; object has no attribute &#123;!r&#125;'</span></span><br><span class="line">        <span class="keyword">raise</span> AttributeError(msg.format(cls, name))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">angle</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        r = math.sqrt(sum(x * x <span class="keyword">for</span> x <span class="keyword">in</span> self[n:]))</span><br><span class="line">        a = math.atan2(r, self[n<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">if</span> (n == len(self) - <span class="number">1</span>) <span class="keyword">and</span> (self[<span class="number">-1</span>] &lt; <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> math.pi * <span class="number">2</span> - a</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">angles</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (self.angle(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span>, len(self)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__format__</span><span class="params">(self, fmt_spec=<span class="string">''</span>)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> fmt_spec.endswith(<span class="string">'h'</span>): <span class="comment"># hyperspherical coordinates</span></span><br><span class="line">            fmt_spec = fmt_spec[:<span class="number">-1</span>]</span><br><span class="line">            coords = itertools.chain([abs(self)], self.angles())</span><br><span class="line">            outer_fmt = <span class="string">'&lt;&#123;&#125;&gt;'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            coords = self</span><br><span class="line">            outer_fmt = <span class="string">'(&#123;&#125;)'</span></span><br><span class="line">        components = (format(c, fmt_spec) <span class="keyword">for</span> c <span class="keyword">in</span> coords)</span><br><span class="line">        <span class="keyword">return</span> outer_fmt.format(<span class="string">', '</span>.join(components))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">frombytes</span><span class="params">(cls, octets)</span>:</span></span><br><span class="line">        typecode = chr(octets[<span class="number">0</span>])</span><br><span class="line">        memv = memoryview(octets[<span class="number">1</span>:]).cast(typecode)</span><br><span class="line">        <span class="keyword">return</span> cls(memv)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>符合Python风格的对象</title>
      <link href="/notes/fluent-python/a-pythonic-object/"/>
      <url>/notes/fluent-python/a-pythonic-object/</url>
      
        <content type="html"><![CDATA[<p>得益于Python数据模型，自定义类型的行为可以像内置类型那样自然。实现如此自然的行为，靠的不是继承，而是鸭子类型（duck typing）：我们只需按照预定行为实现对象所需的方法即可。</p><h1 id="对象表示形式">对象表示形式</h1><p>每门面向对象的语言至少都有一种获取对象的字符串表示形式的标准方式。Python提供了两种方式。</p><p>repr()：以便于开发者理解的方式返回对象的字符串表示形式，由特殊方法<code>__repr__</code>支持。</p><p>str()：以便于用户理解的方式返回对象的字符串表示形式，由特殊方法<code>__str__</code>支持。</p><p>为了给对象提供其他的表示形式，还会用到另外两个特殊方法：<code>__bytes__</code>和<code>__format__</code>。<code>__bytes__</code>方法与<code>__str__</code>方法类似，bytes()函数调用它获取对象的字节序列表示形式。而<code>__format__</code>方法会被内置的format()函数和str.format()方法调用，使用特殊的格式代码显示对象的字符串表示形式。</p><a id="more"></a><h1 id="再谈向量类">再谈向量类</h1><p>为了说明用于生成对象表示形式的众多方法，我们将使用一个Vector2d类。</p><figure class="highlight python"><figcaption><span>vector2d.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span>:</span></span><br><span class="line">    typecode = <span class="string">'d'</span>  <span class="comment"># 类属性，在实例和字节序列之间转换时使用</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = float(x)  <span class="comment"># 把x和y转换成浮点数，尽早捕获错误</span></span><br><span class="line">        self.y = float(y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span>  <span class="comment"># 把Vector2d变成可迭代对象，这样才能拆包</span></span><br><span class="line">        <span class="keyword">return</span> (i <span class="keyword">for</span> i <span class="keyword">in</span> (self.x, self.y))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span>  <span class="comment"># __repr__方法使用&#123;!r&#125;获取各个分量的表示形式，然后插值，构成一个字符串</span></span><br><span class="line">        class_name = type(self).__name__</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&#123;&#125;(&#123;!r&#125;, &#123;!r&#125;)'</span>.format(class_name, *self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>  <span class="comment"># 从可迭代的实例中可以轻松地得到一个元组</span></span><br><span class="line">        <span class="keyword">return</span> str(tuple(self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bytes__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (bytes([ord(self.typecode)]) +  <span class="comment"># 为了生成字节序列，把typecode转换成字节序列，然后</span></span><br><span class="line">                bytes(array(self.typecode, self)))  <span class="comment"># 迭代实例，得到一个数组，再把数组转换成字节序列</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span>  <span class="comment"># 可用，但有点问题，比如Vector2d(3, 4) == [3, 4]的结果会是True。</span></span><br><span class="line">        <span class="keyword">return</span> tuple(self) == tuple(other)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> math.hypot(self.x, self.y)  <span class="comment"># 模是x和y分量构成的直角三角形的斜边长</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(abs(self))  <span class="comment"># abs(0.0)是False，非零值是True</span></span><br></pre></td></tr></table></figure><p>Vector2d实例具有以下基本行为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector2d(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(v1.x, v1.y)  <span class="comment"># 实例的分量可以直接通过属性访问</span></span><br><span class="line"><span class="number">3.0</span> <span class="number">4.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = v1  <span class="comment"># 实例可以拆包成变量元组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y</span><br><span class="line">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1  <span class="comment"># repr函数调用实例，得到的结果类似于构建实例的源码</span></span><br><span class="line">Vector2d(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1_clone = eval(repr(v1))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 == v1_clone</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(v1)  <span class="comment"># print函数会调用str函数</span></span><br><span class="line">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>octets = bytes(v1)  <span class="comment"># bytes函数会调用__bytes__方法，生成实例的二进制表示形式</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>octets</span><br><span class="line"><span class="string">b'd\\x00\\x00\\x00\\x00\\x00\\x00\\x08@\\x00\\x00\\x00\\x00\\x00\\x00\\x10@'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>abs(v1)  <span class="comment"># abs函数会调用__abs__方法，返回实例的模</span></span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(v1), bool(Vector2d(<span class="number">0</span>, <span class="number">0</span>))  <span class="comment"># bool函数会调用__bool__方法，如果实例的模为0，返回False，否则返回True</span></span><br><span class="line"><span class="literal">True</span>, <span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="备选构造方法">备选构造方法</h1><p>我么可以把Vector2d实例转换成字节序列；同理，也应该能从字节序列转换成Vector2d实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在类中定义</span></span><br><span class="line"><span class="meta">@classmethod  # 类方法：从字节序列转换成Vector2d实例</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">frombytes</span><span class="params">(cls, octets)</span>:</span>  <span class="comment"># 不用传入self参数，相反，要通过cls传入类本身</span></span><br><span class="line">    typecode = chr(octets[<span class="number">0</span>])  <span class="comment"># 从第一个字节中读取typecode</span></span><br><span class="line">    memv = memoryview(octets[<span class="number">1</span>:]).cast(typecode)  <span class="comment"># 使用传入的octets字节序列创建一个memoryview，然后使用typecode转换</span></span><br><span class="line">    <span class="keyword">return</span> cls(*memv)  <span class="comment"># 拆包转换后的memoryview，得到构造方法所需的一对参数</span></span><br></pre></td></tr></table></figure><h2 id="classmethod与staticmethod">classmethod与staticmethod</h2><p>classmethod装饰器定义操作类，而不是操作实例的方法。classmethod改变了调用方法的方式，因此类方法的第一个参数是类本身，而不是实例。classmethod最常见的用途是定义备选构造方法。按照约定，类方法的第一个参数名为cls（但是Python不介意具体怎么命名）。</p><p>staticmethod装饰器也会改变方法的调用方式，但是第一个参数不是特殊的值。其实，静态方法就是普通的函数，只是碰巧在类的定义体中，而不是在模块层定义。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>:</span></span><br><span class="line"><span class="meta">... </span>    @classmethod</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">klassmeth</span><span class="params">(*args)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> args  <span class="comment"># 返回全部参数</span></span><br><span class="line"><span class="meta">... </span>    @staticmethod</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">statmeth</span><span class="params">(*args)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> args  <span class="comment"># 返回全部参数</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Demo.klassmeth()  <span class="comment"># 不管怎样调用类方法，第一个参数始终是Demo类</span></span><br><span class="line">(&lt;class '__main__.Demo'&gt;,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Demo.klassmeth(<span class="string">'spam'</span>)</span><br><span class="line">(&lt;class '__main__.Demo'&gt;, 'spam')</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Demo.statmeth()  <span class="comment"># 静态方法的行为与普通的函数类似</span></span><br><span class="line">()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Demo.statmeth(<span class="string">'spam'</span>)</span><br><span class="line">(<span class="string">'spam'</span>,)</span><br></pre></td></tr></table></figure><h1 id="格式化显示">格式化显示</h1><p>内置的format()函数和str.format()方法把各个类型的格式化方法委托给相应的<code>.__format__(format_spec)</code>方法。format_spec是格式说明符，它是：</p><ul><li>format(my_obj, format_spec)的第二个参数，或者</li><li>str.format()方法的格式字符串，{}里代换字段中冒号后面的部分。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>brl = <span class="number">1</span>/<span class="number">2.43</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>brl</span><br><span class="line"><span class="number">0.4115226337448559</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(brl, <span class="string">'0.4f'</span>)  <span class="comment"># 格式说明符是 '0.4f'</span></span><br><span class="line"><span class="string">'0.4115'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'1 BRL = &#123;rate:0.2f&#125; USD'</span>.format(rate=brl)  <span class="comment"># 格式说明符是 '0.2f'</span></span><br><span class="line"><span class="string">'1 BRL = 0.41 USD'</span></span><br></pre></td></tr></table></figure><p>'{rate:0.2f}'这样的格式字符串包含两部分，冒号左边的'rate'在代换字段句法中是字段名，冒号后面的'0.2f'是格式说明符。格式说明符使用的表示法叫格式规范微语言（“<a href="https://devdocs.io/python~3.6/library/string#formatspec" target="_blank" rel="noopener">Format Specification Mini-LMini-Language</a>“）。</p><p>格式规范微语言是可扩展的，因为各个类可以自行决定如果解释format_spec参数。例如，datetime模块中的类，它们的<code>__format__</code>方法使用的格式代码与strftime()函数一样。下面是内置的format()函数和str.format()方法的几个示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(now, <span class="string">'%H:%M:%S'</span>)</span><br><span class="line"><span class="string">'11:46:10'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"It's now &#123;:%I:%M %p&#125;"</span>.format(now)</span><br><span class="line"><span class="string">"It's now 11:46 AM"</span></span><br></pre></td></tr></table></figure><p>如果类没有定义<code>__format__</code>方法，从object继承的方法会返回str(my_object)。然而没如果传入格式说明符，<code>object.__format__</code>方法会抛出TypeError。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector2d(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(v1)  <span class="comment"># 若没有定义__format__方法，则返回str(v1)</span></span><br><span class="line"><span class="string">'(3.0, 4.0)'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(v1, <span class="string">'.3f)</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  ...</span></span><br><span class="line"><span class="string">TypeError: unsupported format string passed to Vector2d.__format__</span></span><br></pre></td></tr></table></figure><p>我们将自己实现微语言来解决这个问题。首先，假设用户提供的格式说明符是用于格式化向量中各个浮点数分量的，想达到的效果是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector2d(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(v1)</span><br><span class="line"><span class="string">'(3.0, 4.0)'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(v1, <span class="string">'.2f'</span>)</span><br><span class="line"><span class="string">'(3.00, 4.00)'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(v1, <span class="string">'.3e'</span>)</span><br><span class="line"><span class="string">'(3.000e+00, 4.000e+00)'</span></span><br></pre></td></tr></table></figure><p>实现这种输出的<code>__format__</code>方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在类中定义</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__format__</span><span class="params">(self, fmt_spec=<span class="string">''</span>)</span>:</span></span><br><span class="line">    components = (format(c, fmt_spec) <span class="keyword">for</span> c <span class="keyword">in</span> self)  <span class="comment"># 使用内置的format函数把fmt_spec应用到向量的各个分量上</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'(&#123;&#125;, &#123;&#125;)'</span>.format(*components)</span><br></pre></td></tr></table></figure><p>下面要在微语言中添加一个自定义的格式代码：如果格式说明符以'p'结尾，那么在极坐标中显示向量，即&lt;r, <span class="math inline">\(\theta\)</span>&gt;，其中r是模，<span class="math inline">\(\theta\)</span>是弧度；其他部分（'p'之前的部分）像往常那样解释。</p><p>对极坐标来说，我们已经定义了计算模的<code>__abs__</code>方法，因此还要定义一个简单的angle方法，使用math.atan2()函数计算角度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在类中定义</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">angle</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> math.atan2(self.y, self.x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__format__</span><span class="params">(self, fmt_spec)</span>:</span>  <span class="comment"># 增强型__format__方法</span></span><br><span class="line">    <span class="keyword">if</span> fmt_spec.endswith(<span class="string">'p'</span>):</span><br><span class="line">        fmt_spec = fmt_spec[:<span class="number">-1</span>]</span><br><span class="line">        coords = (abs(self), self.angle())  <span class="comment"># 极坐标</span></span><br><span class="line">        outer_fmt = <span class="string">'&lt;&#123;&#125;, &#123;&#125;&gt;'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        coords = self</span><br><span class="line">        outer_fmt = <span class="string">'(&#123;&#125;, &#123;&#125;)'</span></span><br><span class="line">    components = (format(c, fmt_spec) <span class="keyword">for</span> c <span class="keyword">in</span> coords)</span><br><span class="line">    <span class="keyword">return</span> outer_fmt.format(*components)</span><br></pre></td></tr></table></figure><p>示例中的代码得到的结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(Vector2d(<span class="number">1</span>, <span class="number">1</span>), <span class="string">'p'</span>)</span><br><span class="line"><span class="string">'&lt;1.4142135623730951, 0.7853981633974483&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(Vector2d(<span class="number">1</span>, <span class="number">1</span>), <span class="string">'.3ep'</span>)</span><br><span class="line"><span class="string">'&lt;1.414e+00, 7.854e-01&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(Vector2d(<span class="number">1</span>, <span class="number">1</span>), <span class="string">'0.5fp'</span>)</span><br><span class="line"><span class="string">'&lt;1.41421, 0.78540&gt;'</span></span><br></pre></td></tr></table></figure><h1 id="可散列的vector2d">可散列的Vector2d</h1><p>目前Vector2d实例是不可散列的，因此不能放入集合（set）中。为了把Vector2d实例变成可散列的，必须使用<code>__hash__</code>方法（还需要<code>__eq__</code>方法）。此外，还要让向量不可变，为此，我们要把x和y分量设为只读属性。（要想创建可散列的类型，不一定要实现特性，也不一定要保护实例属性。只需正确地实现<code>__hash__</code>和<code>__eq__</code>方法即可。但是实例的散列值绝不应该变化，因此借机提到了只读属性）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 类中定义</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">    self.__x = x  <span class="comment"># 使用两个前导下划线，把属性标记为私有的</span></span><br><span class="line">    self.__y = y</span><br><span class="line"></span><br><span class="line"><span class="meta">@property  # @property装饰器把读值方法标记为特性</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.__x</span><br><span class="line"></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">y</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.__y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他方法保持不变，通过self.x和self.y读取公开特性，而不必读取私有属性</span></span><br></pre></td></tr></table></figure><p>让这些向量不可变是有原因的，因为这样才能实现<code>__hash__</code>方法。这个方法应该返回一个整数，理想情况下还要考虑对象属性的散列值（<code>__eq__</code>方法也要使用），因为相等的对象应该具有相同的散列值。根据<a href="https://docs.python.org/3/reference/datamodel.html" target="_blank" rel="noopener">特殊方法<code>__hash__</code>的文档</a>，最好使用位运算符异或（^）混合各分量的散列值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在类中定义</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> hash(self.x) ^ hash(self.y)</span><br></pre></td></tr></table></figure><p>完整代码清单，包含全部doctest。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">A two-dimensional vector class</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 = Vector2d(3, 4)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print(v1.x, v1.y)</span></span><br><span class="line"><span class="string">    3.0 4.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; x, y = v1</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; x, y</span></span><br><span class="line"><span class="string">    (3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1</span></span><br><span class="line"><span class="string">    Vector2d(3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone = eval(repr(v1))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 == v1_clone</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print(v1)</span></span><br><span class="line"><span class="string">    (3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; octets = bytes(v1)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; octets b'd\\x00\\x00\\x00\\x00\\x00\\x00\\x08@\\x00\\x00\\x00\\x00\\x00\\x00\\x10@'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(v1)</span></span><br><span class="line"><span class="string">    5.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; bool(v1), bool(Vector2d(0, 0))</span></span><br><span class="line"><span class="string">    (True, False)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Test of ``.frombytes()`` class method:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone = Vector2d.frombytes(bytes(v1))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone</span></span><br><span class="line"><span class="string">    Vector2d(3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 == v1_clone</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of ``format()`` with Cartesian coordinates:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(v1)</span></span><br><span class="line"><span class="string">    '(3.0, 4.0)'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(v1, '.2f')</span></span><br><span class="line"><span class="string">    '(3.00, 4.00)'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(v1, '.3e')</span></span><br><span class="line"><span class="string">    '(3.000e+00, 4.000e+00)'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of the ``angle`` method::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; Vector2d(0, 0).angle()</span></span><br><span class="line"><span class="string">    0.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; Vector2d(1, 0).angle()</span></span><br><span class="line"><span class="string">    0.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; epsilon = 10**-8</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(Vector2d(0, 1).angle() - math.pi/2) &lt; epsilon</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(Vector2d(1, 1).angle() - math.pi/4) &lt; epsilon</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of ``format()`` with polar coordinates:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector2d(1, 1), 'p') # doctest:+ELLIPSIS</span></span><br><span class="line"><span class="string">    '&lt;1.414213..., 0.785398...&gt;'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector2d(1, 1), '.3ep')</span></span><br><span class="line"><span class="string">    '&lt;1.414e+00, 7.854e-01&gt;'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector2d(1, 1), '0.5fp')</span></span><br><span class="line"><span class="string">    '&lt;1.41421, 0.78540&gt;'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of `x` and `y` read-only properties:</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1.x, v1.y</span></span><br><span class="line"><span class="string">    (3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1.x = 123</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">      ...</span></span><br><span class="line"><span class="string">    AttributeError: can't set attribute</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of hashing:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 = Vector2d(3, 4)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v2 = Vector2d(3.1, 4.2)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; hash(v1), hash(v2)</span></span><br><span class="line"><span class="string">    (7, 384307168202284039)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; len(set([v1, v2]))</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span>:</span></span><br><span class="line">    typecode = <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.__x = float(x)</span><br><span class="line">        self.__y = float(y)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__x</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">y</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (i <span class="keyword">for</span> i <span class="keyword">in</span> (self.x, self.y))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        class_name = type(self).__name__</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&#123;&#125;(&#123;!r&#125;, &#123;!r&#125;)'</span>.format(class_name, *self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(tuple(self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bytes__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (bytes([ord(self.typecode)]) +</span><br><span class="line">                bytes(array(self.typecode, self)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> tuple(self) == tuple(other)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> hash(self.x) ^ hash(self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> math.hypot(self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(abs(self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">angle</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> math.atan2(self.y, self.x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__format__</span><span class="params">(self, fmt_spec=<span class="string">''</span>)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> fmt_spec.endswith(<span class="string">'p'</span>):</span><br><span class="line">            fmt_spec = fmt_spec[:<span class="number">-1</span>]</span><br><span class="line">            coords = (abs(self), self.angle())</span><br><span class="line">            outer_fmt = <span class="string">'&lt;&#123;&#125;, &#123;&#125;&gt;'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            coords = self</span><br><span class="line">            outer_fmt = <span class="string">'(&#123;&#125;, &#123;&#125;)'</span></span><br><span class="line">            components = (format(c, fmt_spec) <span class="keyword">for</span> c <span class="keyword">in</span> coords)</span><br><span class="line">        <span class="keyword">return</span> outer_fmt.format(*components)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">frombytes</span><span class="params">(cls, octets)</span>:</span></span><br><span class="line">        typecode = chr(octets[<span class="number">0</span>])</span><br><span class="line">        memv = memoryview(octets[<span class="number">1</span>:]).cast(typecode)</span><br><span class="line">        <span class="keyword">return</span> cls(*memv)</span><br></pre></td></tr></table></figure><h1 id="python的私有属性和受保护的属性">Python的私有属性和“受保护的”属性</h1><p>Python不能像Java那样使用private修饰符创建私有属性，但是Python有个简单的机制，能避免子类意外覆盖“私有”属性。举个例子，有人编写了一个名为Dog的类，这个类的内部用到了mood实例属性，但是没有将其开放。现在，你创建了Dog的子类：Beagle。如果你在毫不知情的情况下又创建了名为mood的实例属性，那么在继承的方法中就会把Dog类的mood属性覆盖掉。这是个难以调试的问题。</p><p>为了避免这种情况，如果以<code>__mood</code>的形式命名实例属性，Python会把属性名存入实例的<code>__dict__</code>属性中，而且会在前面加上一个下划线和类名。因此，对Dog类来说，<code>__mood</code>会变成<code>_Dog__mood</code>；对Beagle类来说，会变成<code>_Beagle__mood</code>。这个语言特性叫名称改写（name mangling）。名称改写是一种安全措施，不能保证万无一失：它的目的是避免意外访问，不能防止故意做错事。</p><p>以上一节定义的Vector2d类为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector2d(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1.__dict__</span><br><span class="line">&#123;<span class="string">'_Vector2d__x'</span>: <span class="number">3.0</span>, <span class="string">'_Vector2d__y'</span>: <span class="number">4.0</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1._Vector2d__x  <span class="comment"># 故意访问</span></span><br><span class="line"><span class="number">3.0</span></span><br></pre></td></tr></table></figure><p>不是所有Python程序员都喜欢名称改写功能，也不是所有人都喜欢<code>self.__x</code>这种不对称的名称。有些人不喜欢这种句法，他们约定使用一个下环线前缀编写“受保护”的属性（如<code>self._x</code>）。批评使用两个下划线这种改写机制的人认为，应该使用命名约定来避免意外覆盖属性。</p><blockquote><p>绝对不要使用两个前导下划线，这是很烦人的自私行为。如果担心命名冲突，应该明确使用一种名称改写方式（如<code>_MyThing_blahblah</code>）。这其实与使用双下划线一样，不过自己定的规则比双下划线易于理解。</p><p>—— Ian Bicking，<a href="http://pythonpaste.org/StyleGuide.html" target="_blank" rel="noopener">Paste的风格指南</a></p></blockquote><p>Python解释器不会对使用单个下划线的属性名做特殊处理，不过这是很多Python程序员严格遵守的约定，他们不会在类外部访问这种属性（不过在模块中，顶层名称使用一个前导下划线的话，的确会有影响：对from mymod import *来说，mymod中前缀为下划线的名称不会被导入。然而，依旧可以使用from mymod import _privatefunc将其导入）。遵守使用一个下划线标记对象的私有属性很容易，就像遵守使用全大写字母编写常量那样容易。</p><p>Vector2d的分量都是”私有的“，而且Vector2d实例都是”不可变的”。我用了两对引号，这是因为并不能真正实现私有和不可变。</p><h1 id="使用__slots__类属性节省空间">使用<code>__slots__</code>类属性节省空间</h1><p>默认情况下，Python在各个实例中名为<code>__dict__</code>的字典里存储实例属性。为了使用底层的散列表提升访问速度，字典会消耗大量内存。如果要处理数百万个属性不多的实例，通过<code>__slots__</code>类属性，能节省大量内存，方法是让解释器在元组中存储实例属性，而不使用字典。（继承自超类的<code>__slots__</code>属性没有效果。Python只会使用各个类中定义的<code>__slots__</code>属性）</p><p>定义<code>__slots__</code>的方式是，创建一个类属性，使用<code>__slots__</code>这个名字，并把它的值设为一个字符串构成的可迭代对象，其中各个元素表示各个实例属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span>:</span></span><br><span class="line">    __solots__ = (<span class="string">'__x'</span>, <span class="string">'__y'</span>)</span><br><span class="line"></span><br><span class="line">    typecode = <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类方法</span></span><br></pre></td></tr></table></figure><p>如果要处理数百万个数值对象，应该使用NumPy数组。NumPy数组能高效使用内存，而且提供了高度优化的数值处理函数，其中很多都一次操作整个数组。</p><p>在类中定义<code>__slots__</code>属性之后，实例不能再有<code>__slots__</code>中所列名称之外的其他属性。这只是一个副作用，不是<code>__slots__</code>存在的真正原因，不要使用<code>__slots__</code>属性禁止类的用户新增实例。<code>__slots__</code>是用于优化的，不是为了约束程序员。</p><p>然而，“节省的内存也可能被再次吃掉”：如果把'<code>__dict__</code>'这个名称添加到<code>__slots__</code>中，实例会在元组中保存各个实例的属性，此外还支持动态创建属性，这些属性存储在常规的<code>__dict__</code>中。当然，把'<code>__dict__</code>'添加到<code>__slots__</code>中可能完全违背了初衷，这取决于各个实例的静态属性和动态属性的数量及其用法。</p><p>此外，还有一个实例属性可能需要注意，即<code>__weakref__</code>属性，为了让对象支持弱引用，必须有这个属性。用户定义的类中默认就有<code>__weakref__</code>属性。可是，如果类中定义了<code>__slots__</code>属性，而且想把实例作为弱引用的目标，那么要把'<code>__weakref__</code>'添加到<code>__slots__</code>中。</p><p>综上，<code>__slots__</code>属性有些需要注意的地方，而且不能滥用，不能使用它限制用户能赋值的属性。处理列表数据时<code>__slots__</code>属性最有用，例如模式固定的数据库记录，以及特大型数据库。然而，如果你经常处理大量数据，一定要了解一下<a href="http://www.numpy.org" target="_blank" rel="noopener">NumPy</a>；此外，数据分析库<a href="http://pandas.pydata.org" target="_blank" rel="noopener">pandas</a>也值得了解，这个库可以处理非数值数据，而且能导入/导出很多不同的列表数据格式。</p><p>总之，如果使用得当，<code>__slots__</code>能显著节省内存，不过要注意以下几点：</p><ul><li>每个子类都要定义<code>__slots__</code>属性，因为解释器会忽略继承的<code>__slots__</code>属性。</li><li>实例只能拥有<code>__slots__</code>中列出的属性，除非把'<code>__dict__</code>'加入<code>__slots__</code>中（这样做就失去了节省内存的功效）。</li><li>如果不把'<code>__weakref__'</code>加入<code>__slots__</code>，实例就不能作为弱引用的目标。</li></ul><h1 id="覆盖类属性">覆盖类属性</h1><p>Python有个很独特的特性：类属性可用于为实例属性提供默认值。Vector2d中有个typecode类属性，<code>__bytes__</code>方法两次用到了它，而且都故意使用self.typecode读取它的值。因此Vector2d实例本身没有typecode属性，所以self.typecode默认获取的是Vector2d.typecode类属性的值。</p><p>但是，如果为不存在的实例属性赋值，会新建实例属性。假如我们为typecode实例属性赋值，那么同名类属性不受影响。然而，自此之后，实例读取的self.typecode是实例属性typecode，也就是把同名类属性遮盖了。借助这一特性，可以为各个实例的typecode属性定制不同的值。</p><p>Vector2d.typecode属性的默认值是'd'，即转换成字节序列时使用8字节双精度浮点数表示向量的各个分量。如果转换之前把Vector2d实例的typecode属性设为'f'，那么使用4字节的单精度浮点数表示各个分量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector2d(<span class="number">1.1</span>, <span class="number">2.2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dumpd = bytes(v1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dumpd</span><br><span class="line"><span class="string">b'd\x9a\x99\x99\x99\x99\x99\xf1?\x9a\x99\x99\x99\x99\x99\x01@'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(dumpd)</span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1.typecode = <span class="string">'f'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dumpf = bytes(v1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dumpf</span><br><span class="line"><span class="string">b'f\xcd\xcc\x8c?\xcd\xcc\x0c@'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(dumpf)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Vector2d.typecode, v1.typecode</span><br><span class="line">(<span class="string">'d'</span>, <span class="string">'f'</span>)</span><br></pre></td></tr></table></figure><p>如果想修改类属性的值，必须直接在类上修改，不能通过实例修改。如果想修改所有实例（没有typecode实例变量）的typecode属性的默认值，可以这么做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Vector2d.typecode = <span class="string">'f'</span></span><br></pre></td></tr></table></figure><p>然而，有种修改方法更符合Python风格，而且效果持久，也更有针对性。类属性是公开的，因此会被子类继承，于是经常会创建一个子类，只用于定制类的数据属性。Diango基于类的视图就大量使用了这个技术。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShortVector2d</span><span class="params">(Vector2d)</span>:</span></span><br><span class="line">    typecode = <span class="string">'f'</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象引用、可变性和垃圾回收</title>
      <link href="/notes/fluent-python/object-references-mutability-and-recycling/"/>
      <url>/notes/fluent-python/object-references-mutability-and-recycling/</url>
      
        <content type="html"><![CDATA[<h1 id="变量不是盒子">变量不是盒子</h1><p>以一个比喻说明Python的变量：变量是标注，而不是盒子。首先，我们要抛弃变量是存储数据的盒子这一错误观念。Python变量类似于Java中的引用式变量，因此最好把他们理解为附加在对象上的标注。在示例所示的交互式控制台中，无法使用“变量是盒子”做解释。而便利贴则指出了变量的正确工作方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p><img data-src="/uploads/posts/fluent-python/variables-as-sticky-notes.png"></p><p>赋值方式：对引用式变量来说，说把变量分配给对象更合理，反过来说就有问题。毕竟，对象在赋值之前就创建了。下面的示例证明赋值语句的右边先执行。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Gizmo</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">'Gizmo id: %d'</span> %id(self))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = Gizmo()</span><br><span class="line">Gizmo id: <span class="number">4533161544</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = Gizmo() * <span class="number">10</span>  <span class="comment"># 在乘法运算中使用Gizmo实例会抛出异常</span></span><br><span class="line">Gizmo id: <span class="number">4533161376</span>  <span class="comment"># 在尝试求积之前会创建一个新的Gizmo实例</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unsupported operand type(s) <span class="keyword">for</span> *: <span class="string">'Gizmo'</span> <span class="keyword">and</span> <span class="string">'int'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir()  <span class="comment"># dir()的结果表明变量y没有被创建</span></span><br><span class="line">[<span class="string">'Gizmo'</span>, <span class="string">'__annotations__'</span>, <span class="string">'__builtins__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__loader__'</span>, <span class="string">'__name__'</span>, <span class="string">'__package__'</span>, <span class="string">'__spec__'</span>, <span class="string">'x'</span>]</span><br></pre></td></tr></table></figure><p>为了理解Python中的赋值居于，应该始终先读右边。对象在右边创建或获取，在此之后左边的变量才会绑定到对象上，这就像为对象贴上标注。因为变量只不过是标注，所以无法租出为对象贴上多个标注。贴的多个标注，就是别名。</p><h1 id="标识相等性和别名">标识、相等性和别名</h1><p>Lewis Carroll是Charles Lutwidge Dodgson教授的笔名。Carroll先生指的就是Dodgson教授，二者是同一个人。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>charles = &#123;<span class="string">'name'</span>: <span class="string">'Charles L. Dodgson'</span>, <span class="string">'born'</span>: <span class="number">1832</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lweis = charles</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lweis <span class="keyword">is</span> charles</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(charles), id(lweis)</span><br><span class="line">(<span class="number">4531455896</span>, <span class="number">4531455896</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lweis[<span class="string">'balance'</span>] = <span class="number">950</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>charles</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'Charles L. Dodgson'</span>, <span class="string">'born'</span>: <span class="number">1832</span>, <span class="string">'balance'</span>: <span class="number">950</span>&#125;</span><br></pre></td></tr></table></figure><p>然而，假如有冒充者（Alexander Pedachenko博士）生于1832年，声称他是Charles L. Dodgson。这个冒充者的证件可能一样，但是Pedachenko博士不是Dodgson教授。</p><p><img data-src="/uploads/posts/fluent-python/python-is-and-equal.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>alex = &#123;<span class="string">'name'</span>: <span class="string">'Charles L. Dodgson'</span>, <span class="string">'born'</span>: <span class="number">1832</span>, <span class="string">'balance'</span>: <span class="number">950</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>alex == charles</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>alex <span class="keyword">is</span> <span class="keyword">not</span> charles</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(alex), id(charles)</span><br><span class="line">(<span class="number">4533183904</span>, <span class="number">4531455896</span>)</span><br></pre></td></tr></table></figure><p>每个变量都有标识、类型和值。对象一旦创建，它的标识绝不会变。is运算符比较两个对象的标识：id()函数返回对象表示的整数标识。</p><p>对象ID的真正意义在不同的实现中有所不同。在CPython中，id()返回对象的内存地址，但是在其他Python解释器中可能是别的值。关键是，ID一定是唯一的数值标注，而且在对象的生命周期中绝不会变。</p><h2 id="在和is之间选择">在==和is之间选择</h2><p>==运算符比较两个对象的值（对象中保存的数据），而is比较对象的标识。（==相当于Java中的equal()方法，而is相当于Java中的==）。通常，我们关注的是值，而不是标识，因此Python代码中==的出现频率比is高。</p><p><strong>然而，在变量和单例值之间比较时，应该使用is。目前，最常使用is检查变量绑定的值是不是None。</strong>下面是推荐的写法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>is运算符比==速度快，因为它不能重载，所以Python不用寻找并调用特殊方法，而是直接比较两个整数ID。而a==b是语法糖，等同于<code>a.__eq__(b)</code>。继承自object的<code>__eq__</code>方法比较两个对象的ID，结果与is一样，但是多数内置类型使用更有意义的方式覆盖了<code>__eq__</code>方法，会考虑对象属性的值。相等性测试可能涉及大量处理工作，例如，比较大型集合或嵌套层级深的机构时。</p><h2 id="元组的相对不变性">元组的相对不变性</h2><p>元素与多数Python集合（列表、字典、集，等等）一样，保存的是对象的引用（str、bytes和array.array等单一类型序列是扁平的，它们保存的不是引用，而是在连续的内容中保存数据本身）。如果引用的元素是可变的，即使元组本身不可变，元素依然可变。也就是说，元组的不可变性其实是指tuple数据结构的物理内容（即保存的引用）不可变，与引用的对象无关。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 == t2, t1 <span class="keyword">is</span> t2  <span class="comment"># t1与t2相等，但不是同一个对象</span></span><br><span class="line">(<span class="literal">True</span>, <span class="literal">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(t1[<span class="number">-1</span>])</span><br><span class="line"><span class="number">4533178056</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1[<span class="number">-1</span>].append(<span class="number">99</span>)  <span class="comment"># 改变t[-1]的内容</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(t1[<span class="number">-1</span>])  <span class="comment"># t[-1]的标识没变</span></span><br><span class="line"><span class="number">4533178056</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 == t2  <span class="comment"># 内容不再相等</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>来自2.6.1节的一个谜题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>] += [<span class="number">50</span>, <span class="number">60</span>]</span><br></pre></td></tr></table></figure><p>上述两个表达式的运行结果是哪一个？</p><ol type="a"><li><p>t变成(1, 2, [30, 40, 50, 60])。</p></li><li><p>因为tuple不支持对它的元素赋值，所以会抛出TypeError异常。</p></li><li><p>以上两个都不是。</p></li><li><p>a和b都是对的。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ========== 谜题答案 ==========</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>] += [<span class="number">50</span>, <span class="number">60</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>])  <span class="comment"># 由此可见谜题的答案是 d</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(<span class="string">'s[a] += b'</span>)  <span class="comment"># 查看 s[a] += b 背后的字节码</span></span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_NAME                <span class="number">0</span> (s)</span><br><span class="line">              <span class="number">2</span> LOAD_NAME                <span class="number">1</span> (a)</span><br><span class="line">              <span class="number">4</span> DUP_TOP_TWO</span><br><span class="line">              <span class="number">6</span> BINARY_SUBSCR                       <span class="comment"># 将s[a]的值存入TOS(Top Of Stack，栈的顶端)</span></span><br><span class="line">              <span class="number">8</span> LOAD_NAME                <span class="number">2</span> (b)</span><br><span class="line">             <span class="number">10</span> INPLACE_ADD                         <span class="comment"># 计算TOS += b。这一步能够完成，是因为TOS指向的是一个可变对象</span></span><br><span class="line">             <span class="number">12</span> ROT_THREE</span><br><span class="line">             <span class="number">14</span> STORE_SUBSCR                        <span class="comment"># s[a] = TOS赋值。这一步失败，是因为s是不可变的元组</span></span><br><span class="line">             <span class="number">16</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">18</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><p>这其实是个非常罕见的边界情况，在15年的Python生涯中，我还没见过谁在这个地方吃过亏。至此我得到了3个教训。</p><ul><li>不要把可变对象放在元组里面。</li><li>增量赋值不是一个原子操作。我们刚才也看到了，它虽然抛出了异常，但还是完成了操作。</li><li>查看Python的字节码并不难，而且它对我们了解代码背后的运行机制很有帮助。</li></ul><h1 id="默认做浅复制">默认做浅复制</h1><p>复制列表（或多数内置的可变集合）最简单的方式是使用内置的类型构造方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="number">3</span>, [<span class="number">55</span>, <span class="number">44</span>], (<span class="number">7</span>, <span class="number">8</span> ,<span class="number">9</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 = list(l1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 == l1, l2 <span class="keyword">is</span> l1  <span class="comment"># 二者相等，但不是同一个对象</span></span><br><span class="line">(<span class="literal">True</span>, <span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>对列表和其他可变序列来说，还能使用简洁的l2=l1[:]语句创建副本。然而，构造方法或[:]做的是浅复制（即复制了最外层容器，副本中的元素是源容器中元素的引用）。如果所有元素都是不可变的，那么这样没有问题，还能节省内存。但是，如果有可变的元素，可能就会导致意想不到的问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="number">3</span>, [<span class="number">66</span>, <span class="number">55</span>, <span class="number">44</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 = list(l1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1[<span class="number">1</span>] <span class="keyword">is</span> l2[<span class="number">1</span>], l1[<span class="number">2</span>] <span class="keyword">is</span> l2[<span class="number">2</span>]  <span class="comment"># 浅复制复制的是引用</span></span><br><span class="line">(<span class="literal">True</span>, <span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1.append(<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1[<span class="number">1</span>].remove(<span class="number">55</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1</span><br><span class="line">[<span class="number">3</span>, [<span class="number">66</span>, <span class="number">44</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>), <span class="number">100</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2</span><br><span class="line">[<span class="number">3</span>, [<span class="number">66</span>, <span class="number">44</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2[<span class="number">1</span>] += [<span class="number">33</span>, <span class="number">22</span>]  <span class="comment"># 对可变的对象来说，+=运算符就地修改列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2[<span class="number">2</span>] += (<span class="number">10</span>, <span class="number">11</span>)  <span class="comment"># 对元组来说，+=运算符创建一个新元组，然后重新绑定给变量</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1</span><br><span class="line">[<span class="number">3</span>, [<span class="number">66</span>, <span class="number">44</span>, <span class="number">33</span>, <span class="number">22</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>), <span class="number">100</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2</span><br><span class="line">[<span class="number">3</span>, [<span class="number">66</span>, <span class="number">44</span>, <span class="number">33</span>, <span class="number">22</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>)]</span><br></pre></td></tr></table></figure><h2 id="为任意对象做深复制和浅复制">为任意对象做深复制和浅复制</h2><p>copy模块提供的deepcopy和copy函数能为任意对象做深复制和浅复制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bus</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, passengers=None)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> passengers <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="meta">... </span>            self.passengers = []</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>            self.passengers = list(passengers)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.passengers.append(name)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">drop</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.passengers.remove(name)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> copy <span class="keyword">import</span> copy, deepcopy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1 = Bus([<span class="string">'Alice'</span>, <span class="string">'Bill'</span>, <span class="string">'Claire'</span>, <span class="string">'David'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2 = copy(bus1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3 = deepcopy(bus1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(bus1), id(bus2), id(bus3)  <span class="comment"># 3个不同的实例</span></span><br><span class="line">(<span class="number">4533933560</span>, <span class="number">4533933840</span>, <span class="number">4533934232</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1.drop(<span class="string">'Bill'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2.passengers  <span class="comment"># bus1中的Bill下车后，bus2中也没有他了</span></span><br><span class="line">[<span class="string">'Alice'</span>, <span class="string">'Claire'</span>, <span class="string">'David'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3.passengers</span><br><span class="line">[<span class="string">'Alice'</span>, <span class="string">'Bill'</span>, <span class="string">'Claire'</span>, <span class="string">'David'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(bus1.passengers), id(bus2.passengers), id(bus3.passengers)  <span class="comment"># 审查passengers属性，bus1和bus2共享同一个列表对象（浅复制）</span></span><br><span class="line">(<span class="number">4533897800</span>, <span class="number">4533897800</span>, <span class="number">4533249800</span>)</span><br></pre></td></tr></table></figure><p>一般来说，深复制不是件简单的事。如果对象有循环引用，那么这个朴素的算法会进入无限循环。deepcopy函数会记住已经复制的对象，因此能优雅地处理循环引用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [a, <span class="number">30</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>, [[...], <span class="number">30</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = deepcopy(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>, [[...], <span class="number">30</span>]]</span><br></pre></td></tr></table></figure><p>此外，深复制有时可能太深了。例如，对象可能会引用不该复制的外部资源或单例值。我们可以实现特殊方法<code>__copy__()</code>和<code>__deepcopy__()</code>，控制copy和deepcopy的行为。</p><h1 id="函数的参数作为引用时">函数的参数作为引用时</h1><p>Python唯一支持的参数传递模式是共享参数（call by sharing）。多数面向对象语言都采用这一模式。共享传参指函数的各个形式参数获得实参中各个引用的副本，也就是说，函数内部的形参是实参的别名。这种方案的结果是，函数可能会修改作为参数传入的可变对象，但是无法修改那些对象的标识。</p><h2 id="不要使用可变类型作为参数的默认值">不要使用可变类型作为参数的默认值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">HauntedBus</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">"""备受幽灵乘客折磨的校车"""</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, passengers=[])</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.passengers = passengers</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.passengers.append(name)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">drop</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.passengers.remove(name)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1 = HauntedBus([<span class="string">'Alice'</span>, <span class="string">'Bill'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1.pick(<span class="string">'Charlie'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1.drop(<span class="string">'Alice'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1.passengers</span><br><span class="line">[<span class="string">'Bill'</span>, <span class="string">'Charlie'</span>]  <span class="comment"># 不使用默认值没什么问题</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2 = HauntedBus()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2.pick(<span class="string">'Carrie'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2.passengers</span><br><span class="line">[<span class="string">'Carrie'</span>]  <span class="comment"># 使用默认值，目前为止也没什么问题</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3 = HauntedBus()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3.passengers  <span class="comment"># bus3不是预期中的空车</span></span><br><span class="line">[<span class="string">'Carrie'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3.pick(<span class="string">'Dave'</span>)  <span class="comment"># Dave登上bus3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2.passengers  <span class="comment"># Dave出现在了bus2中</span></span><br><span class="line">[<span class="string">'Carrie'</span>, <span class="string">'Dave'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3.passengers <span class="keyword">is</span> bus2.passengers  <span class="comment"># passergers属性是同一个对象</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>问题在于，没有指定初始乘客的HauntedBus实例会共享同一个乘客列表。这是因为self.passengers变成了passengers参数默认值的别名。出现这个问题的根源是，默认值在定义函数时计算（通常在加载模块时），因此默认值变成了函数对象的属性。因此，如果默认值是可变对象，而且修改了它的值，那么后续的函数调用都会受到影响。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>HauntedBus.__init__.__defaults__</span><br><span class="line">([<span class="string">'Carrie'</span>, <span class="string">'Dave'</span>],)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>HauntedBus.__init__.__defaults__[<span class="number">0</span>] <span class="keyword">is</span> bus2.passengers <span class="keyword">is</span> bus3.passengers</span><br><span class="line"><span class="literal">True</span>  <span class="comment"># 使用默认值的实例，其passengers属性实际上都是默认值[]的别名</span></span><br></pre></td></tr></table></figure><h2 id="防御可变参数">防御可变参数</h2><p>如果定义的函数接收可变参数，应该谨慎考虑调用方是否期望修改传入的参数。具体情况具体分析，这其实需要函数的编写者和调用方达成共识。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">TwilightBus</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">"""让乘客销声匿迹的校车</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    一个简单的类，说明接受可变参数的风险"""</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, passengers=None)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> passengers <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="meta">... </span>            self.passengers = <span class="literal">None</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>            self.passengers = passengers  <span class="comment"># self.passengers变成passengers的别名</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.passengers.append(name)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">drop</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.passengers.remove(name)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>basketball_team = [<span class="string">'Sue'</span>, <span class="string">'Tina'</span>, <span class="string">'Maya'</span>, <span class="string">'Diana'</span>, <span class="string">'Pat'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus = TwilightBus(basketball_team)  <span class="comment"># self.passengers变成了实参basketball_team的别名</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus.drop(<span class="string">'Tina'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus.drop(<span class="string">'Pat'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>basketball_team  <span class="comment"># 下车的学生从篮球队中消失了</span></span><br><span class="line">[<span class="string">'Sue'</span>, <span class="string">'Maya'</span>, <span class="string">'Diana'</span>]</span><br></pre></td></tr></table></figure><p>TwilightBus违反了设计接口的最佳实践，即“最少惊讶原则”。正确的做法是，校车自己维护乘客列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, passengers=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> passengers <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self.passengers = []</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.passengers = list(passengers)  <span class="comment"># 修改此处，创建passengers的副本，然后赋值给self.passengers</span></span><br></pre></td></tr></table></figure><p>在内部像这样处理乘客列表，就不会影响初始化校车时传入的参数了。此外，这种处理方式还更灵活：现在传给passengers参数的值可以是元组或任何其他可迭代对象，例如set对象，甚至数据库查询结果。</p><h1 id="del和垃圾回收">del和垃圾回收</h1><p>del语句删除名称，而不是对象。del命令可能会导致对象被当作垃圾回收，但是仅当删除的变量保存的是对象的最后一个引用，或者无法得到对象时（如果两个对象相互引用，当它们的引用只存在二者之间时，垃圾回收程序会判定它们无法获取，进而把它们都销毁）。重新绑定也可能会导致对象的引用数量归零，导致对象被销毁。</p><p>有个<code>__del__</code>特殊方法，它是他不会销毁实例，不应该在代码中调用。即将销毁实例时，Python解释器会调用<code>__del__</code>方法，给实例最后的机会，释放外部资源。自己编写的代码很少需要实现<code>__del__</code>。</p><p>在CPython中，垃圾回收使用的主要算法是引用计数。实际上，每个对象都会统计有多少引用指向自己。当引用计数归零时，对象立即就被销毁：CPython会在对象上调用<code>__del__</code>方法（如果定义了），然后释放分配给对象的内存。CPython 2.0增加了分代垃圾回收算法，用于检测引用循环中涉及的对象组——如果一组对象之间全是相互引用，即使再出色的引用方式也会导致组中的对象不可获取。Python的其他实现有更复杂的垃圾回收程序，而且不依赖引用计数，这意味着，对象的引用数量归零时可能不会立即调用<code>__del__</code>方法。</p><p>对了演示对象生命结束时的情形，使用weakref.finalize注册一个回调函数，在销毁对象时调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> weakref</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = s1  <span class="comment"># s1和s2指向同一个集合</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">bye</span><span class="params">()</span>:</span>  <span class="comment"># 这个函数一定不能是要销毁的对象的绑定方法，否则会有一个指向对象的引用</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Gone with the wind...'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ender = weakref.finalize(s1, bye)  <span class="comment"># 在s1引用的对象上注册bye回调，finalize持有&#123;1, 2, 3&#125;的弱引用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ender.alive</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> s1  <span class="comment"># 删除引用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ender.alive  <span class="comment"># 对象依然存在</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = <span class="string">'spam'</span>  <span class="comment"># 重新绑定了s2，原来的集合对象无法获取，对象被销毁了</span></span><br><span class="line">Gone <span class="keyword">with</span> the wind...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ender.alive</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="弱引用">弱引用</h1><p>弱引用不会增加对象的引用数量。引用的目标对象称为所指对象（referent）。因此，弱引用不会妨碍所指对象被当作垃圾回收。弱引用在缓存应用中很有用，因为我们不想仅因为被缓存引用着而始终保存缓存对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_set = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref = weakref.ref(a_set)  <span class="comment"># 创建弱引用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref  <span class="comment"># 审查</span></span><br><span class="line">&lt;weakref at <span class="number">0x10e3dae08</span>; to <span class="string">'set'</span> at <span class="number">0x10e326ac8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref()  <span class="comment"># 调用wref()返回的是被引用的对象。因为这是控制台会话，所以&#123;0, 1&#125;会绑定给 _ 变量</span></span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_set = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;  <span class="comment"># &#123;0, 1&#125;的引用数减少了，但是 _ 变量仍然指代它</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref()  <span class="comment"># 依旧返回&#123;0, 1&#125;</span></span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref() <span class="keyword">is</span> <span class="literal">None</span>  <span class="comment"># 计算表达式时，&#123;0, 1&#125;存在，因此返回False，随后 _ 绑定到结果值False，现在&#123;0, 1&#125;没有强引用了</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref() <span class="keyword">is</span> <span class="literal">None</span>  <span class="comment"># &#123;0, 1&#125;对象不存在了，所以返回True</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p><a href="http://docs.python.org/3/library/weakref.html" target="_blank" rel="noopener">weakref模块的文档</a>指出，weakref.ref类其实是底层接口，供高级用途使用，多数程序最好使用weakref集合和finalize。也就是说，应该使用WeakKeyDictionary、WeakValueDictionary、WeakSet和finalize（在内部使用弱引用），不要自己动手创建并处理weakref.ref实例。</p><h2 id="weakvaluedictionary简介">WeakValueDictionary简介</h2><p>WeakValueDictionary类实现的是一种可变映射，里面的值是对象的弱引用，被引用的对象在程序的其他地方被当作垃圾回收后，对应的键会自动从WeakValueDictionary中删除。因此WeakValueDictionary经常用于缓存。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Cheese</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, kind)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.kind = kind</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">'Cheese(%r)'</span> % self.kind</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> weakref</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stock = weakref.WeakValueDictionary()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>catalog = [Cheese(<span class="string">'Red Leicester'</span>), Cheese(<span class="string">'Tilsit'</span>), Cheese(<span class="string">'Brie'</span>), Cheese(<span class="string">'Parmesan'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> cheese <span class="keyword">in</span> catalog:  <span class="comment"># 循环中cheese是全局变量，循环结束后也不会消失</span></span><br><span class="line"><span class="meta">... </span>    stock[cheese.kind] = cheese</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(stock.keys())  <span class="comment"># stock是完整的</span></span><br><span class="line">[<span class="string">'Brie'</span>, <span class="string">'Parmesan'</span>, <span class="string">'Red Leicester'</span>, <span class="string">'Tilsit'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> catalog</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(stock.keys())  <span class="comment"># 为什么会剩下一个</span></span><br><span class="line">[<span class="string">'Parmesan'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> cheese  <span class="comment"># 临时变量cheese引用了对象，导致该变量存在时间比预期长</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(stock.keys())</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><p>与WeakValueDictionary对应的是WeakKeyDictionary，后者的键是弱引用。WeakKeyDictionary实例可以为应用中其他部分拥有的对象附加数据，这样就无需为对象添加属性。这对覆盖属性访问权限的对象尤其有用。WeakSet类：保存元素弱引用的集合类。元素没有强应用时，集合会把它删除。</p><h2 id="弱引用的局限">弱引用的局限</h2><p>不是每个Python对象都可以作为弱引用的目标（或称所指对象）。基本的list和dict实例不能作为所指对象，但是他们的子类可以轻松地解决这个问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="string">"""list的子类，实例可以作为弱引用的目标"""</span></span><br><span class="line"></span><br><span class="line">a_list = MyList(range(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># a_list可以作为弱引用的目标</span></span><br><span class="line">wref_to_a_list = weakref.ref(a_list)</span><br></pre></td></tr></table></figure><p>set实例可以作为所指对象（因此前面的实例才使用{0, 1}），用户定义的类型也没问题（Cheese类）。但是，int和tuple实例不能作为弱引用的目标，甚至它们的子类也不行。这些局限基本上是CPython的实现细节，在其他Python解释器中情况可能不一样，这些局限是内部优化导致的结果。</p><h1 id="python对不可变类型施加的把戏">Python对不可变类型施加的把戏</h1><p>对元组t来说，t[:]不创建副本，而是返回同一个对象的引用。此外，tuple(t)获得的也是同一个元组的引用。在Python控制台中输入help(tuple)，你会看到这句话：“If the argument is a tuple, the return value is the same object.”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 = tuple(t1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 <span class="keyword">is</span> t1</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t3 = t1[:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t3 <span class="keyword">is</span> t1</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>str、bytes和frozenset实例也有这种行为。frozenset实例不是序列，不能使用fs[:]，但是fs.copy()具有相同的效果：它会欺骗你，返回同一个对象的引用，而不是创建一个副本。copy方法不会复制所有对象，这是一个善意的谎言，为的是接口的兼容性：这使得frozenset的兼容性比set强。两个不可变对象是同一个对象还是副本，对最终用户来说没有区别。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t3 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 <span class="keyword">is</span> t3  <span class="comment"># t1和t3不是同一个对象</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = <span class="string">'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = <span class="string">'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 <span class="keyword">is</span> s2  <span class="comment"># 奇怪的事情发生了，s1和s2指代同一个字符串</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>共享字符串字面量是一种优化措施，称为驻留（interning）。CPython还会在小的整数上使用这个优化措施，防止重复创建“热门”数字。注意，CPython不会驻留所有字符串和整数，驻留的条件是实现细节，而且没有文档说明。因此，千万不要依赖字符串或整数的驻留！比较字符串或整数是否相等时，应该使用==，而不是is。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标准库中的装饰器</title>
      <link href="/notes/fluent-python/decorators-in-standard-library/"/>
      <url>/notes/fluent-python/decorators-in-standard-library/</url>
      
        <content type="html"><![CDATA[<p>标准库中最值得关注的两个装饰器是lru_cache和全新的singledispatch（Python3.4新增）。这两个装饰器都在functools模块中定义。</p><h1 id="使用lru_cache做备忘">使用lru_cache做备忘</h1><p>functools.lru_cache实现了备忘（memoization）功能。这是一项优化技术，它把耗时的函数的结果保存起来，避免传入相同的参数时重复计算。LRU三个字母是“Least Recently Used”的缩写，表明缓存不会无限制增长，一段时间不用的缓存条目会被扔掉。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/functools#functools.lru_cache" target="_blank" rel="noopener"><code>@functools.lru_cache(maxsize=128, typed=False)</code></a></p><p>maxsize参数指定存储多少个调用的结果。缓存满了之后，旧的结果会被扔掉，腾出空间。为了得到最佳性能，maxsize应该设为2的幂。</p><p>Typed参数如果设为True，把不同类型参数得到的结果分开保存，即把通常认为相同的浮点数和整数参数（如1和1.0）区分开。</p><p>lru_cache使用字典存储结果，而且键根据调用时传入的定位参数和关键字参数创建，所以被lru_cache装饰的函数，它的所有参数都必须是可散列的。</p></blockquote><a id="more"></a><p>生成第n个斐波那契这种慢速递归函数适合使用lru_cache。</p><figure class="highlight python"><figcaption><span>clockdemo.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        t0 = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        elapsed = time.time() - t0</span><br><span class="line">        name = func.__name__</span><br><span class="line">        arg_lst = []</span><br><span class="line">        <span class="keyword">if</span> args:</span><br><span class="line">            arg_lst.append(<span class="string">', '</span>.join(repr(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args))</span><br><span class="line">        <span class="keyword">if</span> kwargs:</span><br><span class="line">            pairs = [<span class="string">'%s=%r'</span> % (k, w) <span class="keyword">for</span> k, w <span class="keyword">in</span> sorted(kwargs.items())]</span><br><span class="line">            arg_lst.append(<span class="string">', '</span>.join(pairs))</span><br><span class="line">        arg_str = <span class="string">', '</span>.join(arg_lst)</span><br><span class="line">        print(<span class="string">'[%0.8fs] %s(%s) -&gt; %r '</span> % (elapsed, name, arg_str, result))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clocked</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> clockdemo <span class="keyword">import</span> clock</span><br><span class="line"></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">2</span>) + fibonacci(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(fibonacci(<span class="number">6</span>))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[0.00000095s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000095s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00005102s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00000072s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000787s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00001478s] fibonacci(3) -&gt; 2</span><br><span class="line">[0.00007391s] fibonacci(4) -&gt; 3</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000691s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00001407s] fibonacci(3) -&gt; 2</span><br><span class="line">[0.00000119s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000691s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000095s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000834s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00001383s] fibonacci(3) -&gt; 2</span><br><span class="line">[0.00002813s] fibonacci(4) -&gt; 3</span><br><span class="line">[0.00005007s] fibonacci(5) -&gt; 5</span><br><span class="line">[0.00013185s] fibonacci(6) -&gt; 8</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>浪费时间的地方很明显：fibonacci(1)调用了8次，fibonacci(2)调用了5次……下面使用缓存实现，速度更快。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">from</span> clockdemo <span class="keyword">import</span> clock</span><br><span class="line"></span><br><span class="line"><span class="meta">@functools.lru_cache()  # 必须加括号，因为lru_cache可以接受配置参数，lru_cache应用到clock返回的函数上</span></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">2</span>) + fibonacci(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(fibonacci(<span class="number">6</span>))</span><br></pre></td></tr></table></figure><p>执行时间减半了，而且n的每个值只调用一次函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[0.00000000s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000119s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00004601s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00000119s] fibonacci(3) -&gt; 2</span><br><span class="line">[0.00005412s] fibonacci(4) -&gt; 3</span><br><span class="line">[0.00000000s] fibonacci(5) -&gt; 5</span><br><span class="line">[0.00006390s] fibonacci(6) -&gt; 8</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>除了优化递归算法之外，lru_cache在从Web中获取信息的应用中也能发挥巨大作用。</p><h1 id="单分派泛函数">单分派泛函数</h1><p>假设我们在开发一个调试Web应用的工具，想生成HTML，显示不同类型的Python对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> html</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">htmlize</span><span class="params">(obj)</span>:</span></span><br><span class="line">    content = html.escape(repr(obj))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;pre&gt;&#123;&#125;&lt;/pre&gt;'</span>.format(content)</span><br></pre></td></tr></table></figure><p>这个函数适用于任何Python类型，但是现在想做个扩展，让它使用特别的方式显示某些类型。</p><ul><li>str: 把内部的换行符替换为'&lt;br&gt;\n'；不使用&lt;pre&gt;，而是使用&lt;p&gt;。</li><li>int: 以十进制和十六进制显示数字。</li><li>list: 输出一个HTML列表，根据各个元素的类型进行格式化。</li></ul><p>因为Python不支持重载方法或函数，所以不能使用不同的签名定义htmlize的变体，也无法使用不同的方式处理不同的数据类型。在Python中，一种常见的做法是把htmlize变成一个分派函数，使用一串if/elif/elif，调用专门的函数，如htmlize_str、htmlize_int，等等。这样不便于模块的用户扩展，还显得笨拙：时间一长，分派函数htmlize会变得很大，而且它与各个专门函数之间的耦合也很紧密。</p><p>Python3.4新增的functools.singledispatch装饰器可以把整体方案拆分成多个模块，甚至可以为你无法修改的类提供专门的函数。使用@singledispatch装饰的普通函数会变成泛函数（generic function）：根据第一个参数的类型，以不同方式执行相同操作的一组函数。（这才称得上是单分派。如果根据多个参数选择专门的函数，那就是多分派了。）具体做法如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"><span class="keyword">import</span> numbers</span><br><span class="line"><span class="keyword">import</span> html</span><br><span class="line"></span><br><span class="line"><span class="meta">@singledispatch  # 标记处理object函数的基函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">htmlize</span><span class="params">(obj)</span>:</span></span><br><span class="line">    content = html.escape(repr(obj))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;pre&gt;&#123;&#125;&lt;/pre&gt;'</span>.format(content)</span><br><span class="line"></span><br><span class="line"><span class="meta">@htmlize.register(str)  # 专门函数，函数名称无关紧要，_是个不错的选择</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(text)</span>:</span></span><br><span class="line">    content = html.escape(text).replace(<span class="string">'\n'</span>, <span class="string">'&lt;br&gt;\n'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;p&gt;&#123;0&#125;&lt;/p&gt;'</span>.format(content)</span><br><span class="line"></span><br><span class="line"><span class="meta">@htmlize.register(numbers.Integral)  # numbers.Integral是int的虚拟超类</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;pre&gt;&#123;0&#125; (0x&#123;0:x&#125;)&lt;/pre&gt;'</span>.format(n)</span><br><span class="line"></span><br><span class="line"><span class="meta">@htmlize.register(tuple)  # 可以叠放多个register装饰器，让同一个函数支持不同类型</span></span><br><span class="line"><span class="meta">@htmlize.register(abc.MutableSequence)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(seq)</span>:</span></span><br><span class="line">    inner = <span class="string">'&lt;/li&gt;\n&lt;li&gt;'</span>.join(htmlize(item) <span class="keyword">for</span> item <span class="keyword">in</span> seq)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;ul&gt;\n&lt;li&gt;'</span> + inner + <span class="string">'&lt;/li&gt;\n&lt;/ul&gt;'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(repr(htmlize(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)), <span class="string">'\n'</span>)</span><br><span class="line">    print(repr(htmlize(abs)), <span class="string">'\n'</span>)</span><br><span class="line">    print(repr(htmlize(<span class="string">'Heimlich &amp; Co.\n- a game'</span>)), <span class="string">'\n'</span>)</span><br><span class="line">    print(repr(htmlize(<span class="number">42</span>)), <span class="string">'\n'</span>)</span><br><span class="line">    print(htmlize([<span class="string">'alpha'</span>, <span class="number">66</span>, &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;]))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&apos;&lt;pre&gt;&#123;1, 2, 3&#125;&lt;/pre&gt;&apos;</span><br><span class="line"></span><br><span class="line">&apos;&lt;pre&gt;&amp;lt;built-in function abs&amp;gt;&lt;/pre&gt;&apos;</span><br><span class="line"></span><br><span class="line">&apos;&lt;p&gt;Heimlich &amp;amp; Co.&lt;br&gt;\n- a game&lt;/p&gt;&apos;</span><br><span class="line"></span><br><span class="line">&apos;&lt;pre&gt;42 (0x2a)&lt;/pre&gt;&apos;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;&lt;p&gt;alpha&lt;/p&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;pre&gt;66 (0x42)&lt;/pre&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;pre&gt;&#123;1, 2, 3&#125;&lt;/pre&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>只要可能，注册的专门函数应该处理抽象基类（如numbers.Integral和abc.MutableSequence），不要处理具体实现类（如int和list）。这样，代码支持的兼容类型更广泛。</p><p>singledispatch机制的一个显著特征是，你可以在系统的任何地方和任何模块中注册专门函数。如果后来在新的模块中定义了新的类型，可以轻松地添加一个新的专门函数用来处理那个类型。此外，还可以为不是自己编写的或者不能修改的类添加自定义函数。</p><p>singledispatch提供的特性很多，这个机制最好的文档是 <a href="https://www.python.org/dev/peps/pep-0443/" target="_blank" rel="noopener">PEP 443 —— Single-dispatch generic functions</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> decorators </tag>
            
            <tag> lru_cache </tag>
            
            <tag> singledispatch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现一个简单的装饰器</title>
      <link href="/notes/fluent-python/implementing-a-simple-decorator/"/>
      <url>/notes/fluent-python/implementing-a-simple-decorator/</url>
      
        <content type="html"><![CDATA[<h1 id="一个简单的clock装饰器">一个简单的clock装饰器</h1><p>定义一个装饰器，它会在每次调用被装饰的函数时计时，然后把经过的时间、传入的参数和调用的结果打印出来。</p><figure class="highlight python"><figcaption><span>clockdeco_demo.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*args)</span>:</span>  <span class="comment"># 定义内部函数clocked，它接受任意个定位参数</span></span><br><span class="line">        t0 = time.perf_counter()</span><br><span class="line">        result = func(*args)  <span class="comment"># func是自由变量</span></span><br><span class="line">        elapsed = time.perf_counter() - t0</span><br><span class="line">        name = func.__name__</span><br><span class="line">        arg_str = <span class="string">', '</span>.join(repr(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args)</span><br><span class="line">        print(<span class="string">'[%0.8fs] %s(%s) -&gt; %r'</span> % (elapsed, name, arg_str, result))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clocked  <span class="comment"># 返回内部函数，取代被装饰的函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@clock  # 示例</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snooze</span><span class="params">(seconds)</span>:</span></span><br><span class="line">    time.sleep(seconds)</span><br><span class="line"></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'*'</span> * <span class="number">40</span>, <span class="string">'Calling snooze(.123)'</span>)</span><br><span class="line">    snooze(<span class="number">.123</span>)</span><br><span class="line">    print(<span class="string">'*'</span> * <span class="number">40</span>, <span class="string">'Calling factorial(6)'</span>)</span><br><span class="line">    print(<span class="string">'6! ='</span>, factorial(<span class="number">6</span>))</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">**************************************** Calling snooze(.123)</span><br><span class="line">[0.12325113s] snooze(0.123) -&gt; None</span><br><span class="line">**************************************** Calling factorial(6)</span><br><span class="line">[0.00000078s] factorial(1) -&gt; 1</span><br><span class="line">[0.00003158s] factorial(2) -&gt; 2</span><br><span class="line">[0.00010166s] factorial(3) -&gt; 6</span><br><span class="line">[0.00043166s] factorial(4) -&gt; 24</span><br><span class="line">[0.00044242s] factorial(5) -&gt; 120</span><br><span class="line">[0.00045205s] factorial(6) -&gt; 720</span><br><span class="line">6! = 720</span><br></pre></td></tr></table></figure><h1 id="工作原理">工作原理</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">factorial = clock(factorial)</span><br></pre></td></tr></table></figure><p>因此，在两个示例中，factorial会作为func参数传给clock。然后，clock函数会返回clocked函数，Python解释器在背后会把clocked赋值给factorial。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> clockdeco_demo  <span class="comment"># 导入模块</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>clockdeco_demo.factorial.__name__  <span class="comment"># factorial的__name__</span></span><br><span class="line"><span class="string">'clocked'</span></span><br></pre></td></tr></table></figure><p>所以，现在factorial保存的是clocked函数的引用。自此之后，每次调用factorial(n)，执行的都是clocked(n)。这是装饰器的典型行为：把被装饰的函数替换成新函数，二者接受相同的参数，而且（通常）返回被装饰的函数本该返回的值，同时还会做些额外操作。</p><p><em>Gamma等人写的《设计模式：可复用面向对象软件的基础》一书是这样概述装饰器模式的：“动态地给一个对象添加一些额外的职责。”函数装饰器符合这一说法，但是，在实现层面，Python装饰器与GoF所述的装饰器没有多少相似之处。</em></p><p>上例实现的clock装饰器有几个缺点：不支持关键字参数，而且遮盖了被装饰函数的<code>__name__</code>和<code>__doc__</code>属性，下面使用functools.wraps装饰器把相关的属性从func复制到clocked中。此外，还能正确处理关键字参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(func)</span>:</span>  <span class="comment"># 新版clock</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)  # 标准库中的装饰器之一</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*args, **kwargs)</span>:</span>  <span class="comment"># 接受定位和关键字参数</span></span><br><span class="line">        t0 = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        elapsed = time.time() - t0</span><br><span class="line">        name = func.__name__</span><br><span class="line">        arg_lst = []</span><br><span class="line">        <span class="keyword">if</span> args:</span><br><span class="line">            arg_lst.append(<span class="string">', '</span>.join(repr(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args))</span><br><span class="line">        <span class="keyword">if</span> kwargs:</span><br><span class="line">            pairs = [<span class="string">'%s=%r'</span> % (k, w) <span class="keyword">for</span> k, w <span class="keyword">in</span> sorted(kwargs.items())]</span><br><span class="line">            arg_lst.append(<span class="string">', '</span>.join(pairs))</span><br><span class="line">        arg_str = <span class="string">', '</span>.join(arg_lst)</span><br><span class="line">        print(<span class="string">'[%0.8fs] %s(%s) -&gt; %r '</span> % (elapsed, name, arg_str, result))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clocked</span><br><span class="line"></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  <span class="comment"># 测试</span></span><br><span class="line">    print(<span class="string">'6! ='</span>, factorial(n=<span class="number">6</span>))</span><br><span class="line">    print(factorial.__name__)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[0.00000000s] factorial(1) -&gt; 1</span><br><span class="line">[0.00003505s] factorial(2) -&gt; 2</span><br><span class="line">[0.00014687s] factorial(3) -&gt; 6</span><br><span class="line">[0.00014997s] factorial(4) -&gt; 24</span><br><span class="line">[0.00015521s] factorial(5) -&gt; 120  # 递归是通过定位传入的</span><br><span class="line">[0.00015807s] factorial(n=6) -&gt; 720  # 最外层是通过关键词传入的</span><br><span class="line">6! = 720</span><br><span class="line">factorial  # 函数的__name__属性也被复制过来了</span><br></pre></td></tr></table></figure><h1 id="叠放装饰器">叠放装饰器</h1><p>把@d1和<span class="citation" data-cites="d2两个装饰器按顺序应用到f函数上">@d2两个装饰器按顺序应用到f函数上</span>，作用相当于f = d1(d2(f))。在一节中使用过该技巧：<span class="citation" data-cites="lru_cache应用到">@lru_cache应用到</span><span class="citation" data-cites="clock装饰fibonacci得到的结果上">@clock装饰fibonacci得到的结果上</span>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@d1</span></span><br><span class="line"><span class="meta">@d2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'f'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'f'</span>)</span><br><span class="line"></span><br><span class="line">f = d1(d2(f))</span><br></pre></td></tr></table></figure><h1 id="参数化装饰器">参数化装饰器</h1><p>解析源码中的装饰器时，Python把被装饰的函数作为第一个参数传给装饰器函数。那怎么让装饰器接受其他参数呢？答案是：创建一个装饰器工厂函数，把参数传给它，返回一个装饰器，然后再把它应用到要装饰的函数上。例如下面的装饰器。</p><figure class="highlight python"><figcaption><span>registration.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">registry = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">'running register(%s)'</span> % func)</span><br><span class="line">    registry.append(func)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f1()'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'running main()'</span>)</span><br><span class="line">print(<span class="string">'registry -&gt;'</span>, registry)</span><br><span class="line">f1()</span><br></pre></td></tr></table></figure><p>为了便于启用或禁用register执行的函数注册功能，为它提供一个可选的active参数，设为False时，不注册被装饰的函数。</p><figure class="highlight python"><figcaption><span>registration_param.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">registry = set()  <span class="comment"># 便于添加和删除对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(active=True)</span>:</span>  <span class="comment"># 接受一个可选的关键字参数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span>  <span class="comment"># 真正的装饰器，其参数是函数</span></span><br><span class="line">        print(<span class="string">'running register(active=%s)-&gt;decorate(%s)'</span> % (active, func))</span><br><span class="line">        <span class="keyword">if</span> active:</span><br><span class="line">            registry.add(func)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            registry.discard(func)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> func  <span class="comment"># 返回一个函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decorate  <span class="comment"># register时装饰器工厂函数，因此返回decorate</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@register(active=False)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f1()'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@register()  # 即使不传入参数，也必须作为函数调用（@register()）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f2()'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f3()'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> registration_param <span class="keyword">import</span> *  <span class="comment"># 导入</span></span><br><span class="line">running register(active=False)-&gt;decorate(&lt;function f1 at 0x109fd0bf8&gt;)</span><br><span class="line">running register(active=True)-&gt;decorate(&lt;function f2 at 0x109fd0c80&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>registry</span><br><span class="line">&#123;&lt;function f2 at <span class="number">0x109fd0c80</span>&gt;&#125;  <span class="comment"># 只有f2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>register()(f3)  <span class="comment"># register()返回decoratro，然后应用到f3上</span></span><br><span class="line">running register(active=True)-&gt;decorate(&lt;function f3 at 0x109fd0b70&gt;)</span><br><span class="line">&lt;function f3 at <span class="number">0x109fd0b70</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>registry</span><br><span class="line">&#123;&lt;function f2 at <span class="number">0x109fd0c80</span>&gt;, &lt;function f3 at <span class="number">0x109fd0b70</span>&gt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>register(active=<span class="literal">False</span>)(f2)  <span class="comment"># 删除f2</span></span><br><span class="line">running register(active=False)-&gt;decorate(&lt;function f2 at 0x109fd0c80&gt;)</span><br><span class="line">&lt;function f2 at <span class="number">0x109fd0c80</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>registry</span><br><span class="line">&#123;&lt;function f3 at <span class="number">0x109fd0b70</span>&gt;&#125;</span><br></pre></td></tr></table></figure><p>参数化装饰器的远离相当复杂，刚刚讨论的比大多数都简单。参数化装饰器通常会把被装饰的函数替换掉，而且结构上需要多一层嵌套。接下来会探讨这种函数金字塔。</p><h1 id="参数化clock装饰器">参数化clock装饰器</h1><p>为clock装饰器添加一个功能：让用户传入一个格式字符串，控制被装饰函数的输出。</p><figure class="highlight python"><figcaption><span>clockdeco_param.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">DEFAULT_FMT = <span class="string">'[&#123;elapsed:0.8f&#125;s] &#123;name&#125;(&#123;args&#125;) -&gt; &#123;result&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(fmt=DEFAULT_FMT)</span>:</span>  <span class="comment"># 装饰器工厂函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span>  <span class="comment"># 真正的装饰器</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*_args)</span>:</span>  <span class="comment"># 包装被装饰的函数</span></span><br><span class="line">            t0 = time.time()</span><br><span class="line">            _result = func(*_args)  <span class="comment"># 调用被装饰的函数</span></span><br><span class="line">            elapsed = time.time() - t0</span><br><span class="line">            name = func.__name__</span><br><span class="line">            args = <span class="string">', '</span>.join(repr(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> _args)</span><br><span class="line">            result = repr(_result)</span><br><span class="line">            print(fmt.format(**locals()))  <span class="comment"># 引用clock的局部变量</span></span><br><span class="line">            <span class="keyword">return</span> _result  <span class="comment"># 返回被装饰函数返回的值</span></span><br><span class="line">        <span class="keyword">return</span> clocked</span><br><span class="line">    <span class="keyword">return</span> decorate</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line"><span class="meta">    @clock()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">snooze</span><span class="params">(seconds)</span>:</span></span><br><span class="line">        time.sleep(seconds)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @clock('&#123;name&#125;: &#123;elapsed&#125;s')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">snooze1</span><span class="params">(seconds)</span>:</span></span><br><span class="line">        time.sleep(seconds)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @clock('&#123;name&#125;(&#123;args&#125;) dt=&#123;elapsed:0.3f&#125;s')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">snooze2</span><span class="params">(seconds)</span>:</span></span><br><span class="line">        time.sleep(seconds)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> func <span class="keyword">in</span> [snooze, snooze1, snooze2]:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            func(<span class="number">.123</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[0.12812114s] snooze(0.123) -&gt; None</span><br><span class="line">[0.12493706s] snooze(0.123) -&gt; None</span><br><span class="line">[0.12483931s] snooze(0.123) -&gt; None</span><br><span class="line">snooze1: 0.12311005592346191s</span><br><span class="line">snooze1: 0.12802791595458984s</span><br><span class="line">snooze1: 0.12346792221069336s</span><br><span class="line">snooze2(0.123) dt=0.124s</span><br><span class="line">snooze2(0.123) dt=0.123s</span><br><span class="line">snooze2(0.123) dt=0.124s</span><br></pre></td></tr></table></figure><p><em>Graham Dumpleton和Lennart Regebro（Fluent Python一书的技术审校之一）认为，装饰器最好通过实现<code>__call__</code>方法的类实现，不应该通过函数实现。</em></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> decorators </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数装饰器和闭包</title>
      <link href="/notes/fluent-python/function-decorators-and-closures/"/>
      <url>/notes/fluent-python/function-decorators-and-closures/</url>
      
        <content type="html"><![CDATA[<p>函数装饰器用于在源码中“标记”函数，以某种方式增强函数的行为。这是一项强大的功能，但是若想掌握，必须理解闭包。除了在装饰器中有用处之外，闭包还是回调式异步编程和函数式编程风格的基础。</p><h1 id="装饰器基础知识">装饰器基础知识</h1><p>装饰器是可调用的对象，其参数是另一个函数（被装饰的函数）。装饰器可能会处理被装饰的函数，然后把它返回，或者将其替换成另一个函数或可调用对象。</p><p>假如有个名为decorate的装饰器，下述两种写法的效果一样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写法1</span></span><br><span class="line"><span class="meta">@decorate</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running target()'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写法2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running target()'</span>)</span><br><span class="line"></span><br><span class="line">target = decorate(target)</span><br></pre></td></tr></table></figure><a id="more"></a><p>两个代码片段执行完毕后得到的是decorate(target)返回的函数。为了确认被装饰的函数会被替换，看一个实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">'running inner()'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> inner  <span class="comment"># 返回inner函数</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@deco  <span class="comment"># 使用deco装饰target函数</span></span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'running target()'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>target()</span><br><span class="line">running inner()  <span class="comment"># 被装饰的target函数其实会运行inner</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>target  <span class="comment"># 审查对象，target现在是inner的引用</span></span><br><span class="line">&lt;function deco.&lt;locals&gt;.inner at <span class="number">0x106580d08</span>&gt;</span><br></pre></td></tr></table></figure><p>装饰器可以像常规的可调用对象那样调用，其参数是另一个函数。有时，这样做更方便，尤其是做元编程（在运行时改变程序的行为）时。</p><ul><li>装饰器的一大特性是，能把被装饰的函数替换成其他函数。</li><li>第二个特性是，装饰器在加载模块时立即执行。</li></ul><h1 id="python何时执行装饰器">Python何时执行装饰器</h1><p>装饰器的一个关键特性是，它们在被装饰的函数定义之后立即运行。这通常是在导入时（即Python加载模块时）。</p><figure class="highlight python"><figcaption><span>registration.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">registry = []  <span class="comment"># 保存被@register装饰的函数引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(func)</span>:</span>  <span class="comment"># 参数是函数</span></span><br><span class="line">    print(<span class="string">'running register(%s'</span> % func)  <span class="comment"># 为了演示，显示被装饰的函数</span></span><br><span class="line">    registry.append(func)  <span class="comment"># 存入被装饰的函数</span></span><br><span class="line">    <span class="keyword">return</span> func  <span class="comment"># 返回值是函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">     print(<span class="string">'running f1()'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f2()'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">()</span>:</span>  <span class="comment"># f1和f2被装饰，f3没有装饰</span></span><br><span class="line">    print(<span class="string">'running f3()'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running main()'</span>)</span><br><span class="line">    print(<span class="string">'registry -&gt;'</span>, registry)</span><br><span class="line">    f1()</span><br><span class="line">    f2()</span><br><span class="line">    f3()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()  <span class="comment"># 作为脚本运行时才调用main()</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ python registration.py  <span class="comment"># 把registration.py当作脚本运行时</span></span><br><span class="line">running register(&lt;function f1 at <span class="number">0x10a8e46a8</span>&gt;</span><br><span class="line">running register(&lt;function f2 at <span class="number">0x10a8e4730</span>&gt;</span><br><span class="line">running main()</span><br><span class="line">registry -&gt; [&lt;function f1 at 0x10a8e46a8&gt;, &lt;function f2 at 0x10a8e4730&gt;]</span><br><span class="line">running f1()</span><br><span class="line">running f2()</span><br><span class="line">running f3()</span><br><span class="line"></span><br><span class="line">$ python  <span class="comment"># 运行python解释器</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> registration  <span class="comment"># 导入模块</span></span><br><span class="line">running register(&lt;function f1 at <span class="number">0x10e893b70</span>&gt;</span><br><span class="line">running register(&lt;function f2 at <span class="number">0x10e893bf8</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>registration.registry  <span class="comment"># 查看registry的值</span></span><br><span class="line">[&lt;function f1 at <span class="number">0x10e893b70</span>&gt;, &lt;function f2 at <span class="number">0x10e893bf8</span>&gt;]</span><br></pre></td></tr></table></figure><p>上例主要想强调，函数装饰器在导入模块时立即执行（register运行了两次，分别装饰了f1和f2），而被装饰的函数只有在明确调用时运行。这突出了导入时和运行时之间的区别。</p><p>考虑到装饰器在真实代码中的常用方式，上例有两个不寻常的地方。</p><ul><li>装饰器函数与被装饰的函数在同一个模块中定义。实际情况是，装饰器通常在一个模块中定义，然后应用到其他模块中的函数上。</li><li>register装饰器返回的函数与通过参数传入的函数相同。实际上，大多数装饰器会在内部定义一个函数，然后将其返回。</li></ul><p>虽然register装饰器原封不动地返回被装饰的函数，到那时这种技术并非没有用处。很多Python Web框架使用这样的装饰器把函数添加到某种中央注册处，例如把URL模式映射到生成HTTP响应的函数上的注册处。这种注册装饰器可能会也可能不会修改被装饰的函数。</p><h1 id="使用装饰器改进策略模式">使用装饰器改进策略模式</h1><p>回顾，支持的简单方案：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fidelity_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""为积分为1000或以上的顾客提供5%折扣"""</span></span><br><span class="line">    <span class="keyword">return</span> order.total() * <span class="number">.05</span> <span class="keyword">if</span> order.customer.fidelity &gt;= <span class="number">1000</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bulk_item_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""单个商品为20个或以上时提供10%折扣"""</span></span><br><span class="line">    discount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> order.cart:</span><br><span class="line">        <span class="keyword">if</span> item.quantity &gt;= <span class="number">20</span>:</span><br><span class="line">            discount += item.total() * <span class="number">.1</span></span><br><span class="line">    <span class="keyword">return</span> discount</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">large_order_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""订单中的不同商品达到10个或以上时提供7%折扣"""</span></span><br><span class="line">    distinct_items = &#123;item.product <span class="keyword">for</span> item <span class="keyword">in</span> order.cart&#125;</span><br><span class="line">    <span class="keyword">if</span> len(distinct_items) &gt;= <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">return</span> order.total() * <span class="number">.07</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">promos = [fidelity_promo, bulk_item_promo, large_order_promo]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""选择可用的最佳折扣"""</span></span><br><span class="line">    <span class="keyword">return</span> max(promo(order) <span class="keyword">for</span> promo <span class="keyword">in</span> promos)  <span class="comment"># 返回折扣额度最大的那个</span></span><br></pre></td></tr></table></figure><p>该方案的主要问题是，定义体中有函数的名称，但是best_promo用来判断哪个折扣幅度最大的promos列表中也有函数名称。这种重复是个问题，因为新增策略函数后可能会忘记把它添加到promos列表中，导致best_promo忽略新策略，而不报错，为系统引入了不易察觉的缺陷。下面使用注册装饰器解决这个问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">promos = []  <span class="comment"># 列表起初是空的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">promotion</span><span class="params">(promo_func)</span>:</span></span><br><span class="line">    promos.append(promo_func)  <span class="comment"># 添加到promos列表中</span></span><br><span class="line">    <span class="keyword">return</span> promo_func  <span class="comment"># 原封不动返回</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@promotion  # 装饰策略</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fidelity_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""为积分为1000或以上的顾客提供5%折扣"""</span></span><br><span class="line">    <span class="keyword">return</span> order.total() * <span class="number">.05</span> <span class="keyword">if</span> order.customer.fidelity &gt;= <span class="number">1000</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@promotion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bulk_item_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""单个商品为20个或以上时提供10%折扣"""</span></span><br><span class="line">    discount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> order.cart:</span><br><span class="line">        <span class="keyword">if</span> item.quantity &gt;= <span class="number">20</span>:</span><br><span class="line">            discount += item.total() * <span class="number">.1</span></span><br><span class="line">    <span class="keyword">return</span> discount</span><br><span class="line"></span><br><span class="line"><span class="meta">@promotion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">large_order_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""订单中的不同商品达到10个或以上时提供7%折扣"""</span></span><br><span class="line">    distinct_items = &#123;item.product <span class="keyword">for</span> item <span class="keyword">in</span> order.cart&#125;</span><br><span class="line">    <span class="keyword">if</span> len(distinct_items) &gt;= <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">return</span> order.total() * <span class="number">.07</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_promo</span><span class="params">(order)</span>:</span>  <span class="comment"># 不变</span></span><br><span class="line">    <span class="string">"""选择可用的最佳折扣"""</span></span><br><span class="line">    <span class="keyword">return</span> max(promo(order) <span class="keyword">for</span> promo <span class="keyword">in</span> promos)</span><br></pre></td></tr></table></figure><p>与使用globals()或用insepect找出全部策略的方案相比，使用装饰器有几个优点。</p><ul><li>促销策略函数无须使用特殊的名称（即不用以_promo结尾）。</li><li><span class="citation" data-cites="promotion装饰器突出了被装饰的函数的作用">@promotion装饰器突出了被装饰的函数的作用</span>，还便于临时禁用某个促销策略：只需把装饰器注释掉。</li><li>促销折扣策略可以在其他模块中定义，在系统中的任何地方都行，只要使用@promotion装饰即可。</li></ul><p>不过，多数装饰器会修改被装饰的函数。通常它们会定义一个内部函数，然后将其返回，替换被装饰的函数。使用内部函数的代码几乎都要靠闭包才能正确运作。</p><h1 id="变量作用域规则">变量作用域规则</h1><p>为了理解闭包，先了解Python中的变量作用域。示例 一个函数，读取一个局部变量和一个全局变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(a)</span>:</span></span><br><span class="line">        print(a)</span><br><span class="line">        print(b)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">3</span>, <span class="keyword">in</span> f1</span><br><span class="line">NameError: name <span class="string">'b'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">6</span>  <span class="comment"># 先给全局变量b赋值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">3</span>)  <span class="comment"># 再调用就不会出错</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p>下面看一个可能会让你吃惊的示例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(a)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(a)</span><br><span class="line"><span class="meta">... </span>    print(b)</span><br><span class="line"><span class="meta">... </span>    b = <span class="number">9</span>  <span class="comment"># 由于给变量b赋值，编译器将b归类为局部变量</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2(<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span>  <span class="comment"># print(a)执行了</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">3</span>, <span class="keyword">in</span> f2</span><br><span class="line">UnboundLocalError: local variable <span class="string">'b'</span> referenced before assignment  <span class="comment"># 局部变量'b'未定义</span></span><br></pre></td></tr></table></figure><p>Python编译函数的定义体时，它判断b是局部变量，因为在函数中给它赋值了。生成的字节码（可以用dis.dis(f2)查看f2的字节码）证实了这种判断，Python会尝试从本地环境获取b。后面调用f2(3)时，f2的定义体会获取并打印局部变量a的值，但是尝试获取局部变量b的值时，发现b没有绑定值。</p><p>这不是缺陷，而是设计选择：Python不要求声明变量，但是假定在函数定义体中赋值的变量是局部变量。JavaScript也不要求声明变量，但是如果忘记把变量声明为局部变量（使用var），可能会在不知情的情况下获取全局变量。</p><p>如果在函数中赋值时想让解释器把b当成全局变量，要使用global声明。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">(a)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">global</span> b</span><br><span class="line"><span class="meta">... </span>    print(a)</span><br><span class="line"><span class="meta">... </span>    print(b)</span><br><span class="line"><span class="meta">... </span>    b = <span class="number">9</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f3(<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f3(<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><h1 id="闭包">闭包</h1><p>在函数内部定义函数不常见，直到开始使用匿名函数才会这样做。而且，只有涉及嵌套函数时才有闭包问题。其实，闭包指延伸了作用域的函数，其中包括函数定义体中引用、但是不在定义体中定义的非全局变量。函数是不是匿名的没有关系，关键是它能访问定义体之外定义的非全局变量。</p><p>假如有个名为avg的函数，它的作用是计算不断增加的系列值的均值。例如，整个历史中某个商品的平均收盘价。每天都会增加新价格，因此平均值要考虑至目前为止所有的价格。起初，avg是这样使用的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">10</span>)</span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">11</span>)</span><br><span class="line"><span class="number">10.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">12</span>)</span><br><span class="line"><span class="number">11.0</span></span><br></pre></td></tr></table></figure><p>avg从何而来，它又在哪里保存历史值呢？下面看两种实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Averager</span><span class="params">()</span>:</span>  <span class="comment"># 使用类实现</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.series = []</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, new_value)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.series.append(new_value)</span><br><span class="line"><span class="meta">... </span>        total = sum(self.series)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> total / len(self.series)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg = Averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">1</span>)</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg = Averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">10</span>)</span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">11</span>)</span><br><span class="line"><span class="number">10.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">12</span>)</span><br><span class="line"><span class="number">11.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.series  <span class="comment"># 历史值保存在实例的series属性中</span></span><br><span class="line">[<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span>  <span class="comment"># 函数式实现</span></span><br><span class="line"><span class="meta">... </span>    series = []  <span class="comment"># series是make_averager的局部变量</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line"><span class="meta">... </span>        series.append(new_value)  <span class="comment"># 访问了定义体之外的局部变量</span></span><br><span class="line"><span class="meta">... </span>        total = sum(series)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> total / len(series)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> averager</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg = make_averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">10</span>)</span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">11</span>)</span><br><span class="line"><span class="number">10.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">12</span>)</span><br><span class="line"><span class="number">11.0</span></span><br></pre></td></tr></table></figure><p>函数式实现中的avg函数在哪里寻找series呢？注意，series是make_averager函数的局部变量，因为那个函数的定义体中初始化了series。可是，调用avg(10)时，make_averager函数已经返回了，而它的本地作用域也一去不复返了。</p><p>在averager函数中，series是自由变量（free variable），这是一个技术术语，指未在本地作用域中绑定的变量（series的绑定发生在make_averager定义体中）。</p><p><img data-src="/uploads/posts/fluent-python/closure-and-free-variable.png"></p><p>averager的闭包延伸到那个函数的作用域之外，包含自由变量series的绑定。审查返回的averager对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__code__.co_varnames</span><br><span class="line">(<span class="string">'new_value'</span>, <span class="string">'total'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__code__.co_freevars</span><br><span class="line">(<span class="string">'series'</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__closure__</span><br><span class="line">(&lt;cell at <span class="number">0x106562738</span>: list object at <span class="number">0x10658fd48</span>&gt;,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__closure__[<span class="number">0</span>].cell_contents</span><br><span class="line">[<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]</span><br></pre></td></tr></table></figure><p>综上，闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时，虽然定义作用域不可用了，但是仍能使用那些绑定。注意，只有嵌套在其他函数中的函数（本例的averager函数）才可能需要处理不在全局作用域中的外部变量（本例的series）。</p><h1 id="nonlocal声明">nonlocal声明</h1><p>在上例中，我们把所有值存储在历史数列中，然后在每次调用averager时使用sum求和。更好的实现方式是，只存储目前的总值和元素个数，然后使用这两个数计算均值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    count = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    total = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line"><span class="meta">... </span>        count += <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>        total += new_value</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> total / count</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> averager</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg = make_averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">10</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">5</span>, <span class="keyword">in</span> averager</span><br><span class="line">UnboundLocalError: local variable <span class="string">'count'</span> referenced before assignment</span><br></pre></td></tr></table></figure><p>为什么想象中的自由变量count会变成局部变量呢？</p><p><strong>问题是，当count是任何不可变类型（数字、字符串、元组等）时，count += 1语句的作用其实与count = count + 1一样。因此，在averager定义体中为count赋值了，这会把count变成局部变量。total变量也受这个问题影响。</strong></p><p><strong>对不可变类型来说，只能读取，不能更新。如果尝试重新绑定，例如count = count + 1，其实会隐式创建局部变量count。这样，count就不是自由变量，因此不会保存在闭包中。</strong></p><p>Python3引入了nonlocal声明。它的作用是把变量标记为自由变量，即使在函数中为变量赋予新值了，也会变成自由变量。如果为nonlocal声明的变量赋予新值，闭包中保存的绑定会更新。使用nonlocal修正后的函数如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> count, total</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        total += new_value</span><br><span class="line">        <span class="keyword">return</span> total / count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> decorators </tag>
            
            <tag> strategy </tag>
            
            <tag> closures </tag>
            
            <tag> global </tag>
            
            <tag> nonlocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SOLID设计原则</title>
      <link href="/notes/the-art-of-design-patterns/solid-design-principles/"/>
      <url>/notes/the-art-of-design-patterns/solid-design-principles/</url>
      
        <content type="html"><![CDATA[<h1 id="solid">SOLID</h1><p>在程序设计领域，SOLID是五种常用原则的首字母缩写。《设计模式的艺术》一书还列出了另外两种（表格最后两行）原则。</p><table><thead><tr class="header"><th>首字母</th><th>名称</th><th>定义</th></tr></thead><tbody><tr class="odd"><td>S</td><td>单一职责原则（Single Responsibility Principle）</td><td>一个类只负责一个功能领域中的相应职责</td></tr><tr class="even"><td>O</td><td>开闭原则（Open-Closed Principle）</td><td>软件实体应对扩展开放，而对修改关闭</td></tr><tr class="odd"><td>L</td><td>里氏代换原则（Liskov Substitution Principle）</td><td>所有引用基类对象的地方能够透明地使用其子类的对象</td></tr><tr class="even"><td>I</td><td>接口隔离原则（Interface Segregation Principle）</td><td>使用多个专门的接口，而不使用单一的总接口</td></tr><tr class="odd"><td>D</td><td>依赖反转原则（Dependence Inversion Principle）</td><td>抽象不应该依赖于细节，细节应该依赖于抽象</td></tr><tr class="even"><td></td><td>合成复用原则（Composite Reuse Principle）</td><td>尽量使用对象组合，而不是继承来达到复用的目的</td></tr><tr class="odd"><td></td><td>迪米特法则（Law of Demeter）</td><td>一个软件实体应当尽可能少地与其他实体发生相互作用</td></tr></tbody></table><a id="more"></a><h1 id="单一职责原则">单一职责原则</h1><blockquote><p>一个类只负责一个功能领域中的相应职责。或者定义为：就一个类而言，应该只有一个引起它变化的原因。</p></blockquote><p>单一职责原则用于控制类的粒度。在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，要将这些职责进行分离，将不同的职责封装在不同的类中。</p><h1 id="开闭原则">开闭原则</h1><blockquote><p>一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。</p></blockquote><p>软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时，具备较好的稳定性和延续性。</p><p>为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。</p><h1 id="里氏代换原则">里氏代换原则</h1><blockquote><p>所有引用基类（父类）的地方必须能透明地使用其子类的对象。</p></blockquote><p>里氏代换原则表明，在软件中将一个基类对象替换成它的子类对象，程序不会产生任何错误和异常，反过来则不成立。这是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中应尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</p><h1 id="接口隔离原则">接口隔离原则</h1><blockquote><p>使用多个专门的接口，而不使用单一的总接口，客户端不应该依赖那些它不需要的接口。</p></blockquote><p>每一个接口应该承担一种相对独立的角色。这里的“接口”有两种不同的含义，对于这两种不同的含义，ISP的表达方式以及含义都有所不同。</p><ol type="1"><li>当把”接口“理解成一个类型所提供的所有方法特征的集合时，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做”角色隔离原则”。</li><li>如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便。为了使接口的职责单一，需要将大接口重的方法根据其职责不同分别放在不同的小接口中。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“定制服务”，即为不同的客户端提供宽窄不同的接口。</li></ol><p>在使用接口隔离原则时，需要注意控制接口的粒度，接口不能太小，太小会导致系统中接口泛滥，不利于维护；也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来不方便。一般而言，接口中仅包含为某一类用户定制的方法即可。</p><h1 id="依赖反转原则">依赖反转原则</h1><blockquote><p>抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。</p></blockquote><p>如果说开闭原则是面向对象设计的目标的话，那么依赖反转原则就是面向对象设计的主要实现机制之一，它是系统抽象化的具体实现。</p><p>依赖反转原则要求在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要使用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，因为无法调用到在子类中增加的新方法。</p><p>在实现依赖反转原则时，需要针对抽象层编程，而将具体类的对象通过<strong>依赖注入</strong>（Dependency Injection，DI）的方式注入到其他对象中。依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有3中：构造注入、设值注入和接口注入。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过实现接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象覆盖父类对象。</p><h1 id="合成复用原则">合成复用原则</h1><blockquote><p>尽量使用对象组合，而不是继承来达到复用的目的。</p></blockquote><p>在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过关联（包括组合和聚合）关系或通过继承，但首先应该考虑使用关联，关联可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，使用继承时，需要严格遵循里氏代换原则。</p><p>通过继承来进行复用的主要问题在于继承会破坏系统的封装行，因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性。</p><p>关联关系可以将已有的对象纳入到新对象中，使之称为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见，所以这种复用又称为“黑箱”复用。相对于继承关系而言，其耦合度较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用成员对象的操作。合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。</p><p>一般而言，如果两个类之间是“Has-A”的关系，应使用组合或聚合，如果是“Is-A”的关系，可使用继承。</p><h1 id="迪米特法则">迪米特法则</h1><blockquote><p>一个软件实体应当尽可能少地与其他实体发生相互作用。</p></blockquote><p>如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易。这是对软件实体之间通信的限制。迪米特法则要求限制软件实体之间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。</p><p>在迪米特法则中，对于一个对象，其”朋友“包括以下几类：</p><ol type="1"><li>当前对象本身（this）。</li><li>以参数形式传入到当前对象方法中的对象。</li><li>当前对象的成员对象。</li><li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友。</li><li>当前对象所创建的对象。</li></ol><p>任何一个对象，如果满足上面的条件之一，就是当前对象的”朋友“，否则就是”陌生人“。在应用迪米特法则时，一个对象只能与直接“朋友”发生交互，不要与“陌生人“发生直接交互，这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。</p><p>迪米特法则要求在设计系统时，应该尽量减少对象之间的交互。如果一个对象需要调用另一个对象的方法，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> design patterns </tag>
            
            <tag> The Art of Design Patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML类图</title>
      <link href="/documentation/the-art-of-design-patterns/uml-class-diagram/"/>
      <url>/documentation/the-art-of-design-patterns/uml-class-diagram/</url>
      
        <content type="html"><![CDATA[<p>内容来自：</p><p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html" target="_blank" rel="noopener">看懂UML类图和时序图</a></p><p><a href="https://plantuml.com/zh/class-diagram" target="_blank" rel="noopener">类图的语法和功能</a></p><h1 id="从一个示例开始">从一个示例开始</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title class UML类图</span><br><span class="line">abstract 车 &lt;&lt;abstract&gt;&gt;</span><br><span class="line">hide empty methods</span><br><span class="line">小汽车 .up.|&gt; 车 : 实现</span><br><span class="line">自行车 .up.|&gt; 车 : 实现</span><br><span class="line">SUV -left-|&gt; 小汽车 : 继承</span><br><span class="line">小汽车 “1” *-down- “4” 轮胎 : 组合</span><br><span class="line">小汽车 “1” *-down- “1” 发动机 : 组合</span><br><span class="line">学生 .right.&gt; 自行车 : 依赖</span><br><span class="line">班级 “1” -up-o “many” 学生 : 聚合</span><br><span class="line">学生 “1” -down- “1” 身份证 : 关联</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><img data-src="http://www.plantuml.com/plantuml/svg/AyaioKbLICv9B2vM2FNrURvnzzFP-xWIaufBYXAJInHUx5scO6C3uzhPSMLafgGgfEOMb5GgvAQMPEId57CztT3_REDUa4gzqWAz6Zkm9Yk5f-lcFU_RmFMYVTMBXJsuP8D3mnHqSrBJIdI1CWY3h1IUxrx-h7C_ajcF6kOOFcgOgw2bcv9VdgSBufk0-2_shdlHt0VMqV9qGWT-7M3-q_w9JxjMF9kp2qdJscNFfynNq2lAJCyeqGEw4UveAuKd--Q-s3gDwtd_skUxbiCDqIqjqCq7yN8Jyoh1faACi59uqJWBoKYuUbGtlDYr-idklI_MDuA2edNpYyOf0000"><ul><li>小汽车与自行车和抽象类车之间的关系为<strong>实现</strong>关系，使用带空心箭头的虚线表示。</li><li>小汽车与SUV之间的关系是<strong>泛化</strong>关系，使用带空心箭头的实线表示。</li><li>小汽车与发动机、轮胎之间是<strong>组合</strong>关系，使用带实心箭头的实线表示。</li><li>学生与班级之间是<strong>聚合</strong>关系，使用带空心箭头的实线表示。</li><li>学生与身份证之间是<strong>关联</strong>关系，使用一根实线表示。</li><li>学生上学需要用到自行车，与自行车是一种<strong>依赖</strong>关系，使用带箭头的虚线表示。</li></ul><a id="more"></a><h1 id="类之间的关系">类之间的关系</h1><h2 id="泛化和实现">泛化和实现</h2><p>泛化关系（generalization）：最终代码中，泛化关系表现为继承非抽象类或实现接口（需要编程语言支持）。</p><p>实现关系（realize）： 最终代码中，实线关系表现为继承抽象类。</p><h2 id="聚合和组合">聚合和组合</h2><p>聚合关系（aggregation）：表示整体由部分构成，与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在。例如，部门撤销了，人员不会消失，他们依然存在。</p><p>组合关系（composition）：组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了。例如，公司不存在了，部门也将不存在了。</p><h2 id="关联和依赖">关联和依赖</h2><p>关联关系（association）：描述不同类的对象之间的结构关系，它是一种静态关系，通常与运行状态无关，一般由常识等因素决定。关联关系是一种“强关联”的关系。比如，乘车人和车票、学生与学校之间就是一种关联关系。关联关系默认不强调方向，表示对象相互知道。在最终代码中，关联对象通常是以成员变量的形式实现的。</p><p>依赖关系（dependency）：描述一个对象在运行期间会用到另一个对象。与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化，依赖关系也可能发生变化。显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单项依赖，杜绝双向依赖的产生。在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，使用对方的方法和属性。</p>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> design patterns </tag>
            
            <tag> UML </tag>
            
            <tag> plantuml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式一览</title>
      <link href="/notes/the-art-of-design-patterns/overview-of-design-patterns/"/>
      <url>/notes/the-art-of-design-patterns/overview-of-design-patterns/</url>
      
        <content type="html"><![CDATA[<blockquote><p>符合模式并不表示做得对。——Ralph Johnson</p><p>经典的《设计模式：可复用面性对象软件的基础》的作者之一</p></blockquote><blockquote><p>虽然设计模式与语言无关，但这并不意味着每一个模式都能在每一门语言中使用。1996年，Peter Norvig在题为“<a href="http://norvig.com/design-patterns/" target="_blank" rel="noopener">Design Patterns in Dynamic Languages</a>”的演讲中指出，Gamma等人合著的《设计模式：可复用面向对象软件的基础》一书中有23个模式，其中有16个在动态语言中“不见了，或者简化了”（参见第9张幻灯片）。他讨论的是Lisp和Dylan，不过很多相关的动态特性在Python中也能找到。</p><p>——流畅的Python，第6章</p></blockquote><h1 id="设计模式是什么">设计模式是什么</h1><p>设计模式的一般定义如下：</p><p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。</p><a id="more"></a><p>狭义的设计模式是指GoF在《设计模式：可复用面性对象软件的基础》一书中所介绍的23种经典设计模式。不过设计模式并不仅仅只有这23种。</p><p>一般而言，一个模式有四个基本要素：</p><ol type="1"><li>模式名称（pattern name）：通过一两个词来为模式命名，以便我们更好地理解模式并方便开发人员之间交流。</li><li>问题（problem）：描述了应该在何时使用模式，它包含了设计中存在的问题以及问题存在的原因。</li><li>解决方案（solution）：描述了一个设计模式的组成部分，以及这些组成部分之间的相互关系、各自的职责和协作方式，通常解决方案通过UML类图和核心代码进行描述。</li><li>效果（consequences）：描述了模式的优缺点以及在使用模式时应权衡的问题。</li></ol><h1 id="组织编目">组织编目</h1><table><tr><th colspan="2" rowspan="2"></th><th colspan="3">目的</th></tr><tr><th>创建型</th><th>结构型</th><th>行为型</th></tr><tr><th rowspan="2">范围</th><th>类</th><td>工厂方法</td><td>适配器（类）</td><td>解释器<br>模板方法</td></tr><tr><th>对象</th><td>抽象工厂<br>生成器<br>原型<br>单例</td><td>适配器（对象）<br>桥接<br>组成<br>装饰<br>外观<br>享元<br>代理</td><td>职责链<br>命令<br>迭代器<br>中介者<br>观察者<br>状态<br>策略<br>访问者</td></tr></table><p>根据两条准则对模式进行分类。第一是目的准则，即模式是用来完成什么工作的。依据其目的可分为创建型（creational）、结构型（structural）或行为型（behavioral）三种。创建型模式与对象的创建有关；结构型模式处理类或对象的组合；行为型模式对类或对象怎样交互和怎样分配职责进行描述。</p><p>第二准则是范围，指定模式主要是用于类还是用于对象。类模式处理类和子类之间的关系，这些关系通过继承建立，是静态的，在编译时刻便确定下来了。对象模式处理对象间的关系，这些关系在运行时刻是可以变化的，更具动态性。从某种意义上来说，几乎所有模式都适用继承机制，所以”类模式“只指那些集中于处理类间关系的模式，而大部分模式都属于对象模式的范畴。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> design patterns </tag>
            
            <tag> The Art of Design Patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用一等函数实现设计模式</title>
      <link href="/notes/fluent-python/design-patterns-with-first-class-functions/"/>
      <url>/notes/fluent-python/design-patterns-with-first-class-functions/</url>
      
        <content type="html"><![CDATA[<p>虽然设计模式与语言无关，但这并不意味着每一个模式都能在每一门语言中使用。1996年，Peter Norvig在题为“<a href="http://norvig.com/design-patterns/" target="_blank" rel="noopener">Design Patterns in Dynamic Languages</a>”的演讲中指出，Gamma等人合著的《设计模式：可复用面向对象软件的基础》一书中有23个模式，其中有16个在动态语言中“不见了，或者简化了”（参见第9张幻灯片）。他讨论的是Lisp和Dylan，不过很多相关的动态特性在Python中也能找到。</p><p>具体而言，Norvig建议在有一等函数的语言中重新审视策略、命令、模板方法和访问者模式。通常，我们可以把这些模式中涉及的某些类的实例替换成简单的函数，从而减少样板代码。</p><h1 id="重构策略模式">重构策略模式</h1><h2 id="经典的策略模式">经典的策略模式</h2><p>《设计模式：可复用面向对象软件的基础》一书是这样概率策略模式的：定义一系列算法，把它们一一封装起来，并且使它们可以相互替换。本模式使得算法可以独立于使用它的客户而变化。</p><a id="more"></a><p>电商领域有个功能明显可以使用策略模式，根据客户的属性或订单中的商品计算折扣。假如一个网店制定了下述折扣规则。</p><ul><li>有1000或以上积分的顾客，每个订单享5%折扣。</li><li>同一订单中，单个商品的数量达到20个或以上，享10%折扣。</li><li>订单中的不同商品达到10个或以上，享7%折扣。</li></ul><p>简单起见，假定一个订单一次只能享用一个折扣。</p><img data-src="http://www.plantuml.com/plantuml/svg/oyXCILL8pIqegLJ8JSrDIYtYIiv9B2vMy2zAIIrIgEPI08AI_9B470rDC3kbD1N8gkLAJ2ekAKfCBb48AChFpI_9pC-3Agw6oTGgf6GM9-UNvfM0DK2CTGDQbvDPKWdM1TM1HPbJQKwsPqbgBW5bFeb5wQbWb-9K2F57lYx2dLm85zlKwEgYEWbT4iKXw99erdFbvPUaAYWzsT7rP4VtisdjIWg9nGfvXb3XvskdFP-w529c11LxshhzoTx9o3B6N7c62df5cUaP9NgGEE3ACrBGoqbD0_8HNa0DHZqza4RKC8E8eGSGM1G0"><p>上下文：把一些计算委托给实现不同算法的可互换组建，它提供服务。在这个电商示例中，上下文是Order，它会根据不同的算法计算促销折扣。</p><p>策略：实现不同算法的组件共同的接口。</p><p>具体策略：策略的具体子类。</p><p>按照《设计模式：可复用面向对象软件的基础》一书的说明，具体策略由上下文类的客户选择。在这个示例中，实例化订单之前，系统会以某种方式选择一种促销折扣策略，然后把它传给Order构造方法。具体怎么选择策略，不在这个模式的职责范围内。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Customer = namedtuple(<span class="string">'Customer'</span>, <span class="string">'name fidelity'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, product, quantity, price)</span>:</span></span><br><span class="line">        self.product = product</span><br><span class="line">        self.quantity = quantity</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.price * self.quantity</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span>  <span class="comment"># 上下文</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, customer, cart, promotion=None)</span>:</span></span><br><span class="line">        self.customer = customer</span><br><span class="line">        self.cart = list(cart)</span><br><span class="line">        self.promotion = promotion</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">'__total'</span>):</span><br><span class="line">            self.__total = sum(item.total() <span class="keyword">for</span> item <span class="keyword">in</span> self.cart)</span><br><span class="line">        <span class="keyword">return</span> self.__total</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">due</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.promotion <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            discount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            discount = self.promotion.discount(self)</span><br><span class="line">        <span class="keyword">return</span> self.total() - discount</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        fmt = <span class="string">'&lt;Order total: &#123;:.2f&#125; due: &#123;:.2f&#125;&gt;'</span></span><br><span class="line">        <span class="keyword">return</span> fmt.format(self.total(), self.due())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promotion</span><span class="params">(ABC)</span>:</span>  <span class="comment"># 策略:抽象基类</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">discount</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="string">"""返回折扣金额(正值)"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FidelityPromo</span><span class="params">(Promotion)</span>:</span>  <span class="comment"># 第一个具体策略</span></span><br><span class="line">    <span class="string">"""为积分为1000或以上的顾客提供5%折扣"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">discount</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> order.total() * <span class="number">.05</span> <span class="keyword">if</span> order.customer.fidelity &gt;= <span class="number">1000</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BulkItemPromo</span><span class="params">(Promotion)</span>:</span>  <span class="comment"># 第二个具体策略</span></span><br><span class="line">    <span class="string">"""单个商品为20个或以上时提供10%折扣"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">discount</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        discount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> order.cart:</span><br><span class="line">            <span class="keyword">if</span> item.quantity &gt;= <span class="number">20</span>:</span><br><span class="line">                discount += item.total() * <span class="number">.1</span></span><br><span class="line">        <span class="keyword">return</span> discount</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LargeOrderPromo</span><span class="params">(Promotion)</span>:</span>  <span class="comment"># 第三个具体策略</span></span><br><span class="line">    <span class="string">"""订单中的不同商品达到10个或以上时提供7%折扣"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">discount</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        distinct_items = &#123;item.product <span class="keyword">for</span> item <span class="keyword">in</span> order.cart&#125;</span><br><span class="line">        <span class="keyword">if</span> len(distinct_items) &gt;= <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> order.total() * <span class="number">.07</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>Promotion定义为抽象基类（Abstract Base Class, ABC），这么做是为了使用@abstractmethod装饰器，从而明确表明所用的模式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>joe = Customer(<span class="string">'John Doe'</span>, <span class="number">0</span>)  <span class="comment"># joe积分为0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ann = Customer(<span class="string">'Ann Smith'</span>, <span class="number">1100</span>)  <span class="comment"># ann积分1100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cart = [LineItem(<span class="string">'banana'</span>, <span class="number">4</span>, <span class="number">.5</span>),</span><br><span class="line"><span class="meta">... </span>        LineItem(<span class="string">'apple'</span>, <span class="number">10</span>, <span class="number">1.5</span>),</span><br><span class="line"><span class="meta">... </span>        LineItem(<span class="string">'watermellon'</span>, <span class="number">5</span>, <span class="number">5.0</span>)]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(joe, cart, FidelityPromo())  <span class="comment"># joe不享折扣</span></span><br><span class="line">&lt;Order total: <span class="number">42.00</span> due: <span class="number">42.00</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(ann, cart, FidelityPromo())  <span class="comment"># ann享有5%积分折扣</span></span><br><span class="line">&lt;Order total: <span class="number">42.00</span> due: <span class="number">39.90</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>banana_cart = [LineItem(<span class="string">'banana'</span>, <span class="number">30</span>, <span class="number">.5</span>),</span><br><span class="line"><span class="meta">... </span>               LineItem(<span class="string">'apple'</span>, <span class="number">10</span>, <span class="number">1.5</span>)]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(joe, banana_cart, BulkItemPromo())  <span class="comment"># 香蕉个数超过20个，香蕉享10%折扣</span></span><br><span class="line">&lt;Order total: <span class="number">30.00</span> due: <span class="number">28.50</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>long_order = [LineItem(str(item_code), <span class="number">1</span>, <span class="number">1.0</span>) <span class="keyword">for</span> item_code <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(joe, long_order, LargeOrderPromo())  <span class="comment"># long_order不同商品达到10个，享7%折扣</span></span><br><span class="line">&lt;Order total: <span class="number">10.00</span> due: <span class="number">9.30</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(joe, cart, LargeOrderPromo())  <span class="comment"># cart不同商品有3个，不能享折扣</span></span><br><span class="line">&lt;Order total: <span class="number">42.00</span> due: <span class="number">42.00</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="使用函数实现策略模式">使用函数实现策略模式</h2><p>在上述示例中，每个具体策略都是一个类，而且都只定义了一个方法，即discount。此外，策略实例没有状态（没有实例属性）。它们看起来像是普通的函数——的确如此。下面是对示例的重构，把具体策略换成了简单的函数，而且去掉了Promo抽象类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Customer = namedtuple(<span class="string">'Customer'</span>, <span class="string">'name fidelity'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, product, quantity, price)</span>:</span></span><br><span class="line">        self.product = product</span><br><span class="line">        self.quantity = quantity</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.price * self.quantity</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span>  <span class="comment"># 上下文</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, customer, cart, promotion=None)</span>:</span></span><br><span class="line">        self.customer = customer</span><br><span class="line">        self.cart = list(cart)</span><br><span class="line">        self.promotion = promotion</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">'__total'</span>):</span><br><span class="line">            self.__total = sum(item.total() <span class="keyword">for</span> item <span class="keyword">in</span> self.cart)</span><br><span class="line">        <span class="keyword">return</span> self.__total</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">due</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.promotion <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            discount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            discount = self.promotion(self)  <span class="comment"># 计算折扣只需调用self.promotion()函数</span></span><br><span class="line">        <span class="keyword">return</span> self.total() - discount</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        fmt = <span class="string">'&lt;Order total: &#123;:.2f&#125; due: &#123;:.2f&#125;&gt;'</span></span><br><span class="line">        <span class="keyword">return</span> fmt.format(self.total(), self.due())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 无抽象类</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fidelity_promo</span><span class="params">(order)</span>:</span>  <span class="comment"># 各个策略都是函数</span></span><br><span class="line">    <span class="string">"""为积分为1000或以上的顾客提供5%折扣"""</span></span><br><span class="line">    <span class="keyword">return</span> order.total() * <span class="number">.05</span> <span class="keyword">if</span> order.customer.fidelity &gt;= <span class="number">1000</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bulk_item_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""单个商品为20个或以上时提供10%折扣"""</span></span><br><span class="line">    discount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> order.cart:</span><br><span class="line">        <span class="keyword">if</span> item.quantity &gt;= <span class="number">20</span>:</span><br><span class="line">            discount += item.total() * <span class="number">.1</span></span><br><span class="line">    <span class="keyword">return</span> discount</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">large_order_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""订单中的不同商品达到10个或以上时提供7%折扣"""</span></span><br><span class="line">    distinct_items = &#123;item.product <span class="keyword">for</span> item <span class="keyword">in</span> order.cart&#125;</span><br><span class="line">    <span class="keyword">if</span> len(distinct_items) &gt;= <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">return</span> order.total() * <span class="number">.07</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>新的Order类使用起来更简单。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>joe = Customer(<span class="string">'John Doe'</span>, <span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ann = Customer(<span class="string">'Ann Smith'</span>, <span class="number">1100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cart = [LineItem(<span class="string">'banana'</span>, <span class="number">4</span>, <span class="number">.5</span>),</span><br><span class="line"><span class="meta">... </span>        LineItem(<span class="string">'apple'</span>, <span class="number">10</span>, <span class="number">1.5</span>),</span><br><span class="line"><span class="meta">... </span>        LineItem(<span class="string">'watermellon'</span>, <span class="number">5</span>, <span class="number">5.0</span>)]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(joe, cart, fidelity_promo)  <span class="comment"># 没必要实例化对象，把函数作为参数传入</span></span><br><span class="line">&lt;Order total: <span class="number">42.00</span> due: <span class="number">42.00</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(ann, cart, fidelity_promo)</span><br><span class="line">&lt;Order total: <span class="number">42.00</span> due: <span class="number">39.90</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>banana_cart = [LineItem(<span class="string">'banana'</span>, <span class="number">30</span>, <span class="number">.5</span>),</span><br><span class="line"><span class="meta">... </span>               LineItem(<span class="string">'apple'</span>, <span class="number">10</span>, <span class="number">1.5</span>)]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(joe, banana_cart, bulk_item_promo)</span><br><span class="line">&lt;Order total: <span class="number">30.00</span> due: <span class="number">28.50</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>long_order = [LineItem(str(item_code), <span class="number">1</span>, <span class="number">1.0</span>) <span class="keyword">for</span> item_code <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(joe, long_order, large_order_promo)</span><br><span class="line">&lt;Order total: <span class="number">10.00</span> due: <span class="number">9.30</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(joe, cart, large_order_promo)</span><br><span class="line">&lt;Order total: <span class="number">42.00</span> due: <span class="number">42.00</span>&gt;</span><br></pre></td></tr></table></figure><p>至此，我们使用函数实现了策略模式，由此也出现了其他可能性。假设我们想创建一个“元策略”，让它为指定的订单选择最佳折扣。</p><h2 id="选择最佳策略简单的方式">选择最佳策略：简单的方式</h2><p>best_promo函数的实现特别简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">promos = [fidelity_promo, bulk_item_promo, large_order_promo]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""选择可用的最佳折扣"""</span></span><br><span class="line">    <span class="keyword">return</span> max(promo(order) <span class="keyword">for</span> promo <span class="keyword">in</span> promos)  <span class="comment"># 返回折扣额度最大的那个</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(joe, long_order, best_promo)  <span class="comment"># 订购多种商品时，选择larger_order_promo</span></span><br><span class="line">&lt;Order total: <span class="number">10.00</span> due: <span class="number">9.30</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(joe, banana_cart, best_promo)  <span class="comment"># 订购大量香蕉时，选择bulk_item_promo</span></span><br><span class="line">&lt;Order total: <span class="number">30.00</span> due: <span class="number">28.50</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Order(ann, cart, best_promo)  <span class="comment"># 为忠实顾客ann提供fidelity_promo优惠的折扣</span></span><br><span class="line">&lt;Order total: <span class="number">42.00</span> due: <span class="number">39.90</span>&gt;</span><br></pre></td></tr></table></figure><p>虽然上述示例可用，而且易读，但是有些重复可能会导致不易察觉的缺陷：若想添加新的促销策略，要定义相应的函数，还要记得把它添加到promos列表中；否则，当新促销函数显式地作为参数传给Order时，它是可用的，但是best_promo不会考虑它。继续往下读，了解这个问题的几种解决方案。</p><h2 id="找出模块中的全部策略">找出模块中的全部策略</h2><p>在Python中，模块也是一等对象，而且标准库提供了几个处理模块的函数。</p><blockquote><p><code>globals()</code></p><p>返回一个字典，表示当前的全局符号表。这个符号表始终针对当前模块（对函数或方法来说，是指定义它们的模块，而不是调用它们的模块）。</p></blockquote><p>示例：使用globals函数帮助best_promo自动找到其他可用的*_promo函数，过程优点曲折。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">promos = [globals()[name] <span class="keyword">for</span> name <span class="keyword">in</span> globals()</span><br><span class="line">          <span class="keyword">if</span> name.endswith(<span class="string">'_promo'</span>)</span><br><span class="line">          <span class="keyword">and</span> name != <span class="string">'best_promo'</span>]  <span class="comment"># 过滤掉best_promo自身，防止无限递归</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""选择可用的最佳折扣"""</span></span><br><span class="line">    <span class="keyword">return</span> max(promo(order) <span class="keyword">for</span> promo <span class="keyword">in</span> promos)</span><br></pre></td></tr></table></figure><p>收集所有可用促销的另一种方法是，在一个单独的模块中保存所有策略函数，把best_promo排除在外。</p><figure class="highlight python"><figcaption><span>promotions.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fidelity_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""为积分为1000或以上的顾客提供5%折扣"""</span></span><br><span class="line">    <span class="keyword">return</span> order.total() * <span class="number">.05</span> <span class="keyword">if</span> order.customer.fidelity &gt;= <span class="number">1000</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bulk_item_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""单个商品为20个或以上时提供10%折扣"""</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">large_order_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""订单中的不同商品达到10个或以上时提供7%折扣"""</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> promotions</span><br><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">promos = [func <span class="keyword">for</span> name, func <span class="keyword">in</span> inspect.getmembers(promotions, inspect.isfunction)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""选择可用的最佳折扣"""</span></span><br><span class="line">    <span class="keyword">return</span> max(promo(order) <span class="keyword">for</span> promo <span class="keyword">in</span> promos)</span><br></pre></td></tr></table></figure><p>不管怎么命名策略函数，上述示例都可用。唯一重要的是，promotions模块只能包含计算订单折扣的函数。如果有人在promotions模块中使用不同的签名定义函数，那么best_promo函数尝试将其应用到订单上时会出错。可以添加更为严格的测试，审查传给实例的参数，进一步过滤函数。上述示例的目的不是提供完善的方案，而是强调模块内省的一种用途。</p><p>动态收集促销折扣函数更为显式的一种方案是使用简单的装饰器。</p><h1 id="命令模式">命令模式</h1><p>命令设计模式也可以通过把函数作为参数传递而简化。</p><img data-src="http://www.plantuml.com/plantuml/svg/XPB1IiD054NtynMFhdIHG6kpAuBejkXUHAR9mmvqPa9c0fLQ4AJWIX3x1Q8W2EhABgH_KzD-Xed9n9cuw2plE-zov_A6B4907kjBuCW7c91mH9M2WpWUiP1g9aMbz56aX0wKJcYeuL1oJaK44mBvcnXz2ZZ6CDMuiqkcrU9nZCB5_pCdL6dS1lLfcCXjq94CKuv2Lm0J2XDzhd6iVo6pthloF3kPEx3Zk1Cx0x5AWfvhLxG5qZCz4UU3dhTVvoH_edJTxTwyqo6B8XHd2RiOwaP0rxj1EfP2QeJMzzjZThjOlxwtW2eGxKhUVDoivo-RwrafTmnzlrnzFPNQNgLbTy_P_BD6kmQTBLRB1tiX8A8Dlk-Sa-Y0NrwJoUmNpdQP-KPXsiqdTKzs7SKySFzTIiw9b59z4CrcHF03"><p>菜单驱动的文本编辑器的UML类图，使用命令设计模式实现。各个命令可以有不同的接收者（实现操作的对象）。对PasteCommand来说，接收者是Document。对OpenCommand来说，接收者是应用程序。</p><p>命令模式的目的是解耦调用操作对象（调用者）和提供实现的对象（接收者）。这个模式的做法是，在二者之间放一个Command对象，让它实现只有一个方法（execute）的接口，调用接收者中的方法执行所需的操作。这样，调用者无需了解接收者的接口，而且不同的接收者可以适应不同的Command子类。调用者有一个具体的命令，通过调用execute方法执行。MacroCommand可能保存一系列命令，它的execute()方法会在各个命令上调用相同的方法。</p><p>我们可以不为调用者提供一个Command实例，而是给它一个函数。此时，调用者不用调用command.execute()，直接调用command()即可。MacroCommand可以实现成定义了<code>__call__</code>方法的类。这样，MacroCommand的实例就是可调用对象，各自维护着一个函数列表，供以后调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MacroCommand</span>:</span></span><br><span class="line">    <span class="string">"""一个执行一组命令的命令"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, commands)</span>:</span></span><br><span class="line">        self.commands = list(commands)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> command <span class="keyword">in</span> self.commands:</span><br><span class="line">            command()</span><br></pre></td></tr></table></figure><p>使用一等函数对命令模式的重新审视到此结束。站在一定高度上看，这里采用的方式与策略模式所用的类似：<strong>把实现单方法接口的类的实例替换成可调用对象</strong>。毕竟，每个Python可调用对象都实现了单方法接口，这个方法就是<code>__call__</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> command </tag>
            
            <tag> first-class functions </tag>
            
            <tag> design patterns </tag>
            
            <tag> strategy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>networkx all simple paths</title>
      <link href="/source-code/networkx-all-simple-paths/"/>
      <url>/source-code/networkx-all-simple-paths/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># source: single node</span></span><br><span class="line"><span class="comment"># targets: set of nodes</span></span><br><span class="line"><span class="comment"># cutoff: maximum edges in a path</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_all_simple_paths_graph</span><span class="params">(G, source, targets, cutoff)</span>:</span></span><br><span class="line">    <span class="comment"># using OrderedDict to save visited nodes and the order of those nodes</span></span><br><span class="line">    visited = collections.OrderedDict.fromkeys([source])</span><br><span class="line">    stack = [iter(G[source])]  <span class="comment"># G[node] returns adjacent nodes and edge attrs</span></span><br><span class="line">    <span class="keyword">while</span> stack:  <span class="comment"># for a list, bool(a_list) == True when len(a_list) &gt; 0</span></span><br><span class="line">        children = stack[<span class="number">-1</span>]</span><br><span class="line">        child = next(children, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> child <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            stack.pop()</span><br><span class="line">            visited.popitem()</span><br><span class="line">        <span class="keyword">elif</span> len(visited) &lt; cutoff:</span><br><span class="line">            <span class="keyword">if</span> child <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> child <span class="keyword">in</span> targets:</span><br><span class="line">                <span class="keyword">yield</span> list(visited) + [child]</span><br><span class="line">            visited[child] = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> targets - set(visited.keys()):  <span class="comment"># expand stack until find all targets</span></span><br><span class="line">                stack.append(iter(G[child]))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                visited.popitem()  <span class="comment"># maybe other ways to child</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># len(visited) == cutoff:</span></span><br><span class="line">            <span class="comment"># set(children) | &#123;child&#125;: all nodes in the stack[-1]</span></span><br><span class="line">            <span class="keyword">for</span> target <span class="keyword">in</span> (targets &amp; (set(children) | &#123;child&#125;)) - set(visited.keys()):</span><br><span class="line">                <span class="keyword">yield</span> list(visited) + [target]</span><br><span class="line">            stack.pop()</span><br><span class="line">            visited.popitem()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_all_simple_paths_multigraph</span><span class="params">(G, source, targets, cutoff)</span>:</span></span><br><span class="line">    visited = collections.OrderedDict.fromkeys([source])</span><br><span class="line">    stack = [(v <span class="keyword">for</span> u, v <span class="keyword">in</span> G.edges(source))]  <span class="comment"># G.edges(u) returns all edges from u</span></span><br><span class="line">    <span class="comment"># so when there exsit multi-edges between u and v, the v can also appear repeatedly</span></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        children = stack[<span class="number">-1</span>]</span><br><span class="line">        child = next(children, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> child <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            stack.pop()</span><br><span class="line">            visited.popitem()</span><br><span class="line">        <span class="keyword">elif</span> len(visited) &lt; cutoff:</span><br><span class="line">            <span class="keyword">if</span> child <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> child <span class="keyword">in</span> targets:</span><br><span class="line">                <span class="keyword">yield</span> list(visited) + [child]</span><br><span class="line">            visited[child] = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> targets - set(visited.keys()):</span><br><span class="line">                stack.append((v <span class="keyword">for</span> u, v <span class="keyword">in</span> G.edges(child)))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                visited.popitem()</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># len(visited) == cutoff:</span></span><br><span class="line">            <span class="keyword">for</span> target <span class="keyword">in</span> targets - set(visited.keys()):</span><br><span class="line">                count = ([child] + list(children)).count(target)</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">                    <span class="keyword">yield</span> list(visited) + [target]</span><br><span class="line">            stack.pop()</span><br><span class="line">            visited.popitem()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithms </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python repr方法</title>
      <link href="/programming/python-repr-method/"/>
      <url>/programming/python-repr-method/</url>
      
        <content type="html"><![CDATA[<h1 id="repr">repr</h1><blockquote><p><a href="https://devdocs.io/python~3.6/library/functions#repr" target="_blank" rel="noopener"><code>repr(object)</code></a></p><p>Return a string containing a printable representation of an object. For many types, this function makes an attempt to return a string that would yield an object with the same value when passed to eval(), otherwise the representation is a string enclosed in angle brackets that contains the name of the type of the object together with additional information often including the name and address of the object.</p></blockquote><p>repr的返回结果大致有两种类型：</p><ul><li>返回一个字符串，这个字符串所代表的代码与原对象相同，即<code>eval(repr(object) == object</code>。</li><li>返回一组尖括号，括号内包含了对象的名称和地址。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Student = namedtuple(<span class="string">'Student'</span>, <span class="string">'id name gender'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>alice = Student(<span class="number">1</span>, <span class="string">'Alice'</span>, <span class="string">'female'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>alice</span><br><span class="line">Student(id=<span class="number">1</span>, name=<span class="string">'Alice'</span>, gender=<span class="string">'female'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval(repr(alice)) == alice</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, id, name, gender)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.id, self.name, self.gender = id, name, gender</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john = Person(<span class="number">2</span>, <span class="string">'John'</span>, <span class="string">'male'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john</span><br><span class="line">&lt;__main__.Person object at <span class="number">0x10bf970b8</span>&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="自定义返回值">自定义返回值</h1><p>自定义返回值只需实现<code>__repr__</code>方法。可以看到默认的输出是第二种，想实现类似第一种可以像下面这样做。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="string">"%s(%s)"</span> % (self.__class__.__name__, <span class="string">', '</span>.join(<span class="string">'%s=%r'</span> % (k, v) <span class="keyword">for</span> k, v <span class="keyword">in</span> self.__dict__.items()))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Person.__repr__ = func</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john</span><br><span class="line">Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval(repr(john)) == john</span><br><span class="line"><span class="literal">False</span>  <span class="comment"># 不相等是因为没有定义__eq__</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval(repr(john))   <span class="comment"># 但内容是相同的</span></span><br><span class="line">Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>)</span><br></pre></td></tr></table></figure><p>优点：对简单类通用。</p><p>缺点：可能会输出不希望被看到的私有属性。如果内部变量有循环引用的话会陷入无限递归。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>marry = Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john = Person(<span class="number">2</span>, <span class="string">'John'</span>, <span class="string">'male'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>marry._sepouse = john  <span class="comment"># 不想被看到的信息</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>marry</span><br><span class="line">Person(id=<span class="number">3</span>, name=<span class="string">'Marry'</span>, gender=<span class="string">'female'</span>, _sepouse=Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john._sepouse = marry  <span class="comment"># 互相引用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john  <span class="comment"># 无限递归</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> func</span><br><span class="line">  ...  <span class="comment"># 省略</span></span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;genexpr&gt;</span><br><span class="line">RecursionError: maximum recursion depth exceeded</span><br></pre></td></tr></table></figure><h1 id="隐藏私有属性">隐藏私有属性</h1><p>常用做法：指定传入的字典即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, id, name, gender)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.id, self.name, self.gender = id, name, gender</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">"%s(%s)"</span> % (self.__class__.__name__, <span class="string">', '</span>.join(<span class="string">'%s=%r'</span> % (k, v) <span class="keyword">for</span> k, v <span class="keyword">in</span> self.get_params().items()))</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">get_params</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> dict(id=self.id, name=self.name, gender=self.gender)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>)</span><br><span class="line">Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john = Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>marry = Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john._sepouse = marry</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>marry._sepouse = john</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john</span><br><span class="line">Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>marry</span><br><span class="line">Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>)</span><br></pre></td></tr></table></figure><h1 id="避免无限递归">避免无限递归</h1><p>reprlib提供了一个装饰器，能检测递归调用，并用指定的字符代替调用。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/reprlib#reprlib.recursive_repr" target="_blank" rel="noopener"><code>@reprlib.recursive_repr(fillvalue=&quot;...&quot;)</code></a></p><p>Decorator for <code>__repr__()</code> methods to detect recursive calls within the same thread. If a recursive call is made, the fillvalue is returned, otherwise, the usual <code>__repr__()</code> call is made.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, id, name, gender)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.id, self.name, self.gender = id, name, gender</span><br><span class="line"><span class="meta">... </span>    @reprlib.recursive_repr()  <span class="comment"># 因为装饰器有参数，所以必须加上()</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">'%s(%s)'</span> % (type(self).__name__, <span class="string">', '</span>.join(<span class="string">'%s=%r'</span> % (k, v) <span class="keyword">for</span> k, v <span class="keyword">in</span> self.__dict__.items()))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>marry = Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john = Person(<span class="number">2</span>, <span class="string">'John'</span>, <span class="string">'male'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>marry</span><br><span class="line">Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>)  <span class="comment"># 无递归调用时</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>marry._sepouse = john</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john._sepouse = marry  <span class="comment"># 有递归调用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>marry</span><br><span class="line">Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>, _sepouse=Person(id=<span class="number">2</span>, name=<span class="string">'John'</span>, gender=<span class="string">'male'</span>, _sepouse=...))</span><br></pre></td></tr></table></figure><h1 id="规避过长的描述">规避过长的描述</h1><p><code>repr()</code>函数的目的是方便程序员检查、调试程序。如果对象的属性中包含过长的列表、字符串等属性，朴素的<code>repr()</code>函数会打印全部内容。其结果会在控制台或日志文件中占据大量篇幅，与初衷相悖。此时推荐的做法是输出其简略的字符串表示形式。万幸，我们无需重复造轮子，也不一定造地好。<code>reprlib.repr()</code>函数能帮我们达到预期的结果。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/reprlib#reprlib.repr" target="_blank" rel="noopener"><code>reprlib.repr(obj)</code></a></p><p>This is the repr() method of aRepr. It returns a string similar to that returned by the built-in function of the same name, but with limits on most sizes.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array(range(<span class="number">10000</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a  <span class="comment"># numpy就做了类似处理</span></span><br><span class="line">array([   <span class="number">0</span>,    <span class="number">1</span>,    <span class="number">2</span>, ..., <span class="number">9997</span>, <span class="number">9998</span>, <span class="number">9999</span>])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> reprlib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = list(range(<span class="number">10000</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reprlib.repr(b)</span><br><span class="line"><span class="string">'[0, 1, 2, 3, 4, 5, ...]'</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> reprlib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Text</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, content)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.content = content</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">'Text(%s)'</span> % reprlib.repr(self.content)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = Text(<span class="string">'The beginning to learn a programming language is to print "Hello World!"'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">Text(<span class="string">'The beginnin...Hello World!"'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> repr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一等函数</title>
      <link href="/notes/fluent-python/first-class-functions/"/>
      <url>/notes/fluent-python/first-class-functions/</url>
      
        <content type="html"><![CDATA[<h1 id="把函数试作对象">把函数试作对象</h1><p>在Python中，整数、字符串、字典和函数都是一等对象。“一等对象”为满足下述条件的过程实体：</p><ul><li>在运行时创建</li><li>能赋值给变量或数据结构中的元素</li><li>能作为参数传给函数</li><li>能作为函数的返回结果</li></ul><p>人们经常将“把函数视作一等对象”简称为“一等函数”。这样说并不完美，似乎表明这是函数中的特殊群体。在Python中，所有函数都是一等对象。</p><a id="more"></a><h1 id="高阶函数">高阶函数</h1><p>接受函数为参数，或者把函数作为结果返回的函数都是高阶函数（higher-order function）。使用高阶函数是函数式编程的特点之一。常见的高阶函数有max, min, sorted, map, filter, reduce。</p><p>max, min, sorted中的key参数接受函数，任何单参数函数都能作为key参数的值。例如，想根据单词长度排序时，只需把len函数传入。若想创建押韵词典（水果中的各类浆果*berry都排在一起），可以把各个单词反过来拼写，然后排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits = [<span class="string">'strawberry'</span>, <span class="string">'fig'</span>, <span class="string">'apple'</span>, <span class="string">'cherry'</span>, <span class="string">'raspberry'</span>, <span class="string">'banana'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(fruits, key=len)</span><br><span class="line">[<span class="string">'fig'</span>, <span class="string">'apple'</span>, <span class="string">'cherry'</span>, <span class="string">'banana'</span>, <span class="string">'raspberry'</span>, <span class="string">'strawberry'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(fruits, key=<span class="keyword">lambda</span> i: i[::<span class="number">-1</span>])</span><br><span class="line">[<span class="string">'banana'</span>, <span class="string">'apple'</span>, <span class="string">'fig'</span>, <span class="string">'raspberry'</span>, <span class="string">'strawberry'</span>, <span class="string">'cherry'</span>]</span><br></pre></td></tr></table></figure><p>map, filter, reduce在多数使用场景下都有更好的替代品。</p><h2 id="mapfilter和reduce的替代品">map、filter和reduce的替代品</h2><p>在Python3中，map和filter返回生成器（一种迭代器），因此它们的直接替代品是生成器表达式（在Python2中，这两个函数返回列表，因此最接近的替代品是列表推导）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">"""Returns n!"""</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> n * fact(n - <span class="number">1</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(fact, range(<span class="number">6</span>))</span><br><span class="line">&lt;map object at <span class="number">0x10c597f98</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(fact(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">6</span>))</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x10c58b780</span>&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(fact, range(<span class="number">6</span>)))</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[fact(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">6</span>)]</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(fact, filter(<span class="keyword">lambda</span> n: n % <span class="number">2</span>, range(<span class="number">6</span>))))</span><br><span class="line">[<span class="number">1</span>, <span class="number">6</span>, <span class="number">120</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[fact(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">6</span>) <span class="keyword">if</span> n % <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">6</span>, <span class="number">120</span>]</span><br></pre></td></tr></table></figure><p>reduce这个函数最常用于求和，可使用sum函数替代，在可读性和性能方面，这是一项重大改善。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> add</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(add, range(<span class="number">100</span>))</span><br><span class="line"><span class="number">4950</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum(range(<span class="number">100</span>))</span><br><span class="line"><span class="number">4950</span></span><br></pre></td></tr></table></figure><h2 id="归约函数">归约函数</h2><p>sum和reduce的通用思想是把某个操作连续应用到序列的元素上，累计之前的结果，把一系列值归约成一个值。all和any也是内置的归约函数。</p><blockquote><p><code>all(iterable)</code></p></blockquote><p>如果iterable的每个元素都是真值，返回True；all([])返回True。</p><blockquote><p><code>any(iterable)</code></p></blockquote><p>只要iterable中有元素是真值，就返回True；any([])返回False。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>all([])</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>any([])</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>any([<span class="number">1</span>])</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>all([<span class="number">1</span>])</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h1 id="匿名函数">匿名函数</h1><p>lambda关键字在Python表达式内创建匿名函数。然而，Python简单的句法限制了lambda函数的定义体只能使用纯表达式。换句话说，lambda函数的定义体中不能赋值，也不能使用while和try等Python语句。</p><p>如果使用lambda表达式导致一段代码难以理解，Fredrik Lundh建议像下面这样重构。</p><p>（1）编写注释，说明lambda表达式的作用。</p><p>（2）研究一会注释，并找出一个名称来概括注释。</p><p>（3）把lambda表达式转换成def语句，使用那个名称来定义函数。</p><p>（4）删除注释。</p><p>与def语句一样，lambda表达式会创建函数对象。这是Python中几种可调用对象的一种。</p><h1 id="可调用对象">可调用对象</h1><p>除了用户定义的函数，调用运算符，即 ()，还可以应用到其他对象上。如果想判断对象能否调用，可以使用内置的callable函数。Python数据模型文档列出了7种可调用对象。</p><ul><li>用户定义的函数：使用def语句或lambda表达式创建。</li><li>内置函数：使用C语言（CPython）实现的函数，如len或time.strftime。</li><li>内置方法：使用C语言实现的方法，如dict.get。</li><li>方法：在类的定义体中定义的函数。</li><li>类：调用类时会运行类的<code>__new__</code>方法创建一个实例，然后运行<code>__init__</code>方法，初始化实例，最后把实例返回给调用方。因为Python没有new运算符，所以调用类相当于调用函数。</li><li>类的实例：如果类定义了<code>__call__</code>方法，那么它的实例可以作为函数调用。</li><li>生成器函数：使用yield关键字的函数或方法。调用生成器函数返回的是生成器对象。生成器函数在很多方面与其他可调用对象不同。</li></ul><p>Python中有各种各样可调用的类型，因此判断对象能否调用，最安全的方法是使用内置的callable函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>abs, str, <span class="number">1</span></span><br><span class="line">(&lt;built-in function abs&gt;, &lt;class 'str'&gt;, 1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[callable(obj) <span class="keyword">for</span> obj <span class="keyword">in</span> (abs, str, <span class="number">1</span>)]</span><br><span class="line">[<span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">False</span>]</span><br></pre></td></tr></table></figure><h1 id="函数内省">函数内省</h1><p>函数对象有很多属性。使用dir函数可以探知fact具有以下属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(fact)</span><br><span class="line">[<span class="string">'__annotations__'</span>, <span class="string">'__call__'</span>, <span class="string">'__class__'</span>, <span class="string">'__closure__'</span>, <span class="string">'__code__'</span>, <span class="string">'__defaults__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__get__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__globals__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__kwdefaults__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__module__'</span>, <span class="string">'__name__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__qualname__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>]</span><br></pre></td></tr></table></figure><p>其中大多数属性是Python对象共有的。</p><p>与用户定义的常规类一样，函数使用<code>__dict__</code>属性存储赋予它的用户属性。一般来说，为函数随意赋予属性不是很常见的做法。</p><p>下面重点说明函数专有而用户定义的一般对象没有的属性。计算两个属性集合的差集便能得到函数专有属性列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = C()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span> <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(set(dir(func)) - set(dir(obj)))</span><br><span class="line">[<span class="string">'__annotations__'</span>, <span class="string">'__call__'</span>, <span class="string">'__closure__'</span>, <span class="string">'__code__'</span>, <span class="string">'__defaults__'</span>, <span class="string">'__get__'</span>, <span class="string">'__globals__'</span>, <span class="string">'__kwdefaults__'</span>, <span class="string">'__name__'</span>, <span class="string">'__qualname__'</span>]</span><br></pre></td></tr></table></figure><table><thead><tr class="header"><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>__annotations__</code></td><td>dict</td><td>参数和返回值的注解</td></tr><tr class="even"><td><code>__call__</code></td><td>method-wrapper</td><td>实现()运算符：即可调用对象协议</td></tr><tr class="odd"><td><code>__closure__</code></td><td>tuple</td><td>函数闭包，即自由变量的绑定（通常是None）</td></tr><tr class="even"><td><code>__code__</code></td><td>code</td><td>编译成字节码的函数元数据和函数定义体</td></tr><tr class="odd"><td><code>__defaults__</code></td><td>tuple</td><td>形式参数的默认值</td></tr><tr class="even"><td><code>__get__</code></td><td>method-wrapper</td><td>实现只读描述符协议</td></tr><tr class="odd"><td><code>__globals__</code></td><td>dict</td><td>函数所在模块中的全局变量</td></tr><tr class="even"><td><code>__kwdefaults__</code></td><td>dict</td><td>仅限关键字形式参数的默认值</td></tr><tr class="odd"><td><code>__name__</code></td><td>str</td><td>函数名称</td></tr><tr class="even"><td><code>__qualname__</code></td><td>str</td><td>函数的限定名称，如Random.choice（<a href="https://www.python.org/dev/peps/pep-3155/" target="_blank" rel="noopener">参阅PEP 3155</a>）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> first-class functions </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从定位参数到仅限关键字参数</title>
      <link href="/notes/fluent-python/from-positional-to-keyword-only-parameters/"/>
      <url>/notes/fluent-python/from-positional-to-keyword-only-parameters/</url>
      
        <content type="html"><![CDATA[<h1 id="从定位参数到仅限关键字参数">从定位参数到仅限关键字参数</h1><p>Python最好的特性之一是提供了极为灵活的参数处理机制，而且Python3进一步提供了仅限关键字参数（keyword-only argument）。与之密切相关的是，调用函数时使用*和**“展开”可迭代对象，映射到单个参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tag</span><span class="params">(name, *content, cls=None, **attrs)</span>:</span></span><br><span class="line">    <span class="string">"""生成一个或多个HTML标签"""</span></span><br><span class="line">    <span class="keyword">if</span> cls <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        attrs[<span class="string">'class'</span>] = cls</span><br><span class="line">    <span class="keyword">if</span> attrs:</span><br><span class="line">        attr_str = <span class="string">''</span>.join(<span class="string">' %s="%s"'</span> % (attr, value)</span><br><span class="line">            <span class="keyword">for</span> attr, value <span class="keyword">in</span> sorted(attrs.items()))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        attr_str = <span class="string">''</span></span><br><span class="line">    <span class="keyword">if</span> content:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'\n'</span>.join(<span class="string">'&lt;%s%s&gt;%s&lt;/%s&gt;'</span> %</span><br><span class="line">            (name, attr_str, c, name) <span class="keyword">for</span> c <span class="keyword">in</span> content)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;%s%s /&gt;'</span> % (name, attr_str)</span><br></pre></td></tr></table></figure><a id="more"></a><p>tag函数的调用方式很多</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag(<span class="string">'br'</span>)  <span class="comment"># A</span></span><br><span class="line"><span class="string">'&lt;br /&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag(<span class="string">'p'</span>, <span class="string">'hello'</span>, <span class="string">'sidebar'</span>)  <span class="comment"># B</span></span><br><span class="line"><span class="string">'&lt;p&gt;hello&lt;/p&gt;\n&lt;p&gt;sidebar&lt;/p&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag(<span class="string">'p'</span>, <span class="string">'hello'</span>, cls=<span class="string">'sidebar'</span>)  <span class="comment"># C</span></span><br><span class="line"><span class="string">'&lt;p class="sidebar"&gt;hello&lt;/p&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_tag = &#123;<span class="string">'name'</span>: <span class="string">'img'</span>, <span class="string">'title'</span>: <span class="string">'Sunset Boulevard'</span>, <span class="string">'src'</span>: <span class="string">'sunset.jpg'</span>, <span class="string">'cls'</span>: <span class="string">'framed'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag(**my_tag)  <span class="comment"># D</span></span><br><span class="line"><span class="string">'&lt;img class="framed" src="sunset.jpg" title="Sunset Boulevard" /&gt;'</span></span><br></pre></td></tr></table></figure><p>A. 传入单个定位参数。</p><p>B. 传入多个定位参数，根据函数定义，第1个参数被传入name，剩余的未命名定位参数被传入content。</p><p>C. cls参数只能通过关键字参数指定，它一定不会捕获未命名的定位参数。（因为cls参数在有<code>*</code>参数的后面（不能放在<code>**</code>参数的后面），若不指定关键字，则编译器无法判断它是该传入content还是该传入cls）</p><p>D. 在my_tag前面加上<code>**</code>，字典中的所有元素作为单个参数传入，同名键会绑定到对应的具名参数上，余下的被<code>**attrs</code>捕获。</p><p>如果不想支持数量不定的定位参数（即<code>*content</code>），但想支持仅限关键字参数，在签名中放一个<code>*</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, *, b)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> a, b</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment"># 强制以关键字传入</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: f() takes <span class="number">1</span> positional argument but <span class="number">2</span> were given</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">1</span>, b=<span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h1 id="获取关于参数的信息">获取关于参数的信息</h1><p>查看<code>__defaultS__</code>、<code>__code__.co_varnames</code>、<code>__code__.co_argcount</code>的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, b=None, *c, d=None, **e)</span>:</span> f, g = <span class="number">0</span>, <span class="number">1</span>; <span class="keyword">return</span> f + g</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__defaults__  <span class="comment"># 形式参数的默认值</span></span><br><span class="line">(<span class="literal">None</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__kwdefaults__  <span class="comment"># 仅限关键字形式参数的默认值</span></span><br><span class="line">&#123;<span class="string">'d'</span>: <span class="literal">None</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__code__.co_varnames  <span class="comment"># 参数名称+函数定义体中创建的局部变量</span></span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'d'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__code__.co_argcount  <span class="comment"># 参数数量（看来不包括带*参数以及在其后面的参数）</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>上述组织方式不友好，我们有更好的模块inspect模块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> inspect <span class="keyword">import</span> signature</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sig = signature(f)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sig</span><br><span class="line">&lt;Signature (a, b=<span class="literal">None</span>, *c, d=<span class="literal">None</span>, **e)&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name, param <span class="keyword">in</span> sig.parameters.items():</span><br><span class="line"><span class="meta">... </span>    print(param.kind, <span class="string">':'</span>, name, <span class="string">'='</span>, param.default)</span><br><span class="line">...</span><br><span class="line">POSITIONAL_OR_KEYWORD : a = &lt;<span class="class"><span class="keyword">class</span> '<span class="title">inspect</span>.<span class="title">_empty</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">POSITIONAL_OR_KEYWORD</span> :</span> b = <span class="literal">None</span></span><br><span class="line">VAR_POSITIONAL : c = &lt;<span class="class"><span class="keyword">class</span> '<span class="title">inspect</span>.<span class="title">_empty</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">KEYWORD_ONLY</span> :</span> d = <span class="literal">None</span></span><br><span class="line">VAR_KEYWORD : e = &lt;<span class="class"><span class="keyword">class</span> '<span class="title">inspect</span>.<span class="title">_empty</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>signature返回一个Signature对象，它有一个parameters属性，这是一个有序映射，把参数名和Parameter对象对应起来。Parameter也有自己的属性。例如name、default、kind、annotation（下一节函数注解中使用此属性获取附加的元数据）。特殊的<code>inspect._empty</code>表示参数没有默认值。kind属性是<code>_ParameterKind</code>类中的5个值之一。</p><ul><li><p>POSITIONAL_OR_KEYWORD：可以通过定位参数和关键字参数传入的形参（多数Python函数的参数属于此类）。</p></li><li><p>VAR_POSITIONAL：定位参数元组。</p></li><li><p>VAR_KEYWORD：关键字参数字典。</p></li><li><p>KEYWORD_ONLY：仅限关键字参数（Python3新增）。</p></li><li><p>POSITIONAL_ONLY：仅限定位参数；目前，Python声明函数的句法不支持，但是有些使用C语言实现且不接受关键字参数的函数（如divmod）支持。</p></li></ul><p>Signature对象有个bind方法，它可以把任意个参数绑定到签名中的形参上，所用的规则与实参到形参的匹配方式一样。框架可以使用这个方法在真正调用函数前验证参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> inspect <span class="keyword">import</span> signature</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sig = signature(tag)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_tag = &#123;<span class="string">'name'</span>: <span class="string">'img'</span>, <span class="string">'title'</span>: <span class="string">'Sunset Boulevard'</span>, <span class="string">'src'</span>: <span class="string">'sunset.jpg'</span>, <span class="string">'cls'</span>: <span class="string">'framed'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bound_args = sig.bind(**my_tag)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bound_args</span><br><span class="line">&lt;BoundArguments (name=<span class="string">'img'</span>, cls=<span class="string">'framed'</span>, attrs=&#123;<span class="string">'title'</span>: <span class="string">'Sunset Boulevard'</span>, <span class="string">'src'</span>: <span class="string">'sunset.jpg'</span>&#125;)&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> bound_args.arguments.items():</span><br><span class="line"><span class="meta">... </span>    print(k, <span class="string">'='</span>, v)</span><br><span class="line">...</span><br><span class="line">name = img</span><br><span class="line">cls = framed</span><br><span class="line">attrs = &#123;<span class="string">'title'</span>: <span class="string">'Sunset Boulevard'</span>, <span class="string">'src'</span>: <span class="string">'sunset.jpg'</span>&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> my_tag[<span class="string">'name'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bound_args = sig.bind(**my_tag)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"/Users/cws/opt/anaconda3/envs/python36/lib/python3.6/inspect.py"</span>, line <span class="number">2997</span>, <span class="keyword">in</span> bind</span><br><span class="line">    <span class="keyword">return</span> args[<span class="number">0</span>]._bind(args[<span class="number">1</span>:], kwargs)</span><br><span class="line">  File <span class="string">"/Users/cws/opt/anaconda3/envs/python36/lib/python3.6/inspect.py"</span>, line <span class="number">2912</span>, <span class="keyword">in</span> _bind</span><br><span class="line">    <span class="keyword">raise</span> TypeError(msg) <span class="keyword">from</span> <span class="literal">None</span></span><br><span class="line">TypeError: missing a required argument: <span class="string">'name'</span></span><br></pre></td></tr></table></figure><h1 id="函数注解">函数注解</h1><p>Python3提供了一种句法，用于为函数声明中的参数和返回值附加元数据。函数声明中的各个参数可以在<code>:</code>之后增加注解表达式。</p><p>Python对注解所做的唯一的事情是，把它们存储在函数的<code>__annotations__</code>属性里。仅此而已，Python不做检查、不做强制、不做验证，什么操作都不做。换句话说，注解对Python解释器没有任何意义。注解只是元数据，可以供IDE、框架和装饰器等工具使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, b, c, d)</span>:</span> <span class="keyword">pass</span>  <span class="comment"># 常规</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, b: str, c: <span class="string">'int &gt; 0'</span>, d: float=<span class="number">0.0</span>)</span> -&gt; str:</span> <span class="keyword">pass</span>  <span class="comment"># 加注解</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__annotations__</span><br><span class="line">&#123;'b': &lt;class 'str'&gt;, 'c': 'int &gt; 0', 'd': &lt;class 'float'&gt;, 'return': &lt;class 'str'&gt;&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> inspect <span class="keyword">import</span> signature</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sig = signature(f)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sig.return_annotation</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">for</span> <span class="title">param</span> <span class="title">in</span> <span class="title">sig</span>.<span class="title">parameters</span>.<span class="title">values</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    note = repr(param.annotation).ljust(<span class="number">26</span>)</span><br><span class="line"><span class="meta">... </span>    print(note, <span class="string">':'</span>, param.name, <span class="string">'='</span>, param.default)</span><br><span class="line">...</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">inspect</span>.<span class="title">_empty</span>'&gt;   :</span> a = &lt;<span class="class"><span class="keyword">class</span> '<span class="title">inspect</span>.<span class="title">_empty</span>'&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">str</span>'&gt;              :</span> b = &lt;<span class="class"><span class="keyword">class</span> '<span class="title">inspect</span>.<span class="title">_empty</span>'&gt;</span></span><br><span class="line"><span class="class">'<span class="title">int</span> &gt; 0'                  :</span> c = &lt;<span class="class"><span class="keyword">class</span> '<span class="title">inspect</span>.<span class="title">_empty</span>'&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">float</span>'&gt;            :</span> d = <span class="number">0.0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> parameters </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>支持函数式编程的包</title>
      <link href="/notes/fluent-python/packages-for-functional-programming/"/>
      <url>/notes/fluent-python/packages-for-functional-programming/</url>
      
        <content type="html"><![CDATA[<h1 id="operator模块">operator模块</h1><p>Python的目标不是变成函数式编程语言，但是得益于operator和functools等包的支持，函数式编程风格也可以信手拈来。下面是operator模块中定义的部分函数（省略了以_开头的名称，因为它们基本上是实现细节）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> operator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[name <span class="keyword">for</span> name <span class="keyword">in</span> dir(operator) <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'_'</span>)]</span><br><span class="line">[<span class="string">'abs'</span>, <span class="string">'add'</span>, <span class="string">'and_'</span>, <span class="string">'attrgetter'</span>, <span class="string">'concat'</span>, <span class="string">'contains'</span>, <span class="string">'countOf'</span>, <span class="string">'delitem'</span>, <span class="string">'eq'</span>, <span class="string">'floordiv'</span>, <span class="string">'ge'</span>, <span class="string">'getitem'</span>, <span class="string">'gt'</span>, <span class="string">'iadd'</span>, <span class="string">'iand'</span>, <span class="string">'iconcat'</span>, <span class="string">'ifloordiv'</span>, <span class="string">'ilshift'</span>, <span class="string">'imatmul'</span>, <span class="string">'imod'</span>, <span class="string">'imul'</span>, <span class="string">'index'</span>, <span class="string">'indexOf'</span>, <span class="string">'inv'</span>, <span class="string">'invert'</span>, <span class="string">'ior'</span>, <span class="string">'ipow'</span>, <span class="string">'irshift'</span>, <span class="string">'is_'</span>, <span class="string">'is_not'</span>, <span class="string">'isub'</span>, <span class="string">'itemgetter'</span>, <span class="string">'itruediv'</span>, <span class="string">'ixor'</span>, <span class="string">'le'</span>, <span class="string">'length_hint'</span>, <span class="string">'lshift'</span>, <span class="string">'lt'</span>, <span class="string">'matmul'</span>, <span class="string">'methodcaller'</span>, <span class="string">'mod'</span>, <span class="string">'mul'</span>, <span class="string">'ne'</span>, <span class="string">'neg'</span>, <span class="string">'not_'</span>, <span class="string">'or_'</span>, <span class="string">'pos'</span>, <span class="string">'pow'</span>, <span class="string">'rshift'</span>, <span class="string">'setitem'</span>, <span class="string">'sub'</span>, <span class="string">'truediv'</span>, <span class="string">'truth'</span>, <span class="string">'xor'</span>]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="算术运算符函数">算术运算符函数</h2><p>在函数式编程中，经常需要把算术运算符当作函数使用。例如，不使用递归进行阶乘</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> a, b: a*b, range(<span class="number">1</span>, n+<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>operator模块为多个算术运算符提供了对应的函数，从而避免编写<code>lambda a, b: a*b</code>这种平凡的匿名函数。使用算术运算符函数，可以把上例改写为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> mul</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">_fact</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> reduce(mul, range(<span class="number">1</span>, n+<span class="number">1</span>))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>all(fact(i) == _fact(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">100</span>))</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="getter函数">getter函数</h2><p>operator模块中还有一类函数，能替代从序列中取出元素或读取对象属性的lambda表达式：因此，itemgetter和attrgetter其实会自行构建函数（点击链接查看其等价函数）。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/operator#operator.itemgetter" target="_blank" rel="noopener"><code>operator.itemgetter(item) operator.itemgetter(*items)</code></a></p><p>Return a callable object that fetches <em>item</em> from its operand using the operand’s <code>__getitem__()</code> method. If multiple items are specified, returns a tuple of lookup values. For example:</p><ul><li>After <code>f = itemgetter(2)</code>, the call <code>f(r)</code> returns <code>r[2]</code>.</li><li>After <code>g = itemgetter(2, 5, 3)</code>, the call <code>g(r)</code> returns <code>(r[2], r[5], r[3])</code>.</li></ul><hr><p><a href="https://devdocs.io/python~3.6/library/operator#operator.attrgetter" target="_blank" rel="noopener"><code>operator.attrgetter(attr) operator.attrgetter(*attrs)</code></a></p><p>Return a callable object that fetches <em>attr</em> from its operand. If more than one attribute is requested, returns a tuple of attributes. The attribute names can also contain dots. For example:</p><ul><li>After <code>f = attrgetter('name')</code>, the call <code>f(b)</code> returns <code>b.name</code>.</li><li>After <code>f = attrgetter('name', 'date')</code>, the call <code>f(b)</code> returns <code>(b.name, b.date)</code>.</li><li>After <code>f = attrgetter('name.first', 'name.last')</code>, the call <code>f(b)</code> returns <code>(b.name.first, b.name.last)</code>.</li></ul></blockquote><h2 id="methodcall函数">methodcall函数</h2><p>它的作用与attrgetter和itemgetter类似，它会自行创建函数。methodcaller创建的函数会在对象上调用参数指定的方法。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/operator#operator.methodcaller" target="_blank" rel="noopener"><code>operator.methodcaller(name[, args...])</code></a></p><p>Return a callable object that calls the method <em>name</em> on its operand. If additional arguments and/or keyword arguments are given, they will be given to the method as well. For example:</p><ul><li>After <code>f = methodcaller('name')</code>, the call <code>f(b)</code> returns <code>b.name()</code>.</li><li>After <code>f = methodcaller('name', 'foo', bar=1)</code>, the call <code>f(b)</code> returns <code>b.name('foo', bar=1)</code>.</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> methodcaller</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'The time has come'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>upcase = methodcaller(<span class="string">'upper'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>upcase(s)  <span class="comment"># 相当于s.upper()</span></span><br><span class="line"><span class="string">'THE TIME HAS COME'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hiphenate = methodcaller(<span class="string">'replace'</span>, <span class="string">' '</span>, <span class="string">'-'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hiphenate(s)  <span class="comment"># 相当于s.replace(' ', '-')</span></span><br><span class="line"><span class="string">'The-time-has-come'</span></span><br></pre></td></tr></table></figure><h1 id="使用functools.partial冻结参数">使用functools.partial冻结参数</h1><blockquote><p><a href="https://devdocs.io/python~3.6/library/functools#functools.partial" target="_blank" rel="noopener"><code>functools.partial(func, *args, **keywords)</code></a></p></blockquote><p>partial这个高阶函数用于部分应用一个函数。部分应用是指，基于一个函数创建一个新的调用对象，把原函数的某些参数固定。使用这个函数可以把接受一个或多个参数的函数改编成需要回调的API，这样参数更少。</p><p>示例：使用partial把一个两参数函数改编成需要单参数的可调用对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> mul</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>triple = partial(mul, <span class="number">3</span>)  <span class="comment"># 相当于 lambda e: mul(3, e)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>triple</span><br><span class="line">functools.partial(&lt;built-<span class="keyword">in</span> function mul&gt;, <span class="number">3</span>)  <span class="comment"># 返回一个partial对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>triple(<span class="number">7</span>)  <span class="comment"># triple接受单参数</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(triple, range(<span class="number">1</span>, <span class="number">10</span>)))</span><br><span class="line">[<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">21</span>, <span class="number">24</span>, <span class="number">27</span>]</span><br></pre></td></tr></table></figure><p>functools.partialmethod函数（Python3.4新增）的作用与partial一样，不过是用于处理方法（在类中定义的函数）的。</p><blockquote><p><a href="https://devdocs.io/python~3.6/library/functools#functools.partialmethod" target="_blank" rel="noopener"><code>class functools.partialmethod(func, *args, **keywords)</code></a></p></blockquote><p>Example:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Cell</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self._alive = <span class="literal">False</span></span><br><span class="line"><span class="meta">... </span>    @property</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">alive</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> self._alive</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">set_state</span><span class="params">(self, state)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self._alive = bool(state)</span><br><span class="line"><span class="meta">... </span>    set_alive = partialmethod(set_state, <span class="literal">True</span>)</span><br><span class="line"><span class="meta">... </span>    set_dead = partialmethod(set_state, <span class="literal">False</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Cell()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.alive</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.set_alive()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.alive</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> functional programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dict：处理找不到的键</title>
      <link href="/notes/fluent-python/handling-missing-keys-in-a-dict/"/>
      <url>/notes/fluent-python/handling-missing-keys-in-a-dict/</url>
      
        <content type="html"><![CDATA[<h1 id="get">get</h1><blockquote><p><code>get(key[, default])</code></p></blockquote><p>当key存在时，返回其对应的值，否则返回default，defaut的默认值为None，这比处理KeyError要方便不少。相当于<code>return m[key] if key in a else default</code>。</p><p>但是要更新某个键对应的值时，不管使用<code>__getitem__</code>（即类似m[key]的形式）还是get都会不自然，而且效率低。</p><h1 id="setdefault">setdefault</h1><blockquote><p><code>setdefault(key[, default])</code></p></blockquote><p>当key不存在时，会先更新key的值为default，然后返回default。当key存在时，返回key的值。相当于：</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setdefault</span><span class="params">(self, key, default=None)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> self[key]  <span class="comment"># key已存在时</span></span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">        self[key] = default  <span class="comment"># key不存在时</span></span><br><span class="line">        <span class="keyword">return</span> default</span><br></pre></td></tr></table></figure><p>get(key, default)与setdefault(key, default)在key不存在时都能返回default，不同的是setdefault在返回前更新了key的值，这在某些时候（比如值是一个对象，且对其进行修改时）非常有用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name_list = m.get(<span class="string">'names'</span>, [])  <span class="comment"># 第1次查询</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name_list.append(<span class="string">'Alice'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="string">'names'</span>] = name_list  <span class="comment"># 第2次查询</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m</span><br><span class="line">&#123;<span class="string">'names'</span>: [<span class="string">'Alice'</span>]&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.setdefault(<span class="string">'names'</span>, []).append(<span class="string">'John'</span>)  <span class="comment"># 1步到位</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m</span><br><span class="line">&#123;<span class="string">'names'</span>: [<span class="string">'Alice'</span>, <span class="string">'John'</span>]&#125;</span><br></pre></td></tr></table></figure><h1 id="defaultdict">defaultdict</h1><blockquote><p><code>class collections.defaultdict([default_factory[, ...]])</code></p></blockquote><p>在用户创建defaultdict对象的时候，就需要给它配置一个为找不到的键创造默认值的方法。具体而言，在实例化一个defaultdict的时候，需要给构造方法提供一个可调用对象，这个可调用对象会在<code>__getitem__</code>碰到找不到的键的时候被调用，让<code>__getitem__</code>返回某种默认值。</p><p>defaultdict里的default_factory只会在<code>__getitem__</code>里被调用，在其他的方法里完全不会发挥作用。比如，dd是个defaultdict，k是个找不到的键，dd[k]这个表达式会调用default_factory创造某个默认值，而dd.get(k)则会返回None。</p><p>所有这一切背后的功臣其实是特殊方法<code>__missing__</code>。它会在defaultdict遇到找不到的键的时候调用default_factory，而实际上这个特性是所有映射类型都可以选择去支持的。</p><p>使用例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = defaultdict(list)  <span class="comment"># default_factory=list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="string">'names'</span>].append(<span class="string">'Alice'</span>)  <span class="comment"># default_factor会被调用，为查询不到的键创建一个值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">defaultdict(&lt;class 'list'&gt;, &#123;'names': ['Alice']&#125;)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.get(<span class="number">0</span>)  <span class="comment"># default_factor会被调用不会被调用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.get(<span class="string">'names'</span>)</span><br><span class="line">[<span class="string">'Alice'</span>]</span><br></pre></td></tr></table></figure><h1 id="特殊方法">特殊方法</h1><p><strong>所有的映射类型在处理找不到的键的时候，都会牵扯到<code>__missing__</code>方法。</strong>这也是这个方法称作“missing”的原因。虽然基类dict并没有定义这个方法，但是dict是知道有这么个东西存在的。也就是说，如果有一个类继承了dict，然后这个继承类提供了<code>__missing__</code>方法，那么在<code>__getitem__</code>碰到找不到的键的时候，Python 就会自动调用它，而不是抛出一个KeyError异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">StrKeyDict</span><span class="params">(dict)</span>:</span>  <span class="comment"># 继承自dict</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> isinstance(key, str):  <span class="comment"># 如果key本身是字符串，就抛出异常</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">raise</span> KeyError(key)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> self[str(key)]  <span class="comment"># 否则，转换成字符串在进行查找</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key, default=None)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> self[key]  <span class="comment"># 将get方法的查找工作委托给__getitem__，这样在宣布</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">except</span> KeyError:      <span class="comment"># 查找失败之前，还能通过__missing__再给某个键一次机会</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> default</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self, key)</span>:</span>  <span class="comment"># 继承的__contains__方法在找不到键时不会调用__missing__</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> key <span class="keyword">in</span> self.keys() <span class="keyword">or</span> str(key) <span class="keyword">in</span> self.keys()  <span class="comment"># 因此这里需要重写此方法</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = StrKeyDict(&#123;i <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> str(i): i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m</span><br><span class="line">&#123;<span class="number">0</span>: <span class="number">0</span>, <span class="string">'1'</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">4</span>, <span class="string">'3'</span>: <span class="number">9</span>, <span class="number">4</span>: <span class="number">16</span>, <span class="string">'5'</span>: <span class="number">25</span>, <span class="number">6</span>: <span class="number">36</span>, <span class="string">'7'</span>: <span class="number">49</span>, <span class="number">8</span>: <span class="number">64</span>, <span class="string">'9'</span>: <span class="number">81</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="number">0</span>]</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.get(<span class="number">0</span>)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="number">1</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.get(<span class="number">1</span>)  <span class="comment"># 与defaultdict不同，能触发__missing__</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> <span class="keyword">in</span> m</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> <span class="keyword">in</span> m</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><ul><li><p><code>__missing__</code>方法中isinstance是必须的，否则当str(key)是一个不存在的键时，会陷入无限递归。</p></li><li><p><code>__contains__</code>方法中没有用key in my_dict来检查键是否存在，因为那也会导致<code>__contains__</code>被递归调用（or关键字后面的第二次查找会调用<code>__contains__</code>）。为了避免这一情况，这里采用了更显式的方法，直接在self.keys()里查询。</p></li><li><p>像k in my_dict.keys()这种操作在Python 3中是很快的，而且即便映射类型对象很庞大也没关系。这是因为dict.keys()的返回值是一个”视图“。视图就像一个集合，而且跟字典类似的是，在视图里查找一个元素的速度很快。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> dict </tag>
            
            <tag> defaultdict </tag>
            
            <tag> special methods </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用bisect来管理已排序的序列</title>
      <link href="/notes/fluent-python/managing-ordered-sequences-with-bisect/"/>
      <url>/notes/fluent-python/managing-ordered-sequences-with-bisect/</url>
      
        <content type="html"><![CDATA[<h1 id="bisect">bisect</h1><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><thead><tr class="header"><th>Method</th><th>Doc</th></tr></thead><tbody><tr class="odd"><td><code>bisect.bisect_left(a, x, lo=0, hi=len(a))</code></td><td>Return the leftmost index where to insert item x in list a, assuming a is sorted.</td></tr><tr class="even"><td><code>bisect.bisect_right(a, x, lo=0, hi=len(a))</code></td><td>Return the rightmost index where to insert item x in list a, assuming a is sorted.</td></tr><tr class="odd"><td><code>bisect.bisect(a, x, lo=0, hi=len(a))</code></td><td>Equal to bisect_right.</td></tr><tr class="even"><td><code>bisect.insort_left(a, x, lo=0, hi=len(a))</code></td><td>Insert item x in a and keep it sorted assuming a is sorted. If equal keys are found, add to the left.</td></tr><tr class="odd"><td><code>bisect.insort_right(a, x, lo=0, hi=len(a))</code></td><td>Insert item x in a and keep it sorted assuming a is sorted. If equal keys are found, add to the right.</td></tr><tr class="even"><td><code>bisect.insort(a, x, lo=0, hi=len(a))</code></td><td>Equal to insort_right.</td></tr></tbody></table><a id="more"></a><h1 id="sortedcollection">SortedCollection</h1><p>Python的高产贡献者Raymond Hettinger写了一个排序集合模块<a href="http://code.activestate.com/recipes/577197-sortedcollection/" target="_blank" rel="noopener">SortedCollection</a>，模块里集成了bisect功能，但是比独立的bisect更易用。</p><table><colgroup><col style="width: 33%"><col style="width: 66%"></colgroup><thead><tr class="header"><th>Method</th><th>Doc</th></tr></thead><tbody><tr class="odd"><td><code>def clear(self)</code></td><td></td></tr><tr class="even"><td><code>def copy(self)</code></td><td></td></tr><tr class="odd"><td><code>def index(self, item)</code></td><td>Find the position of an item. Raise ValueError if not found.</td></tr><tr class="even"><td><code>def count(self, item)</code></td><td>Return number of occurrences of item.</td></tr><tr class="odd"><td><code>def insert(self, item)</code></td><td>Insert a new item. If equal keys are found, add to the left.</td></tr><tr class="even"><td><code>def insert_right(self, item)</code></td><td>Insert a new item. If equal keys are found, add to the right.</td></tr><tr class="odd"><td><code>def remove(self, item)</code></td><td>Remove first occurence of item. Raise ValueError if not found.</td></tr><tr class="even"><td><code>def find(self, k)</code></td><td>Return first item with a key == k. Raise ValueError if not found.</td></tr><tr class="odd"><td><code>def find_le(self, k)</code></td><td>Return last item with a key &lt;= k. Raise ValueError if not found.</td></tr><tr class="even"><td><code>def find_lt(self, k)</code></td><td>Return last item with a key &lt; k. Raise ValueError if not found.</td></tr><tr class="odd"><td><code>def find_ge(self, k)</code></td><td>Return first item with a key &gt;= k. Raise ValueError if not found.</td></tr><tr class="even"><td><code>def find_gt(self, k)</code></td><td>Return first item with a key &gt; k. Raise ValueError if not found.</td></tr></tbody></table><h1 id="bisect源码">bisect源码</h1><figure class="highlight python"><figcaption><span>bisect.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""Bisection algorithms."""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insort_right</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="string">"""Insert item x in list a, and keep it sorted assuming a is sorted.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If x is already in a, insert it to the right of the rightmost x.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Optional args lo (default 0) and hi (default len(a)) bound the</span></span><br><span class="line"><span class="string">    slice of a to be searched.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; a[mid]: hi = mid</span><br><span class="line">        <span class="keyword">else</span>: lo = mid+<span class="number">1</span></span><br><span class="line">    a.insert(lo, x)</span><br><span class="line"></span><br><span class="line">insort = insort_right   <span class="comment"># backward compatibility</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bisect_right</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="string">"""Return the index where to insert item x in list a, assuming a is sorted.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The return value i is such that all e in a[:i] have e &lt;= x, and all e in</span></span><br><span class="line"><span class="string">    a[i:] have e &gt; x.  So if x already appears in the list, a.insert(x) will</span></span><br><span class="line"><span class="string">    insert just after the rightmost x already there.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Optional args lo (default 0) and hi (default len(a)) bound the</span></span><br><span class="line"><span class="string">    slice of a to be searched.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; a[mid]: hi = mid</span><br><span class="line">        <span class="keyword">else</span>: lo = mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> lo</span><br><span class="line"></span><br><span class="line">bisect = bisect_right   <span class="comment"># backward compatibility</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insort_left</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="string">"""Insert item x in list a, and keep it sorted assuming a is sorted.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If x is already in a, insert it to the left of the leftmost x.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Optional args lo (default 0) and hi (default len(a)) bound the</span></span><br><span class="line"><span class="string">    slice of a to be searched.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> a[mid] &lt; x: lo = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: hi = mid</span><br><span class="line">    a.insert(lo, x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bisect_left</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="string">"""Return the index where to insert item x in list a, assuming a is sorted.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The return value i is such that all e in a[:i] have e &lt; x, and all e in</span></span><br><span class="line"><span class="string">    a[i:] have e &gt;= x.  So if x already appears in the list, a.insert(x) will</span></span><br><span class="line"><span class="string">    insert just before the leftmost x already there.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Optional args lo (default 0) and hi (default len(a)) bound the</span></span><br><span class="line"><span class="string">    slice of a to be searched.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> a[mid] &lt; x: lo = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: hi = mid</span><br><span class="line">    <span class="keyword">return</span> lo</span><br><span class="line"></span><br><span class="line"><span class="comment"># Overwrite above definitions with a fast C implementation</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> _bisect <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h1 id="sortedcollection源码">SortedCollection源码</h1><figure class="highlight python"><figcaption><span>recipe-577197-1.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_left, bisect_right</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortedCollection</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''Sequence sorted by a key function.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    SortedCollection() is much easier to work with than using bisect() directly.</span></span><br><span class="line"><span class="string">    It supports key functions like those use in sorted(), min(), and max().</span></span><br><span class="line"><span class="string">    The result of the key function call is saved so that keys can be searched</span></span><br><span class="line"><span class="string">    efficiently.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Instead of returning an insertion-point which can be hard to interpret, the</span></span><br><span class="line"><span class="string">    five find-methods return a specific item in the sequence. They can scan for</span></span><br><span class="line"><span class="string">    exact matches, the last item less-than-or-equal to a key, or the first item</span></span><br><span class="line"><span class="string">    greater-than-or-equal to a key.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Once found, an item's ordinal position can be located with the index() method.</span></span><br><span class="line"><span class="string">    New items can be added with the insert() and insert_right() methods.</span></span><br><span class="line"><span class="string">    Old items can be deleted with the remove() method.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The usual sequence methods are provided to support indexing, slicing,</span></span><br><span class="line"><span class="string">    length lookup, clearing, copying, forward and reverse iteration, contains</span></span><br><span class="line"><span class="string">    checking, item counts, item removal, and a nice looking repr.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Finding and indexing are O(log n) operations while iteration and insertion</span></span><br><span class="line"><span class="string">    are O(n).  The initial sort is O(n log n).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The key function is stored in the 'key' attibute for easy introspection or</span></span><br><span class="line"><span class="string">    so that you can assign a new key function (triggering an automatic re-sort).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    In short, the class was designed to handle all of the common use cases for</span></span><br><span class="line"><span class="string">    bisect but with a simpler API and support for key functions.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; from pprint import pprint</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; from operator import itemgetter</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s = SortedCollection(key=itemgetter(2))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; for record in [</span></span><br><span class="line"><span class="string">    ...         ('roger', 'young', 30),</span></span><br><span class="line"><span class="string">    ...         ('angela', 'jones', 28),</span></span><br><span class="line"><span class="string">    ...         ('bill', 'smith', 22),</span></span><br><span class="line"><span class="string">    ...         ('david', 'thomas', 32)]:</span></span><br><span class="line"><span class="string">    ...     s.insert(record)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; pprint(list(s))         # show records sorted by age</span></span><br><span class="line"><span class="string">    [('bill', 'smith', 22),</span></span><br><span class="line"><span class="string">     ('angela', 'jones', 28),</span></span><br><span class="line"><span class="string">     ('roger', 'young', 30),</span></span><br><span class="line"><span class="string">     ('david', 'thomas', 32)]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s.find_le(29)           # find oldest person aged 29 or younger</span></span><br><span class="line"><span class="string">    ('angela', 'jones', 28)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s.find_lt(28)           # find oldest person under 28</span></span><br><span class="line"><span class="string">    ('bill', 'smith', 22)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s.find_gt(28)           # find youngest person over 28</span></span><br><span class="line"><span class="string">    ('roger', 'young', 30)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; r = s.find_ge(32)       # find youngest person aged 32 or older</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s.index(r)              # get the index of their record</span></span><br><span class="line"><span class="string">    3</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s[3]                    # fetch the record at that index</span></span><br><span class="line"><span class="string">    ('david', 'thomas', 32)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; s.key = itemgetter(0)   # now sort by first name</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; pprint(list(s))</span></span><br><span class="line"><span class="string">    [('angela', 'jones', 28),</span></span><br><span class="line"><span class="string">     ('bill', 'smith', 22),</span></span><br><span class="line"><span class="string">     ('david', 'thomas', 32),</span></span><br><span class="line"><span class="string">     ('roger', 'young', 30)]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, iterable=<span class="params">()</span>, key=None)</span>:</span></span><br><span class="line">        self._given_key = key</span><br><span class="line">        key = (<span class="keyword">lambda</span> x: x) <span class="keyword">if</span> key <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> key</span><br><span class="line">        decorated = sorted((key(item), item) <span class="keyword">for</span> item <span class="keyword">in</span> iterable)</span><br><span class="line">        self._keys = [k <span class="keyword">for</span> k, item <span class="keyword">in</span> decorated]</span><br><span class="line">        self._items = [item <span class="keyword">for</span> k, item <span class="keyword">in</span> decorated]</span><br><span class="line">        self._key = key</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_getkey</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._key</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_setkey</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">is</span> <span class="keyword">not</span> self._key:</span><br><span class="line">            self.__init__(self._items, key=key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_delkey</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._setkey(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    key = property(_getkey, _setkey, _delkey, <span class="string">'key function'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__init__([], self._key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copy</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__class__(self, self._key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._items)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._items[i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self._items)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reversed__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> reversed(self._items)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'%s(%r, key=%s)'</span> % (</span><br><span class="line">            self.__class__.__name__,</span><br><span class="line">            self._items,</span><br><span class="line">            getattr(self._given_key, <span class="string">'__name__'</span>, repr(self._given_key))</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reduce__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__class__, (self._items, self._given_key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        k = self._key(item)</span><br><span class="line">        i = bisect_left(self._keys, k)</span><br><span class="line">        j = bisect_right(self._keys, k)</span><br><span class="line">        <span class="keyword">return</span> item <span class="keyword">in</span> self._items[i:j]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'Find the position of an item.  Raise ValueError if not found.'</span></span><br><span class="line">        k = self._key(item)</span><br><span class="line">        i = bisect_left(self._keys, k)</span><br><span class="line">        j = bisect_right(self._keys, k)</span><br><span class="line">        <span class="keyword">return</span> self._items[i:j].index(item) + i</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'Return number of occurrences of item'</span></span><br><span class="line">        k = self._key(item)</span><br><span class="line">        i = bisect_left(self._keys, k)</span><br><span class="line">        j = bisect_right(self._keys, k)</span><br><span class="line">        <span class="keyword">return</span> self._items[i:j].count(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'Insert a new item.  If equal keys are found, add to the left'</span></span><br><span class="line">        k = self._key(item)</span><br><span class="line">        i = bisect_left(self._keys, k)</span><br><span class="line">        self._keys.insert(i, k)</span><br><span class="line">        self._items.insert(i, item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_right</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'Insert a new item.  If equal keys are found, add to the right'</span></span><br><span class="line">        k = self._key(item)</span><br><span class="line">        i = bisect_right(self._keys, k)</span><br><span class="line">        self._keys.insert(i, k)</span><br><span class="line">        self._items.insert(i, item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'Remove first occurence of item.  Raise ValueError if not found'</span></span><br><span class="line">        i = self.index(item)</span><br><span class="line">        <span class="keyword">del</span> self._keys[i]</span><br><span class="line">        <span class="keyword">del</span> self._items[i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        <span class="string">'Return first item with a key == k.  Raise ValueError if not found.'</span></span><br><span class="line">        i = bisect_left(self._keys, k)</span><br><span class="line">        <span class="keyword">if</span> i != len(self) <span class="keyword">and</span> self._keys[i] == k:</span><br><span class="line">            <span class="keyword">return</span> self._items[i]</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'No item found with key equal to: %r'</span> % (k,))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_le</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        <span class="string">'Return last item with a key &lt;= k.  Raise ValueError if not found.'</span></span><br><span class="line">        i = bisect_right(self._keys, k)</span><br><span class="line">        <span class="keyword">if</span> i:</span><br><span class="line">            <span class="keyword">return</span> self._items[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'No item found with key at or below: %r'</span> % (k,))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_lt</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        <span class="string">'Return last item with a key &lt; k.  Raise ValueError if not found.'</span></span><br><span class="line">        i = bisect_left(self._keys, k)</span><br><span class="line">        <span class="keyword">if</span> i:</span><br><span class="line">            <span class="keyword">return</span> self._items[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'No item found with key below: %r'</span> % (k,))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_ge</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        <span class="string">'Return first item with a key &gt;= equal to k.  Raise ValueError if not found'</span></span><br><span class="line">        i = bisect_left(self._keys, k)</span><br><span class="line">        <span class="keyword">if</span> i != len(self):</span><br><span class="line">            <span class="keyword">return</span> self._items[i]</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'No item found with key at or above: %r'</span> % (k,))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_gt</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        <span class="string">'Return first item with a key &gt; k.  Raise ValueError if not found'</span></span><br><span class="line">        i = bisect_right(self._keys, k)</span><br><span class="line">        <span class="keyword">if</span> i != len(self):</span><br><span class="line">            <span class="keyword">return</span> self._items[i]</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'No item found with key above: %r'</span> % (k,))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------  Simple demo and tests  -------------------------</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ve2no</span><span class="params">(f, *args)</span>:</span></span><br><span class="line">        <span class="string">'Convert ValueError result to -1'</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> f(*args)</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">slow_index</span><span class="params">(seq, k)</span>:</span></span><br><span class="line">        <span class="string">'Location of match or -1 if not found'</span></span><br><span class="line">        <span class="keyword">for</span> i, item <span class="keyword">in</span> enumerate(seq):</span><br><span class="line">            <span class="keyword">if</span> item == k:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">slow_find</span><span class="params">(seq, k)</span>:</span></span><br><span class="line">        <span class="string">'First item with a key equal to k. -1 if not found'</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> seq:</span><br><span class="line">            <span class="keyword">if</span> item == k:</span><br><span class="line">                <span class="keyword">return</span> item</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">slow_find_le</span><span class="params">(seq, k)</span>:</span></span><br><span class="line">        <span class="string">'Last item with a key less-than or equal to k.'</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> reversed(seq):</span><br><span class="line">            <span class="keyword">if</span> item &lt;= k:</span><br><span class="line">                <span class="keyword">return</span> item</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">slow_find_lt</span><span class="params">(seq, k)</span>:</span></span><br><span class="line">        <span class="string">'Last item with a key less-than k.'</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> reversed(seq):</span><br><span class="line">            <span class="keyword">if</span> item &lt; k:</span><br><span class="line">                <span class="keyword">return</span> item</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">slow_find_ge</span><span class="params">(seq, k)</span>:</span></span><br><span class="line">        <span class="string">'First item with a key-value greater-than or equal to k.'</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> seq:</span><br><span class="line">            <span class="keyword">if</span> item &gt;= k:</span><br><span class="line">                <span class="keyword">return</span> item</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">slow_find_gt</span><span class="params">(seq, k)</span>:</span></span><br><span class="line">        <span class="string">'First item with a key-value greater-than or equal to k.'</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> seq:</span><br><span class="line">            <span class="keyword">if</span> item &gt; k:</span><br><span class="line">                <span class="keyword">return</span> item</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line">    pool = [<span class="number">1.5</span>, <span class="number">2</span>, <span class="number">2.0</span>, <span class="number">3</span>, <span class="number">3.0</span>, <span class="number">3.5</span>, <span class="number">4</span>, <span class="number">4.0</span>, <span class="number">4.5</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">500</span>):</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">            s = [choice(pool) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">            sc = SortedCollection(s)</span><br><span class="line">            s.sort()</span><br><span class="line">            <span class="keyword">for</span> probe <span class="keyword">in</span> pool:</span><br><span class="line">                <span class="keyword">assert</span> repr(ve2no(sc.index, probe)) == repr(slow_index(s, probe))</span><br><span class="line">                <span class="keyword">assert</span> repr(ve2no(sc.find, probe)) == repr(slow_find(s, probe))</span><br><span class="line">                <span class="keyword">assert</span> repr(ve2no(sc.find_le, probe)) == repr(slow_find_le(s, probe))</span><br><span class="line">                <span class="keyword">assert</span> repr(ve2no(sc.find_lt, probe)) == repr(slow_find_lt(s, probe))</span><br><span class="line">                <span class="keyword">assert</span> repr(ve2no(sc.find_ge, probe)) == repr(slow_find_ge(s, probe))</span><br><span class="line">                <span class="keyword">assert</span> repr(ve2no(sc.find_gt, probe)) == repr(slow_find_gt(s, probe))</span><br><span class="line">            <span class="keyword">for</span> i, item <span class="keyword">in</span> enumerate(s):</span><br><span class="line">                <span class="keyword">assert</span> repr(item) == repr(sc[i])        <span class="comment"># test __getitem__</span></span><br><span class="line">                <span class="keyword">assert</span> item <span class="keyword">in</span> sc                       <span class="comment"># test __contains__ and __iter__</span></span><br><span class="line">                <span class="keyword">assert</span> s.count(item) == sc.count(item)  <span class="comment"># test count()</span></span><br><span class="line">            <span class="keyword">assert</span> len(sc) == n                         <span class="comment"># test __len__</span></span><br><span class="line">            <span class="keyword">assert</span> list(map(repr, reversed(sc))) == list(map(repr, reversed(s)))    <span class="comment"># test __reversed__</span></span><br><span class="line">            <span class="keyword">assert</span> list(sc.copy()) == list(sc)          <span class="comment"># test copy()</span></span><br><span class="line">            sc.clear()                                  <span class="comment"># test clear()</span></span><br><span class="line">            <span class="keyword">assert</span> len(sc) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    sd = SortedCollection(<span class="string">'The quick Brown Fox jumped'</span>.split(), key=str.lower)</span><br><span class="line">    <span class="keyword">assert</span> sd._keys == [<span class="string">'brown'</span>, <span class="string">'fox'</span>, <span class="string">'jumped'</span>, <span class="string">'quick'</span>, <span class="string">'the'</span>]</span><br><span class="line">    <span class="keyword">assert</span> sd._items == [<span class="string">'Brown'</span>, <span class="string">'Fox'</span>, <span class="string">'jumped'</span>, <span class="string">'quick'</span>, <span class="string">'The'</span>]</span><br><span class="line">    <span class="keyword">assert</span> sd._key == str.lower</span><br><span class="line">    <span class="keyword">assert</span> repr(sd) == <span class="string">"SortedCollection(['Brown', 'Fox', 'jumped', 'quick', 'The'], key=lower)"</span></span><br><span class="line">    sd.key = str.upper</span><br><span class="line">    <span class="keyword">assert</span> sd._key == str.upper</span><br><span class="line">    <span class="keyword">assert</span> len(sd) == <span class="number">5</span></span><br><span class="line">    <span class="keyword">assert</span> list(reversed(sd)) == [<span class="string">'The'</span>, <span class="string">'quick'</span>, <span class="string">'jumped'</span>, <span class="string">'Fox'</span>, <span class="string">'Brown'</span>]</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> sd:</span><br><span class="line">        <span class="keyword">assert</span> item <span class="keyword">in</span> sd</span><br><span class="line">    <span class="keyword">for</span> i, item <span class="keyword">in</span> enumerate(sd):</span><br><span class="line">        <span class="keyword">assert</span> item == sd[i]</span><br><span class="line">    sd.insert(<span class="string">'jUmPeD'</span>)</span><br><span class="line">    sd.insert_right(<span class="string">'QuIcK'</span>)</span><br><span class="line">    <span class="keyword">assert</span> sd._keys ==[<span class="string">'BROWN'</span>, <span class="string">'FOX'</span>, <span class="string">'JUMPED'</span>, <span class="string">'JUMPED'</span>, <span class="string">'QUICK'</span>, <span class="string">'QUICK'</span>, <span class="string">'THE'</span>]</span><br><span class="line">    <span class="keyword">assert</span> sd._items == [<span class="string">'Brown'</span>, <span class="string">'Fox'</span>, <span class="string">'jUmPeD'</span>, <span class="string">'jumped'</span>, <span class="string">'quick'</span>, <span class="string">'QuIcK'</span>, <span class="string">'The'</span>]</span><br><span class="line">    <span class="keyword">assert</span> sd.find_le(<span class="string">'JUMPED'</span>) == <span class="string">'jumped'</span>, sd.find_le(<span class="string">'JUMPED'</span>)</span><br><span class="line">    <span class="keyword">assert</span> sd.find_ge(<span class="string">'JUMPED'</span>) == <span class="string">'jUmPeD'</span></span><br><span class="line">    <span class="keyword">assert</span> sd.find_le(<span class="string">'GOAT'</span>) == <span class="string">'Fox'</span></span><br><span class="line">    <span class="keyword">assert</span> sd.find_ge(<span class="string">'GOAT'</span>) == <span class="string">'jUmPeD'</span></span><br><span class="line">    <span class="keyword">assert</span> sd.find(<span class="string">'FOX'</span>) == <span class="string">'Fox'</span></span><br><span class="line">    <span class="keyword">assert</span> sd[<span class="number">3</span>] == <span class="string">'jumped'</span></span><br><span class="line">    <span class="keyword">assert</span> sd[<span class="number">3</span>:<span class="number">5</span>] ==[<span class="string">'jumped'</span>, <span class="string">'quick'</span>]</span><br><span class="line">    <span class="keyword">assert</span> sd[<span class="number">-2</span>] == <span class="string">'QuIcK'</span></span><br><span class="line">    <span class="keyword">assert</span> sd[<span class="number">-4</span>:<span class="number">-2</span>] == [<span class="string">'jumped'</span>, <span class="string">'quick'</span>]</span><br><span class="line">    <span class="keyword">for</span> i, item <span class="keyword">in</span> enumerate(sd):</span><br><span class="line">        <span class="keyword">assert</span> sd.index(item) == i</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sd.index(<span class="string">'xyzpdq'</span>)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="number">0</span>, <span class="string">'Oops, failed to notify of missing value'</span></span><br><span class="line">    sd.remove(<span class="string">'jumped'</span>)</span><br><span class="line">    <span class="keyword">assert</span> list(sd) == [<span class="string">'Brown'</span>, <span class="string">'Fox'</span>, <span class="string">'jUmPeD'</span>, <span class="string">'quick'</span>, <span class="string">'QuIcK'</span>, <span class="string">'The'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> doctest</span><br><span class="line">    <span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line">    print(doctest.testmod())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> bisect </tag>
            
            <tag> binary serch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>list.sort方法和内置函数sorted</title>
      <link href="/notes/fluent-python/list-sort-and-the-sorted-built-in-function/"/>
      <url>/notes/fluent-python/list-sort-and-the-sorted-built-in-function/</url>
      
        <content type="html"><![CDATA[<h1 id="python的一个惯例">Python的一个惯例</h1><p>如果一个函数或者方法对对象进行的是就地改动，那它就应该返回None，好让调用者知道传入的参数发生了变动，而且并未产生新的对象。例如，list.sort和random.shuffle函数。</p><h1 id="list.sort和sorted">list.sort和sorted</h1><blockquote><p><code>sort(*, key=None, reverse=False)</code></p></blockquote><blockquote><p><code>sorted(iterable, *, key=None, reverse=False)</code></p></blockquote><p>这两个函数都有两个可选的关键字参数。</p><ul><li><p>reverse：如果被设定为True，被排序的序列里的元素会以降序输出。默认值是False。</p></li><li><p>key：指定一个函数，这个函数会被用在序列里的每一个元素上，所产生的结果将是排序算法依赖的对比关键字。默认值是None，直接比较元素。</p></li></ul><p>sorted函数会新建一个列表作为返回值。这个方法可以接受任何形式的可迭代对象作为参数，甚至包括不可变序列或生成器。而不管接受的是怎样的参数，它最后都会返回一个列表。</p><a id="more"></a><h1 id="例">例</h1><p>参数使用例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits = [<span class="string">'grape'</span>, <span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'Grape'</span>, <span class="string">'Apple'</span>, <span class="string">'Banana'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits.sort()  <span class="comment"># 默认</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits  <span class="comment"># 参数本身改变了</span></span><br><span class="line">[<span class="string">'Apple'</span>, <span class="string">'Banana'</span>, <span class="string">'Grape'</span>, <span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'grape'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits.sort(reverse=<span class="literal">True</span>)  <span class="comment"># 降序</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits</span><br><span class="line">[<span class="string">'grape'</span>, <span class="string">'banana'</span>, <span class="string">'apple'</span>, <span class="string">'Grape'</span>, <span class="string">'Banana'</span>, <span class="string">'Apple'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits.sort(key=len)  <span class="comment"># 按照字符串长度排序</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits</span><br><span class="line">[<span class="string">'grape'</span>, <span class="string">'apple'</span>, <span class="string">'Grape'</span>, <span class="string">'Apple'</span>, <span class="string">'banana'</span>, <span class="string">'Banana'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits.sort(key=str.lower)  <span class="comment"># 按照小写字母的大小排序</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits</span><br><span class="line">[<span class="string">'apple'</span>, <span class="string">'Apple'</span>, <span class="string">'banana'</span>, <span class="string">'Banana'</span>, <span class="string">'grape'</span>, <span class="string">'Grape'</span>]</span><br></pre></td></tr></table></figure><p>sorted函数使用例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits = [<span class="string">'grape'</span>, <span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'Grape'</span>, <span class="string">'Apple'</span>, <span class="string">'Banana'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = sorted(fruits)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits  <span class="comment"># 参数不变</span></span><br><span class="line">[<span class="string">'grape'</span>, <span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'Grape'</span>, <span class="string">'Apple'</span>, <span class="string">'Banana'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r  <span class="comment"># 返回一个新列表</span></span><br><span class="line">[<span class="string">'Apple'</span>, <span class="string">'Banana'</span>, <span class="string">'Grape'</span>, <span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'grape'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = sorted(fruits)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r1 = sorted(tuple(fruits))  <span class="comment"># 参数是不可变序列（元组）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r2 = sorted(set(fruits))  <span class="comment"># 参数是集合</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r == r1 == r2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = [(<span class="string">'amily'</span>, <span class="number">12</span>), (<span class="string">'william'</span>, <span class="number">17</span>), (<span class="string">'joseph'</span>, <span class="number">16</span>), (<span class="string">'olivia'</span>, <span class="number">13</span>), (<span class="string">'amily'</span>, <span class="number">11</span>), (<span class="string">'olivia'</span>, <span class="number">17</span>)]  <span class="comment"># (name, age)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = sorted(m)  <span class="comment"># 默认参数：按name升序排列，name完全一样，按age升序排列</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r</span><br><span class="line">[(<span class="string">'amily'</span>, <span class="number">11</span>), (<span class="string">'amily'</span>, <span class="number">12</span>), (<span class="string">'joseph'</span>, <span class="number">16</span>), (<span class="string">'olivia'</span>, <span class="number">13</span>), (<span class="string">'olivia'</span>, <span class="number">17</span>), (<span class="string">'william'</span>, <span class="number">17</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = sorted(m, key=<span class="keyword">lambda</span> i: i[<span class="number">1</span>])  <span class="comment"># 按年龄</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r</span><br><span class="line">[(<span class="string">'amily'</span>, <span class="number">11</span>), (<span class="string">'amily'</span>, <span class="number">12</span>), (<span class="string">'olivia'</span>, <span class="number">13</span>), (<span class="string">'joseph'</span>, <span class="number">16</span>), (<span class="string">'william'</span>, <span class="number">17</span>), (<span class="string">'olivia'</span>, <span class="number">17</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = sorted(m, key=<span class="keyword">lambda</span> i: (i[<span class="number">1</span>], i[<span class="number">0</span>]))  <span class="comment"># 先按年龄排序，年龄相同时按名字排序</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r</span><br><span class="line">[(<span class="string">'amily'</span>, <span class="number">11</span>), (<span class="string">'amily'</span>, <span class="number">12</span>), (<span class="string">'olivia'</span>, <span class="number">13</span>), (<span class="string">'joseph'</span>, <span class="number">16</span>), (<span class="string">'olivia'</span>, <span class="number">17</span>), (<span class="string">'william'</span>, <span class="number">17</span>)]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> sorted </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>切片</title>
      <link href="/notes/fluent-python/slicing/"/>
      <url>/notes/fluent-python/slicing/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么切片和区间会忽略最后一个元素">为什么切片和区间会忽略最后一个元素</h1><p>在切片和区间操作里不包含区间范围的最后一个元素是Python的风格，这个习惯符合Python、C和其他语言里以0作为起始下标的传统。这样做带来的好处如下。</p><ul><li>当只有最后一个位置信息时，可以快速看出切片和区间里有几个元素：range(3)和my_list[:3]都返回3个元素。</li><li>当起止位置信息都可见时，可以快速计算出切片和区间的长度，用后一个数减去第一个下标(stop - start)即可。</li><li>可以利用任意一个下标来把序列分割成不重叠的两部分，只要写成my_list[:x]和my_list[x:]就可以了。</li></ul><h1 id="切片示例">切片示例</h1><p>在Python里，像列表（list）、元组（tuple）和字符串（str）这类序列类型都支持切片操作。</p><p>常用用法：<code>my_list[start:stop]</code></p><p>理解：取出下标从start到stop - 1之间的所有元素，组成新列表。</p><p>相当于：<code>[my_list[i] for i in range(start, stop)]</code></p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>li = list(range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[<span class="number">0</span>:len(li)]  <span class="comment"># 拷贝整个列表</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[:]  <span class="comment"># 常用写法，更简单易读</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[<span class="number">1</span>:]  <span class="comment"># 从第1个元素切到最后一个元素</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[:<span class="number">5</span>]  <span class="comment"># 从第0个元素切到第4个元素</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[<span class="number">1</span>:<span class="number">5</span>] <span class="comment"># 从第0个元素切到第4个元素</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>更高级的：<code>my_list[start:stop:step]</code></p><p>理解：将my_list[start:stop]按序分组，每组step个元素，取出每组的第1个元素组成新列表。</p><p>相当于：<code>[my_list[i] for i in range(start, stop, step)]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[::<span class="number">1</span>]  <span class="comment"># 等价于 li[:]</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[::<span class="number">3</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[::<span class="number">-1</span>] <span class="comment"># step可以为负值，负值意味着反向取值</span></span><br><span class="line">[<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[<span class="number">5</span>:<span class="number">1</span>:<span class="number">-2</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><h1 id="切片对象">切片对象</h1><blockquote><p><code>class slice(stop)</code></p></blockquote><blockquote><p><code>class slice(start, stop[, step])</code></p></blockquote><p><code>a:b:c</code>这种用法只能作为索引或者下标用在[]中来返回一个切片对象：slice(a, b, c)。在对seq[start:stop:step]进行求值的时候，Python会调用<code>seq.__getitem__(slice(start, stop, step))</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>first_five = slice(<span class="number">5</span>)  <span class="comment"># 1个参数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[first_five]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>last_five = slice(len(li) - <span class="number">5</span>, len(li))  <span class="comment"># 2个参数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[last_five]</span><br><span class="line">[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>odd = slice(<span class="number">1</span>, len(li), <span class="number">2</span>)  <span class="comment"># 全部3个参数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[odd]</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><h1 id="给切片赋值">给切片赋值</h1><p>如果把切片放在赋值语句的左边，或把它作为del操作的对象，我们就可以对序列进行嫁接、切除或就地修改操作。</p><p>如果赋值的对象是一个切片，那么赋值语句的右侧必须是个可迭代对象。即便只有单独一个值，也要把它转换成可迭代的序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[<span class="number">2</span>:<span class="number">3</span>] = <span class="number">-2</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: can only assign an iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[<span class="number">2</span>:<span class="number">3</span>] = [<span class="number">-2</span>]  <span class="comment"># 必须可迭代</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[<span class="number">0</span>:<span class="number">6</span>] = [<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>, <span class="number">-4</span>, <span class="number">-5</span>]  <span class="comment"># 切除前6个元素，嫁接5个新元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li</span><br><span class="line">[<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>, <span class="number">-4</span>, <span class="number">-5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li = list(range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li[<span class="number">2</span>::<span class="number">2</span>] = [<span class="number">-2</span>, <span class="number">-4</span>, <span class="number">-6</span>, <span class="number">-8</span>]  <span class="comment"># 偶数改为负值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">3</span>, <span class="number">-4</span>, <span class="number">5</span>, <span class="number">-6</span>, <span class="number">7</span>, <span class="number">-8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> li[<span class="number">1</span>::<span class="number">2</span>]  <span class="comment"># 删除奇数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li</span><br><span class="line">[<span class="number">0</span>, <span class="number">-2</span>, <span class="number">-4</span>, <span class="number">-6</span>, <span class="number">-8</span>]</span><br></pre></td></tr></table></figure><h1 id="多维切片和省略">多维切片和省略</h1><p>[]运算符里还可以使用逗号分开的多个索引或者是切片，外部库NumPy里就用到了这个特性，二维的numpy.ndarray就可以用a[i, j]这种形式来获取，抑或是a[m:n, k:l]的方式来得到二维切片。要正确处理这种[]运算符的话，对象的特殊方法<code>__getitem__</code>和<code>__setitem__</code>需要以元组的形式来接收a[i, j]中的索引。也就是说，如果要得到a[i, j]的值，Python会调用<code>a.__getitem__((i, j))</code>。</p><p>Python内置的序列类型都是一维的，因此它们只支持单一的索引，成对出现的索引是没有用的。</p><p>省略（ellipsis）的正确书写方法是三个英文句号（<code>...</code>）。省略在Python解释器眼里是一个符号，而实际上它是Ellipsis对象的别名，而Ellipsis对象又是ellipsis类的单一实例（是的，你没看错，ellipsis是类名，全小写，而它的内置实例写作Ellipsis。这其实跟bool是小写，但是它的两个实例写作True和False异曲同工）。它可以当作切片规范的一部分，也可以用在函数的参数清单中，比如<code>f(a, ..., z)</code>，或<code>a[i:...]</code>。在NumPy中，<code>...</code>用作多维数组切片的快捷方式。如果x是四维数组，那么<code>x[i,...]</code>就是<code>x[i, :, :, :]</code>的缩写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">12</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(a)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">numpy</span>.<span class="title">ndarray</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">a</span>.<span class="title">shape</span>  # 查看维度</span></span><br><span class="line"><span class="class"><span class="params">(<span class="number">12</span>,)</span>  # 一维的含有12个元素的数组</span></span><br><span class="line">&gt;&gt;&gt; a.shape = 3, 4  # 将其转换为一个二维的数组</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.shape</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)  <span class="comment"># 二维，各维度分别含有3、4个元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>, <span class="number">1</span>]  <span class="comment"># 等价于a[0][1]</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>:, <span class="number">2</span>:]</span><br><span class="line">array([[ <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.shape = <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>  <span class="comment"># 转换为三维数组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>],</span><br><span class="line">        [ <span class="number">2</span>,  <span class="number">3</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">        [ <span class="number">6</span>,  <span class="number">7</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">11</span>]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>:, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">array([<span class="number">5</span>, <span class="number">9</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>, <span class="built_in">Ellipsis</span>]  <span class="comment"># 完整的取出第1个维度的1号元素</span></span><br><span class="line">array([[<span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">6</span>, <span class="number">7</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>...</span><br><span class="line"><span class="built_in">Ellipsis</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>, ...]  <span class="comment"># 完整的取出第1个维度的1号元素</span></span><br><span class="line">array([[<span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">6</span>, <span class="number">7</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>, :, :]</span><br><span class="line">array([[<span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">6</span>, <span class="number">7</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[..., <span class="number">1</span>]  <span class="comment"># 取出最后1个维度的1号元素</span></span><br><span class="line">array([[ <span class="number">1</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">5</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">9</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[..., <span class="number">1</span>, ...]  <span class="comment"># 不能包含多个ellipsis</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">IndexError: an index can only have a single ellipsis (<span class="string">'...'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> slicing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python map filter函数</title>
      <link href="/programming/python-map-filter-functions/"/>
      <url>/programming/python-map-filter-functions/</url>
      
        <content type="html"><![CDATA[<h1 id="map">map</h1><blockquote><p><code>map(function, iterable, ...)</code></p></blockquote><p>将iterable中的元素依次传入function，返回function的返回值。大致相当于</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span><span class="params">(function, *iterable)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> zip(*iterable):</span><br><span class="line">        <span class="keyword">yield</span> function(*e)</span><br></pre></td></tr></table></figure><a id="more"></a><p>例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(int, <span class="string">'0123456789'</span>))  <span class="comment"># 类型转换</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(<span class="keyword">lambda</span> x, y: x + y, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))  <span class="comment"># 对应两数相加</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]                     <span class="comment"># 当列表长度不一致时，按照最小的那个长度算</span></span><br></pre></td></tr></table></figure><p>可以用列表解析实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[int(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">'0123456789'</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x + y <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(range(<span class="number">1</span>, <span class="number">6</span>), range(<span class="number">1</span>, <span class="number">5</span>))]</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure><h1 id="filter">filter</h1><blockquote><p><code>filter(function, iterable)</code></p></blockquote><p>将iterable中的元素依次传入function，返回function的返回值为真时的元素。</p><p>当function != None时，相当于<code>(item for item in iterable if function(item))</code>；</p><p>当function == None时，相当于<code>(item for item in iterable if item)</code>。</p><p>例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, range(<span class="number">11</span>)))  <span class="comment"># 返回10以下的偶数</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><h1 id="组合使用">组合使用</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(str, filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span> ==<span class="number">0</span>, range(<span class="number">10</span>))))  <span class="comment"># map/filter组合</span></span><br><span class="line">[<span class="string">'0'</span>, <span class="string">'2'</span>, <span class="string">'4'</span>, <span class="string">'6'</span>, <span class="string">'8'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[str(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>]  <span class="comment"># 列表解析</span></span><br><span class="line">[<span class="string">'0'</span>, <span class="string">'2'</span>, <span class="string">'4'</span>, <span class="string">'6'</span>, <span class="string">'8'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, map(int, <span class="string">'0123456789'</span>)))</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[int(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">'0123456789'</span> <span class="keyword">if</span> int(i) % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用特殊方法</title>
      <link href="/notes/fluent-python/how-special-methods-are-used/"/>
      <url>/notes/fluent-python/how-special-methods-are-used/</url>
      
        <content type="html"><![CDATA[<p>不管在哪种框架下写程序，都会花费大量时间去实现那些会被框架本身调用的方法，Python也不例外。Python解释器碰到特殊的句法时，会使用特殊方法去激活一些基本的对象操作，这些特殊方法的名字以两个下划线开头，以两个下划线结尾(例如<code>__getitem__</code>)。比如obj[key]的背后就是<code>__getitem__</code>方法，为了能求得my_collection[key]的值，解释器实际上会调用<code>my_collection.__getitem__(key)</code>。</p><p>这些特殊方法名能让你自己的对象实现和支持以下的语言架构，并与之交互：</p><ul><li>迭代</li><li>集合类</li><li>属性访问</li><li>运算符重载</li><li>函数和方法的调用</li><li>对象的创建和销毁</li><li>字符串表示形式和格式化</li><li>管理上下文（即with块）</li></ul><a id="more"></a><h1 id="一摞python风格的纸牌">一摞Python风格的纸牌</h1><figure class="highlight python"><figcaption><span>french_deck.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">Card = collections.namedtuple(<span class="string">'Card'</span>, [<span class="string">'rank'</span>, <span class="string">'suit'</span>])</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrenchDeck</span>:</span></span><br><span class="line">    ranks = [str(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">11</span>)] + list(<span class="string">'JQKA'</span>)</span><br><span class="line">    suits = <span class="string">'spades diamonds clubs hearts'</span>.split()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'__init__'</span>)</span><br><span class="line">        self._cards = [Card(rank, suit) <span class="keyword">for</span> suit <span class="keyword">in</span> self.suits</span><br><span class="line">                       <span class="keyword">for</span> rank <span class="keyword">in</span> self.ranks]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'__len__'</span>)</span><br><span class="line">        <span class="keyword">return</span> len(self._cards)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        print(<span class="string">'__getitem__'</span>)</span><br><span class="line">        <span class="keyword">return</span> self._cards[item]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        print(<span class="string">'__setitem__'</span>)</span><br><span class="line">        self._cards[key] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'__iter__'</span>)</span><br><span class="line"></span><br><span class="line">suit_values = dict(spades=<span class="number">3</span>, hearts=<span class="number">2</span>, diamonds=<span class="number">1</span>, clubs=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spades_high</span><span class="params">(card)</span>:</span></span><br><span class="line">    <span class="comment"># 按照常规，用点数来判定扑克牌的大小，2 最小、A 最大；</span></span><br><span class="line">    <span class="comment"># 同时还要加上对花色的判定，黑桃最大、红桃次之、方块再次、梅花最小。</span></span><br><span class="line">    rank_value = FrenchDeck.ranks.index(card.rank)</span><br><span class="line">    <span class="keyword">return</span> rank_value * len(suit_values) + suit_values[card.suit]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> french_deck <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> random <span class="keyword">import</span> choice, randrange</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck = FrenchDeck()  <span class="comment"># 初始化</span></span><br><span class="line">__init__</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(deck)  <span class="comment"># len</span></span><br><span class="line">__len__</span><br><span class="line"><span class="number">52</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[<span class="number">0</span>]  <span class="comment"># 下标访问</span></span><br><span class="line">__getitem__</span><br><span class="line">Card(rank=<span class="string">'2'</span>, suit=<span class="string">'spades'</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>choice(deck)  <span class="comment"># 随机抽取</span></span><br><span class="line">__len__</span><br><span class="line">__getitem__</span><br><span class="line">Card(rank=<span class="string">'K'</span>, suit=<span class="string">'diamonds'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[randrange(<span class="number">0</span>, len(deck))]  <span class="comment"># 随机抽取等价替代</span></span><br><span class="line">__len__</span><br><span class="line">__getitem__</span><br><span class="line">Card(rank=<span class="string">'8'</span>, suit=<span class="string">'clubs'</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> card <span class="keyword">in</span> deck:  <span class="comment"># 迭代，无需调用__len__方法</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line">__getitem__</span><br><span class="line"><span class="comment"># 中间全都是__getitem__ #</span></span><br><span class="line">__getitem__</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[<span class="number">-2</span>:]  <span class="comment"># 切片，注意只调用一次__getitem__方法</span></span><br><span class="line">__getitem__</span><br><span class="line">[Card(rank=<span class="string">'K'</span>, suit=<span class="string">'hearts'</span>), Card(rank=<span class="string">'A'</span>, suit=<span class="string">'hearts'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[<span class="number">12</span>::<span class="number">13</span>]  <span class="comment"># 从第12张牌开始，每隔13张取一张牌</span></span><br><span class="line">__getitem__</span><br><span class="line">[Card(rank=<span class="string">'A'</span>, suit=<span class="string">'spades'</span>), Card(rank=<span class="string">'A'</span>, suit=<span class="string">'diamonds'</span>), Card(rank=<span class="string">'A'</span>, suit=<span class="string">'clubs'</span>), Card(rank=<span class="string">'A'</span>, suit=<span class="string">'hearts'</span>)]</span><br></pre></td></tr></table></figure><p>迭代通常是隐式的，譬如说一个集合类型没有实现<code>__contains__</code>方法，那么in运算符就会按顺序做一次迭代搜索。于是，in运算符可以用在我们的FrenchDeck类上，因为它是可迭代的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[<span class="number">2</span>]</span><br><span class="line">__getitem__</span><br><span class="line">Card(rank=<span class="string">'4'</span>, suit=<span class="string">'spades'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Card(<span class="string">'4'</span>, <span class="string">'spades'</span>) <span class="keyword">in</span> deck  <span class="comment"># in，没有实现__contains__方式时，按顺序查找</span></span><br><span class="line">__getitem__</span><br><span class="line">__getitem__</span><br><span class="line">__getitem__</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> card <span class="keyword">in</span> sorted(deck, key=spades_high):  <span class="comment"># sorted</span></span><br><span class="line"><span class="meta">... </span>    print(card)</span><br><span class="line">...</span><br><span class="line">__len__</span><br><span class="line">__getitem__</span><br><span class="line"><span class="comment"># 省略 #</span></span><br><span class="line">__getitem__</span><br><span class="line">Card(rank=<span class="string">'2'</span>, suit=<span class="string">'clubs'</span>)</span><br><span class="line">Card(rank=<span class="string">'2'</span>, suit=<span class="string">'diamonds'</span>)</span><br><span class="line"><span class="comment"># 省略 #</span></span><br><span class="line">Card(rank=<span class="string">'A'</span>, suit=<span class="string">'hearts'</span>)</span><br><span class="line">Card(rank=<span class="string">'A'</span>, suit=<span class="string">'spades'</span>)</span><br></pre></td></tr></table></figure><p>虽然FrenchDeck隐式地继承了object类，但功能却不是继承而来的。我们通过数据模型和一些合成来实现这些功能。通过实现<code>__len__</code>和<code>__getitem__</code>这两个特殊方法，FrenchDeck就跟一个Python自有的序列数据类型一样，可以体现出Python的核心语言特性（例如迭代和切片）。同时这个类还可以用于标准库中诸如random.choice、reversed和sorted这些函数。另外，对合成的运用使得<code>__len__</code>和<code>__getitem__</code>的具体实现可以代理给self._cards这个Python列表（即list对象）。</p><table><thead><tr class="header"><th>操作</th><th>底层支持</th></tr></thead><tbody><tr class="odd"><td>初始化</td><td><code>__init__</code></td></tr><tr class="even"><td>获取长度</td><td><code>__len__</code></td></tr><tr class="odd"><td>下标访问</td><td><code>__getitem__</code></td></tr><tr class="even"><td>随机抽取</td><td><code>__len__</code>, <code>__getitem__</code></td></tr><tr class="odd"><td>查询</td><td><code>__getitem__</code>（没有实现<code>__contains__</code>方法时，in运算符会做一次顺序搜索）</td></tr><tr class="even"><td>迭代</td><td><code>__getitem__</code>（调用次数与迭代次数有关，神奇的是不需要调用<code>__len__</code>）</td></tr><tr class="odd"><td>切片</td><td><code>__getitem__</code>（只调用一次，同样不需要调用<code>__len__</code>）</td></tr><tr class="even"><td>排序</td><td><code>__len__</code>（一次）, <code>__getitem__</code>（调用次数与迭代次数有关）</td></tr></tbody></table><h1 id="如何使用特殊方法">如何使用特殊方法</h1><p>首先明确一点，特殊方法的存在是为了被Python解释器调用的，你自己并不需要调用它们。也就是说没有<code>my_object.__len__()</code>这种写法，而应该使用len(my_object)。在执行len(my_object)的时候，如果my_object是一个自定义类的对象，那么Python会自己去调用其中由你实现的<code>__len__</code>方法。</p><p>然而如果是Python内置的类型，比如列表(list)、字符串(str)、字节序列(bytearray)等，那么CPython会抄个近路，<code>__len__</code>实际上会直接返回PyVarObject里的ob_size属性。PyVarObject是表示内存中长度可变的内置对象的C语言结构体。直接读取这个值比调用一个方法要快很多。</p><p>很多时候，特殊方法的调用是隐式的，比如for i in x这个语句，背后其实用的是iter(x)，而这个函数的背后则是<code>x.__iter__()</code>方法。当然<strong>前提</strong>是这个方法在x中被实现了。</p><p>通常你的代码无需直接使用特殊方法。除非有大量的元编程存在，直接调用特殊方法的频率应该远远低于你去实现它们的次数。唯一的例外可能是<code>__init__</code>方法，你的代码里可能经常会用到它，目的是在你自己的子类的<code>__init__</code>方法中调用超类的构造器。</p><p>通过内置的函数（例如len、iter、str，等等）来使用特殊方法是最好的选择。这些内置函数不仅会调用特殊方法，通常还提供额外的好处，而且对于内置的类来说，它们的速度更快。</p><p>不要自己想当然地随意添加特殊方法，比如<code>__foo__</code>之类的，因为虽然现在这个名字没有被Python内部使用，以后就不一定了。</p><h2 id="模拟数值类型">模拟数值类型</h2><p><img data-src="/uploads/posts/fluent-python/example-of-2d-vector-addition.png" title="一个二维向量加法的例子"></p><p>一个二维向量加法的例子，Vector(2, 4) + Vector(2, 1) = Vector(4, 5)</p><p>向量加法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v2 = Vector(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + v2</span><br><span class="line">Vector(<span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>向量的模：abs是一个内置函数，如果输入是整数或者浮点数，它返回的是输入值的绝对值；如果输入是复数(complex number)，那么返回这个复数的模。为了保持一致性，我们的API在碰到abs函数的时候，也应该返回该向量的模。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v = Vector(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>abs(v)</span><br><span class="line"><span class="number">5.0</span></span><br></pre></td></tr></table></figure><p>标量乘法（即向量与数的乘法，得到的结果向量的方向与原向量一致，模变大）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v * <span class="number">3</span></span><br><span class="line">Vector(<span class="number">9</span>, <span class="number">12</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>abs(v * <span class="number">3</span>)</span><br><span class="line"><span class="number">15.0</span></span><br></pre></td></tr></table></figure><h2 id="实现">实现</h2><figure class="highlight python"><figcaption><span>vector.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> hypot</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x=<span class="number">0</span>, y=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Vector(%r, %r)'</span> % (self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> hypot(self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(self.x <span class="keyword">or</span> self.y)  <span class="comment"># 更高效</span></span><br><span class="line">        <span class="comment"># return bool(abs(self))</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        x = self.x + other.x</span><br><span class="line">        y = self.y + other.y</span><br><span class="line">        <span class="keyword">return</span> Vector(x, y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, scalar)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Vector(self.x * scalar, self.y * scalar)</span><br></pre></td></tr></table></figure><h2 id="自定义的布尔值">自定义的布尔值</h2><p>尽管Python里有bool类型，但实际上任何对象都可以用于需要布尔值的上下文中（比如if或while语句，或者and、or和not运算符）。为了判定一个值x为真还是为假，Python会调用bool(x)，这个函数只能返回True或者False。</p><p>默认情况下，我们自己定义的类的实例总被认为是真的，除非这个类对<code>__bool__</code>或者<code>__len__</code>函数有自己的实现。bool(x)的背后是调用<code>x.__bool__()</code>的结果；如果不存在<code>__bool__</code>方法，那么bool(x)会尝试调用<code>x.__len__()</code>。若返回0，则bool会返回False；否则返回True。</p><table><thead><tr class="header"><th>操作</th><th>底层支持</th></tr></thead><tbody><tr class="odd"><td>取绝对值或取模</td><td><code>__abs__</code></td></tr><tr class="even"><td>布尔运算</td><td><code>__bool__</code>（优先调用），<code>__len__</code>（不存在<code>__bool__</code>时调用）</td></tr><tr class="odd"><td>加法</td><td><code>__add__</code></td></tr><tr class="even"><td>乘法</td><td><code>__mul__</code></td></tr></tbody></table><h1 id="特殊方法一览">特殊方法一览</h1><p>Python语言参考手册中的<a href="https://docs.python.org/3/reference/datamodel.html" target="_blank" rel="noopener">“Data Model”</a>一章列出了83个特殊方法的名字，其中47个用于实现算术运算、位运算和比较操作。</p><h2 id="跟运算无关的特殊方法">跟运算无关的特殊方法</h2><table><thead><tr class="header"><th>类别</th><th>方法名</th></tr></thead><tbody><tr class="odd"><td>字符串 / 字节序列表示形式</td><td><code>__repr__</code>、<code>__str__</code>、<code>__format__</code>、<code>__bytes__</code></td></tr><tr class="even"><td>数值转换</td><td><code>__abs__</code>、<code>__bool__</code>、<code>__complex__</code>、<code>__int__</code>、<code>__float__</code>、<code>__hash__</code>、<code>__index__</code></td></tr><tr class="odd"><td>集合模拟</td><td><code>__len__</code>、<code>__getitem__</code>、<code>__setitem__</code>、<code>__delitem__</code>、<code>__contains__</code></td></tr><tr class="even"><td>迭代枚举</td><td><code>__iter__</code>、<code>__reversed__</code>、<code>__next__</code></td></tr><tr class="odd"><td>可调用模拟</td><td><code>__call__</code></td></tr><tr class="even"><td>上下文管理</td><td><code>__enter__</code>、<code>__exit__</code></td></tr><tr class="odd"><td>实例创建和销毁</td><td><code>__new__</code>、<code>__init__</code>、<code>__del__</code></td></tr><tr class="even"><td>属性管理</td><td><code>__getattr__</code>、<code>__getattribute__</code>、<code>__setattr__</code>、<code>__delattr__</code>、<code>__dir__</code></td></tr><tr class="odd"><td>属性描述符</td><td><code>__get__</code>、<code>__set__</code>、<code>__delete__</code></td></tr><tr class="even"><td>跟类相关的服务</td><td><code>__prepare__</code>、<code>__instancecheck__</code>、<code>__subclasscheck__</code></td></tr></tbody></table><h2 id="跟运算符相关的特殊方法">跟运算符相关的特殊方法</h2><table><colgroup><col style="width: 23%"><col style="width: 76%"></colgroup><thead><tr class="header"><th>类别</th><th>方法名和对应的运算符</th></tr></thead><tbody><tr class="odd"><td>一元运算符</td><td><code>__neg__ -</code>、<code>__pos__ +</code>、<code>__abs__ abs()</code></td></tr><tr class="even"><td>比较运算符</td><td><code>__lt__ &lt;</code>、<code>__le__ &lt;=</code>、<code>__eq__ ==</code>、<code>__ne__ !=</code>、<code>__gt__ &gt;</code>、<code>__ge__ &gt;=</code></td></tr><tr class="odd"><td>算术运算符</td><td><code>__add__ +</code>、<code>__sub__ -</code>、<code>__mul__ *</code>、<code>__truediv__ /</code>、<code>__floordiv__ //</code>、<code>__mod__ %</code>、<code>__divmod__ divmod()</code>、<code>__pow__ **</code>或<code>pow()</code>、<code>__round__ round()</code></td></tr><tr class="even"><td>反向算术运算符</td><td><code>__radd__</code>、<code>__rsub__</code>、<code>__rmul__</code>、<code>__rtruediv__</code>、 <code>__rfloordiv__</code>、<code>__rmod__</code>、<code>__rdivmod__</code>、<code>__rpow__</code></td></tr><tr class="odd"><td>增量赋值算术运算符</td><td><code>__iadd__</code>、<code>__isub__</code>、<code>__imul__</code>、<code>__itruediv__</code>、 <code>__ifloordiv__</code>、<code>__imod__</code>、<code>__ipow__</code></td></tr><tr class="even"><td>位运算符</td><td><code>__invert__ ~</code>、<code>__lshift__ &lt;&lt;</code>、<code>__rshift__ &gt;&gt;</code>、<code>__and__ &amp;</code>、<code>__or__ |</code>、<code>__xor__ ^</code></td></tr><tr class="odd"><td>反向位运算符</td><td><code>__rlshift__</code>、<code>__rrshift__</code>、<code>__rand__</code>、<code>__rxor__</code>、<code>__ror__</code></td></tr><tr class="even"><td>增量赋值位运算符</td><td><code>__ilshift__</code>、<code>__irshift__</code>、<code>__iand__</code>、<code>__ixor__</code>、<code>__ior__</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
            <tag> special methods </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jupyter Notebook ModuleNotFoundError</title>
      <link href="/programming/jupyter-notebook-ModuleNotFoundError/"/>
      <url>/programming/jupyter-notebook-ModuleNotFoundError/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_34650787/article/details/83304080" target="_blank" rel="noopener">点击查看原文</a></p><p>可能原因：安装了多个Python版本，终端和Jupyter Notebook使用的不是同一个Python。</p><p>在Terminal和Jupyter Notebook中分别执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.executable</span><br></pre></td></tr></table></figure><p>比较各自的输出路径。若不相同，例如</p><p>Terminal：<code>/Users/cws/opt/anaconda3/bin/python</code></p><p>Notebook：<code>/usr/local/bin/python3.6</code></p><p>则可按照下述操作解决此问题。打开Terminal，</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(base) MacBook-Pro:~ cws$ jupyter kernelspec list</span><br><span class="line">Available kernels:  <span class="comment"># 列出所有内核</span></span><br><span class="line">  python36    /Users/cws/Library/Jupyter/kernels/python36</span><br><span class="line">  python3     /Library/Frameworks/Python.framework/Versions/<span class="number">3.6</span>/share/jupyter/kernels/python3</span><br></pre></td></tr></table></figure><p>根据自己正在使用的内核，例如python3，进入对应目录/Library/.../python3，修改配置文件kernel.json</p><figure class="highlight diff"><figcaption><span>kernel.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> "argv": [</span><br><span class="line"><span class="deletion">- "python",</span></span><br><span class="line"><span class="addition">+ "/Users/cws/opt/anaconda3/bin/python",</span></span><br><span class="line">  "-m",</span><br><span class="line">  "ipykernel_launcher",</span><br><span class="line">  "-f",</span><br><span class="line">  "&#123;connection_file&#125;"</span><br><span class="line"> ],</span><br><span class="line"> "display_name": "Python 3",</span><br><span class="line"> "language": "python"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后保存，重启Notebook。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> jupyter notebook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树</title>
      <link href="/notes/introduction-to-algorithms/red-black-trees/"/>
      <url>/notes/introduction-to-algorithms/red-black-trees/</url>
      
        <content type="html"><![CDATA[<h1 id="红黑树">红黑树</h1><p>红黑树（red-black tree）是一棵二叉搜索树，是许多平衡搜索树的一种。它在每个节点上增加了一个存储位来表示结点的颜色，可以是RED或BLACK。通过对任何一条从根到叶子的简单路径上各个结点的颜色进行约束，<strong>红黑树确保没有一条路径会比其他路径长出2倍</strong>，因而是近似于平衡的。</p><h1 id="性质">性质</h1><p>树中每个结点包含5个属性：color、key、left、right和p。</p><p>一棵红黑树是满足下面<strong>红黑性质</strong>的二叉搜索树：</p><ol type="1"><li>每个结点或是红色的，或是黑色的。</li><li>根节点是黑色的。</li><li>每个叶子结点（NIL）是黑色的。</li><li>如果一个结点是红色的，则它的两个子节点都是黑色的。</li><li>对每个结点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色结点。</li></ol><a id="more"></a><p>为了便于处理红黑树中的边界条件，使用一个哨兵来代替NIL。哨兵的color=BLACK，其他属性的p、left、right、key的取值不重要。尽管可以为树中每一个NIL（叶子结点）新增一个不同的哨兵结点，但会浪费空间。取而代之的是，使用一个哨兵T.nil​来代表所有的NIL。如图(b)可以用更少的空间等价地表示图(a)。其中黑色结点用黑色、红色节点用灰色表示。</p><p><strong>黑高</strong>（black-height）：从某个结点x出发（不含该结点）到达一个叶节点的任意一条简单路径上的黑色结点个数（根据性质5可知结点的黑高是唯一的）称为该结点的黑高，记为bh(x)​。定义红黑树的黑高为其根节点的黑高。如图(a)所示的红黑树中，红黑树的黑高为3。图(c)省略了哨兵，多数时候采用这种更简洁的画法。</p><p><img data-src="/uploads/posts/introduction-to-algorithms/red-black-tree.png"></p><blockquote><p>引理13.1</p><p>一棵有n个内部结点的红黑树的高度至多为<span class="math inline">\(2\lg(n+1)\)</span>。</p></blockquote><p><strong>证明</strong>： 先证明以任一结点x为根的子树中至少包含<span class="math inline">\(2^{bh(x)}-1\)</span>个内部结点。使用归纳法证明。</p><ol type="1"><li><p>如果x的高度为0，则x为叶节点（T.nil)，且以x为根节点的子树至少包含<span class="math inline">\(2^{bh(x)}-1=2^0-1=0\)</span>个内部结点。</p></li><li><p>如果x的高度为h(h&gt;0)，假设以x为根节点的子树至少包含<span class="math inline">\(2^{bh(x)}-1\)</span>个内部结点成立。</p></li><li><p>考虑高度h+1且有两个子节点的内部节点<span class="math inline">\(x^\prime\)</span>。子节点的高度为h，黑高为</p><ul><li><span class="math inline">\(bh(x^\prime)\)</span>（当子节点为红色时），</li><li>或<span class="math inline">\(bh(x^\prime)-1\)</span>（当子节点为黑色时）。</li></ul><p>根据归纳假设，以子节点为根节点的子树至少包含<span class="math inline">\(2^{bh(x)-1}-1\)</span>个结点。于是，以<span class="math inline">\(x^\prime\)</span>为根的子树至少包含<span class="math inline">\((2^{bh(x)-1}-1)+(2^{bh(x)-1}-1)+1=2^{bh(x)}-1\)</span>个内部结点。</p></li></ol><p>之后，证明引理：设h为树的高度。根据性质4，从根到叶节点的任何一条简单路径上都至少有一半的结点为黑色。因此，根的黑高至少为h/2，于是有<span class="math inline">\(n\ge2^{h/2}-1\)</span>，将1移到左边，再对两边取对数，得到<span class="math inline">\(h\le2\lg(n+1)\)</span>。</p><h1 id="旋转">旋转</h1><p>搜索树操作TREE-INSERT和TREE-DELETE在含n个关键字的红黑树上，运行花费时间为<span class="math inline">\(O(\lg{n})\)</span>。由于这两个操作对树做了修改，结果可能违反红黑性质。为了维护这些性质，必须要改变树中某些结点的颜色以及指针结构。</p><p>指针结构的修改是通过<strong>旋转</strong>（rotation）来完成的，这是一种能保持二叉搜索树性质的局部操作。<strong>在旋转操作中只有指针改变</strong>，其他所有属性都保持不变。下图给出了两种旋转：左旋和右旋。</p><ul><li>左旋：结点x取代<span class="math inline">\(\beta\)</span>成为y的左孩子结点，<span class="math inline">\(\beta\)</span>取代y成为x的右孩子结点。</li><li>右旋：结点y取代<span class="math inline">\(\beta\)</span>成为x的左孩子结点，<span class="math inline">\(\beta\)</span>取代x成为y的左孩子结点。</li></ul><p><img data-src="/uploads/posts/introduction-to-algorithms/red-black-tree-rotation.png"></p><p>容易观察到，旋转前与旋转后各元素的大小顺序没有改变，都是<span class="math inline">\(\alpha\le{x}\le\beta\le{y}\le\gamma\)</span>。</p><p>在LEFT-ROTATE的伪代码中，假设<span class="math inline">\(x.right\ne{T.nil}\)</span>且根节点的父节点为T.nil。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LEFT-ROTATE(T, x):</span><br><span class="line">y = x.right              <span class="comment"># y的位置（结合上图理解）</span></span><br><span class="line">x.right = y.left         <span class="comment"># beta取代y成为x的右孩子</span></span><br><span class="line"><span class="keyword">if</span> y.left != T.nil:      <span class="comment"># 此时y.left还是beta结点</span></span><br><span class="line">    y.left.p = x         <span class="comment"># 修改beta的父节点为x</span></span><br><span class="line">y.p = x.p                <span class="comment"># 修改y的父节点</span></span><br><span class="line"><span class="keyword">if</span> x.p == T.nil:         <span class="comment"># 若x原本是根节点，y将变为树的根</span></span><br><span class="line">    T.root = y</span><br><span class="line"><span class="keyword">elif</span> x == x.p.left:      <span class="comment"># 若原本x是左孩子，y取代x后依旧是左孩子</span></span><br><span class="line">    x.p.left = y</span><br><span class="line"><span class="keyword">else</span>:                    <span class="comment"># 若原本x是右孩子，y取代x后依旧是右孩子</span></span><br><span class="line">    x.p.right = y</span><br><span class="line">y.left = x               <span class="comment"># x变为y的左孩子</span></span><br><span class="line">x.p = y                  <span class="comment"># 修改x的父节点为y</span></span><br></pre></td></tr></table></figure><p>RIGHT-ROTATE操作的代码是对称的。它们都在O(1)时间内运行完成。</p><p><img data-src="/uploads/posts/introduction-to-algorithms/red-black-tree-left-rotate.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RIGHT-ROTATE(T, x):</span><br><span class="line">y = x.p</span><br><span class="line">y.left = x.right</span><br><span class="line"><span class="keyword">if</span> x.right != T.nil:</span><br><span class="line">    x.right.p = y</span><br><span class="line">x.p = y.p</span><br><span class="line"><span class="keyword">if</span> y.p == T.nil:</span><br><span class="line">    T.root = x</span><br><span class="line"><span class="keyword">elif</span> y == y.p.left:</span><br><span class="line">    y.p.left = x</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    y.p.right = x</span><br><span class="line">x.right = y</span><br><span class="line">y.p = x</span><br></pre></td></tr></table></figure><h1 id="插入">插入</h1><p>利用二叉搜索树的插入过程，略作修改来将结点z插入树T内，就好像T是一棵普通的二叉搜索树一样，然后将z着为红色。为了保证红黑性质能继续保持，调用一个辅助程序RB-INSERT-FIXUP来对结点重新着色并旋转。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">RB-INSERT(T, z):</span><br><span class="line">y = T.nil             <span class="comment"># 与普通的二叉搜索树不同，此处y指向哨兵</span></span><br><span class="line">x = T.root            <span class="comment"># 寻找z的插入位置</span></span><br><span class="line"><span class="keyword">while</span> x != T.nil:</span><br><span class="line">    y = x</span><br><span class="line">    <span class="keyword">if</span> z.key &lt; x.key:</span><br><span class="line">        x = x.left</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x = x.right</span><br><span class="line">z.p = y               <span class="comment"># 插入结点z</span></span><br><span class="line"><span class="keyword">if</span> y == T.nil:</span><br><span class="line">    T.root = z</span><br><span class="line"><span class="keyword">elif</span> z.key &lt; y.key:</span><br><span class="line">    y.left = z</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    y.right = z</span><br><span class="line">z.left = T.nil        <span class="comment"># 设置新节点的左右孩子为哨兵结点，以保持合理的树结构</span></span><br><span class="line">z.right = T.nil</span><br><span class="line">z.color = RED         <span class="comment"># 新插入节点着红色</span></span><br><span class="line">RB-INSERT-FIXUP(T, z) <span class="comment"># 辅助程序，对结点重新着色并旋转以维护红黑性质</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RB-INSERT-FIXUP(T, z):</span><br><span class="line"><span class="keyword">while</span> z.p.color == RED:        <span class="comment"># z的父节点也为红色，违反性质4</span></span><br><span class="line">    <span class="keyword">if</span> z.p == z.p.p.left:      <span class="comment"># 如果z的父节点是左孩子结点</span></span><br><span class="line">        y = z.p.p.right        <span class="comment"># z的叔结点(父节点的另一个兄弟结点)</span></span><br><span class="line">        <span class="keyword">if</span> y.color == RED:        <span class="comment"># 情况1：z的叔结点y也是红色的</span></span><br><span class="line">            z.p.color = BLACK          <span class="comment"># z的父节点涂黑</span></span><br><span class="line">            y.color = BLACK            <span class="comment"># z的叔结点也涂黑</span></span><br><span class="line">            z.p.p.color = RED          <span class="comment"># z的祖父结点涂红(将祖父结点涂红可能违反性质4)</span></span><br><span class="line">            z = z.p.p                  <span class="comment"># z指针上升至祖父结点，等候下一次循环修复性质</span></span><br><span class="line">        <span class="keyword">elif</span> z == z.p.right:      <span class="comment"># 情况2：叔结点非红且z是右孩子结点</span></span><br><span class="line">            z = z.p                    <span class="comment"># 注意此时无论情况1是否发生，z的父节点都是红色</span></span><br><span class="line">            LEFT-ROTATE(T, z)          <span class="comment"># 左旋，转为情况3</span></span><br><span class="line">                                  <span class="comment"># 情况3：叔结点非红且z是左孩子结点(注意左旋后z的位置变化)</span></span><br><span class="line">        z.p.color = BLACK         <span class="comment"># 父节点涂黑</span></span><br><span class="line">        z.p.p.color = RED         <span class="comment"># 祖父结点涂红</span></span><br><span class="line">        RIGHT-ROTATE(T, z.p.p)    <span class="comment"># 右旋</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        same <span class="keyword">as</span> then clause <span class="keyword">with</span> <span class="string">"right"</span> <span class="keyword">and</span> <span class="string">"left"</span> exchanged</span><br><span class="line">T.root.color = BLACK              <span class="comment"># 根节点涂黑，修复性质2</span></span><br></pre></td></tr></table></figure><p>在调用RB-INSERT-FIXUP操作时，哪些红黑性质可能会被破坏呢？性质1（非红即黑）和性质3（叶子全黑）继续成立，因为新插入的红节点的两个子节点都是哨兵T.nil。性质5（黑高相等）也会成立，因为结点z代替了黑色的哨兵结点，并且z本身是红结点且有哨兵结点。仅可能被破坏的就是性质2（根节点为黑色）和性质4（红节点不能有红孩子）。如果z是根节点，则破坏了性质2；如果z的父节点是红节点，则破坏了性质4。</p><p>当违反性质4时，z与父节点z.p都时红色，此时可能发生的情况如下：</p><ul><li>情况1：z的叔结点y是红色的。通过重新着色修复性质。</li><li>z的叔结点y是黑色：<ul><li>情况2：z是一个右孩子。通过左旋转化为情况3。（表明这几种情况不是完全独立的）</li><li>情况3：z是一个左孩子。通过重新着色和右旋修复性质。</li></ul></li></ul><p>下图给出一个范例，显示在一棵红黑树上RB-INSERT-FIXUP如何操作。</p><p><img data-src="/uploads/posts/introduction-to-algorithms/red-black-tree-insert-fixup.png"></p><p>由于一棵有n个结点的红黑树的高度为<span class="math inline">\(O(\lg{n})\)</span>，因此RB-INSERT的插入操作要花费<span class="math inline">\(O(\lg{n})\)</span>时间。在RB-INSERT-FIXUP中，仅当情况1发生，然后指针z沿着树上升2层，while循环才会重复执行。所以while循环可能被执行的总次数为<span class="math inline">\(O(\lg{n})\)</span>。因此，RB-INSERT总共花费<span class="math inline">\(O(\lg{n})\)</span>时间。此外，该程序所做的旋转不超过2次，因为只要执行了情况2（先左旋后右旋，旋转两次）或情况3（一次右旋），while循环就结束了。</p><h1 id="删除">删除</h1><p>从一棵红黑树中删除结点的过程是基于二叉搜索树的删除过程而来的。首先，需要特别设计一个子过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RB-TRANSPLANT(T, u, v): <span class="comment"># 用根节点为v的子树替换根节点为u的子树</span></span><br><span class="line"><span class="keyword">if</span> u.p == T.nil:        <span class="comment"># 若u为根结点，只需改变树的根指针即可</span></span><br><span class="line">    T.root = v</span><br><span class="line"><span class="keyword">elif</span> u == u.p.left:     <span class="comment"># 若u是左孩子</span></span><br><span class="line">    u.p.left = v        <span class="comment"># 移植v</span></span><br><span class="line"><span class="keyword">else</span>:                   <span class="comment"># 若u是右孩子</span></span><br><span class="line">    u.p.right = v</span><br><span class="line">v.p = u.p               <span class="comment"># 无条件执行，因为红黑树所有结点(包括哨兵结点)都有父节点属性</span></span><br></pre></td></tr></table></figure><p>过程RB-DELETE与TREE-DELETE类似，两个过程具有相同的基本结构。在RB-DELETE中能够找到TREE-DELETE的每一行语句（其中NIL被替换成了T.nil，TRANSPLANT换成了RB-TRANSPLANT），其执行的条件相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">RB-DELETE(T, z):</span><br><span class="line">y = z                             <span class="comment"># y为从树中删除的结点或者移至树内的结点</span></span><br><span class="line">y-original-color = y.color        <span class="comment"># 记录y的原始颜色</span></span><br><span class="line"><span class="keyword">if</span> z.left == T.nil:               <span class="comment"># 情况(a)：左孩子为空</span></span><br><span class="line">    x = z.right                     <span class="comment"># 移植后的结点可能会破坏红黑性质，用x记录其踪迹</span></span><br><span class="line">    RB-TRANSPLANT(T, z, z.right)    <span class="comment"># 用z的右孩子(可能为T.nil)替换z，达到删除z的目的</span></span><br><span class="line"><span class="keyword">elif</span> z.right == T.nil:            <span class="comment"># 情况(b)：右孩子为空</span></span><br><span class="line">    x = z.left                      <span class="comment"># 记录x的踪迹</span></span><br><span class="line">    RB-TRANSPLANT(T, z, z.left)     <span class="comment"># 用z的左孩子替换z</span></span><br><span class="line"><span class="keyword">else</span>:                             <span class="comment"># 情况(c)和(d)：有两个孩子，用z的后继结点y替换z</span></span><br><span class="line">    y = TREE-MINIMUM(z.right)       <span class="comment"># 查找后继结点y</span></span><br><span class="line">    y-original-color = y.color      <span class="comment"># 记录y的初始颜色</span></span><br><span class="line">    x = y.right                     <span class="comment"># 记录x的踪迹</span></span><br><span class="line">    <span class="keyword">if</span> y.p != z                   <span class="comment"># 情况(d)：后继结点y不是z的子节点</span></span><br><span class="line">        RB-TRANSPLANT(T, y, y.right)</span><br><span class="line">        y.right = z.right</span><br><span class="line">        y.right.p = y</span><br><span class="line">    <span class="keyword">else</span>:                         <span class="comment"># 情况(c)：y是z的子节点</span></span><br><span class="line">        x.p = y                     <span class="comment"># 没搞懂你存在的意义</span></span><br><span class="line">    RB-TRANSPLANT(T, z, y)</span><br><span class="line">    y.left = z.left</span><br><span class="line">    y.left.p = y</span><br><span class="line">    y.color = z.color             <span class="comment"># 删除z后，将替换z的结点y涂与z相同的颜色</span></span><br><span class="line"><span class="keyword">if</span> y-original-color == BLACK:  <span class="comment"># 如果原始为黑色，删除或移动y会破坏红黑性质；原始为红色，则不会</span></span><br><span class="line">    RB-DELETE-FIXUP(T, x)      <span class="comment"># 调用子过程修复红黑性质</span></span><br></pre></td></tr></table></figure><p>删除过程分为两部分：</p><ul><li><p>与二叉搜索树的删除操作相同的删除操作。下图描述了在二叉搜索树上删除结点时的4种情况，在红黑树上删除结点时同样考虑这4种情况。</p></li><li><p>修复红黑性质的RB-DELETE-FIXUP操作。为此，在删除结点时用变量y-original-color和x记录了必要的信息。</p></li></ul><p><img data-src="/uploads/posts/introduction-to-algorithms/binary-search-tree-delete.png"></p><p>在RB-DELETE的最后，如果结点y是黑色的，就有可能已经引入了一个或多个红黑性质被破坏的情况，所以调用RB-DELETE-FIXUP来恢复红黑性质。如果结点y是红色，当y被删除或移动时，红黑性质仍然保持，原因如下：</p><ol type="1"><li>树中的黑高没有变化。</li><li>不存在两个相邻的红色结点：<ul><li>情况(a)或情况(b)发生时（y与z相同），y是红色，则其子节点一定是黑色。y被删除后，其子节点替换y的位置。因此，不会出现两个相邻的红色结点。</li><li>情况(c)发生时（y是z的后继结点），y是红色，则y的右孩子x一定是黑色，y替换z后被涂成与z相同的颜色，y和x不会出现两个相邻的红色结点。</li><li>情况(d)的第一步替换中，y是红色，则x是黑色，x替换y之后不会出现两个相邻的红色结点。第二步替换中，y替换z并且被涂成与z相同的颜色。因此y与r不会是两个相邻的红色结点（y与r的颜色就是原来z与r的颜色）。</li></ul></li><li>y是红色，就不可能是根节点，所以根节点仍旧是黑色。</li></ol><p>如果结点y是黑色，则会产生三个问题，可以通过调用RB-DELETE-FIXUP进行修复。</p><ol type="1"><li>在情况(a)和(b)中，y（与z相同）是黑色，若y的一个红色的孩子（l或r）替换了y成为新的根节点，则违反了性质2（根节点为黑色）。</li><li>在情况(c)和(d)中，y是黑色，若y.p与x同时为红色，则删除z后出现y.p与x都是红色的情况，违反了性质4（红色结点的孩子是黑色的）。</li><li>y为黑色，移动y将导致包含y的任何简单路径上的黑结点个数少1。因此，y的任何祖先都不满足性质5（到叶节点的简单路径含有相同数目的黑色结点）。改正这一问题的办法是将现在占有y原来位置的结点x视为还有一重额外的黑色。当将黑色结点y删除或移动时，将其黑色“下推“给结点x。这个额外的黑色是针对结点x的，而不是反映在它的color属性上的。x.color仍然是RED（如果x是红黑色的）或BLACK（如果x是双重黑色的）。x时双重黑色或红黑色时，分别给包含x的简单路径上黑结点数贡献了2或1。</li></ol><p>下面是过程RB-DELETE-FIXUP的伪代码。该过程可以恢复性质1、性质2和性质4。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">RB-DELETE-FIXUP(T, x):</span><br><span class="line"><span class="keyword">while</span> x != T.root <span class="keyword">and</span> x.color == BLACK:<span class="comment"># x为双重黑色，为黑色结点数贡献2</span></span><br><span class="line">    <span class="keyword">if</span> x == x.p.left:</span><br><span class="line">        w = x.p.right                  <span class="comment"># w指向兄弟结点</span></span><br><span class="line">        <span class="keyword">if</span> w.color == RED:             <span class="comment"># 情况1：w是红色的，可以通过以下操作转化为情况2、3或4</span></span><br><span class="line">            w.color = BLACK               <span class="comment"># 而不会违反红黑树的任何性质</span></span><br><span class="line">            x.p.color = RED            <span class="comment"># 改变w和x.p的颜色</span></span><br><span class="line">            LEFT-ROTATE(T, x.p)        <span class="comment"># 然后对x.p做一次左旋</span></span><br><span class="line">            w = x.p.right              <span class="comment"># x的新的兄弟结点w是黑色了</span></span><br><span class="line">        <span class="keyword">if</span> w.left.color == BLACK <span class="keyword">and</span> w.right.color == BLACK: <span class="comment"># 情况2：w和w的两个孩子都是黑色的</span></span><br><span class="line">            w.color = RED              <span class="comment"># 抹去w的黑色，w的所有祖先的黑高降低了1</span></span><br><span class="line">            x = x.p                    <span class="comment"># 作为补偿，在x.p(也是w的父节点)上新增一重额外的黑色</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 情况3和情况4的公共前提：w是黑色的，但两个孩子不全是黑色</span></span><br><span class="line">            <span class="keyword">if</span> w.right.color == BLACK: <span class="comment"># 情况3：w的右孩子是黑色的，暗示着左孩子是红色的</span></span><br><span class="line">                w.left.color = BLACK      <span class="comment"># 通过下列操作转化为情况4而不违反红黑树的任何性质</span></span><br><span class="line">                w.color = RED             <span class="comment"># w与其左孩子交换颜色(w变为红色了)</span></span><br><span class="line">                RIGHT-ROTATE(T, w)        <span class="comment"># 然后对w进行右旋(旋转后的w变成了新w的右孩子)</span></span><br><span class="line">                w = x.p.right             <span class="comment"># x的新的兄弟结点w仍旧是黑色的</span></span><br><span class="line">            w.color = x.p.color        <span class="comment"># 情况4：w的右孩子是红色的，左孩子颜色无所谓</span></span><br><span class="line">            x.p.color = BLACK          <span class="comment"># w涂上父节点的颜色</span></span><br><span class="line">            w.right.color = BLACK      <span class="comment"># 然后将父节点x.p和右孩子w.right涂成黑色</span></span><br><span class="line">            LEFT-ROTATE(T, x.p)        <span class="comment"># 最后对x.p进行一次左旋，即可去掉x的额外的黑色</span></span><br><span class="line">            x = T.root                 <span class="comment"># 将x设置为root，退出while循环</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">         <span class="comment"># same as then clause with "right" and "left" exchanged</span></span><br><span class="line">x.color = BLACK                        <span class="comment"># 若x指向红黑结点或根节点，直接涂成黑色即可修复性质5</span></span><br></pre></td></tr></table></figure><p>while循环的目标是将额外的黑色沿树上移，直到可以将额外的黑色移除：</p><ol type="1"><li>x指向红黑结点，此时将x着为黑色（x.color = BLACK），”移除”额外的黑色。</li><li>x指向根结点，此时”移除“额外的黑色即可。根结点x到所有叶子结点的简单路径的黑色结点数都降低1。</li><li>执行适当的旋转和重新着色，退出循环（while循环内的代码）。</li></ol><p>在while循环中，x总是指向一个具有双重黑色的非根结点。要判断x是左孩子还是右孩子。为左孩子时的代码与为右孩子时的代码是对称的。</p><p><img data-src="/uploads/posts/introduction-to-algorithms/red-black-tree-delete-fixup.png"></p><p>对图的说明：</p><ul><li>加黑的结点color属性为BLACK，深阴影的结点color属性为RED，浅阴影的结点color属性用c和<span class="math inline">\(c^\prime\)</span>表示，它既可为RED也可为BLACK。字母<span class="math inline">\(\alpha,\beta,\dots,\zeta\)</span>代表任意的子树。容易观察到在上述4中操作中，任意结点的黑高都没有发生变化（注意x的黑色层数）。</li><li>x指向的结点带有额外的一重黑色，即x为双重黑色或红黑色。</li></ul><p>对代码内注释的整理：</p><ul><li>x的兄弟结点w是红色的。改变w和x.p的颜色，对x.p做一次左旋。旋转后，x的新兄弟结点new w是黑色的，就将情况1转换为情况2、3或4。</li><li>x的兄弟结点w是黑色的。<ul><li>w的两个子节点都是黑色的。去掉w的黑色，作为补偿对w.p（=x.p）补偿一层黑色。在代码中表现为指针x的移动。</li><li>w的两个孩子不全是黑色的。<ul><li>w的左孩子是红色的，右孩子是黑色的。交换w和左孩子w.left的颜色，对w进行右旋。旋转后，x的新兄弟结点w是一个有红色右孩子的黑色结点，将情况3转换成情况4。</li><li>w的右孩子是红色的，左孩子颜色可红可黑。通过进行某些颜色修改并对x.p做一次左旋，可以去掉x的额外的黑色，从而使它变为单黑色。将x设置为根后，当while循环测试循环条件时，循环终止。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction To Algorithms </tag>
            
            <tag> data structures </tag>
            
            <tag> red-black tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx启用WebDAV</title>
      <link href="/server/nginx-set-up-a-webdav/"/>
      <url>/server/nginx-set-up-a-webdav/</url>
      
        <content type="html"><![CDATA[<h1 id="环境">环境</h1><p><a href="https://en.wikipedia.org/wiki/WebDAV" target="_blank" rel="noopener">WebDAV</a>: Web Distributed Authoring and Versioning.</p><ul><li><p>系统：ubuntu 18.04.2 LTS</p></li><li><p>nginx：1.14.0</p></li><li><p>客户端：iOS documents 和 Windows winscp</p></li></ul><h1 id="安装nginx">安装nginx</h1><p>nginx默认支持dav，但PROPFIND、OPTIONS操作还不支持。支持这些操作需要额外的模块。</p><ul><li>完全安装。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip:~$ sudo apt-get update</span><br><span class="line">ubuntu@ip:~$ sudo apt-get install nginx-full</span><br></pre></td></tr></table></figure><ul><li>部分安装。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip:~$ sudo apt-get update</span><br><span class="line">ubuntu@ip:~$ sudo apt-get install nginx nginx-extras</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="配置">配置</h1><p>使用新域名。在sites-available目录下添加配置文件。</p><figure class="highlight plain"><figcaption><span>/etc/nginx/sites-available/dav</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 443 ssl;</span><br><span class="line">        listen [::]:443 ssl;</span><br><span class="line"></span><br><span class="line">        server_name your_dav_domain.com;</span><br><span class="line">        root /var/www/nginx/dav;</span><br><span class="line"></span><br><span class="line">        ssl on;</span><br><span class="line">        ssl_certificate /your/path/dav.crt;</span><br><span class="line">        ssl_certificate_key /your/path/dav.key;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                charset         utf-8;</span><br><span class="line">                autoindex       on;</span><br><span class="line"></span><br><span class="line">                client_body_temp_path   /etc/nginx/client_temp;</span><br><span class="line">                client_max_body_size    512m;  # 最大文件，若为0则表示不限制</span><br><span class="line"></span><br><span class="line">                dav_methods PUT DELETE MKCOL COPY MOVE;</span><br><span class="line">                dav_ext_methods PROPFIND OPTIONS;  # 需要额外的模块支持</span><br><span class="line"></span><br><span class="line">                create_full_put_path    on;</span><br><span class="line">                dav_access              group:rw all:r;</span><br><span class="line"></span><br><span class="line">                auth_basic              &quot;Access limited&quot;;</span><br><span class="line">                auth_basic_user_file    /etc/nginx/user.passwd;</span><br><span class="line"></span><br><span class="line">                access_log              /var/log/nginx/access.dav.log;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启用该配置。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git@ip:/etc/nginx/sites-enabled$ <span class="built_in">cd</span> /etc/nginx/sites-available/</span><br><span class="line">git@ip:/etc/nginx/sites-available$ sudo ln -s dav ../sites-enabled/dav</span><br><span class="line">git@ip:/etc/nginx/sites-available$ sudo nginx -t</span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf <span class="built_in">test</span> is successful</span><br><span class="line">git@ip:/etc/nginx/sites-available$ sudo nginx -s reload</span><br></pre></td></tr></table></figure><h1 id="删除文件夹">删除文件夹</h1><p>搭建了webdav服务器后，能访问并可以执行部分操作，如创建文件等。但也有不能执行的操作，出现此问题的原因是客户端和服务器的要求不兼容。比如winscp可以删除文件夹，但不可以修改文件夹名称。documents不可以删除文件夹（但是文件夹里面的文件会被成功删除），也不能重命名文件夹（客户端提示权限不足，提示并不正确，看nginx的错误日志）。</p><table><thead><tr class="header"><th>操作</th><th>winscp</th><th>documents</th><th>err_log</th></tr></thead><tbody><tr class="odd"><td>浏览</td><td>Y</td><td>Y</td><td></td></tr><tr class="even"><td>创建文件</td><td>Y</td><td>Y</td><td></td></tr><tr class="odd"><td>创建文件夹</td><td>Y</td><td>Y</td><td></td></tr><tr class="even"><td>移动文件（包括重命名）</td><td>Y</td><td>Y</td><td></td></tr><tr class="odd"><td>移动文件夹（包括重命名）</td><td>N</td><td>N</td><td>&quot;/folder&quot; is collection</td></tr><tr class="even"><td>删除文件</td><td>Y</td><td>Y</td><td></td></tr><tr class="odd"><td>删除文件夹</td><td>Y</td><td>N</td><td>DELETE &quot;/folder&quot; failed (21: Is a directory)</td></tr></tbody></table><p>根据日志，报错的原因是nginx要求对文件夹的操作请求的末尾带上斜线/，比如删除文件夹必须是DELETE /folder/，但是客户端发出的请求是DELETE /folder，因此报错。</p><p>修复方法是重写请求，在webdav的配置文件中加入下列修改：</p><figure class="highlight diff"><figcaption><span>/etc/nginx/sites-enabled/dav</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"><span class="addition">+    # 如果请求内容是文件夹，在请求末尾加上/</span></span><br><span class="line"><span class="addition">+    if ( -d $request_filename ) &#123;  </span></span><br><span class="line"><span class="addition">+        rewrite ^(.*[^/])$ $1/ break;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="移动文件夹">移动文件夹</h1><p>加了如上配置后，documents可以删除文件夹了，但是不论winscp还是documents都无法重命名文件夹。错误日志为<code>both URI &quot;/fog/&quot; and &quot;Destination&quot; URI &quot;https://dav.server.demo/fofg&quot; should be either collections or non-collections</code>。即nginx收到了将文件夹重命名为文件的操作请求，于是报出以上错误。在尝试了各种配置无法解决后，我在nginx源文件ngx_http_dav_module.c中找到了这段代码。这段代码要求URI和Destination一致，要么都带/，要么都不带/。</p><figure class="highlight c"><figcaption><span>~/nginx-1.14.0/src/http/modules/ngx_http_dav_module.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((r-&gt;uri.data[r-&gt;uri.len - <span class="number">1</span>] == <span class="string">'/'</span> &amp;&amp; *(last - <span class="number">1</span>) != <span class="string">'/'</span>)</span><br><span class="line">    || (r-&gt;uri.data[r-&gt;uri.len - <span class="number">1</span>] != <span class="string">'/'</span> &amp;&amp; *(last - <span class="number">1</span>) == <span class="string">'/'</span>))</span><br><span class="line">&#123;</span><br><span class="line">    ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                  <span class="string">"both URI \"%V\" and \"Destination\" URI \"%V\" "</span></span><br><span class="line">                  <span class="string">"should be either collections or non-collections"</span>,</span><br><span class="line">                  &amp;r-&gt;uri, &amp;dest-&gt;value);</span><br><span class="line">    <span class="keyword">return</span> NGX_HTTP_CONFLICT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要解决这个问题，我注释掉了这段代码，重新编译nginx。</p><h1 id="编译nginx">编译nginx</h1><p>下载nginx和nginx-dav-ext-module。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip:~$ wget http://nginx.org/download/nginx-1.14.0.tar.gz</span><br><span class="line">ubuntu@ip:~$ tar xzf nginx-1.14.0.tar.gz</span><br><span class="line">ubuntu@ip:~$ git <span class="built_in">clone</span> https://github.com/arut/nginx-dav-ext-module.git</span><br></pre></td></tr></table></figure><p>在nginx源码中注释掉上述代码。</p><figure class="highlight c"><figcaption><span>~/nginx-1.14.0/src/http/modules/ngx_http_dav_module.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if ((r-&gt;uri.data[r-&gt;uri.len - 1] == '/' &amp;&amp; *(last - 1) != '/')</span></span><br><span class="line"><span class="comment">    || (r-&gt;uri.data[r-&gt;uri.len - 1] != '/' &amp;&amp; *(last - 1) == '/'))</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0,</span></span><br><span class="line"><span class="comment">                  "both URI \"%V\" and \"Destination\" URI \"%V\" "</span></span><br><span class="line"><span class="comment">                  "should be either collections or non-collections",</span></span><br><span class="line"><span class="comment">                  &amp;r-&gt;uri, &amp;dest-&gt;value);</span></span><br><span class="line"><span class="comment">    return NGX_HTTP_CONFLICT;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>设置编译参数，<a href="https://xuexb.github.io/learn-nginx/guide/nginx-configure-descriptions.html" target="_blank" rel="noopener">编译参数介绍</a>。不想深究编译参数，可以使用如下默认的编译参数。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip:~/nginx-1.14.0$ nginx -V  <span class="comment"># 查看编译参数</span></span><br><span class="line">nginx version: nginx/1.14.0 (Ubuntu)</span><br><span class="line">built with OpenSSL 1.1.1  11 Sep 2018</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --with-cc-opt=<span class="string">'-g -O2 -fdebug-prefix-map=/build/nginx-DUghaW/nginx-1.14.0=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wdate-time -D_FORTIFY_SOURCE=2'</span> --with-ld-opt=<span class="string">'-Wl,-Bsymbolic-functions -Wl,-z,relro -Wl,-z,now -fPIC'</span> --prefix=/usr/share/nginx --conf-path=/etc/nginx/nginx.conf --http-log-path=/var/<span class="built_in">log</span>/nginx/access.log --error-log-path=/var/<span class="built_in">log</span>/nginx/error.log --lock-path=/var/lock/nginx.lock --pid-path=/run/nginx.pid --modules-path=/usr/lib/nginx/modules --http-client-body-temp-path=/var/lib/nginx/body --http-fastcgi-temp-path=/var/lib/nginx/fastcgi --http-proxy-temp-path=/var/lib/nginx/proxy --http-scgi-temp-path=/var/lib/nginx/scgi --http-uwsgi-temp-path=/var/lib/nginx/uwsgi --with-debug --with-pcre-jit --with-http_ssl_module --with-http_stub_status_module --with-http_realip_module --with-http_auth_request_module --with-http_v2_module --with-http_dav_module --with-http_slice_module --with-threads --with-http_addition_module --with-http_geoip_module=dynamic --with-http_gunzip_module --with-http_gzip_static_module --with-http_image_filter_module=dynamic --with-http_sub_module --with-http_xslt_module=dynamic --with-stream=dynamic --with-stream_ssl_module --with-mail=dynamic --with-mail_ssl_module</span><br></pre></td></tr></table></figure><p>保持这些参数不变，添加额外的nginx-dav-ext-module模块。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip:~/nginx-1.14.0$ ./configure --with-cc-opt=...原来的参数... --add-module=../nginx-dav-ext-module</span><br><span class="line">ubuntu@ip:~/nginx-1.14.0$ make  <span class="comment"># 编译</span></span><br><span class="line">ubuntu@ip:~/nginx-1.14.0$ sudo objs/nginx -t  <span class="comment"># 测试</span></span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf <span class="built_in">test</span> is successful</span><br><span class="line">ubuntu@ip:~/nginx-1.14.0$ sudo cp /usr/sbin/nginx /usr/sbin/nginx.bak  <span class="comment"># 备份</span></span><br><span class="line">ubuntu@ip:~/nginx-1.14.0$ sudo nginx -s stop  <span class="comment"># 停止服务</span></span><br><span class="line">ubuntu@ip:~/nginx-1.14.0$ sudo cp objs/nginx /usr/sbin/nginx  <span class="comment"># 替换</span></span><br><span class="line">ubuntu@ip:~/nginx-1.14.0$ sudo service nginx start  <span class="comment"># 重启</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> webdav </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu挂载和卸除文件系统</title>
      <link href="/server/ubuntu-mount-and-unmount-drive/"/>
      <url>/server/ubuntu-mount-and-unmount-drive/</url>
      
        <content type="html"><![CDATA[<h1 id="挂载">挂载</h1><p>查看文件系统</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git@ip:~$ sudo fdisk -l</span><br><span class="line">...省略...</span><br><span class="line">Disk /dev/xvdb: 20 GiB, 21474836480 bytes, 41943040 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br></pre></td></tr></table></figure><p>目标文件系统为/dev/xvdb。挂载：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git@ip:~$ sudo mkdir /mnt/data</span><br><span class="line">git@ip:~$ sudo mount /dev/xvdb /mnt/data/</span><br><span class="line">git@ip:~$ sudo df -h  <span class="comment"># 显示文件系统</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">...省略...</span><br><span class="line">/dev/xvdb        20G  208M   19G   2% /mnt/data</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="卸除">卸除</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git@ip:~$ sudo umount /dev/xvdb  <span class="comment"># 通过设备名</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git@ip:~$ sudo umount /mnt/data  <span class="comment"># 通过挂载点</span></span><br></pre></td></tr></table></figure><h1 id="自动挂载">自动挂载</h1><p>查看文件系统信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git@ip:~$ sudo e2label /dev/xvdb data  <span class="comment"># 修改卷标</span></span><br><span class="line">git@ip:~$ sudo blkid /dev/xvdb</span><br><span class="line">/dev/xvdb: LABEL=<span class="string">"data"</span> UUID=<span class="string">"a0001bdb-4b69-4419-9339-f57ddec2f007"</span> TYPE=<span class="string">"ext4"</span></span><br></pre></td></tr></table></figure><p>修改fstab文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git@ip:~$ sudo nano /etc/fstab</span><br></pre></td></tr></table></figure><p>添加一列：</p><figure class="highlight diff"><figcaption><span>/etc/fstab</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+    LABEL=data              /mnt/data       ext4    defaults                0 2</span></span><br></pre></td></tr></table></figure><p>/etc/fstab文件包含了如下字段，通过空格或Tab分隔：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;file system&gt;    &lt;dir&gt;    &lt;type&gt;    &lt;options&gt;    &lt;dump&gt;    &lt;pass&gt;</span><br></pre></td></tr></table></figure><ul><li><file system> - 要挂载的分区或存储设备。</file></li><li><dir><ul><li>file systems的挂载位置。</li></ul></dir></li><li><type> - 文件系统类型，支持许多种不同的文件系统：ext2, ext3, ext4, reiserfs, xfs, jfs, smbfs, iso9660, vfat, ntfs, swap及auto。设置成auto类型，mount命令会猜测使用的文件系统类型，对CDROM和DVD等移动设备是非常有用的。</type></li><li><options> - 挂载时使用的参数，注意有些参数是特定文件系统才有的。</options></li><li><dump> - dump工具通过它决定何时作备份。dump会检查其内容，并用数字来决定是否对这个文件系统进行备份。允许的数字是0和1。0表示忽略，1则进行备份。大部分的用户是没有安装dump的，对他们而言<dump>应设为0。</dump></dump></li><li><pass> - fsck读取<pass>的数值来决定需要检查的文件系统的检查顺序。允许的数字是0, 1, 和2。根目录应当获得最高的优先权1,其它所有需要被检查的设备设置为2。0表示设备不会被fsck所检查。</pass></pass></li></ul><p><strong>验证配置的正确性</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git@ip:~$ sudo mount -a  <span class="comment"># 有错误时打印错误信息</span></span><br><span class="line">mount: /mnt/data: can<span class="string">'t find LABEL=date.</span></span><br></pre></td></tr></table></figure><p>最后可以重启系统验证一下。</p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> command </tag>
            
            <tag> mount </tag>
            
            <tag> unmount </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python迭代器与生成器</title>
      <link href="/programming/python-iterator-generator/"/>
      <url>/programming/python-iterator-generator/</url>
      
        <content type="html"><![CDATA[<h1 id="迭代器">迭代器</h1><p>迭代是访问集合元素的一种方式。迭代器从集合的第一个元素开始访问，直到所有元素被访问完。迭代器只能往前访问，不能后退。字符串，列表，集合等集合对象都可用于创建迭代器。</p><p>多数情况下，更倾向于通过以下方式遍历集合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line"><span class="meta">... </span>    print(i, end=<span class="string">' '</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>    print()</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>等价地，可以创建一个集合a的迭代器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it = iter(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>        print(next(it), end=<span class="string">' '</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">except</span> StopIteration:   <span class="comment"># 访问结束后再次调用next(it)会抛出此异常</span></span><br><span class="line"><span class="meta">... </span>        print()</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">break</span></span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>例如，有一个链表，我希望像遍历数组一样可以遍历链表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        self.key, self.next = key, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.y = self  <span class="comment"># 用变量y记录位置</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.y <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 队尾判断</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x = self.y  <span class="comment"># 暂存</span></span><br><span class="line">            <span class="keyword">if</span> self.y <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment"># 更新位置以便下次访问</span></span><br><span class="line">                self.y = self.y.next</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a, b, c = Node(<span class="number">1</span>), Node(<span class="number">2</span>), Node(<span class="number">3</span>)</span><br><span class="line">    a.next, b.next, c.next = b, c, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a:             <span class="comment"># for each</span></span><br><span class="line">        print(i, end=<span class="string">' '</span>)</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line">    it = iter(b)            <span class="comment"># iterator</span></span><br><span class="line">    print(next(it))</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h1 id="生成器">生成器</h1><p>在Python中，使用了yield的函数被称为生成器。生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</p><p>python可以通过列表解析（list comprehension）的方式构建集合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><p>实际上，<code>(i for i in range(10))</code>就是一个生成器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">generator</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>在生成器运行过程中，每次遇到yield时函数会暂停并保存当前所有的运行信息，返回yield的值，并在下一次执行next()方法时从当前位置继续运行。</p><p>这在很多情况下特别有用。例如，最近研究如何获得一个图中两点之间的所有简单路径。一个测试示例中大概包含一千万条不同的简单路径，若是一次性将这一千万条作为数组返回，……，大概我的笔记本会原地爆炸吧。</p><p>这时生成器就排上用场了。为了简化说明，使用斐波那契数列作为示例。一个斐波那契数列的迭代版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">"""返回斐波那契数列的前n个元素组成的列表"""</span></span><br><span class="line">    a, b, c, r = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, []</span><br><span class="line">    <span class="keyword">while</span> c &lt; n:</span><br><span class="line">        r.append(a)</span><br><span class="line">        a, b, c = b, a + b, c + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure><p>假设需要获得前一千万个数，……，(#`O′)。下面使用yield将之变为生成器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci_it</span><span class="params">(n)</span>:</span> <span class="comment"># 它是一个迭代器</span></span><br><span class="line">    a, b, c = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> c &lt; n:</span><br><span class="line">        <span class="keyword">yield</span> a  <span class="comment"># 每次执行到此处暂停，返回一个结果，下次调用next时将从此处继续执行</span></span><br><span class="line">        a, b, c = b, a + b, c + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> fibonacci_it(<span class="number">10</span>):    <span class="comment"># 使用</span></span><br><span class="line">        print(i, end=<span class="string">' '</span>)</span><br><span class="line">    print()</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 1 2 3 5 8 13 21 34</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> iterator </tag>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NetworkX</title>
      <link href="/documentation/networkx-documentation/"/>
      <url>/documentation/networkx-documentation/</url>
      
        <content type="html"><![CDATA[<h1 id="图的种类">图的种类</h1><p>有4种+1类<a href="https://networkx.github.io/documentation/stable/reference/classes/index.html#basic-graph-types" target="_blank" rel="noopener">Basic graph types</a>。</p><ul><li>Graph：无向图，允许自环（顶点与自身连接的边）。</li><li>DiGraph：有向图，允许自环。</li><li>MultiGraph：无向图，允许自环和平行边（两条或多条与同一对顶点相连接的边）。</li><li>MultiDiGraph：有向图，允许自环和平行边。</li><li>Ordered Graph：OrderedGraph，OrderedDiGraph，OrderedMultiGraph，OrderedMultiDiGraph。</li></ul><p>Ordered Graph的存在意义：在返回图中顶点或边的集合时，Ordered Graph总是以一个固定的顺序返回。</p><p>当<strong>无需此项性质</strong>或<strong>使用Python 3.6+</strong>（Python 3.6+中，集合的顺序是固定的）时，使用前四种基本类即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = nx.Graph()</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="方法">方法</h1><h2 id="adding-and-removing-nodes-and-edges">Adding and removing nodes and edges</h2><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><thead><tr class="header"><th><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.__init__.html#networkx.Graph.__init__" target="_blank" rel="noopener"><code>Graph.__init__</code></a>([incoming_graph_data])</th><th>Initialize a graph with edges, name, or graph attributes.</th></tr></thead><tbody><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.add_node.html#networkx.Graph.add_node" target="_blank" rel="noopener"><code>Graph.add_node</code></a>(node_for_adding, **attr)</td><td>Add a single node <code>node_for_adding</code> and update node attributes.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.add_nodes_from.html#networkx.Graph.add_nodes_from" target="_blank" rel="noopener"><code>Graph.add_nodes_from</code></a>(nodes_for_adding, **attr)</td><td>Add multiple nodes.</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.remove_node.html#networkx.Graph.remove_node" target="_blank" rel="noopener"><code>Graph.remove_node</code></a>(n)</td><td>Remove node n.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.remove_nodes_from.html#networkx.Graph.remove_nodes_from" target="_blank" rel="noopener"><code>Graph.remove_nodes_from</code></a>(nodes)</td><td>Remove multiple nodes.</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.add_edge.html#networkx.Graph.add_edge" target="_blank" rel="noopener"><code>Graph.add_edge</code></a>(u_of_edge, v_of_edge, **attr)</td><td>Add an edge between u and v.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.add_edges_from.html#networkx.Graph.add_edges_from" target="_blank" rel="noopener"><code>Graph.add_edges_from</code></a>(ebunch_to_add, **attr)</td><td>Add all the edges in ebunch_to_add.</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.add_weighted_edges_from.html#networkx.Graph.add_weighted_edges_from" target="_blank" rel="noopener"><code>Graph.add_weighted_edges_from</code></a>(ebunch_to_add)</td><td>Add weighted edges in <code>ebunch_to_add</code> with specified weight attr</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.remove_edge.html#networkx.Graph.remove_edge" target="_blank" rel="noopener"><code>Graph.remove_edge</code></a>(u, v)</td><td>Remove the edge between u and v.</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.remove_edges_from.html#networkx.Graph.remove_edges_from" target="_blank" rel="noopener"><code>Graph.remove_edges_from</code></a>(ebunch)</td><td>Remove all edges specified in ebunch.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.update.html#networkx.Graph.update" target="_blank" rel="noopener"><code>Graph.update</code></a>([edges, nodes])</td><td>Update the graph using nodes/edges/graphs as input.</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.clear.html#networkx.Graph.clear" target="_blank" rel="noopener"><code>Graph.clear</code></a>()</td><td>Remove all nodes and edges from the graph.</td></tr></tbody></table><h2 id="reporting-nodes-edges-and-neighbors">Reporting nodes edges and neighbors</h2><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><thead><tr class="header"><th><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.nodes.html#networkx.Graph.nodes" target="_blank" rel="noopener"><code>Graph.nodes</code></a></th><th>A NodeView of the Graph as G.nodes or G.nodes().</th></tr></thead><tbody><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.__iter__.html#networkx.Graph.__iter__" target="_blank" rel="noopener"><code>Graph.__iter__</code></a>()</td><td>Iterate over the nodes.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.has_node.html#networkx.Graph.has_node" target="_blank" rel="noopener"><code>Graph.has_node</code></a>(n)</td><td>Returns True if the graph contains the node n.</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.__contains__.html#networkx.Graph.__contains__" target="_blank" rel="noopener"><code>Graph.__contains__</code></a>(n)</td><td>Returns True if n is a node, False otherwise.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.edges.html#networkx.Graph.edges" target="_blank" rel="noopener"><code>Graph.edges</code></a></td><td>An EdgeView of the Graph as G.edges or G.edges().</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.has_edge.html#networkx.Graph.has_edge" target="_blank" rel="noopener"><code>Graph.has_edge</code></a>(u, v)</td><td>Returns True if the edge (u, v) is in the graph.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.get_edge_data.html#networkx.Graph.get_edge_data" target="_blank" rel="noopener"><code>Graph.get_edge_data</code></a>(u, v[, default])</td><td>Returns the attribute dictionary associated with edge (u, v).</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.neighbors.html#networkx.Graph.neighbors" target="_blank" rel="noopener"><code>Graph.neighbors</code></a>(n)</td><td>Returns an iterator over all neighbors of node n.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.adj.html#networkx.Graph.adj" target="_blank" rel="noopener"><code>Graph.adj</code></a></td><td>Graph adjacency object holding the neighbors of each node.</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.__getitem__.html#networkx.Graph.__getitem__" target="_blank" rel="noopener"><code>Graph.__getitem__</code></a>(n)</td><td>Returns a dict of neighbors of node n.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.adjacency.html#networkx.Graph.adjacency" target="_blank" rel="noopener"><code>Graph.adjacency</code></a>()</td><td>Returns an iterator over (node, adjacency dict) tuples for all nodes.</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.nbunch_iter.html#networkx.Graph.nbunch_iter" target="_blank" rel="noopener"><code>Graph.nbunch_iter</code></a>([nbunch])</td><td>Returns an iterator over nodes contained in nbunch that are also in the graph.</td></tr></tbody></table><h2 id="counting-nodes-edges-and-neighbors">Counting nodes edges and neighbors</h2><table><colgroup><col style="width: 51%"><col style="width: 48%"></colgroup><thead><tr class="header"><th><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.order.html#networkx.Graph.order" target="_blank" rel="noopener"><code>Graph.order</code></a>()</th><th>Returns the number of nodes in the graph.</th></tr></thead><tbody><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.number_of_nodes.html#networkx.Graph.number_of_nodes" target="_blank" rel="noopener"><code>Graph.number_of_nodes</code></a>()</td><td>Returns the number of nodes in the graph.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.__len__.html#networkx.Graph.__len__" target="_blank" rel="noopener"><code>Graph.__len__</code></a>()</td><td>Returns the number of nodes in the graph.</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.degree.html#networkx.Graph.degree" target="_blank" rel="noopener"><code>Graph.degree</code></a></td><td>A DegreeView for the Graph as G.degree or G.degree().</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.size.html#networkx.Graph.size" target="_blank" rel="noopener"><code>Graph.size</code></a>([weight])</td><td>Returns the number of edges or total of all edge weights.</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.number_of_edges.html#networkx.Graph.number_of_edges" target="_blank" rel="noopener"><code>Graph.number_of_edges</code></a>([u, v])</td><td>Returns the number of edges between two nodes.</td></tr></tbody></table><h2 id="making-copies-and-subgraphs">Making copies and subgraphs</h2><table><colgroup><col style="width: 50%"><col style="width: 49%"></colgroup><thead><tr class="header"><th><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.copy.html#networkx.Graph.copy" target="_blank" rel="noopener"><code>Graph.copy</code></a>([as_view])</th><th>Returns a copy of the graph.</th></tr></thead><tbody><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.to_undirected.html#networkx.Graph.to_undirected" target="_blank" rel="noopener"><code>Graph.to_undirected</code></a>([as_view])</td><td>Returns an undirected copy of the graph.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.to_directed.html#networkx.Graph.to_directed" target="_blank" rel="noopener"><code>Graph.to_directed</code></a>([as_view])</td><td>Returns a directed representation of the graph.</td></tr><tr class="odd"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.subgraph.html#networkx.Graph.subgraph" target="_blank" rel="noopener"><code>Graph.subgraph</code></a>(nodes)</td><td>Returns a SubGraph view of the subgraph induced on <code>nodes</code>.</td></tr><tr class="even"><td><a href="https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.Graph.edge_subgraph.html#networkx.Graph.edge_subgraph" target="_blank" rel="noopener"><code>Graph.edge_subgraph</code></a>(edges)</td><td>Returns the subgraph induced by the specified edges.</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> networkx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广度优先搜索和深度优先搜索</title>
      <link href="/notes/introduction-to-algorithms/breadth-first-search-and-depth-first-search/"/>
      <url>/notes/introduction-to-algorithms/breadth-first-search-and-depth-first-search/</url>
      
        <content type="html"><![CDATA[<h1 id="广度优先搜索">广度优先搜索</h1><p>广度优先搜索是最简单的图搜索算法之一，也是许多重要算法的原型。<strong>Prim的最小生成树算法和Dijkstra的单源最短路径算法都使用了类似广度优先搜索的思想</strong>。</p><p>给定图G=(V,E)和一个可以识别的源结点s，广度优先搜索对图G中的边进行系统性的探索来发现<strong>可以从源结点s到达的所有结点</strong>。该算法能够计算从源结点s到每个可到达的结点的距离（最少的边数），同时生成一棵“广度优先搜索树”。该树以源结点s为根节点，包含所有可以从s到达的结点。对于每个从源结点s可以到达的结点v，在广度优先搜索树里从结点s到结点v的简单路径所对应的就是图G中从结点s到结点v的“最短路径”，即包含最少边数的路径。该算法既可以用于有向图，也可以用于无向图。</p><p>广度优先搜索之所以如此得名是因为该算法始终是将已发现结点和未发现结点之间的边界，沿其广度方向向外扩展。也就是说，<strong>算法需要在发现所有距离源结点s为k的所有结点之后，才会发现距离源结点s为k+1的其他结点</strong>。</p><h2 id="算法">算法</h2><p>为了跟踪算法的进展，广度优先搜索在概念上将每个结点涂上白色、灰色或黑色。所有结点在一开始的时候涂上白色。在算法推进过程中，这些结点可能会变成灰色或黑色（灰色或黑色结点不会变回白色）。在搜索过程中，第一次遇到一个结点就称该结点被“<strong>发现</strong>”，此时该结点的颜色将发生改变。因此，凡是灰色和黑色的结点都是已被发现的结点。</p><a id="more"></a><p>如果边<span class="math inline">\((u,v)\in{E}\)</span>且结点u是黑色，则结点v既可能是灰色也可能是黑色。也就是说，所有与黑色结点邻接的结点都已经被发现。对于灰色结点来说，其邻接结点中可能存在未被发现的白色结点。灰色结点所代表的就是已知和未知两个集合之间的边界。</p><p>在执行广度优先搜索的过程中将构造出一棵广度优先树。一开始，该树仅含有根节点，就是源结点s。在扫描已发现结点u的邻接链表时，每当发现一个白色结点v，就将结点v和边(u,v)同时加入该棵树中。在广度优先树中，称结点u是结点v的<strong>前驱</strong>或者<strong>父结点</strong>。由于每个结点最多被发现一次，它最多只有一个父结点。广度优先树中的祖先和后代关系皆以相对于根节点s的位置来定义：如果结点u是从根节点s到结点v的简单路径上的一个结点，则结点u是结点v的祖先，结点v是结点u的后代。</p><p>在下面给出的 广度优先搜索过程BFS中，假定输入图G=(V,E)是以邻接链表所表示的。该算法为图中每个结点赋予了一些额外的属性：</p><ul><li>u.color：每个结点u的颜色。</li><li>u.pi：u的前驱结点，如果u没有前驱结点，则u.pi=NIL。</li><li>u.d：BFS算法所计算出的从源结点s到结点u之间的距离。</li></ul><p>该算法使用一个先进先出的队列Q来管理灰色结点集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">BFS(G, s):</span><br><span class="line">    <span class="keyword">for</span> each vertex u <span class="keyword">in</span> G.V-&#123;s&#125;:  <span class="comment"># 初始化</span></span><br><span class="line">        u.color = WHITE</span><br><span class="line">        u.d = infinity</span><br><span class="line">        u.pi = NIL</span><br><span class="line">    s.color = GRAY</span><br><span class="line">    s.d = <span class="number">0</span></span><br><span class="line">    s.pi = NIL</span><br><span class="line">    Q = &#123;&#125;</span><br><span class="line">    ENQUEUE(Q, s)</span><br><span class="line">    <span class="keyword">while</span> Q <span class="keyword">is</span> <span class="keyword">not</span> empty:</span><br><span class="line">        u = DEQUEUE(Q)</span><br><span class="line">        <span class="keyword">for</span> each v <span class="keyword">in</span> G.Adj[u]:</span><br><span class="line">            <span class="keyword">if</span> v.color == WHITE:</span><br><span class="line">                v.color = GRAY</span><br><span class="line">                v.d = u.d + <span class="number">1</span></span><br><span class="line">                v.pi = u</span><br><span class="line">                ENQUEUE(Q, v)</span><br><span class="line">        u.color = BLACK</span><br></pre></td></tr></table></figure><p>下图描述的是BFS在一个样本图上的推进过程。</p><p><img data-src="/uploads/posts/introduction-to-algorithms/operation-of-BFS-on-an-undirected-graph.png" title="BFS在一个无向图上的推进过程"></p><h2 id="分析">分析</h2><p>每个结点的入队（当它是白色时）次数最多为一次，因而出队最多一次。入队和出队的时间均为O(1)，因此，对队列进行操作的总时间为O(V)。因为算法只在一个结点出队的时候才对该结点的邻接链表进行扫描，所以每个邻接链表最多只扫描一次。由于所有邻接链表的长度之和是<span class="math inline">\(\Theta(E)\)</span>，用于扫描邻接链表的总时间为O(E)。初始化操作的成本是O(V)，因此<strong>广度优先搜索的总运行时间为</strong>O(V+E)。因此，广度优先搜索的运行时间是图G的邻接链表大小的一个线性函数。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> networkx <span class="keyword">import</span> Graph</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_f</span><span class="params">(graph)</span>:</span></span><br><span class="line">    fmt = <span class="string">'&#123;0:&lt;10s&#125; &#123;1:&lt;10s&#125; &#123;2:&lt;10s&#125;\n'</span></span><br><span class="line">    title = fmt.format(<span class="string">'vertex'</span>, <span class="string">'distance'</span>, <span class="string">'previous'</span>)</span><br><span class="line">    data = <span class="string">''</span>.join(fmt.format(str(k), str(attr[<span class="string">'distance'</span>]), str(attr[<span class="string">'previous'</span>])) <span class="keyword">for</span> k, attr <span class="keyword">in</span> graph.nodes.items())</span><br><span class="line">    print(title + data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">breadth_first_search</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> attr <span class="keyword">in</span> graph.nodes.values():</span><br><span class="line">        attr[<span class="string">'visited'</span>], attr[<span class="string">'distance'</span>], attr[<span class="string">'previous'</span>] = <span class="literal">False</span>, float(<span class="string">'inf'</span>), <span class="literal">None</span></span><br><span class="line">    graph.nodes[s][<span class="string">'visited'</span>], graph.nodes[s][<span class="string">'distance'</span>], q = <span class="literal">True</span>, <span class="number">0</span>, Queue()</span><br><span class="line">    q.put(s)</span><br><span class="line">    <span class="keyword">while</span> q.empty() <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">        u = q.get()</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> graph[u].keys():</span><br><span class="line">            v_attr, u_attr = graph.nodes[v], graph.nodes[u]</span><br><span class="line">            <span class="keyword">if</span> v_attr[<span class="string">'visited'</span>] <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">                v_attr[<span class="string">'visited'</span>], v_attr[<span class="string">'distance'</span>], v_attr[<span class="string">'previous'</span>] = <span class="literal">True</span>, u_attr[<span class="string">'distance'</span>] + <span class="number">1</span>, u</span><br><span class="line">                q.put(v)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    g = Graph()</span><br><span class="line">    g.add_nodes_from(<span class="string">'rstuvwxy'</span>)</span><br><span class="line">    g.add_edges_from(</span><br><span class="line">        [(<span class="string">'r'</span>, <span class="string">'v'</span>), (<span class="string">'r'</span>, <span class="string">'s'</span>), (<span class="string">'s'</span>, <span class="string">'w'</span>), (<span class="string">'w'</span>, <span class="string">'t'</span>), (<span class="string">'w'</span>, <span class="string">'x'</span>), (<span class="string">'t'</span>, <span class="string">'x'</span>), (<span class="string">'t'</span>, <span class="string">'u'</span>), (<span class="string">'u'</span>, <span class="string">'x'</span>), (<span class="string">'u'</span>, <span class="string">'y'</span>),</span><br><span class="line">         (<span class="string">'x'</span>, <span class="string">'y'</span>)])</span><br><span class="line">    breadth_first_search(g, <span class="string">'s'</span>)</span><br><span class="line">    print_f(g)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vertex     distance   previous  </span><br><span class="line">r          1          s</span><br><span class="line">s          0          None</span><br><span class="line">t          2          w</span><br><span class="line">u          3          t</span><br><span class="line">v          2          r</span><br><span class="line">w          1          s</span><br><span class="line">x          2          w</span><br><span class="line">y          3          x</span><br></pre></td></tr></table></figure><h1 id="深度优先搜索">深度优先搜索</h1><p>深度优先搜索总是对最近才发现的结点v的出发边进行搜索，直到该结点的所有出发边都被发现为止。一旦结点v的所有出发边都被发现，搜索则“回溯”到v的前驱结点，来搜索该前驱结点的出发边。该过程一直持续到从源结点可以达到的所有结点都被发现为止。如果还存在尚未发现的结点，则深度优先搜索将从这些未被发现的结点中任选一个作为新的源结点，并重复同样的搜索过程。该算法重复整个过程，直到图中的所有结点都被发现为止。</p><p>与广度优先搜索不同的是，广度优先搜索的前驱子图形成一棵树，而深度优先搜索的前驱子图可能由多棵树组成，因为搜索可能从多个源结点重复进行。深度优先搜索的前驱子图形成一个由多棵<strong>深度优先树</strong>构成的<strong>深度优先森林</strong>。</p><h2 id="算法-1">算法</h2><p>像广度优先搜索算法一样，深度优先搜索算法在搜索过程中也是对结点进行涂色来指明结点的状态。每个结点的初始颜色都是白色，在结点被<strong>发现</strong>后变为灰色，在其邻接链表被扫描完成后变为黑色。该方法可以保证每个结点仅在一棵深度优先树中出现，因此，所有的深度优先树是不相交的（disjoint）。</p><p>深度优先搜索算法还在每个结点盖上一个<strong>时间戳</strong>。每个结点v有两个时间戳：第一个时间戳v.d记录结点v第一次被发现的时间（涂上灰色的时候），第二个时间戳v.f记录的是搜索完成对v的邻接链表扫描的时间（涂上黑色的时候）。这些时间戳提供了图结构的重要信息，通常能够帮助推断深度优先算法的行为。</p><p>因为|V|个结点中每个结点只能有一个发现事件和一个完成事件，所以这些时间戳都是处于1和2|V|之间的整数。很显然，对于每个结点u，我们有：u.d &lt; u.f。结点u在时刻u.d之前为白色，在时刻u.d和u.f之间为灰色，在时刻u.f之后为黑色。</p><p>下面的伪代码给出的是基本的深度优先搜索算法。输入图G既可以是无向图，也可以是有向图。变量time是一个全局变量，用来计算时间戳。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DFS(G):</span><br><span class="line">    <span class="keyword">for</span> each vertex u <span class="keyword">in</span> G.V:  <span class="comment"># 初始化</span></span><br><span class="line">        u.color = WHITE</span><br><span class="line">        u.pi = NIL</span><br><span class="line">    time = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> each vertex u <span class="keyword">in</span> G.V:</span><br><span class="line">        <span class="keyword">if</span> u.color == WHITE:</span><br><span class="line">            DFS-VISIT(G, u)  <span class="comment"># 以u为源结点进行深度优先探索</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DFS-VISIT(G, u):</span><br><span class="line">    time = time + <span class="number">1</span></span><br><span class="line">    u.d = time</span><br><span class="line">    u.color = GRAY            <span class="comment"># 发现</span></span><br><span class="line">    <span class="keyword">for</span> each v <span class="keyword">in</span> G.Adj[u]:   <span class="comment"># 探索u的邻接结点</span></span><br><span class="line">        <span class="keyword">if</span> v.color == WHITE:  <span class="comment"># 若发现新的未探索结点</span></span><br><span class="line">            v.pi = u</span><br><span class="line">            DFS-VISIT(G, v)   <span class="comment"># 优先递归探索新的结点v</span></span><br><span class="line">            <span class="comment"># 探索完v后，循环继续进行，探索u的下一个邻接结点</span></span><br><span class="line">    u.color = BLACK</span><br><span class="line">    time = time + <span class="number">1</span></span><br><span class="line">    u.f = time                <span class="comment"># 探索完成</span></span><br></pre></td></tr></table></figure><p>注意，深度优先算法的结果可能依赖于算法DFS中第6行对结点进行检查的次序和算法DFS-VISIT中的第5行对一个结点的邻接结点进行访问的次序。不过，这些不同的访问次序在实际中并不会导致问题，因为我们通常可以对任意的深度优先搜索结果加以有效利用，并获得等价的结果。</p><p>下图展示算法DFS在有向图上的运行过程。结点中的时间戳表明该结点的发现时间和完成时间。</p><p><img data-src="/uploads/posts/introduction-to-algorithms/progress-of-the-depth-first-search-algorithm-DFS-on-a-directed-graph.png"></p><h2 id="分析-1">分析</h2><p>如果排除调用DFS-VISIT的时间，DFS中两个循环所需的时间均为<span class="math inline">\(\Theta(V)\)</span>。对每个结点<span class="math inline">\(v\in{V}\)</span>来说，DFS-VISIT被调用的次数刚好为1次，这是因为在对一个结点u调用DFS-VISIT时，该结点u必须是白色，而DFS-VISIT所做的第一件事情就是将结点u涂上灰色。在执行DFS-VISIT(G, v)的过程中，5~8行的循环所执行的次数为|Adj[v]|。由于<span class="math inline">\(\sum_{v\in{V}}|Adj[v]|=\Theta(E)\)</span>，执行循环操作的总成本是<span class="math inline">\(\Theta(E)\)</span>。因此，深度优先搜索算法的运行时间为<span class="math inline">\(\Theta(V+E)\)</span>。</p><h2 id="代码-1">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> networkx <span class="keyword">import</span> Graph, DiGraph</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_f</span><span class="params">(g)</span>:</span></span><br><span class="line">    fmt = <span class="string">'&#123;0:&lt;10s&#125; &#123;1:&lt;10s&#125; &#123;2:&lt;10s&#125;\n'</span></span><br><span class="line">    title = fmt.format(<span class="string">'vertex'</span>, <span class="string">'distance'</span>, <span class="string">'previous'</span>)</span><br><span class="line">    data = <span class="string">''</span>.join(fmt.format(str(k), str(attr[<span class="string">'distance'</span>]), str(attr[<span class="string">'previous'</span>])) <span class="keyword">for</span> k, attr <span class="keyword">in</span> g.nodes.items())</span><br><span class="line">    print(title + data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">depth_first_search</span><span class="params">(g)</span>:</span>  <span class="comment"># 函数入口</span></span><br><span class="line">    <span class="keyword">for</span> attr <span class="keyword">in</span> g.nodes.values():  <span class="comment"># 初始化</span></span><br><span class="line">        attr[<span class="string">'visited'</span>], attr[<span class="string">'previous'</span>] = <span class="literal">False</span>, <span class="literal">None</span></span><br><span class="line">    g.graph[<span class="string">'time'</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> u, attr <span class="keyword">in</span> g.nodes.items():  <span class="comment"># 递归搜索无法访问到非连通的部分，通过此处循环解决</span></span><br><span class="line">        <span class="keyword">if</span> attr[<span class="string">'visited'</span>] <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">            dfs_visit(g, u)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs_visit</span><span class="params">(g, u)</span>:</span>  <span class="comment"># 递归方法主体</span></span><br><span class="line">    g.graph[<span class="string">'time'</span>] += <span class="number">1</span></span><br><span class="line">    g.nodes[u][<span class="string">'distance'</span>], g.nodes[u][<span class="string">'visited'</span>] = g.graph[<span class="string">'time'</span>], <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> g[u].keys():</span><br><span class="line">        <span class="keyword">if</span> g.nodes[v][<span class="string">'visited'</span>] <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">            g.nodes[v][<span class="string">'previous'</span>] = u</span><br><span class="line">            dfs_visit(g, v)  <span class="comment"># 递归</span></span><br><span class="line">    g.nodes[u][<span class="string">'visited'</span>] = <span class="literal">True</span></span><br><span class="line">    g.graph[<span class="string">'time'</span>] += <span class="number">1</span></span><br><span class="line">    g.nodes[u][<span class="string">'distance'</span>] = str(g.nodes[u][<span class="string">'distance'</span>]) + <span class="string">'/'</span> + str(g.graph[<span class="string">'time'</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    h = DiGraph()</span><br><span class="line">    h.add_nodes_from(<span class="string">'uvwxyz'</span>)</span><br><span class="line">    h.add_edges_from([(<span class="string">'u'</span>, <span class="string">'v'</span>), (<span class="string">'u'</span>, <span class="string">'x'</span>), (<span class="string">'x'</span>, <span class="string">'v'</span>), (<span class="string">'v'</span>, <span class="string">'y'</span>), (<span class="string">'y'</span>, <span class="string">'x'</span>), (<span class="string">'w'</span>, <span class="string">'y'</span>), (<span class="string">'w'</span>, <span class="string">'z'</span>), (<span class="string">'z'</span>, <span class="string">'z'</span>)])</span><br><span class="line">    depth_first_search(h)</span><br><span class="line">    print_f(h)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vertex     distance   previous  </span><br><span class="line">u          1/8        None</span><br><span class="line">v          2/7        u</span><br><span class="line">w          9/12       None</span><br><span class="line">x          4/5        y</span><br><span class="line">y          3/6        v</span><br><span class="line">z          10/11      w</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction To Algorithms </tag>
            
            <tag> algorithms </tag>
            
            <tag> stack </tag>
            
            <tag> recursion </tag>
            
            <tag> queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的表示</title>
      <link href="/notes/introduction-to-algorithms/representations-of-graphs/"/>
      <url>/notes/introduction-to-algorithms/representations-of-graphs/</url>
      
        <content type="html"><![CDATA[<h1 id="图的表示">图的表示</h1><p>对于图G=(V,E)，可以用两种标准表示方法表示。两种表示方法都既可以表示无向图，也可以表示有向图。</p><ul><li><p><strong>邻接链表表示</strong>：将图作为邻接链表的组合。</p><p>在表示<strong>稀疏图</strong>（边的条数|E|远远小于<span class="math inline">\(|V|^2\)</span>的图）时非常紧凑而成为通常的选择。</p></li><li><p><strong>邻接矩阵表示</strong>：将图作为邻接矩阵来看待。</p><p>在<strong>稠密图</strong>（|E|接近<span class="math inline">\(|V|^2\)</span>的图）的情况下，倾向于使用邻接矩阵表示法。另外，如果需要快速判断任意两个结点之间是否有边相连，可能也需要使用邻接矩阵表示法。</p></li></ul><p><img data-src="/uploads/posts/introduction-to-algorithms/two-representations-of-an-undirected-graph.png" title="无向图的表示方法"></p><p><img data-src="/uploads/posts/introduction-to-algorithms/two-representations-of-a-directed-graph.png" title="有向图的表示方法"></p><a id="more"></a><h1 id="邻接链表表示">邻接链表表示</h1><p>如上图(b)所示：对于图G=(V,E)来说，其<strong>邻接链表表示</strong>由一个包含|V|条链表的数组Adj所构成，每个结点有一条链表。对于每个结点<span class="math inline">\(u\in{V}\)</span>，邻接链表Adj[u]包含所有与结点u之间有边相邻的结点v，即Adj[u]包含图G中所有与u邻接的结点（也可以说，该链表里包含指向这些结点的指针）。</p><p>如果G是一个有向图，则对于边(u,v)来说，结点v将出现在链表Adj[u]里，因此，所有邻接链表的长度之和等于|E|。如果G是一个无向图，则对于边(u,v)来说，结点v将出现在链表Adj[u]里，结点u将出现在链表Adj[v]里，因此，所有邻接链表的长度之和为2|E|。但不管是有向图还是无向图，邻接链表表示法的存储空间需求均为<span class="math inline">\(\Theta(V+E)\)</span>。</p><p>对邻接链表稍加修改，即可以用来表示<strong>权重图</strong>，权重图是图中的每条边都带有一个相关的权重的图。可以直接将边<span class="math inline">\((u,v)\in{E}\)</span>的权重值w(u,v)存放在结点u的邻接链表里。从这种意义上说，邻接链表表示法的鲁棒性很高，可以通过对其进行简单修改来支持许多其他的图变种。</p><p>邻接链表的一个潜在缺陷是无法快速判断一条边(u,v)是否是图中的一条边，唯一的办法是在邻接链表Adj[u]里面搜索结点v。邻接矩阵表示则克服了这个缺陷，但付出的代价是更大的存储空间消耗。</p><h1 id="邻接矩阵表示">邻接矩阵表示</h1><p>对于<strong>邻接矩阵表示</strong>来说，通常会将图G中的结点编为<code>1,2,...,|V|</code>，这种编号可以是任意的。在进行此种编号之后，图G的邻接矩阵表示由一个<span class="math inline">\(|V|\times|V|\)</span>的矩阵<span class="math inline">\(A=(a_{ij})\)</span>予以表示，该矩阵满足下述条件： <span class="math display">\[a_{ij}=\begin{cases}1\quad\text{if }(i,j)\in{E}\\0\quad\text{otherwise}\end{cases}\]</span> 图(c)给出的是图(a)的邻接矩阵表示。不管一个图中由多少条边，邻接矩阵的空间需求皆为<span class="math inline">\(\Theta(V^2)\)</span>。</p><p>无向图的邻接矩阵是一个对称矩阵。由于在无向图中，边(u,v)和边(v,u)是同一条边，无向图的邻接矩阵A就是自己的转置，即<span class="math inline">\(A=A^T\)</span>。在某些应用中，可能只需要存放对角线及其以上的这部分邻接矩阵（即半个矩阵），从而将图存储空间需要减少几乎一半。</p><p>与邻接链表表示法一样，邻接矩阵也可以用来表示权重图。例如，如果G=(V,E)为一个权重图，则直接将边<span class="math inline">\((u,v)\in{E}\)</span>的权重w(u,v)存放在邻接矩阵中的第u行第v列记录上。对于不存在的边，则在相应的行列记录上存放值NIL。不过，对于许多问题来说，用0或<span class="math inline">\(\infty\)</span>来表示一条不存在的边可能更为便捷。</p><p>邻接矩阵表示法更为简单，因此在图规模比较小时，可能更倾向于使用邻接矩阵表示法。</p><p>而且，对于无向图来说，邻接矩阵还有一个优势：每个纪录项只需要1位空间。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graph </tag>
            
            <tag> Introduction To Algorithms </tag>
            
            <tag> adjacent list </tag>
            
            <tag> adjacent matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小费用流问题</title>
      <link href="/notes/minimum-cost-flow-problems/"/>
      <url>/notes/minimum-cost-flow-problems/</url>
      
        <content type="html"><![CDATA[<h1 id="最小费用流问题">最小费用流问题</h1><p>最小费用流问题（MCFP）试图在一个流网络中寻找发送指定流量的最便宜的可行方案。一个典型的应用是寻找工厂到仓库之间的最佳配送路径，每段路线都有相应的容量和费用。</p><p><strong>定义</strong></p><p>有向图G=(V,E)定义的流网络中，源结点为<span class="math inline">\(s\in{V}\)</span>，汇点为t，每条边<span class="math inline">\((u,v)\in{E}\)</span>有容量c(u,v)&gt;0，流<span class="math inline">\(f(u,v)\ge0\)</span>和代价a(u,v)（代价可以为负）。沿某条边(u,v)发送流量的代价为f(u,v)*a(u,v)。问题要求从源结点s发送指定大小的流量d到汇点t。最小费用流问题试图最小化所有边的总代价：<span class="math inline">\(\sum_{(u,v)\in{E}}a(u,v)*f(u,v)\)</span></p><p>满足以下约束条件：</p><ul><li>容量限制：对于所有的结点<span class="math inline">\(u,v\in{V}\)</span>，要求<span class="math inline">\(0\le{f(u,v)}\le{c(u,v)}\)</span>。</li><li>流量守恒：对于所有的结点<span class="math inline">\(u\in{V-\lbrace{s,t}\rbrace}\)</span>，要求<span class="math inline">\(\sum_{v\in{V}}f(v,u)=\sum_{v\in{V}}f(u，v)\)</span>。</li><li>流量要求：<span class="math inline">\(\sum_{v\in{V}}f(s,v)=d\quad\text{and}\quad\sum_{v\in{V}}f(v,t)=d\)</span>。</li></ul><h1 id="负权环路消除法">负权环路消除法</h1><p>负权环路是指有向图G=(V,E)中的环路且构成环路的所有边的权重之和为负数值。</p><a id="more"></a><h2 id="残存网络">残存网络</h2><p>假定由一个流网络G=(V,E)，其源结点为s，汇点为t。设f为图G中的一个流，考虑结点对<span class="math inline">\(u,v\in{V}\)</span>，定义残存容量<span class="math inline">\(c_f(u,v)\)</span>如下： <span class="math display">\[c_f(u,v)=\begin{cases}c(u,v)-f(u,v)&amp;\text{if }(u,v)\in{E}\\f(v,u)&amp;\text{if }(v,u)\in{E}\\0&amp;otherwise\end{cases}\]</span> 定义残存网络代价<span class="math inline">\(a_f(u,v)\)</span>如下： <span class="math display">\[a_f(u,v)=\begin{cases}a(u,v)&amp;\text{if }(u,v)\in{E}\\-a(u,v)&amp;\text{if }(v,u)\in{E}\\0&amp;otherwise\end{cases}\]</span> 负权环路消除法的核心思想是在残存网络中寻找从源结点s可达的负权环路，然后沿环路发送流量。直到残存网路中不存在从源结点s可达的负权环路为止。算法的步骤如下：</p><ol type="1"><li>设G=(V,E)为一个流网络，求出值为d的一个流。通过修改最大流的Ford-Fulkerson算法，可以求出值为d的一个流。</li><li>在残存网络中寻找从源结点s可达的负权环路。单源最短路径算法的Bellman-Ford算法可以检测图G=(V,E)中是否含有负权环路，通过修改Bellman-Ford算法可以求出该环路。</li><li>若存在，沿环路发送流量，返回步骤2。若不存在，则当前网络中的流为最佳方案。</li></ol><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> graph.max_flow <span class="keyword">import</span> find_path</span><br><span class="line"><span class="keyword">from</span> graph.bellman_ford <span class="keyword">import</span> initialize_single_source, relax</span><br><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_f</span><span class="params">(graph)</span>:</span></span><br><span class="line">    print(<span class="string">'min cost:'</span>, graph.graph[<span class="string">'min_cost'</span>])</span><br><span class="line">    fmt = <span class="string">'&#123;0:&lt;4s&#125; &#123;1:&lt;4s&#125; &#123;2:&lt;4s&#125; &#123;3:&lt;4s&#125; &#123;4:&lt;8s&#125;\n'</span></span><br><span class="line">    title = fmt.format(<span class="string">'u'</span>, <span class="string">'v'</span>, <span class="string">'flow'</span>, <span class="string">'cost'</span>, <span class="string">'capacity'</span>)</span><br><span class="line">    data = <span class="string">''</span>.join(</span><br><span class="line">        fmt.format(str(u), str(v), str(attr[<span class="string">'flow'</span>]), str(attr[<span class="string">'cost'</span>]), str(attr[<span class="string">'capacity'</span>]))</span><br><span class="line">        <span class="keyword">for</span> u, v, attr <span class="keyword">in</span> graph.edges(data=<span class="literal">True</span>) <span class="keyword">if</span> attr[<span class="string">'flow'</span>] &gt; <span class="number">0</span>)</span><br><span class="line">    print(title + data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flow</span><span class="params">(graph, s, t, f)</span>:</span></span><br><span class="line">    <span class="string">"""求出任意一个值为f的流"""</span></span><br><span class="line">    p = find_path(graph, s, t, set())</span><br><span class="line">    <span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        residual = [graph[u][v][<span class="string">'capacity'</span>] - graph[u][v][<span class="string">'flow'</span>] <span class="keyword">for</span> u, v <span class="keyword">in</span> p]</span><br><span class="line">        augment_flow = min(min(residual), f)</span><br><span class="line">        <span class="keyword">for</span> u, v <span class="keyword">in</span> p:</span><br><span class="line">            graph[u][v][<span class="string">'flow'</span>] += augment_flow</span><br><span class="line">            graph[v][u][<span class="string">'flow'</span>] -= augment_flow</span><br><span class="line">        f -= augment_flow</span><br><span class="line">        <span class="keyword">if</span> f == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        p = find_path(graph, s, t, set())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bellman_ford</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    initialize_single_source(graph, s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(graph.number_of_nodes() - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> u, v, e_attr <span class="keyword">in</span> graph.edges(data=<span class="literal">True</span>):</span><br><span class="line">            <span class="keyword">if</span> e_attr[<span class="string">'capacity'</span>] - e_attr[<span class="string">'flow'</span>] &gt; <span class="number">0</span>:  <span class="comment"># 只有此值大于0的边存在于残存网络中</span></span><br><span class="line">                relax(graph, u, v, e_attr[<span class="string">'cost'</span>])</span><br><span class="line">    <span class="keyword">for</span> u, v, e_attr <span class="keyword">in</span> graph.edges(data=<span class="literal">True</span>):</span><br><span class="line">        residual = e_attr[<span class="string">'capacity'</span>] - e_attr[<span class="string">'flow'</span>]</span><br><span class="line">        <span class="keyword">if</span> residual &gt; <span class="number">0</span> <span class="keyword">and</span> graph.nodes[v][<span class="string">'distance'</span>] &gt; graph.nodes[u][<span class="string">'distance'</span>] + e_attr[<span class="string">'cost'</span>]:</span><br><span class="line">            <span class="comment"># 当存在负权环路时，返回从环路可达的一个结点</span></span><br><span class="line">            <span class="keyword">return</span> u</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_negative_cycle</span><span class="params">(graph, v, cycle)</span>:</span></span><br><span class="line">    <span class="string">"""根据previous属性找出环路"""</span></span><br><span class="line">    <span class="comment"># 先找到环路中任一结点</span></span><br><span class="line">    visit = &#123;v&#125;</span><br><span class="line">    pre = graph.nodes[v][<span class="string">'previous'</span>]  <span class="comment"># 前驱结点</span></span><br><span class="line">    <span class="keyword">while</span> pre <span class="keyword">not</span> <span class="keyword">in</span> visit:</span><br><span class="line">        visit.add(pre)</span><br><span class="line">        pre = graph.nodes[pre][<span class="string">'previous'</span>]</span><br><span class="line">    <span class="comment"># 通过previous找出环路</span></span><br><span class="line">    anchor = pre</span><br><span class="line">    end, start = pre, graph.nodes[pre][<span class="string">'previous'</span>]</span><br><span class="line">    <span class="keyword">while</span> start != anchor:</span><br><span class="line">        cycle.append((start, end))</span><br><span class="line">        end = start</span><br><span class="line">        start = graph.nodes[start][<span class="string">'previous'</span>]</span><br><span class="line">    cycle.append((start, end))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">negative_cycle_canceling</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    key = bellman_ford(graph, s)  <span class="comment"># bellman ford求最短路径的方式寻找环路</span></span><br><span class="line">    <span class="keyword">while</span> key <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        cycle = []</span><br><span class="line">        get_negative_cycle(graph, key, cycle)</span><br><span class="line">        cancel_flow = min(graph[u][v][<span class="string">'capacity'</span>] - graph[u][v][<span class="string">'flow'</span>] <span class="keyword">for</span> u, v <span class="keyword">in</span> cycle)  <span class="comment"># 修改环路上的流量</span></span><br><span class="line">        <span class="keyword">for</span> u, v <span class="keyword">in</span> cycle:</span><br><span class="line">            graph[u][v][<span class="string">'flow'</span>] += cancel_flow</span><br><span class="line">            graph[v][u][<span class="string">'flow'</span>] -= cancel_flow</span><br><span class="line">        key = bellman_ford(graph, s)  <span class="comment"># 重新寻找环路</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min_cost</span><span class="params">(graph, s, t, d)</span>:</span></span><br><span class="line">    <span class="string">"""求解流量值为d的最小费用流"""</span></span><br><span class="line">    flow(graph, s, t, d)  <span class="comment"># 先找到一个可行解，当d大于最大流量时，找到的可行解是最大流量</span></span><br><span class="line">    negative_cycle_canceling(graph, s)  <span class="comment"># 移除负权环路</span></span><br><span class="line">    graph.graph[<span class="string">'min_cost'</span>] = sum(attr[<span class="string">'flow'</span>] * attr[<span class="string">'cost'</span>] <span class="keyword">for</span> attr <span class="keyword">in</span> graph.edges.values() <span class="keyword">if</span> attr[<span class="string">'flow'</span>] &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_graph</span><span class="params">(graph, vertices, edges)</span>:</span></span><br><span class="line">    graph.add_nodes_from(vertices)</span><br><span class="line">    <span class="keyword">for</span> u, v, cap, cost <span class="keyword">in</span> edges:</span><br><span class="line">        graph.add_edges_from([(u, v, &#123;<span class="string">'capacity'</span>: cap, <span class="string">'cost'</span>: cost&#125;), (v, u, &#123;<span class="string">'capacity'</span>: <span class="number">0</span>, <span class="string">'cost'</span>: -cost&#125;)], flow=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    g = nx.DiGraph()</span><br><span class="line">    v = <span class="string">'s1234t'</span></span><br><span class="line">    e = [(<span class="string">'s'</span>, <span class="string">'1'</span>, <span class="number">10</span>, <span class="number">2</span>), (<span class="string">'s'</span>, <span class="string">'3'</span>, <span class="number">35</span>, <span class="number">4</span>), (<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="number">20</span>, <span class="number">6</span>), (<span class="string">'1'</span>, <span class="string">'3'</span>, <span class="number">10</span>, <span class="number">1</span>), (<span class="string">'2'</span>, <span class="string">'t'</span>, <span class="number">35</span>, <span class="number">2</span>),</span><br><span class="line">         (<span class="string">'3'</span>, <span class="string">'2'</span>, <span class="number">5</span>, <span class="number">6</span>), (<span class="string">'3'</span>, <span class="string">'4'</span>, <span class="number">30</span>, <span class="number">2</span>), (<span class="string">'4'</span>, <span class="string">'2'</span>, <span class="number">15</span>, <span class="number">2</span>), (<span class="string">'4'</span>, <span class="string">'t'</span>, <span class="number">10</span>, <span class="number">7</span>)]</span><br><span class="line">    initialize_graph(g, v, e)</span><br><span class="line">    min_cost(g, <span class="string">'s'</span>, <span class="string">'t'</span>, <span class="number">20</span>)</span><br><span class="line">    print_f(g)</span><br><span class="line"></span><br><span class="line">    g.clear()</span><br><span class="line">    e = [(<span class="string">'s'</span>, <span class="string">'1'</span>, <span class="number">16</span>, <span class="number">3</span>), (<span class="string">'s'</span>, <span class="string">'2'</span>, <span class="number">13</span>, <span class="number">4</span>), (<span class="string">'1'</span>, <span class="string">'3'</span>, <span class="number">12</span>, <span class="number">7</span>), (<span class="string">'2'</span>, <span class="string">'1'</span>, <span class="number">4</span>, <span class="number">3</span>), (<span class="string">'2'</span>, <span class="string">'4'</span>, <span class="number">14</span>, <span class="number">6</span>),</span><br><span class="line">         (<span class="string">'3'</span>, <span class="string">'2'</span>, <span class="number">9</span>, <span class="number">5</span>), (<span class="string">'3'</span>, <span class="string">'t'</span>, <span class="number">20</span>, <span class="number">6</span>), (<span class="string">'4'</span>, <span class="string">'3'</span>, <span class="number">7</span>, <span class="number">8</span>), (<span class="string">'4'</span>, <span class="string">'t'</span>, <span class="number">4</span>, <span class="number">9</span>)]</span><br><span class="line">    initialize_graph(g, v, e)</span><br><span class="line">    min_cost(g, <span class="string">'s'</span>, <span class="string">'t'</span>, <span class="number">19</span>)</span><br><span class="line">    print_f(g)</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">min cost: 195</span><br><span class="line">u    v    flow cost capacity</span><br><span class="line">s    1    10   2    10</span><br><span class="line">s    3    10   4    35</span><br><span class="line">1    2    5    6    20</span><br><span class="line">1    3    5    1    10</span><br><span class="line">2    t    20   2    35</span><br><span class="line">3    4    15   2    30</span><br><span class="line">4    2    15   2    15</span><br><span class="line"></span><br><span class="line">min cost: 340</span><br><span class="line">u    v    flow cost capacity</span><br><span class="line">s    1    12   3    16</span><br><span class="line">s    2    7    4    13</span><br><span class="line">1    3    12   7    12</span><br><span class="line">2    4    7    6    14</span><br><span class="line">3    t    15   6    20</span><br><span class="line">4    3    3    8    7</span><br><span class="line">4    t    4    9    4</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithms </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大子数组问题</title>
      <link href="/notes/introduction-to-algorithms/maximum-subarray-problems/"/>
      <url>/notes/introduction-to-algorithms/maximum-subarray-problems/</url>
      
        <content type="html"><![CDATA[<h1 id="最大化收益">最大化收益</h1><p>假设你知道了未来17天某公司的股票价格，你的目标是最大化收益。</p><ul><li>你可能认为可以“低价买进，高价卖出”——在最低价格时买进股票，之后在最高价格时卖出，这样可以最大化收益。但遗憾的是，在一段时间内，可能无法做到在最低价格时买进股票，然后在最高价格时卖出。例如，下图中，最低价在后，最高价在前。</li></ul><p><img data-src="/uploads/posts/introduction-to-algorithms/maximum-subarray-problem-price-of-stock.png" title="未来17天股票价格"></p><a id="more"></a><ul><li>你还可能认为可以在最低价格时买进，或在最高价格时卖出，即可最大化收益。如果这种策略总是有效的，则确定最大化收益是非常简单的：寻找最高和最低价格，然后从最高价格开始向左寻找之前的最低价格；从最低价格开始向右寻找之后的最高价格；取两对价格中差值最大者。例如上图中，在第7天股票价格最低时买入，即可最大化收益。但下图给出了一个简单的反例，显示有时最大收益既不是在最低价格时买进，也不是在最高价格时卖出。</li></ul><p><img data-src="/uploads/posts/introduction-to-algorithms/maximum-subarray-problem-a-counter-example.png" title="一个反例：最大收益既不是在最低价格时买进，也不是在最高价格时卖出"></p><p>暴力求解方法：</p><p>尝试每对可能的买进和卖出日期组合，只要卖出日期在买进日期之后即可。n天中共有<span class="math inline">\(\begin{pmatrix}n\\2\end{pmatrix}=\Theta(n^2)\)</span>种日期组合。处理每对日期所花费的时间至少也是常量，因次这种方法的运行时间为<span class="math inline">\(\Omega(n^2)\)</span>。</p><h1 id="最大子数组问题">最大子数组问题</h1><p>从一个稍微不同的角度来看待输入数据。我们的目的是寻找一段日期，使得从第一天到最后一天的股票价格净变值最大。因此，我们不再从每日价格的角度来看待输入数据，而是考察每日价格变化，第i天的价格变化定义为第i天和第i-1天的价格差。第一幅图的最后一行给出了每日价格变化。如果将这一行看作一个数组A，那么问题就转化为寻找A的<strong>和最大的非空连续子数组</strong>。这样的连续子数组为<strong>最大子数组</strong>（maximum subarray）。例如，对第一幅图中的数组，<code>A[1...16]</code>的最大子数组为<code>A[8...11]</code>，其和为43。因此，可以在第8天开始前（第7天结束后）买入股票，并在第11天结束后卖出，获得每股收益43。</p><p><img data-src="/uploads/posts/introduction-to-algorithms/maximum-subarray.png" title="最大子数组"></p><p>乍一看，这种变换对问题求解并没有什么帮助。对于一段n天的日期，仍需要检查<span class="math inline">\(\begin{pmatrix}n-1\\2\end{pmatrix}=\Theta(n^2)\)</span>个子数组。计算一个子数组之和所需的时间是线性的，但当计算所有<span class="math inline">\(\Theta(n^2)\)</span>个子数组和时，可以重新组织计算方式，利用之前计算出的子数组和来计算当前子数组的和，使得每个子数组和的计算时间为O(1)，从而暴力求解方法所花费的时间仍为<span class="math inline">\(\Theta(n^2)\)</span>。</p><p>接下来，寻找最大子数组问题的更高效的求解方法。在此过程中，我们通常说“一个最大子数组”而不是“最大子数组”，因为可能有多个子数组达到最大和。</p><p>只有当数组中包含负数时，最大子数组问题才有意义。如果所有数组元素都是非负的，最大子数组问题没有任何难度，因为整个数组的和肯定是最大的。</p><h1 id="使用分治策略的算法">使用分治策略的算法</h1><p>假定要寻找子数组<code>A[low...high]</code>的最大子数组。使用分治技术意味着要将子数组划分成两个规模尽量相等的子数组。也就是说，找到子数组的中央位置，比如mid，然后考虑求解两个子数组<code>A[low...mid]</code>和<code>A[mid+1...high]</code>。如下图(a)所示，<code>A[low...high]</code>的任何连续子数组<code>A[i...j]</code>所处的位置必然是以下三种情况之一：</p><ul><li>完全位于子数组<code>A[low...mid]</code>中，因此<span class="math inline">\(low\le{i}\le{j}\le{mid}\)</span>。</li><li>完全位于子数组<code>A[mid+1...high]</code>中，因此<span class="math inline">\(mid&lt;i\le{j}\le{high}\)</span>。</li><li>跨越了中点，因此<span class="math inline">\(low\le{i}\le{mid}&lt;j\le{high}\)</span>。</li></ul><p><img data-src="/uploads/posts/introduction-to-algorithms/maximum-subarray-problem-possible-locations.png" title="最大子数组所处的三种位置"></p><p>我们可以递归地求解<code>A[low...mid]</code>和<code>A[mid+1...high]</code>的最大子数组，因为这两个子问题仍是最大子数组问题，只是规模更小。因此，剩下的全部工作就是寻找跨越中点的最大子数组，然后在三种情况中选取和最大者。</p><p>求出跨越中点的最大子树组并非原问题规模更小的实例，因为它加入了限制——求出的子数组必须跨越中点。如上图(b)所示，任何跨越中点的子数组都有两个子数组<code>A[i...mid]</code>和<code>A[mid+1...j]</code>组成。因此，只需找出形如<code>A[i...mid]</code>和<code>A[mid+1...j]</code>的最大子数组，然后将其合并即可。过程FIND-MAX-CROSSING-SUBARRAY接收数组A和下标low、mid和high为输入，返回一个下标元组划定跨越中点的最大子数组的边界，并返回最大子数组值的和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high):  <span class="comment"># 设 high-low+1 = n</span></span><br><span class="line">    left-sum = -infinty</span><br><span class="line">    sum = <span class="number">0</span>                   <span class="comment"># 求出左半部的最大子数组</span></span><br><span class="line">    <span class="keyword">for</span> i = mid downto low:   <span class="comment"># 循环 mid-low+1 次</span></span><br><span class="line">        sum = sum + A[i]      <span class="comment"># 循环体花费常数时间</span></span><br><span class="line">        <span class="keyword">if</span> sum &gt; left-sum：</span><br><span class="line">            left-sum = sum</span><br><span class="line">            max-left = i</span><br><span class="line">    right-sum = -infinty</span><br><span class="line">    sum = <span class="number">0</span>                   <span class="comment"># 求出右半部的最大子数组</span></span><br><span class="line">    <span class="keyword">for</span> j = mid + <span class="number">1</span> to high:  <span class="comment"># 循环 high-(mid+1)+1=high-mid 次</span></span><br><span class="line">        sum = sum + A[j]      <span class="comment"># 循环体花费常数时间</span></span><br><span class="line">        <span class="keyword">if</span> sum &gt; right-sum:</span><br><span class="line">            right-sum = sum</span><br><span class="line">            max-right = j</span><br><span class="line">    <span class="keyword">return</span> (max-left, max-right, left-sum + right-sum)</span><br></pre></td></tr></table></figure><p>如果子数组<code>A[low...high]</code>包含n个元素，则两个for循环的总迭代次数为high-mid+mid-low+1=high-low+1=n次，每次迭代花费<span class="math inline">\(\Theta(1)\)</span>时间，因此调用FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)花费<span class="math inline">\(\Theta(n)\)</span>时间。</p><p>求解最大子数组问题的分治算法的伪代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FIND-MAXIMUM-SUBARRAY(A, low, high):</span><br><span class="line">    <span class="keyword">if</span> high == low:  <span class="comment"># 只有一个元素的情况，花费常量时间</span></span><br><span class="line">        <span class="keyword">return</span> (low, high, A[low])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mid = math.floor((low+high)/<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 分解成子问题</span></span><br><span class="line">        (left-low, left-high, left-sum)    = FIND-MAXIMUM-SUBARRAY(A, low, mid)  <span class="comment"># 递归</span></span><br><span class="line">        (right-low, right-high, right-sum) = FIND-MAXIMUM-SUBARRAY(A, mid+<span class="number">1</span>, high)</span><br><span class="line">        (cross-low, cross-high, cross-sum) = FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)  <span class="comment"># 对第三种情况单独求解</span></span><br><span class="line">        <span class="comment"># 合并：三种结果中最大的子数组为原问题的解</span></span><br><span class="line">        <span class="keyword">if</span> left-sum &gt;= right-sum <span class="keyword">and</span> left-sum &gt;= cross-sum:</span><br><span class="line">            <span class="keyword">return</span> (left-low, left-high, left-sum)</span><br><span class="line">        <span class="keyword">elif</span> right-sum &gt;= left-sum <span class="keyword">and</span> right-sum &gt;= cross-sum:</span><br><span class="line">            <span class="keyword">return</span> (right-low, right-high, right-sum)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (cross-low, cross-high, cross-sum)</span><br></pre></td></tr></table></figure><p>初始调用FIND-MAXIMUM-SUBARRAY(A, 0, A.lenght-1)即可求出<code>A[0...n-1]</code>的最大子数组。</p><h2 id="分析">分析</h2><p>建立一个递归式来描述递归过程FIND-MAXIMUM-SUBARRAY的运行时间。对问题进行简化，假设原问题的规模为2的幂，这样所有子问题的规模均为整数。采用T(n)表示FIND-MAXIMUM-SUBARRAY求解n个元素的最大子数组的运行时间。</p><p>对于n=1的基本情况，花费常量时间，因此<span class="math inline">\(T(1)=\Theta(1)\)</span>。</p><p>当n&gt;1时为递归情况。到达递归调用前花费<span class="math inline">\(\Theta(1)\)</span>时间。递归求解的子问题均为n/2个元素的子数组（假定原问题规模为2的幂，保证了n/2为整数），因此每个子问题求解时间为T(n/2)。调用FIND-MAX-CROSSING-SUBARRAY花费<span class="math inline">\(\Theta(n)\)</span>时间。合并过程花费<span class="math inline">\(\Theta(1)\)</span>时间。因此，对于递归情况，有<span class="math inline">\(T(n)=\Theta(1)+2T(n/2)+\Theta(n)+\Theta(1)=2T(n/2)+\Theta(n)\)</span>。</p><p>结合两式，得到FIND-MAXIMUM-SUBARRAY运行时间T(n)的递归式： <span class="math display">\[T(n)=\begin{cases}\Theta(1)&amp;\text{if }n=1\\2T(n/2)+Theta(n)&amp;\text{if }n&gt;1\end{cases}\]</span> 此递归式与归并排序的递归式一样，其解为<span class="math inline">\(T(n)=\Theta(n\lg{n})\)</span>。利用分治策略的求解方法渐进复杂性优于暴力求解方法。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_max_crossing_subarray</span><span class="params">(a, low, mid, high)</span>:</span></span><br><span class="line">    left_sum = right_sum = float(<span class="string">'-inf'</span>)</span><br><span class="line">    max_left = max_right = t = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(low, mid + <span class="number">1</span>)):</span><br><span class="line">        t += a[i]</span><br><span class="line">        <span class="keyword">if</span> t &gt; left_sum:</span><br><span class="line">            left_sum, max_left = t, i</span><br><span class="line">    t = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(mid + <span class="number">1</span>, high + <span class="number">1</span>):</span><br><span class="line">        t += a[i]</span><br><span class="line">        <span class="keyword">if</span> t &gt; right_sum:</span><br><span class="line">            right_sum, max_right = t, i</span><br><span class="line">    <span class="keyword">return</span> max_left, max_right, left_sum + right_sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_maximum_subarray_dac</span><span class="params">(a, low, high)</span>:</span></span><br><span class="line">    <span class="string">"""divide and conquer"""</span></span><br><span class="line">    <span class="keyword">if</span> high == low:</span><br><span class="line">        <span class="keyword">return</span> low, high, a[low]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mid = (low + high) // <span class="number">2</span></span><br><span class="line">        left_low, left_high, left_sum = find_maximum_subarray_dac(a, low, mid)</span><br><span class="line">        right_low, right_high, right_sum = find_maximum_subarray_dac(a, low + <span class="number">1</span>, high)</span><br><span class="line">        cross_low, cross_high, cross_sum = find_max_crossing_subarray(a, low, mid, high)</span><br><span class="line">        <span class="keyword">if</span> left_sum &gt;= right_sum <span class="keyword">and</span> left_sum &gt;= cross_sum:</span><br><span class="line">            <span class="keyword">return</span> left_low, left_high, left_sum</span><br><span class="line">        <span class="keyword">elif</span> right_sum &gt;= left_sum <span class="keyword">and</span> right_sum &gt;= cross_sum:</span><br><span class="line">            <span class="keyword">return</span> right_low, right_high, right_sum</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> cross_low, cross_high, cross_sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">13</span>, <span class="number">-3</span>, <span class="number">-25</span>, <span class="number">20</span>, <span class="number">-3</span>, <span class="number">-16</span>, <span class="number">-23</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">-7</span>, <span class="number">12</span>, <span class="number">-5</span>, <span class="number">-22</span>, <span class="number">15</span>, <span class="number">-4</span>, <span class="number">7</span>]</span><br><span class="line">    print(find_maximum_subarray_dac(arr, <span class="number">0</span>, len(arr) - <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(7, 10, 43)</span><br></pre></td></tr></table></figure><h1 id="使用动态规划的算法">使用动态规划的算法</h1><p>从数组的左边界开始，从左至右处理，记录到目前为止已经处理过的最大子数组。定义数组dp，其中dp[j]代表数组<code>A[0...j]</code>中以A[j]结尾的最大子数组，则 <span class="math display">\[dp[j]=\begin{cases}A[j]&amp;j=0\\max(dp[j-1],0)+A[j]&amp;j=1\dots{n-1}\end{cases}\]</span></p><ul><li><p>j=0时，以A[j]结尾的最大子数组就是其本身。</p></li><li>j&gt;0时，以A[j]结尾的最大子数组可分为两种情况：<ul><li><p>最大子数组是<span class="math inline">\(A[i..j](0\le{i}&lt;j)\)</span>，此时dp[j]=dp[j-1]+A[j]</p></li><li><p>最大子数组是A<a href="i=j">j</a>，此时dp[j]=0+A[j]。</p><p>比较二者间较大的值，作为以A[j]结尾的最大子数组。</p></li></ul></li></ul><h2 id="代码-1">代码</h2><p>计算dp的过程如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kadanes</span><span class="params">(a)</span>:</span></span><br><span class="line">    dp = [<span class="number">0</span>] * len(a)</span><br><span class="line">    dp[<span class="number">0</span>] = a[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(a)):</span><br><span class="line">        dp[i] = max(dp[i - <span class="number">1</span>], <span class="number">0</span>) + a[i]</span><br><span class="line">    <span class="keyword">return</span> dp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">13</span>, <span class="number">-3</span>, <span class="number">-25</span>, <span class="number">20</span>, <span class="number">-3</span>, <span class="number">-16</span>, <span class="number">-23</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">-7</span>, <span class="number">12</span>, <span class="number">-5</span>, <span class="number">-22</span>, <span class="number">15</span>, <span class="number">-4</span>, <span class="number">7</span>]</span><br><span class="line">    print(max(kadanes(arr)))  <span class="comment"># 最大的值就是整个数组中的最大子数组</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">43</span><br></pre></td></tr></table></figure><h2 id="分析-1">分析</h2><p>对一个输入规模为n的数组，for循环的迭代次数为n，每次迭代花费<span class="math inline">\(\Theta(1)\)</span>时间。因此，算法的总代价为<span class="math inline">\(n*\Theta(1)=\Theta(n)\)</span>。</p><p>算法使用了一个长度为n的辅助数组，因此空间复杂度为<span class="math inline">\(\Theta(n)\)</span>。</p><h2 id="降低空间复杂度">降低空间复杂度</h2><p>若只需要整个数组的最大子数组，那么可以用一个变量代替dp数组，从而降低动态规划算法的空间复杂度。该变量记录到目前为止已处理过的最大子数组中最大的值。修改后的算法代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kadanes_r1</span><span class="params">(a)</span>:</span></span><br><span class="line">    current_max = total_max = float(<span class="string">'-inf'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(a)):</span><br><span class="line">        current_max = max(current_max, <span class="number">0</span>) + a[i]</span><br><span class="line">        total_max = max(total_max, current_max)</span><br><span class="line">    <span class="keyword">return</span> total_max</span><br></pre></td></tr></table></figure><p>修改后的算法时间复杂度还是<span class="math inline">\(\Theta(n)\)</span>，空间复杂度降低为O(1)。</p><h2 id="记录子数组位置">记录子数组位置</h2><p>展开max，在current_max和total_max的值发生改变的同时，更新起始或终止位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kadanes_r2</span><span class="params">(a)</span>:</span></span><br><span class="line">    current_max = total_max = float(<span class="string">'-inf'</span>)</span><br><span class="line">    start = end = temp_start = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(a)):</span><br><span class="line">        current_max += a[i]</span><br><span class="line">        <span class="keyword">if</span> current_max &lt; <span class="number">0</span>:</span><br><span class="line">            current_max, temp_start = <span class="number">0</span>, i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> total_max &lt; current_max:</span><br><span class="line">            total_max = current_max</span><br><span class="line">            start, end = temp_start, i</span><br><span class="line">    <span class="keyword">return</span> start, end, total_max</span><br></pre></td></tr></table></figure><p>时间复杂度为<span class="math inline">\(\Theta(n)\)</span>，空间复杂度为O(1)。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction To Algorithms </tag>
            
            <tag> divide-and-conquer </tag>
            
            <tag> dynamic programming </tag>
            
            <tag> algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序统计量</title>
      <link href="/notes/introduction-to-algorithms/order-statistics/"/>
      <url>/notes/introduction-to-algorithms/order-statistics/</url>
      
        <content type="html"><![CDATA[<h1 id="顺序统计量">顺序统计量</h1><p>在一个由n个元素组成的集合中，第i个顺序统计量（order statistic）是该集合中第i小的元素。</p><p>例如，在一个元素集合中，最小值是第1个顺序统计量（i=1），最大值是第n个顺序统计量（i=n）。</p><p>将从一个由n个互异的元素构成的集合中选择第i个顺序统计量的问题形式化定义为如下的<strong>选择问题</strong>：</p><p><strong>输入</strong>： 一个包含n个（互异的）数的集合A和一个整数<span class="math inline">\(i，1\le{i}\le{n}\)</span>。</p><p><strong>输出</strong>： 元素<span class="math inline">\(x\in{A}\)</span>，且A中恰好有i-1个其他元素小于它。</p><a id="more"></a><h1 id="最大值和最小值">最大值和最小值</h1><h2 id="找到最小值或最大值">找到最小值或最大值</h2><p>在一个有n个元素的集合中，找出其最小值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minimum</span><span class="params">(a)</span>:</span>  <span class="comment"># 与min()作用相同</span></span><br><span class="line">    <span class="keyword">if</span> len(a) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'minimum() arg is an empty sequence'</span>)</span><br><span class="line">    m = a[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(a)):  <span class="comment"># 循环n-1次，n位数组长度</span></span><br><span class="line">        m = min(m, a[i])  <span class="comment"># 元素之间比较n-1次</span></span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">18</span>, <span class="number">24</span>, <span class="number">17</span>, <span class="number">3</span>, <span class="number">21</span>, <span class="number">7</span>, <span class="number">23</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">39</span>, <span class="number">46</span>, <span class="number">26</span>, <span class="number">30</span>, <span class="number">38</span>, <span class="number">52</span>]</span><br><span class="line">    print(<span class="string">'min ='</span>, minimum(arr))</span><br></pre></td></tr></table></figure><p>需要做n-1次比较，n-1次既是其比较次数上界亦是其下界。找出最大值的方法类似。</p><p>在一个包含n个元素的集合中找出最小值（最大值）的时间是<span class="math inline">\(\Theta(n)\)</span>。</p><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min = 3</span><br></pre></td></tr></table></figure><h2 id="同时找到最小值和最大值">同时找到最小值和最大值</h2><p>可以分别独立地找出最小值和最大值，这各需要n-1次比较，共需2n-2次比较。即将每个元素与当前最小值比较一次，再与最大元素比较一次。代价是每个元素都需要2次比较。</p><p>事实上，只需要最多<span class="math inline">\(3\lfloor{n/2}\rfloor\)</span>次比较就可以同时找到最小值和最大值。</p><p>记录已知的最大值和最小值，对输入元素成对地进行处理。首先，将一对输入元素相互进行比较，然后把较小的与当前最小值比较，把较大的与当前最大值进行比较。这样，对每连个元素共需3次比较。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min_max</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(a) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'min_max() arg is an empty sequence'</span>)</span><br><span class="line">    mini = maxi = a[<span class="number">0</span>]  <span class="comment"># n为奇数时，临时变量同时指向第一个元素</span></span><br><span class="line">    i = <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> len(a) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        mini, maxi = a[<span class="number">0</span>], a[<span class="number">1</span>]  <span class="comment"># n为偶数时，先比较前两个元素确定当前最小值和最大值</span></span><br><span class="line">        <span class="keyword">if</span> mini &lt; maxi:</span><br><span class="line">            mini, maxi = maxi, mini</span><br><span class="line">        i = <span class="number">3</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(a):</span><br><span class="line">        x, y = a[i - <span class="number">1</span>], a[i]</span><br><span class="line">        <span class="keyword">if</span> a[i - <span class="number">1</span>] &gt; a[i]:</span><br><span class="line">            x, y = y, x  <span class="comment"># 先比较数组中两个元素</span></span><br><span class="line">        mini = min(mini, x)  <span class="comment"># 小的元素与当前最小值比较</span></span><br><span class="line">        maxi = max(maxi, y)  <span class="comment"># 大的元素与当前最大值比较</span></span><br><span class="line">        i += <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> mini, maxi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">18</span>, <span class="number">24</span>, <span class="number">17</span>, <span class="number">3</span>, <span class="number">21</span>, <span class="number">7</span>, <span class="number">23</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">39</span>, <span class="number">46</span>, <span class="number">26</span>, <span class="number">30</span>, <span class="number">38</span>, <span class="number">52</span>]</span><br><span class="line">    print(<span class="string">'(min, max) ='</span>, min_max(arr))</span><br></pre></td></tr></table></figure><p>分析以下总的比较次数：</p><ul><li>如果n是奇数，那么第一个元素不用比较，后n-1个元素每两个进行3次比较，总共进行<span class="math inline">\(3(n-1)/2=3\lfloor{n/2}\rfloor\)</span>次比较。</li><li>如果n是偶数，那么前两个元素比较1次，后n-2个元素每两个进行3次比较，总共进行<span class="math inline">\(1+3(n-2)/2=3n/2-2&lt;3\lfloor{n/2}\rfloor\)</span>。</li></ul><p>因此，不管是哪一种情况，总的比较次数至多是<span class="math inline">\(3\lfloor{n/2}\rfloor\)</span>。</p><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(min, max) = (3, 52)</span><br></pre></td></tr></table></figure><h1 id="期望为线性时间的选择算法">期望为线性时间的选择算法</h1><p>一般选择问题看起来要比找最小值这样的简单问题更难。但令人惊奇的是，这两个问题的渐进运行时间确实相同的：<span class="math inline">\(\Theta(n)\)</span>。下面介绍一种解决选择问题的分治算法。RANDOMIZED-SELECT算法是以快速排序算法为模型的。</p><ul><li><p>与快速排序一样，将输入数组进行递归划分。</p></li><li><p>与快速排序不同的是，快速排序会递归处理划分的两边，而RANDOMIZED-SELECT只处理划分的一边。快速排序的期望运行时间是<span class="math inline">\(n\lg(n)\)</span>，而RANDOMIZED-SELECT的期望运行时间为O(n)。</p></li></ul><p>RANDOMIZED-SELECT返回数组<code>A[p...r]</code>中第i小的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RANDOMIZED-SELECT(A, p, r, i):</span><br><span class="line">    <span class="keyword">if</span> p == r:          <span class="comment"># 如果数组中只包括一个元素，那么此时i必然等于1</span></span><br><span class="line">        <span class="keyword">return</span> A[p]    <span class="comment"># 此时只需返回这唯一的一个元素</span></span><br><span class="line">    q = RANDOMIZED-PARTITION(A, p, r)  <span class="comment"># 随机选择主元并划分，返回主元位置。因为主元与其他元素</span></span><br><span class="line">    k = q-p+<span class="number">1</span>  <span class="comment"># 主元是第k小             # 都比较过，所以主元所在位置就是最终在已排序数组中的位置</span></span><br><span class="line">    <span class="keyword">if</span> i == k:          <span class="comment"># 检测A[q]是否是第i小元素</span></span><br><span class="line">        <span class="keyword">return</span> A[q]</span><br><span class="line">    <span class="keyword">elif</span> i &lt; k:         <span class="comment"># i&lt;k说明A[q]过大，要找的元素落在左边</span></span><br><span class="line">        <span class="keyword">return</span> RANDOMIZED-SELECT(A, p, q<span class="number">-1</span>, i)</span><br><span class="line">    <span class="keyword">else</span>:               <span class="comment"># 否则落在右边</span></span><br><span class="line">        <span class="keyword">return</span> RANDOMIZED-SELECT(A, q+<span class="number">1</span>, r, i-k)  <span class="comment"># 左边+主元一共k个元素，在右边要找第i-k小元素</span></span><br></pre></td></tr></table></figure><p>程序判断了p==r即子数组只含有1个元素的情况，那么含有0个元素的情况呢？划分操作有可能产生长度为0的子数组，那么上述递归操作会调用含有0个元素的子数组吗？答案是这种情况不会发生。考虑主元位于边界的情况：</p><ul><li>p=q：左边子数组长度为0，右边不为0。主元是第1小元素，由于i不可能小于1，若所寻目标i=1，程序结束并返回；若i&gt;1，程序将在右边的子数组中递归寻找。</li><li>p=r：与p=q是对称的。i不可能大于n（数组中元素总个数）。此时主元是第n小，若i=n，程序结束并返回；若i&lt;n，则在左边的子数组中递归寻找。</li></ul><p>因此，程序会不递归调用含有0个元素的数组。</p><h2 id="分析">分析</h2><p>RANDOMIZED-SELECT的最坏情况运行时间为<span class="math inline">\(\Theta(n^2)\)</span>，即使是找最小元素也是如此，因为在每次划分时可能极不走运地总是按余下的元素中最大的来进行划分，而划分操作需要<span class="math inline">\(\Theta(n)\)</span>时间。但因为算法是随机化的，所以不存在一个特定的会导致其最坏情况发生的输入数据。下面分析算法的期望运行时间。</p><p>设该算法在一个含有n个元素的输入数组<code>A[p...r]</code>上的运行时间是一个随机变量，记为T(n)。对每一个<span class="math inline">\(k(1\le{k}\le{n})\)</span>，子数组<code>A[p...q]</code>（全部小于或等于主元）有k个元素的概率是1/n。对所有的<code>k=1,2,...,n</code>，定义指示器变量<span class="math inline">\(X_k\)</span>为：<span class="math inline">\(X_k=I\lbrace子数组A[p...q]正好包含k个元素\rbrace\)</span>。假设元素是互异的，有<span class="math inline">\(E[X_k]=1/n\)</span>。</p><p>为了得到所需时间的上界，假定查找的第i个元素总是在划分中包含较大元素的一边。指示器随机变量<span class="math inline">\(X_k\)</span>恰好在给定的k值上取值1，对其他值都为0。当<span class="math inline">\(X_k=1\)</span>时，可能要递归处理的两个子数组大小分别为k-1和n-k。因此可以得到递归式： <span class="math display">\[\begin{aligned}T(n)&amp;\le\sum_{k=1}^nX_k\cdot\Bigl(T\bigl(max(k-1,n-k)\bigr)+O(n)\Bigr)\\&amp;=\sum_{k=1}^nX_k\cdot{T(max(k-1,n-k))}+O(n)\end{aligned}\]</span> 两边取期望值，得到 <span class="math display">\[\begin{aligned}E[T(n)]&amp;\le{E\Big[\sum_{k=1}^nX_k\cdot{T(max(k-1,n-k))}+O(n)\Bigr]}\\&amp;=\sum_{k=1}^nE\Big[X_k\cdot{T(max(k-1,n-k))}\Big]+O(n)\quad\text{(期望的线性性质)}\\&amp;=\sum_{k=1}^nE[X_k]\cdot{E[T(max(k-1,n-k))]}+O(n)\quad\text{(}X_k\text{和}T(max(k-1,n-k))\text{相互独立)}\\&amp;=\sum_{k=1}^n\frac{1}{n}\cdot{E[T(max(k-1,n-k))]}+O(n)\end{aligned}\]</span> 考虑表达式max(k-1,n-k)，有 <span class="math display">\[max(k-1,n-k)=\begin{cases}k-1\quad\text{若}k&gt;\lceil{n/2}\rceil\\n-k\quad\text{若}k\le\lceil{n/2}\rceil\end{cases}\]</span> 观察到表达式max(k-1,n-k)的取值是成对出现的：</p><ul><li>如果n是偶数，则<span class="math inline">\(k=1,2,\dots,n/2\)</span>与<span class="math inline">\(k=n,n-1,\dots,n/2+1\)</span>时的取值相等，取值分别是<span class="math inline">\(n-1,n-2,\dots,n/2\)</span>。</li><li>如果n是奇数，则<span class="math inline">\(k=1,2,\dots,\lfloor{n/2}\rfloor\)</span>与<span class="math inline">\(k=n,n-1,\dots,\lceil{n/2}\rceil+1\)</span>时的取值相等，分别是<span class="math inline">\(n-1,n-2,\dots,\lceil{n/2}\rceil\)</span>。此外<span class="math inline">\(k=\lceil{n/2}\rceil\)</span>时的取值单独出现，值是<span class="math inline">\(\lfloor{2/n}\rfloor\)</span>。</li></ul><p>因此，有 <span class="math display">\[E[T(n)]\le\frac{2}{n}\sum_{k=\lfloor{n/2}\rfloor}^{n-1}E[T(k)]+O(n)\]</span> 下面用替代法来得到E[T(n)]=O(n)。</p><p>假设对某个常数c，有<span class="math inline">\(E[T(n)]\le{cn}\)</span>。假设对小于某个常数的n，有T(n)=O(1)。同时，选择一个常数a，使得对所有n&gt;0，上式中O(n)项所描述的函数有上界an。利用这个归纳假设，可以得到： <span class="math display">\[\begin{aligned}E[T(n)]&amp;\le\frac{2}{n}\sum_{k=\lfloor{n/2}\rfloor}^{n-1}ck+an\\&amp;=\frac{2c}{n}\Big(\sum_{k=1}^{n-1}k-\sum_{k=1}^{\lfloor{n/2}\rfloor-1}k\Big)+an\\&amp;=\frac{2c}{n}\Big(\frac{(n-1)n}{2}-\frac{(\lfloor{n/2}\rfloor-1)\lfloor{n/2}\rfloor}{2}\Big)+an\\&amp;\le\frac{2c}{n}\Big(\frac{(n-1)n}{2}-\frac{(n/2-2)(n/2-1)}{2}\Big)+an\\&amp;=\frac{2c}{n}\Big(\frac{n^2-n}{2}-\frac{n^2-3n/2+2}{2}\Big)+an\\&amp;=\frac{c}{n}(\frac{3n}{4}+\frac{1}{2}-\frac{2}{n})+an\\&amp;\le\frac{3cn}{4}+\frac{c}{2}+an\\&amp;=cn-\color{red}{(\frac{cn}{4}-\frac{c}{2}-an)}\end{aligned}\]</span> 为了完成证明，还需要证明：对足够大的n，最后一个表达式至多是cn。 <span class="math display">\[\begin{aligned}\frac{cn}{4}-\frac{c}{2}-an&amp;\ge0\\n(\frac{c}{4}-a)&amp;\ge\frac{c}{2}\end{aligned}\]</span> 只要选择的常数c能够满足c/4-a&gt;0，就可以将两边同时除以c/4-a，得到 <span class="math display">\[n\ge\frac{c/2}{c/4-a}=\frac{2c}{c-4a}\]</span> 因此，如果假设对所有n&lt;2c/(c-4a)，都有T(n)=O(1)，那么就有E[T(n)]=O(n)。</p><p>结果：假设所有元素是互异的，在期望线性时间内，可以找到任一顺序统计量，特别是中位数（？）。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sort.quick_sort <span class="keyword">import</span> partition</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randomized_select</span><span class="params">(a, p, r, i)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> p == r:  <span class="comment"># 只有一个元素时，i一定等于1，i代表的是在a[p..r]中第i小</span></span><br><span class="line">        <span class="keyword">return</span> a[p]</span><br><span class="line">    q = partition(a, p, r, randint(p, r))  <span class="comment"># 随机选择主元并划分</span></span><br><span class="line">    k = q - p + <span class="number">1</span>  <span class="comment"># 主元是第k小元素</span></span><br><span class="line">    <span class="keyword">if</span> i == k:</span><br><span class="line">        <span class="keyword">return</span> a[q]</span><br><span class="line">    <span class="keyword">elif</span> i &lt; k:  <span class="comment"># 在左边继续寻找</span></span><br><span class="line">        <span class="keyword">return</span> randomized_select(a, p, q - <span class="number">1</span>, i)</span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 在右边继续寻找，注意要寻找的序号要变化</span></span><br><span class="line">        <span class="keyword">return</span> randomized_select(a, q + <span class="number">1</span>, r, i - k)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">18</span>, <span class="number">24</span>, <span class="number">17</span>, <span class="number">3</span>, <span class="number">21</span>, <span class="number">7</span>, <span class="number">23</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">39</span>, <span class="number">46</span>, <span class="number">26</span>, <span class="number">30</span>, <span class="number">38</span>, <span class="number">52</span>]</span><br><span class="line">    print([randomized_select(arr, <span class="number">0</span>, len(arr) - <span class="number">1</span>, i + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr))])</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3, 7, 17, 18, 21, 23, 24, 26, 30, 35, 38, 39, 41, 46, 52]</span><br></pre></td></tr></table></figure><h1 id="最坏情况为线性时间的选择算法">最坏情况为线性时间的选择算法</h1><p>本节介绍一个最坏情况运行时间为<span class="math inline">\(\Theta(n)\)</span>的选择算法：SELECT算法。像RANDOMIZED-SELECT一样，SELECT算法通过对输入数组的递归划分来找出所需元素，但是，在该算法中<strong>能够保证得到对数组的一个好的划分</strong>。</p><p>SELECT算法的执行步骤如下：</p><ol type="1"><li>如果n=1，则返回唯一元素作为第i小的元素。否则将输入数组的n个元素划分为<span class="math inline">\(\lfloor{n/5}\rfloor\)</span>组，每组5个元素，剩下的一组至多由n%5个元素组成。</li><li>寻找这<span class="math inline">\(\lceil{n/5}\rceil\)</span>组中每一组的中位数：首先对每组元素进行插入排序，然后确定每组有序元素的中位数。</li><li>对第2步中找出的<span class="math inline">\(\lceil{n/5}\rceil\)</span>个中位数，递归调用SELECT以找出其中的中位数x（如果由偶数个中位数，为了方便，约定x是较小的中位数）。</li><li>按中位数的中位数x对输入数组进行划分。让k比划分的低区中的元素数目多1，因此x是第k小的元素，并且有n-k个元素在划分的高区。</li><li>如果i=k，则返回x。如果i&lt;k，则在地区递归调用SELECT来找出第i小的元素。如果i&gt;k，则在高区递归查找第i-k小的元素。</li></ol><h2 id="分析-1">分析</h2><p>首先确定大于划分主元x的元素个数的下界。下图给出了一些形象的说明。在第2步找出的中位数中，至少有一半大于或等于中位数的中位数x。因此，在这<span class="math inline">\(\lceil{n/5}\rceil\)</span>个组中， 除了当n不能被5整除时产生的所含元素少于5的那个组，和包含x的那个组之外，至少有一半的组中有3个元素大于x。不算这两个组，大于x的元素个数至少为 <span class="math display">\[3\Bigl(\big\lceil\frac{1}{2}\lceil\frac{n}{5}\rceil\big\rceil-2\Bigr)\ge\frac{3n}{10}-6\]</span> 类似地，至少有3n/10-6个元素小于x。因此，在最坏情况下，在第5步中，SELECT的递归调用最多作用于7n/10+6个元素。</p><p><img data-src="/uploads/posts/introduction-to-algorithms/select-analysis.png" title="灰色阴影覆盖的元素全都大于x"></p><p>现在，设计一个递归式来推到SELECT算法的最坏情况运行时间T(n)。</p><p>步骤1：分组需要O(n)时间。</p><p>步骤2：对大小为O(1)（大小为5）的集合调用O(n)（<span class="math inline">\(\lceil{n/5}\rceil\)</span>次）插入排序，总时间也为O(n)。</p><p>步骤3：递归所需时间为<span class="math inline">\(T(\lceil{n/5}\rceil)\)</span>。</p><p>步骤4：partition所需时间为O(n)。</p><p>步骤5：递归所需时间至多为T(7n/10+6)。</p><p>将上述时间累加，可得到 <span class="math display">\[T(n)\le{T(\lceil{n/5}\rceil)+T(7n/10+6)+O(n)}\]</span> 下面用替换法证明这个运行时间是线性的。更明确地说，证明对某个适当大的常数c和所有的n&gt;0，有<span class="math inline">\(T(n)\le{cn}\)</span>。挑选一个常数a，使得对所有的n&gt;0，公式中的O(n)项所对应的函数有上界an。假设<span class="math inline">\(T(n)\le{cn}\)</span>成立。将假设带入上述递归式的右边，得到 <span class="math display">\[\begin{aligned}T(n)&amp;\le{c\lceil{n/5}\rceil}+c(7n/10+6)+an\\&amp;\le{cn/5+c}+7cn/10+6c+an\\&amp;=9cn/10+7c+an\\&amp;=cn+\color{red}{(-cn/10+7c+an)}\end{aligned}\]</span> 若<span class="math inline">\(-cn/10+7c+an\le0\)</span>时，则<span class="math inline">\(T(n)\le{cn}\)</span>成立。 <span class="math display">\[\begin{aligned}-cn/10+7c+an&amp;\le0\\cn/10-7c&amp;\ge{an}\\c\frac{n-70}{10}&amp;\ge{an}\end{aligned}\]</span> 观察上式可知，当n&gt;70时，<span class="math inline">\(-cn/10+7c+an\le0\)</span>，此时<span class="math inline">\(c\ge10a\color{red}{(n/(n-70))}\)</span>。 <span class="math display">\[\frac{n}{n-70}=\frac{1}{1-\frac{70}{n}}\]</span> 当n增大时，n/(n-70)减小，因此只要适当地选择c的值，使不等式<span class="math inline">\(-cn/10+7c+an\le0\)</span>成立，就能证明<span class="math inline">\(T(n)\le{cn}\)</span>。例如，n&gt;70时，<span class="math inline">\(n/(n-70)\le71\)</span>，选择常数<span class="math inline">\(c\ge710a\)</span>即可满足<span class="math inline">\(T(n)\le{cn}\)</span>。又例如，当<span class="math inline">\(n\ge140\)</span>时，<span class="math inline">\(n/(n-70)\le2\)</span>，选择常数<span class="math inline">\(c\ge20a\)</span>即可。无论如何选择n的边界x，在n&lt;x时，<span class="math inline">\(T(n)\le{cn}\)</span>成立（只需选择足够大的c即可）。因此，最坏情况下SELECT的运行时间是线性的。</p><h2 id="代码-1">代码</h2><p>不同的是：将选择中位数的中位数过程（步骤1~3）从选择算法中独立出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sort.quick_sort <span class="keyword">import</span> partition</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> ceil</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(a, i, j)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> i != j:</span><br><span class="line">        a[i], a[j] = a[j], a[i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span><span class="params">(a, p, r)</span>:</span>  <span class="comment"># 修改过的插入排序，对a[p..r]进行排序</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(p + <span class="number">1</span>, r + <span class="number">1</span>):</span><br><span class="line">        key = a[j]</span><br><span class="line">        i = j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= p <span class="keyword">and</span> a[i] &gt; key:</span><br><span class="line">            a[i + <span class="number">1</span>] = a[i]</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        a[i + <span class="number">1</span>] = key</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">median_of_median</span><span class="params">(a, p, r)</span>:</span></span><br><span class="line">    <span class="string">"""将数组分成每5个元素一组，找其中位数，若有多个，递归中位数组成的数组，继续寻找"""</span></span><br><span class="line">    <span class="keyword">if</span> p == r:</span><br><span class="line">        <span class="keyword">return</span> a[p]</span><br><span class="line">    <span class="comment"># 对每5个元素调用插入排序</span></span><br><span class="line">    left = p</span><br><span class="line">    <span class="keyword">while</span> left &lt;= r:</span><br><span class="line">        right = min(left + <span class="number">4</span>, r)</span><br><span class="line">        insertion_sort(a, left, right)  <span class="comment"># 对每5个数排序，剩下的一组若不足5个，有几个算几个</span></span><br><span class="line">        <span class="comment"># 交换中位数到数组前面，方便递归调用</span></span><br><span class="line">        exchange(a, p + (right - p) // <span class="number">5</span>, (right + left) // <span class="number">2</span>)</span><br><span class="line">        left += <span class="number">5</span></span><br><span class="line">    n = ceil((r - p + <span class="number">1</span>) / <span class="number">5</span>)  <span class="comment"># 所有分组的中位数的个数</span></span><br><span class="line">    <span class="keyword">return</span> median_of_median(a, p, p + n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select</span><span class="params">(a, p, r, i)</span>:</span></span><br><span class="line">    median_of_median(a, p, r)  <span class="comment"># 找出中位数的中位数，过程结束时找到的中位数位置为p</span></span><br><span class="line">    q = partition(a, p, r, p)  <span class="comment"># 以找到的中位数为pivot，划分数组</span></span><br><span class="line">    k = q - p + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i == k:</span><br><span class="line">        <span class="keyword">return</span> a[q]</span><br><span class="line">    <span class="keyword">elif</span> i &lt; k:</span><br><span class="line">        <span class="keyword">return</span> select(a, p, q - <span class="number">1</span>, i)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> select(a, q + <span class="number">1</span>, r, i - k)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">18</span>, <span class="number">24</span>, <span class="number">17</span>, <span class="number">3</span>, <span class="number">21</span>, <span class="number">7</span>, <span class="number">23</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">39</span>, <span class="number">46</span>, <span class="number">26</span>, <span class="number">30</span>, <span class="number">38</span>, <span class="number">52</span>]</span><br><span class="line">    print([select(arr, <span class="number">0</span>, len(arr) - <span class="number">1</span>, i + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr))])</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3, 7, 17, 18, 21, 23, 24, 26, 30, 35, 38, 39, 41, 46, 52]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction To Algorithms </tag>
            
            <tag> divide-and-conquer </tag>
            
            <tag> algorithms </tag>
            
            <tag> quicksort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大流</title>
      <link href="/notes/introduction-to-algorithms/maximum-flow/"/>
      <url>/notes/introduction-to-algorithms/maximum-flow/</url>
      
        <content type="html"><![CDATA[<h1 id="流网络和流">流网络和流</h1><p><strong>流网络</strong>G=(V,E)是一个有向图，图中每条边<span class="math inline">\((u,v)\in{E}\)</span>有一个非负的<strong>容量值</strong><span class="math inline">\(c(u,v)\ge0\)</span>。而且，如果边集合E包含一条边(u,v)，则图中不存在反向边(v,u)。如果<span class="math inline">\((u,v)\notin{E}\)</span>，为方便起见，定义c(u,v)=0，并且在图中不允许自循环。</p><p>在流网络的所有结点中，特别分辨出两个特殊结点：<strong>源结点</strong>s和<strong>汇点</strong>t。为方便起点，假定每个结点都在从源结点到汇点的某条路径上。因此，流网络图是连通的，并且由于除源结点外的每个结点都至少有一条进入的边，有<span class="math inline">\(|E|\ge|V|-1\)</span>。下图描述的是一个流网络的例子。</p><p><img data-src="/uploads/posts/introduction-to-algorithms/flow-network.png" title="一个流网络"></p><a id="more"></a><p>下面给出流的形式化定义。设G=(V,E)为一个流网络，其容量函数为c。设s为网络的源结点，t为汇点。G中的<strong>流</strong>是一个实值函数<span class="math inline">\(f:V\times{V}\rightarrow\mathbb{R}\)</span>，满足下面的两条性质：</p><ul><li>容量限制：对于所有的结点<span class="math inline">\(u,v\in{V}\)</span>，要求<span class="math inline">\(0\le{f(u,v)}\le{c(u,v)}\)</span>。</li><li>流量守恒：对于所有的结点<span class="math inline">\(u\in{V-\lbrace{s,t}\rbrace}\)</span>，要求</li></ul><p><span class="math display">\[\sum_{v\in{V}}f(v,u)=\sum_{v\in{V}}f(u，v)\]</span></p><p>当<span class="math inline">\((u,v)\notin{E}\)</span>时，从结点u到结点v之间没有流，因此f(u,v)=0。</p><p>容量限制性质说明，从一个结点到另一个结点之间的流必须为非负值且不能超过给定的容量限制。</p><p>流量守恒性质说明，流入一个结点（源结点和汇点除外）的总流量必须等于流出该节点的总流量，“流入等于流出”。</p><p>一个流f的<strong>值</strong>|f|（这里，符号| |表示流的值）定义如下： <span class="math display">\[|f|=\sum_{v\in{V}}f(s,v)-\sum_{v\in{V}}f(v,s)\tag{26.1}\]</span> 也就是说，流f的值是从源结点流出的总流量减去流入源结点的总流量。在<strong>最大流问题</strong>中，给定一个流网络G、一个源结点s、一个汇点t，希望找到值最大的一个流。</p><h1 id="反平行边多源点汇点">反平行边、多源点汇点</h1><p>上述流网络假设：如果边<span class="math inline">\((u,v)\in{E}\)</span>，则<span class="math inline">\((v,u)\notin{E}\)</span>。称(u,v)和边(v,u)为<strong>反平行</strong>（antiparallel）。如果一个流问题中包含反平行边，必须将这种网络转换为一个等价的但不包含反平行边的网络。下图描述的就是这样一个等价网络。选择两条反平行边中的一条，在这个例子中是边<span class="math inline">\((v_1,v_2)\)</span>，通过加入一个新结点<span class="math inline">\(v^\prime\)</span>来将其分且为两段，并以边<span class="math inline">\((v_1,v^\prime)\)</span>和<span class="math inline">\((v^\prime,v_2)\)</span>来替换边<span class="math inline">\((v_1,v_2)\)</span>。同时将两条新设立的边的容量设置为与原来的边的容量相同。</p><p><img data-src="/uploads/posts/introduction-to-algorithms/flow-network-with-antiparallel-edges.png" title="带有反平行边的流网络"></p><p>一个最大流问题可能有几个源结点和几个汇点。在具有多个源结点和汇点的网络中，确定最大流的问题可以规约为一个普通的最大流问题。下图(b描述的是如何将(a)所示的网络转换为只有一个源结点和一个汇点的普通流网络。转换方法是加入一个<strong>超级源结点</strong>s，并加入有向边<span class="math inline">\((s,s_i),i=1,2,\dots,m\)</span>，其容量<span class="math inline">\(c(s,s_i)=\infty\)</span>。同时创建一个新的<strong>超级汇点</strong>t，并加入有向边<span class="math inline">\((t_i,t),i=1,2,\dots,n\)</span>，其容量<span class="math inline">\(c(t_i,t)=\infty\)</span>。</p><p><img data-src="/uploads/posts/introduction-to-algorithms/flow-network-with-multiple-source-multiple-sink.png" title="含有多个源结点和汇点的流网络"></p><h1 id="ford-fulkerson方法">Ford-Fulkerson方法</h1><p>Ford-Fulkerson方法是解决最大流问题的一种方法。之所以称其为“方法”而不是“算法”，是因为它包含了几种运行时间各不相同的具体实现。Ford-Fulkerson方法依赖于三种重要思想，它们与许多的流算法和问题有关：残存网络、增广路径和切割。这些思想是最大流最小切割定理的精髓。</p><p>Ford-Fulkerson方法循环增加流的值。</p><ul><li>在开始的时候，对于所有的结点<span class="math inline">\(u,v\in{V}\)</span>，f(u,v)=0，给出的初始流值为0。</li><li>在每一次迭代中，将图G的流值进行增加，方法是在一个关联的“残存网络”<span class="math inline">\(G_f\)</span>中寻找一条“增广路径”。增加的是整个网络中的流量，对于图中特定的一条边来说，其流量在迭代过程中可能增加，也可能减少。对某些边的流进行缩减可能是必要的，以便让算法可以将更多的流从源结点发送到汇点。</li><li>重复对流进行上述迭代过程，直到残存网络中不再存在增广路径未知。最大流最小切割定理将说明在算法终止时，将获得一个最大流。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FORD-FULKERSON-METHOD(G, s, t):</span><br><span class="line">    initialize flow f to <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> there exists an augmenting path p <span class="keyword">in</span> the residual network:</span><br><span class="line">        augment flow f along p</span><br><span class="line">    <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure><p>为了实现和分析Ford-Fulkerson方法，需要引入几个新的概念。</p><h2 id="残存网络">残存网络</h2><p>从直观上看，给定流网络G和流量f，残存网络<span class="math inline">\(G_f\)</span>由那些仍有空间对流量进行调整的边构成。</p><ul><li>流网络的一条边可以允许的额外流量等于该边的容量减去该边上的流量。如果该差值为正，则将该条边置于图<span class="math inline">\(G_f\)</span>中，并将其残存容量设置为<span class="math inline">\(c_f(u,v)=c(u,v)-f(u,v)\)</span>。如果边(u,v)的流量等于其容量，则其<span class="math inline">\(c_f(u,v)=0\)</span>，该条边将不属于<span class="math inline">\(G_f\)</span>。</li><li>残存网络<span class="math inline">\(G_f\)</span>还可能包含图G中不存在的边。算法对流量进行操作的目标是增加总流量，为此，算法可能对某些特定边上的流量进行缩减。为了表示对一个正流量f(u,v)的缩减，将边(v,u)加入到图<span class="math inline">\(G_f\)</span>中，并将其残存容量设置为<span class="math inline">\(c_f(v,u)=f(u,v)\)</span>。也就是说，一条边所能允许的反向流量最多将其正向流量抵消。</li></ul><p>残存网络中的这些反向边允许算法将已经发送出来的流量发送回去。而将流量从同一条边发送回去等同于缩减该条边的流量，这种操作在许多算法中都是必要的。</p><p>更形式化地，假定由一个流网络G=(V,E)，其源结点为s，汇点为t。设f为图G中的一个流，考虑结点对<span class="math inline">\(u,v\in{V}\)</span>，定义残存容量<span class="math inline">\(c_f(u,v)\)</span>如下： <span class="math display">\[c_f(u,v)=\begin{cases}c(u,v)-f(u,v)&amp;\text{if }(u,v)\in{E}\\f(v,u)&amp;\text{if }(v,u)\in{E}\\0&amp;otherwise\end{cases}\tag{26.2}\]</span> 因为假定边<span class="math inline">\((u,v)\in{E}\)</span>意味着<span class="math inline">\((v,u)\notin{E}\)</span>（对流网络的假设），对于每一对边来说，上述公式中只有一种情况成立。下图中，(a)所示的流网络中流f所对应的残存网络如(b)所示。</p><p>给定一个流网络G=(V,E)和一个流f，则由f所诱导的图G的残存网络为<span class="math inline">\(G_f=(V,E_f)\)</span>，其中 <span class="math display">\[E_f=\lbrace(u,v)\in{V\times{V}}:c_f(u,v)&gt;0\rbrace\]</span> 也就是说，残存网络的每条边或<strong>残存边</strong>，必须允许大于0的流量通过。图(a)给出了流网络G和流量f，图(b)描述的是对应的残存网络<span class="math inline">\(G_f\)</span>。<span class="math inline">\(E_f\)</span>中的边要么是E中原有的边，要么是其反向边，因此有 <span class="math display">\[|E_f|\le2|E|\]</span></p><p><img data-src="/uploads/posts/introduction-to-algorithms/maximum-flow-problem.png" title="最大流问题以及残存网络"></p><p>可以在残存网络中定义一个流，它满足流的定义，但是针对的是残存网络<span class="math inline">\(G_f\)</span>中的容量<span class="math inline">\(c_f\)</span>。残存网络中的一个流指出的是一条路线图：如何在原来的流网络中增加流。如果f是G的一个流，<span class="math inline">\(f^\prime\)</span>是对应的残存网络<span class="math inline">\(G_f\)</span>中的一个流，定义<span class="math inline">\(f\uparrow{f^\prime}\)</span>为流<span class="math inline">\(f^\prime\)</span>对流f的<strong>递增</strong>（augmentation），它是一个从<span class="math inline">\(V\times{V}\)</span>到<span class="math inline">\(\mathbb{R}\)</span>的函数，其定义如下： <span class="math display">\[(f\uparrow{f^\prime})(u,v)=\begin{cases}f(u,v)+f^\prime(u,v)-f^\prime(v,u)&amp;if (u,v)\in{E}\\0&amp;otherwise\end{cases}\tag{26.4}\]</span></p><p>该定义背后的直观解释遵循残存网络的定义。因为在残存网络中将流量发送到反向边上等同于在原来的网络中缩减流量，所以将边(u,v)的流量增加了<span class="math inline">\(f^\prime(u,v)\)</span>，但减少了<span class="math inline">\(f^\prime(v,u)\)</span>。在残存网络中将流量推送回去也称为<strong>抵消操作</strong>（cancellation）。例如，如果将5货箱的冰球从城市u发送到城市v，同时将2货箱冰球从城市v发送到城市u，那么可以等价（以最后结果来看）地将3货箱冰球从城市u发送到城市v，而不从城市v发送货箱到城市u。这类抵消操作对于任何最大流算法来说都是非常关键的。</p><blockquote><p>引理26.1</p><p>设G=(V,E)为一个流网络，源结点为s，汇点为t，设f为G中的一个流。设<span class="math inline">\(G_f\)</span>为由流f所诱导的G的残存网络，设<span class="math inline">\(f^\prime\)</span>为<span class="math inline">\(G_f\)</span>中的一个流。那么式(26.4)所定义的函数<span class="math inline">\(f\uparrow{f^\prime}\)</span>是G的一个流，其值<span class="math inline">\(|f\uparrow{f^\prime}|=|f|+|f^\prime|\)</span>。</p></blockquote><p><strong>证明</strong>：首先证明<span class="math inline">\(f\uparrow{f^\prime}\)</span>是G的一个流，即满足流的两条性质：容量限制和流量守恒。</p><p>对于容量限制，注意到，如果边<span class="math inline">\((u,v)\in{E}\)</span>，则<span class="math inline">\(c_f(v,u)=f(u,v)\)</span>。而且<span class="math inline">\(f^\prime(v,u)\le{c_f(v,u)}=f(u,v)\)</span>。因此， <span class="math display">\[\begin{aligned}(f\uparrow{f^\prime})(u,v)&amp;=f(u,v)+f^\prime(u,v)-f^\prime(v,u)&amp;\text{(by equation(26.4))}\\&amp;\ge{f(u,v)+f^\prime(u,v)}-f(u,v)&amp;\text{(because }f^\prime(v,u)\le{f(u,v)}\text{)}\\&amp;=f^\prime(u,v)\\&amp;\ge0\end{aligned}\]</span> 此外， <span class="math display">\[\begin{aligned}(f\uparrow{f^\prime})(u,v)&amp;=f(u,v)+f^\prime(u,v)-f^\prime(v,u)&amp;\text{(by equation(26.4))}\\&amp;\le{f(u,v)+f^\prime(u,v)}&amp;\text{(because flows are nonnegative}\\&amp;\le{f(u,v)+c_f(u,v)}&amp;\text{(capacity constraint)}\\&amp;=f(u,v)+c(u,v)-f(u,v)&amp;\text{(by definition (26.2))}\\&amp;=c(u,v)\end{aligned}\]</span></p><p>对于流量守恒性质，因为f和<span class="math inline">\(f^\prime\)</span>均遵守流量守恒性质，所以有<span class="math inline">\(f(u,v)=f(v,u)\)</span>和<span class="math inline">\(f^\prime(u,v)=f^\prime(v,u)\)</span>。因此，对于所有的结点<span class="math inline">\(u\in{V-\lbrace{s,t}\rbrace}\)</span>，有 <span class="math display">\[\begin{aligned}\sum_{v\in{V}}(f\uparrow{f^\prime})(u,v)&amp;=\sum_{v\in{V}}(f(u,v)+f^\prime(u,v)-f^\prime(v,u))\\&amp;=\sum_{v\in{V}}f(u,v)+\sum_{v\in{V}}f^\prime(u,v)-\sum_{v\in{V}}f^\prime(v,u)\\&amp;=\sum_{v\in{V}}f(v,u)+\sum_{v\in{V}}f^\prime(v,u)-\sum_{v\in{V}}f^\prime(u,v)\\&amp;=\sum_{v\in{V}}(f(v,u)+f^\prime(v,u)-f^\prime(u,v))\\&amp;=\sum_{v\in{V}}(f\uparrow{f^\prime})(v,u)\end{aligned}\]</span></p><p>最后，计算<span class="math inline">\(f\uparrow{f^\prime}\)</span>的值。将顶点集合分<span class="math inline">\(V_1\)</span>和<span class="math inline">\(V_2\)</span>两个集合。定义<span class="math inline">\(V_1=\lbrace{v:(s,v)\in{E}}\rbrace\)</span>为有边从源结点s到达的结点集合，<span class="math inline">\(V_2=\lbrace{v:(v,s)\in{E}}\rbrace\)</span>为有边通往s的结点集合，有<span class="math inline">\(V_1\bigcup{V_2}\subseteq{V}\)</span>。并且因为不允许有反平行边，又有<span class="math inline">\(V_1\bigcap{V_2}=\varnothing\)</span>。现在来计算 <span class="math display">\[\begin{aligned}|f\uparrow{f^\prime}|&amp;=\sum_{v\in{V}}(f\uparrow{f^\prime})(s,v)-\sum_{v\in{V}}(f\uparrow{f^\prime})(v,s)\\&amp;=\sum_{v\in{V_1\cup{V_2}}}(f\uparrow{f^\prime})(s,v)-\sum_{v\in{V_1\cup{V_2}}}(f\uparrow{f^\prime})(v,s)\\\end{aligned}\tag{26.5}\]</span> 回忆之间的内容，对于边<span class="math inline">\((u,v)\notin{E}\)</span>，定义f(u,v)=0，因此有<span class="math inline">\(f(s,v)=0\text{, if }{v\in{V_2}}\)</span>和<span class="math inline">\(f(v,s)=0\text{, if }{v\in{V_1}}\)</span>。现在将<span class="math inline">\(f\uparrow{f^\prime}\)</span>的定义应用到式(26.5)上，然后对和值项进行重新排序与重组可以获得： <span class="math display">\[\begin{aligned}|f\uparrow{f^\prime}|&amp;=\sum_{v\in{V_1}}(f\uparrow{f&#39;})(s,v)-\sum_{v\in{V_2}}(f\uparrow{f&#39;})(v,s)\\&amp;=\sum_{v\in{V_1}}(f(s,v)+f&#39;(s,v)-f&#39;(v,s))-\sum_{v\in{V_2}}(f(v,s)+f&#39;(v,s)-f&#39;(s,v))\\&amp;=\sum_{v\in{V_1}}f(s,v)-\sum_{v\in{V_2}}f(v,s)+\sum_{v\in{V_1}}f&#39;(s,v)+\sum_{v\in{V_2}}f&#39;(s,v)-\sum_{v\in{V_1}}f&#39;(v,s)-\sum_{v\in{V_2}}f&#39;(v,s)\\&amp;=\sum_{v\in{V_1}}f(s,v)-\sum_{v\in{V_2}}f(v,s)+\sum_{v\in{V_1\bigcup{V_2}}}f&#39;(s,v)-\sum_{v\in{V_1\bigcup{V_2}}}f&#39;(v,s)\\&amp;=\sum_{v\in{V}}f(s,v)-\sum_{v\in{V}}f(v,s)+\sum_{v\in{V}}f&#39;(s,v)-\sum_{v\in{V}}f&#39;(v,s)\\&amp;=|f|+|f&#39;|\end{aligned}\]</span></p><h2 id="增广路径">增广路径</h2><p>给定流网络G=(V,E)和流f，增广路径p是残存网络<span class="math inline">\(G_f\)</span>中一条从源结点到汇点t的简单路径。根据残存网络的定义，对于一条增广路径上的边(u,v)，可以增加其流量的幅度最大为<span class="math inline">\(c_f(u,v)\)</span>，而不会违反原始流网络G中对边(u,v)或(v,u)的容量限制。</p><p>上图(b)中阴影覆盖的路径是一条增广路径。如果将图中的残存网络<span class="math inline">\(G_f\)</span>看作一个流网络，那么可以对这条路径上每条边的流量增加4个单位，而不会违反容量限制，因为该条路径上最小的残存容量是<span class="math inline">\(c_f(v_2,v_3)=4\)</span>。称在一条增广路径p上能够为每条边增加的流量的最大值为路径p的<strong>残存容量</strong>，该容量由下面的表达式给出： <span class="math display">\[c_f(p)=min\lbrace{c_f(u,v):(u,v)\text{ 属于路径 }p}\rbrace\]</span></p><p>下面精确阐述残存网络中的流：</p><blockquote><p>引理26.2</p><p>设G=(V,E)为一个流网络，设f为G中的一个流，设p为残存网络<span class="math inline">\(G_f\)</span>中的一条增广路径。定义一个函数<span class="math inline">\(f_p:V\times{V}\rightarrow\mathbb{R}\)</span>如下： <span class="math display">\[f_p(u,v)=\begin{cases}c_f(p)&amp;\text{if }(u,v)\text{ is on }p\\0&amp;otherwise\end{cases}\tag{26.8}\]</span> 则<span class="math inline">\(f_p\)</span>是残存网络<span class="math inline">\(G_f\)</span>中的一个流，其值为<span class="math inline">\(|f_p|=c_f(p)&gt;0\)</span>。</p></blockquote><p>式(26.8)表示，残存网络中在增广路径p上的边的流量等于残存容量<span class="math inline">\(c_f(p)\)</span>，不在增广路径p上的边的流量为0。</p><p>下面的推论证明，如果将流f增加<span class="math inline">\(f_p\)</span>的量，则将获得G的另一个流，该流的值更加接近最大值。</p><blockquote><p>推论26.3</p><p>设G=(V,E)为一个流网络，设f为G中的一个流，设p为残存网络<span class="math inline">\(G_f\)</span>中的一条增广路径。设<span class="math inline">\(f_p\)</span>由式(26.8)所定义，假定将f增加<span class="math inline">\(f_p\)</span>的量，则函数<span class="math inline">\(f\uparrow{f_p}\)</span>是图G中的一个流，其值为<span class="math inline">\(|f\uparrow{f_p}|=|f|+|f_p|&gt;|f|\)</span>。</p></blockquote><p><strong>证明</strong>：根据引理26.1和引理26.2可得到上述结论。</p><h2 id="流网络的切割">流网络的切割</h2><p>Ford-Fulkerson方法的核心就是沿着增广路径重复增加路径上的流量，直到找到最大流为止。如何知道在算法中终止时，确实找到了一个最大流呢？最大流最小割定理告诉我们，一个流是最大流当且仅当其残存网络中不包含任何增广路径。为了证明这个定理，首先来探讨一下流网络中的切割概念。</p><p>流网络G=(V,E)中的一个切割(S,T)将结点集合V划分为S和T=V-S两个集合，使得<span class="math inline">\(s\in{S},t\in{T}\)</span>。若f是一个流，则定义横跨切割(S,T)的<strong>净流量</strong>f(S,T)如下： <span class="math display">\[f(S,T)=\sum_{u\in{S}}\sum_{v\in{T}}f(u,v)-\sum_{u\in{S}}\sum_{v\in{T}}f(v,u)\tag{26.9}\]</span> 切割(S,T)的<strong>容量</strong>是： <span class="math display">\[c(S,T)=\sum_{u\in{S}}\sum_{v\in{T}}c(u,v)\tag{26.10}\]</span> 一个网络的最小切割是整个网络中<strong>容量最小</strong>的切割。</p><p>流的定义和切割容量的定义之间存在着不对称性，这种不对称性是有意而为，并且很重要。</p><ul><li>对于容量，计算从集合S发出进入集合T的边的容量，而忽略反方向边上的容量。</li><li>对于流，考虑的则是从S到T的流量减去从T到S的反方向的流量。</li></ul><p>下图描述的是流网络的一个切割（<span class="math inline">\(\lbrace{s,v_1,v_2}\rbrace,\lbrace{v_3,v_4,t}\rbrace\)</span>）。横跨该切割的净流量是<span class="math inline">\(f(v_1,v_3)+f(v_2,v_4)-f(v_3,v_2)=12+11-4=19\)</span>。该切割的容量是<span class="math inline">\(c(v_1,v_3)+c(v_2,v_4)=12+14=26\)</span>。</p><p><img data-src="/uploads/posts/introduction-to-algorithms/s-t-cut-in-flow-network.png" title="流网络的一个ST切割"></p><blockquote><p>引理26.4</p><p>设f为流网络G的一个流，该流网络的源结点为s，汇点为t，设(S,T)为流网络G的任意切割，则横跨切割(S,T)的净流量为f(S,T)=|f|。</p></blockquote><p>直观上，从源结点s发往汇点t的流量必然经过切割的边界（图中虚线）,并且流满足流量守恒性质，表明所有从源结点s发出的流量最终都会流入汇点t。因此所有横跨边界的净流量等于流的值。</p><p>形式化地：对于任意结点<span class="math inline">\(u\in{V-\lbrace{s,t}\rbrace}\)</span>，重写（将右边的子式移到左边）流量守恒性质如下： <span class="math display">\[\begin{aligned}\sum_{v\in{V}}f(u,v)-\sum_{v\in{V}}f(v,u)=0\qquad{u\in{V-\lbrace{s,t}\rbrace}}\end{aligned}\tag{26.11}\]</span> 针对所有结点<span class="math inline">\(S-\lbrace{s}\rbrace\)</span>求和： <span class="math display">\[\sum_{u\in{S-\{s\}}}(\sum_{v\in{V}}f(u,v)-\sum_{v\in{V}}f(v,u))=0\]</span> 根据式(26.1)对|f|的定义，将上式的左项加进来： <span class="math display">\[\begin{aligned}|f|&amp;=\sum_{v\in{V}}f(s,v)-\sum_{v\in{V}}f(v,s)+\sum_{u\in{S-\{s\}}}(\sum_{v\in{V}}f(u,v)-\sum_{v\in{V}}f(v,u))\\&amp;=\sum_{v\in{V}}f(s,v)-\sum_{v\in{V}}f(v,s)+\sum_{u\in{S-\{s\}}}\sum_{v\in{V}}f(u,v)-\sum_{u\in{S-\{s\}}}\sum_{v\in{V}}f(v,u)\\&amp;=\sum_{v\in{V}}(f(s,v)+\sum_{u\in{S-\{s\}}}f(u,v))-\sum_{v\in{V}}(f(v,s)+\sum_{u\in{S-\{s\}}}f(v,s))\\&amp;=\sum_{v\in{V}}\sum_{u\in{S}}f(u,v)-\sum_{v\in{V}}\sum_{u\in{S}}f(v,u)\end{aligned}\]</span></p><p>因为<span class="math inline">\(V=S\bigcup{T},S\bigcap{T}=\varnothing\)</span>，将上述表达式中针对集合V的求和分解为针对S和T的求和，得到： <span class="math display">\[\begin{aligned}|f|&amp;=\sum_{v\in{S}}\sum_{u\in{S}}f(u,v)+\sum_{v\in{T}}\sum_{u\in{S}}f(u,v)-\sum_{v\in{S}}\sum_{u\in{S}}f(v,u)-\sum_{v\in{T}}\sum_{u\in{S}}f(v,u)\\&amp;=\sum_{v\in{T}}\sum_{u\in{S}}f(u,v)-\sum_{v\in{T}}\sum_{u\in{S}}f(v,u)+\color{red}{\Bigl(\sum_{v\in{S}}\sum_{u\in{S}}f(u,v)-\sum_{v\in{S}}\sum_{u\in{S}}f(v,u)\Bigr)}\end{aligned}\]</span> 上式表达式括号里面的两个求和项实际上是一样的。因此，这些求和项相互抵消，得到： <span class="math display">\[|f|=\sum_{v\in{T}}\sum_{u\in{S}}f(u,v)-\sum_{v\in{T}}\sum_{u\in{S}}f(v,u)=f(S,T)\]</span></p><blockquote><p>推论26.5</p><p>流网络G中任意流f的值不能超过G的任意切割容量。</p></blockquote><p><strong>证明</strong>：设(S,T)为流网络G的任意切割，设f为G中的任意流。根据引理26.4和容量限制性质，有 <span class="math display">\[\begin{aligned}|f|=f(S,T)&amp;=\sum_{u\in{S}}\sum_{v\in{T}}f(u,v)-\sum_{u\in{S}}\sum_{v\in{T}}f(v,u)\\&amp;\le\sum_{u\in{}S}\sum_{v\in{T}}f(u,v)\le\sum_{u\in{}S}\sum_{v\in{T}}c(u,v)=c(S,T)\end{aligned}\]</span></p><h2 id="最大流最小割定理">最大流最小割定理</h2><blockquote><p>定理26.6 （最大流最小割定理）</p><p>设f为流网络G=(V,E)中的一个流，该流网络的源结点为s，汇点为t，则下面的条件是等价的：</p><ol type="1"><li>f是G的一个最大流。</li><li>残存网络<span class="math inline">\(G_f\)</span>不包含任何增广路径。</li><li>|f|=c(S,T)，其中(S,T)是流网络的某个切割。</li></ol></blockquote><p><strong>证明</strong>：</p><ul><li><p><span class="math inline">\((1)\Rightarrow(2)\)</span>：使用反证法。假定f是G的一个最大流，但残存网络<span class="math inline">\(G_f\)</span>同时包含一条增广路径p。那么根据推论26.3，对f增加流量<span class="math inline">\(f_p\)</span>所形成的流是G中的一个值严格大于|f|的流，这与f是最大流的假设矛盾。</p></li><li><p><span class="math inline">\((2)\Rightarrow(3)\)</span>：假设<span class="math inline">\(G_f\)</span>不包含任何增广路径，也就是说，在残存网络<span class="math inline">\(G_f\)</span>中不存在任何从源结点s到汇点t的路径。定义<span class="math inline">\(S=\lbrace{v\in{V}:\text{在 }G_f\text{中存在从 }s\text{到}v\text{的路径}}\rbrace,T=V-S\)</span>。显然，<span class="math inline">\(s\in{S}\)</span>，而因为<span class="math inline">\(G_f\)</span>中不存在从s到t的路径（增广路径），所以<span class="math inline">\(t\notin{S}\)</span>。因此，划分(S,T)是流网络G的一个切割。下面证明|f|=c(S,T)。</p><p>考虑一对结点<span class="math inline">\(u\in{S}\)</span>和<span class="math inline">\(v\in{T}\)</span>。</p><ul><li>如果<span class="math inline">\((u,v)\in{E}\)</span>，则必有f(u,v)=c(u,v)，否则边(u,v)将属于<span class="math inline">\(E_f\)</span>，在残存网络中存在一条路径<span class="math inline">\(s\rightsquigarrow{u}\rightarrow{v}\)</span>到达结点v，即<span class="math inline">\(v\in{S}\)</span>，这与结点<span class="math inline">\(v\in{T}\)</span>矛盾。</li><li>如果<span class="math inline">\((v,u)\in{E}\)</span>，则必有f(v,u)=0，否则边(u,v)将属于<span class="math inline">\(E_f\)</span>，得出<span class="math inline">\(v\in{S}\)</span>，与<span class="math inline">\(v\in{T}\)</span>矛盾。</li><li>如果边(u,v)和(v,u)都不在集合E中，则f(u,v)=f(v,u)=0。</li></ul></li></ul><p>因此有 <span class="math display">\[\begin{aligned}f(S,T)&amp;=\sum_{u\in{S}}\sum_{v\in{T}}f(u,v)-\sum_{u\in{S}}\sum_{v\in{T}}f(v,u)\\&amp;=\sum_{u\in{S}}\sum_{v\in{T}}f(u,v)-\sum_{u\in{S}}\sum_{v\in{T}}0\\&amp;=c(S,T)\end{aligned}\]</span></p><ul><li><span class="math inline">\((3)\Rightarrow(1)\)</span>：根据推论26.5，对于所有切割(S,T)，<span class="math inline">\(|f|\le{c(S,T)}\)</span>。因此，条件|f|=c(S,T)隐含着|f|是一个最大流。</li></ul><h1 id="基本的ford-fulkerson算法">基本的Ford-Fulkerson算法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FORD-FULKERSON(G, s, t):</span><br><span class="line">    <span class="keyword">for</span> each edge (u,v) <span class="keyword">in</span> G.E:  <span class="comment"># 将流f初始化为0</span></span><br><span class="line">        (u,v).f = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> there exists a path p <span class="keyword">from</span> s to t <span class="keyword">in</span> the residual network:  <span class="comment"># 寻找增广路径</span></span><br><span class="line">        c_f(p) = min&#123;c_f(u,v):(u,v) <span class="keyword">is</span> <span class="keyword">in</span> p&#125;   <span class="comment"># 残存容量</span></span><br><span class="line">        <span class="keyword">for</span> each edge (u,v) <span class="keyword">in</span> p:              <span class="comment"># 修改原始流网络中的流</span></span><br><span class="line">            <span class="keyword">if</span> (u,v) <span class="keyword">in</span> E:</span><br><span class="line">                (u,v).f = (u,v).f + c_f(p)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                (v,u).f = (v,u).f - c_f(p)</span><br></pre></td></tr></table></figure><p>FORD-FULKERSON算法仅是对FORD-FULKERSON-METHOD过程的简单扩展。下图描述的是一个样本运行过程的每次迭代的结果。</p><p><img data-src="/uploads/posts/introduction-to-algorithms/ford-fulkerson-example.png" title="Ford-Fulkerson示例"></p><h2 id="分析">分析</h2><p>假定所选择的任意增广路径和所有的容量都是整数（如果容量为有理数，则可以通过乘以某个系数来将其转换为整数；如果容量为无理数，则Ford-Fulkerson方法可能不会终止）。</p><ul><li>初始化：对每条边赋初始值0，成本是O(E)。</li><li>寻找增广路径：如果用来实现流网络G=(V,E)的数据结构是合理的，使用深度优先搜索或广度优先搜索在一个残存网络中找到一条路径的时间应是O(V+E)=O(E)。</li><li>while循环：执行一遍的时间为O(E)。如果<span class="math inline">\(f^\star\)</span>表示网络中的一个最大流，则在FORD-FULKERSON算法中，while循环的次数最多为<span class="math inline">\(|f^\star|\)</span>次，因为流量值在每次迭代中最少增加一个单位。</li></ul><p>从而整个FORD-FULKERSON算法的运行时间为<span class="math inline">\(O(E|f^\star|)\)</span>。</p><p>当容量都是整数值且最优的流量值<span class="math inline">\(|f^\star|\)</span>较小时，FORD-FULKERSON算法的运行时间相当不错。下图描述的是当<span class="math inline">\(|f^\star|\)</span>的取值较大时可能发生的情况。该网络的一个最大流取值为2 000 000，1 000 000单位的流量流经路径<span class="math inline">\(s\rightarrow{u}\rightarrow{t}\)</span>，另外1 000 000单位的流量流经路径<span class="math inline">\(s\rightarrow{v}\rightarrow{t}\)</span>。</p><p>如果FORD-FULKERSON算法找到的第一条增广路径为<span class="math inline">\(s\rightarrow{u}\rightarrow{v}\rightarrow{t}\)</span>，如图(a)所示，则在第一次迭代后，流的值为1。产生的残存网络如图(b)所示，找到的第二条增广路径为<span class="math inline">\(s\rightarrow{v}\rightarrow{u}\rightarrow{t}\)</span>，然后流的值将为2。图(c)描述的是结果残存网络。</p><p>如此继续下去，在每个奇数次迭代中，选择增广路径<span class="math inline">\(s\rightarrow{u}\rightarrow{v}\rightarrow{t}\)</span>，在每个偶数次迭代中，选择增广路径<span class="math inline">\(s\rightarrow{v}\rightarrow{u}\rightarrow{t}\)</span>，这样将一共执行2 000 000次递增操作，每次将流量增加1个单位。</p><p><img data-src="/uploads/posts/introduction-to-algorithms/ford-fulkerson-analysis.png" title="循环次数很大的一个示例问题"></p><h1 id="edmonds-karp算法">Edmonds-Karp算法</h1><p>使用广度优先搜索寻找增广路径可以改善FORD-FULKERSON算法的效率。广度优先搜索得到的增广路径是一条从源结点s到汇点t的<strong>最短</strong>（边数最少）路径。称如此实现的Ford-Fulkerson方法为Edmonds-Karp算法。该算法的运行时间为<span class="math inline">\(O(VE^2)\)</span>，只与流网络的规模有关，与最优的流量值无关。</p><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_f</span><span class="params">(graph)</span>:</span></span><br><span class="line">    print(<span class="string">'max flow:'</span>, graph.graph[<span class="string">'max_flow'</span>])</span><br><span class="line">    fmt = <span class="string">'&#123;0:&lt;4s&#125; &#123;1:&lt;4s&#125; &#123;2:&lt;4s&#125; &#123;3:&lt;8s&#125;\n'</span></span><br><span class="line">    title = fmt.format(<span class="string">'u'</span>, <span class="string">'v'</span>, <span class="string">'flow'</span>, <span class="string">'capacity'</span>)</span><br><span class="line">    data = <span class="string">''</span>.join(</span><br><span class="line">        fmt.format(str(u), str(v), str(attr[<span class="string">'flow'</span>]), str(attr[<span class="string">'capacity'</span>])) <span class="keyword">for</span> u, v, attr <span class="keyword">in</span> graph.edges(data=<span class="literal">True</span>) <span class="keyword">if</span></span><br><span class="line">        attr[<span class="string">'flow'</span>] &gt; <span class="number">0</span>)</span><br><span class="line">    print(title + data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_path_dfs</span><span class="params">(graph, s, t, p)</span>:</span></span><br><span class="line">    <span class="string">"""寻找增广路径，深度优先搜索（递归实现）"""</span></span><br><span class="line">    <span class="keyword">if</span> s == t:</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> graph.get_e(s):</span><br><span class="line">        residuals = e.c - e.f</span><br><span class="line">        <span class="keyword">if</span> residuals &gt; <span class="number">0</span> <span class="keyword">and</span> e <span class="keyword">not</span> <span class="keyword">in</span> p:</span><br><span class="line">            p.add(e)  <span class="comment"># 将当前邻接边加入path，向sink寻路</span></span><br><span class="line">            result = find_path_dfs(graph, e.v, t, p)</span><br><span class="line">            <span class="keyword">if</span> result <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">            p.remove(e)  <span class="comment"># 若没找到通向sink的路，从path中移除当前边，循环下一条邻接边</span></span><br><span class="line">    <span class="comment"># 未找到路径，将返回默认值None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_path_bfs</span><span class="params">(graph, s, t, p)</span>:</span></span><br><span class="line">    <span class="string">"""Ford-Fulkerson Method的一种特殊实现：Edmonds-Karp algorithm</span></span><br><span class="line"><span class="string">    使用广度优先搜索寻找增广路径，寻找一条边数最少的增广路径"""</span></span><br><span class="line">    previous, visit, q = &#123;s: <span class="literal">None</span>&#125;, set(), Queue()</span><br><span class="line">    q.put(s)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">        u = q.get()</span><br><span class="line">        visit.add(u)  <span class="comment"># visit用来记录结点是否曾被访问过</span></span><br><span class="line">        <span class="keyword">if</span> u == t:  <span class="comment"># 输出路径</span></span><br><span class="line">            pre = previous[t]</span><br><span class="line">            <span class="keyword">while</span> pre <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                p.add((pre, u))  <span class="comment"># path的顺序无影响</span></span><br><span class="line">                u = pre</span><br><span class="line">                pre = previous[pre]</span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line">        <span class="keyword">for</span> v, attr <span class="keyword">in</span> graph[u].items():</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> visit:</span><br><span class="line">                residual = attr[<span class="string">'capacity'</span>] - attr[<span class="string">'flow'</span>]  <span class="comment"># 判断残存容量</span></span><br><span class="line">                <span class="keyword">if</span> residual &gt; <span class="number">0</span>:</span><br><span class="line">                    q.put(v)</span><br><span class="line">                    previous[v] = u  <span class="comment"># previous记录前驱结点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_path</span><span class="params">(graph, s, t, path)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> find_path_bfs(graph, s, t, path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_flow</span><span class="params">(graph, s, t)</span>:</span></span><br><span class="line">    <span class="string">"""求最大流"""</span></span><br><span class="line">    p = find_path(graph, s, t, set())</span><br><span class="line">    <span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        augment_flow = min(graph[u][v][<span class="string">'capacity'</span>] - graph[u][v][<span class="string">'flow'</span>] <span class="keyword">for</span> u, v <span class="keyword">in</span> p)</span><br><span class="line">        <span class="keyword">for</span> u, v <span class="keyword">in</span> p:</span><br><span class="line">            graph[u][v][<span class="string">'flow'</span>] += augment_flow</span><br><span class="line">            graph[v][u][<span class="string">'flow'</span>] -= augment_flow</span><br><span class="line">        p = find_path(graph, s, t, set())</span><br><span class="line">    graph.graph[<span class="string">'max_flow'</span>] = sum(attr[<span class="string">'flow'</span>] <span class="keyword">for</span> attr <span class="keyword">in</span> graph[s].values())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_graph</span><span class="params">(graph, vertices, edges)</span>:</span></span><br><span class="line">    graph.add_nodes_from(vertices)</span><br><span class="line">    <span class="keyword">for</span> u, v, c <span class="keyword">in</span> edges:</span><br><span class="line">        graph.add_edges_from([(u, v, &#123;<span class="string">'capacity'</span>: c&#125;), (v, u, &#123;<span class="string">'capacity'</span>: <span class="number">0</span>&#125;)], flow=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    g = nx.DiGraph()</span><br><span class="line">    v = <span class="string">'s1234t'</span></span><br><span class="line">    e = [(<span class="string">'s'</span>, <span class="string">'1'</span>, <span class="number">6</span>), (<span class="string">'s'</span>, <span class="string">'3'</span>, <span class="number">5</span>), (<span class="string">'s'</span>, <span class="string">'4'</span>, <span class="number">1</span>), (<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="number">5</span>), (<span class="string">'1'</span>, <span class="string">'4'</span>, <span class="number">2</span>), (<span class="string">'1'</span>, <span class="string">'t'</span>, <span class="number">3</span>),</span><br><span class="line">         (<span class="string">'2'</span>, <span class="string">'t'</span>, <span class="number">5</span>), (<span class="string">'3'</span>, <span class="string">'1'</span>, <span class="number">2</span>), (<span class="string">'3'</span>, <span class="string">'4'</span>, <span class="number">4</span>), (<span class="string">'4'</span>, <span class="string">'2'</span>, <span class="number">3</span>), (<span class="string">'4'</span>, <span class="string">'t'</span>, <span class="number">3</span>)]</span><br><span class="line">    initialize_graph(g, v, e)</span><br><span class="line">    max_flow(g, <span class="string">'s'</span>, <span class="string">'t'</span>)</span><br><span class="line">    print_f(g)</span><br><span class="line"></span><br><span class="line">    g.clear()</span><br><span class="line">    e = [(<span class="string">'s'</span>, <span class="string">'1'</span>, <span class="number">16</span>), (<span class="string">'s'</span>, <span class="string">'2'</span>, <span class="number">13</span>), (<span class="string">'1'</span>, <span class="string">'3'</span>, <span class="number">12</span>), (<span class="string">'2'</span>, <span class="string">'1'</span>, <span class="number">4</span>), (<span class="string">'2'</span>, <span class="string">'4'</span>, <span class="number">14</span>), (<span class="string">'3'</span>, <span class="string">'2'</span>, <span class="number">9</span>),</span><br><span class="line">         (<span class="string">'3'</span>, <span class="string">'t'</span>, <span class="number">20</span>), (<span class="string">'4'</span>, <span class="string">'3'</span>, <span class="number">7</span>), (<span class="string">'4'</span>, <span class="string">'t'</span>, <span class="number">4</span>)]</span><br><span class="line">    initialize_graph(g, v, e)</span><br><span class="line">    max_flow(g, <span class="string">'s'</span>, <span class="string">'t'</span>)</span><br><span class="line">    print_f(g)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">max flow: 11</span><br><span class="line">u    v    flow capacity</span><br><span class="line">s    1    6    6</span><br><span class="line">s    3    5    5</span><br><span class="line">1    2    2    5</span><br><span class="line">1    4    2    2</span><br><span class="line">1    t    3    3</span><br><span class="line">2    t    5    5</span><br><span class="line">3    1    1    2</span><br><span class="line">3    4    4    4</span><br><span class="line">4    2    3    3</span><br><span class="line">4    t    3    3</span><br><span class="line"></span><br><span class="line">max flow: 23</span><br><span class="line">u    v    flow capacity</span><br><span class="line">s    1    12   16</span><br><span class="line">s    2    11   13</span><br><span class="line">1    3    12   12</span><br><span class="line">2    4    11   14</span><br><span class="line">3    t    19   20</span><br><span class="line">4    3    7    7</span><br><span class="line">4    t    4    4</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction To Algorithms </tag>
            
            <tag> algorithms </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Python中使用CPLEX</title>
      <link href="/operations-research/cplex-in-python/"/>
      <url>/operations-research/cplex-in-python/</url>
      
        <content type="html"><![CDATA[<h1 id="设置api">设置API</h1><p>从搭建运行环境开始。使用的软件如下：</p><ul><li>ILOG CPLEX Optimization studio 12.9.0 64bit。</li><li>Python3.6.8 64bit。</li></ul><p>安装好ILOG CPLEX Optimization studio后，<a href="https://www.ibm.com/support/knowledgecenter/zh/SSSA5P_12.9.0/ilog.odms.cplex.help/CPLEX/GettingStarted/topics/set_up/Python_setup.html" target="_blank" rel="noopener">设置 CPLEX 的 Python API</a>。</p><h2 id="使用脚本-setup.py">使用脚本 setup.py</h2><p>要在系统上安装 CPLEX-Python 模块，请使用位于 yourCplexhome/python/VERSION/PLATFORM 中的脚本 setup.py。 如果要将 CPLEX-Python 模块安装在非缺省位置，请使用选项 --home 识别安装目录。 例如，要将 CPLEX-Python 模块安装在缺省位置，请从命令行使用以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><p>要安装在目录 yourPythonPackageshome/cplex 中，请从命令行使用以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py install --home yourPythonPackageshome/cplex</span><br></pre></td></tr></table></figure><p>这两个命令（缺省和指定主目录）均会调用 Python 包 distutils。 有关适用于该软件包的其他选项，请参考 Python distutils 的文档。</p><p>设置完成后，若能在Python解释器中导入cplex库（<code>import cplex</code>）说明配置成功。</p><a id="more"></a><p><strong>附</strong>：</p><ol type="1"><li>CPLEX API和Python位数需一致。</li><li>CPLEX Optimization studio 12.9版本不支持32bit。</li><li>如果都安装64bit版本，Python不要选择v3.7，某些库尚不支持Python3.7 64bit。</li></ol><h1 id="hello-cplex">Hello CPLEX</h1><p>cplex中重要的一个类就是Cplex类，它提供了创建、修改、查询最优化问题的一系列方法。Cplex 的官方文档：<a href="https://www.ibm.com/support/knowledgecenter/zh/SSSA5P_12.9.0/ilog.odms.cplex.help/refpythoncplex/html/cplex.Cplex-class.html" target="_blank" rel="noopener">Class Cplex</a>。使用cplex优化一个LP模型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Maximize</span><br><span class="line">3x1 + 5x2</span><br><span class="line">Subject to</span><br><span class="line"> x1 + 7x2 &lt;= 140</span><br><span class="line"> x1 + 2x2 &lt;= 50</span><br><span class="line">3x1 + 2x2 &lt;= 130</span><br><span class="line">Bounds</span><br><span class="line">0 &lt;= x1 &lt;= infinity</span><br><span class="line">0 &lt;= x2 &lt;= infinity</span><br><span class="line">End</span><br></pre></td></tr></table></figure><p>将上述内容保存至文件hello.lp，之后可以直接读取该文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cplex</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    c = cplex.Cplex()</span><br><span class="line">    c.read(<span class="string">'hello.lp'</span>)</span><br><span class="line">    c.solve()</span><br><span class="line">    print(c.solution.get_objective_value(), c.solution.get_values())</span><br></pre></td></tr></table></figure><p>或者直接构建相同的模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cplex</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    c = cplex.Cplex()</span><br><span class="line">    <span class="comment"># 设置优化目标为最大化，默认是minimize</span></span><br><span class="line">    c.objective.set_sense(c.objective.sense.maximize)</span><br><span class="line">    <span class="comment"># obj: 目标函数</span></span><br><span class="line">    <span class="comment"># names: 变量名</span></span><br><span class="line">    <span class="comment"># lb: lower bound</span></span><br><span class="line">    <span class="comment"># ub: upper bound</span></span><br><span class="line">    c.variables.add(</span><br><span class="line">        obj=[<span class="number">3</span>, <span class="number">5</span>], names=[<span class="string">'x1'</span>, <span class="string">'x2'</span>],</span><br><span class="line">        lb=[<span class="number">0.0</span>, <span class="number">0.0</span>], ub=[cplex.infinity] * <span class="number">2</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># lin_expr: 线性表达式，约束条件左边</span></span><br><span class="line">    <span class="comment"># senses: 约束条件的比较符号，G|L|E|R，分别表示大于等于|小于等于|等于|区间约束</span></span><br><span class="line">    <span class="comment"># rhs: right hand side，约束条件右边的值</span></span><br><span class="line">    c.linear_constraints.add(</span><br><span class="line">        lin_expr=[([<span class="string">'x1'</span>, <span class="string">'x2'</span>], [<span class="number">1</span>, <span class="number">7</span>]),</span><br><span class="line">                  ([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>]),</span><br><span class="line">                  ([<span class="string">'x1'</span>, <span class="string">'x2'</span>], [<span class="number">3</span>, <span class="number">2</span>])],</span><br><span class="line">        senses=<span class="string">'L'</span> * <span class="number">3</span>,</span><br><span class="line">        rhs=[<span class="number">140.0</span>, <span class="number">50.0</span>, <span class="number">130.0</span>]</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 求解问题，解决方案保存在c.solution变量</span></span><br><span class="line">    c.solve()</span><br><span class="line">    <span class="comment"># 打印最优值和所有变量的值</span></span><br><span class="line">    print(c.solution.get_objective_value(), c.solution.get_values())</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CPXPARAM_Read_DataCheck                          1</span><br><span class="line">Tried aggregator 1 time.</span><br><span class="line">No LP presolve or aggregator reductions.</span><br><span class="line">Presolve time = 0.00 sec. (0.00 ticks)</span><br><span class="line"></span><br><span class="line">Iteration log . . .</span><br><span class="line">Iteration:     1   Dual infeasibility =             0.000000</span><br><span class="line">Iteration:     2   Dual objective     =           175.789474</span><br><span class="line">145.0 [40.0, 5.0]  # 最优值和此时变量的值，上面是log内容</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 运筹学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linear programming </tag>
            
            <tag> cplex </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单源最短路径</title>
      <link href="/notes/introduction-to-algorithms/single-source-shortest-paths/"/>
      <url>/notes/introduction-to-algorithms/single-source-shortest-paths/</url>
      
        <content type="html"><![CDATA[<h1 id="简介">简介</h1><p>最短路径问题（Shortest path problem, SPP）旨在寻找图中两个结点之间的最短路径。本文介绍单源最短路径问题：给定一个图G=(V,E)，我们希望找到从给定源节点s到每个结点<span class="math inline">\(v\in{V}\)</span>的最短路径。广度优先搜索就是权重均为1的单源最短路径问题，根节点（源点）到每个结点的最短距离等于最短路径上的边的条数。单源最短路径问题可以用来解决许多其他问题，其中就包括它的几个变体：</p><ul><li>单目的地最短路径问题：找到从给定结点v到给定目的地结点t的最短路径。如果将图的每条边的方向翻转过来，就可以将这个问题转换为单源最短路径问题。</li><li>单节点对最短路径问题：找到从给定结点u到给定节点v的最短距离。如果解决了针对单个结点u的单源最短路径问题，那么也就解决了这个问题。而且，在该问题的所有已知算法中，最坏情况下的渐进运行时间都和最好的单源最短路径算法的运行时间一样。</li><li>所有结点对最短距离：对于每对结点u和v，找到从结点u到结点v的最短路径。可以针对每个结点运行一遍单源最短路径算法，但可以更快地解决这个问题。此类问题适合使用Floyd-Warshall算法。</li></ul><a id="more"></a><h1 id="最短路径的最优子结构">最短路径的最优子结构</h1><blockquote><p>引理24.1 （最短路径的子路径也是最短路径）</p><p>给定带权重的有向图G=(V,E)和权重函数<span class="math inline">\(w:E\rightarrow{R}\)</span>。设<span class="math inline">\(p=\langle{v_0,v_1,\dots,v_k\rangle}\)</span>为从结点<span class="math inline">\(v_0\)</span>到结点<span class="math inline">\(v_k\)</span>的一条最短路径，并且对于任意的<span class="math inline">\(i\)</span>和<span class="math inline">\(j，0\le{I}\le{j}\le{k}\)</span>，设<span class="math inline">\(p_{ij}=\langle{v_i,v_{i+1},\dots,v_j}\rangle\)</span>为路径p中从结点<span class="math inline">\(v_i\)</span>到结点<span class="math inline">\(v_j\)</span>的子路径。那么<span class="math inline">\(p_{ij}\)</span>是从结点<span class="math inline">\(v_i\)</span>到结点<span class="math inline">\(v_j\)</span>的一条最短路径。</p></blockquote><p><strong>证明</strong>：假设p是从<span class="math inline">\(v_0\)</span>到<span class="math inline">\(v_k\)</span>的一条最短路径。将路径p分解为 <span class="math display">\[v_0\mathop{\rightsquigarrow}^{p_{0i}}v_i\mathop{\rightsquigarrow}^{p_{ij}}v_j\mathop{\rightsquigarrow}^{p_{jk}}v_k\]</span> 则有<span class="math inline">\(w(p)=w(p_{0i})+w(p_{ij})+w(p_{jk})\)</span>。</p><p>假设存在一条从<span class="math inline">\(v_i\)</span>到<span class="math inline">\(v_j\)</span>的路径<span class="math inline">\(p^\prime_{ij}\)</span>，且<span class="math inline">\(w(p^\prime_{ij})&lt;w(p_{ij})\)</span>。</p><p>则</p><p><span class="math display">\[v_0\mathop{\rightsquigarrow}^{p_{0i}}v_i\mathop{\rightsquigarrow}^{\color{red}{p^\prime_{ij}}}v_j\mathop{\rightsquigarrow}^{p_{jk}}v_k\]</span> 是一条从结点<span class="math inline">\(v_0\)</span>到结点<span class="math inline">\(v_k\)</span>的权重为<span class="math inline">\(w(p^\prime)=w(p_{0i})+w(p^\prime_{ij})+w(p_{jk})\)</span>的路径，而该权重小于w(p)。</p><p>这与p是从<span class="math inline">\(v_0\)</span>到<span class="math inline">\(v_k\)</span>的一条最短路径这一假设矛盾。</p><h1 id="环路">环路</h1><p>不失一般性，我们可以假定找到的最短路径中没有环路，即它们都是简单路径。</p><ul><li><p>若一条路径包含权重为正值的环路，那么将环路从路径上删除就可以得到一条源点和终点相同的权重更小的路径。</p></li><li><p>若包含权重为负值的环路，那么只要沿着环路再遍历一遍，就能找到一条权重更小的路径。如果从结点s到结点v的某条路径上存在权重为负值的环路，我们定义结点s到结点v的最短路径<span class="math inline">\(\delta(s,v)=-\infty\)</span>。例如下图中，存在<span class="math inline">\(\langle{e,f,e}\rangle\)</span>这条权重为-3的环路，因此所有经过这条环路可达的结点e,f,g的最短路径权重为<span class="math inline">\(-\infty\)</span>。</p><p><img data-src="/uploads/posts/introduction-to-algorithms/negative-edge-weights-in-a-directed-graph.png" title="包含权重为负值的环路的有向图"></p></li><li><p>若包含权重为0的环路，那么删除该环路后得到的路径权重与原来的相等。只要一条最短路径上还有权重为0的环路，我们就可以重复删除这些环路，直到得到一条不包含环路的简单路径。</p></li></ul><p>由于图G=(V,E)中的任意无环路径最多包含|V|个不同的结点，到任意结点的最短路径最多包含|V|-1条边。</p><h1 id="最短路径的表示">最短路径的表示</h1><p>通常情况下，我们不但希望计算出最短路径权重，还希望计算出最短路径上的结点。</p><p>给定图G=(V,E)，对于每个结点v，维持一个<strong>前驱结点</strong><span class="math inline">\(v.\pi\)</span>。该前驱结点可能是另一个结点或者NIL。将从结点v开始的前驱结点链反转过来，就是从s到v的一条最短路径。</p><p>我们感兴趣的是由<span class="math inline">\(\pi\)</span>值所诱导的<strong>前驱子图</strong><span class="math inline">\(G_\pi=(V_\pi,E_\pi)\)</span>。定义结点集<span class="math inline">\(V_\pi\)</span>为图G中的前驱结点不为NIL的结点的集合，再加上源节点s，即<span class="math inline">\(V_\pi=\{v\in{V}:v.\pi\neq{NIL}\}\cup\{s\}\)</span>。有向边集合<span class="math inline">\(E_\pi\)</span>是由<span class="math inline">\(V_\pi\)</span>中的结点的<span class="math inline">\(\pi\)</span>值所诱导的边的集合，即<span class="math inline">\(E_\pi=\{(v.\pi,v)\in{E}:v\in{V_\pi-\{s\}}\}\)</span>。</p><p>一个正确的单源最短路径算法：在算法终止时，<span class="math inline">\(G_\pi\)</span>是一棵“最短路径树“。最短路径树是一棵有根节点的树，该树包括了从源节点s到每个可以从s到达的结点的一条最短路径。类似于广度优先搜索中的广度优先树，但它所包括的最短路径是以边的权重来定义的，而不是边的条数。</p><p>需要指出的是，最短路径不一定是唯一的，最短路径树也不一定是唯一的。如下图(a)所示的带权重的有向图中，有(b)和(c)两种最短路径，即存在两棵根节点为s的最短路径树。</p><p><img data-src="/uploads/posts/introduction-to-algorithms/two-shortest-paths-trees-with-the-same-root.png" title="根结点相同的两棵不同的最短路径树"></p><h1 id="松弛操作">松弛操作</h1><p>本文的算法需要使用松弛（relaxation）技术。对于每个结点v来说，维持一个属性v.d，用来记录从源节点s到结点v的最短路径权重的上界。称之为s到v的<strong>最短路径估计</strong>。使用下面运行时间为<span class="math inline">\(\Theta(V)\)</span>的算法来对最短路径估计和前驱结点进行初始化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INITIALIZE-SINGLE-SOURCE(G, s):</span><br><span class="line">    <span class="keyword">for</span> each vertex v <span class="keyword">in</span> G.V:</span><br><span class="line">        v.d = infinity</span><br><span class="line">        v.pi = NIL</span><br><span class="line">    s.d = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>下面的伪代码给出了对边(u,v)在O(1)时间内进行的松弛操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RELAX(u, v, w)：</span><br><span class="line">    <span class="keyword">if</span> v.d &gt; u.d + w(u, v):</span><br><span class="line">        v.d = u.d + w(u, v)</span><br><span class="line">        v.pi = u</span><br></pre></td></tr></table></figure><p>对一条边的松弛过程为：</p><p>首先测试一下是否可以对从s到v的最短距离进行改善。测试方法是，将从结点s到结点u之间的最短路径距离u.d加上结点u与v之间的边权重w(u, v)，并与当前的s到v的最短路径估计v.d进行比较。如果前者更小，则对v.d和v.pi进行更新。如下图：</p><ol type="a"><li><p>v.d=9; u.d=5; w(u,v)=2，9&gt;5+2，因此v的最短路径估计v.d降低，同时v的前驱结点也要更新为u。称这种情况为松弛成功。</p></li><li><p>6&lt;5+2，因此v.d和v.pi属性都不会变化。称这种情况为松弛失败。</p></li></ol><p><img data-src="/uploads/posts/introduction-to-algorithms/single-source-shortest-path-relax.png" title="松弛成功和松弛失败"></p><h1 id="bellman-ford算法">Bellman-Ford算法</h1><p>Bellman-Ford算法解决的是一般情况下的单源最短路径问题。边的权重可以为负值。算法返回一个布尔值，以表明是否存在一个从源节点可以到达的权重为负值的环路。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BELLMAN-FORD(G, w, s):</span><br><span class="line">    INITIALIZE-SINGLE-SOURCE(G, s)</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to |G.V| - <span class="number">1</span>:        <span class="comment"># 算法对每条边进行|V|-1次处理</span></span><br><span class="line">        <span class="keyword">for</span> each edge(u, v) <span class="keyword">in</span> G.E:</span><br><span class="line">            RELAX(u, v, w)</span><br><span class="line">    <span class="keyword">for</span> each edge(u, v) <span class="keyword">in</span> G.E:    <span class="comment"># 检查是否存在权重为负值的环路</span></span><br><span class="line">        <span class="keyword">if</span> v.d &gt; u.d + w(u, v):</span><br><span class="line">            <span class="keyword">return</span> false           <span class="comment"># 若存在，返回false</span></span><br><span class="line">    <span class="keyword">return</span> true</span><br></pre></td></tr></table></figure><p><img data-src="/uploads/posts/introduction-to-algorithms/execution-of-bellman-ford.png" title="Bellman Ford每次迭代后的结果"></p><p>例如在图(a)所示的带权重的有向图中，按(t,x), (t,y), (t,z), (x,t), (y,x), (y,z), (z,x), (z,s), (s,t), (s,y)的顺序对边执行松弛操作的过程。有向图中有6个顶点，因此需要循环5次。单次循环后的结果分为如图(b)~(e)所示。只有v.d值降低的结点成功松弛。</p><p>边的顺序不会对最终结果产生影响，但若斟酌选择，可以减少松弛失败的次数，从而提高代码的执行效率。在后续的优化中将会提到一种选择方案。</p><h2 id="分析">分析</h2><p>INITIALIZE-SINGLE-SOURCE所需时间为<span class="math inline">\(\Theta(V)\)</span>，内层循环对每条边都执行一次RELAX操作，因此运行时间为<span class="math inline">\(\Theta(E)\)</span>，且一共要进行|V|-1次循环，检测是否存在权重为负值的环路所需时间为O(E)，Bellman-Ford算法的总运行时间为<span class="math inline">\(\Theta(V)+(|V|-1)\Theta(E)+O(E)=O(VE)\)</span>。</p><h2 id="优化">优化</h2><ol type="1"><li><p>提前跳出循环。</p><p>实际操作中，Bellman-Ford算法经常会在未达到|V|-1次前就出解，|V|-1其实是最大值。于是可以在循环中设置判定，在某次循环不再进行松弛时，直接退出循环，进行负权环判定。（若存在负权环，则循环次数一定会达到|V|-1次，因此，若是提前跳出循环，则说明图中没有负权环）</p></li><li><p>队列优化。参考最短路径快速算法。</p><p>松弛操作必定只会发生在最短路径前驱结点松弛成功过的结点上：结点v的所有前驱结点<span class="math inline">\(\{u|(u,v)\in{E}\}\)</span>中，若存在松弛成功（更新了最短路径估计d和前驱结点pi）的结点，则对结点v执行松弛操作RELAX(v, n, w)。</p><p>反过来说，我们应该对哪些结点v执行松弛操作：若结点u成功松弛，则应该对u的所有后继结点<span class="math inline">\(\{v|(u,v)\in{E}\}\)</span>执行松弛操作。</p><p>用一个队列记录松弛过的结点，避免了冗余计算。</p></li></ol><h2 id="代码">代码</h2><p>图用邻接链表的方式存储。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_f</span><span class="params">(graph, result=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> result <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        print(<span class="string">'has negative cycle or not?'</span>, <span class="keyword">not</span> result)</span><br><span class="line">    fmt = <span class="string">'&#123;0:&lt;10s&#125; &#123;1:&lt;10s&#125; &#123;2:&lt;10s&#125;\n'</span></span><br><span class="line">    title = fmt.format(<span class="string">'vertex'</span>, <span class="string">'distance'</span>, <span class="string">'previous'</span>)</span><br><span class="line">    data = <span class="string">''</span>.join(fmt.format(str(k), str(attr[<span class="string">'distance'</span>]), str(attr[<span class="string">'previous'</span>])) <span class="keyword">for</span> k, attr <span class="keyword">in</span> graph.nodes.items())</span><br><span class="line">    print(title + data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_single_source</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    <span class="string">"""初始化单源点"""</span></span><br><span class="line">    <span class="keyword">for</span> attr <span class="keyword">in</span> graph.nodes.values():</span><br><span class="line">        attr[<span class="string">'previous'</span>] = <span class="literal">None</span></span><br><span class="line">        attr[<span class="string">'distance'</span>] = float(<span class="string">'inf'</span>)</span><br><span class="line">    graph.nodes[s][<span class="string">'distance'</span>] = <span class="number">0</span>  <span class="comment"># 源点距离初始为0，其他为无穷远</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relax</span><span class="params">(graph, u, v, w)</span>:</span></span><br><span class="line">    <span class="string">"""relax操作，distance的值只在此处发生改变"""</span></span><br><span class="line">    u_attr, v_attr = graph.nodes[u], graph.nodes[v]</span><br><span class="line">    <span class="keyword">if</span> v_attr[<span class="string">'distance'</span>] &gt; u_attr[<span class="string">'distance'</span>] + w:</span><br><span class="line">        v_attr[<span class="string">'distance'</span>] = u_attr[<span class="string">'distance'</span>] + w  <span class="comment"># 更新最短距离</span></span><br><span class="line">        v_attr[<span class="string">'previous'</span>] = u  <span class="comment"># 更新前驱结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detect_negative_cycle</span><span class="params">(graph)</span>:</span></span><br><span class="line">    <span class="string">"""检测图g中是否包含负权环路"""</span></span><br><span class="line">    <span class="keyword">for</span> u, v, w <span class="keyword">in</span> graph.edges.data(<span class="string">'weight'</span>):</span><br><span class="line">        <span class="keyword">if</span> graph.nodes[v][<span class="string">'distance'</span>] &gt; graph.nodes[u][<span class="string">'distance'</span>] + w:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bellman_ford</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    <span class="string">"""Bellman Ford算法，同时判断是否存在权重为负值的环路"""</span></span><br><span class="line">    initialize_single_source(graph, s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(graph.number_of_nodes() - <span class="number">1</span>):  <span class="comment"># 重复|V|-1遍</span></span><br><span class="line">        <span class="keyword">for</span> u, v, w <span class="keyword">in</span> graph.edges.data(<span class="string">'weight'</span>):  <span class="comment"># 对每条边执行一次relax</span></span><br><span class="line">            relax(graph, u, v, w)</span><br><span class="line">    <span class="keyword">return</span> detect_negative_cycle(graph)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bellman_ford_op_1</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    <span class="string">"""优化方案1：提前跳出循环"""</span></span><br><span class="line">    initialize_single_source(graph, s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(graph.number_of_nodes() - <span class="number">1</span>):</span><br><span class="line">        relaxed = <span class="literal">False</span>  <span class="comment"># 一次循环开始前，标志位置为0</span></span><br><span class="line">        <span class="keyword">for</span> u, v, w <span class="keyword">in</span> graph.edges.data(<span class="string">'weight'</span>):</span><br><span class="line">            <span class="keyword">if</span> relax(graph, u, v, w) <span class="keyword">is</span> <span class="literal">True</span>:  <span class="comment"># 若松弛成功，标志位置为1</span></span><br><span class="line">                relaxed = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> relaxed <span class="keyword">is</span> <span class="literal">False</span>:  <span class="comment"># 提前跳出循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 若完整执行了|V|-1次循环，则去判断是否包含负权环</span></span><br><span class="line">        <span class="keyword">return</span> detect_negative_cycle(graph)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bellman_ford_op_2</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    <span class="string">"""队列优化"""</span></span><br><span class="line">    initialize_single_source(graph, s)</span><br><span class="line">    q = Queue()</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> graph.edges:</span><br><span class="line">        graph[u][v][<span class="string">'__times__'</span>] = <span class="number">0</span>  <span class="comment"># 记录松弛次数（不论结果），当超过|V|-1次时，说明图中包含负权环</span></span><br><span class="line">    q.put(s)  <span class="comment"># 初始放入源点</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">        u = q.get()</span><br><span class="line">        <span class="keyword">for</span> v, attr <span class="keyword">in</span> graph[u].items():  <span class="comment"># 遍历邻接边</span></span><br><span class="line">            <span class="keyword">if</span> relax(graph, u, v, attr[<span class="string">'weight'</span>]) <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">                q.put(v)  <span class="comment"># 将松弛成功过的结点放入队列</span></span><br><span class="line">                graph[u][v][<span class="string">'__times__'</span>] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> graph[u][v][<span class="string">'__times__'</span>] &gt; graph.number_of_nodes() - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># Bellman-Ford示例</span></span><br><span class="line">    g = nx.DiGraph()</span><br><span class="line">    g.add_nodes_from(<span class="string">'stxyz'</span>)</span><br><span class="line">    edges = [(<span class="string">'s'</span>, <span class="string">'t'</span>, <span class="number">6</span>), (<span class="string">'s'</span>, <span class="string">'y'</span>, <span class="number">7</span>), (<span class="string">'t'</span>, <span class="string">'x'</span>, <span class="number">5</span>), (<span class="string">'t'</span>, <span class="string">'y'</span>, <span class="number">8</span>), (<span class="string">'t'</span>, <span class="string">'z'</span>, <span class="number">-4</span>), (<span class="string">'x'</span>, <span class="string">'t'</span>, <span class="number">-2</span>), (<span class="string">'y'</span>, <span class="string">'x'</span>, <span class="number">-3</span>),</span><br><span class="line">             (<span class="string">'y'</span>, <span class="string">'z'</span>, <span class="number">9</span>), (<span class="string">'z'</span>, <span class="string">'s'</span>, <span class="number">2</span>), (<span class="string">'z'</span>, <span class="string">'x'</span>, <span class="number">7</span>)]</span><br><span class="line">    g.add_weighted_edges_from(edges)</span><br><span class="line">    r = bellman_ford(g, <span class="string">'s'</span>)</span><br><span class="line">    print_f(g, r)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 一个带有负权环路的示例</span></span><br><span class="line">    g.clear()</span><br><span class="line">    g.add_nodes_from(<span class="string">'s1234t'</span>)</span><br><span class="line">    edges = [(<span class="string">'s'</span>, <span class="string">'1'</span>, <span class="number">1</span>), (<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="number">1</span>), (<span class="string">'2'</span>, <span class="string">'1'</span>, <span class="number">-2</span>), (<span class="string">'1'</span>, <span class="string">'3'</span>, <span class="number">1</span>), (<span class="string">'3'</span>, <span class="string">'4'</span>, <span class="number">-4</span>), (<span class="string">'4'</span>, <span class="string">'1'</span>, <span class="number">1</span>), (<span class="string">'4'</span>, <span class="string">'t'</span>, <span class="number">1</span>)]</span><br><span class="line">    g.add_weighted_edges_from(edges)</span><br><span class="line">    r = bellman_ford_op_2(g, <span class="string">'s'</span>)</span><br><span class="line">    print_f(g, r)</span><br><span class="line"></span><br><span class="line">    g.clear()</span><br><span class="line">    g.add_nodes_from(<span class="string">'s1234t'</span>)</span><br><span class="line">    edges = [(<span class="string">'s'</span>, <span class="string">'1'</span>, <span class="number">3</span>), (<span class="string">'1'</span>, <span class="string">'s'</span>, <span class="number">-3</span>), (<span class="string">'s'</span>, <span class="string">'2'</span>, <span class="number">4</span>), (<span class="string">'2'</span>, <span class="string">'s'</span>, <span class="number">-4</span>), (<span class="string">'2'</span>, <span class="string">'1'</span>, <span class="number">3</span>), (<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="number">-3</span>), (<span class="string">'1'</span>, <span class="string">'3'</span>, <span class="number">7</span>),</span><br><span class="line">             (<span class="string">'3'</span>, <span class="string">'1'</span>, <span class="number">-7</span>), (<span class="string">'3'</span>, <span class="string">'2'</span>, <span class="number">5</span>), (<span class="string">'2'</span>, <span class="string">'4'</span>, <span class="number">6</span>), (<span class="string">'4'</span>, <span class="string">'2'</span>, <span class="number">-6</span>), (<span class="string">'3'</span>, <span class="string">'4'</span>, <span class="number">-8</span>), (<span class="string">'3'</span>, <span class="string">'t'</span>, <span class="number">6</span>),</span><br><span class="line">             (<span class="string">'t'</span>, <span class="string">'3'</span>, <span class="number">-6</span>), (<span class="string">'4'</span>, <span class="string">'t'</span>, <span class="number">9</span>), (<span class="string">'t'</span>, <span class="string">'4'</span>, <span class="number">-9</span>)]</span><br><span class="line">    g.add_weighted_edges_from(edges)</span><br><span class="line">    r = bellman_ford_op_1(g, <span class="string">'s'</span>)</span><br><span class="line">    print_f(g, r)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">has negative cycle or not? False</span><br><span class="line">vertex     distance   previous  </span><br><span class="line">s          0          None</span><br><span class="line">t          2          x</span><br><span class="line">x          4          y</span><br><span class="line">y          7          s</span><br><span class="line">z          -2         t</span><br><span class="line"></span><br><span class="line">has negative cycle or not? True</span><br><span class="line">vertex     distance   previous  </span><br><span class="line">s          0          None</span><br><span class="line">1          -4         4</span><br><span class="line">2          -3         1</span><br><span class="line">3          -2         1</span><br><span class="line">4          -6         3</span><br><span class="line">t          -4         4</span><br><span class="line"></span><br><span class="line">has negative cycle or not? True</span><br><span class="line">vertex     distance   previous  </span><br><span class="line">s          -23        2</span><br><span class="line">1          -17        3</span><br><span class="line">2          -24        4</span><br><span class="line">3          -15        t</span><br><span class="line">4          -18        3</span><br><span class="line">t          -9         4</span><br></pre></td></tr></table></figure><h1 id="dijkstra算法">Dijkstra算法</h1><p>Dijkstra算法是另一个解决单源最短路径问题的算法，该要求所有边的权重都为非负值。</p><p>Dijkstra算法在运行过程中维持的关键信息是一组结点集合S。从源节点s到该集合中每个结点之间的最短距离已经被找到。算法重复从结点集V-S中选择<strong>最短路径估计最小</strong>的结点u，将u加入到集合S，然后对所有从u发出的边进行松弛（对于边<span class="math inline">\((u,v),v\in{S}\)</span>是没有松弛的必要的，即使对之松弛，松弛一定不会成功，因为s到v的最短距离已经求出）。因为算法总是选择集合V-S中最近的结点来加入到集合S中，该算法使用的是贪心策略。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DIJKSTRA(G, w, s):</span><br><span class="line">    INITIALIZE-SINGLE-SOURCE(G, s)</span><br><span class="line">    S = empty set           <span class="comment"># 到源点s的最短距离被找到的结点集，伪代码中体现的作用不大</span></span><br><span class="line">    Q = G.V                 <span class="comment"># 初始时将所有结点放入优先队列</span></span><br><span class="line">    <span class="keyword">while</span> Q <span class="keyword">not</span> empty:</span><br><span class="line">        u = EXTRACT-MIN(Q)  <span class="comment"># 选择最短路径估计最小的结点</span></span><br><span class="line">        S = S + &#123;u&#125;         <span class="comment"># 将u加入集合S</span></span><br><span class="line">        <span class="keyword">for</span> each vertex v <span class="keyword">in</span> G.Adj[u]:     <span class="comment"># 松弛所有从u发出的边</span></span><br><span class="line">            RELAX(u, v, w)  <span class="comment"># 如果松弛成功，还要改变优先队列中结点v的减值</span></span><br></pre></td></tr></table></figure><p><img data-src="/uploads/posts/introduction-to-algorithms/execution-of-dijkstra.png" title="Dijkstra每次迭代后的结果"></p><p>在一个结点个数为5的带权重的有向图上执行Dijkstra算法的过程如上图。</p><p>(a)~(e) 为每次while循环开始时，灰色结点为最短路径估计最小的结点。白色结点属于集合V-S。</p><p>(b)~(f) 为每次for循环结束后，阴影的边描述了前驱节点。黑色的结点属于集合S。图(f)就是最终结果。</p><h2 id="分析-1">分析</h2><p>首先分析算法的循环次数。算法调用1次INITIALIZE-SINGLE-SOURCE操作和1次初始化优先队列操作Q=G.V。之后的while循环执行次数为|V|次，因为每次循环都从最小优先队列Q中提取一个结点。因此，EXTRACT-MIN也执行了|V|次。内层的for循环对从结点u发出的边执行一次松弛操作，而在while循环过程中，u取到了图中所有的结点且各取到一次。因此for循环实际上对图中所有的边执行了1次松弛操作，即RELAX操作的执行次数为|E|。暗含在其中的降低键值DECREASE-KEY操作也执行了|E|次。</p><p>如何实现算法中的优先队列直接影响到算法的时间复杂度。在此列出3中实现下的时间复杂度分析。</p><table><thead><tr class="header"><th>实现方式</th><th>初始化代价*1</th><th>提取最小值代价*V</th><th>降低键值代价*E</th><th>Dijkstra算法总代价</th></tr></thead><tbody><tr class="odd"><td>数组</td><td><span class="math inline">\(O(V)\)</span></td><td><span class="math inline">\(O(V)\)</span>，搜索整个数组</td><td><span class="math inline">\(O(1)\)</span></td><td><span class="math inline">\(O(V^2+E)=O(V^2)\)</span></td></tr><tr class="even"><td>二叉堆</td><td><span class="math inline">\(O(V)\)</span></td><td><span class="math inline">\(O(\lg{V})\)</span>，调整队</td><td><span class="math inline">\(O(\lg{V})\)</span>，调整堆</td><td><span class="math inline">\(O((V+E)\lg{V})\)</span></td></tr><tr class="odd"><td>斐波那契堆</td><td><span class="math inline">\(O(V)\)</span></td><td><span class="math inline">\(O(\lg{V})\)</span>，摊还代价</td><td><span class="math inline">\(O(1)\)</span>，摊还代价</td><td><span class="math inline">\(O(V\lg{V}+E)\)</span></td></tr></tbody></table><p>若所有结点都可以从源节点到达（|V|&lt;|E|），则<span class="math inline">\(O((V+E)\lg{V})=O(E\lg{V})\)</span>。对于稀疏图，特别地，如果<span class="math inline">\(E=o(V^2/\lg{V})\)</span>，则使用二叉堆实现最小优先队列相对于用数组直接实现的<span class="math inline">\(O(V^2)\)</span>代价有改善。</p><p>Dijkstra算法与广度优先搜索算法及计算最小生成树的Prim算法的相似点：</p><ul><li>与广度优先搜索算法：集合S对应的是广度优先搜索中的黑色结点集合：正如集合S中的结点的最短路径权重已经计算出来一样，在广度优先搜索中，黑色结点的正确广度优先距离也已经计算出来。</li><li>与Prim算法：两个算法都使用最小优先队列来寻找集合之外“最轻”结点，将该节点加入到集合里，并对位于集合外面的结点的权重进行相应调整。</li></ul><h2 id="代码-1">代码</h2><p>使用内建的优先队列时的妥协：</p><p>因为无法改变优先队列中的键值（或者说改变了也没有意义，优先队列不会调整结点在队列中的先后顺序），所以在初始时<span class="math inline">\(Q\neq{G.V}\)</span>，而是只将源点s放入优先队列。之后在松弛过程中，若发现集合S中不存在的结点，再将之放入优先队列。</p><p>但这也随之产生了一个问题：多条不同的边可能指向同一个集合S外的结点u，当这些边成功松弛多次时，结点u被多次加入队列中（因为内建的优先队列没有提供DECREASE-KEY操作，只能通过重复放入的方式更新键值）。这些重复加入的结点u携带不同的键值，显然，因最近一次松弛成功而被加入队列的结点u携带最小的键值。携带较大键值的结点u对算法没有意义，但它们仍然存在于队列中。因此，在循环开始时对取得的结点进行判断：若u结点在visit集合中，说明源结点s到u的最短距离已经求出，跳过这样的结点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue</span><br><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"><span class="keyword">from</span> graph.bellman_ford <span class="keyword">import</span> initialize_single_source, relax, print_f</span><br><span class="line"><span class="keyword">from</span> data_structure.fib_heap <span class="keyword">import</span> FibHeap, Node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dijkstra_queue</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    <span class="string">"""使用优先队列"""</span></span><br><span class="line">    initialize_single_source(graph, s)</span><br><span class="line">    visit, q = set(), PriorityQueue()  <span class="comment"># visit：集合S</span></span><br><span class="line">    q.put((graph.nodes[s][<span class="string">'distance'</span>], s))  <span class="comment"># 初始时s入队列</span></span><br><span class="line">    <span class="keyword">while</span> q.empty() <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">        u = q.get()[<span class="number">1</span>]  <span class="comment"># 选择最近的节点u</span></span><br><span class="line">        <span class="keyword">if</span> u <span class="keyword">not</span> <span class="keyword">in</span> visit:</span><br><span class="line">            visit.add(u)</span><br><span class="line">            <span class="keyword">for</span> v, e_attr <span class="keyword">in</span> graph[u].items():</span><br><span class="line">                <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> visit:  <span class="comment"># 已经访问过的顶点无需入队列</span></span><br><span class="line">                    relax(graph, u, v, e_attr[<span class="string">'weight'</span>])  <span class="comment"># relax最近顶点u的临界点</span></span><br><span class="line">                    q.put((graph.nodes[v][<span class="string">'distance'</span>], v))  <span class="comment"># 临接顶点入队列，同一顶点可能带有不同的distance值多次入队列</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dijkstra_fibonacci</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    <span class="string">"""使用斐波那契堆优化算法"""</span></span><br><span class="line">    initialize_single_source(graph, s)</span><br><span class="line">    m, visit, heap = &#123;&#125;, set(), FibHeap()  <span class="comment"># m：顶点到堆中结点的映射&#123;v.key:Node&#125;</span></span><br><span class="line">    <span class="keyword">for</span> v, v_attr <span class="keyword">in</span> graph.nodes.items():  <span class="comment"># 所有顶点入堆</span></span><br><span class="line">        n = Node(v_attr[<span class="string">'distance'</span>])</span><br><span class="line">        n.v = v  <span class="comment"># 为fibonacci node添加属性v，记录指向顶点的指针</span></span><br><span class="line">        heap.insert(n)</span><br><span class="line">        m[v] = n</span><br><span class="line">    <span class="keyword">while</span> heap.n &gt; <span class="number">0</span>:  <span class="comment"># 实际上循环|V|-1次，等价于for i in range(len(g.get_v_set()))</span></span><br><span class="line">        u = heap.pop().v  <span class="comment"># 选择最近的节点u</span></span><br><span class="line">        visit.add(u)</span><br><span class="line">        <span class="keyword">for</span> v, e_attr <span class="keyword">in</span> graph[u].items():</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> visit:</span><br><span class="line">                relax(graph, u, v, e_attr[<span class="string">'weight'</span>])</span><br><span class="line">                heap.decrease_key(m[v], graph.nodes[v][<span class="string">'distance'</span>])  <span class="comment"># 修改heap中对应节点的key值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># Dijkstra示例</span></span><br><span class="line">    g = nx.DiGraph()</span><br><span class="line">    g.add_nodes_from(<span class="string">'s12345t'</span>)</span><br><span class="line">    edges = [(<span class="string">'s'</span>, <span class="string">'1'</span>, <span class="number">2</span>), (<span class="string">'s'</span>, <span class="string">'2'</span>, <span class="number">3</span>), (<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="number">4</span>), (<span class="string">'1'</span>, <span class="string">'3'</span>, <span class="number">8</span>), (<span class="string">'1'</span>, <span class="string">'4'</span>, <span class="number">5</span>), (<span class="string">'2'</span>, <span class="string">'4'</span>, <span class="number">3</span>), (<span class="string">'2'</span>, <span class="string">'5'</span>, <span class="number">4</span>),</span><br><span class="line">             (<span class="string">'3'</span>, <span class="string">'4'</span>, <span class="number">2</span>), (<span class="string">'3'</span>, <span class="string">'t'</span>, <span class="number">9</span>), (<span class="string">'4'</span>, <span class="string">'t'</span>, <span class="number">6</span>), (<span class="string">'5'</span>, <span class="string">'t'</span>, <span class="number">10</span>)]</span><br><span class="line">    g.add_weighted_edges_from(edges)</span><br><span class="line">    dijkstra_queue(g, <span class="string">'s'</span>)</span><br><span class="line">    print_f(g)</span><br><span class="line"></span><br><span class="line">    g.clear()</span><br><span class="line">    g.add_nodes_from(<span class="string">'stxyz'</span>)</span><br><span class="line">    edges = [(<span class="string">'s'</span>, <span class="string">'t'</span>, <span class="number">10</span>), (<span class="string">'s'</span>, <span class="string">'y'</span>, <span class="number">5</span>), (<span class="string">'t'</span>, <span class="string">'x'</span>, <span class="number">1</span>), (<span class="string">'t'</span>, <span class="string">'y'</span>, <span class="number">2</span>), (<span class="string">'x'</span>, <span class="string">'z'</span>, <span class="number">4</span>), (<span class="string">'y'</span>, <span class="string">'t'</span>, <span class="number">3</span>), (<span class="string">'y'</span>, <span class="string">'x'</span>, <span class="number">9</span>),</span><br><span class="line">             (<span class="string">'y'</span>, <span class="string">'z'</span>, <span class="number">2</span>), (<span class="string">'z'</span>, <span class="string">'s'</span>, <span class="number">7</span>), (<span class="string">'z'</span>, <span class="string">'x'</span>, <span class="number">6</span>)]</span><br><span class="line">    g.add_weighted_edges_from(edges)</span><br><span class="line">    dijkstra_fibonacci(g, <span class="string">'s'</span>)</span><br><span class="line">    print_f(g)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vertex     distance   previous  </span><br><span class="line">s          0          None</span><br><span class="line">1          2          s</span><br><span class="line">2          3          s</span><br><span class="line">3          10         1</span><br><span class="line">4          6          2</span><br><span class="line">5          7          2</span><br><span class="line">t          12         4</span><br><span class="line"></span><br><span class="line">vertex     distance   previous  </span><br><span class="line">s          0          None</span><br><span class="line">t          8          y</span><br><span class="line">x          9          t</span><br><span class="line">y          5          s</span><br><span class="line">z          7          y</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction To Algorithms </tag>
            
            <tag> algorithms </tag>
            
            <tag> fibonacci heap </tag>
            
            <tag> greedy method </tag>
            
            <tag> priority queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树</title>
      <link href="/notes/introduction-to-algorithms/binary-search-trees/"/>
      <url>/notes/introduction-to-algorithms/binary-search-trees/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉搜索树">二叉搜索树</h1><p>一棵二叉搜索树是以一棵二叉树来组织的。每个结点除了key之外，还包含属性left、right、p，分别指向结点的左孩子、右孩子和父节点。如果父节点或者子节点不存在，则相应属性值为NIL。根节点是唯一父节点为NIL的结点。</p><h1 id="性质">性质</h1><p>二叉搜索树性质：</p><p>设x是二叉搜索树中的一个结点。如果y是x左子树中的一个结点，那么<span class="math inline">\(y.key\le{x.key}\)</span>。如果y是x右子树中的一个结点，那么<span class="math inline">\(y.key\ge{x.key}\)</span>。</p><p>根据此性质，可以通过中序遍历（inorder tree walk）算法按序输出二叉搜索树中的所有关键字。比较简单的递归实现如下：</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INORDER-TREE-WALK(x):</span><br><span class="line">    <span class="keyword">if</span> x != NIL:</span><br><span class="line">        INORDER-TREE-WALK(x.left)</span><br><span class="line">        <span class="keyword">print</span> x.key</span><br><span class="line">        INORDER-TREE-WALK(x.right)</span><br></pre></td></tr></table></figure><p>包含相同结点的两棵高度不同的二叉搜索树。大部分搜索树操作的运行时间与树的高度成正比。因此(b)比(a)低效。</p><p><img data-src="/uploads/posts/introduction-to-algorithms/binary-search-trees.png" title="二叉搜索树"></p><h1 id="操作">操作</h1><h2 id="查找">查找</h2><p>使用下面的过程在一棵二叉搜索树中查找一个具有给定关键字的结点。输入一个指向树根的指针x和一个关键字k，如果这个结点存在，返回一个指向关键字为k的结点的指针；否则返回NIL。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TREE-SEARCH(x, k):</span><br><span class="line">    <span class="keyword">if</span> x == NIL <span class="keyword">or</span> k == x.key:  <span class="comment"># 如果关键字与k相等，返回结果</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">if</span> k &lt; x.key:               <span class="comment"># 如果关键字大于k，查找在左子树中继续</span></span><br><span class="line">        <span class="keyword">return</span> TREE-SEARCH(x.left, k)   <span class="comment"># 递归</span></span><br><span class="line">    <span class="keyword">else</span>:                       <span class="comment"># 如果关键字小于k，查找在右子树中继续</span></span><br><span class="line">        <span class="keyword">return</span> TREE-SEARCH(x.right, k)</span><br></pre></td></tr></table></figure><p>可以采用循环来展开递归，用一种迭代方式重写此过程。对于大多数计算机，迭代版本的效率要高得多。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ITERATIVE-TREE-SEARCH(x, k):</span><br><span class="line">    <span class="keyword">while</span> x != NIL <span class="keyword">and</span> k != x.key:  <span class="comment"># 迭代实现：如果关键字与k不相等，重复循环</span></span><br><span class="line">        <span class="keyword">if</span> k &lt; x.key:               <span class="comment"># 如果关键字大于k，查找在左子树中继续</span></span><br><span class="line">            x = x.left</span><br><span class="line">        <span class="keyword">else</span>:                       <span class="comment"># 否则，在右子树中继续</span></span><br><span class="line">            x = x.right</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p><img data-src="/uploads/posts/introduction-to-algorithms/binary-search-tree-search.png" title="搜索键值等于13的结点"></p><p>例如在如上图所示的二叉查找树中查找键值为13的查找路径是<span class="math inline">\(15\rightarrow6\rightarrow7\rightarrow13\)</span>。具体步骤为：</p><ol type="1"><li>x指向根节点，比较x与13。13&lt;15：x指向x.left，在左子树中继续查找。</li><li>13&gt;6：x指向x.right，在右子树中继续查找。</li><li>13&gt;7：x指向x.right，在右子树中继续查找。</li><li>13=13：返回x。</li></ol><h3 id="最大和最小关键字">最大和最小关键字</h3><p>查找最小关键字元素：从根开始沿着left孩子指针直到遇到一个NIL。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TREE-MINIMUM(X):</span><br><span class="line">    <span class="keyword">while</span> x.left != NIL:  <span class="comment"># 假设x != NIL，不停查找左子树</span></span><br><span class="line">        x = x.left</span><br><span class="line">    <span class="keyword">return</span> x              <span class="comment"># 当x的左子树为NIL时，x为最小关键字元素</span></span><br></pre></td></tr></table></figure><p>查找最大关键字的TREE-MAXIMUM的伪代码是对称的，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TREE-MAXIMUM(x):</span><br><span class="line">    <span class="keyword">while</span> x.right != NIL:</span><br><span class="line">        x = x.right</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h3 id="后继和前驱">后继和前驱</h3><p>给定一棵二叉搜索树中的一个结点，有时候需要按中序遍历的次序查找它的后继。如果所有的关键字互不相同，则一个结点x的<strong>后继</strong>是大于x.key的最小关键字的结点。二叉搜索树的性质允许我们通过没有任何关键字的比较来确定一个结点的后继。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TREE-SUCCESSOR(x):</span><br><span class="line">    <span class="keyword">if</span> x.right != NIL:  <span class="comment"># 如果x的右子树不为空，根据性质，右子树中的关键字均大于x的关键字</span></span><br><span class="line">        <span class="keyword">return</span> TREE-MINIMUM(x.right)  <span class="comment"># 此时x的后继为右子树中最小的结点</span></span><br><span class="line">    y = x.p  <span class="comment"># 如果右子树为空，那么x的后继是 x的有左孩子的最底层祖先（回想中序遍历次序）</span></span><br><span class="line">    <span class="keyword">while</span> y != NIL <span class="keyword">and</span> x == y.right:</span><br><span class="line">        x = y</span><br><span class="line">        y = y.p</span><br><span class="line">    <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><p>查找<strong>前驱</strong>的TREE-PREDECESSOR的伪代码是对称的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TREE-PREDECESSOR(x):</span><br><span class="line">    <span class="keyword">if</span> x.left != NIL:</span><br><span class="line">        <span class="keyword">return</span> TREE-MAXIMUM(x.left)</span><br><span class="line">    y = x.p</span><br><span class="line">    <span class="keyword">while</span> y != NIL <span class="keyword">and</span> x == y.left:</span><br><span class="line">        x = y</span><br><span class="line">        y = y.p</span><br><span class="line">    <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><h2 id="插入和删除">插入和删除</h2><p>插入和删除操作会引起由二叉搜索树表示的动态集合的变化（二叉搜索树中的元素集合会变化）。一定要修改指针以保持二叉搜索树性质的成立。</p><h3 id="插入">插入</h3><p>插入操作相对简单些。将结点z插入到树中的相应位置上，这个过程要修改T和z的某些属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TREE-INSERT(T, z):</span><br><span class="line">    y = NIL</span><br><span class="line">    x = T.root            <span class="comment"># 找到z在树中的位置</span></span><br><span class="line">    <span class="keyword">while</span> x != NIL:</span><br><span class="line">        y = x</span><br><span class="line">        <span class="keyword">if</span> z.key &lt; x.key:</span><br><span class="line">            x = x.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x = x.right</span><br><span class="line">    z.p = y               <span class="comment"># 找到z的位置时，y为z在树中的父节点</span></span><br><span class="line">    <span class="keyword">if</span> y == NIL:          <span class="comment"># 如果父节点为NIL，说明在插入前二叉搜索树是空的</span></span><br><span class="line">        T.root = z</span><br><span class="line">    <span class="keyword">elif</span> z.key &lt; y.key:   <span class="comment"># 判断z与父节点y的大小关系，决定z称为左孩子还是右孩子</span></span><br><span class="line">        y.left = z</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        y.right = z</span><br></pre></td></tr></table></figure><p><img data-src="/uploads/posts/introduction-to-algorithms/binary-search-tree-insert.png" title="插入一个键值等于13的新结点"></p><p>例如在如上图所示的二叉查找树中插入键值为13的结点。步骤为：</p><ol type="1"><li>x指向根节点。比较x的键值与欲插入的键值13的大小关系：12&lt;13：x指向x.right。意味着，结点13应该在根节点的右子树中。</li><li>x.key=18，18&gt;13：x指向x.left。</li><li>x.key=15，15&gt;13：x指向x.left。</li><li>x=NIL，x就是结点13应该插入的位置。修改相应指针完成插入操作。</li></ol><h3 id="删除">删除</h3><p>从一棵二叉搜索树T中删除一个结点z时需要考虑三种基本情况。</p><ul><li>如果z没有孩子结点。</li><li>如果z只有一个孩子。</li><li>如果z既有左孩子又有右孩子。</li></ul><p>在具体的删除操作中，则需要考虑4中情况，它与上面的三种情况有些不同。</p><ul><li><ol type="a"><li>若z的左孩子为空，那么用其右孩子来替换z，这个右孩子可以是NIL。为NIL时对应上面的第一种情况；不为NIL时对应第二种情况。</li></ol></li><li><ol start="2" type="a"><li>若z的右孩子为空，那么用其左孩子来替换z。</li></ol><p>否则，z既有左孩子又有右孩子。需要查找z的后继节点y（这个后继位于z的右子树中并且没有左孩子）。</p></li><li><ol start="3" type="a"><li>若y是z的右孩子，那么用y替换z，并仅留下y的右孩子。</li></ol></li><li><ol start="4" type="a"><li>若y位于z的右子树中但并不是z的右孩子。在这种情况下，先用y的右孩子替换y，然后再用y替换z。</li></ol></li></ul><p><img data-src="/uploads/posts/introduction-to-algorithms/binary-search-tree-delete.png" title="删除结点的4种情况"></p><p>为了在二叉搜索树内移动子树，定义一个子过程TRANSPLANT。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TRANSPLANT(T, u, v):        <span class="comment"># 用根节点为v的子树替换根节点为u的子树</span></span><br><span class="line">    <span class="keyword">if</span> u.p == NIL:          <span class="comment"># 若u为根节点，则子树的替换实际上就是整棵树的替换</span></span><br><span class="line">        T.root = v          <span class="comment"># 因而，只需修改树的root属性</span></span><br><span class="line">    <span class="keyword">elif</span> u == u.p.left:     <span class="comment"># 若u是左孩子</span></span><br><span class="line">        u.p.left = v        <span class="comment"># 修改父节点左孩子指针</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        u.p.right = v       <span class="comment"># 否则修改右孩子指针</span></span><br><span class="line">    <span class="keyword">if</span> v != NIL:            <span class="comment"># 若v不为空，修改v的父节点指针</span></span><br><span class="line">        v.p = u.p</span><br></pre></td></tr></table></figure><p>注意到，TRANSPLANT并没有处理v.left和v.right的更新，这些更新都由TRANSPLANT的调用者来负责。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TREE-DELETE(T, z):</span><br><span class="line">    <span class="keyword">if</span> z.left == NIL:                  <span class="comment"># 情况(a)：左孩子为空</span></span><br><span class="line">        TRANSPLANT(T, z, z.right)      <span class="comment"># 用右孩子替换</span></span><br><span class="line">    <span class="keyword">elif</span> z.right == NIL:               <span class="comment"># 情况(b):右孩子为空</span></span><br><span class="line">        TRANSPLANT(T, z, z.left)       <span class="comment"># 用左孩子替换</span></span><br><span class="line">    <span class="keyword">else</span>:                              <span class="comment"># 既有左孩子又有右孩子</span></span><br><span class="line">        y = TREE-MINIMUM(z.right)      <span class="comment"># 查找z的后继y</span></span><br><span class="line">        <span class="keyword">if</span> y.p != z:                   <span class="comment"># 情况(d)：如果y不是z的右孩子</span></span><br><span class="line">            TRANSPLANT(T, y, y.right)  <span class="comment"># 用y的右孩子替换y</span></span><br><span class="line">            y.right = z.right          <span class="comment"># 修改y的右孩子指针</span></span><br><span class="line">            y.right.p = y              <span class="comment"># 将原来z的孩子结点的父节点指针指向y</span></span><br><span class="line">        TRANSPLANT(T, z, y)            <span class="comment"># 情况(c)：y是z的子节点，用y替换z，也是(d)的第二步替换</span></span><br><span class="line">        y.left = z.left                <span class="comment"># 修改y的指针属性</span></span><br><span class="line">        y.left.p = y</span><br></pre></td></tr></table></figure><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> data_structure.binary_tree <span class="keyword">import</span> BinaryTree, Node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span><span class="params">(BinaryTree)</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(x, k)</span>:</span></span><br><span class="line">        <span class="string">"""在根节点为x的子树中迭代查找键值为k的结点"""</span></span><br><span class="line">        <span class="keyword">while</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> k != x.key:</span><br><span class="line">            <span class="keyword">if</span> k &lt; x.key:</span><br><span class="line">                x = x.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x = x.right</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimum</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="string">"""返回以x为根节点的子树中键值最小的结点，x为空时返回None"""</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">while</span> x.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                x = x.left</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximum</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="string">""""返回子树中键值最大的结点"""</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">while</span> x.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                x = x.right</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">successor</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""返回结点x的后继结点"""</span></span><br><span class="line">        <span class="keyword">if</span> x.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self.minimum(x.right)</span><br><span class="line">        y = x.p</span><br><span class="line">        <span class="keyword">while</span> y <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> x == y.right:</span><br><span class="line">            x, y = y, y.p</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predecessor</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""返回前驱"""</span></span><br><span class="line">        <span class="keyword">if</span> x.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self.maximum(x.left)</span><br><span class="line">        y = x.p</span><br><span class="line">        <span class="keyword">while</span> y <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> x == y.left:</span><br><span class="line">            x, y = y, y.p</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, z)</span>:</span></span><br><span class="line">        <span class="string">"""插入结点z"""</span></span><br><span class="line">        y, x = <span class="literal">None</span>, self.root</span><br><span class="line">        <span class="keyword">while</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            y = x</span><br><span class="line">            <span class="keyword">if</span> z.key &lt; x.key:</span><br><span class="line">                x = x.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x = x.right</span><br><span class="line">        z.p = y</span><br><span class="line">        <span class="keyword">if</span> y <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.root = z</span><br><span class="line">        <span class="keyword">elif</span> z.key &lt; y.key:</span><br><span class="line">            y.left = z</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            y.right = z</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transplant</span><span class="params">(self, u, v)</span>:</span></span><br><span class="line">        <span class="string">"""用v替换u"""</span></span><br><span class="line">        <span class="keyword">if</span> u.p <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.root = v</span><br><span class="line">        <span class="keyword">elif</span> u == u.p.left:</span><br><span class="line">            u.p.left = v</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            u.p.right = v</span><br><span class="line">        <span class="keyword">if</span> v <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            v.p = u.p</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, z)</span>:</span></span><br><span class="line">        <span class="string">"""删除结点z"""</span></span><br><span class="line">        <span class="keyword">if</span> z.left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.transplant(z, z.right)</span><br><span class="line">        <span class="keyword">elif</span> z.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.transplant(z, z.left)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            y = self.minimum(z.right)</span><br><span class="line">            <span class="keyword">if</span> y.p != z:</span><br><span class="line">                self.transplant(y, y.right)</span><br><span class="line">                y.right, y.right.p = z.right, y</span><br><span class="line">            self.transplant(z, y)</span><br><span class="line">            y.left, y.left.p = z.left, y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    key = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">18</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">15</span>, <span class="number">19</span>, <span class="number">17</span>, <span class="number">3</span>, <span class="number">21</span>]</span><br><span class="line">    n = &#123;i: Node(i) <span class="keyword">for</span> i <span class="keyword">in</span> key&#125;</span><br><span class="line">    bst = BinarySearchTree()</span><br><span class="line">    [bst.insert(n[i]) <span class="keyword">for</span> i <span class="keyword">in</span> key]</span><br><span class="line">    print(<span class="string">'初始    '</span>, bst)</span><br><span class="line">    print(<span class="string">'查找 8  '</span>, bst.search(bst.root, <span class="number">8</span>))  <span class="comment"># 在整棵树中搜索</span></span><br><span class="line">    print(<span class="string">'查找 9  '</span>, bst.search(bst.root, <span class="number">9</span>))</span><br><span class="line">    print(<span class="string">'12的前驱'</span>, bst.predecessor(n[<span class="number">12</span>]))  <span class="comment"># 前驱</span></span><br><span class="line">    print(<span class="string">'12的后继'</span>, bst.successor(n[<span class="number">12</span>]))  <span class="comment"># 后继</span></span><br><span class="line">    n[<span class="number">8</span>] = Node(<span class="number">8</span>)</span><br><span class="line">    bst.insert(n[<span class="number">8</span>])  <span class="comment"># 插入</span></span><br><span class="line">    print(<span class="string">'插入 8后'</span>, bst)</span><br><span class="line">    bst.delete(n[<span class="number">3</span>])  <span class="comment"># 情况(a)，只有右孩子</span></span><br><span class="line">    print(<span class="string">'删除 3后'</span>, bst)</span><br><span class="line">    bst.delete(n[<span class="number">8</span>])  <span class="comment"># 情况(a)，只有左孩子</span></span><br><span class="line">    print(<span class="string">'删除 8后'</span>, bst)</span><br><span class="line">    bst.delete(n[<span class="number">18</span>])  <span class="comment"># 情况(c)，有右孩子结点19，且右孩子是其后继结点</span></span><br><span class="line">    print(<span class="string">'删除18后'</span>, bst)</span><br><span class="line">    bst.delete(n[<span class="number">12</span>])  <span class="comment"># 情况(d)，后继结点是15</span></span><br><span class="line">    print(<span class="string">'删除12后'</span>, bst)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">初始     &#123;12: [&#123;5: [&#123;2: [None, 3]&#125;, 9]&#125;, &#123;18: [&#123;15: [None, 17]&#125;, &#123;19: [None, 21]&#125;]&#125;]&#125;</span><br><span class="line">查找 8   None</span><br><span class="line">查找 9   9</span><br><span class="line">12的前驱 9</span><br><span class="line">12的后继 15</span><br><span class="line">插入 8后 &#123;12: [&#123;5: [&#123;2: [None, 3]&#125;, &#123;9: [8, None]&#125;]&#125;, &#123;18: [&#123;15: [None, 17]&#125;, &#123;19: [None, 21]&#125;]&#125;]&#125;</span><br><span class="line">删除 3后 &#123;12: [&#123;5: [2, &#123;9: [8, None]&#125;]&#125;, &#123;18: [&#123;15: [None, 17]&#125;, &#123;19: [None, 21]&#125;]&#125;]&#125;</span><br><span class="line">删除 8后 &#123;12: [&#123;5: [2, 9]&#125;, &#123;18: [&#123;15: [None, 17]&#125;, &#123;19: [None, 21]&#125;]&#125;]&#125;</span><br><span class="line">删除18后 &#123;12: [&#123;5: [2, 9]&#125;, &#123;19: [&#123;15: [None, 17]&#125;, 21]&#125;]&#125;</span><br><span class="line">删除12后 &#123;15: [&#123;5: [2, 9]&#125;, &#123;19: [17, 21]&#125;]&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction To Algorithms </tag>
            
            <tag> data structures </tag>
            
            <tag> binary tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有根树</title>
      <link href="/notes/introduction-to-algorithms/rooted-trees/"/>
      <url>/notes/introduction-to-algorithms/rooted-trees/</url>
      
        <content type="html"><![CDATA[<h1 id="有根树">有根树</h1><p>表示链表的方法可以推广到任意同构的数据结构上。树的结点用对象表示。与链表类似，每个结点都含有一个关键字key。其余的属性包括指向其他结点的指针，它们随树的种类不同会有所变化。</p><p>链表的结点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Node:</span><br><span class="line">    key       <span class="comment"># 结点自身的键值</span></span><br><span class="line">    previous  <span class="comment"># 前驱节点</span></span><br><span class="line">    next      <span class="comment"># 后继结点</span></span><br></pre></td></tr></table></figure><h1 id="二叉树">二叉树</h1><p>二叉树的结点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Node:</span><br><span class="line">    key    <span class="comment"># 键值</span></span><br><span class="line">    p      <span class="comment"># 父节点，只有根节点的父节点为NIL</span></span><br><span class="line">    left   <span class="comment"># 左孩子，若没有左孩子，则该属性为NIL</span></span><br><span class="line">    right  <span class="comment"># 右孩子，若没有右孩子，则该属性为NIL</span></span><br></pre></td></tr></table></figure><a id="more"></a><p><img data-src="/uploads/posts/introduction-to-algorithms/binary-tree.png" title="二叉树的表示方法"></p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.p = self.left = self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_left</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.left, n.p = n, self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_right</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.right, n.p = n, self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.values(self.root))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">values</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""递归得到以当前结点为根节点的子树中所有结点的值"""</span></span><br><span class="line">        v, c = [], <span class="number">0</span>  <span class="comment"># c：孩子个数</span></span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            v.append(self.values(node.left))</span><br><span class="line">            c += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            v.append(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            v.append(self.values(node.right))</span><br><span class="line">            c += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            v.append(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> c &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;node.key: v&#125;</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> node.key</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    key = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">    n = [Node(i) <span class="keyword">for</span> i <span class="keyword">in</span> key]</span><br><span class="line">    t = BinaryTree()</span><br><span class="line">    t.root = n[<span class="number">0</span>]</span><br><span class="line">    n[<span class="number">0</span>].set_left(n[<span class="number">1</span>])</span><br><span class="line">    n[<span class="number">0</span>].set_right(n[<span class="number">2</span>])</span><br><span class="line">    n[<span class="number">1</span>].set_right(n[<span class="number">3</span>])</span><br><span class="line">    n[<span class="number">2</span>].set_left(n[<span class="number">4</span>])</span><br><span class="line">    n[<span class="number">2</span>].set_right(n[<span class="number">5</span>])</span><br><span class="line">    n[<span class="number">3</span>].set_left(n[<span class="number">6</span>])</span><br><span class="line">    n[<span class="number">3</span>].set_right(n[<span class="number">7</span>])</span><br><span class="line">    n[<span class="number">4</span>].set_right(n[<span class="number">8</span>])</span><br><span class="line">    n[<span class="number">5</span>].set_left(n[<span class="number">9</span>])</span><br><span class="line">    n[<span class="number">8</span>].set_left(n[<span class="number">10</span>])</span><br><span class="line">    print(t)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">0</span>: [&#123;<span class="number">1</span>: [<span class="literal">None</span>, &#123;<span class="number">3</span>: [<span class="number">6</span>, <span class="number">7</span>]&#125;]&#125;, &#123;<span class="number">2</span>: [&#123;<span class="number">4</span>: [<span class="literal">None</span>, &#123;<span class="number">8</span>: [<span class="number">10</span>, <span class="literal">None</span>]&#125;]&#125;, &#123;<span class="number">5</span>: [<span class="number">9</span>, <span class="literal">None</span>]&#125;]&#125;]&#125;</span><br></pre></td></tr></table></figure><h1 id="分支无限制的有根树">分支无限制的有根树</h1><p>二叉树的表示方法可以推广到每个结点的孩子数至多为常数k的任意类型的树：只需要将left和right属性用<code>child1，child2，...，childk</code>代替。缺点是，若大部分结点只有少量的孩子，则会浪费大量存储空间（大量无意义的孩子指针）。此外，若孩子的结点数无限制时，此方法失效。所幸的是，有一个巧妙地方法可以用来表示孩子数任意的树。</p><p><strong>左孩子右兄弟表示法</strong>（left-child, right-sibling representation）：对任意n个结点的有根树，只需要O(n)的存储空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Node:</span><br><span class="line">    key              <span class="comment"># 键值</span></span><br><span class="line">    p                <span class="comment"># 父节点，若为根节点，则为NIL</span></span><br><span class="line">    left-child       <span class="comment"># 最左边的孩子结点，若没有孩子结点，则为NIL</span></span><br><span class="line">    right-sibling    <span class="comment"># 右侧相邻的兄弟结点，若是其父节点的最右孩子，则为NIL</span></span><br></pre></td></tr></table></figure><p><img data-src="/uploads/posts/introduction-to-algorithms/tree-with-unbounded-branching.png" title="不限分支数的有根树的表示方法"></p><h2 id="代码-1">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> data_structure.binary_tree <span class="keyword">import</span> Node <span class="keyword">as</span> Ne</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(Ne)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_child</span><span class="params">(self, c)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.set_left(c)  <span class="comment"># 添加第一个孩子</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 追加孩子</span></span><br><span class="line">            x = self.left</span><br><span class="line">            <span class="keyword">while</span> x.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment"># 寻找追加位置</span></span><br><span class="line">                x = x.right</span><br><span class="line">            x.right, c.p = c, self  <span class="comment"># 添加指针</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        self.root = root</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.values(self.root))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">values</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 没有孩子节点</span></span><br><span class="line">            <span class="keyword">return</span> node.key</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c = node.left</span><br><span class="line">            v = [self.values(c)]  <span class="comment"># 所有孩子组成的列表</span></span><br><span class="line">            <span class="keyword">while</span> c.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                v.append(self.values(c.right))</span><br><span class="line">                c = c.right</span><br><span class="line">            <span class="keyword">return</span> &#123;node.key: v&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    key = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line">    n = [Node(i) <span class="keyword">for</span> i <span class="keyword">in</span> key]</span><br><span class="line">    t = Tree(n[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        n[<span class="number">0</span>].add_child(n[i])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>, <span class="number">6</span>):</span><br><span class="line">        n[<span class="number">1</span>].add_child(n[i])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>, <span class="number">10</span>):</span><br><span class="line">        n[<span class="number">2</span>].add_child(n[i])</span><br><span class="line">    n[<span class="number">3</span>].add_child(n[<span class="number">10</span>])</span><br><span class="line">    n[<span class="number">5</span>].add_child(n[<span class="number">11</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">12</span>, <span class="number">14</span>):</span><br><span class="line">        n[<span class="number">8</span>].add_child(n[i])</span><br><span class="line">    print(t)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;0: [&#123;1: [4, &#123;5: [11]&#125;]&#125;, &#123;2: [6, 7, &#123;8: [12, 13]&#125;, 9]&#125;, &#123;3: [10]&#125;]&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction To Algorithms </tag>
            
            <tag> data structures </tag>
            
            <tag> binary tree </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/notes/introduction-to-algorithms/linked-lists/"/>
      <url>/notes/introduction-to-algorithms/linked-lists/</url>
      
        <content type="html"><![CDATA[<h1 id="链表">链表</h1><p>链表（linked list）中的各元素按线性顺序排列。数据的线性顺序是由数组下标决定的，然而与数组不同的是，链表的顺序是由各个对象里的指针决定的。链表为动态集合提供了一种简单而灵活的表示方法。</p><h1 id="种类">种类</h1><p>链表可以有多种形式。它可以是单链接的或双链接的，可以是已排序的或未排序的，可以是循环的或非循环的。</p><ul><li><p>双向链表（doubly linked list）L的每个元素都是一个对象，每个对象有一个关键字k和两个指针：next和prev。对象中还可以包含其他辅助数据（或称为卫星数据）。设x为链表的一个元素，x.next指向它在链表中的后继元素，x.prev则指向它的前驱元素。如果x.prev=NIL，则元素x没有前驱，因此是链表的第一个元素，即链表的头（head）。如果x.next=NIL，则元素x没有后继，因此是链表的最后一个元素，即链表的尾（tail）。属性L.head指向链表的第一个元素。如果L.head=NIL，则链表为空。</p><p><img data-src="/uploads/posts/introduction-to-algorithms/linked-list.png" title="链表"></p></li><li><p>单链接的（single linked）：省略每个元素中的prev指针。</p></li></ul><a id="more"></a><ul><li>已排序（sorted）的：链表的线性顺序与链表元素中关键字的线性顺序一致。据此，最小的元素就是表头元素，而最大的元素则是表尾元素。</li><li><p>未排序（unsorted）的：链表的各元素可以以任何顺序出现。</p></li><li><p>循环链表（circular list）：表头元素的prev指针指向表尾元素，而表尾元素的next指针则指向表头元素。可以将循环链表想象成一个各元素组成的圆环。</p></li></ul><h1 id="操作">操作</h1><h2 id="搜索">搜索</h2><p>过程LIST-SEARCH采用简单的线性搜索方法，用于查找链表L中第一个关键字为k的元素，并返回指向该元素的指针。如果链表中没有关键字为k的对象，则返回NIL。要搜索一个有n个对象的链表，过程LIST-SEARCH在最坏情况下的运行时间为<span class="math inline">\(\Theta(n)\)</span>，因为可能需要搜索整个链表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LIST-SEARCH(L, k):</span><br><span class="line">    x = L.head</span><br><span class="line">    <span class="keyword">while</span> x != NIL <span class="keyword">and</span> x.key != k:</span><br><span class="line">        x = x.next</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h2 id="插入">插入</h2><p>给定一个元素x，过程LIST-INSERT将x”连接入“到链表的前端。在一个含n个元素的链表上执行LIST-INSERT的运行时间是<span class="math inline">\(\Theta(1)\)</span>。例如，在(a)所示的链表中插入键值为25的元素。插入后的链表如(b)所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LIST-INSERT(L, x):</span><br><span class="line">    x.next = L.head      <span class="comment"># 将x的后继元素指向当前head</span></span><br><span class="line">    <span class="keyword">if</span> L.head != NIL:    <span class="comment"># 若当前head不为NIL</span></span><br><span class="line">        L.head.prev = x  <span class="comment"># 修改head的前驱元素为x</span></span><br><span class="line">    L.head = x           <span class="comment"># 更改链表的表头元素</span></span><br><span class="line">    x.prev = NIL         <span class="comment"># 修改x的前驱元素为NIL</span></span><br></pre></td></tr></table></figure><h2 id="删除">删除</h2><p>过程LIST-DELETE将一个元素x从链表L中移除。通过修改一些指针，将x“删除出”该链表。如果要删除具有给定关键字值的元素，则必须先调用LIST-SEARCH找到该元素。LIST-DELETE的运行时间为<span class="math inline">\(\Theta(1)\)</span>。例如，在(b)所示的链表中删除键值为4的元素，删除后的链表如(c)所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LIST-DELETE(L, x):</span><br><span class="line">    <span class="keyword">if</span> x.prev != NIL:          <span class="comment"># 如果x不是表头元素</span></span><br><span class="line">        x.prev.next = x.next   <span class="comment"># 修改x的前驱中的后继指针</span></span><br><span class="line">    <span class="keyword">else</span>:                      <span class="comment"># 如果x是表头元素，则x没有前驱</span></span><br><span class="line">        L.head = x.next        <span class="comment"># 直接修改表头指针</span></span><br><span class="line">    <span class="keyword">if</span> x.next != NIL:          <span class="comment"># 如果x有后继元素</span></span><br><span class="line">        x.next.prev = x.prev   <span class="comment"># 修改后继元素的前驱指针</span></span><br></pre></td></tr></table></figure><h2 id="哨兵">哨兵</h2><p>哨兵（sentinel）是一个哑对象，其作用是简化边界条件的处理。在链表L中设置一个哨兵L.nil，对于链表代码中出现的每一处（表头和表尾）对NIL的引用，都代之以对哨兵L.nil的引用，即表头元素的prev指针和表尾的next指针均指向L.nil。这样的调整将一个常规的双向链表转变为一个<strong>有哨兵的双向循环链表</strong>（circular, doubly linked list with a sentinel），哨兵位于表头和表尾之间。属性L.nil.next指向表头，L.nil.prev指向表尾。一个空链表只由一个哨兵构成，L.nil.next和L.nil.prev同时指向L.nil。</p><p><img data-src="/uploads/posts/introduction-to-algorithms/circular-doubly-linked-list-with-a-sentinel.png" title="有哨兵的双向循环链表"></p><p>应当慎用哨兵。假如有许多个很短的链表，它们的哨兵所占用的额外的存储空间会造成严重的存储浪费。</p><p>引入哨兵后，搜索、插入和删除的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LIST-SEARCH<span class="string">'(L, k):</span></span><br><span class="line"><span class="string">    x = L.nil.next   # 初始x指向表头元素</span></span><br><span class="line"><span class="string">    while x != L.nil and x.key != k:</span></span><br><span class="line"><span class="string">        x = x.next</span></span><br><span class="line"><span class="string">    return x</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">LIST-INSERT'</span>(L, X):</span><br><span class="line">    x.next = L.nil.next</span><br><span class="line">    L.nil.next.prev = x</span><br><span class="line">    L.nil.next = x</span><br><span class="line">    x.prev = L.nil</span><br><span class="line"></span><br><span class="line">LIST-DELETE<span class="string">'(L, x):</span></span><br><span class="line"><span class="string">    x.prev.next = x.next</span></span><br><span class="line"><span class="string">    x.next.prev = x.prev</span></span><br></pre></td></tr></table></figure><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.prev = self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>:</span></span><br><span class="line">    <span class="string">"""双向循环链表"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""空链表"""</span></span><br><span class="line">        self.nil, self.size = Element(<span class="literal">None</span>), <span class="number">0</span></span><br><span class="line">        self.nil.prev = self.nil.next = self.nil  <span class="comment"># 哨兵（sentinel）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str([x.key <span class="keyword">for</span> x <span class="keyword">in</span> self])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self.to_list())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_list</span><span class="params">(self)</span>:</span></span><br><span class="line">        x, values = self.head(), []</span><br><span class="line">        <span class="keyword">while</span> x != self.nil:</span><br><span class="line">            values.append(x)</span><br><span class="line">            x = x.next</span><br><span class="line">        <span class="keyword">return</span> values</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""删除元素x"""</span></span><br><span class="line">        x.prev.next, x.next.prev = x.next, x.prev</span><br><span class="line">        self.size -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        <span class="string">"""查找键值为k的元素"""</span></span><br><span class="line">        x = self.head()</span><br><span class="line">        <span class="keyword">while</span> x != self.nil <span class="keyword">and</span> x.key != k:  <span class="comment"># 找不到时x重新指向nil</span></span><br><span class="line">            x = x.next</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""插入元素x，x作为新的表头"""</span></span><br><span class="line">        x.next, self.head().prev = self.head(), x  <span class="comment"># 链接x与第1个元素</span></span><br><span class="line">        self.nil.next, x.prev = x, self.nil  <span class="comment"># 链接哨兵与x</span></span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">head</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回表头元素"""</span></span><br><span class="line">        <span class="keyword">return</span> self.nil.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tail</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回表尾元素"""</span></span><br><span class="line">        <span class="keyword">return</span> self.nil.prev</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(y, z)</span>:</span></span><br><span class="line">    <span class="string">"""合并链表y和z为一个新的链表，y和z会被销毁"""</span></span><br><span class="line">    x = LinkedList()</span><br><span class="line">    x.nil.next, y.head().prev = y.head(), x.nil  <span class="comment"># 链接x.nil与y的头部</span></span><br><span class="line">    x.nil.prev, z.tail().next = z.tail(), x.nil  <span class="comment"># 链接x.nil与z的尾部</span></span><br><span class="line">    y.tail().next, z.head().prev = z.head(), y.tail()  <span class="comment"># 链接y的尾部与z的头部</span></span><br><span class="line">    y = z = <span class="literal">None</span>  <span class="comment"># 销毁y和z</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    l = LinkedList()</span><br><span class="line">    l.insert(Element(<span class="number">1</span>))</span><br><span class="line">    l.insert(Element(<span class="number">2</span>))</span><br><span class="line">    l.insert(Element(<span class="number">3</span>))</span><br><span class="line">    l.insert(Element(<span class="number">4</span>))</span><br><span class="line">    l.insert(Element(<span class="number">5</span>))</span><br><span class="line">    l.insert(Element(<span class="number">6</span>))</span><br><span class="line">    print(l)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[6, 5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction To Algorithms </tag>
            
            <tag> data structures </tag>
            
            <tag> list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MathJax快速参考</title>
      <link href="/documentation/mathjax-quick-reference/"/>
      <url>/documentation/mathjax-quick-reference/</url>
      
        <content type="html"><![CDATA[<h1 id="希腊字母">希腊字母</h1><table><thead><tr class="header"><th>Notation</th><th>Commands</th><th>Notation</th><th>Commands</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\alpha\)</span></td><td><code>\alpha</code></td><td><span class="math inline">\(\beta\)</span></td><td><code>\beta</code></td></tr><tr class="even"><td><span class="math inline">\(\gamma\)</span> <span class="math inline">\(\Gamma\)</span></td><td><code>\gamma \Gamma</code></td><td><span class="math inline">\(\delta\)</span> <span class="math inline">\(\Delta\)</span></td><td><code>\delta \Delta</code></td></tr><tr class="odd"><td><span class="math inline">\(\varepsilon\)</span></td><td><code>\varepsilon</code></td><td><span class="math inline">\(\epsilon\)</span></td><td><code>\epsilon</code></td></tr><tr class="even"><td><span class="math inline">\(\zeta\)</span></td><td><code>\zeta</code></td><td><span class="math inline">\(\eta\)</span></td><td><code>\eta</code></td></tr><tr class="odd"><td><span class="math inline">\(\theta\)</span> <span class="math inline">\(\Theta\)</span></td><td><code>\theta \Theta</code></td><td><span class="math inline">\(\vartheta\)</span></td><td><code>\vartheta</code></td></tr><tr class="even"><td><span class="math inline">\(\iota\)</span></td><td><code>\iota</code></td><td><span class="math inline">\(\kappa\)</span></td><td><code>\kappa</code></td></tr><tr class="odd"><td><span class="math inline">\(\lambda\)</span> <span class="math inline">\(\Lambda\)</span></td><td><code>\lambda \Lambda</code></td><td><span class="math inline">\(\mu\)</span></td><td><code>\mu</code></td></tr><tr class="even"><td><span class="math inline">\(\nu\)</span></td><td><code>\nu</code></td><td><span class="math inline">\(\xi\)</span> <span class="math inline">\(\Xi\)</span></td><td><code>\xi \Xi</code></td></tr><tr class="odd"><td><span class="math inline">\(\omicron\)</span></td><td><code>\omicron</code></td><td><span class="math inline">\(\pi\)</span> <span class="math inline">\(\Pi\)</span></td><td><code>\pi \Pi</code></td></tr><tr class="even"><td><span class="math inline">\(\varpi\)</span></td><td><code>\varpi</code></td><td><span class="math inline">\(\rho\)</span></td><td><code>\rho</code></td></tr><tr class="odd"><td><span class="math inline">\(\varrho\)</span></td><td><code>\varrho</code></td><td><span class="math inline">\(\sigma\)</span> <span class="math inline">\(\Sigma\)</span></td><td><code>\sigma \Sigma</code></td></tr><tr class="even"><td><span class="math inline">\(\varsigma\)</span></td><td><code>\varsigma</code></td><td><span class="math inline">\(\tau\)</span></td><td><code>\tau</code></td></tr><tr class="odd"><td><span class="math inline">\(\upsilon\)</span> <span class="math inline">\(\Upsilon\)</span></td><td><code>\upsilon \Upsilon</code></td><td><span class="math inline">\(\varphi\)</span></td><td><code>\varphi</code></td></tr><tr class="even"><td><span class="math inline">\(\phi\)</span> <span class="math inline">\(\Phi\)</span></td><td><code>\phi \Phi</code></td><td><span class="math inline">\(\chi\)</span></td><td><code>\chi</code></td></tr><tr class="odd"><td><span class="math inline">\(\psi\)</span> <span class="math inline">\(\Psi\)</span></td><td><code>\psi \Psi</code></td><td><span class="math inline">\(\omega\)</span> <span class="math inline">\(\Omega\)</span></td><td><code>\omega \Omega</code></td></tr></tbody></table><a id="more"></a><h1 id="括号">括号</h1><table><colgroup><col style="width: 16%"><col style="width: 33%"><col style="width: 16%"><col style="width: 33%"></colgroup><thead><tr class="header"><th>Notation</th><th>Commands</th><th>Notation</th><th>Commands</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\lbrace\)</span> <span class="math inline">\(\rbrace\)</span></td><td><code>\lbrace \rbrace</code></td><td><span class="math inline">\(\mid\)</span></td><td><code>| or \mid</code></td></tr><tr class="even"><td><span class="math inline">\(\Vert\)</span></td><td><code>\Vert</code></td><td><span class="math inline">\(\langle\)</span> <span class="math inline">\(\rangle\)</span></td><td><code>\langle \rangle</code></td></tr><tr class="odd"><td><span class="math inline">\(\lceil\)</span> <span class="math inline">\(\rceil\)</span> <span class="math inline">\(\lfloor\)</span> <span class="math inline">\(\rfloor\)</span></td><td><code>\lceil \rceil</code> <code>\lfloor \rfloor</code></td><td><span class="math inline">\(\Bigg(\bigg(\big((x)\big)\Big)\Bigg)\)</span></td><td><code>\Bigg(\bigg(\big((x)\big)\Big)\Bigg)</code></td></tr></tbody></table><h1 id="特殊角标">特殊角标</h1><table><thead><tr class="header"><th>Notation</th><th>Commands</th><th>Notation</th><th>Commands</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\hat{a}\)</span></td><td><code>\hat{a}</code></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mathjax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斐波那契堆</title>
      <link href="/notes/introduction-to-algorithms/fibonacci-heaps/"/>
      <url>/notes/introduction-to-algorithms/fibonacci-heaps/</url>
      
        <content type="html"><![CDATA[<h1 id="斐波那契堆">斐波那契堆</h1><p>斐波那契堆数据结构有两种用途：</p><ul><li>它支持一些列操作，这些操作构成了所谓的“可合并堆”。</li><li>斐波那契堆的一些操作（INSERT/UNION/DECREASE-KEY）可以在常数摊还时间内完成，非常适用于需要频繁使用这些操作的应用。</li></ul><table><thead><tr class="header"><th>操作</th><th>二项堆（最坏情形）</th><th>斐波那契堆（摊还）</th></tr></thead><tbody><tr class="odd"><td>MAKE-HEAP()：创建空堆</td><td><span class="math inline">\(\Theta(1)\)</span></td><td><span class="math inline">\(\Theta(1)\)</span></td></tr><tr class="even"><td>INSERT(H, x)：插入元素x</td><td><span class="math inline">\(\Theta(\lg{n})\)</span></td><td><span class="math inline">\(\Theta(1)\)</span></td></tr><tr class="odd"><td>MINIMUM()：提取最小元素</td><td><span class="math inline">\(\Theta(1)\)</span></td><td><span class="math inline">\(\Theta(1)\)</span></td></tr><tr class="even"><td>EXTRACT-MIN()：删除并返回最小元素</td><td><span class="math inline">\(\Theta(\lg{n})\)</span></td><td><span class="math inline">\(O(\lg{n})\)</span></td></tr><tr class="odd"><td>UNION(H1, H2)：创建一个包含H1和H2中所有元素的新堆</td><td><span class="math inline">\(\Theta(n)\)</span></td><td><span class="math inline">\(\Theta(1)\)</span></td></tr><tr class="even"><td>DECREASE-KEY(H, x, k)：将元素x的关键字赋予新值k</td><td><span class="math inline">\(\Theta(\lg{n})\)</span></td><td><span class="math inline">\(\Theta(1)\)</span></td></tr><tr class="odd"><td>DELETE(H, x)：删除元素x</td><td><span class="math inline">\(\Theta(\lg{n})\)</span></td><td><span class="math inline">\(O(\lg{n})\)</span></td></tr></tbody></table><ul><li>从理论上看，当EXTRACT-MIN和DELETE数目相比于其他操作小得多的时候，斐波那契堆尤为合适。例如，一些图问题算法可能每条边调用一次DECREASE-KEY。对于有很多边的稠密图，每次调用DECREASE-KEY需要<span class="math inline">\(\Theta(1)\)</span>摊还时间，相比起二叉堆最坏情况时间<span class="math inline">\(\Theta(\lg{n})\)</span>，其积累起来是个很大的改进。如最小生成树和寻找单源最短路径的快速算法必不可少地要用到斐波那契堆。</li><li>从实际上看，除了某些需要管理大量数据的应用外，对于大多数应用，斐波那契堆的常数因子和编程复杂性使得它比起普通二项（或k项）堆并不那么适用。因此对斐波那契堆的研究主要出于理论研究。</li></ul><a id="more"></a><h1 id="结构">结构</h1><p>一个斐波那契堆（Fibonacci heap）一系列具有最小堆序（min-heap ordered）的有根树的集合。也就是说，每棵树均遵守最小堆性质（min-heap property）：每个结点的关键字大于或等于它的父结点的关键字。</p><p>斐波那契堆的每个结点x包含：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    int     key      <span class="comment"># 值</span></span><br><span class="line">    int     degree   <span class="comment"># 度，孩子数目</span></span><br><span class="line">    Node    left     <span class="comment"># 左兄弟</span></span><br><span class="line">    Node    right    <span class="comment"># 右兄弟</span></span><br><span class="line">    Node    p        <span class="comment"># 父节点</span></span><br><span class="line">    Node    child    <span class="comment"># 任意一个孩子</span></span><br><span class="line">    bool    marked   <span class="comment"># 是否第一次被删除某个孩子</span></span><br></pre></td></tr></table></figure><p>x的所有孩子被链接成一个环形的双向链表（如下图(b)所示，通常情况下省略了指针，将图画成(a)的样子，因为很容易从(a)中推断出指针指向），称为x的孩子链表（child list）。</p><p>斐波那契堆H包含：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FiboHeap</span>:</span></span><br><span class="line">    Node        min        <span class="comment"># 堆中最小结点（minimum node）</span></span><br><span class="line">    LinkedList  root_list  <span class="comment"># 包含所有根结点的双向环形链表</span></span><br><span class="line">    int         n          <span class="comment"># 堆中所有结点数目</span></span><br></pre></td></tr></table></figure><p><img data-src="/uploads/posts/introduction-to-algorithms/fibonacci-heap.png" title="斐波那契堆"></p><h1 id="可合并堆">可合并堆</h1><h2 id="创建一个新的斐波那契堆">创建一个新的斐波那契堆</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MAKE-FIB-HEAP():</span><br><span class="line">    H = FiboHeap()</span><br><span class="line">    H.n         = <span class="number">0</span>                 <span class="comment"># 结点数目为0</span></span><br><span class="line">    H.min       = NIL               <span class="comment"># 最小结点为NIL</span></span><br><span class="line">    H.root_list = new LinkedList()  <span class="comment"># 根链表初始为空</span></span><br><span class="line">    <span class="keyword">return</span> H</span><br></pre></td></tr></table></figure><h2 id="插入一个结点">插入一个结点</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FIB-HEAP-INSERT(H, x):</span><br><span class="line">    x.degree    = <span class="number">0</span>                        <span class="comment"># 初始化x的属性</span></span><br><span class="line">    x.p         = NIL</span><br><span class="line">    x.child     = NIL</span><br><span class="line">    x.mark      = <span class="literal">False</span></span><br><span class="line">    H.root_list.insert(x)                  <span class="comment"># 将x插入H的根链表</span></span><br><span class="line">    <span class="keyword">if</span> H.min == NIL <span class="keyword">or</span> x.key &lt; H.min.key:  <span class="comment"># 更新H.min</span></span><br><span class="line">        H.min = x</span><br><span class="line">    H.n = H.n + <span class="number">1</span>                          <span class="comment"># 更新结点数目</span></span><br></pre></td></tr></table></figure><p>在一个斐波那契堆中插入键值为21的结点：</p><p><img data-src="/uploads/posts/introduction-to-algorithms/fib-heap-insert.png" title="插入"></p><p>图中插入位置为H.min的前驱，实际的插入位置没有影响。</p><h2 id="两个斐波那契堆的合并">两个斐波那契堆的合并</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FIB-HEAP-UNION(H1, H2):</span><br><span class="line">    H = MAKE-FIB-HEAP()</span><br><span class="line">    H.root_list = concatenate(H1.root_list, H2.root_list) <span class="comment"># 合并根链表</span></span><br><span class="line">    H.min = H1.min      <span class="comment"># 判断合并后堆的最小结点</span></span><br><span class="line">    <span class="keyword">if</span> H1.min == NIL <span class="keyword">or</span> (H2.min != NIL <span class="keyword">and</span> H2.min.key &lt; H1.min.key):</span><br><span class="line">        H.min = H2.min</span><br><span class="line">    H.n = H1.n + H2.n   <span class="comment"># 更新结点数目</span></span><br><span class="line">    <span class="keyword">return</span> H</span><br></pre></td></tr></table></figure><h2 id="抽取最小结点">抽取最小结点</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FIB-HEAP-EXTRACT-MIN(H):</span><br><span class="line">    z = H.min</span><br><span class="line">    <span class="keyword">if</span> z != NIL:</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> z.child:           <span class="comment"># 将min的所有孩子结点移动到根链表</span></span><br><span class="line">            H.root_list.insert(x)   <span class="comment"># 更新left和right</span></span><br><span class="line">            x.p = NIL               <span class="comment"># 更新父节点，不更新child意味着孩子结点x的孩子结点不变</span></span><br><span class="line">        H.root_list.delete(z)       <span class="comment"># 删除最小结点min</span></span><br><span class="line">        H.min = NIL</span><br><span class="line">        CONSOLIDATE(H)              <span class="comment"># 子过程</span></span><br><span class="line">        H.n = H.n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> z</span><br></pre></td></tr></table></figure><p>其中子过程CONSOLIDATE(H)用来把具有相同度数的根节点合并（consolidating），直到每个度数至多只有一个根。该过程使用一个辅助数组<code>A[0...D(H.n)]</code>来记录根节点对用的度数的轨迹，其中D(H.n)表示一个n个结点的斐波那契堆中任何结点的最大度数上界（<span class="math inline">\(D(n)=O(\lg{n})\)</span>）。如果A[i]=y，那么当前的y是一个具有y.degree=i的根。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">CONSOLIDATE(H):</span><br><span class="line">    let A[<span class="number">0.</span>.D(H.n)] be a new array</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to D(H.n):  <span class="comment"># 初始化A</span></span><br><span class="line">        A[i] = NIL</span><br><span class="line">    <span class="keyword">for</span> each node w <span class="keyword">in</span> the root list of H:</span><br><span class="line">        x = w</span><br><span class="line">        d = x.degree</span><br><span class="line">        <span class="keyword">while</span> A[d] != NIL:</span><br><span class="line">            y = A[d]      <span class="comment"># 另一个具有相同度数d的结点y</span></span><br><span class="line">            <span class="keyword">if</span> x.key &gt; y.key:</span><br><span class="line">                exchange x <span class="keyword">with</span> y   <span class="comment"># 始终保证x.key &lt; y.key</span></span><br><span class="line">            FIB-HEAP-LINK(H, y, x)  <span class="comment"># 子过程：将y链接为x的孩子结点</span></span><br><span class="line">            A[d] = NIL              <span class="comment"># 合并后具有度数d的结点不存在了</span></span><br><span class="line">            d = d + <span class="number">1</span>               <span class="comment"># 合并后x的度数，通过while循环再次寻找具有相同度数的结点y</span></span><br><span class="line">        A[d] = x                    <span class="comment"># 不存在相同度数d的y，记录x的度数信息</span></span><br><span class="line">        <span class="keyword">if</span> H.min == NIL <span class="keyword">or</span> x.key &lt; H.min.key:  <span class="comment"># 更新min结点</span></span><br><span class="line">            H.min = x</span><br><span class="line"></span><br><span class="line">FIB-HEAP-LINK(H, y, x):</span><br><span class="line">    H.root_list.delete(y)    <span class="comment"># 从H的根链表中移除y</span></span><br><span class="line">    x.child.insert(y)        <span class="comment"># 将y添加到x的孩子结点中</span></span><br><span class="line">    x.degree = x.degree + <span class="number">1</span>  <span class="comment"># 更新x的度</span></span><br><span class="line">    y.mark = <span class="literal">False</span>           <span class="comment"># 清除y上的标记</span></span><br></pre></td></tr></table></figure><p><img data-src="/uploads/posts/introduction-to-algorithms/fib-heap-extract-min.png" title="提取最小的元素"></p><ul><li><span class="math inline">\((a)\)</span> 从当前的斐波那契堆中提取最小结点H.min。以后把“键值为x的结点”省略称为“结点x“。</li><li><span class="math inline">\((a)\rightarrow(b)\)</span> 将结点3的所有子节点移动到根链表。H.min指针右移一位。此时不一定指向最小元素，在后续操作中会调整。</li><li><span class="math inline">\((b)\rightarrow(c)\)</span> 创建一个辅助数组A，遍历根链表。当前结点的度数为1，A[1]为空，将A[1]指向当前结点。继续下一位。</li><li><span class="math inline">\((d)\rightarrow(e)\)</span> 过程类似。结果是A[2]指向度数为2的结点24；A[0]指向度数为0的结点23。</li><li><span class="math inline">\((e)\rightarrow(f)\)</span> 结点7的度数为0，但A[0]不为空，将结点7与A[0]指向的结点23合并：键值较大的结点23移动到结点7的子节点链表中。移动后，清除A[0]。</li><li><span class="math inline">\((f)\rightarrow(g)\)</span> 结点7的度数为1，A[1]不为空且指向结点17。于是将结点17移动到结点7的子结点链表中。清除A[1]。</li><li><span class="math inline">\((g)\rightarrow(h)\)</span> 结点7的度数为2，A[2]不为空且指向24。合并结点7与结点24。清除A[2]。此时结点7的度数为3，而A[3]为空，令A[3]指向结点结点7。继续下一个结点。</li><li><span class="math inline">\((i)\rightarrow(j)\)</span> A[0]指向结点21；A[1]指向结点18。</li><li><span class="math inline">\((j)\rightarrow(k)\)</span> 结点52度数为0，A[0]不为空且指向21。合并结点21与结点52。清除A[0]；合并后结点21的度数为1，A[1]指向结点18。合并结点21与结点18。清除A[1]；合并后结点18度数为2，A[2]为空，令A[2]指向结点18。继续下一结点。</li><li><span class="math inline">\((k)\rightarrow(l)\)</span> 结点38的度数为1，A[1]为空。令A[1]指向结点38。继续下一节点。</li><li><span class="math inline">\((m)\)</span> 所有结点遍历完毕。更新H.min。</li></ul><h1 id="减值和删除">减值和删除</h1><h2 id="关键字减值">关键字减值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">FIB-HEAP-DECREASE-KEY(H, x, k):</span><br><span class="line">    <span class="keyword">if</span> k &gt; x.key:</span><br><span class="line">        error <span class="string">"new key is greater than current key"</span></span><br><span class="line">    x.key = k</span><br><span class="line">    y = x.p</span><br><span class="line">    <span class="keyword">if</span> y != NIL <span class="keyword">and</span> x.key &lt; y.key:  <span class="comment"># 如果更新后x的值小于父节点的值，调整堆</span></span><br><span class="line">        CUT(H, x, y)                <span class="comment"># 子过程：切断x与其父节点y之间的链接</span></span><br><span class="line">        CASCADING-CUT(H, y)         <span class="comment"># 子过程：级联切断</span></span><br><span class="line">    <span class="keyword">if</span> x.key &lt; H.min.key:           <span class="comment"># 更新min结点</span></span><br><span class="line">        H.min = x</span><br><span class="line"></span><br><span class="line">CUT(H, x, y):                <span class="comment"># 切断x与其父节点y之间的链接，并将x添加到根链表</span></span><br><span class="line">    y.child.delete(x)        <span class="comment"># remove x from the child list of y</span></span><br><span class="line">    y.degree = y.degree - <span class="number">1</span>  <span class="comment"># decrementint y.degree</span></span><br><span class="line">    H.root_list.insert(x)    <span class="comment"># add x to the root list of H</span></span><br><span class="line">    x.p = NIL</span><br><span class="line">    x.mark = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">CASCADING-CUT(H, y):            <span class="comment"># 级联切断</span></span><br><span class="line">    z = y.p</span><br><span class="line">    <span class="keyword">if</span> z != NIL:</span><br><span class="line">        <span class="keyword">if</span> y.mark == <span class="literal">False</span>:     <span class="comment"># 如果mark为false，那么上次CUT中，是结点y第一次失去孩子</span></span><br><span class="line">            y.mark == <span class="literal">True</span>      <span class="comment"># 第一次失去孩子，mark置为True</span></span><br><span class="line">        <span class="keyword">else</span>:                   <span class="comment"># 如果mark为True，那么上次CUT之前，y已经失去过孩子</span></span><br><span class="line">            CUT(H, y, z)</span><br><span class="line">            CASCADING-CUT(H, Z) <span class="comment"># 向上递归，直到遇到根节点或者一个未被标记的结点（mark=False）</span></span><br></pre></td></tr></table></figure><p><img data-src="/uploads/posts/introduction-to-algorithms/fib-heap-decrease-key.png" title="减小元素的值"></p><ul><li><span class="math inline">\((a)\)</span> 初始斐波那契堆。将结点46的键值降低为15。</li><li><p><span class="math inline">\((a)\rightarrow(b)\)</span> 修改键值。将修改后的结点15移动到根链表（切断）。其父节点24，之前未被标记。现在失去了一个孩子，标记它。</p></li><li><p><span class="math inline">\((b)\)</span> 在此斐波那契堆上，将结点35的键值降低为5。</p></li><li><span class="math inline">\((b)\rightarrow(c)\)</span> 修改键值，将修改后的结点5移动到根链表（切断）。</li><li><span class="math inline">\((c)\rightarrow(d)\)</span> 结点5的原来的父节点26是被标记的，触发级联切断的条件：切断结点26与其父节点，将结点26移动到根链表，清除其标记。之后对结点26的原来的父节点24递归地调用级联切断过程。</li><li><span class="math inline">\((d)\rightarrow(e)\)</span> 结点24同样是被标记的，切断结点24与其父节点7。最后对结点24的原来的父节点7递归地调用级联切断。</li><li><p>结点7没有父节点，级联切断不处理此类结点。</p></li></ul><h2 id="删除一个结点">删除一个结点</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FIB-HEAP-DELETE(H, x):</span><br><span class="line">    FIB-HEAP-DECREASE-KEY(H, x, -infinty)</span><br><span class="line">    FIB-HEAP-EXTRACT-MIN(H)</span><br></pre></td></tr></table></figure><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> data_structure.linked_list <span class="keyword">import</span> Element, LinkedList, union <span class="keyword">as</span> union_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(Element)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        Element.__init__(self, k)</span><br><span class="line">        self.degree, self.mark = <span class="number">0</span>, <span class="literal">False</span>  <span class="comment"># mark：第1次失去孩子后为True、第2次后为False</span></span><br><span class="line">        self.p = self.child = self.prev = self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.value())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">value</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.child <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> len(self.child) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.key</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;self.key: [c.value() <span class="keyword">for</span> c <span class="keyword">in</span> self.child]&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FibHeap</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.n, self.min = <span class="number">0</span>, <span class="literal">None</span>  <span class="comment"># 堆中结点数目, 堆中最小结点</span></span><br><span class="line">        self.root_list = LinkedList()  <span class="comment"># 根链表</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        s = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self.root_list:</span><br><span class="line">            s.append(str(x))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">', '</span>.join(s)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x.degree, x.mark = <span class="number">0</span>, <span class="literal">False</span></span><br><span class="line">        x.p = x.child = <span class="literal">None</span></span><br><span class="line">        self.root_list.insert(x)  <span class="comment"># 插入根链表</span></span><br><span class="line">        <span class="keyword">if</span> self.min <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> x.key &lt; self.min.key:</span><br><span class="line">            self.min = x</span><br><span class="line">        self.n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        z = self.min</span><br><span class="line">        <span class="keyword">if</span> z <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> z.child <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment"># 将所有子节点插入到根链表</span></span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> z.child:</span><br><span class="line">                    self.root_list.insert(x)</span><br><span class="line">                    x.p = <span class="literal">None</span></span><br><span class="line">            self.min = <span class="literal">None</span></span><br><span class="line">            self.root_list.delete(z)  <span class="comment"># 从根链表中移除</span></span><br><span class="line">            self.consolidate()  <span class="comment"># 合并度数相同的结点</span></span><br><span class="line">            self.n -= <span class="number">1</span>  <span class="comment"># 总结点数目减1</span></span><br><span class="line">            z.child = <span class="literal">None</span>  <span class="comment"># 清除指针，不清除对斐波那契堆也没什么影响</span></span><br><span class="line">        <span class="keyword">return</span> z</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">consolidate</span><span class="params">(self)</span>:</span></span><br><span class="line">        degree = &#123;&#125;  <span class="comment"># degree[i]=y，那么y.degree=i</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self.root_list:  <span class="comment"># 在link()中可能被删除的元素已经访问过，因此可以使用迭代器</span></span><br><span class="line">            d = x.degree</span><br><span class="line">            <span class="keyword">while</span> d <span class="keyword">in</span> degree:</span><br><span class="line">                y = degree.pop(d)  <span class="comment"># another node with the same degree as x</span></span><br><span class="line">                <span class="keyword">if</span> x.key &gt; y.key:</span><br><span class="line">                    x, y = y, x</span><br><span class="line">                self.link(y, x)</span><br><span class="line">                d = d + <span class="number">1</span></span><br><span class="line">            degree[d] = x</span><br><span class="line">            <span class="keyword">if</span> self.min <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> self.min.key &gt; x.key:</span><br><span class="line">                self.min = x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">link</span><span class="params">(self, y, x)</span>:</span></span><br><span class="line">        self.root_list.delete(y)</span><br><span class="line">        y.p = x</span><br><span class="line">        <span class="keyword">if</span> x.child <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            x.child = LinkedList()</span><br><span class="line">        x.child.insert(y)</span><br><span class="line">        x.degree += <span class="number">1</span></span><br><span class="line">        y.mark = <span class="literal">False</span>  <span class="comment"># y成为孩子结点时，mark置为False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decrease_key</span><span class="params">(self, x, k)</span>:</span> <span class="comment"># 没有对结点x是否在堆中进行判断，heap.min可能会指向堆外结点</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; x.key:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'new key is greater than current key'</span>)</span><br><span class="line">        x.key, y = k, x.p</span><br><span class="line">        <span class="keyword">if</span> y <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> x.key &lt; y.key:  <span class="comment"># 当更新后的值小于父节点时调整堆</span></span><br><span class="line">            self.cut(x, y)  <span class="comment"># 切断x与y</span></span><br><span class="line">            self.cascading_cut(y)</span><br><span class="line">        <span class="keyword">if</span> x.key &lt; self.min.key:</span><br><span class="line">            self.min = x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cut</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        y.child.delete(x)  <span class="comment"># 分离x与其父节点y</span></span><br><span class="line">        self.root_list.insert(x)  <span class="comment"># 使x成为根节点</span></span><br><span class="line">        y.degree -= <span class="number">1</span></span><br><span class="line">        x.p, x.mark = <span class="literal">None</span>, <span class="literal">False</span>  <span class="comment"># x成为根结点时，mark置为False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cascading_cut</span><span class="params">(self, y)</span>:</span></span><br><span class="line">        z = y.p</span><br><span class="line">        <span class="keyword">if</span> z <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> y.mark <span class="keyword">is</span> <span class="literal">False</span>:  <span class="comment"># mark=False，是第一次失去孩子</span></span><br><span class="line">                y.mark = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># mark=True,是第二次失去孩子</span></span><br><span class="line">                self.cut(y, z)</span><br><span class="line">                self.cascading_cut(z)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.decrease_key(x, float(<span class="string">'-inf'</span>))</span><br><span class="line">        self.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(h1, h2)</span>:</span></span><br><span class="line">    h = FibHeap()  <span class="comment"># 初始化新堆</span></span><br><span class="line">    h.root_list = union_list(h1.root_list, h2.root_list)  <span class="comment"># 合并根链表，h1和h2的根链表会被销毁</span></span><br><span class="line">    h.min = h1.min  <span class="comment"># 比较最小结点</span></span><br><span class="line">    <span class="keyword">if</span> h1.min <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> (h2.min <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> h2.min.key &lt; h1.min.key):</span><br><span class="line">        h.min = h2.min</span><br><span class="line">    h.n = h1.n + h2.n  <span class="comment"># 结点数目相加</span></span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    h1, h2 = FibHeap(), FibHeap()</span><br><span class="line">    key1, key2 = [<span class="number">23</span>, <span class="number">7</span>, <span class="number">21</span>, <span class="number">3</span>, <span class="number">17</span>, <span class="number">24</span>, <span class="number">18</span>], [<span class="number">52</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">26</span>, <span class="number">46</span>, <span class="number">39</span>, <span class="number">41</span>, <span class="number">35</span>]</span><br><span class="line">    [h1.insert(Node(i)) <span class="keyword">for</span> i <span class="keyword">in</span> key1]</span><br><span class="line">    [h2.insert(Node(i)) <span class="keyword">for</span> i <span class="keyword">in</span> key2]</span><br><span class="line">    print(<span class="string">'h1:'</span>, h1)</span><br><span class="line">    print(<span class="string">'h2:'</span>, h2)</span><br><span class="line">    h = union(h1, h2)  <span class="comment"># union，合并根链表</span></span><br><span class="line">    print(<span class="string">'h:'</span>, h)</span><br><span class="line">    print(<span class="string">'&#123;0:&lt;3s&#125; &#123;1:&lt;6s&#125;'</span>.format(<span class="string">'pop'</span>, <span class="string">'h'</span>))</span><br><span class="line">    <span class="keyword">while</span> h.n &gt; <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">'&#123;0:&lt;3d&#125; &#123;1:&lt;6s&#125;'</span>.format(h.pop().key, str(h)))</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">h1: 18, 24, 17, 3, 21, 7, 23</span><br><span class="line">h2: 35, 41, 39, 46, 26, 30, 38, 52</span><br><span class="line">h: 18, 24, 17, 3, 21, 7, 23, 35, 41, 39, 46, 26, 30, 38, 52</span><br><span class="line">pop h</span><br><span class="line">3   &#123;7: [&#123;17: [&#123;18: [24]&#125;, 21]&#125;, &#123;35: [41]&#125;, 23]&#125;, &#123;26: [&#123;39: [46]&#125;, 30]&#125;, &#123;38: [52]&#125;</span><br><span class="line">7   23, &#123;35: [&#123;38: [52]&#125;, 41]&#125;, &#123;17: [&#123;26: [&#123;39: [46]&#125;, 30]&#125;, &#123;18: [24]&#125;, 21]&#125;</span><br><span class="line">17  &#123;18: [&#123;26: [&#123;39: [46]&#125;, 30]&#125;, &#123;21: [23]&#125;, 24]&#125;, &#123;35: [&#123;38: [52]&#125;, 41]&#125;</span><br><span class="line">18  24, &#123;21: [23]&#125;, &#123;26: [&#123;35: [&#123;38: [52]&#125;, 41]&#125;, &#123;39: [46]&#125;, 30]&#125;</span><br><span class="line">21  &#123;23: [24]&#125;, &#123;26: [&#123;35: [&#123;38: [52]&#125;, 41]&#125;, &#123;39: [46]&#125;, 30]&#125;</span><br><span class="line">23  24, &#123;26: [&#123;35: [&#123;38: [52]&#125;, 41]&#125;, &#123;39: [46]&#125;, 30]&#125;</span><br><span class="line">24  &#123;26: [&#123;35: [&#123;38: [52]&#125;, 41]&#125;, &#123;39: [46]&#125;, 30]&#125;</span><br><span class="line">26  30, &#123;39: [46]&#125;, &#123;35: [&#123;38: [52]&#125;, 41]&#125;</span><br><span class="line">30  &#123;39: [46]&#125;, &#123;35: [&#123;38: [52]&#125;, 41]&#125;</span><br><span class="line">35  41, &#123;38: [&#123;39: [46]&#125;, 52]&#125;</span><br><span class="line">38  &#123;39: [&#123;41: [52]&#125;, 46]&#125;</span><br><span class="line">39  46, &#123;41: [52]&#125;</span><br><span class="line">41  &#123;46: [52]&#125;</span><br><span class="line">46  52</span><br><span class="line">52</span><br></pre></td></tr></table></figure><h1 id="应用">应用</h1><ul><li>Dijkstra算法</li><li>Prim算法</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction To Algorithms </tag>
            
            <tag> data structures </tag>
            
            <tag> heap </tag>
            
            <tag> fibonacci heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斯特灵近似公式</title>
      <link href="/further-mathematics/stirling-s-approximation/"/>
      <url>/further-mathematics/stirling-s-approximation/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zh.wikipedia.org/wiki/%E6%96%AF%E7%89%B9%E9%9D%88%E5%85%AC%E5%BC%8F" target="_blank" rel="noopener">斯特灵公式</a>（Stirling's approximation or Stirling's formula）是一条用来取n阶乘近似值的数学公式。一般来说，当n很大的时候，n阶乘的计算量十分大，所以斯特灵公式十分好用。而且，即使在n很小的时候，斯特灵公式的取值已经十分准确。</p><p><span class="math display">\[n! \approx \sqrt{2\pi{n}}(\frac{n}{e})^n\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> formula </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/notes/introduction-to-algorithms/quicksort/"/>
      <url>/notes/introduction-to-algorithms/quicksort/</url>
      
        <content type="html"><![CDATA[<h1 id="快速排序">快速排序</h1><p>快速排序（Quicksort）是一种高效的比较型排序算法，于1961年由瑞典科学家<a href="https://en.wikipedia.org/wiki/Tony_Hoare" target="_blank" rel="noopener">Tony Hoare</a>发表。与<a href="/algorithm/Merge-sort">归并排序</a>类似，快速排序也是一种分治算法。快速排序是常用的排序算法，一个好的快速排序的实现，甚至可以比归并排序和堆排序快两到三倍。快速排序不是稳定排序，但它是原址排序。排序n个数的<strong>平均</strong>时间代价是<span class="math inline">\(O(n\log{n})\)</span>。最坏情况下，它的时间代价是<span class="math inline">\(O(n^2)\)</span>，这种情况很少出现。快速排序的示例图（来自<a href="https://en.wikipedia.org/wiki/Quicksort" target="_blank" rel="noopener">维基百科：Quicksort</a>）如下：</p><p><img data-src="/uploads/posts/introduction-to-algorithms/sorting-quicksort-anim.gif" title="快速排序动态过程"></p><a id="more"></a><h1 id="实现">实现</h1><p>快速排序同样遵循分治模式，每层递归是有三个步骤：</p><ul><li>分解（Divide）：数组<code>A[p...r]</code>被划分为两个（可能为空）子数组<code>A[p...q-1]</code>和<code>A[q+1...r]</code>，使得<span class="math inline">\(A[i]\le{A[q]}\le{A[j]}, i\in[p,q-1], j\in[q+1,r]\)</span>。其中，计算下标q也是划分过程的一部分。</li><li>解决（Conquer）：通过递归调用快速排序，对子数组<code>A[p...q-1]</code>和<code>A[q+1...r]</code>进行排序。</li><li>合并（Combine）：快速排序不需要合并操作，数组<code>A[p...r]</code>已经有序。</li></ul><p>与归并排序不同，快速排序的比较过程发生在分解阶段，且快速排序是原址排序，所以快速排序不需要合并操作。</p><p>实现快速排序的过程如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">quicksort(A, p, r):</span><br><span class="line">    <span class="keyword">if</span> p &lt; r:</span><br><span class="line">        q = partition(A, p, r)</span><br><span class="line">        quicksort(A, p, q - <span class="number">1</span>)</span><br><span class="line">        quicksort(A, q + <span class="number">1</span>, r)</span><br></pre></td></tr></table></figure><p>快速排序的关键部分是partition过程，它实现了对子数组<code>A[p...r]</code>的原址排序。</p><h2 id="lomuto划分">Lomuto划分</h2><p>Lomuto划分的效率不高，但它易于理解。它通常选择最后一个元素x=A[r]作为<strong>主元</strong>（pivot），并围绕它来划分子数组<code>A[p...r]</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lomuto_partition(A, p, r):</span><br><span class="line">    x = A[r]</span><br><span class="line">    i = p - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j = p to r - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> A[j] &lt;= x</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">            exchange A[i] <span class="keyword">with</span> A[j]</span><br><span class="line">    exchange A[i+<span class="number">1</span>] <span class="keyword">with</span> A[r]</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>        // q的最终位置</span><br></pre></td></tr></table></figure><p>随着划分过程的进行，数组被划分成4个（可能有空的）区域。分别为小于等于x的部分，大于x的部分，未比较部分，和主元x。将这些性质作为循环不变量：</p><blockquote><p>在循环体的每一轮迭代开始时，对任意数组下标k，有：</p><ol type="1"><li>小于x的部分：若<span class="math inline">\(p\le{k}\le{i}\)</span>，则<span class="math inline">\(A[k]\le{x}\)</span>。</li><li>大于x的部分：若<span class="math inline">\(i+1\le{k}\le{j-1}\)</span>，则<span class="math inline">\(A[k]\ge{x}\)</span>。</li><li>等于x的部分：若k=r，则A[k]=x。</li></ol></blockquote><p>上述坐标之外的区域<code>A[j...r-1]</code>对应为比较部分。Lomuto划分的一个示例如下：</p><p>数组的四个部分分别是 (小于主元的元素) (大于等于主元的元素) (未划分元素) (主元)。</p><table><thead><tr class="header"><th><code>array[p...r]</code></th><th>A[i]</th><th>A[j]</th></tr></thead><tbody><tr class="odd"><td>() () (2871356) (4)</td><td>null（i=p-1）</td><td>2</td></tr><tr class="even"><td>x=array[r]=4</td><td></td><td>2&lt;4，i=i+1; exchange 2 with 2; j=j+1</td></tr><tr class="odd"><td>(2) () (871356) (4)</td><td>2</td><td>8</td></tr><tr class="even"><td></td><td></td><td>8&gt;=4，j=j+1</td></tr><tr class="odd"><td>(2) (8) (71356) (4)</td><td>2</td><td>7</td></tr><tr class="even"><td></td><td></td><td>7&gt;=4，j=j+1</td></tr><tr class="odd"><td>(2) (87) (1356) (4)</td><td>2</td><td>1</td></tr><tr class="even"><td></td><td></td><td>1&lt;4，i=i+1; exchange 8 with 1; j=j+1</td></tr><tr class="odd"><td>(21) (78) (356) (4)</td><td>1</td><td>3</td></tr><tr class="even"><td></td><td></td><td>3&lt;4，i=i+1; exchange 7 with 3; j=j+1</td></tr><tr class="odd"><td>(213) (87) (56) (4)</td><td>3</td><td>5</td></tr><tr class="even"><td></td><td></td><td>5&gt;=4，j=j+1</td></tr><tr class="odd"><td>(213) (875) (6) (4)</td><td>3</td><td>6</td></tr><tr class="even"><td></td><td></td><td>6&gt;=4，j=j+1</td></tr><tr class="odd"><td>(213) (8756) () (4)</td><td>3</td><td>4</td></tr><tr class="even"><td></td><td></td><td>j==r，退出循环，exchange 8 with 4</td></tr><tr class="odd"><td>213 4 7568</td><td>3</td><td>return i+1，是主元位置</td></tr></tbody></table><h2 id="hoare划分">Hoare划分</h2><p>Hoare划分比Lomuto划分更加高效。在选择了主元之后，它使用两个下标i和j，i从前往后、j从后往前移动。当找到<span class="math inline">\(A[i]\ge{x}\)</span>、<span class="math inline">\(A[j]\le{x}\)</span>且i&lt;j的两个坐标i和j之后，交换它们的元素。当i和j相遇（<span class="math inline">\(i\ge{j}\)</span>）后，划分过程停止。平均情况下，Hoare划分比Lomuto划分少3次交换次数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">hoare_partition(A, p, r):</span><br><span class="line">    x = A[r]                           <span class="comment"># 最后一个元素作为主元</span></span><br><span class="line">    i = p</span><br><span class="line">    j = r - <span class="number">1</span>                          <span class="comment"># 最后一位是主元</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">while</span> i &lt; r <span class="keyword">and</span> A[i] &lt;= x:     <span class="comment"># 找到大于主元的元素或i=r（主元的位置）时停止</span></span><br><span class="line">            i = i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= p <span class="keyword">and</span> A[j] &gt;=x:     <span class="comment"># 找到小于主元的元素或j&lt;p（超出了边界）时停止</span></span><br><span class="line">            j = j<span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; j:                      <span class="comment"># i与j相遇，i是主元应处的位置</span></span><br><span class="line">            <span class="keyword">if</span> i != r:</span><br><span class="line">                swap A[i] <span class="keyword">with</span> A[r]</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        swap A[i] <span class="keyword">with</span> A[j]</span><br></pre></td></tr></table></figure><p>Hoare划分的一个示例如下：</p><p>数组的四个部分分别是 (小于等于主元的元素) (未划分元素) (大于等于主元的元素) (主元)。</p><table><thead><tr class="header"><th></th><th><code>array[p...r]</code></th><th>A[i]</th><th>A[j]</th></tr></thead><tbody><tr class="odd"><td>初始</td><td>() (2871356) () (4)</td><td>2</td><td>6</td></tr><tr class="even"><td>寻找下一对交换元素</td><td>主元x=4</td><td>8</td><td>3，交换</td></tr><tr class="odd"><td>继续寻找</td><td>(23) (71) (856) (4)</td><td>7</td><td>1，交换</td></tr><tr class="even"><td>继续寻找</td><td>(231) () (7856) (4)</td><td>7</td><td>1，相遇，交换A[i]与主元，return i</td></tr><tr class="odd"><td></td><td>231 4 8567</td><td>4</td><td>7</td></tr></tbody></table><h2 id="主元的选择">主元的选择</h2><p>不论Lomuto划分还是Hoare划分，主元的选择方式都会直接影响到划分结果。例如上述Hoare划分过程的示例，若选择主元x=1，正好是数组中最小的元素，划分过程很快就结束，并产生了两个长度相差较大的子数组[1]和[2, 8, 7, 2, 3, 5, 6, 4]。同理若正好选择了最大的元素，也会产生类似的结果。称这种划分为不平衡划分（Unbalanced partitioning）。</p><p>在Lomuto划分中，总是选择最右侧元素作为主元。若输入数组是已排序的，排序算法将总是产生不平衡划分，触发最坏情况。幸运的是，可以通过一些策略来优化，使得对任何输入都比较好。例如随机选择，后文将分析随机选择主元的快速排序的期望运行时间为<span class="math inline">\(O(n\log{n})\)</span>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">random(A, left, right):</span><br><span class="line">    select an integer i <span class="keyword">in</span> [left, right] randomly</span><br><span class="line">    <span class="keyword">if</span> i != right:</span><br><span class="line">        swap A[i] <span class="keyword">with</span> A[right]</span><br><span class="line">    <span class="keyword">return</span> A[right]</span><br></pre></td></tr></table></figure><p>还有一种模式：选择左中右元素的中位数（Median-of-three，mo3）。随机选择模式下，快速排序的比较次数的期望是<span class="math inline">\(1.386n\log{n}\)</span>，mo3模式下，期望可下降至<span class="math inline">\(1.188n\log{n}\)</span>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">median_of_three(A, left, right):</span><br><span class="line">    mid = (left + right) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> A[mid] &lt; A[left]:</span><br><span class="line">        swap A[left] <span class="keyword">with</span> A[mid]    <span class="comment"># A[left] &lt;= A[mid]</span></span><br><span class="line">    <span class="keyword">if</span> A[right] &lt; A[left]:</span><br><span class="line">        swap A[left] <span class="keyword">with</span> A[right]  <span class="comment"># A[left] &lt;= A[right]</span></span><br><span class="line">    <span class="keyword">if</span> A[mid] &lt; A[right]:</span><br><span class="line">        swap A[mid] <span class="keyword">with</span> A[right]   <span class="comment"># A[right] &lt;= A[mid]</span></span><br><span class="line">    pivot = A[right]</span><br></pre></td></tr></table></figure><p>通过上述代码，使得<span class="math inline">\(A[mid]\ge{A[right]}\ge{A[left]}\)</span>，此时再选择最右侧元素，实际上是左中右元素的中位数。当输入数组的排序情况未知时，相比总是直接选择左右侧元素，该方法性能更好。对于更长的数组，可以扩展mo3规则至更强的ninther。</p><p><code>ninther(A)=middle(mo3(first 1/3 of A), mo3(middle 1/3 of A), mo3(final 1/3 of A))</code></p><p><strong>注意</strong>：mid = (left + right) / 2可能会发生越界情况（没搞懂），可以用mid = left + (right - left) / 2来代替。</p><h1 id="分析">分析</h1><h2 id="最坏情况">最坏情况</h2><p>以Lomuto划分为例，当划分操作总是得到一个大小为0、另一个大小为n-1的数组时（还有一个元素是主元），假设T(n)是quicksort在输入规模为n的数据集合上所花费的时间，则有递归式：</p><p><span class="math display">\[T(n)=T(0)+T(n-1)+\Theta(n)\]</span></p><p>递归树深度为n，容易得到<span class="math inline">\(T(n)=O(n^2)\)</span>。</p><p>利用代入法证明：</p><p><span class="math display">\[T(n)=\max_{0\le{q}\le{n-1}}(T(q)+T(n-q-1)+\Theta(n))\]</span></p><p>q和n-q-1分别是两个子数组的规模。设<span class="math inline">\(T(n)\le{cn^2}\)</span>成立，将其带入上式 <span class="math display">\[\begin{aligned}T(n)&amp;\le{\max_{0\le{q}\le{n-1}}(cq^2+c(n-q-1)^2)+\Theta(n)}\\&amp;=c\max_{0\le{q}\le{n-1}}(q^2+(n-q-1)^2)+\Theta(n)\end{aligned}\]</span></p><p><span class="math inline">\(q^2+(n-q-1)^2\le(n-1)^2=n^2-2n+1\)</span>（在端点处取得最大值），将其带入上式，得到</p><p><span class="math display">\[T(n)\le{cn^2-c(2n-1)+\Theta(n)}\le{cn^2}\]</span></p><p><span class="math inline">\(\therefore{T(n)=O(n^2)}\)</span>。</p><h2 id="最佳情况">最佳情况</h2><p>若划分操作总是得到两个规模相等的子数组时，触发最佳情况。</p><p><span class="math display">\[T(n)=2T(\frac{n}{2})+\Theta(n)\]</span></p><p>递归树深度为<span class="math inline">\(\log_2{n}\)</span>，可得<span class="math inline">\(T(n)=O(n\log(n))\)</span>。</p><h2 id="平均情况">平均情况</h2><p>对于规模为n的无重复元素的数组，若主元的选择是独立且随机的，则快速排序的期望运行时间为<span class="math inline">\(O(n\log(n))\)</span>。</p><p>证明：</p><p>考虑输入数组的一个随机序列<span class="math inline">\((x_1,x_2,...,x_n)\)</span>，定义C表示比较次数，<span class="math inline">\(c_{ij}\)</span>为指示器随机变量。有</p><p><span class="math display">\[c_{ij}=\begin{cases}1&amp;x_i与x_j发生比较\\0&amp;x_i与x_j不发生比较&amp;&amp;\end{cases}C=\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}c_{i,j}\]</span></p><p>对C取期望，有</p><p><span class="math display">\[E[C]=\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}E(c_{ij})=\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}Pr(c_{ij})\]</span></p><p>在划分操作中，只有主元会与其他元素发生比较，因此</p><p><span class="math display">\[Pr(c_{ij})=Pr(x_i\text{或}x_j\text{被选为主元)}\]</span></p><p>在一次划分中，<span class="math inline">\(x_i\)</span>与<span class="math inline">\(x_j\)</span>不可能同时被选为主元，且主元的选择是独立的，因此</p><p><span class="math display">\[Pr(c_{ij})=2*Pr(x_i被选为主元)=\frac{2}{j-i+1}\]</span></p><p>令<span class="math inline">\(k=j-i\)</span>，代入<span class="math inline">\(E[C]\)</span>得</p><p><span class="math display">\[\begin{aligned}E[C]&amp;=\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}\frac{2}{j-i+1}\\&amp;=\sum_{i=1}^{n-1}\sum_{k=1}^{n-i}\frac{2}{k+1}\\&amp;&lt;\sum_{i=1}^{n-1}\sum_{k=1}^{n}\frac{2}{k}\\&amp;=\sum_{i=1}^{n-1}O(\log{n})\\&amp;=O(n\log{n})\end{aligned}\]</span></p><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(a, i, j)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> i != j:</span><br><span class="line">        a[i], a[j] = a[j], a[i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">median_of_three</span><span class="params">(a, left, right)</span>:</span></span><br><span class="line">    <span class="string">"""选择左中右三元素的中位数作为pivot"""</span></span><br><span class="line">    mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> a[mid] &lt; a[left]:</span><br><span class="line">        exchange(a, left, mid)  <span class="comment"># now: a[left] &lt;= a[mid]</span></span><br><span class="line">    <span class="keyword">if</span> a[right] &lt; a[left]:</span><br><span class="line">        exchange(a, left, right)  <span class="comment"># now: a[left] &lt;= a[right]</span></span><br><span class="line">    <span class="keyword">if</span> a[mid] &lt; a[right]:</span><br><span class="line">        exchange(a, mid, right)  <span class="comment"># now: a[right] &lt;= a[mid]</span></span><br><span class="line">    <span class="comment"># now: a[left&#125; &lt;= a[right] &lt;= a[mid]</span></span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hoare_partition</span><span class="params">(a, left, right)</span>:</span></span><br><span class="line">    <span class="string">"""Hoare's scheme is more efficient than Lomuto's partition scheme</span></span><br><span class="line"><span class="string">    because it does three times fewer swaps on average."""</span></span><br><span class="line">    pivot, i, j = a[right], left, right - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">while</span> i &lt; right <span class="keyword">and</span> a[i] &lt;= pivot:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= left <span class="keyword">and</span> a[j] &gt;= pivot:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; j:  <span class="comment"># i, j 相遇</span></span><br><span class="line">            exchange(a, i, right)</span><br><span class="line">            <span class="keyword">return</span> i  <span class="comment"># pivot位置</span></span><br><span class="line">        exchange(a, i, j)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lomuto_partition</span><span class="params">(a, left, right)</span>:</span></span><br><span class="line">    pivot, i = a[right], left</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(left, right):</span><br><span class="line">        <span class="keyword">if</span> a[j] &lt; pivot:  <span class="comment"># 小于pivot的元素被划分到左边，大于等于pivot的元素被划分到右边</span></span><br><span class="line">            exchange(a, i, j)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    exchange(a, i, right)</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">q_sort</span><span class="params">(a, left, right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; right:</span><br><span class="line">        p_idx = random.randint(left, right)  <span class="comment"># 随机选择pivot</span></span><br><span class="line">        <span class="comment"># p_idx = median_of_three(a, left, right)  # 选择左中右元素的中位数</span></span><br><span class="line">        q = partition(a, left, right, p_idx)</span><br><span class="line">        q_sort(a, left, q - <span class="number">1</span>)</span><br><span class="line">        q_sort(a, q + <span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(a, left, right, p_idx)</span>:</span>  <span class="comment"># 增加参数，p_idx指示所用主元在数组中的位置</span></span><br><span class="line">    <span class="keyword">if</span> p_idx &lt; left <span class="keyword">or</span> p_idx &gt; right:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">"主元位置越界"</span>)</span><br><span class="line">    exchange(a, p_idx, right)</span><br><span class="line">    <span class="keyword">return</span> hoare_partition(a, left, right)</span><br><span class="line">    <span class="comment"># return lomuto_partition(a, left, right)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="string">"""排序整个列表"""</span></span><br><span class="line">    q_sort(a, <span class="number">0</span>, len(a) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">16</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">11</span>, <span class="number">15</span>]</span><br><span class="line">    quick_sort(arr)</span><br><span class="line">    print(arr)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction To Algorithms </tag>
            
            <tag> divide-and-conquer </tag>
            
            <tag> sort </tag>
            
            <tag> algorithms </tag>
            
            <tag> comparison sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/notes/introduction-to-algorithms/merge-sort/"/>
      <url>/notes/introduction-to-algorithms/merge-sort/</url>
      
        <content type="html"><![CDATA[<h1 id="归并排序">归并排序</h1><p>归并排序（Merge sort）是一种比较高效的比较型排序算法，由<a href="https://en.wikipedia.org/wiki/John_von_Neumann" target="_blank" rel="noopener">John von Neumann</a>于1945年提出。归并排序算法是运用分治策略（Divide-and-conquer）的典型算法，它有许多中不同的实现，且大多数实现是稳定排序。归并排序的示意图（出自<a href="https://en.wikipedia.org/wiki/Merge_sort#Top-down_implementation_using_lists" target="_blank" rel="noopener">维基百科：Merge sort</a>）如下：</p><p><img data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/cc/Merge-sort-example-300px.gif/220px-Merge-sort-example-300px.gif" title="归并排序动态示意图"></p><a id="more"></a><h1 id="实现">实现</h1><p>归并排序在每层递归时有三个步骤（遵循分治模式）：</p><ul><li><p>分解（Divide）：分解待排序的n个元素的序列成各局n/2个元素的两个子序列。</p></li><li><p>解决（Conquer）：使用归并排序递归地排序两个子序列。</p></li><li><p>合并（Combine）：合并两个已排序的子序列以产生已排序的答案。</p></li></ul><h2 id="合并">合并</h2><p>合并过程是归并排序的关键操作。通过调用一个辅助过程merge(A, p, q, r)来完成，其中A是一个数组，p、q和r是数组下标，满足<span class="math inline">\(p\le{q}&lt;r\)</span>。假设子数组<code>A[p...q]</code>和<code>A[q+1...r]</code>都已经排好序。该过程合并这两个子数组形成单一的已排好序的数组来代替当前的数组<code>A[p...r]</code>。</p><p>合并时需要注意要时刻判断两个子数组是否为空，当某个子数组为空时，则无需比较，只需要将另一个子数组中的元素取出即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">merge(A, p, q, r):</span><br><span class="line">    创建新数组B[<span class="number">0.</span>.r-p]</span><br><span class="line">    将A[p..r]复制到B[<span class="number">0.</span>.r-p]</span><br><span class="line">    i = p</span><br><span class="line">    j = q</span><br><span class="line">    <span class="keyword">for</span> k = p to r:</span><br><span class="line">        <span class="keyword">if</span> i &lt; q <span class="keyword">and</span> (j &gt;= r <span class="keyword">or</span> B[i] &lt;= B[j]):  <span class="comment"># 用 i &lt; q 和 j &gt;=r 时刻判断非空</span></span><br><span class="line">            A[k] = B[i]</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            A[k] = B[j]</span><br><span class="line">            j = j + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>为了避免每次检查非空以简化代码，可以通过在子数组末尾放置一个哨兵（sentinel）元素。使用<span class="math inline">\(\infty\)</span>作为哨兵元素的值。当有效数组元素为空时，哨兵元素显露出来，它不可能小于其他非哨兵元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">merge(A, p, q, r):</span><br><span class="line">    <span class="comment"># --------准备工作-------------</span></span><br><span class="line">    创建两个新数组L[<span class="number">0.</span>.p-q+<span class="number">1</span>]和R[<span class="number">0.</span>.r-q]</span><br><span class="line">    将A[p..q]复制到L[<span class="number">0.</span>.p-q]</span><br><span class="line">    将B[q+<span class="number">1.</span>.r]复制到R[<span class="number">0.</span>.r-q<span class="number">-1</span>]</span><br><span class="line">    L[p-q+<span class="number">1</span>] = inf</span><br><span class="line">    R[r-q] = inf</span><br><span class="line">    <span class="comment"># -----------end--------------------</span></span><br><span class="line">    <span class="comment"># ---------比较------------</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k = p to r:</span><br><span class="line">        <span class="keyword">if</span> L[i] &lt; R[j]:</span><br><span class="line">            A[k] = L[i]</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            A[k] = R[j]</span><br><span class="line">            j = j + <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="自顶向下的实现">自顶向下的实现</h2><p>自顶向下的归并排序递归地将序列分解成子序列，直到子序列只有1个元素。当待排序的序列长度为1时，递归“开始回升”，此时无需合并，因为长度为1的每个序列是已排序的。之后合并这些子序列生成已排序的序列。上述示意图描述的就是自顶向下的归并排序算法的排序过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">merge_sort_top_down(A, p, r):</span><br><span class="line">    <span class="keyword">if</span> p &lt; r:    <span class="comment"># 当元素个数大于1时</span></span><br><span class="line">        q = (p + q) / <span class="number">2</span></span><br><span class="line">        merge_sort_top_down(A, p, q)</span><br><span class="line">        merge_sort_top_down(A, q + <span class="number">1</span>, r)</span><br><span class="line">        merge(A, p, q, r)</span><br></pre></td></tr></table></figure><h2 id="自底向上的实现">自底向上的实现</h2><p>自底向上的归并排序将原数组视为n个长度为1的子数组，然后依次合并两个相邻子数组，得到长度为2，4，6.…的已排序数组，直到整个数组。自底向上的归并排序的排序过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input:  6  5  3  1  8  7  2  4</span><br><span class="line">1st:    56  31  78  24</span><br><span class="line">2nd:    1356  2478</span><br><span class="line">3rd:    12345678</span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">merge_sort_bottom_up(A):</span><br><span class="line">    n = A.length</span><br><span class="line">    <span class="keyword">for</span> (width = <span class="number">1</span>; width &lt; n; width = <span class="number">2</span> * width):</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i = i + <span class="number">2</span> * width):</span><br><span class="line">            merge(A, i, min(i + width, n) - <span class="number">1</span>, min(i + <span class="number">2</span> * width, n) - <span class="number">1</span>)  <span class="comment"># 合并相邻数组</span></span><br></pre></td></tr></table></figure><h1 id="自然归并排序">自然归并排序</h1><p>自然归并排序（Natural merge sort）类似于自底向上的归并排序。自底向上的归并排序的出发点是1（将长度为n的数组视为n个长度为1的子数组，这n个子数组是已排序的）。而输入数组可能包含已排序的子数组，这些子数组可通过一遍遍历找出。自然归并排序将依次合并这些子数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Start:          3421758906</span><br><span class="line">Select runs:    34  2  17  589  06</span><br><span class="line">Merge:          234  15789  06</span><br><span class="line">Merge:          12345789  06</span><br><span class="line">Merge:          0123456789</span><br></pre></td></tr></table></figure><h1 id="分析">分析</h1><p>合并过程只需要一次遍历即可完成，运行时间是<span class="math inline">\(\Theta(n)\)</span>，n是合并后数组的长度。归并排序的<strong>平均</strong>和<strong>最坏</strong>情况下的时间复杂度是<span class="math inline">\(O(n\lg{n})\)</span>。</p><p>设T(n)为归并排序对长度为n的数组进行排序的运行时间，则归并排序的时间复杂度可以描述为<span class="math inline">\(T(n)=2T(n/2)+\Theta(n)\)</span>。可解得<span class="math inline">\(T(n)=O(n\lg{n})\)</span>。</p><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort_top_down</span><span class="params">(array, p, r)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> p &lt; r:</span><br><span class="line">        q = (p + r) // <span class="number">2</span></span><br><span class="line">        merge_sort_top_down(array, p, q)  <span class="comment"># 递归调用</span></span><br><span class="line">        merge_sort_top_down(array, q + <span class="number">1</span>, r)  <span class="comment"># 递归调用</span></span><br><span class="line">        merge(array, p, q, r)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort_bottom_up</span><span class="params">(array)</span>:</span></span><br><span class="line">    width, n = <span class="number">1</span>, len(array)</span><br><span class="line">    <span class="keyword">while</span> width &lt; n:</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            merge(array, i, min(i + width, n) - <span class="number">1</span>, min(i + (width &lt;&lt; <span class="number">1</span>), n) - <span class="number">1</span>)</span><br><span class="line">            i += (width &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        width = width &lt;&lt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(array, p, q, r)</span>:</span></span><br><span class="line">    <span class="string">"""合并array[p..q]与array[q+1..r]"""</span></span><br><span class="line">    left, right = array[p:q + <span class="number">1</span>], array[q + <span class="number">1</span>:r + <span class="number">1</span>]</span><br><span class="line">    left.append(float(<span class="string">"inf"</span>))</span><br><span class="line">    right.append(float(<span class="string">"inf"</span>))</span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(p, r + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">            array[k] = left[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            array[k] = right[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line">    merge_sort_top_down(arr, <span class="number">0</span>, len(arr) - <span class="number">1</span>)</span><br><span class="line">    print(arr)</span><br><span class="line">    arr = [<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line">    merge_sort_bottom_up(arr)</span><br><span class="line">    print(arr)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 7, 8, 9, 10, 14, 16]</span><br><span class="line">[1, 2, 3, 4, 7, 8, 9, 10, 14, 16]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction To Algorithms </tag>
            
            <tag> divide-and-conquer </tag>
            
            <tag> sort </tag>
            
            <tag> algorithms </tag>
            
            <tag> comparison sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python列表推导</title>
      <link href="/programming/python-list-comprehensions/"/>
      <url>/programming/python-list-comprehensions/</url>
      
        <content type="html"><![CDATA[<h1 id="列表推导">列表推导</h1><p>列表推导（List comprehensions）提供了一种更简洁的方式来创建集合。例如创建一个平方和的列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>    squares.append(x**<span class="number">2</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><p>可以看到在循环结束后，x仍然存在。利用列表推导，可以摆脱这种“副作用”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = list(map(<span class="keyword">lambda</span> y: y**<span class="number">2</span>, range(<span class="number">10</span>)))</span><br></pre></td></tr></table></figure><p>等价于，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = [z**<span class="number">2</span> <span class="keyword">for</span> z <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br></pre></td></tr></table></figure><p>最后一种方法更加简洁，可读性也更好。</p><a id="more"></a><h1 id="扩展">扩展</h1><p>一个列表推导语句至少要有一对内含for语句的括号（例如<code>[x for x in range(9)]</code>），for语句后面可以跟其他for或if语句。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] <span class="keyword">if</span> x != y]</span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">1</span>, <span class="number">5</span>), (<span class="number">1</span>, <span class="number">6</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">2</span>, <span class="number">6</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure><p>将for和if语句按序拆开，上述语句等价于</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>combs = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">if</span> x != y:</span><br><span class="line"><span class="meta">... </span>                    combs.append((x, y))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>combs</span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">1</span>, <span class="number">5</span>), (<span class="number">1</span>, <span class="number">6</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">2</span>, <span class="number">6</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure><p>要注意，当表达式是元组（tuple）时，必须要包含在括号内。如上例中的(x, y)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x, x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    [x, x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line">               ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><h1 id="嵌套">嵌套</h1><p>列表推导自身可以嵌套使用，用来创建一个多维列表。下面是求转置矩阵的例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">    [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">    [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],</span><br><span class="line">    [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>],</span><br><span class="line">]</span><br><span class="line">// 以下<span class="number">3</span>中方法等价，只是写法不同</span><br><span class="line">// 方法<span class="number">1</span>：两个comprehensions嵌套</span><br><span class="line">transposed = [[row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br><span class="line">// 方法<span class="number">2</span>：一个comprehension</span><br><span class="line">transposed = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    transposed.append([row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix])</span><br><span class="line">// 方法<span class="number">3</span>：原生</span><br><span class="line">transposed = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    transposed_row = []</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> matrix:</span><br><span class="line">        transposed_row.append(row[i])</span><br><span class="line">    transposed.append(transposed_row)</span><br><span class="line"></span><br><span class="line">// 结果</span><br><span class="line">[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>], [<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>]]</span><br></pre></td></tr></table></figure><p>实际使用时，更倾向于内建方法。如zip()方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(*matrix))</span><br><span class="line">[(<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>), (<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>), (<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>), (<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>)]</span><br></pre></td></tr></table></figure><h1 id="创建集合和字典">创建集合和字典</h1><p>类似的操作同样适用于创建集合和字典。可以称之为集合推导（Set comprehensions）和字典推导（Dictionary comprehensions）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;s <span class="keyword">for</span> s <span class="keyword">in</span> <span class="string">'hello world'</span>&#125;</span><br><span class="line">&#123;<span class="string">'w'</span>, <span class="string">'o'</span>, <span class="string">'r'</span>, <span class="string">'h'</span>, <span class="string">'l'</span>, <span class="string">' '</span>, <span class="string">'d'</span>, <span class="string">'e'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;k:v <span class="keyword">for</span> k, v <span class="keyword">in</span> enumerate([<span class="string">'zero'</span>, <span class="string">'first'</span>, <span class="string">'second'</span>])&#125;</span><br><span class="line">&#123;<span class="number">0</span>: <span class="string">'zero'</span>, <span class="number">1</span>: <span class="string">'first'</span>, <span class="number">2</span>: <span class="string">'second'</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python循环技巧</title>
      <link href="/programming/python-looping-techniques/"/>
      <url>/programming/python-looping-techniques/</url>
      
        <content type="html"><![CDATA[<h1 id="同时遍历key和value">同时遍历key和value</h1><p>使用items()方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic = &#123;<span class="string">'name'</span>: <span class="string">'chen'</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> dic.items():</span><br><span class="line"><span class="meta">... </span>    print(k, v)</span><br><span class="line">...</span><br><span class="line">name chen  </span><br><span class="line">gender male</span><br></pre></td></tr></table></figure><h1 id="同时遍历index和value">同时遍历index和value</h1><p>使用enumerate()方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate([<span class="string">'zero'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]):</span><br><span class="line"><span class="meta">... </span>    print(i, v)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> zero</span><br><span class="line"><span class="number">1</span> one</span><br><span class="line"><span class="number">2</span> two</span><br><span class="line"><span class="number">3</span> three</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="同时遍历多个数组">同时遍历多个数组</h1><p>使用zip()方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>eng = [<span class="string">'zero'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n, e <span class="keyword">in</span> zip(nums, eng):</span><br><span class="line"><span class="meta">... </span>    print(n, e)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> zero</span><br><span class="line"><span class="number">1</span> one</span><br><span class="line"><span class="number">2</span> two</span><br></pre></td></tr></table></figure><h1 id="反序遍历">反序遍历</h1><p>使用reversed()方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(<span class="number">2</span>, <span class="number">11</span>, <span class="number">2</span>)):</span><br><span class="line"><span class="meta">... </span>    print(i, end=<span class="string">' '</span>)</span><br><span class="line">...</span><br><span class="line"><span class="number">10</span> <span class="number">8</span> <span class="number">6</span> <span class="number">4</span> <span class="number">2</span> &gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h1 id="排序和去重">排序和去重</h1><p>使用sorted()和set()方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>basket = [<span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'apple'</span>, <span class="string">'banana'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> f <span class="keyword">in</span> sorted(set(basket)):</span><br><span class="line"><span class="meta">... </span>    print(f)</span><br><span class="line">...</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br></pre></td></tr></table></figure><h1 id="循环里面的else">循环里面的else</h1><p>退出循环时执行else块中代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">if</span> n % x == <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>                    print(n, <span class="string">'equals'</span>, x, <span class="string">'*'</span>, n//x)</span><br><span class="line"><span class="meta">... </span>                    <span class="keyword">break</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>            print(n, <span class="string">'is a prime number'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="number">2</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">3</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">4</span> equals <span class="number">2</span> * <span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">6</span> equals <span class="number">2</span> * <span class="number">3</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">8</span> equals <span class="number">2</span> * <span class="number">4</span></span><br><span class="line"><span class="number">9</span> equals <span class="number">3</span> * <span class="number">3</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性时间排序</title>
      <link href="/notes/introduction-to-algorithms/sorting-in-linear-time/"/>
      <url>/notes/introduction-to-algorithms/sorting-in-linear-time/</url>
      
        <content type="html"><![CDATA[<h1 id="计数排序">计数排序</h1><p>计数排序于1954年由Harold H. Seward提出，是一种线性时间排序算法。它是稳定排序算法，这个性质很重要，是它可以作为基数排序子过程的前提。但不是原址排序算法，即需要额外的随输入规模增大的辅助空间。计数排序不是比较排序，摆脱了比较排序的下界<span class="math inline">\(\Omega(n\lg{n})\)</span>，可以在线性时间内完成排序。</p><p>计数排序先“数”出不同元素值的个数，之后通过算数运算求出不同元素值排序后的位置。它的运行时间是O(max-min) 。计数排序比较适用于，输入数组中最大值和最小值的差不特别大于元素个数的情况。但计数排序可以用作别的排序的子过程，例如<a href="/algorithm/Radix-sort">基数排序</a>，基数排序可以很好的处理上述情况。</p><h2 id="实现">实现</h2><p>计数排序假设，输入数组是一组从0开始，最大值不超过k（即小于等于k）的整型数组。在某些情况下，k可能已知，比如十进制数的基数排序中k=9。在未知的时候，需要通过遍历数组，得出k的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">counting_sort(A, B, k):   <span class="comment"># A：输入；B：输出 ；k：A中的最大值</span></span><br><span class="line">    C = new array[k+<span class="number">1</span>]    <span class="comment"># C：辅助数组</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to A.length - <span class="number">1</span>:</span><br><span class="line">        C[A[i]] = C[A[i]] + <span class="number">1</span></span><br><span class="line">    <span class="comment"># C[i] now means that A has C[i] elements equal to i</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to k:</span><br><span class="line">        C[i] = C[i] + C[i + <span class="number">1</span>]</span><br><span class="line">    <span class="comment"># C[i] now means that A has C[i] elements equal to or less than i</span></span><br><span class="line">    <span class="keyword">for</span> j = A.length - <span class="number">1</span> to <span class="number">0</span>:</span><br><span class="line">        B[C[A[i]] - <span class="number">1</span>] = A[i]</span><br><span class="line">        C[A[i]] = C[A[i]] - <span class="number">1</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>通过一个简单的例子来理解这段伪代码。</p><table><thead><tr class="header"><th>序号</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr class="odd"><td>数组A</td><td>2</td><td>5</td><td>3</td><td>0</td><td>2</td><td>3</td><td>0</td><td>3</td></tr><tr class="even"><td>第一个循环后C的值</td><td>2</td><td>0</td><td>2</td><td>3</td><td>0</td><td>1</td><td></td><td></td></tr><tr class="odd"><td>第二个循环后C的值</td><td>2</td><td>2</td><td>4</td><td>7</td><td>7</td><td>8</td><td></td><td></td></tr><tr class="even"><td>j=7，C[A[7]]=C[3]=7，有7个数小于3，则B[6]=A[7]</td><td></td><td></td><td></td><td></td><td></td><td></td><td>3</td><td></td></tr><tr class="odd"><td>C[3]-=1</td><td>2</td><td>2</td><td>4</td><td>6</td><td>7</td><td>8</td><td></td><td></td></tr><tr class="even"><td>j=6，……</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>Q: 为什么不在第一个循环之后借助数组C直接输出排序后的数组？</p><p>A: 保证计数排序算法的稳定性（如果不要求排序结果的稳定性可以这样做）。在下面的基数排序算法中，计数排序通常作为子排序过程出现，而且为了保证基数排序是正确的，子排序过程必须是稳定的。</p><h2 id="分析">分析</h2><p>计数排序的代码只有三个循环，第一个和第三个循环执行n次，第二个循环执行k次，每个循环的单次运行时间都是<span class="math inline">\(\Theta(1)\)</span>。所以总运行时间是<span class="math inline">\(T(n)=2\Theta(n)+\Theta(k)=\Theta(k+n)\)</span>。当<span class="math inline">\(k=\Theta(n)\)</span>的时候，即数组中的最大值随数组大小线性变化时，<span class="math inline">\(T(n)=\Theta(n)\)</span>，计数排序可以在线性时间内完成排序。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counting_sort</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    c = [<span class="number">0</span>] * (max(a) + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">        c[a[i]] += <span class="number">1</span>  <span class="comment"># C[i] now contains the number of elements equal to i.</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(c)):</span><br><span class="line">        c[i] += c[i - <span class="number">1</span>]  <span class="comment"># C[i] now contains the number of elements less than or equal to i.</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        b[c[a[i]] - <span class="number">1</span>] = a[i]</span><br><span class="line">        c[a[i]] -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="基数排序">基数排序</h1><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字（位数不足的数字高位补零），然后按每个位数分别比较。基数排序最初是应用在卡片排序机上的算法，可以被“机械编程”。</p><h2 id="实现-1">实现</h2><p>基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital）。LSD即从最低位开始比较，MSD相反，从最高位开始比较。</p><ul><li><p>MSD的排序过程：按最高有效位进行排序，按最高位分别放入“容器0-9”，然后按下一个最高位递归的对每个容器中的数进行排序。</p><p>使用MSD排序一组数的例子如下，表中省略了没有数的容器：</p></li></ul><table><colgroup><col style="width: 18%"><col style="width: 20%"><col style="width: 20%"><col style="width: 20%"><col style="width: 18%"></colgroup><thead><tr class="header"><th>输入数组</th><th>按最高位排序后</th><th>递归排序容器0和1</th><th>递归排序容器0</th><th>按序收集</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\begin{aligned}004\\178\\045\\009\\135\end{aligned}\)</span></td><td><span class="math inline">\(\begin{aligned}&amp;容器0\begin{cases}004\\045\\009\end{cases}\\&amp;容器1\begin{cases}178\\135\end{cases}\end{aligned}\)</span></td><td><span class="math inline">\(\begin{aligned}&amp;容器0\begin{cases}容器0\begin{cases}004\\009\end{cases}\\容器4：045\\\end{cases}\\&amp;容器1\begin{cases}容器3：135\\容器7：178\end{cases}\end{aligned}\)</span></td><td><span class="math inline">\(\begin{aligned}&amp;容器0\begin{cases}容器0\begin{cases}容器4：004\\容器9：009\end{cases}\\容器4：045\end{cases}\\&amp;容器1\begin{cases}容器3：135\\容器7：178\end{cases}\end{aligned}\)</span></td><td><span class="math inline">\(\begin{aligned}004\\009\\045\\135\\178\end{aligned}\)</span></td></tr></tbody></table><ul><li><p>LSD的排序过程：按最低有效位进行排序，将排序结果放入同一个”容器“，然后按下一个最低位重复排序，再收集，直至最高位排序完成。</p><p>同样的输入，使用LSD排序的例子如下（注意稳定性）：</p></li></ul><table><colgroup><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"></colgroup><thead><tr class="header"><th>输入数组</th><th>按最低位排序后</th><th>第二低位</th><th>第三低位</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\begin{aligned}004\\178\\045\\009\\135\end{aligned}\)</span></td><td><span class="math inline">\(\begin{aligned}004\\045\\135\\178\\009\end{aligned}\)</span></td><td><span class="math inline">\(\begin{aligned}004\\009\\135\\045\\178\end{aligned}\)</span></td><td><span class="math inline">\(\begin{aligned}004\\009\\045\\135\\178\end{aligned}\)</span></td></tr></tbody></table><hr><p>在MSD排序中，例如第二列中，为了排序容器0中的数，容器1-9中的数必须先放一边保存起来，每次递归都需要额外准备10个“容器”用来保存排序结果。如果递归深度比较大，MSD会占用非常多的空间。</p><p>相比之下，LSD只需要10个“容器”，在下一次循环开始前，“容器”中的数被收集起来，“容器”可以重复使用。</p><p>因此基数排序采用LSD进行排序，也因此要求子过程必须是稳定的。即高位的比较结果不能破坏低位的比较结果。</p><p>例如004和009：</p><p>在最低位上通过排序确定了004在009之前（4&lt;9）。</p><p>下一个最低有效位都是0，004和009之间的次序应该由较低位（即上一次排序结果）决定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">radix_sort(A, d):</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to d:  <span class="comment"># d 是有效位数</span></span><br><span class="line">        use a stable sort to sort array A on i</span><br></pre></td></tr></table></figure><p>对于十进制数字来说，每一位只会出现10种数字（0-9），因此计数排序是一个好的选择。</p><h2 id="分析-1">分析</h2><p>基数排序的时间代价依赖于所使用的稳定的排序算法。如果子过程是计数排序的话，则基数排序的时间复杂度可以描述为<span class="math inline">\(d\Theta(n+k)=\Theta(d(n+k))\)</span>。当d为常数（位数固定）且k=O(n)（每位数字都在0到k-1区间内）时，基数排序具有线性时间代价。</p><h2 id="代码-1">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="string">"""十进制数的基数排序算法"""</span></span><br><span class="line">    c, b = [], [<span class="literal">None</span>] * len(a)  <span class="comment"># b is an auxiliary list, c share the same meaning with list c in counting sort</span></span><br><span class="line">    digit, _max = <span class="number">1</span>, max(a)</span><br><span class="line">    <span class="keyword">while</span> _max // digit &gt; <span class="number">0</span>:</span><br><span class="line">        c = [<span class="number">0</span>] * <span class="number">10</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">            c[(a[i] // digit) % <span class="number">10</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(c)):</span><br><span class="line">            c[i] += c[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(len(a))):</span><br><span class="line">            target = (a[i] // digit) % <span class="number">10</span></span><br><span class="line">            b[c[target] - <span class="number">1</span>] = a[i]</span><br><span class="line">            c[target] -= <span class="number">1</span></span><br><span class="line">        a[:] = b[:]</span><br><span class="line">        digit *= <span class="number">10</span></span><br></pre></td></tr></table></figure><h1 id="桶排序">桶排序</h1><p>桶排序（Bucket sort）或箱排序，工作原理是将数组分到有限数量的桶里。每个桶再个别排序。</p><p>计数排序假设输入数据都属于一个小区间内的整数，桶排序也对输入作了某种假设。桶排序假设输入服从均匀分布，平均情况下时间代价为O(n)。</p><h2 id="实现-2">实现</h2><p>桶排序将[0,1)区间划分为k个大小相同的子区间，或称为桶。然后，将n个输入数分别放到各个桶中。对每个桶中的数进行排序，然后遍历每个桶，按照次序把各个桶中的元素列出来即可。因为输入是均匀、独立地分布在[0,1)区间上，所以一般不会出现很多数落在同一个桶中的情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bucket_sort(A):</span><br><span class="line">    n = A.length</span><br><span class="line">    B = new array[k]</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to k - <span class="number">1</span>:</span><br><span class="line">        make B[i] an empty list        <span class="comment"># make k buckets</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to n - <span class="number">1</span>:</span><br><span class="line">        insert A[i] into list B[floor(k * A[i])]</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to k - <span class="number">1</span>:</span><br><span class="line">        sort list B[i] <span class="keyword">with</span> insertion sort</span><br><span class="line">    concatenate the lists B[<span class="number">0</span>], B[<span class="number">1</span>],...,B[k<span class="number">-1</span>] together <span class="keyword">in</span> order</span><br></pre></td></tr></table></figure><p>例如k=10时，排序一组数的过程如下：</p><table><thead><tr class="header"><th>输入</th><th>所属桶<span class="math inline">\(\lfloor{k * A[i]}\rfloor\)</span></th><th>桶序号</th><th>桶中元素</th><th>排序后桶中元素</th></tr></thead><tbody><tr class="odd"><td>0.78</td><td>7（<span class="math inline">\(\lfloor10 * 0.78\rfloor=7\)</span>）</td><td>0</td><td></td><td></td></tr><tr class="even"><td>0.17</td><td>1</td><td>1</td><td>0.17、0.12</td><td>0.12、0.17</td></tr><tr class="odd"><td>0.39</td><td>3</td><td>2</td><td>0.26、0.21、0.23</td><td>0.21、0.23、0.26</td></tr><tr class="even"><td>0.26</td><td>2</td><td>3</td><td>0.39</td><td>0.39</td></tr><tr class="odd"><td>0.72</td><td>7</td><td>4</td><td></td><td></td></tr><tr class="even"><td>0.94</td><td>9</td><td>5</td><td></td><td></td></tr><tr class="odd"><td>0.21</td><td>2</td><td>6</td><td>0.68</td><td>0.68</td></tr><tr class="even"><td>0.12</td><td>1</td><td>7</td><td>0.78、0.72</td><td>0.72、0.78</td></tr><tr class="odd"><td>0.23</td><td>2</td><td>8</td><td></td><td></td></tr><tr class="even"><td>0.68</td><td>6</td><td>9</td><td>0.94</td><td>0.94</td></tr></tbody></table><p>遍历桶中元素即可得到排序结果。</p><h2 id="分析-2">分析</h2><p>除去调用插入排序的代码，其他代码可以在<span class="math inline">\(\Theta(1)\)</span>时间内完成。已知插入排序的时间复杂度为<span class="math inline">\(O(n^2)\)</span>，n为元素个数。桶排序对每个桶都调用了插入排序，桶中有多少元素直接影响到时间代价。设桶i中的元素个数为<span class="math inline">\(n_i\)</span>，则桶排序的时间代价可以描述为：</p><p><span class="math display">\[T(n)=\Theta(n)+\sum_{i=0}^{k-1}{O(n_i^2)}\]</span></p><p>虽然无法准确直到每个桶中元素个数，从而无法计算上述时间代价。但可以计算其期望。通过对上式求期望：</p><p><span class="math display">\[\begin{aligned}E[T(n)]&amp;=E[\Theta(n)+\sum_{i=0}^{k-1}{O(n_i^2)}]\\&amp;=\Theta(n)+\sum_{i=0}^{k-1}{E[O(n_i^2)]}\\&amp;=\Theta(n)+\sum_{i=0}^{k-1}{O(E[n_i^2])}\end{aligned}\]</span></p><p>桶排序假设输入服从均匀分布，因此可以认为元素落到每个桶的概率是相同的，为1/k。n个元素分到k个桶（设为随机变量X），X服从参数为n和1/k的二项分布，即<span class="math inline">\(X\sim{b(n,1/k)}\)</span>。通过二项分布的期望和方差可以快速计算出<span class="math inline">\(E(n_i^2)\)</span>。</p><p><span class="math display">\[\begin{aligned}E(n_i^2)&amp;=E(X^2)\\&amp;=V(X)+(E(X))^2\\&amp;=n\frac{1}{k}(1-\frac{1}{k})+(n\frac{1}{k})^2\\&amp;=\frac{n^2+nk-n}{k^2}\end{aligned}\]</span></p><p>由此可以得出桶排序的期望时间代价为</p><p><span class="math display">\[\begin{aligned}E[T(n)]&amp;=\Theta(n)+\sum_{i=0}^{k-1}{O(E[n_i^2])}\\&amp;=\Theta(n)+kO(\frac{n^2+nk-n}{k^2})\\&amp;=\Theta(n)+O(\frac{n^2}{k}+n)\end{aligned}\]</span></p><p>如果桶的个数<span class="math inline">\(k=\Theta(n)\)</span>，则上式等于O(n)，桶排序可以在线性时间内结束。如果k=n，则桶排序近似等价于计数排序。</p><p>总结：虽然插入排序的时间复杂度是<span class="math inline">\(O(n^2)\)</span>，但在n比较小的时候同其他比较排序的差距并不明显。桶排序就是将原数组分到不同的桶中，使得各个桶中的元素个数比较小且桶之间满足次序关系，再对桶中元素使用插入排序。</p><h2 id="代码-2">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> insertion_sort <span class="keyword">import</span> insertion_sort</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucket_sort</span><span class="params">(a)</span>:</span></span><br><span class="line">    b = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a))]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">        b[math.floor(len(a) * a[i])].append(a[i])</span><br><span class="line">    a.clear()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(b)):</span><br><span class="line">        insertion_sort(b[i])</span><br><span class="line">        a.extend(b[i])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction To Algorithms </tag>
            
            <tag> sort </tag>
            
            <tag> algorithms </tag>
            
            <tag> non-comparison sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插入排序、选择排序和冒泡排序</title>
      <link href="/notes/introduction-to-algorithms/insertion-sort-selection-sort-and-bubble-sort/"/>
      <url>/notes/introduction-to-algorithms/insertion-sort-selection-sort-and-bubble-sort/</url>
      
        <content type="html"><![CDATA[<h1 id="插入排序">插入排序</h1><p>对于少量元素的排序，插入排序（Insertion sort）是一个有效的算法。插入排序的工作方式像许多人排序一手扑克牌。开始时左手为空，每次从桌子上拿走一张牌并将它插入左手中正确的位置。插入排序将输入数组分成未排序部分和已排序部分两个子数组，初始时已排序部分为空（或者有一个，因为一个数的数组是已排序的），每次迭代从未排序数组中选择一个元素，将其放入已排序数组中的合适位置。</p><p>插入排序示意图（出自<a href="https://en.wikipedia.org/wiki/Insertion_sort" target="_blank" rel="noopener">维基百科：Insertion sort</a>）：</p><p><img data-src="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif" title="插入排序动态示意图"></p><h2 id="实现">实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">insertion_sort(A):</span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">1</span> to A.length - <span class="number">1</span>:</span><br><span class="line">        key = A[j]</span><br><span class="line">        <span class="comment"># Insert A[j] into the sorted sequence A[1...j-1]</span></span><br><span class="line">        i = j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> A[i] &gt; key:</span><br><span class="line">            A[i + <span class="number">1</span>] = A[i]</span><br><span class="line">            i = i - <span class="number">1</span></span><br><span class="line">        A[i + <span class="number">1</span>] = key</span><br></pre></td></tr></table></figure><a id="more"></a><p>循环不变式（<a href="https://en.wikipedia.org/wiki/Loop_variant" title="Loop variant" target="_blank" rel="noopener">Loop variant</a>）用来帮助理解算法的正确性。关于循环不变式，必须证明三条性质。</p><ul><li>初始化：循环的第一次迭代前，它为真。</li><li>保持：如果循环的某次迭代前它为真，那么下次迭代前它仍为真。</li><li>终止：在循环终止时，不变式提供一个有用的性质，该性质有助于证明算法是正确的。</li></ul><p>（类似于数学归纳法）</p><p>用下面的循环不变式证明插入排序算法的正确性。</p><blockquote><p>在for循环的每次迭代开始前，子数组<code>A[0...(j-1)]</code>由原来在<code>A[0...(j-1)]</code>中的元素组成，但已按序排列。</p></blockquote><ul><li>初始化：循环的第一次迭代前，j=1，子数组只包含A[0]，它为真。</li><li>保持：for循环里面嵌套了一个while循环，同样可以用另一个循环不变式证明它。但对于简单的循环，同样可以通过非形式化的分析证明其正确性。非形式化地，while循环将 A[j-1], A[j-2]等向右移动一个位置，直到找到A[j]的适当位置。最后将A[j]插入该位置。此时，子数组<code>A[0...(j)]</code>由原来在 <code>A[0...(j)]</code>中的元素组成，但已按序排列。那么下一次迭代增加j，上述循环不变式为真。</li><li>终止：循环终止时j=A.length，则根据循环不变式子数组<code>A[0...(A.length-1)]</code>由原来在<code>A[0...(A.length-1)]</code>中的元素组成，但已按序排列。此时<code>A[0...(A.length-1)]</code>就是整个数组。因此该算法正确。</li></ul><h2 id="分析">分析</h2><p>在for循环内部，除去while循环的语句执行时间均为<span class="math inline">\(\Theta(1)\)</span>（即常数时间内），for循环执行n-1次。while循环的运行时间与数组的已排序程度有关系。若输入数组已按递增序排好，则导致最佳情况。若输入数组已反向排序，即按递减序排好，则导致最坏情况。在while循环处，必须将每个元素 A[j]与整个已排序子数组<code>A[0...(j-1)]</code>中每个元素进行比较。</p><table><thead><tr class="header"><th>j</th><th>最佳时比较元素</th><th>比较次数</th><th>最坏时比较元素</th><th>比较次数</th></tr></thead><tbody><tr class="odd"><td>1</td><td>A[0]</td><td>1</td><td>A[0]</td><td>1</td></tr><tr class="even"><td>2</td><td>A[1]</td><td>1</td><td>A[0, 1]</td><td>2</td></tr><tr class="odd"><td><span class="math inline">\(\vdots\)</span></td><td><span class="math inline">\(\vdots\)</span></td><td><span class="math inline">\(\vdots\)</span></td><td><span class="math inline">\(\vdots\)</span></td><td><span class="math inline">\(\vdots\)</span></td></tr><tr class="even"><td>n-1</td><td>A[n-2]</td><td>1</td><td><code>A[0...(n-2)]</code></td><td>n-1</td></tr></tbody></table><p>最佳情况下，while循环的执行时间为<span class="math inline">\(\sum_{n=1}^{n-1}1=n-1\)</span>。</p><p>最佳运行时间为<span class="math inline">\(T(n)=(n-1)\Theta(1)+n-1=\Theta(n)\)</span>。它是n的线性函数。</p><p>最坏情况下，while循环的执行时间为<span class="math inline">\(\sum_{n=1}^{n-1}n=\frac{n(n-1)}{2}\)</span>。</p><p>所以，插入排序的最坏情况运行时间为<span class="math inline">\(T(n)=(n-1)\Theta(1)+\frac{n(n-1)}{2}\le{n^2}=O(n^2)\)</span>。此时它是n的二次函数。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(a)):</span><br><span class="line">        key = a[j]</span><br><span class="line">        i = j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> a[i] &gt; key:</span><br><span class="line">            a[i + <span class="number">1</span>] = a[i]</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        a[i + <span class="number">1</span>] = key</span><br></pre></td></tr></table></figure><h2 id="最坏最佳与平均情况">最坏、最佳与平均情况</h2><p>最坏情况比最佳情况更加有用，算法导论给出了三点理由。</p><ul><li>一个算法的最坏情况运行时间给出了任何输入的运行时间的一个上界。知道了这个界，就能确保该算法绝不需要更长的时间。</li><li>对某些算法，最坏情况经常出现。例如，当数据库中检索一条特定信息时，若该信息不在数据库中出现，则检索算法的最坏情况会出现。在某些应用中，对缺失信息的检索可能是频繁的。</li><li>“平均情况”往往与最坏情况大致一致。假定随机选择n个数并应用插入排序。平均来说，<code>A[0...(j-1)]</code>中的一般元素小于A[j]，一半元素大于A[j]。所以，平均来说，每次while循环的比较次数大约为j/2。导致平均情况运行时间结果像最坏情况运行时间一样，也是输入规模的一个二次函数。</li></ul><p>在某些特定情况下，会对一个算法的平均情况运行时间感兴趣。平均情况分析的范围有限，因为对于特定的问题，什么构成一种“平均”输入并不明显。</p><h1 id="选择排序">选择排序</h1><p>如果说插入排序是拿一张牌去找在左手中的位置，那么选择排序就是找出最小的牌，放到左手的末位（或者找最大的牌，放到左手的首位）。与插入排序类似，选择排序也将输入数组分成已排序和未排序两个子数组，每次迭代选择未排序数组中最小（或最大，取决于排序规则）的元素，将其与未排序子数组的第一位元素交换，然后扩展已排序数组的边界加一。</p><p>选择排序示意图（出自<a href="https://en.wikipedia.org/wiki/Selection_sort" title="Selection sort" target="_blank" rel="noopener">维基百科：Selection sort</a>）：</p><p><img data-src="https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif" title="选择排序动态示意图"></p><h2 id="实现-1">实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">selection_sort(A):</span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">0</span> to A.length - <span class="number">2</span>:</span><br><span class="line">        i_min = j</span><br><span class="line">        <span class="keyword">for</span> i = j + <span class="number">1</span> to A.length - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> A[i] &lt; A[i_min]:</span><br><span class="line">                i_min = i</span><br><span class="line">        <span class="keyword">if</span> i_min != j:</span><br><span class="line">            exchange A[i_min] <span class="keyword">with</span> A[j]</span><br></pre></td></tr></table></figure><h2 id="分析-1">分析</h2><p>外层循环执行n-1次，单次运行时间为<span class="math inline">\(\Theta(1)\)</span>。内层循环寻找下一个最小的数执行n-1-j次，单次运行时间也是<span class="math inline">\(\Theta(1)\)</span>。</p><p>总运行时间为：</p><p><span class="math display">\[\begin{aligned}T(n)&amp;=n-1+\sum_{j=0}^{n-2}n-i-j \\&amp;=n-1+\sum_{i=1}^{n-1}n-i \\&amp;=n-1+\frac{n(n-1)}{2} \\&amp;=O(n^2)\end{aligned}\]</span></p><h2 id="代码-1">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(a) - <span class="number">1</span>):</span><br><span class="line">        i_min = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(j + <span class="number">1</span>, len(a)):</span><br><span class="line">            <span class="keyword">if</span> a[i] &lt; a[i_min]:</span><br><span class="line">                i_min = i</span><br><span class="line">        <span class="keyword">if</span> i_min != j:</span><br><span class="line">            a[i_min], a[j] = a[j], a[i_min]</span><br></pre></td></tr></table></figure><h1 id="冒泡排序">冒泡排序</h1><p>冒泡排序（Bubble sort）通过依次比较两个相邻的元素，如果它们的顺序关系是错误的，就交换它们。正如它的命名一样，比较大的元素先浮到数组顶端。</p><p>冒泡排序示意图（出自<a href="https://en.wikipedia.org/wiki/Bubble_sort" title="冒泡排序" target="_blank" rel="noopener">维基百科：Bubble sort</a>）：</p><p><img data-src="https://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif" title="冒泡排序动态示意图"></p><h2 id="实现-2">实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bubble_sort(A):</span><br><span class="line">    n = A.length</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to n - <span class="number">1</span>:       <span class="comment"># 每次循环将下一个最大元素冒泡到正确位置</span></span><br><span class="line">        swapped = false</span><br><span class="line">        <span class="keyword">for</span> j = <span class="number">1</span> to n - i:   <span class="comment"># 后i位元素大于之前的元素且已经排好序</span></span><br><span class="line">            <span class="keyword">if</span> A[j - <span class="number">1</span>] &gt; A[j]:</span><br><span class="line">                exchange A[j] <span class="keyword">with</span> A[j - <span class="number">1</span>]</span><br><span class="line">                swapped = true</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> swapped:       <span class="comment"># 结束排序</span></span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h3 id="优化">优化</h3><p>与其记录swapped=true or false，不如记录下最后发生交换的位置i，之后没有发生交换意味着i之后的元素全部大于i之前的元素且已经按序排好。那么在下次冒泡前，结束位置可以直接跳到i。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bubble_sort(A):</span><br><span class="line">    target = A.length</span><br><span class="line">    <span class="keyword">while</span> target &gt; <span class="number">1</span>:</span><br><span class="line">        last_swap = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j = <span class="number">1</span> to target - <span class="number">1</span>:   <span class="comment"># target及target之后的元素大于之前的元素且已经排好序</span></span><br><span class="line">            <span class="keyword">if</span> A[j - <span class="number">1</span>] &gt; A[j]:</span><br><span class="line">                exchange A[j] <span class="keyword">with</span> A[j - <span class="number">1</span>]</span><br><span class="line">                last_swap = j</span><br><span class="line">        target = last_swap</span><br></pre></td></tr></table></figure><h2 id="分析-2">分析</h2><p>冒泡排序的平均时间和最坏时间复杂度为<span class="math inline">\(O(n^2)\)</span>。在实际应用中，时间复杂度同样是<span class="math inline">\(O(n^2)\)</span>的插入排序一般比冒泡排序要快，更不用说还有其他更快的排序算法。</p><p>冒泡排序可以用来检测一个数组是否已经排好序，即冒泡排序的最佳情况运行时间O(n)。插入排序同样可以在O(n)时间内检测一个数组是否排好序，且比冒泡排序好。</p><h2 id="代码-2">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(a)</span>:</span></span><br><span class="line">    target = len(a)</span><br><span class="line">    <span class="keyword">while</span> target &gt; <span class="number">1</span>:</span><br><span class="line">        last_swapped = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, target):</span><br><span class="line">            <span class="keyword">if</span> a[j - <span class="number">1</span>] &gt; a[j]:</span><br><span class="line">                a[j - <span class="number">1</span>], a[j] = a[j], a[j - <span class="number">1</span>]</span><br><span class="line">                last_swapped = j</span><br><span class="line">        target = last_swapped</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction To Algorithms </tag>
            
            <tag> sort </tag>
            
            <tag> algorithms </tag>
            
            <tag> comparison sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆和堆排序</title>
      <link href="/notes/introduction-to-algorithms/heaps-and-heapsort/"/>
      <url>/notes/introduction-to-algorithms/heaps-and-heapsort/</url>
      
        <content type="html"><![CDATA[<h1 id="堆">堆</h1><p>堆（Heap）始于<a href="https://en.wikipedia.org/wiki/J._W._J._Williams" target="_blank" rel="noopener">J. W. J. Williams</a>在1964年发表的堆排序（heap sort）。</p><p>堆是一种基于树的数据结构，一棵满足以下性质的完全树可称为堆。</p><blockquote><p>给定堆中任意节点P和C，若P是C的母节点，那么P的值会小于等于（或大于等于）C的值。</p><ol type="1"><li>若P的值小于等于C的值，称为最小堆（min heap）。</li><li>若P的值大于等于C的值，称为最大堆（max heap）。</li></ol></blockquote><p>在堆中最顶端的节点称为根节点（root node），根节点本身没有母节点（parent node）。</p><p>常见的堆有二叉堆、斐波那契堆等。</p><a id="more"></a><h1 id="操作">操作</h1><p>一个堆应该支持以下常见操作（参考了<a href="https://en.wikipedia.org/wiki/Heap_(data_structure)" title="Heap" target="_blank" rel="noopener">维基百科</a>）。</p><ul><li>peek()：返回堆顶元素。</li><li>pop()：返回并移除堆顶元素，需要调整堆。</li><li>append(x)：添加一个新的元素x​，需要调整堆以满足堆的性质。</li><li>replace()：相当于一次pop之后append。但比分别执行更效率，因为只需要调整一次堆。</li></ul><hr><ul><li>heapify()：创建一个堆。只需要调用一次。</li><li>merge(other)：合并other中的元素到堆。</li></ul><hr><ul><li>size()：返回堆中元素数。</li><li>is_empty()：如果是空堆，返回true，否则返回false。</li></ul><hr><ul><li>increase_key(i, x)：增大元素的值。</li><li>decrease_key(i, x)：减小元素的值。</li><li>delete(i)：删除指定的一个元素。</li><li>sift_up(i)：不断上移元素，直到满足最小堆的性质。</li><li>sift_down(i)：不断下移元素，直到满足最大堆的性质。</li></ul><h1 id="实现">实现</h1><p>堆通常用数组（静态或动态）实现，并且不需要保存指针。</p><p>树的根节点是A[0]，给定一个节点的下标i，通过计算可以得到它的母节点、左孩子和右孩子节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">parent(i):</span><br><span class="line">    <span class="keyword">return</span> floor((i<span class="number">-1</span>) / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">left_child(i):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">right_child(i):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">2</span></span><br></pre></td></tr></table></figure><p><img data-src="/uploads/posts/introduction-to-algorithms/heap-and-array.png" title="堆和数组"></p><h2 id="维护堆的性质">维护堆的性质</h2><p>以最大堆为例，如何维护一个数组使之满足最大堆性质。考虑下面这种情况。</p><ul><li>前提条件：假设<strong>根节点</strong>为left_child(i)和right_child(i)的二叉树都是最大堆。</li></ul><p>但A[i]有可能小于其孩子节点，这违背了最大堆的性质。sift_down（下滤）通过让A[i]的值在最大堆中“逐级下降”，从而使下标为i的子树重新遵循最大堆的性质。</p><p><img data-src="/uploads/posts/introduction-to-algorithms/heap-sift-down.png" title="sift down"></p><p>关于逐级下降正确性的思考：满足前提条件的情况下，</p><p>假设根节点i与i的子节点x, y中，值最大的是子节点x。交换i与x的值，现在A[i]&gt;A[x]，满足最大堆的性质。但x的值相比交换前变小了，所以可能小于其子节点的值。</p><p>新的状况变为节点x可能小于其子节点的值，其子节点均大于或等于下一层子节点的值。符合前提条件，所以对x递归调用sift_down即可。在节点i上执行sift_down的过程如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sift_down(A, i):</span><br><span class="line">    l = left_child(i)</span><br><span class="line">    r = right_child(i)</span><br><span class="line">    <span class="keyword">if</span> l &lt; size() <span class="keyword">and</span> A[l] &gt; A[i]:  <span class="comment"># Find the largest element of i, l and r.</span></span><br><span class="line">        largest = l</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        largest = i</span><br><span class="line">    <span class="keyword">if</span> r &lt; size() <span class="keyword">and</span> A[r] &gt; A[largest]:</span><br><span class="line">        largest = r</span><br><span class="line">    <span class="keyword">if</span> largest != i:              <span class="comment"># If violating the heap properity, then fix them.</span></span><br><span class="line">        exchange A[i] <span class="keyword">with</span> A[largest]</span><br><span class="line">        sift_down(A, largest)     <span class="comment"># A[largest] might violating the heap properity.</span></span><br><span class="line">                                  <span class="comment"># Call sift_down recursively to fix it.</span></span><br></pre></td></tr></table></figure><p>sift_down的时间复杂度：</p><p>在一棵大小为n​的子树上，运行sift_down的时间T(n)包括：比较三个节点大小关系以及交换值的时间代价<span class="math inline">\(\Theta(1)\)</span>，加上在一棵子树上运行sift_down的时间。子树的大小至多为2n/3（最底层正好半满的时候，即最后一层左子树节点填满，右子树节点是空的），由此可以得到刻画程序运行时间的递归式：<span class="math inline">\(T(n)\le\Theta(1)+T(2n/3)\)</span>。解得<span class="math inline">\(T(n)=O(\lg{n})\)</span>。</p><p>也就是说，对于一棵树高为h的节点来说，sift_down的时间复杂度是O(h)。</p><p>关于一棵子树的大小至多为2n/3的由来。</p><p>首先明确关于树的两个性质：</p><ol type="1"><li>如果以某个节点为根节点的树是完全树，那么它的左子树大小大于等于右子树大小。因为完全树的最后一层是从左到右填入的。</li><li>如果一棵满二叉树的最后一层节点数目为n，那么这个树的大小为2n-1。因为满二叉树第i(i&gt;=0)层节点数量是<span class="math inline">\(2^i\)</span>。</li></ol><p>根据性质1，只需要考虑左子树最多为母树的几分之几即可。</p><p>假设一个完全树的大小为n，它的左子树大小为i，比值i/n根据最底层节点数目而变动。观察最底层节点数目从0逐渐增长时该比值的变化情况。</p><ul><li><p>当新增节点属于左子树时，比值由i/n变成(i+1)/(n+1)，比值增大。</p></li><li><p>当新增节点属于右子树时，比值由i/n变成i/(n+1)，比值减小。</p></li></ul><p>因此当左子树恰好填满（最底层恰好半满）时，比值最大。</p><p>设此时最低层节点个数为x，注意这x个节点正好填满左子树最底层，则根据性质2，i=2x-1，<span class="math inline">\(n=2*i+1-x=3x-1\)</span>。</p><p>所以得到<span class="math inline">\(i/n=(2x-1)/(3x-1)\le2/3\)</span>。即大小为n的树中，子树的大小至多为2n/3。</p><h2 id="建堆">建堆</h2><p>同样以最大堆为例，可以用<strong>自底向上</strong>的方法调用过程sift_down，将一个数组转换为最大堆。过程heapify对树中非叶子节点都调用一次sift_down。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heapify(A):</span><br><span class="line">    <span class="keyword">for</span> i = parent(size()<span class="number">-1</span>) downto <span class="number">0</span>:</span><br><span class="line">        sift_down(A, i)</span><br></pre></td></tr></table></figure><p>可以使用如下的循环不变量验证该过程的正确性。</p><blockquote><p>每一次for循环开始前，节点 <code>i, i+1,...,size()</code>都是一个最大堆的根节点。</p></blockquote><p>需要证明此循环不变量在循环开始前，迭代时以及结束后都成立。</p><ul><li>初始化：第一次迭代前，i之后的节点都是叶节点，因此它们都是最大堆的根节点。</li><li>保持：注意到节点i+1​始终比i先调用sift_down过程，根据循环不变量，它们都是最大堆的根节点。</li><li>终止：终止时i=-1​，根据循环不变量节点<code>0,1,...,size()</code>都是最大堆的根节点，特别的，0是堆的顶点。</li></ul><p>之前分析了sift_down(A, i)的运行时间与节点i所处高度有关，在建堆过程中，不同的节点所处高度可能不同，想准确计算建堆的时间复杂度利用了下面所示的树的特性。</p><ul><li>一棵含有n个元素的完全树，在高度h处，最多有<span class="math inline">\(\lceil{n/2^{h+1}}\rceil\)</span> 个元素。根节点所处高度为0。</li></ul><p>根据这条性质，运行时间可以刻画为 <span class="math display">\[\begin{aligned}T(n)&amp;=\sum_{h=0}^{\lfloor\log_{2}n\rfloor}\lceil{n/2^{h+1}}\rceil*O(h)\\&amp;=O(n\sum_{h=0}^{\lfloor\log_{2}n\rfloor}\frac{h}{2^h})\end{aligned}\\\begin{aligned}\because&amp;\sum_{k=0}^{\infty}kx^k=\frac{x}{(1-x)^2}(|x|\le1)\\\therefore&amp;\sum_{h=0}^{\infty}\frac{h}{2^h}=\frac{1/2}{(1-\frac{1}{2})^2}=2\end{aligned}\]</span></p><p>将其带入可得 <span class="math display">\[\begin{aligned}T(n)&amp;=O(n\sum_{h=0}^{\infty}\frac{h}{2^h})\\&amp;=O(n)\end{aligned}\]</span> 由此可得出结论，heapify可以在线性时间内将一个数组转换成一个堆。</p><h2 id="其他方法">其他方法</h2><ul><li>sift_up：与sift_down相反，当节点i的值大于其母节点的值，而其他节点均满足堆的性质时，通过此过程将节点i不断上移，直到满足堆的性质。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sift_up(A, i):</span><br><span class="line">    <span class="keyword">while</span> i&gt;<span class="number">1</span> <span class="keyword">and</span> A[parent(i)] &lt; A[i]:</span><br><span class="line">        exchange A[parent(i)] <span class="keyword">with</span> A[i]</span><br><span class="line">        i = parent(i)</span><br></pre></td></tr></table></figure><ul><li>increase_key：当堆中某个节点的值变大时，可能大于其母节点，与上述情况相同。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">increase_key(A, i):</span><br><span class="line">    sift_up(A, i)</span><br></pre></td></tr></table></figure><ul><li>decrease_key：与sift_down的情况相同。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decrease_key(A, i):</span><br><span class="line">    sift_down(A, i)</span><br></pre></td></tr></table></figure><ul><li>replace：更新后的值大于原来的值，调用increase_key；小于原来的值，调用decrease_key。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">replace(A, i, x):</span><br><span class="line">    <span class="keyword">if</span> A[i] &lt; x:</span><br><span class="line">        increase_key(A, i)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> A[i] &gt; x:</span><br><span class="line">        decrease_key(A, i)</span><br></pre></td></tr></table></figure><ul><li>append：先添加一个值为无穷小的元素到堆的末尾，然后调用increase_key修改值。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">append(A, x):</span><br><span class="line">    A.heap_size = A.heap_size + <span class="number">1</span></span><br><span class="line">    A[A.heap_size - <span class="number">1</span>] = -inf</span><br><span class="line">    increase_key(A, A.heap_size - <span class="number">1</span>, x)</span><br></pre></td></tr></table></figure><hr><ul><li>peek：第一个元素就是堆顶元素，直接返回即可。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">peek():</span><br><span class="line">    <span class="keyword">return</span> A[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><ul><li>pop：将堆顶元素保存，然后用最后一个元素替换堆顶元素，删除最后一个元素。此时堆顶元素可能违背堆的性质，对其调用sift_down。或者调用decrease_key将堆顶元素的值减小到最后一个元素值，两者调用的过程时一样的。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pop():</span><br><span class="line">    r = A[<span class="number">0</span>]</span><br><span class="line">    A[<span class="number">0</span>] = A[A.lenght - <span class="number">1</span>]</span><br><span class="line">    A.heap_size = A.heap_size - <span class="number">1</span></span><br><span class="line">    sift_down(A, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure><ul><li>delete：与pop过程相同，pop就是特殊的delete过程。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">delete(A, i):</span><br><span class="line">    A[i] = A[A.lenght - <span class="number">1</span>]</span><br><span class="line">    A.heap_size = A.heap_size - <span class="number">1</span></span><br><span class="line">    sift_down(A, i)</span><br></pre></td></tr></table></figure><hr><ul><li>merge：逐次调用append添加另一个堆中的元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">merge(A, o):</span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> o:</span><br><span class="line">        append(A, e)</span><br></pre></td></tr></table></figure><ul><li>meld：取出两个堆中的元素，合并成新的列表，调用heapify创建堆。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meld(A, B, C):</span><br><span class="line">    C = A + B</span><br><span class="line">    heapify(C)</span><br></pre></td></tr></table></figure><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parent</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="string">"""计算元素i的母节点位置"""</span></span><br><span class="line">    <span class="keyword">return</span> math.floor((i - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">left_child</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="string">"""计算元素i的左孩子节点位置"""</span></span><br><span class="line">    <span class="keyword">return</span> (i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">right_child</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="string">"""计算元素i的右孩子节点位置"""</span></span><br><span class="line">    <span class="keyword">return</span> (i &lt;&lt; <span class="number">1</span>) + <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(a, i, j)</span>:</span></span><br><span class="line">    <span class="string">"""交换元素i和j的值"""</span></span><br><span class="line">    a[i], a[j] = a[j], a[i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heap</span>:</span></span><br><span class="line">    <span class="string">"""最小堆"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回堆顶元素"""</span></span><br><span class="line">        <span class="keyword">return</span> self.value[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""删除并返回堆顶元素"""</span></span><br><span class="line">        <span class="keyword">if</span> self.size() &gt; <span class="number">1</span>:  <span class="comment"># 堆中元素多于2个时，pop()之后需要调整堆</span></span><br><span class="line">            m = self.value[<span class="number">0</span>]</span><br><span class="line">            self.value[<span class="number">0</span>] = self.value.pop(self.size() - <span class="number">1</span>)  <span class="comment"># 将堆尾元素移动到堆顶</span></span><br><span class="line">            self.sift_down(<span class="number">0</span>)  <span class="comment"># 调整堆</span></span><br><span class="line">            <span class="keyword">return</span> m</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 堆中元素少于2个时，直接调用list的pop()方法</span></span><br><span class="line">            <span class="keyword">return</span> self.value.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""添加元素"""</span></span><br><span class="line">        self.value.append(x)</span><br><span class="line">        self.decrease_key(self.size() - <span class="number">1</span>, x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replace</span><span class="params">(self, i, x)</span>:</span></span><br><span class="line">        <span class="string">"""替换元素的值，替换堆顶元素时指定i=0"""</span></span><br><span class="line">        <span class="keyword">if</span> self.value[i] &lt; x:</span><br><span class="line">            self.increase_key(i, x)</span><br><span class="line">        <span class="keyword">elif</span> self.value[i] &gt; x:</span><br><span class="line">            self.decrease_key(i, x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heapify</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""建堆"""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(parent(self.size() - <span class="number">1</span>), <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            self.sift_down(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="string">"""合并堆"""</span></span><br><span class="line">        self.value.extend(other)</span><br><span class="line">        self.heapify()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回堆的大小"""</span></span><br><span class="line">        <span class="keyword">return</span> len(self.value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""判断是否是空堆"""</span></span><br><span class="line">        <span class="keyword">return</span> self.size() == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increase_key</span><span class="params">(self, i, x)</span>:</span></span><br><span class="line">        <span class="string">"""增加元素的值"""</span></span><br><span class="line">        self.value[i] = x</span><br><span class="line">        self.sift_down(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decrease_key</span><span class="params">(self, i, x)</span>:</span></span><br><span class="line">        <span class="string">"""减小元素的值"""</span></span><br><span class="line">        self.value[i] = x</span><br><span class="line">        self.sift_up(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="string">"""删除元素"""</span></span><br><span class="line">        last = self.value.pop(self.size() - <span class="number">1</span>)  <span class="comment"># pop堆尾元素</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; self.size():  <span class="comment"># 防止删除堆中唯一元素时越界</span></span><br><span class="line">            self.decrease_key(i, last)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sift_up</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="string">"""上滤，将元素放到正确位置"""</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> self.value[parent(i)] &gt; self.value[i]:</span><br><span class="line">            exchange(self.value, parent(i), i)</span><br><span class="line">            i = parent(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sift_down</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="string">"""下滤，将元素放到正确位置"""</span></span><br><span class="line">        l, r = left_child(i), right_child(i)</span><br><span class="line">        <span class="keyword">if</span> l &lt; self.size() <span class="keyword">and</span> self.value[l] &lt; self.value[i]:</span><br><span class="line">            smallest = l</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            smallest = i</span><br><span class="line">        <span class="keyword">if</span> r &lt; self.size() <span class="keyword">and</span> self.value[r] &lt; self.value[smallest]:</span><br><span class="line">            smallest = r</span><br><span class="line">        <span class="keyword">if</span> smallest != i:</span><br><span class="line">            exchange(self.value, i, smallest)</span><br><span class="line">            self.sift_down(smallest)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span><span class="params">(Heap)</span>:</span></span><br><span class="line">    <span class="string">"""最大堆"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.append(x)</span><br><span class="line">        self.increase_key(self.size() - <span class="number">1</span>, x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increase_key</span><span class="params">(self, i, x)</span>:</span></span><br><span class="line">        self.value[i] = x</span><br><span class="line">        self.sift_up(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decrease_key</span><span class="params">(self, i, x)</span>:</span></span><br><span class="line">        self.value[i] = x</span><br><span class="line">        self.sift_down(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sift_down</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        l, r = left_child(i), right_child(i)</span><br><span class="line">        <span class="keyword">if</span> l &lt; self.size() <span class="keyword">and</span> self.value[l] &gt; self.value[i]:</span><br><span class="line">            largest = l</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            largest = i</span><br><span class="line">        <span class="keyword">if</span> r &lt; self.size() <span class="keyword">and</span> self.value[r] &gt; self.value[largest]:</span><br><span class="line">            largest = r</span><br><span class="line">        <span class="keyword">if</span> largest != i:</span><br><span class="line">            exchange(self.value, i, largest)</span><br><span class="line">            self.sift_down(largest)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sift_up</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> self.value[self.value.parent(i)] &lt; self.value[i]:</span><br><span class="line">            exchange(self.value, parent(i), i)</span><br><span class="line">            i = parent(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    min_heap = Heap([<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">7</span>])</span><br><span class="line">    min_heap.heapify()</span><br><span class="line">    print(<span class="string">'min heap'</span>, min_heap.value)</span><br><span class="line"></span><br><span class="line">    max_heap = MaxHeap([<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">7</span>])</span><br><span class="line">    max_heap.heapify()</span><br><span class="line">    print(<span class="string">'max heap'</span>, max_heap.value)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min heap [1, 2, 3, 4, 7, 9, 10, 14, 8, 16]</span><br><span class="line">max heap [16, 14, 10, 8, 7, 9, 3, 2, 4, 1]</span><br></pre></td></tr></table></figure><h1 id="应用">应用</h1><ul><li>堆排序</li><li>优先队列</li></ul><h1 id="堆排序">堆排序</h1><p>堆排序（Heapsort）是一种比较排序算法。堆排序在1964年首次被<a href="https://en.wikipedia.org/wiki/J._W._J._Williams" target="_blank" rel="noopener">J. W. J. Williams</a>提出，同时也是堆这种数据结构首次出现。堆排序是一种原址（In-place）、非稳定（NOT stable）排序算法。</p><p>堆排序可以看作是选择排序的优化版本。堆排序与选择排序类似，将数组分成两个部分，未排序部分和已排序部分。算法每次从未排序部分提取最大值放入已排序部分，当未排序部分为空时，排序结束。</p><p>选择排序通过一次数组遍历（时间复杂度<span class="math inline">\(\Theta(n)\)</span>获取最大值。而堆排序通过堆这种数据结构快速获取最大值。获取的时间复杂度是<span class="math inline">\(\Theta(1)\)</span>，但获取之后要花费<span class="math inline">\(\Theta(\lg{n})\)</span>时间调整堆，因此总运行时间为<span class="math inline">\(\Theta(1)+\Theta(\lg{n})=\Theta(\lg{n})\)</span>。由此可以看出堆排序相比于选择排序改进的点。</p><p>下面是一幅关于堆排序的示意图（出自<a href="https://en.wikipedia.org/wiki/Heapsort" title="Heapsort" target="_blank" rel="noopener">维基百科</a>）。</p><p><img data-src="/uploads/posts/introduction-to-algorithms/sorting-heapsort-anim.gif" title="堆排序动态示意图"></p><h2 id="实现-1">实现</h2><p>有了堆和堆支持的一些基础操作后，可定义堆排序的过程如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">heapsort(A):</span><br><span class="line">    heapify(A)                         <span class="comment"># Build a max heap with array A</span></span><br><span class="line">    <span class="keyword">for</span> i=A.length<span class="number">-1</span> downto <span class="number">1</span>:</span><br><span class="line">        exchange A[<span class="number">0</span>] <span class="keyword">with</span> A[i]</span><br><span class="line">        A.heap_size = A.heap_size - <span class="number">1</span></span><br><span class="line">        sift_down(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>在关于堆的介绍中，所有在heap.data中的数都被认为是堆中的元素，但是堆排序算法为了节省空间被设计成原址算法，heap.data中需要同时存储堆（未排序部分）和非堆（已排序部分），因此需要做点小修改，保证size()函数返回堆的边界，当超出边界时，即使存在对应数据也不被认为是堆中元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size():</span><br><span class="line">    <span class="keyword">return</span> heap_size</span><br></pre></td></tr></table></figure><p>堆排序的运行时间分为两部分，建堆的时间O(n)和n-1次调整堆的时间 <span class="math inline">\(O(\lg{n})\)</span>。所以总的运行时间是</p><p><span class="math inline">\(T(n)=O(n)+(n-1)O(\lg{n})=O(n\lg{n})\)</span>。</p><h2 id="代码-1">代码</h2><p>继承并重写了堆的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> data_structure.heap <span class="keyword">import</span> MaxHeap</span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> heapify, heappop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min_heap_sort</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="string">"""heap sort implemented by using heapq. NOT an in-place algorithm"""</span></span><br><span class="line">    heap = a[:]</span><br><span class="line">    heapify(heap)</span><br><span class="line">    <span class="keyword">return</span> [heappop(heap) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(heap))]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span><span class="params">(MaxHeap)</span>:</span></span><br><span class="line">    <span class="string">"""基于最大堆的堆排序实现，它是原址排序"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, a)</span>:</span></span><br><span class="line">        MaxHeap.__init__(self, a)</span><br><span class="line">        self.heap_size = len(a)  <span class="comment"># 增加heap_size变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""重写方法"""</span></span><br><span class="line">        <span class="keyword">return</span> self.heap_size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""排序过程主体"""</span></span><br><span class="line">        self.heapify()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.size() - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            self.value[<span class="number">0</span>], self.value[i] = self.value[i], self.value[<span class="number">0</span>]</span><br><span class="line">            self.heap_size -= <span class="number">1</span></span><br><span class="line">            self.sift_down(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    h = HeapSort([<span class="number">16</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line">    h.heap_sort()</span><br><span class="line">    print(h.value)</span><br><span class="line"></span><br><span class="line">    print(min_heap_sort([<span class="number">16</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]))</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 7, 8, 9, 10, 14, 16]</span><br><span class="line">[1, 2, 3, 4, 7, 8, 9, 10, 14, 16]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduction To Algorithms </tag>
            
            <tag> data structures </tag>
            
            <tag> binary tree </tag>
            
            <tag> heap </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
